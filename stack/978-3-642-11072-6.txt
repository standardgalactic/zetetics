
 
 
 
 
 
 
 
 
G. Lolli 
Recursion Theory 
and Computational Complexity
Lectures given at 
Centro Internazionale Matematico Estivo (C.I.M.E.), 
held in Bressanone (Bolzano), Italy, 
June 14-23, 1979 
( d.)
E
a Summer School of the

C.I.M.E. Foundation 
c/o Dipartimento di Matematica “U. Dini” 
Viale Morgagni n. 67/a 
50134 Firenze 
Italy 
cime@math.unifi.it  
 
 
 
 
 
ISBN 978-3-642-1 0
 
e-ISBN: 978-3-642-1 0
DOI:10.1007/978-3-642-1 0
Springer Heidelberg Dordrecht London New York 
 
 
 
 
 
©Springer-Verlag Berlin Heidelberg 2010 
st
 
With kind permission of C.I.M.E. 
 
 
 
Printed on acid-free paper 
 
Springer.com 
1 71-9
1 72-6
Reprint of the 1 ed. C.I.M.E., Ed. Liguori, Napoli & Birkhäuser 1981 
1 72-6

C O N  T E N T S  
S . 
HOMER 
: Admissible Recursion 'Iheory 
Pag. 
7 
B. E. 
JACOBS : Computational Complexity and 
recursion theory 
Pag. 
31 
D. 
NORMANN 
: A Survey of Set Recursion 
Pag. 
101 
G.E. 
SACKS 
: P r i o r i t y  Arguments in Higgler 
Recursion 
Pag. 
109 
R.I. 
SOARE 
: Constructions i n  the Recursively 
Enumerable Degrees 
Pag. 
172 
W. MAASS 
: Recursively Invariant 
Recursion meory 
Pag. 
229 

CEN TRO I N  TERNAZIONALE MATEMATICO ESTIVO 
(c.I.M.E. 1 
ADMISSIBLE RECURSION THEORY 
STEVE HOMER 

ADMISSIBLE RECURSION THEORY 
Steve Homer 
DePaul University 
INTRODUCTION 
The purpose of these lectures is to develop some deeper re- 
sults in a-recursion theory which will hold in somewhat more 
general setting than L(a) and in particular in many other admiss- 
ible sets and structures. In addition, I will briefly mention 
some applications to structures which arise from other areas of 
recursion theory and which are inadmissible. 
An important underlying idea behind many of these theorems 
is the notion of a dynamic argument. In general what is meant 
by this is the following: In w-recursion theory, the starting 
point for all of these generalizations, the exceedingly strong 
closure properties of w are used in almost every construction, 
often without a second glance. Almost any operation on finite 
sets yields a finite set and in particular the image of a finite 
set under any function is finite. Uhen we consider a-recursion 
theory, a C1-admissible, we of course loose a great deal of 
the closure present in w-recursion theory. However we still 
have a certain weak closure property - the image of an a-finite 
set under a C (L 1 function is a-finite. But as soon as we do a 
I a 
construction in which a C (La) (or C (L ) . . . .) function arises, 
3 a 

and such does occur in almost every priority argument, then we 
immediately run into trouble. (We will see a concrete example of 
this shortly when we start talking about Post's problem in this 
setting. 
While we have lost the strong closure properties in L(a) 
we have gained the use of much work in set theory, mainly by 
~ o d e l  
and Jensen, in which many deep properties of L have been 
developed. 
It is just these properties of L which often save us 
when we run into trouble because of a lack of closure under cer- 
tain functions. 
Now some properties of L work, under suitable conditions, in 
other settings, while others are really peculiar to L. 
In part- 
icular many of the deeper results about L depend 
on taking 
Skolem hulls of certain sets in L(a), taking the tranitive col- 
lapse of that Skolem hull, and being able to determine exactly 
what that transitive collapse looks like, namely, an initial 
segment of L(a) (an L (y) for some ~ ( a ) .  
These collapsing arguments tend to be very specific to L and 
almost never work in other settings. In particular, they fail 
when the universe is changed by constructing L relative to a 
given predicate. So, to get constructions to work in more gen- 
eral settings, we need to eliminate, if at all possible, these 
collapsing arguments peculiar to L. 
We want to give a "dynamicn 
argument (basically more similar to the original one for w), 
which views r.e. sets is being listed and increasing in an 
effective manner, not as being defined by a El-formula which is 
really the crucial property making collapsing arguments work. 
In order to make this more explicit I want now to turn to a 

couple of concrete examples. Both examples depend upon the same 
method and so the second will be given in much less detail. 
After presenting these examples I will indicate some extensions 
and applications of these results to other areas and in parti- 
cular to admissible sets and structures. We will also, and of 
course this is the reason these methods were first developed, 
gain some knowledge of the structure of a-r.e. degrees. 
In what follows I am assuming a familiarity with the 
basic facts and definitions of a-recursion theory. These are 
given in the first of Sacks' lectures in this volume. For a 
more detailed account see the papers by simpsonpg or ~hore(141. 
1. Post's Problem for a-Recursion Theory 
Let o be a C1-admissible ordinal. We want to prove the 
following theorem. 
Theorem: There exists two a-r.e. sets which are incomparable 
with respect to < . This theorem was originally proved by Sacks 
-a 
and Simpson 1111. Their argument depended heavily on using 
properties of Skolem hulls in L. 
I will present another way of proving this theorem based 
largely on ideas of R. ~horeb41 , (161 . Shore's ideas were 
applied to this problem by Simpson t191 The proof is more 
dynamic, more "constructive" if you will, than the original 
proof and, as we will see, is more adaptable to other settings. 
It is not so dependent on the special properities of initial 
segments of L. 
The argument will be presented by starting out with the 
basic ideas for solving Post's problem from w-recursion theory. 

I assume some familiarity with that argument. As we try to 
carry out the argument in the setting of L(a) we will meet with 
various difficulties for which we will propose solutions. Fin- 
ally, we will put all of this together to get the actual con- 
struction and proof. 
Now, we are going to construct two a-r.e. sets A and B. 
We require that A g a B  and BfaA. 
In fact we will construct them 
to satisfy the stronger incomparability, A dWaB and B &,,A. 
That is, for each e e L(a), we want to ensure that 
A : {elA + B 
S e 
and 
A bit of notation is necessary here. 
Requirements of the 
B 
form ~ f t  
are called A-requirements, requirements of the form Se 
are B-requirements. In these requirements we are identifying a 
set C with its characteristic function, 
For any set CSa, we let F = a-C. 
In the construction of A and 
B we let A
'
 
(Ba) = set of elements enumerated in A (B) by stage 
a. 
Finally let A" 
= 
A ~ ,  
B<' 
= U B6. 
6<a 
6<a 
The method used to satisfy the above requirements is the 
A 
same as for U-recursion theory. Consider (el # B. 
At various 
stages of the construction it will appear that we can use A to 
to enumerate E. That is, at a stage a we will see that 
- 
(e]ti%O for some x which is in B". 
We would like to put x into 
Bar insuring that ~ ( x )  
= 1, and at the same time try to keep 
A< a 
the computation {el 
(x) = 0 correct. This computations uses 

- 
a-finite subsets of A'' 
and A
'
'
 
and so we try to keep the u- 
- 
finite subset of A
'
'
 
from intersecting A. 
B 
Of course, we do the same for requirements {e'l # A. 
For 
such requirements we try to keep elements out of B and to put 
them into A,so they tend to conflict with the A-requirements. 
Such conflicts ariseinclassical recursion theory as well and 
are resolved by giving priority to a requirement s over a 
B 
requirement Set if, say, e 2 el. 
If we do this, an inductive 
argument then proves that each requirement is eventually acted 
upon successfully. In addition, for any e, there is a stage of 
the construction by which any action taken on behalf of require- 
ments sA or sB , where eO, el < e, has already been taken. 
In 
0 
1 
other words all activity on behalf of such requirements has al- 
ready settled down. 
This gives rise to the first major problem in doing this 
argument for a. 
The function taking the eth requirement to the 
first stage at which it has settled down is C2(L(a)) and so we 
can't use the admissibility to get a bound on the activity of 
the requirement. 
For example, lets look at the particular admissible ordinal 
a = 
It could be that 5: does not stop acting until after 
I 
I 
A 
stage 
S: 
until after stage A1, the S1 until after stage 
x2, 
etc. If this were the case then there might be no stage 
A 
past which the requirements, is never injured, there being no 
bound on the activity of the first ,-many requirements. 

Picture: 
requirements 
stages past which 
requirements have 
settled down 
The problem is that our priority listing of requirements is too 
long. If we just list our requirements in the usual, most 
B 
straightforward way, 6, 
s t ,  4, s:, 
S$, ..... 8, 
e set --, e<a, 
an initial segment of this list may never settle down.* 
Shore devised the following method to avoid this problem. 
Note that requirements of the same kind do not conflict. We 
take advantage of this trivial fact by arranging our require- 
ments in groups or blocks, each block containing requirements 
In fact it can be shown that this problem is avoided for this 
particular a. 
However for many admissible a this is the crucial 
problem. 

of the same type. We essentially treat each block as a 
A 
B 
B 
single requirement. So we will have blocks Ro, Ro, R;, 
R1.. . 
B 
where R
:
 
is a block of A-requirements, Re a block of B-require- 
ments. Each block consists of lots of requirements but as 
they don't conflict we give each requirement the same priority. 
By doing this we can, for troublesome a, get away with less 
than a-many priorities and blocks and so will be able to 
bound the activity of an initial segment of blocks, even 
though the function giving this bound is 5 (L(a) 1. 
How short do we need to make the list of blocks? Short 
enough so that no 5 function from an initial segment of the 
list of blocks to a is unbouriddd. 
Definition: Let A = Z, 
cf(a) = least 
5 a such that the there 
is an 
f:B+a, f % ( L ( a ) )  and range(f) unbounded in a. 
We will make the list of blocks have length A, thus ensuring 
the above property. 
Now this takes care of part of the problem as there are 
now not too many blocks. Within each block, requirements 
don't conflict. We need to make sure that no block is too 
large so that we can find a stage at which all activity in 
a given block has settled down. Let's look at the very first 
block. The requirements in this block, since they have the 
highest priority, are all acted upon once at most. 
The set 
of requirements which are acted upon is a-r.e.. 
If we could 
ensure that this set is a-finite, we could then conclude there 
is a stage past which no requirement in the first block is 
acted upon. How can we do this? Make the block bounded 
below a*, for any a-r.e. set bounded below a* is a-finite. 

(For a proof see Devlin 131 
or Sacks' lectures in this 
volume.) 
To accomplish this we will use a projection 
1-1 
p: a --+a* 
to enumerate our requirements in a list of length 
a*. Our blocks will then be subsets of a*. 
We have one more problem to surmount. We would like to 
divide a* into C 2cf(a) many blocks. We could divide a* into 
C 2cf (a*) many blocks, where C 2 ~ f  
(a*) = least B 5 a such that 
there is an f: (3 + a*, f C (L (a) 
) and range (f) unbounded in 
a*, but this could be too many blocks. The following crucial 
lemma says that this cannot happen. 
Lemma: C2cf (a) = C 2 ~ f  
(a*). 
Proof (simpson 1191 ) : 
1- 1 
Let p: a + 
a* be a-rec. 
Using the admissibility of 
u ~t is straightforward to show that if X S a  is unbounded then 
Pm 
is unbounded in a*. 
NOW let 6 < a, g: 6- 
be C 
(L(a) ) with range (g) 
unbounded in a. 
The peg: 6---* 
is 
C2 (L (a) ) and by the 
above fact, range(pog) is unbounded in a*. 
So Z2cf(a*) 5 
C2cf (a) . 
Conversely let h: y - ~ *  be C 
(L (a) ) and range (h) 
unbounded in a*. 
Define k: y--4-a 
by, for v < y, 
k is C (L (a) 
) and range (k) is unbounded in a. 
SO c p f  
(a) 5 C2cf (a*). 

2. 
The Construction and Proof 
Using the above lemma we can now put all of our consid- 
erations together and give the blocking construct-ion. 
Let H: A = C 2cf (a) = C2cf (a*) -4 a* be a C2 ( ~ ( a )  
) function. 
Without loss of generality we can assume, 
1. 
~ ( 0 )  
2 H(1) 2 . . . < H(y) 5 . . . < a* and 
- 
2. 
H ( 0  = yy6~(y)r 
for any limit ordinal 6. 
For details of this and other properties of the blocking 
function H and its approximation see Simpson rl91 . 
Using the above H function we can now say precisely what 
our blocks R
:
,
 
R ,  4, R . . . of requirements will be. 
A 
A
A
A
 
A 
Ro = SO, S1, S2, . . . , Se, . . . 
e < H(0) 
B
 B
B
 
B
 
Ro = So, S1, . . . , Se, . . . 
e < H(1) 
A 
A 
A 
R
:
 
* So, S,, . . . , Sen . . . 
e < H(2) 
B 
B
B
 
B
 
R2 = So, S1, . . . , SeI . . . 
e < H(3) 
The picture is: 
We will now give the construction of the a-r.e. 
sets 

A and B. 
In this construction three "details" are left out. 
These require some care but tend to obscure the proof so I 
will briefly describe them here and leave them to you. 
1. 
It is convenient to keep the witnesses x for different 
requirements disjoint and necessary to make sure we have an 
endless supply of them. To do this, break a up into a-many 
disjoint a-rec. sets, each unbounded in a. Assign one such 
set to each requirement in each block. The witnesses for 
a requirement are constrained to come from the associated set. 
2. 
Since H is E *(L(a)) we cannot effectively calculate its 
value. Instead we approximate H with an a-rec. function G. 
G has the property that when restricted to an initial segment 
of A, G equals H on all but initial segment of stages. We 
will refer to H in the construction but keep in mind that 
what we really do is calculate values of G, a "nice" approx- 
imation to H. 
1 - 1 
3. Using the a-rec. projection p: a -+- a* we can assume 
that the requirements are enumerated via ordinals less than 
B 
a*. So from now on we assume we have requirements <, Se 
where e < a*. 
Of course many of these requirements are 
undefined but all of the original requirements are contained 
in this enumeration. 
The construction takes place in a-many stages. Initially 
0 
AO = B = 8. 
Stage a: 
Step 1: For each odd v < A proceed as follows. Find 
the least e < H(v) and the least x < o in the witness set 
for S
:
 
such that 

A 
1. 
There is no requirement for Se. 
2. 
B<'(x) 
= 0 = {ela (XI. 
3. 
x is not being kept out of B for some requirement in an 
earlier block. That is, a requirement in some block deter- 
mined by H ( v '  ) where v '  < v. 
If no such e and x exist do nothing and proceed with 
step 2. 
Otherwise put x in B
'
 
and create a negative requirement 
keeping out of A all elements of A" 
used in the computation 
of {elf:x) 
= 0. 
If x is contained in any negative require- 
ment on B that requirement is destroyed. 
Step 2: 
Do the same as in step 1 only for even v  < X 
interchanging the roles of A and B. 
The following claim is the main ingredient in showing 
that the construction works. 
Claim 1: For each v  < A there is a stage a. 
such that all 
activity on all blocks 2 v  has ceased. i.e. At no stage 
past a. 
is any requirement in any block 5 v  injured or acted 
upon. 
Proof: By induction on v < A. 
Case 1: 
v  = 0 
The proof here is the same as in the successor case 2. 
Case 2: 
v  = v '  + 1 
By induction there is a stage a such that by stage a 
1 
1 
all blocks up to and including v '  have settled down. Then 
past stage al 
no requirement in block v  can be injured. 
Consider the set I = {ele < H ( v )  and for some a2 1 alr 

A 
Se is acted upon a't stage up} (Without loss of generality 
we are assuming here that v is odd.) 
I is a-r.e. and 
I "(v) 
< a*, hence I is a-infinite. 
Define f: I ---+ 
a by 
f (el = least a (st is acted upon at stage 0). 
Then 
f [a is bounded by the desired stage ao. 
Case 3: 
v a limit ordinal 
Define g: u 4 a by, for y < v, g (y) = least a (block 
y has settled down by stage a), Then g is C (L (a) ) and SO 
since v < A ,  g rv] is bounded by the desired stage oo. 
__I 
We can now prove the theorem. 
Claim 2: 
A f waB and B 1 waA. 
Proof: We will show A f waB. 
Assume not, then A = {elB for some e < a*. 
Let v < A be the 
least even ordinal such that e < H(v). Let uo be a stage 
past which all blocks 5 v have settled down. Then there is 
an x < u0 in the witness set for sB as a v-requirement and 
< 5 
a stage al > X, u0 such that {elB (XI = A<',(X) 
= 0. 
AS 
O1 
x > ao, x is not in any negative requirement for A of higher 
priority and x jf A. 
So at stage ul either x is put into 
~'1, contradicting x # A or there is a requirement for 
B 
S 
present at stage al and hence never injured, insuring 
e 
that {elB f A. 
+ 

3. The Splitting Theorem 
The blocking method described in the previous sections was 
first developed by Shore to prove the following generalization of 
Sacks' splitting theorem. 
Theorem (Shore C163 : 
Let C and D be regular a-r.e. sets with 
D not a-recursive. Then there exists a-r.e. sets A and B such 
that ~n B = $, A U  B = C, A ,  c 
D{~A 
and D&B. 
All of the usual corollaries of the splittinq theorem 
concerning Turing degrees are true for a-degrees as a conse- 
quence of this theorem. For instance below any non-zero 
a-r.e. degree there are two incomparable a-r.e. degrees. 
We have already encountered in our proof of Post's problem 
all of the major obstacles to provinu Shore's splitting theorem. 
This being so I will constrain myself to briefly mentionins 
the main ideas of the proof. 
The requirements which we satisfy are of three types: 
s:: 
{elA f D 
s:: 
{elB f D 
R : x E C + X E A U B  
As usual we construct A and B in a-many stages. To 
satisfy S
:
 
we follow Sacks' original strategy of trying to 
preserve the equality {elA = D on lonsek and longer initial 
segments of a. The idea here is that if we succeed in pre- 
serving eauality all the way up to a then we could compute D 
a-recursively. Since D is not a-recursive this can't happen, 
but if {elA = D we could show that the preservation up to a 
A 
would succeed. So Se must be satisfied. S: 
is handled 
similarly. To satisfy R we insist that when an ordinal x 

appears in the a-recursive enumeration of C at some stage of 
the construction, it is immediately put into exactly one of A 
or B. 
Such an x is put into A or B so as to preserve the 
highest priority negative requirements on A or B which contains 
x. These negative requirements are created for A and B as a 
B 
result of action taken for S
:
 
and Se. 
The construction is carried out just as in the above proof 
B 
of Post's problem. 
As there, the requirements sA and Se 
e 
are enumerated via ordinals less than a* and a* is divided 
into C2cf(a)-many blocks. The stages of the construction are 
carried out just as for the previous proof. Of course, action 
on behalf of the various requirements is different as de- 
scribed above. 
The proof that the construction works is also very similar 
to that of Post's problem. As before an inductive argument 
is necessary to show that every block eventually settles down. 
Once this is shown the various properties of A and B are easily 
shown. For a more detailed and precise account of this argument 
see Shorerl41 or 1161. 
4. 
Applications 
The arguments we have discussed so far have been refined 
and applied to several other areas of recursion theory. The 
major area we will consider is admissible sets and structures, 
but before doing this I want to look briefly at two other 
places where these methods have been of use. 
The first of these is Kleene recursion in an object of 
finite type. For the relevant definitions see Sacks' article 

in this volume or Kleene r9J. 
Harrington 1 7 1  was able to apply 
the results of a-recursion theory to solve a particular version 
of Post's problem for higher types. In order to do this 
Harrington used the following strong solution to Post's-problem 
for a-recursion theory. 
Theorem (Shore h7)): 
There exists a pair of integers m,n 
such that for a11 B and a where (L~KB], 
r ,  B) is admissible, 
m and n are indices for a-B-r.e, hyperregular sets such that 
neither is a-B-recursive in the other. 
The proof of this theorem is a refinement and extension 
of the blocking proof presented earlier. In particular, extra 
requirements are necessary to make sure the sets constructed 
are hyperregular. To make the construction uniform the para- 
meters used in the construction, a* and E2cf (a) , cannot be 
used outright but must be "guessed at", that is approximated, 
during the construction. 
Harrington's version of Post's problem considers reduction 
procedures which allow subconstructive parameters. These para- 
meters are essentially ordinals which arise from computations 
in an object of type n + 2 with type n - 1, that is sub- 
individual, parameters. Harrington 171 shows that there are 
two r.e. sets of subconstructive ordinals which are incomparable 
with respect to the above reducibility. 
The proof proceeds by reducing PosC1s problem in the above 
setting to Post's problem for an admissible structure of the 
form < L ~  187, E ,  8) 
and then applying Shore' s result. 
Recently, a strong version of Post's problem for higher types 
has been proved by Sacks. The blocking method is also an 

ingredient of his proof. For a more detailed discussion of 
this see Sacks' article in this volume. 
A second area of application for these methods has been 
to B-recursion theory where B is a weakly admissible ordinal 
(that is Zlcf(B) 2 B*). 
Post's problem was originally solved 
for weakly admissible ordinals 6 by Sy Friedman 147 . 
Friedman's proof was very close to the above argument for 
a-recursion theory. The one important difference is that 
requirements have to be added to insure that the two sets 
constructed are tamely-0-r.e.. 
The splitting theorem works 
similarly in this case, (see Homer MI. It should be noted 
that the admissible collapse of Maass 501 can be used to get 
these results directly from the corresponding results of 
a-recursion theory. 
Admissible Sets 
In this section I want to present the axioms for admissible 
sets due to Kripke and Platek. Models for these axioms were 
envisioned as structures within which to do recursion theory. 
As such, it is natural to try to determine the solution to 
Post's problem in various admissible sets. In particular, it 
would be interesting to see if there are certain necessary and 
sufficient conditions for Post's problem to have a positive 
solution in an admissible set. Before addressing this 
question we need to briefly investigate How much recursion 
theory can be developed in these structures. For an in-depth 
look at admissible sets see Barwise r21. 
Definition: An admissible set A is a transitive set satisfying 
1. 
union: x E A - 
UX E A 

2. pairing: x,y E A - 
{x,yl E A  
3. AO-comprehension: If 4 (x) is any A0 formula, 
VaJb)/x(x c b - 
x E a 4 #(XI). 
4. 
b0-bounding: if ((x,y) is any A0 formula, (Vx3y((xIy))-r 
(\ds3tVx E ~
3
y
 
E ~('$(xIY))). 
There are many stronger forms of comprehension and bounding 
which are provable from these axioms. We now state one of 
these in order to relate these axioms to the replacement 
principle of a-recursion theory. 
Theorem (C1-replacement): If A is admissible, a E A  and f is 
Zl(A) then ffa is an element of A. 
Hence we see that the same replacement principle is present 
in both a-recursion theory and the theory of admissible sets. 
The hope is that by studying this theory we will gain some 
understanding of exactly what properties are most important 
to carry out various recursion theoretic arguments. Studying 
admissible sets allows us to try to apply our methods to 
structures other than L(a) without giving up the strong closure 
properties provided by admissibility. 
Typical examples of admissible sets are the collection 
of hereditarily finite sets, sets of hereditary cardinality 
less than K ,  for any cardinal K ,  and models of ZF. The 
following definition links up the notions of admissible set 
and admissible ordinal. 
Definition: Let A be admissible. Then I A ~  = ordinal height of 
A = least a(a is an ordinal and a / A). 
Claim: a is an admissible ordinal iff a = I A l  for some admis- 
- 
sible set A. 

Sketch of proof: Assume a is an admissible ordinal. Since 
then L(a) satisfies C1-replacement it is easy to check that 
L (a) satisfies the axioms for an admissible set and I L  (a) 
1 = a. 
Conversely assume a = I A ~  for some admissible A. 
Now carry 
out the construction of L(a) within A. 
By absoluteness, this 
is the real L(a) and by Z1-replacement in A, L(a) satisfies 
C -replacement. So a is an admissible ordinal. 
1 
--i 
We now turn to exploring recursion theory on admissible 
sets. 
Definition: Let A be admissible. 
1. 
B 5 A is A-r.e. if B is E1(A). 
2. 
B S A  is A-rec. if B is A1(A). 
3. 
B 
A is A-finite if B E A. 
Theorem (Enumeration Theorem): There is a universal A-r.e. 
relation W(x,y) such that, if Wa = { y l ~  W(a,y)), Wa ranges 
over all A-r;e. sets as a ranges over A. 
Corollary: There is a non-A-recursive, A-r.e. set. 
The above two facts are about as far as we can go without 
any additional assumptions on the admissible set. 
In particular, 
there is no hope of a positive solution to Post's problem for 
all admissible sets as the following theorem of Harrington 
shows. 
Theorem (Harington 171): 
There exists an admissible set A in 
which every A-r.e. set is A ~ ( A )  
or zl-complete. 
There are a couple of interesting open problems associated 
with this result. The admissible set which Harrington con- 
: 
structs has height a2. 
Tt is not known if Post's problem can fail in an admissible 

set of height 
or in one which is locally countable. 
Some even simpler properties of r.e. sets in classical 
recursion theory are not provable in arbitrary admissible 
sets. For example, consider the following property of r.e. 
sets. 
Separations for r.e. sets: For any disjoint r.e. sets A and 
B there is a recursive C with A 
C and B 0 C = /. 
Picture: 
The separation property fails for r.e. sets. That is there 
are r.e. sets A. 
and Bo such that there is no recursive set 
C with A 5 C, B n C = #. 
Even this property of r.e. sets is 
not true in every admissible set. 
Theorem (Harington 171) : There exists an admissible set A 
in which separation for A-r.e. sets holds. 
In fact Abramson Ll] has shown that such an admissible set can 
have height any countable admissible ordinal. 
One reason that many of the important arguments from 
w-recursion theory fail to work in an arbitrary admissible set 
is that an admissible set may lack a definable wellordering. 
It is just such a wellordering which enables the dynamic 
approach to all of these arguments to succeed. Without it 
there is no canonical way of carrying out an effective 

inductive construction as is done in priority arguments. Even 
a simple selection theorem, as is necessary to prove elemen- 
tary principles like non-separation for r.e. sets, cannot 
be proved for admissible sets without wellorderings. 
Something like the following notion is necessary. 
Definition: An admissible set A with I A ~  = a has a recursive 
wellordering if there is an A-recursive bijection from a onto 
A. 
Theorem: If A has a recursive wellordering then Post's 
problem has a positive solution for A. 
Proof: For such an admissible set all of the machinery 
developed in sections 1 and 2 can be brought to bear. 
Essentially the same proof that was given there can be carried 
out for an admissible set with a recursive wellordering. 
Actually a slightly weaker property than a recursive 
wellordering will suffice to give a positive solution to 
Post's problem for an admissible set A. 
Simpson 
calls 
a many-one A-recursive projection from A to I A I  whose levels 
are a-finite a thin prewellorderinq. He notes that the 
argument in [ld can be used to show that an admissible set 
with a thin prewellordering yields a positive solution to 
Post's problem. 
The general problem of giving necessary and sufficient 
conditions for a positive solution to Post's problem is wide 
open. It would be most interesting to be able to find such 
conditions for an admissible set or an admissible structure. 

Bibliography 
Abramson, F., C1-Separation, to appear in JSL. 
Barwise, J., Admissible Sets and Structures, Springer, 1975. 
Devlin, K.J., 
Aspects of Constructibility, Springer 
Lecture Notes 8354, 1973. 
Friedman, S.D., Recursion on Inadmissable Ordinals, 
Ph.D. Thesis, M.I.T., 
1976. 
Friedman, S.D., 
@-Recursion Theory, to appear, Transactions 
AMS . 
Harrington, L., Contributions to recursion theory in higher 
types, Ph.D. Thesis, M.I.T., 
1973. 
Harrington, L., An Admissible Set with no Intermediate 
El-Degrees, to appear. 
Homer, S.E., 
Priority Arguments in 0-Recursion Theory, 
Ph.D. Thesis, M.I.T., 
1978. 
Kleene, S.C., 
Recursive functionals and quantifiers of 
finite type I and 11, TAMS 91, 1959 and 1963. 
Maass, W., Contributaions to a- and 0-Recursion Theory, 
Habilitationschrift, University of Munich, 1977. 
Sacks,. G.E. and Simpson, S.G., The a-Finite Injury 
Method, Ann. Math. Logic 4, 1972. 
Sacks, G.E., 
Post's problem, absoluteness and recursion 
in finite types, 1978 Kleene Symposium volume, to appear. 
Sacks, G.E., 
Three theorems on recursive enumerability in 
a finite type object, to appear. 
Shore, R., a-recursion theory, in: Barwise, editor, 
Handbook of Mathematical Logic, North Holland, 1977. 
Shore, R., Priority Arguments in a-Recursion Theory, 
Ph.D. Thesis, M.I.T., 
1972. 
Shore, R., Splitting an a-R.E. Set, TAMS 204, 1975. 
Shore, R., XnSets which are An Incomparable, JSL 39, 1974. 
Simpson, S.G., 
Short course on admissible recursion theory, 
in: Fenstod, Gandy and Sacks, editors, Generalized 
Recursion Theory 11, North Holland, 1977. 

19. Simpson, S.G., Degree Theory on Admissible Ordinals, in: 
Fenstad and Hinman editors, Generalized Recursion Theory 
I, North Holland, 1974. 
20. Simpson, S.G., 
Post's Problem for Admissible Sets, 
in: Fenstad and Hinman editors, Generalized Recursion 
Theory I, North Holland, 1974. 

CENTRO INTERNAZIONALE MATEMATICO ESTIVO 
(c.I.M.E.) 
COMPUTATIONAL COMPLEX1 TY AND RECURSION THEORY 
BARRY E. JACOBS 

COMPUTATIONAL COMPLEXITY AND RECURSION THEORY 
Barry E. Jacobs 
University of Maryland 
Department of Computer Science 
College Park, Maryland 20742 
Contents 
0. 
Introduction 
1. Abstract Computational Complexity Measures 
2. 
Blum-Rabin, Compression and Speedup Theorems 
3. Complexity Classes 
4. 
Speedable and Nonspeedable Sets 
5. 
Generalizations 
References 
0. 
Introduction 
A general axiomatic approach to computational complexity 
was formulated by Blum 111. His work was greatly influenced by 
the work of Rabin 1231 and served to generalize to all complex- 
ity measures, results derived by Hartmanis and Sterns 181 for 
Turing machine computation times. The speed-up theorem, due to 
Blum, was probably most responsible for attracting great interest 
into the area. Since then abstract or axiomatic complexity 
theory has seen a great deal of activity. This paper represents 
a survey of some of the major products of that research. 
An outline of this paper is as follows. 
In Section 1 we introduce the notion of an abstract 

computational complexity measure first considered by Rabin 
and later by Blum. Examples of complexity measures are given 
as well as examples of measures that fail to satisfy Blum's 
axioms. Several easy results are shown. Namely, that recursive 
increasing functions applied to the step counters of a measure 
produce new measures. Recursive relations exist between step 
counting functions across different measures (for the same 
partial recursive functions). 
In any measure, arbitrarily hard 
to compute 
recursive functions exist. Although there is no 
recursive way to bound the complexity of a function by its 
output, the opposite does hold. We conclude Section 1 with some 
results that relate the complexity of a computation and its 
subcomputations . 
In Section 2 we prove results essentialy due to M. Blum. 
The first, called the Blum Theorem, tells us that in any complex- 
ity measure, 
arbitrarily hard to compute partial recursive 
functions exist. The second is Blum's Compression Theorem 
which tells us how'heasure~sets of functions serving as complex- 
ity bounds (on classes of recursive functions) can be effectively 
increased to produce larger bounds. The third result of Section 
2 is Blum's well-known Speed-up Theorem. This tells us that in 
any measure recursive functions exist which have no best 
algorithm. 
In Section 3 we consider classes of recursive functions 
whose step-counting functions are bounded by a recursive func- 
tion. Such collections are called comptexity cZasses. We first 
prove results that tell us when we may effectively increase a 
complexity class to include more functions. We then consider 
Borodin's Gap Theorem which tells us that there are very few 

step-counting functions compared to the recursive functions. The 
McCreight-Meyer Union Theorem tells us that for certain sequences 
of functions bounding complexity classes, a recursive function 
exists whose complexity class is precisely the union of these 
classes. The case in which classes are bounded by primitive 
recursive functions is given as an illustration. Section 3 is 
concluded with the Meyer-Moll-McCreight Honesty or Naming Theorem. 
This tells us that for any sequence of partial recursive func- 
tions a "measured" sequence can be generated so that none of the 
complexity classes defined by the former are lost. 
In Section 4 we explore some close interaction between 
computational complexity and pure recursion theory. We consider 
classes of sets called speedable and nonspeedable and their 
relation to various classes of recursively enumerable sets. 
Soare's index set characterization is proven for nonspeedable 
sets. That is, an r.e.-set A is nonspeedable precisely when the 
set of r.e. indices of sets not contained in A is Turing reduc- 
ible to 0'. 
This is used to prove Marque's result that every 
r.e. Turing degree contains a nonspeedable set. It is also used 
to show that the Turing degrees containing speedable sets are 
precisely the high ones (i.e. its Turing jump is On). 
We 
conclude Section 4 with a discussion of speedable sets and their 
relation to well-studied classes of r.e. sets. In particular, we 
see that every maximal r.e. set is speedable. 
In Section 5 we consider an infinitary ahlogue to Blum 
complexity theory called a-complexity theory. Specifically, we 
examine the generalization of the Blum axioms in Kripke-Platek 
admissible recursion theory. Several analogues to important 
results of ordinary complexity theory are formulated and proven; 

namely, the a-Blum, a-Rabin, and a-Gap Theorems. We conclude 
Section 5 with a discussion of those results of the o-theory 
that have been shown to generalize to the admissible case. 
1. Abstract Computational Complexity Measures 
In this section we introduce the notion of an abstract 
computational complexity measure first introduced by Rabin I231 
and later greatly exploited by Blum Ill. 
Several illustrations 
of complexity measures are given as well as examples of measures 
that do not satisfy the defining axioms. For the remainder of 
the section we prove same relatively easy results about computa- 
tional complexity measures demonstrating the power of the theory. 
We begin by showing that any recursive increasing function 
applied to all the step-counters in a complexity measure always 
yields another canplexity measure. 
We then show that recursive 
relations exist between complexities of corresponding algo- 
rithms in two different measures. That is, "easy to computew 
functions in one measure are "easy to compute" in another meaeure 
We next show that in any complexity measure, arbitrarily hard to 
compute recursive functions always exist. This result is extend- 
ed to the case of 0-1 valued functions or predicates yielding 
the fact that there is no recursive way of bounding the complex- 
ity of a function from its output. However, the converse does 
hold,namely, that one can recursively bound an output by the 
complexity of a computation. We conclude the section with tech- 
nical lemmas that relate the complexity of a computation with 
the complexities of subcomputations. 
Definition. An abstract computationat comptexity measure @ 
(or simply a comptexity measure) is an enumeration of the partial 

recursive f d c t i o n s  
1 e < u3 
t o  which are associated the p a r t i a l  recursive step-counting 
functions 
COe 1 e < wl 
f o r  which t h e  following axioms hold: 
(1) $, (x) is defined on a given x i f f  Oe (XI is defined; 
(2) the 
predicate 
is recursive. 
W e  s h a l l  also assume that the s: 
and Universal Function 
Theorems (Davis 15 1 ) hold for the enumerations { +e I e < w 1. 
W e  also assume t h a t  given any index e, both the function $, , in 
the form of an algorithm "em, and its step-counter 
Oe may be 
effectively retrieved. 
W e  i l l u s t r a t e  the notion of complexity measure with several 
examples. 
(1) Let $e be the p a r t i a l  recursive function (of one argu- 
ment) computed by the Turing machine with Godel number e. Let 
Oe(x) be the number of steps taken t o  compute $,(XI by machine 
"e". 
Clearly, the sequences 
{Oel 
constitute a complexity 
measure. 
(2) 
L e t  
cpe 
be the same a s  i n  (1). Let 
Oe (x) be the 
number of squares used by "en in the computation on x with the 
proviso t h a t  i f  +e (XI 
4 then Oe (XI t . The sequences { $e 1, I Qe 1 
also constitute a complexity measure. 
(3) L e t  4, 
be the primitive recursive function computed by 

the equations with Godel number e and Oe 
the number of recur- 
sions i n  "em. Such does not constitute a complexity measure 
since t h e  schema are not capable of capturing a l l  partial recur- 
sive functions. 
(4) 
L e t  9, be the same as i n  (1)- Let @,(XI be defined by 
0 
i f  $=(x)t 
Qe ("1 ' t otherwise 
This doesn't constitute a complexity m e a s u r e  since the predicate 
M(e,x,y) * @,(x) = y is not recursive. (Its recursiveness would 
imply the recursive solvability of the halting problem.) 
For the remainder of this section we present several results 
relatively easily obtainable from the definition of complexity 
measures. 
(The author is not certain who are t h e  individuals t o  
be credited for these results. 
However, most of them can be 
found i n  the survey a r t i c l e  by Hartmanis and Hopcroft [71.) 
W e  f i r s t  see that a recursive increasing function applied 
t o  step-counting functions yields step-countinv functions. 
1.1 Theorem, 
L e t  O be a complexity measure with enumeration 
I+,) and step-counting functions {(Pel. L e t  f ( y )  be a recursive 
function such that f ( y )  2 y. 
Then if oOe) is a set of step- 
counting functions f o r  {$,). 
Proof. 
For (11, since f is recursive 
fo9 (XI+ i f f  @,(XI + 
i f f  $e(xl t . 
For (2) , let 
0 i f  f o @,(XI 
= y 
M(e,x,~) = 
1 i f  f 0 @,(XI # y 

Since f ( y )  2 y, we check t o  see i f  there is a w 5 y such t h a t  
Qe(x) = W. 
This can be done recursively since the search is 
bounded and {ae) s a t i s f i e s  (2). 
If no such w is found, 
M(e,x,y) = 1. I f  such a w is found, then the value of M(e,x,y) 
is 0 i f  f(w) = y; otherwise, it is 1. 
W e  next show t h a t  we can find a recursive relation between 
the complexities of corresponding algorithms i n  two complexity 
measures. This tells us t h a t  functions that are "easy t o  compute" 
i n  one measure are "easy t o  compute" i n  a l l  measures. 
L e t  @, i be two complexity measures such that {(,I. 
{ie) 
h 
are t h e i r  corresponding enumerations. W e  c a l l  Q and @ 
paratZel 
A 
i f  for all e < w, 
$Ie 
Z $Ie. 
h 
1.2 
Theorem. 
L e t  @ and @ be two parallel complexity measures. 
Then there exists a recursive function r such t h a t  for a l l  e < w 
and 
for a l l  but a f i n i t e  set of x. 
Proof. 
Let 
A 
c(x,y) = {e / e 5 x & Pe(x) = Y v ae(x) = Y). 
Then our desired function r is defined a s  
1 0 ,  
otherwise 
Clearly, r is a recursive function. 
W e  check to see t h a t  r s a t i s f i e s  the conditions. Let x 
e 
and suppose $ (x) is defined. Then 

~ ( x , Q ~  
(XI ) = max{ 
max 
{ae, (XI 1, 
max 
1 5 ~ .  
(XI 1 )  
e 'EC(x, Qe (x) 1 
e'EC(x,ae (x) 1 
Since x 2 e, the index e was one of those indices checked in 
the computation of r(x,ee(xf) 
it follows that 
If Qe (x) is undefined then both l e f t  and right sides are 
undefined and the relation holds* It follows that the desired 
inequality holds everywhere, but i n  the bounded s e t  Ixlx < e1.O 
We next show that for any complexity measure, given an 
arbitrary recursive function f ,  there exists another recursive 
4 such that any way of computing $ takes more than f steps on 
an i n f i n i t e  s e t  of inputs. 
1.3 Theorem (Rabin [23 1 ) . L e t  9 be a complexity measure and f 
a recursive function. 
Then there exists a recursive function 
such that for any index e of $ (in Q) 
Qe (XI > f (x) 
on an infinite s e t  of x. 
Proof. 
Define the recursive function $ by 
l o 
otherwise 
where 
cnl(x) s (XI> = x is some standard pairing function. 
' 2 
It follows from the definition of complexity measure and the 
recurs$veness of f that $ is recursive. 
To see 4 satisfies the theorem, assume there exists some 
index e for 4 and a y 
s u c h t h a t  f o r a l l  x ,  
x > Y  

oe (x) 5 f (x) . L e t  z be . 
y such t h a t  nl (2) = e. Hence, for 
t h i s  z 
since (be (2) ( f (z) by the clefinition of $. 
But nl (2) = e, hence 
and since 4e is total, t h i s  i u  a contradiction. 
In Section 2 we w i l l  prove the following: 
1.4 
Theorem (Rabin E231). 
Let O be a complexity measure and f 
a recursive function. 
Then there exists a recursive 0-1 valued 
function such t h a t  f o r  any index e for $ 
for a l l  but a f i n i t e  set of x. 
W e  w i l l  prove Theorem 1.4 i n  a more general form (i.e., f 
p a r t i a l  recursive instead of f recursive). 
One may intuitively feel t h a t  the s i z e  of an output indi- 
cates the complexity of the computation required t o  obtain t h a t  
output. Theorem 1.5 tells us t h a t  we cannot recursively bound 
the complexity of a computation by its output. 
1.5 Theorem. 
Let 
be a complexity measure. 
Then there does 
not e x i s t  a recursive function k such t h a t  for each e 
k ( ~ , $ ,  (XI 1 ) Qe(x) 
for a l l  but a f i n i t e  set of x. 
Proof. 
Suppose such a recursive k exists. Then the 
complexity of any 0-1 valued recursive Ge must s a t i s f y  

for a l l  but a f i n i t e  set of x. 
Clearly, k(x,O) + k(x,l) is 
recursive. 
Hence, by Theorem 1.4 there is a 0-1 valued recursive 
$ such t h a t  f o r  any index e f o r  $I 
for a l l  but a f i n i t e  set of x. 
Formulas (1) and (2) yield an 
obvious contradiction. 
Although Theorem 1.5 tells us that we cannot recursively 
bound the complexity of a computation by its output, our next 
result shows t h a t  the opposite does hold. 
Namely, t h a t  we may 
recursively bound the value of a computation by its complexity. 
1.6 
Theorem. 
L e t  4 be a complexity measure. 
Then there e x i s t s  
a recursive function h such t h a t  for each e 
for a l l  but a f i n i t e  s e t  of x. 
Proof. 
Define the auxiliary function 
- 
t 
$,(XI i f  Oe(x) = Y 
H(erxry) 
1 
otherwise 
H is evidently recursive. 
The desired function h is defined as 
h(x,y) = max H(e',x.y) . 
e 'LX 
Clearly, h is recursive. 
To see the conditions of the theorem a r e  s a t i s f i e d  suppose 
x 2 e and t h a t  9, (x) is defined. Thus, 
Since x 2 e, it follows t h a t  
max ~ l ( e ' . x , @ ~ ( x ) )  
2 @,(XI 
e 'zx 

I f  qe (XI is undefined, then the relation h (x,4,(x) 1 
Oe (XI still 
holds. 
It then follows t h a t  the set f o r  which the relation i n  
the theorem f a i l s  is bounded by e. 
0 
W e  conclude t h i s  section v i t h  several technical lemmas t h a t  
w i l l  be used in a l a t e r  chapter. 
Intuitively, in a single 
complexity measure, when we 'combine1 computations the complex- 
i t y  of the new computation is recursively bounded by the 
complexity of the component computatione. 
1.7 - Lemma (First Combining L8ma). Let O be a complexity 
measure and let C(e,y) be a recursive function such t h a t  i f  
Ge(x) and $el (x) are defined (for a given x ) ,  then so is 
@ ~ ( e , e n )  
(x) also defined. 
Then there is a recursive function h 
such t h a t  
@c(e,el) 
(XI 2 h (x, ae (XI , @e (XI ) 
for a l l  but a f i n i t e  set of x. 
Proof. 
Define the intermediate function 
(XI i f  ee (XI = u and eel (XI = v 
p(e,el ,x,u,v) = 
otherwise 
p is evidently recursive. 
Define the function h by 
h(x,u,v) = 
max 
p(;,;* 
,x,u,v) 
{ Z , 5 ' ~ 1  
h is also recursive. 
To see that h s a t i s f i e s  the desired condi- 
tions, let x 2 e,e8. From the definition of h 
I f  both Qe (XI and Oe , (XI are defined, by hypothesis, so is 

@c (eve' (XI defined. 
Fmm the definition of p and since x 2 e,e' 
Should e i t h e r  Oe (x) o r  Oe, (XI 
be undefined, then the inequality 
holds independently of whether o r  not 
(x) is defined. 
,eS) 
It follows t h a t  the set of a l l  x f o r  which the inequality fails 
is bounded by max Ce,e'l. 
D 
Another form involves a C w h i c h  is a function of a single 
argument. 
1.8 Lemma (Secand Combining Lemma) . Let @ be a complexity 
masure and let C(e) be a recursive function such t h a t  i f  $,(XI 
is defined then 
(XI is defined. 
Then there is a recur- 
sive h such t h a t  
for a l l  but a f i n i t e  set of x. 
Proof. 
Define the function 
- 
@C(e) (XI i f  4, (XI = y 
p(e,x,y) = 
otherwise 
p is evidently recursive, Define the function h a s  
h(x,y) = max 
p(e',x,y) 
Eev(xl 
h is recursive and for any x 2 e, 
(whethel o r  not (0, 
(XI is defined). 
Hence, the set {xi h (x,Be (x) ) 
< @C(e) (XI 1 is bounded by e. 
D 
It should be clear t h a t  Lemmas 1.7 and 1.8 can be general- 

ized t o  any f i n i t e  mnber of arguments. 
We 
prove a last version 
which allows us t o  eliminate the f i r s t  argument of t h e  bounding 
function. 
1.9 
Lemma (Third Combining Lemma). Suppose the same hypothesis 
a s  Lemma 1.8 holds and i n  addition (Pe(x) 2 x for a l l  x. Then 
there is a recursive function h such t h a t  
BC 
(XI 5 h (Oe (XI 
f o r  a l l  but a f i n i t e  set of x. 
Proof. 
Define th@ function 
@C (e) (XI i f  Qe(x) = y 
p(e,x,y) = 
otherwise 
p is evidently recursive. 
Define the function h by 
h(y) = 
max 
p(el,x*,y) 
{e*' , x g ~ . )  
h is a l s o  recursive. 
For x 2 e 
h(Qe(x)) = 
max 
~ ( e ' , x * , @ ~ ( x )  
(e' ,x'(ee(x) 1 
Since Oe(x) 2 x 
e, 
max 
p(e' ,x* ,Be (XI 1 
(XI 
{e* ,xm5Qe (x) 1 
It follows t h a t  the set Ex lh (ae (XI ) 
< OC 
(XI 1 is bounded 
by e. 
2. 
Blum-Rabin Compression and Speed-Up Theorems 
In t h i s  section we prove results on t h e  complexity of compu- 
t a t i o n s  t h a t  a r e  basically due t o  M. 
Blum [ l l  . The first r e s u l t ,  
called the Blum Theorem, tells us t h a t  i n  any complexity measure 
there a r e  a r b i t r a r i l y  complex p a r t i a l  recursive functions, i-e., 

functions such that any way of computing them takes more than a 
predetermined partial recursive g almost everywhere- A s  a 
special case we prove Theorem 1.4 of Section 1. 
The second major result is the Blum 
Compression Theorem 
This essentially tells how lneasured'sets 
functions and 
arbitrary step-counting functions are interweaved; i n  particular, 
when the measured collection is a sequence of step-counting 
funotions. 
We conclude Section 2 with a proof of Blum's well 
known Speed-up Theorem. 
W e  proved i n  Theorem 1.3 that for arbitrary complexity 
measure 4 and recursive function 
f there always exists some 
0-1 valued +suchthat any way of computing + takes more than 
f(x) steps or an inEinite set of x. 
W e  next prove that such an 
inequality holds on not just an infinite s e t  but for a l l  but a 
finite set. 
This result is further generalized from recursive 
t o  partial recursive functions. 
2.1 
Theorem (Blum i l l ) .  
L e t  4 be a complexity measure and g a 
partial recursive function. 
Then there corresponds t o  g a 0-1 
valued partial recursive function f ,  with the same domain a s  g, 
such that i f  e is any index f o r  f then 
cOe (XI 2 g(x) 
for a l l  but a finite set of x. 
Assuming that we've proven Theorem 2.1 we have 
2.2 
Corollary (Rabin 1231 1. 
Let 4 be a complexity measure and 
g be a recursive function. 
Then there corresponds t o  g a 0-1 
valued recursive function f such that for any index e for f 

for all but a f i n i t e  set of x. 
Proof. 
L e t  g be recursive. 
By Theorem 2.1 there e x i s t s  a 
p a r t i a l  recursive f such that for any index e for f the set 
{ x ~ @ ~ ( x )  
< g ( x ) )  is finite. 
Since g is recursive and has the 
same domain as f ,  f is also recursive. 
Corollary 2.2 w a s  actually Theorem 1.4 of Section 1 whose 
proof was promised earlier. 
W e  now prove Theorem 2.1. 
Proof. 
The function f w i l l  be defined by a construction 
- 
specified below, 
The construction w i l l  proceed i n  steps s and 
w i l l  be accumulating two sets A and F defined as follows. 
The s e t  A' , a t  stage s, w i l l  be a f i n i t e  collection of 
indices t h a t  have been "cancelled" prior t o  or during stage s. 
The set A<' 
w i l l  denote those cancelled indices just prior t o  
stage s. The set FS w i l l  represent the graph of our desired 
function f collected a t  stage s. The set F<" w i l l  be FS 
just 
prior t o  stage s. 
Construction: 
For an input value k the following construction 
tells us how t o  compute f (k). 
Stage 0: 
B e t  A' 
= F0 = 0. 
Stage s: 
Let x = sl(s) and y = r2(s) where rl,r2 a r e  pairing 
functions. 
I f  @,(XI # y, where g = 0, 
then set AS - A'", 
FS = FCS and 
go t o  stage s+l. 
In t h i s  situation, it is not certain whether 
g(x)S, hence we add nothing t o  A o r  F. 
If 
@,(x) = y then set V = {ele z x  61 Qe(x) < g(x)). In 
t h i s  situation we know g(x1S. 
What we do is to collect i n  V the 
set of indices e which are "eligible for cancellation". 

W e  next ask i f  set V contains any new indices not already 
cancelled: 
I f  A < ~  
= A<' 
U V 
then set A = A<' 
and F' 
= F < ~  
U I<x,l>) 
and go t o  CHECK. In the case where every e l i g i b l e  index has 
already been cancelled we merely set As = A<' 
and assign t o  f (x) 
the value I. 
~f A<' z A<' 
u v then set 
where 8 is either 0 o r  1 but not $=(x) and go t o  CHECK. H e r e  
there is an eligible index which can be cancelled. 
We choose it 
t o  be t h a t  index with t h e  highest priority (smallest) of a l l  the 
eligibles. 
W e  then set f ( x )  t o  either 0 o r  1 but unequal t o  
the value of the function with cancelled index. 
CHECK: 
I f  x = k then output the value 8 and halt, otherwise 
go t o  stage s+l. 
This completes the construction. 
L e t  F 3 U FS 
and define f ( x )  = y * <x,y> E F. 
W e  next 
s 
show t h a t  f s a t i s f i e s  a l l  requirements of the theorem. 
By examining the construction we see f is w e l l  defined, 
dom(f) = dom(g) and has range { O  ,I). 
By the effective nature of 
the construction, f is p a r t i a l  recursive. 
Remark. 
A value f ( k )  for the function defined above is 
dependent on input k and on the index R of g. Hence, it is a 
partial recursive function of two arguments, m(a,k). It 
follows from the s3theorem t h a t  
OS (El (k) = m(E,k) 
f o r  some 

recursive s. 
W e  w i l l  use t h i s  result l a t e r  on i n  t h i s  section. 
W e  complete t h e  proof of the theorem by proving the follow- 
ing * 
Claim. 
Let e be any index for f .  
Then t h e  set 
- 
i x  I Oe(x) < g ( x ) I  is bounded. 
Proof. 
Assume the contrary. 
That ie, f o r  some index e for 
- 
f t h e  set {xlOe(x) : 
g(x) 3 is infinite. 
Then there w i l l  be a 
stage so past which no index smaller than e w i l l  ever be 
cancelled. 
Since {xi Oe (XI < g (x) 1 is i n f i n i t e ,  it must have a 
member x' > so . Since x' is i n  the s e t ,  @,(x1), hence Oa(x') is 
defined. Furthermore, by a basic property of pairing functions 
S1 = < X I  ,aQ (x') > 2 X' > So 
F r m t h e  d e t a i l s  of the construction e i t h e r  
(a) 
A t  stage sl , e is added t o  A 
o r  
(b) A t  stage 2, 
s2 < sl, e is added t o  A. 
In e i t h e r  case, there e x i s t s  a stage k * <2,3> a t  which e is 
added t o  A. 
By the construction, <;, 
B"> is added t o  F a t  ;. 
However, 6 was chosen s o  t h a t  
+ $, (2) contradicting t h e  
assumption that f 
@e. 
0 
Definition. 
A sequence of functions {ye) is said t o  be 
reoursivety enumerabte i f  the function t ( e , x )  = ye(x) is p a r t i a l  
recursive. 
A sequence of functions {ye) which is recursively 
enumerable and f o r  which we can recursively decide f o r  a l l  e,x,y 
whether ye(x) = y is called a measured s e t  of functions. 
By our assumptions, the step-counting functions {ae) of any 
complexity measure forms a measured s e t  of functions. 
2.3 
Lemma. 
Let {ye) be a measured set of functions and l e t  O 
be a complexity measure, 
Then there e x i s t s  a recursive r such 

t h a t  
Proof. 
By the definition of a measured s e t  t h e  predicate 
M' (e,x,y) * ye (x) = y is recursive. 
Hence, the function 
f (e,xl = min iM' (e,x,yl I is p a r t i a l  recursive. By the .:-theorem 
Y 
there is a recursive s such t h a t  $r(e) (x) = f (e,x) = ye(x). 
Our next r e s u l t  r e l a t e s  measured s e t s  and complexity 
measures. 
It t e l l s  us t h a t  i f  {ye] is measured, 
ye E {ye}, 
@ 
is a complexity measure and h 
a recursive function, 
t h a t  there 
e x i s t s  a p a r t i a l  recursive function f with an index !Z such t h a t  
for a l l  but a f i n i t e  set 
Hence, there is some algorithm f o r  f whose complexity is 
compressed between h (x, ye ( x )  ) and ye (x) . 
2.4 
Theorem (Blum [ I ] ) .  Let {y 1 be a measured s e t  and @ a 
e 
complexity measure. 
Then there e x i s t s  a recursive h and f o r  
each p a r t i a l  recursive y there is a 0-1 valued p a r t i a l  recur- 
e 
sive function f with the same domain a s  ye such t h a t  
(1) I f  e' is any index f o r  f then ye(x) < Qe, (x) for a l l  but a 
f i n i t e  set of x, 
(2) there e x i s t s  an index e* for f such t h a t  
@,* (x) < h(xIye(x)) f o r  a l l  but a f i n i t e  s e t  of x, 
and 
( 3 )  there e x i s t s  a recursive function t such t h a t  f o r  each ye, 
e* = t ( e )  s a t i s f i e s  ( 2 ) .  
Proof. 
By Lemma 2.3 there is a recursive function r such 
t h a t  ye = $ r  (e) ' Let s be the recursive function whose exis- 
tence w a s  introduced i n  the remark i n  the proof of Theorem 2.1. 
W e  w i l l  see t h a t  the function f corresponding t o  ye is precisely 


algorithm. 
The proof t h a t  follows is t h a t  of Young 
1301. 
2.4 
Theorem 
(Blum [ l l ) .  For any recursive function r(x,y) 
there e x i s t s  a 0-1 valued recursive f such t h a t  f o r  any index e 
for f there e x i s t s  another index e '  such t h a t  
@,(XI > r (x,Qe, (XI 1 
for a l l  but a f i n i t e  set of x. 
Proof. 
A recursive function w i l l  be defined i n  terms of a 
construction given below. 
The construction w i l l  depend on four 
parameters 
u,v,ll and x and w i l l  proceed in stages. 
A s  t h e  
construction runs we w i l l  be accumulating two s e t s  ARuv and FRuv 
S 
The set AQuv a t  stage s w i l l  serve a s  a f i n i t e  collection 
of indices which have been cancelled p r i o r  t o  o r  during stage s. 
The s e t  
w i l l  consist of those indices cancelled just p r i o r  
t o  stage a. 
Set F:, 
w i l l  consist of the graph of t h e  desired 
<s 
function accumulated by stage s. 
The s e t  Ftuv contains members 
of F
;
~
~
 
entered p r i o r  t o  stage s. 
Definition. 
A set B is a f i n i t e  function i f  B is t h e  
graph of a f i n i t e  function with domain an* i n i t i a l  segment of w. 
L e t  { G ~ }  
denote some canonical enumeration of a l l  f i n i t e  func- 
tions. 
I n  addition, let {Ke) denote some canonical enumeration 
of the f i n i t e  subsets of w. 
The construction t h a t  nW follows w i l l  compute a function 
value f o r  argument x. 
The r e s u l t  a l s o  ddpends on three other 
parameters 
u, v and a. 
Construction 
0 
0 
Stage 0 :  
Set AQuv f FQuv = 8 .  
Stage s: 
I f  s E dom(G, 
) (where rl is a pairing function), 
1 

then set 
<s 
Afuv = A ~ U V  
and go t o  CHECK. 
We 
check 
t o  see i f  the nl(v)-th f i n i t e  function w i l l  give 
us a value on s. 
I f  so, we use it i n  obtaining the value f o r  
the constructed function. 
Otherwise 
(2) 
Compute the s e t  
V is t h e  s e t  of a l l  indices e eligible for cancetlation 
a t  stage s. 
We w i l l  see below t h a t  for a l l  s,v,x,u 
and a particular R, 
the conditions i n  the s e t  may be recursively checked. 
We next check t o  see i f  there a r e  any new indices i n  V not 
previously cancelled. 
( 3 )  I f  
# A;& 
U V 
then we compute e' = min {EEV 6 E$!A;:~} 
e 
W e  then s e t  
and 
S 
e u v  = Fkuv u {<s,9>1 
where 
Here we have found indices which are e l i g i b l e  f o r  cancellation 
and which were never cancelled. 
W e  cancel t h e  smallest 

(highest priority) by placing ft into 
W e  then assign t o  
our constructed function a value making it different from the 
function whose index was cancelled. 
W e  then 
go to CHECK. 
4 1 
If A;& 
= 
U V 
then re set 
0 
A:, 
Iluv 
and go t o  CHECK. 
Here we cannot cancel any index. 
W e  a r b i t r a r i l y  assign the value 
0 t o  our function for argument s. 
CHECK: 
I f  s = x then output 8; otherwise go t o  stage s+l. 
This ends the construction. 
0 
S 
s 
Define AQuv = U AQuv and FQuv = U FQuv . W e  define our 
s 
s 
function fauv as follows. 
(XI = Y * < X I Y >  E FRUV * <x,y> is placed i n t o  FEU, a t  Stage 
QUV 
X. 
It Follows from the d e t a i l s  of the construction that fQuv is 
a 0-1 valued, well defined, p a r t i a l  recursive function. By the 
#-theorem 
f R u v ( ~ )  
= L
!
~
~
 
( L )  (u,v,x) = (s2 ( R , ~ , v )  
( X I  
for recursive s1,s2. By the recursion theorem there is an Ro 
such t h a t  
$ 
(u,v,x) 
= 
OS 
(, 
) (u,v,x) . 
Ro 
1
0
 
The funotion f required by t h e  theorem i s  p r e c i s e t y  
fROo0 
(x) . 
Recall t h a t  fROo0(x) = 
(0,O.x). 
W e  assume without loss 
0 
of generality t h a t  Kn (o) = GT2 (o) = 8. The main computation 
1 

of 4 
(u,v,x) refers to the main body computation and not to any 
&o 
recursive calls which may be produced. 
2.4.1 
C a m .  
For each x and u,v < w, 
fgou,v (XI is defined. 
Proof. By an outer induction on s and an inner induction 
on d = s - u. 
The details are left to the reader. 
U 
2.4.2 
Claim. 
Let u,v,x < w. 
Then in the main computation of 
( u,v,x ) 
no index e ever gets cancelled more than once. 
&o 
proof. Immediate. 
2.4.3 
Claim. Let u < w. 
Then in the main computation of 
4, 
(O,O,x) there is an s > u such that no e < u ever gets cancel- 
0 
u 
cancelled after stage sU. 
Proof. Immediate. 
- 
0 
2.4.4 
Claim. Let u < w and sU be as in Claim 2.4.3. 
Then there 
exists a vU such that 
and 
Kr2 
= {e le is cancelled in computing 4 
for some x<s 
- u 
Proof. Since 4 
(O,O,x)/sU is a finite function, let d be 
&o 
such that G (x) = 
(O,O,x)/su. 
Let Kn = Iele is cancelled in 
du 
0 
u 
computing 4 
(O,O,x) for some x f sU). 
The result follows by 
&o 
taking vU = <dU,nu>- 
2.4.5 
Claim. For all x < w 
Proof. Immediate from the details of the construction and 

the definitions o f  sU and vu. 
2.4.6 
Claim. 
For any index e f o r  f R  00 
0 
for a l l  but a f i n i t e  set of x. 
Proof. 
Suppose otherwise t h a t  t h e  set 
- 
is i n f i n i t e .  
A f t e r  a stage so no index of 
higher p r i o r i t y  
than e g e t s  cancelled during the main computation of f 
ve+l' 
By the d e t a i l s  of the construction, e i t h e r  a t - s t a g e  x > so and 
x € B 
index e is cancelled implying 4, f f 
D 
R0e+l ve+l 
The remainder of t h e  theorem follows immediately from 
Claim 2.4.6 
and the i d e n t i t y  
of Claim 2.4.5. 
3. 
Complexity Classes 
In this section we concentrate on sets of recursive 
functions a l l  of whose step-counters are bounded by a recursive 
function. 
Such sets a r e  called "complexity classes". 
We f i r s t  
consider t h e  problem o f ,  given an algorithm f o r  the bounding 
function, effectively increasing the complexity c l a s s  t o  include 
more functions. 
Several r e s u l t s  a r e  provided which solve t h i s  
problem. 
We next prove the well-known Borodin Gap Theorem. This t e l l s  
us, essentially, t h a t  t h e  stepcounting functions of a complexity 

measure a r e  r e l a t h e l y  sparse compared t o  the s e t  of recursive 
functions. 
We then prove McCreight-Meyer's Union Theorem. 
This t e l l s  us t h a t  whenever an increasing 
sequence of recursive 
functions defines a sequence of complexity classes, there w i l l  be 
a recursive function defining precisely t h e  union of these 
classes. 
A s  an application we see t h a t  the union of complexity 
classes defined by the primitive recursive functions is a complex 
complexity c l a s s  defined by a single recursive function. 
W e  conclude Section 3 with a proof of the Meyer-Moll- 
McCreight 
Honesty o r  Naming Theorem. 
This provides us with a 
means of generating from any sequence of p a r t i a l  recursive 
functions, a measured 
sequence of p a r t i a l  recursive functions. 
Furthermore,: the constructed functions a r e  such t h a t  none of the 
complexity classes named by the f i r s t  set is l o s t .  
Definition. 
For any computational complexity measure a, we 
define for a given recursive function t, t h e  c o m p l e x i t y  c l a s s  
C: 
= {+sl(s 
is t o t a l  & P ( x ) z  t ( x )  f o r  a l l  but a f i n i t e  s e t  of x 
S 
0 
Thus Ct o r  simply Ct , when P is understood, is t h e  set of 
a l l  recursive functions whose complexity is bounded by t f o r  a l l  
but a f i n i t e  s e t  of x. 
Remark. 
The f a c t  t h a t  (s E C 
, does not imply t h a t  Ps'+e 
+ e 
almost everywhere. It only implies t h a t  t h e r e  i s  an i n d e x  k for 
+s, 6, = +k where 
Pk 5 4 1 ~  almost everywhere. 
Without l o s s  of 
generality, we assume throughout t h a t  the correct index is chosen. 
We begin by considering the problem of extending a complex- 
i t y  c l a s s  C 
effectively when given the index e f o r  the bounding 
+e 

function. 
(Again, the author is not certain of the names of 
those responsible for these results and once again points the 
reader t o  the survey by Hartmanis and Hopcroft 171.) 
3.1 
Theorem. 
In any measure 
there e x i s t s  a recursive 
function h such t h a t  for each t o t a l  4, 
there is a corresponding 
@ such t h a t  $ 9 C 
and $ E CAxhlx,ae(x)l. 
$e 
Proof. 
Recall the pairing function wl 
has the property 
- 
that for any s, nl (x) = s for an unbounded set of x. Let 
(x)+l if 4, 
(XI 2 @ e ( ~ )  
$(XI = 
1 
otherwise 
Since +e is t o t a l ,  $ is recursive. 
To see @ 9 C 
, let $ = Os 
and suppose it w e r e  i n  C . 
@ e 
@ e 
Then for sufficiently large x both 4s (x) ( ge (x) and n1 (x) = s. 
By the construction,$ f $,. 
To continue the proof, l e t  $ = $s f o r  some s. Clearly, 
t h i s  s is dependent on e, and furthermore there e x i s t s  a recur- 
recursive C (el such t h a t  bC(,) = . 
By the Second Combining 
(x) < h (x,ee (x) ) for a l l  but 
Lemma 1.8, since $e is t o t a l ,  
(DC 
- 
a f i n i t e  set of x. 
Hence, 
E CAxh(x,ae(x)) . 
0 
I f  
Qe(x) > x then the recursive function h need only 
depend on the value Qe (x) (and not x) . 
3.2 
Theorem. 
In any measure 
there is a recursive function h 
such t h a t  for a l l  t o t a l  4, 
where 
Qe(x) ) X  for a l l  x, there 
exists an $ such t h a t  
$ 
C 
and $ E Ch . 
4 e 
O Q e  
Proof. 
Exactly the same a s  the proof of Theorem 3.1 except 
the Third Combining Lemma 1.9 is used. 

W e  modify the above proof t o  obtain a new complexity c l a s s  
which properly contains the original one. 
'3.3 
Theorem. 
In any measure Q 
there e x i s t s  a recursive 
function R such t h a t  f o r  a l l  t o t a l  me . C 
C C h X R [ X , f ( X ) ~ *  
+ e 
Proof. 
A s  i n  t h e  proof of Theorem 3.1 (and 3.2). we can 
find recursive 
+C (,) 
and h so t h a t  
QC 
(XI ( h(xIQe(x)) f o r  
a l l  but a f i n i t e  set of x where 
9 C . By Theorem 1.6, 
+ e 
we can find a recursive h' such t h a t  h' (x,Qe(x)) 2 
f o r  a l l  
but a f i n i t e  s e t  of x. 
Let R(XIy) = max{h(x,y),h'(x,y)). 
W e  next show C 
c CR(xIQe(X) 
From the above. we s e e  t h a t  
+ e 
f o r  a l l  x 
R[x,Qe(x) 1 = max {htx,Qe (x) ) ,h' (x,Qe(x) ) 1 
> h'(x,Qe(x)) 
- 
By the construction of h' 
> 4, (x) 
- 
f o r  a11 but a f i n i t e  set of x. 
Hence, C 
5 C R I x I Q e ( x ) l .  To see 
me 
the containment is proper observe t h a t  
R[x,Qe(x) I 2 h(xIQe (XI 1 
f o r  a l l  x. 
By our construction 
f o r  a l l  but a f i n i t e  set of x. 
I-Ience. 
E CR[xIQe(x)l* But 
r e c a l l  t h a t  mC 
F ' C  . Hence. C 
c CR[x,Qe(X)I - 
+ e 
e 
I f  Qe(x) > x 
then the recursive function increasing t h e  
complexity c l a s s  defined by +, 
can be made t o  depend only on 
on Qe (x) . 
3.4 
Theorem. 
In any measure Q let 4, 
be a recursive function 

where Qe(x) 2 x f o r  a l l  x. 
Then there is a recursive B such t h a t  
c 
= CR.Qe. 
@ e 
Proof. 
Following the proof of Theorem 3.2, we can find 
recursive functions h and 
s o  t h a t  (PC 
(x) 5 h(@, (x) ) f o r  
a l l  but a f i n i t e  set of x. 
Further, we have t h a t  $C(e) P C  
@ e 
3.4.1 
Claim. 
Let @ be a measure. 
Suppose $e is a recursive 
function such t h a t  @,(XI 2 x f o r  a l l  x. 
Then there e x i s t s  a 
recursive h' such t h a t  for each e h' ((De(x) 1 2 
(x) f o r  a l l  but 
a f i n i t e  set of x. 
Proof. 
Let 
[ x 
i f  ee (x) = Y 
H ( ~ , x , Y )  = 
otherwise 
H is recursive. 
Define h' as h' (y) = 
max 
H(eg,x',y1. 
h' is 
fe' ,x'lyl 
recursive and we show t h a t  t h e  set Ixlh' (Qe ( x ) )  < Oe (x) 1 is 
f i n i t e .  
Let x 2 e. Then 
h'(Oe(xI) = 
max 
H ( e ' , ~ ' , @ ~ ( x )  
) 
I e '  ,x'f" 
,(XI 1 
Since ae (XI I. x 1 e, 
> $,(XI . 
- 
Hence, t h e  s e t  is bounded by e. 
0 
Returning t o  the proof, we define the function 
R(y) = max { h ( y ) , h ' ( y ) l .  A3 i n  the proof of 
Theorem 3.3, 
Our next r e s u l t  is an assertion t h a t  f o r  any complexity 
measure Q 
t h e  step-counting functions (9,) 
a r e  sparse r e l a t i v e  
t o  the recursive functions. 
I n  terms of the previous r e s u l t s ,  
Borodin's Gap Theorem t e l l s  us t h a t  there is no recursive r, 
where r ( x )  > x, t h a t  w i l l  expand every possible complexity class. 

The proof here is that of Young I301. 
3.6 
Theorem (Borodin [ 3 1 ) .  
In any complexity measure Q for any 
recursive function r with r(x) 2 x, for all x, there exists a 
recursive monotonically increasing function t such that 
Proof. Let {Qel be the enumeration of the step counting 
functions of measure Q. We define function t by 
t(0) = 0 
t(x) = max[t(s)+m(s,x,t(s)) Is < XI 
where 
m(s,x,y) = min Ve,,I 
(Qe (XI 5 r(y+m) 
+ (Qe (XI f y+m) 
m 
- 
We first show the function m(s,x,y) is recursive. Clearly, 
the predicate 
is recursive. Thus, it can be tested for m = 0,1,... . Further, 
for fixed s, x and y, there will always be a corresponding m. 
For certainty, there exists an m such that Qe(x) ( y+m for all 
e < s, Qe (x) is 
defined, (Qe (x) > r (y+m), otherwise .) Hence, 
m(s,x,y) is recursive. It follows from its definition that t 
is also recursive (and monotonically increasing). 
We neft show Ct = Crot . Since r(x) 2 x, Ct 5 Grot. Suppose 
4, 
E Crot . Then we know that for some xo > e, Qe (x) 5 rot (x) 
when x > xo. 
But 
= max[t(s) + min 
V 
{(Qe(x) Lr(t(s)+m)) 
m ezs 
+ (oe(x) 5 t(s) + m) 1 I s < XI. 

Thus, for x > x,, 
> e ,  t ( x )  2 Qe(x) making +e E Ct. 
Hence, 
We next show that for any sequence of increasing recursive 
functions, there is a complexity class comprised of the union of 
the classes bounded by functions from the sequence. 
3.7 
Theorem (McCreight-Meyer 1191 . L e t  Q be a complexity 
measure. 
Suppose {fe I e < w )  
is a recursively enumerable s e t  
of recursive functions such t h a t  for each e , e l , x  
for e > el. Then there is a recursive function k(x) such t h a t  
Observe that the function k (x) = fx(x) is greater than fe (x) 
for each e on a l l  but a f i n i t e  set of x. 
For when x 2 e, 
klx) 2 fe (x) . Hence, for each e the s e t  {XI k (x) < fe (x) 
is 
f i n i t e  and we concLude that U C 
Ck. 
e fe 
However, there may e x i s t  some +I for which (1) QI(x) 5 k(x) 
for a l l  but a f i n i t e  set of x, and yet (2) GQ(x) > fe(x) for each 
e on an unbounded s e t  of x. 
This would cause +I t o  be i n  Ck but 
not i n  the union of the C , thus, implying only U C 
C Ck. 
fe 
e 
'e 
The way we avoid t h i s  difficulty is t o  "guess" for each 
and some e that fe(x) 1 QE(x) for a l l  but a f i n i t e  s e t  of x. I f  
we discover that for some x, fe(x) < QI(x), w e  t r y  t o  assign a 
value t o  k(x) which is l e s s  than QQ(x). We also "guessn again 
that for a larger e '  (e' > el t h a t  fe, (x) ) QQ(x) for a l l  but a 
f i n i t e  set. 
I f  
QI is actually i n  u C 
, then there w i l l  be an 
e f e  
eo such t h a t  @&(XI 
f 
(x) for a l l  but a f i n i t e  set. However, 
0 
it w i l l  a l s o  be the case t h a t  f 
(x) 5 k(x) f o r  a l l  but a f i n i t e  
eo 

s e t .  
Hence 
E Ck. 
On t h e  other hand, i f  
is not i n  the 
union of the C 
then f o r  some e, f e  (x) < Q R  (x) f o r  an i n f i n i t e  
e 
s e t .  
This w i l l  force k (x) < 
(x) f o r  an i n f i n i t e  set and hence, 
@a B Ck- 
Proof. 
A recursive function k w i l l  be defined i n  terms of 
a construction given below. 
The construction w i l l  compute k(m) 
f o r  any m. 
Throughout the construction we w i l l  be accumulating 
three s e t s  K, I, and TO 
defined a s  follows. 
The s e t  KS , a t  stage s, 
represents t h e  function k(x) being 
constructed. 
A p a i r  <x,y> is placed i n  KX a t  some stage x i f  and 
only i f  k (x) = y. 
The set IS, a t  stage s, represents encodings 
of p a i r s  <R,k> such t h a t  we have made the guess fk(x) 
QR(x) 
f o r  a l l  but a f i n i t e  s e t .  
A t  stage s there w i l l  be an existence 
no more than 21s guesses. 
The s e t   TO^ a t  stage s, consists of 
encodings of pairs <k,k> f o r  incorrect -"guesses". Sets K < ~ ,  I < ~  
and  TO<^ 
represent 
K ~ ,  I~ and TO", 
respectively, prior to 
Stage s. 
We next define the construction which computes k(m) f o r  any 
m < u. 
The Construction 
Stage 0. 
Set I' = TO' 
= KO = 9. 
Stage s. 
Compute t h e  s e t  V = ( r l r  E 1" 
& r 9 ~
0
'
~
 
& 
W e  search through our list of guesses and choose one of those 
f o r  which we guessed incorrectly. 
I f  V = 9 the set 6 = f s ( s ) ,  K~ = 
U {<s,B>j, 
I' = 1'' 
U {<s,s>) , TO" =  TO<^ and go t o  CHECK; 

Here it seems t h a t  so far we have guessed correctly. We then 
make a new guess t h a t  fs(x) ) QS(x) for a11 but a f i n i t e  set 
and set k ( s )  = f S ( s ) .  
I f  V # $3 then s e t  k = min {r2(r) / r € V) and 
v 5 min {nl(r) 1 r E V & r2(r) = k). 
The value of k is the number with highest p r i o r i t y  such t h a t  the 
value <v,k> represents a wrong guess. 
I f  more than one member 
of 1' 
has a second component k, we choose t h e  one with smallest 
f i r s t  component. 
s e t  ms = TO" 
u {<v,kr), 8 = s
,
 
K'= 
K" 
u {<s,B>I, 
1' = 1" 
U {<v,s>,<s,s>) and go t o  CHECK. 
Here we a r e  s e t t i n g  k (s) = f k ( s ) .  We are a l s o  guessing t h a t  
fs(x) 2 eV(x) and fs(x) 2 Qs(x) for a l l  but a f i n i t e  s e t  of X. 
CHECK: 
I f  s = m then output 8 and h a l t ,  otherwise, go t o  Step 
s t e p  s+l. 
This ends the construction. 
0 
We define the following sets. 
K = U K S ,  
I
s
U
I
 
and 
TO = u TO' . 
s 
8 
s 
S 
Our required function k is defined a s  
3.7.1 
C l a i m .  
k(x) is a well-defined recursive function. 
Proof. 
In order t o  compute k (x) , f o r  any x , we merely 
compute through t h e  x-th stage. 
Clearly, a t  any stage s exactly 
one value is assigned t o  k ( s )  and every stage x can be effective- 
l y  pel'f ormed . 
The remainder of the proof is the demonstration t h a t  Ck=UC . 
e fe 

W e  c a l l  the value d an m-pair i f  s 2 ( d )  = m. 
W e  say t h a t  
an m-pair d is popped a t  s t a g e  s, i f  d is placed i n  TO' 
a t  stage 
8. 
3.7.2 
Claim. 
For each e there is a stage se such t h a t  f o r  a l l  
stages s > s 
i f  an m-pair is popped then m > e. 
e 
Proof. 
Immediate. 
0 
Claim. 
Proof. 
Suppose @ 
E Ck. 
Then we have O (x) 2 k(x) f o r  a l l  
9 
9 
but a f i n i t e  s e t .  
We have t o  show t h a t  there must be an fk where 
where Q (x) 5 fk(x) f o r  a l l  but a f i n i t e  s e t .  
This w i l l  imply 
4 
@g E C 
and @ 
E U C . Suppose not. 
That is, f o r  any k t h e  
*k 
g 
fe 
set D~ = {xlfk(x) < O (x) 1 is i n f i n i t e .  
9 
9 
3.7.4 
Claim. 
The s e t  A 
= { s  l a t  stage s a p a i r  of t h e  form 
9 
<g,s> is put i n t o  1' while another p a i r  <g,R> is put i n t o  TO') 
is i n f i n i t e .  
The proof of C l a i m  3.4.3 follows from Claim 3.7.4. 
For by 
t h e  d e t a i l s  of the construction, i f  t h i s  s e t  is unbounded then 
so is the s e t  { s  1 k ( s )  < Q (s) 1 which contradicts the f a c t  t h a t  
9 
Proof (of Claim 3.7.4). 
Suppose t h a t  t h e  s e t  A is f i n i t e .  
9 
From the d e t a i l s  of the construction 
there must be a stage ko 
s u ~ h t h a t ~ g , k ~ ~ E ~ ~ - T O  
a
n
d
~
~
k
~
*
~
g
,
k
~
~
E
i
~
That is, a f t e r  stage kg , the p a i r  <g,ko> endures. By Claim3.7.2 
there is a stage 
Ska 
such t h a t  no m-pair with m 
having 
higher o r  equal p r i o r i t y  than ko , is ever popped 
a f t e r  stage 
0 
s . By our original assumption the s e t  
D 
5 {xlfk (x)< (Pg(x)l 
ko 
0 
is i n f i n i t e .  Hence, there is an 
s ' E D 
where 
9 

s' > maxisk ,kg). 
By t h e  d e t a i l s  of the construction a t  stage st 
0 
the p a i r  <g,ko> w i l l  be put i n t o  TO". 
But t h i s  contradicts t h e  
f a c t  t h a t  ko bounds a l l  such stages. 
0 
Before proving t h e  second inclusion w e  verify t h e  following. 
3.7.5 
Claim. 
For each e, fe (x) 5 k (x) f o r  a l l  but a f i n i t e  
s e t  of x. 
Proof. 
By Claip 3.7.2, 
there e x i s t s  a stage se such t h a t  
- 
for a l l  stages s > se , i f  an m-pair is popped then m > e. From 
the d e t a i l s  of t h e  construction a t  a l &  stages x > maxfse,e) 
either 
k(x) = fX(x) > fe(x) 
or 
k(x) = fm(x) > fe(x) 
(since m > e) . Hence, t h e  set 
{x. 
f e  (XI > k(x) 1 
is f i n i t e .  
0 
3.7.6 
Claim. u C 
5 Ck. 
a 
f e  
Proof. 
Suppose $ 
€ U C . Then there e x i s t s  an eo such 
Q 
e fe 
and, hence, 
0 
(*I 
QI (XI 2 f 
(XI 
9 
eo 
for a l l  but a f i n i t e  set. It follows from Claim 3.7.5 and (*I 
that O (x) 5 k(x) f o r  a l l  but a f i n i t e  set. Hence, 
'3 
4g E Ck. 
0 
The equality u C 
= Ck follows from Claims 3.7.3 
e < w  fe 
and 3.7.6. 
0 
A s  an application of t h e  Theorem 3.7 
consider the c l a s s  
of primitive recursive functions and the complexity measure @ 
which counts t h e  steps of a single-tape Turing machine. 

3.8.1 
Claim. If g is primitive recursive then there is a primi- 
0 
tive recursive t such that 9 E Ct. 
Proof. By induction on the definition of primitive recur- 
sive g. Details are left to the reader. 
0 
3.8.2. Claim. If t is primitive recursive then C: is made up of 
only primitive recursive functions. 
Proof. It is easy to show that primitive recursive 
functions are sufficient to simulate Turing machines for a 
primitive recursive number of steps. Again, details are left to 
the reader. 
3.8.3 
Claim. There exists a recursively enumerable strictly 
increasing sequence af primitive recursive functions fe 1 such 
that every primitive recursive function is majorized by some fe. 
Proof. Let {g.) be a recursively enumerable sequence of 
1 
all the primitive recursive functions. Let fi(x) be defined by 
fi (x) = max {gl (XI ,g2 (XI,. . . ,gy (XI 1 + 1. 
Then the sequence if.) is a recursively enumerable sequence of 
1 
increasing functions majorizing every primitive recursive 
function. 
U 
3.8 
Theorem. There exists a recursive function t such that 
the set of functions computable on a one-tapeaTuring machine in 
time bound t is exactly the set of primitive recursive 
functions. 
Proof. We first show that the set of primitive recursive 
functions is u C: 
where {fe) is the sequence of Claim 3.8.3. 
e 
e 
Let 4 be primitive recursive to see 
$I 
E U C@ . By Claim 3,8,1 
e fe 

0 
there exists a primitive recursive g such t h a t  $ E Cg. 
By Claim 
3.8.3, 
g < fe for some e; thus, ( E  C: 
and ( E  U C i  . For 
e 
e f e  
the popposite inclusion, by Claim 3.8.3, 
fe is primitive recur- 
sive for a l l  e. 
By Claim 3.8.2, 
c : ~  contains only primitive 
recursive functions; hence, u C' 
ia made up of only primitive 
e f e  
recursive functions. 
0 
Let {fe) be the recursively enumerable s t r i c t l y  increasing 
sequence of Claim 3.8.3. 
By Theorem 3.7 
and the above 
there 
is a recursive t such t h a t  C: - u C' 
= the class of primitive 
e *e 
recursive functions. 
W e  conclude t h i s  section with a proof of the Xeyer- 
McCreight-Moll Honesty o r  Naming Theorem. 
This result t e l l s  us 
that given any sequence of p a r t i a l  recursive functions a 
measured sequence can be constructed so t h a t  none of 
the 
complexity classes of recursive functions are lost. 
3.9 
Theorem (Meyer-3lcCreight-Moll 
[19,21]).Let @ be a complex- 
i t y  measure with p a r t i a l  recursive functions {4e) ; then there 
exists a measured s e t  {gg(,)} naming every complexity class. 
Proof. 
W e  w i l l  give a procedure which for any partial 
recursive Ot produces a p a r t i a l  recursive $g(t) such that 
M(trx,y) * $g(t) (XI 
Y 
is a recursive predicate. That is, the s e t  {$g(tl) w i l l  be a 
measured set of p a r t i a l  recursive functions. 
Our procedure w i l l  
be 
uniform i n  t implying that g is a recursive function. We 
remark t h a t  $g (t) w i l l  not be t o t a l  even i f  $ t . i s  total. We then 
show how t o  obtain a recursive 
g' from g such t h a t  $t t o t a l  
implies 
$g, (t) total. Further, 

w i l l  be recursive and 
C 
= C  
f o r  a l l  et t o t a l  . 
4 t  
$ g ' ( t )  
The construction described below f o r  computing +g(t) (x)' 
makes use of several auxiliary sets. 
The set 0' 
, a t  stage s, 
of the construction, represents a queue i n  which elements a r e  
"popped out" and moved further dawn the queue. 
The elements of 
Q' 
a r e  t r i p l e s .  (actually encodings of t r i p l e s )  . having t h e  form 
<v,e,r>. 
The v represents the p r i o r i t y  of index e; t h a t  is, 
e's r e l a t i v e  position on the queue. 
The value of r is e i t h e r  
1 o r  0 
depending on whether o r  not e is "poppable". 
An index 
e is made poppable when it is discovered t h a t  f o r  some x ,  
Qe(x) > 4t ( X I .  
The index e is l a t e r  popped when an assignment 
t o  4g(t) is made making Qe(x) > $ 
(x) f o r  some x. A t  t h i s  
g (t) 
point 
index e once again becomes unpoppabte. The s e t  TO', 
a t  
stage s, a c t s  os a collection of t r i p l e s  coming from Q" , s'c s, 
which have been discarded. 
Whenever a t r i p l e  of the form 
<v,e,r> is ejected from QS 
it is done s o  by placing it i n t o  TO". 
The s e t  TP', 
a t  stage s, represents the function $ g(t) being 
constructed. 
A p a i r  <x,y> is placed i n t o  TpS a t  stage s i f  and 
only i f  4 
(x) = y. 
Sets 
QCS , TO" 
and TP<' a r e  QS, TO' 
g (t) 
and TP', 
respectively, j u s t  prior t o  stage s. 
W e  next give t h e  procedure f o r  computing $ g(t) (k) f o r  a 
given k . 
Construction 
Stage 0. Set Q' 
= TO' 
= TP' 
= $8. 
Stage s. 
Let b = rl(s) and m = a 2 ( s )  where w1,r2 
a r e  pairing 
functions. 
(We assume t h a t  *2 is increasing i.e. 

x < Y * rZ (XI < n2 ( ~ 1 . 1 .  Next s e t  QS = Q" 
U {<s,s,O>}. 
W e  a r e  
putting index s i n t o  the queue giving it p r i o r i t y  s. 
We a r e  a l s o  
making index s unpoppabZe (zero). 
I f  Qt(b) = m t o  go t o  (2) otherwise, go t o  (3). Here we 
check t o  see i f  at (b) converges. 
(2) 
Set TOs = TO" 
U {<g,e,r>l<g,e,r> E 
- TOS 
& Qe (b) > $t(b) I 
and set 
Q' 
= Q' 
u {<g,e,l>l<g,e,r> E Q' - TO' 
& ae(b) > (t (b) I. 
That is, we make poppabte a l l  those indices e which take more 
than $t(b) steps t o  compute an input b. 
Notice t h a t  i n  making 
an index poppable w e  have t o  e j e c t  the old t r i p l e  putting it 
into TO'. 
(3) I f  <b,8> 9 TP" 
then go t o  (4). 
Otherwise set TP' 
= TP" 
and go t o  stage s + l .  H e r e  it is 
discovered t h a t  $g(t) (b) has already been defined. 
( 4 )  
Let v = min {for some e ,  <v,e,l> E QS - TO' 
& Qe(b) > m 
v<s 
& Vv,,vI 
(<v',el,o> E 
- TO' 
+ pel (b) 
ml I. 
- 
That is, e is the poppable index of highest priority, l e s s  than 
o r  equal t o  s, such t h a t  at2 unpoppable indices of higher 
p r i o r i t y  take no more than m steps on input b. 
Further, index e ,  
i t s e l f ,  takes more than m steps on input b. 
I f  v = 0 then set TpS = T P < ~  
and go t o  stage s+l. Here, no 
such index exists. 
Otherwise, s e t  
e = rnin { ~ v , e , l >  
E 
- TO' 
& ae(b) > m 
e 
& vv'<v 
- [ ( < v 1 , e v , ~ >  
E as - TO') * Qel (bl 5 m11 
e is t h a t  index with p r i o r i t y  v causing a change t o  be made. 
I f  there is more than one such e l i g i b l e  index, e is t h e  smallest 

one. 
Set TpS = TP<' U {<b,m>). That is, $g(t) (b) = m. 
Set TO' 
=  TO<^ U {<v,e,l>l and Q~ = Q' 
U {cs,e,O>). That is, 
pop index e from the queue to the s-th position and make it 
unpoppabZe. 
CHECK: If k g b then halt the procedure and output m, 
otherwise go to stage s+l. 
This ends the construction. 
The function created by the construction was denoted symbol- 
ically as @g(t). We at no point made reference to what g 
represented. Bat it is clear that the function created is a 
partial recursive function 8(t,k) of two arguments. Applying that 
sg-theorem justifies our notation. 
3.9.1 
Claim. {$g(t)) is a measured set. 
Proof. We have to show that 
M(t,x,y) * $g(t) (XI = Y 
is a recursive predicate. From the details of the construction 
it is clear that if I# 
(x) is defined at stage s, then 
g(t) 
s = < x , $ ~ ( ~ )  
(x)>. Hence, to decide if $ 
(x) = y we just run 
g (t) 
the construction until stage <x,y>. 
We next modify g to g' 
so that if $t is total then 
$9' (t) is total, and (2) C 
= C 
. We define 
@t 
@g'(t) 
Og' (t) (XI = min {$g(t) (x) I$t (x) + at (XI 1 
Again, the s:-theorem 
justifies our use of notation. 
3.9.2 
Claim. 
{+g, (t) is a measured set. 

Proof. 
Since {$g(tl 1 is measured it can be recursively 
decided whether o r  not Og (tl (x) = y .  
Since {ae) is measured and 
since qt (x) S * at (x)S, it follows t h a t  we can recursively 
decide i f  + t ( ~ )  + Qt(x) = y. 
I f  e i t h e r  one equals y, we can 
t e s t  t o  see i f  t h e  other is ( y. The r e s u l t  follows. 
0 
It is c l e a r  from t h e  definition o r  $ g1 (t) t h a t  +t t o t a l  
implies $ g' (t) t o t a l .  
Thus what remains t o  be shown, is t h a t  for 
f o r  +t t o t a l ,  C 
= C 
. Since both +t , +gl ( t )  a r e  t o t a l  
@t @g' (t) 
t h i s  reduces t o  showing 
3.9.3 
Claim. 
For $t t o t a l  and any e ,  {xi ae (x) 5 $t (x) 1 f i n i t e  
i f  and only i f  {xlQe (XI > +gl (t) (XI 1 f i n i t e .  
Before proceeding we define some useful terminology regard- 
ing the construction of the function $ g ( t )  ' 
Definition. 
An index e is said t o  be stable i f  there e x i s t s  
e x i s t s  some stage so i n  the construction 
Of +g (t) such t h a t  for 
some g and r E {0,11 (1) <g,e,r> E Q' - TO" 
f o r  a l l  s > so. 
Index e is stable a t  O ( 1 )  i f  t h e  r above is o ( 1 ) .  
We a l s o  say 
t h a t  e becomes stabilized a f t e r  so . 
An index e is said t o  be unstable i f  it is not stable. That 
is, e is unstable i f  f o r  a l l  stages s there e x i s t s  a stage 
s' > s such t h a t  for g,gl and r,rl E {0,11, 
and 
where 
g # g l  o r r # r t .  
For a fixed e an e-triple is a t r i p l e  of t h e  form <g,e,r> 
for some g and r E I0,l). 

3.9.4 
Claim. 
I f  index e is s t a b l e  ( a t  0 o r  1) then there 
e x i s t s  a stage so such t h a t  a f t e r  stage so , 
(1) e has already become stabilized ( a t  0 o r  1 1 ,  and 
(2) 
a l l  indices with higher p r i o r i t y  than e ,  and which 
s t a b i l i z e ,  have done s o  already. 
Proof. 
Immediate. 
0 
3.9.5 
Lemma. 
Let $t be t o t a l .  
Then f o r  any index e i f  e is 
unstable then the s e t s  A = {XI ae(x) > $t (x) ) and 
A' = { ~ l @ ~ ( x )  
> $gl ( t )  (x) 1 a r e  i n f i n i t e .  
Proof. 
Suppose e were unstable. Then by the d e t a i l s  of 
the construction t h e  s e t s  
B = {S I an e-tuple goes from an unpoppable t o  a poppable s t a t e  
a t  stage sl, and 
B1= is I an e-tuple gets popped a t  stage s ) ,  
a r e  both i n f i n i t e .  
Suppose 
A were f i n i t e  t o  obtain a contradic- 
tion. 
Observe s e t  C = {XIS = <x,Qt (x)> E B} 5 A. 
For i f  x E C, 
then a t  stage s = <x,at(x)> an e-tuple goes from an unpoppable 
t o  a poppable s t a t e .  By the d e t a i l s  of t h e  construction, t h i s  
occurs only i f  ae(x) > $ t ( ~ ) .  Hence, x E A. Thus, since C 5 A, 
and A is f i n i t e ,  C is f i n i t e .  
Define the map f (x) = <x,at(x)> t o  see B C f [C]. 
For i f  
s E B, then a t  stage s = <x,at(x)>, an e-tuple goes from an 
unp ppable t o  a poppable s t a t e .  Clearly, x E C and s = f(x)Ef[C]. 
However, since C is f i n i t e ,  f[C] is f i n i t e ,  hence B must a l s o  
be f i n i t e  contradicting our i n i t i a l  observation. 
For the second half suppose A' were bounded t o  derive a 
contradiction. 
Define the mapping k(x) = < x , $ ~ ( ~ )  
( X I >  t o  see 
B1 C k[A1]. For suppose s E B1. 
Then a t  stage s an e-tuple 


i n  the second argument a l l  the x's i n  F appear i n  the construc- 
t i o n  of $ g ( t l  f o r  the f i r s t  time a f t e r  stage so. 
3.9.7 
Claim. 
Tf x € F then Qe(x) L $  
g' (t) ' 
Proof. 
Since the value of $J g' (t) is 
min {$Jg(t) (x) '41. (x) ,Qt(x)I there a r e  two subcases. 
t 
Subcase (1) . $gl (t) (XI is $Jg ( t )  (XI . From the d e t a i l s  of 
the construction, i f  an assignment t o  $ 
(x) is made a f t e r  
g ( t )  
stage so , it is done by popping an index of tower p r i o r i t y  than 
e. Further, from the d e t a i l s  of the construction, the assignment 
is made t o  $g ( t )  (x) such t h a t  $g ( t )  (x) ) Oe (x) . Hence, the 
r e s u l t  follows. 
Subcase ( 2 ) .  
+g, (t) (x) is +t (x) + OT (x) . We have t o  show 
t h a t  $t (x) + Ot (x) 
Qe(x). Suppose 
instead t h a t  $t(x)+Qt (x) 
< Oe (x) . Then +t (x) < Oe (x) and from the d e t a i l s  of the constru- 
construction 
e would be poppabZe a t  stage <x,Qt(x)>. This, 
however, contradicts the assumption t h a t  e is stable a t  0. 
From Claim 3.9.7 it follows t h a t   XI$^,(^) (XI < Oe(x) 1 
c - (xl<x,O> 2 so). 
But the l a t e r  s e t  is f i n i t e ,  hence, s o  is 
the former, A' . 
This completes the proof of Lemma 3.9.6. 
0 
3.9.8 
Lemma. 
Let +t be t o t a l .  
Then i f  e is s t a b l e  a t  1 then 
the sets A = {XI ee (XI > $t (x) 1 and A'= {xi Ot (x) > $ g ,  ( t )  (XI 1 a r e  
f i n i t e .  
Proof. 
Consider any x having the property t h a t  <x,O> > so, 
where so is the stage of Claim 3.9.4. 
Since < , > is increasing 
i n  the second argurrlent, it follows t h a t  p r i o r  t o  stage "<x,O>" 
no mention of input x has ever been made i n  the construction. 
3.9.9 
Claim. 
If x is such t h a t  <x,O> > so then Qe(x) 5 $t(x) 

and Qe(x) 5 $ g1 (t) ' 
Once we've proven Claim 3.9.9 
it follows t h a t  
A,A1 C_ {xl<x,O> f s o ) ,  hence A,A1 are f i n i t e  
Before showing Claim 3.9.9 
we introduce 
3.9.10 
Claim. 
For any x such t h a t  <x,O> > s , , Qe 1 (XI 
< min I$t (x) ,4g1 (t) 
- 
(XI) f o r  a l l  e' having higher priority than 
e and such t h a t  e' is unpoppable. 
Proof. 
Since e n  has higher priority than e, e '  must be 
stable a t  0. 
From t h e  d e t a i l s  of the proof of Claim 3.9.7, 
since 
<x,O> > so then Oe, (x) 2 Qg1 (t) (XI . It must a l s o  be t h a t  
Qe,(x) f $It(x) f o r  otherwise, e' would be poppable contrary t o  
our assumption. 
Hence, 6,' (x) f min {$t (x) ,$g, 
(x) ) for a l l  x 
such t h a t  <x,O> > so. 
We return t o  the proof of Claim 3.9.9. 
Consider x fixed 
where <x,O> > so. Let m = max {Qe,(x) le' 
has higher p r i o r i t y  
than e and e '  is unpoppable a f t e r  stage sol. From Claim 3.9.10 
(*I 
m - 
< min {$It(x) ,$Ig, 
(XI) 
If we can show 
(**I 
(Pe (XI ( m 
we a r e  done. 
For by (*) and (**I, 
Qe (x) 5 min C$t (x) ,$g, ( t )  (XI 1 
which v e r i f i e s  Claim 3.9.9. 
3.9.11 
Claim. 
A t  stage <x,m> is the earliest stage a t  which 
$g (t) (x) could be defined. 
Proof. 
It is clear t h a t  $g(t) (x) cannot be defined before 
stage <x,O>, since x never appears f o r  consideration before. 
Suppose +g(t) (x) was defined a t  stage <x,y>, y < m. Then it must 
have been t h a t  since m = Qe,(x) (e' having higher p r i o r i t y  than 

e) 
t h a t  m = Qe, (k) > y = $Si(t) ( X I .  
But t h i s  cannot occur by 
t h e  d e t a i l s  of t h e  construction. Hence, Claim 3.9.11 is proved.D 
A l l  t h a t  remains is t o  v e r i f y  (**). Certainly, Qe, (x) 5 m 
f o r  a l l  e' having higher p r i o r i t y  than e and unpoppable. By 
Claim 3.9.11 a t  s t a g e  <x,m> index e would be popped. 
But t h i s  
c o n t r a d i c t s  t h e  s t a b i l i t y  of e a f t e r  s t a g e  so. 
This completes t h e  proof of Lemma 3.9.8. 
D 
The proof of Claim 3.9.3 
follows from Lemmas 3.9.5, 
3.9.6 
and 3.9.8. 
For a l l  t h r e e  imply t h a t  f o r  $t t o t a l  and e any 
index, 
{x I @ e ( ~ )  
> $t (XI 1 
is f i n i t e  i f  and only i f  
( X  1 Qe (x) > $g, (t) (XI 1 
is f i n i t e .  
4. 
Speedable and 
Nonspeedable S e t s  
I n  t h i s  s e c t i o n  w e  examine some c l o s e  r e l a t i o n s h i p s  between 
a b s t r a c t  complexity and pure 
recursion theory. 
I n  p a r t i c u l a r ,  
we consider connections between s p e c i a l  types of sets c a l l e d  
speedable and nonspeedable and classes o f  r e c u r s i v e l y  enumerable 
(r.e.) sets. 
The f i r s t  theorem is Soare's 1281 pure recursion 
t h e o r e t i c  c h a r a c t e r i z a t i o n  of nonspeedable sets. Namely, set A 
is nonspeedable p r e c i s e l y  when t h e  c o l 1 e c t i o n o f r . e .  i n d i c e s  o f  
sets having nonempty i n t e r s e c t i o n  with 
is Turing reducible 
t o  0'. IIJe c a l l  any 
s a t i s f y i n g  t h e  l a t t e r  condition semilow. 
A second theorem tells us t h a t  t h e r e  are nonspeedable sets 
i n  every r.e. Turing degree. 
Althouqh t h i s  was f i r s t  shown by 
:larques, 
t h e  proof given here is t h a t  of Soare. 
( H i s  use of 
h i s  semi-lownesscriterion makes t h e  proof simpler.) 
We nex* 

characterize these r.e. Turing degrees t h a t  contain speedable 
sets. 
Namely, an r.e. degree has a speedable s e t  i f  and only i f  
its Turing jump is above 9'. 
We conclude t h e  section with a 
discussion of t h e  structure of the speedable s e t s  and t h e i r  
relation t o  well-studied classes of r.e. sets. 
We 
assume the reader is familiar with the basic notions of 
ordinary and relativized recursion theory. 
In particular, the 
concepts of recursively enumerable in a set, Turing degree, jump 
of a s e t  and a degree, O w ,  Turing reducibility (zT), m-reducibil- 
i t y  (2nd and m-completeness a r e  assumed. For d e t a i l s  we refer the 
reader t o  Roqers [ 24 1 . 
B 
From now on {Re) and (
~
~
3
 
denote some canonical enumeration 
of the recursively enumerable sets and the s e t s  recursively 
enumerable i n  B, respectively. 
4.1 
Definition.(Blum and Marques 121). 
An r.e. s e t  A is 
speedable i f  f o r  a l l  e such t h a t  Re = A and for a l l  recursive 
functions h, there e x i s t s  e' such t h a t  Re,= 
A and 
{ X I  Qe (x) > h (x,Qe, (x) ) 1 is i n f i n i t e .  
Intuitively, i f  A is speedable then f o r  every algorithm "en 
f o r  A and every recursive h there is another algorithm " e n "  f o r  A 
which is an h speed-up of the f i r s t  (i.e., Qe (x) > h (x, Gel (x) 
i n f i n i t e l y  of ten) . 
4.2 
Definition. 
An r.e. set A is called nonspeedabte i f  it is 
not speedable. 
More precisely, r.e. s e t  A is nonspeedabte i f  and 
only i f  there e x i s t s  e such t h a t  Re = A and a recursive function 
h such t h a t  f o r  a l l  e 1  where Re, = A , 
x E A * (De(x) 5 h(x,Qe,(x)) 
f o r  a l l  but a f i n i t e  set. 

E s s e n t i a l l y  an r.e. s e t  A 
is nonspeedable i f  t h e r e  e x i s t s  a 
recursive h and an index e f o r  A such t h a t  every algorithm e' f o r  
A cannot be an h speedup of e. 
Definition. 
Given a set A t h e  weak jump of A is t h e  set 
HA =  el^^ " A # g ) .  
A set 
A is c a l l e d  semi-Zou i f  its weak 
jump is Turing reducible t o  0' (HA L~ 0 '  . 
Several of o u r  r e s u l t s r e a u i r e t h e  well known l i m i t  theorem 
of Schoenfield [261. 
4.1 
Limit Lemma. 
Given S r w, S L~ 0' i f  and only i f  t h e r e  is 
a recursive predicate S (e,s) such t h a t  S ( e )  = l i m  S (e,s) e x i s t s  
S 
f o r  a l l  e. 
Proof (*) . Suppose S ( e , s )  is recursive and l i m  S (ens) e x i s t s  
S 
and equals S ( e ) .  Let A,Z be defined by 
- 
Since 
is r.e. and 0' is m-complete 
t h e r e  is a recursive f such 
t h a t  <e,t> E A * f ( < e , t > )  9 0'. Hence, 
and 
g(e) * 3 t  <e,t> E A & S(e,t) 
Thus, S 2T 0'. 
0 ' 
. 
Assume S f T  0' and t h a t  S ( e )  = Cell 
(el f o r  some el. 
Then 
S ( e )  * 3n 3m <e,l,n,m> E Re 
& Kn 5 0' & Km C 5' 
1 
- 
5(e) * 3 n  3m <e,O,n,m> E R 
& K~ c O' 
& K~ 5 5' 
el 
- 
(By t h e  d e f i n i t i o n  of recursive i n  0 '  where {Ki) is an enumera- 
t i o n  of t h e  f i n i t e  s u b s e t s  of w ) .  
Since 0' is r.e. t h e r e  is a 
1 
recursive predicate Os (e) where 
0' = l i m  0;. 

Define 
- 
i 
1 if 3h.m < s <e,l,n,n> RS & KnC_ 0; & K, 
5 0; 
S(e,s) I 
el 
0 otherwise 
Clearly S(e,s) is recursive and from S = tell0', 
lim S(e,s) 
S 
exists and equals S(e). 
0 
We next prove Soare's recursion theoreticcharacterization of 
nonspeedability. Namely, nonspeedable sets are those r.e. sets 
whose complements are semi-low. 
4.2 
Theorem (Soare [ 2 8 1 ) .  
A recursively enumerable set A is 
nonspeedable if and only if  el^, " 
# 81 $ 0'. 
Proof (*): 
Let A be nonspeedable and let el and h satisfy 
Definition 4.2. 
Define recursive function f by Rf 
= Re U A 
and Hz(e,s) by i 
1 if (3 X) [X E R:-R~ 
and 0 (XI > h (x,@f (el (x) 
HA(e,s) = 
1 
1 
0 otherwise 
HX(e,s) is clearly recursive. We show that Hx(e) = lim HX(e,s) 
s 
is the characteristic function of Hz. 
By the Limit Lemma 4.1 
HJi LT 0'. 
Suppose x € Re n z (i.e. e E Hz). Then x E R: 
- A' 
= R:-RS 
el 
for all s > so. Thus, since Re = A, 0 (x) diverges and since 
1 
el 
Re 5 Rf(e) , h(@f(e) (x),x) is defined. Hence, HJi(e,s) = 1, s >so. 
Suppose Re n 
= 
(i.e., e 9 HA) then Re C_ A and hence, 
Rf (el = Re U A = A. By the nonspeedability of A, since A = Rf(e), 
is bounded by some xo. Hence, there will be some stage so such 
s 
S 
that A 
x0 
Rel 
(= A ) for all s > so. Hence, (A Q x0)n(R:-$ 
) 
1 
= $3 and thus HE(e,s) = 0 for all s > so. 
(-1 
Assume 
is semilow, that is, Hz= (elRen 
# 91 zT 0'. 
By the Limit Lemma 4.1 
there are Hji(e,s) and HE(e) where 

Hx (e) = lim Hx (e, s) . Let el be such that Re = A and define 
s 
1 
G(x,y,e) as follows: 
(1) If Qe(x) # y set G(x,y,e) = 0, 
(2) If Qe(x) = y let t = min [Qe (x) = s or Hji(e,s) = 11 
s2x 
1 
(a) If Qe (XI = t set G(x,y,e) = t 
1 
A 
(b) Otherwise, 
set G(x,y,e)=O. 
Observe that t exists in (2) when Qe (x) = y. 
For then x E Re , 
hence, either x E Re = A or else x E Re n 
and then Hx(e,s) = 1 
1 
for all but a finite set of s. 
Define h(x,y) = max {G(x,y,el) le' 5 x) to see that el and h 
witness the nonspeedability of A. 
For suppose Re = A. Then 
since Re n 5 = jB, HJi(e,s) = 0 for s > so. Let x E A where 
x > maxis0,e,Qe (x) 1, to see that Q 
(x) 
h(Qe(x) ,XI. 
For then 
1 
el 
h (x,Qe (x) = max {G(x,Q~ 
(x) ,e 
I e 
XI. 
Since x > e, 
2 G (x,Qe(x) ,el. 
But since x > so, by the definition of G, 
= @ 
(XI. 
0 
el 
An easy method of demonstrating nonspeedability is given 
in the following: 
4.3 
Corollary (Soare [281). For an r.e. set A to be nonspeed- 
able it suffices to provide enumeration {
~
~
l
~
<
~
 
of A such that 
for all e there are infinite sets of s such that RE-A~ # jB 
implies Re n x # 9. 
Proof. Define 
1 if RE-A~ # 9 
Hx(e,s) = 
0 otherwise 
We will see that Hx(e) = lim Hx(e,s) 
exists for all e. Hence, 
s 
by Theorem 4.2,and Limit Lemma 4.1, A is nonspeedable. 
Suppose e E Hz then there is an x E Re n x. Hence, for all 

s > so. x E R: 
n 6' 
and thus Hi(e,s) = 1. Suppose f o r  all s > so, 
HJi(e,s)=L Then by hypothesis 
Re n 
# $3 and thus e E Hz. 
0 
The next r e s u l t  was f i r s t  shown by Marques i n  [17]. In 1281 
Soare exploits t h i s  semi-lowness criterion t o  obtain a shorter 
proof. 
4.4 
Theorem (Soare I281, Marques 1171). 
There a r e  nonspeedable 
s e t s  i n  every r.e. Turing degree. 
Proof. 
Let B be an r.e. set i n  degree a and l e t  BS be some 
recursive enumeration of B. Let IFn) be some canonical sequence 
of d i s j o i n t  f i n i t e  sets such t h a t  
(1)  IF,^ = n + 1  
(2) Fn n Fm = $3, 
n # m, and 
(3) 
the f i n i t e  set Fn is recursively obtainable from 
n. 
We define A by a construction. 
Stage 0. 
Set A' 
= 0. 
Stage s+l: 
Define 
min[*R:-As] 
i f  such x e x i s t s  
e 
otherwise 
I f n E B  
B', 
let xn - min Ix E Pn- U {dzle < n l l .  
X 
set A'+' 
= A' u {xn). 
End of construction. 
4 . 4 1  C l a i m .  
de = l i m  d: 
e x i s t s  for a l l  e. 
s 
Proof. 
For any e there is a stage so such t h a t  for a l l  
s > so , i f  n E B'+'-B~ 
then n > e. 
By the d e t a i l s  of the 
construction d: , s > so cannot be added i n t o  AS. Hence the 
only way it can be changed is by being replaced by 
a smaller 
member of Re. 
It follows t h a t  a f t e r  some stage sl, dg is stable. 
4.4.2 
Claim. 
A is nonspeedable. 
Proof. 
Suppose t h a t  f o r  an i n f i n i t e  s e t  of s R:-As 
# 0. 

By the details of the construction it must be that Ren 
g $3, 
Hence, A's nonspeedability follows from Corollary 4.3. 
4.4.3 
Claim. n E B * Fn n A # $3. 
By this claim and the fact that I F  
fl n A I  5 1 we have 
B & A and A IT B. Hence, A and B are in the same Turing degree. 
Proof (of Claim 4.4.3). 
(*) 
If n E B, let n E B'+~-B 
for 
some s~+l. Since IFn[ = n+l it follows that some xnE Fn is added 
to A at stage s+l. Hence, Fn n A # 8. 
('1 
Since the {I?,) 
are mutually disjoint, if x E Fn n A 
then n E B. 
This ends the proof of Theorem 4.3. 
Definition. An r.e. set A is h i g h  if A' ET 0' and Zow if 
A' E 0'. An r.e. degree a is h i g h  (Zoo) if it contains a high 
T 
- 
(low) set. 
4.5 Lemma. An r.e. set which is low is semi-low. 
B 
B 
Proof. Let B be any set and let H =   el^, # $3). We will 
show that 
(1) 
H~ 
H~ 
and 
(2) 
H~ &" B1 
where &, denotes m-reducible. From these it follows that HB &" B' 
and that if B' 5T 0' then HB L~ 0'. 
For (1) e E HB * Re n B # $3 
* R: 
(,) # !ij for some recursive f, 
*£(el 
H ~ .  
For (2) e E nB * R: 
# $3 * 3m,n,x <x8nIm>ERe 
& Kn C - B & Km 5 
* 3m,n <l,m,n> E R 
,S 
K~ c B & K~ 5 i where 
r (el 
- 
R~ 
{<l,m,n> 13x <x,m,n> E Re * <lrr(e)> 
B' 
9 f(e) E B' where f (el = <l,r(e)>- 
U 
Marques proved that if an r.e. degree contained a speedable 
set then it must be high. Soare [281 completed the characteri- 
zation by showing that each such degree contains a speedable set 

4.6 
Theorem (Marques 117 I , Soare [28 ] ) . An r. e. degree a 
contains a speedable set if and only if a' > 0'. 
- 
- 
Proof. (*) 
Suppose a is low. Then for some A E a, A is low 
- 
- 
and by Lemma 4.5 A is semilow. By Theorem 4.2, A is nonspeedable. 
* 
Suppose 2' > 0'. Then choose B E a and let 
- 
- 
A = 1 x 1 ~ ~  
n  B f 9). (Here (
~
~
1
 
is some enumeration of the finite 
sets where "xn recursively encodes set Kx.) Clearly, A ET B and 
0' < 
B'. 
T 
4.6.1 Claim. B' LT Hz. 
From this and the above it follows that 0' <T Hs , hence 
Hz fT 0' . By Theorem 4.2, A is speedable. 
B 
Proof (of Claim 4.6.1). 
Recall that B'= {ele€~~). 
Define 
p(e) as in Rogers [24]. (That is, 
S 
<x,y,m,n> E Rp(e) 
e 
(x) = y whenever Km 5 S & % 5 8 . )  
By the s:-theorem, 
there is a recursive u(e) such that 
Ra (el = {m13n [<e,e,n,m> E R 
C B). 
p(e) & '
n
 
- 
Then e E B' * (317) [v E R,(,) 
& Kv 5 E l .  
By definition of A, 
a R, 
n  f pl. 
By definition of Hz * ~ ( e )  
E Hz. 
(Remark. B' is not only Turing reducible to HE but also 
1-reducible.) This completes the proof of Theorem 4.4. 
0 
We conclude the section by relating speedable sets to well 
structured classes of recursively enumerable sets. 
4.5 
Definition. A confinite r.e. set A is f i n i t e l y  s t r o n g l y  
h y p e r s i m p l e  
'if there is no recursive function f such that for 
all x and y 
(4.5.1) 
x # y * Rf(x) n  Rf(y) = 0 (4.5.2) Rf(x) n z f 0  
(4.5.3) 
Rf(x) isfinite, 
and 
(4.5.4) 
U R f ( x ) -  
3 X. 
X 

The diagram below summarizes relationships between 
simple sets where "P + Qn indicates that property P implies 
property Q and the lack of an arrow indicates that the implica- 
tion fails. Deleting condition (4.5.4) we obtain the definition 
of A being hyperhypersimple and deleting (4.5.3) we have A 
strongly hypersimple. 
The definitions of the others can be 
found in Rogers [24 ] . 
strongly , 
finite strongly 
r-maximal * hypersimple 
hypersimple 
maximal ir 
T 
\3 
L 
dense + hypersimple 
quasi-maximal + hyperhypersimple + simple 
J. 
simple 
4.7 Theorem (Jockusch [14], Soare [28] ) . If A is finitely 
strongly hypersimple then A is speedable. 
Proof. Jockusch [14, Theorem 6.11 
proves that if 
is 
infinite and low there is a recursive function satisfying 
4.5.1-4.5.4. 
His proof uses only the hypothesis HE I?, @'. 
The theorem follows from Theorem 4.2. 
0 
4.8 Corollary (Marques [17]). 
Every maximal set is speedable. 
Proof. Immediate from Theorem 4.7 and the diagram. 
0 
5 .  
Generalizations 
In this section we examine the infinitary analogue of 
abstract complexity theory in Kriple-Platek admissible recursion 
theory (cf. [I51 , [22] ) . We introduce a generalization to the 
definition of computational complexity measure. Using this we 
formulate generalizations to several important results from the 
w theory and show these generalizations hold in the new theory. 
In particular we prove analogues to the Blum, Rabin, and Gap 

theorems. Typically, the demonstrations of these generalizations, 
require modifications to constructions and verification proofs. 
We begin with some basic definitions: 
A Von Neumann o r d i n a t ,  or simply an o r d i n a t ,  is identified 
with the set of all smaller ordinals. We use lower case Greek 
letters to denote ordinals (a,B,y ... ),lower case Latin letters 
for functions (f,g,h,.,.) 
and upper case Latin letters for sets 
of ordinals (A,B,C, . . . 
) . 
Let La be the collection of sets obtained from Godel's I61 
transfinite hierarchy of constructible sets before a. 
Namely, 
Lo = 8, 
La+l = Def(La) U La , 
LA = TYA LT 
where Def(La) is the collection of first order definable subsets 
of La. 
By a C1-replacement axiom of ZF 
we mean a formula 
(in the language of ZF set theory) of the form: 
VxVyVy' (4(x,y) A $ (x,y' 
+ y=y') 
+ \It 3w tlv [V E w *,3u u E t A $(u,v)]) 
where $ is a C1 formula. Ordinal a is C1 a d m i s s i b l e  if La 
satisfies all El-replacement axioms of ZF. From t h i s  point on a 
i s  some f i x e d  C1 a d m i s s i b l e  o r d i n a l .  
A partial function f: a + a is a-partial recursive if its 
graph has a C1 definition over La (with parameters in La). An 
a-partial recursive function f total on a is a-recursive. A set 
A 5 a is a-recursively enumerable (a-r.e.) if it is empty or the 
range of an a-recursive function; it is a-recursive if it and its 
complement (with respect to a) are a-recursively enumerable. 
We say a set A 5 a is a-bounded (or bounded when a is under- 
stood) if there exists a 6 < a so that a E A + o < 6 .  If A is 
both a-recursive and bounded it is a-finite. Following sacks[251 

there e x i s t s  some standard enumeration {K In < a )  of a l l  t h e  
0 
a-finite subsets of a. 
5.1 
F S .  Let f be a-partial recursive and K an a-finite subset 
of the domain of f .  Then f[K] is a-finite. 
The projectum of a ,  denoted a*, is the l e a s t  ordinal 8 5 a 
such t h a t  there is a one-to-one a-recursive mapping from a i n t o  
8. 
Unlike w ,  s e t s  which are bounded and a-r.e. 
a r e  not necessar- 
i l y  a-finite. However, a-finiteness w i l l  occur i f  the bound is 
small enough. 
5.2 Fact. 
I f  0 < a* and A is an a-recursively enumerable subset 
of 0 ,  then A is a-finite. 
We employ the a-recursive functions, 'rrl,s2 and < , > obtain- 
ing a one-to-one correspondence between a and a x a (cf. [16]). 
These enjoy the usual properties of pairing functions. Namely, 
f o r  B1,B2,y 
< a ,  ( i ) < * 1 ( ~ ) r ~ 2 ( ~ ) >  
= Y; (ii) al(<Bl,B2>) = B1 
and 
a2(<B1,B2>) = B2 ; and nl(y) = B1 
f o r  an unbounded s e t  of y. 
Sacks [15] proves the existence of an a-recursive r ( a , & )  
such t h a t  (i) a 2 r implies Kr ( u , E )  5 
, and (ii) B 
a-recursively enumerable implies B=U{K 
la<a) f o r  some €<a. 
r ( u , ~ )  
Definition. 
Let R: 
= Kr 
. Then the s e t  R~=~{R:IU 
C a ]  
represents the E~~ 
a-recursiveZy enumerable s e t .  We c a l l  
E the 
t index of RE. 
This formulation provides us with an enumeration of t h e  
a-partial recursive functions. Namely, t h e  a-partial recursive 
function with index E is 
. - 
Note t h i s  c a r r i e s  along with it an a-analogue t o  the Normal Form 
Theorem (cf. (51 . 
A generalization t o  Blumts notion of abstract c o m ~ l e x i t y  

measure is introduced. 
Definition. 
An a-complexity measure, 
@, 
is an enumeration 
(in a )  of t h e  a-partial recursive functions {@,I& < a} t o  which 
are associated the a-partial recursive a-step counting functions 
I@,le<a} f o r  which the following axioms hold: 
(1) $,(B) is defined i f f  @,(B) 
i s  defined 
( 2 )  
The predicate M(c,B,y) * QE (0) = y is a-recursive. 
It is a l s o  assumed t h a t  a-recursive ve'rsions of the s:, 
Universal Function and Recursion Theorems hold 
f o r  the enumera- 
tion , 1 E < a .  Implicit i n  t h i s  definition is the capability 
t o  retrieve, given any index E ,  both the function 4, , i n  the 
form of an 'algorithm', and t h e  a-step counter, Q, . 
iJe conclude the section with several examples of a-complex- 
i t y  measures. 
(1) For the case a = w ,  
it is clear t h e  notion of 
a-complexity measure coincides with Blum's notion. 
( 2 )  Let {0,lc<a) 
be the enumeration of the a-partial recur- 
sive functions obtained via the Kripke Equation Calculus (EC) D5]. 
Namely, 8, is the function computed from the system of equations 
with Giidel number & < a. Let G N - ~ ( E )  be the s e t  of equations with 
E 
Godel number E and S t h e  a - f i n i t e  s e t  of equations derived from 
Y 
s e t  E by stage y according t o  t h e  rules of EC. 
A set of a-step counting functions {O,l~<a} is defined by 
O E ( B )  = y * B E ( @ )  
is f i r s t  definea a t  S G N ' ~  ( E 
Y 
Clearly, 
0, ($1 f i f f  0, ( B )  f . Further, the predicate 
PI(c,B,y) * t h e  equation defining the value of 0, (6) f i r s t  
G N - ~  
( E 
appears i n  S ' N - ~ ( ~ )  i n  some standard enumeration of Sa 
Y 
is a-recursive. 

(3) Let ( 6 e l ~ < a l  be the enumeration of the a-partial recur- 
sive functions defined i n  (*). L e t  {A,] &<a} be a corresponding 
s e t  of a-step counting functions defined by 
a2-(v 
A , ( B )  
= min { < B , n l ( ~ ) >  RE 
I .  
Y<a 
Clearly €iE(6) t i f  and only i f  A E  ( B ) + .  Further, the predicate 
n2(v) 
M ( E , B , ~ )  * y = min { < B , T ~ ( Y ) >  
E RE 
1 
y<a 
is a-recursive. 
We next prove a generalization t o  Blum's theorem, called, 
appropriately enough, the a-Blum theorem. 
An analogue t o  t h e  
Rabin theorem follows a s  an immediate corollary. 
5.2 a-Blum Theorem (Jacobs [lo]. 
Let '4 be an a-computational 
complexity measure and g an a-partial recursive function. Then 
there corresponds t o  g a 0-1 valued a-partial recursive function 
f ,  with the same domain a s  g, such t h a t  i f  E is any index f o r  f 
then Q E ( B )  ) g(B) f o r  a l l  but a bounded s e t  of 6. 
An immediate consequence is the 
5.3 a-Rabin Theorem (Jacobs [ l o ] ) .  Let 
Q be an a-computational 
complexity measure and g an a-recursive function. Then t h e r e  
corresponds t o  g a 0-1 valued a-recursive function f such t h a t  
i f  E is any index f o r  f then O E ( B )  2 g(B) f o r  a l l  but an a-finite 
s e t  of 6. 
Proof. 
L e t  f be the 0-1 valued a-partial recursive function 
corresponding t o  g by the a-Blum Theorem. 
Since g i s  a-recursive 
and dom(g) = dom(f), f is a-recursive. For any index E f o r  f ,  the 
s e t  B = (BIOE(B) < g ( 6 ) )  is bounded. Since g is a-recursive, B is 
a-recursive , hence, a-f i n i t e  . 
0 
Rabin and B l u m ' s  original constructions hinge upon a funda- 
mental property of w; namely, t h a t  unbounded sequences cannot be 
one-one mapped i n t o  proper i n i t i a l  segments. 
In t h e  case of 

admissibles greater than w, such can occur due to the presence of 
limits. Consequently, in a-constructions in which objects are 
"cancelledn based upon natural order priority (< a), one cannot 
automatically assume that objects with unbounded opportunities 
for cancellation will ultimately do so. For it may occur that 
every time an object with priority 0<a is eligible for cancella- 
tion, some other object with priority X < B  beats it out. As a 
result the 0-th object will never be cancelled. 
The way in which we solve this problem is by formulating 
constructions with priorities founded, not upon natural order, 
but rather upon ordering induced by an a-recursive projection. By 
making use of the properties that a-r.e. subsets below a* are 
a-f inite (Fact 5.2 ) and that a satisfies El-replacement (Fact 5.1) 
we argue that objects trying hard enough will ultimately be 
cancelled. 
We now prove the a-Blum Theorem. 
Proof. By definition of projectum, there exists an a-recur- 
sive one-to-one map t: a + a*. The function t serves to generate 
our "prioritiesn. For any index E<a, t(c)<a* is called the 
pseudo index for E. 
Since t is one-to-one and a-recursive, it has an a-partial 
recursive inverse t-l: a * .  Fix c0 in our enumeration (4,) so 
that (E 
= t-l. Let t,' 
be the approrimation t o  t-l through s t a g e  
0 
,<a, defined by 
($1 
if @, 
(0) 5 a 
0 
otherwise 
Clearly, for ,,$<a it can be a-recursively determined whether or 
-1 
not t, 
(6)C. 
The required function f will be defined by a construction 

specified belbw. 
This construction proceeds i n  stages a<a and is 
defined by t r a n s f i n i t e  induction on a. Throughout the construc- 
tion we w i l l  be accumulating two s e t s  A and F. 
The s e t  A', 
a t  stage a, w i l l  serve a s  the collection of 
pseudo indices which have been "cancelledn prior t o  o r  during 
stage a. The s e t  A<' 
w i l l  denote those cancelled pseudo indices 
just prior t o  stage a; i.e. A<' 
= 
U A'. 
T < U  
The s e t  F', 
a t  stage a serves a s  t h a t  p a r t  of the graph of 
our desired function collected a t  stage a. 
The s e t  F<' w i l l  be 
a 
F j u s t  prior t o  stage a; i.e. F<' = 
u F'. 
'<a 
For any input K < a ,  the following construction t e l l s  us how 
t o  compute the value of f ( ~ ) .  
Construction 
Stage 0. 
Set A' 
= F' 
= 9. 
Stage a. 
(1) Set B = I T ~ ( U )  
I 
IJ = n2(a) where I I ~ , I I ~  
a r e  defined above. 
( 2 )  
I f  @ I ~ ( B )  # 1 1 ,  where g = @ A  then s e t  A' 
= A<'; 
FU = F"; 
go t o  stage a+l. 
( 3 )  
s e t  v = { ~ l t ( l ' ( ~ ) +  
L E 5 t (8) L 
-1 
(6) < g ( 8 ) ) .  
t a  ( E )  
( 4 )  
I f  
A<' 
= A < '  
u V 
then set 
A' 
= A<U; 
0 = 1; 
Fa = F" 
U {<B,0>1; go t o  s t e p  
(6). 
(5) Set p = min ( T  E V & T 9 A<'}; 
A'= 
A<'U 
{PI; F ~ = F < ~ U { < B , ~ > ~
T 
where 0 is e i t h e r  0 o r  1 but not 4 
(8). 
t - h  
(6) 
I f  8 = K then output 0 and h a l t ;  else 
t o  stage a+l. 
Set F = 
U Fa, A = 
U 
A' 
and l e t  f be defined by 
a<a 
a<a 
f(B) = y * <B,y> E F . 
We show f s a t i s f i e s  a l l  requirements v i a  a sequence of lemmas. 
5.2.1 
Lemma. 
(i) f is a 0-1-valued a-partial recursive function 
and (ii) dorn(g) = dom(f1. 


91 
cancelled by t h e  construction. 
Proof. 
The set k[Ev] is comprised of a l l  of t h e  s t a g e s  a t  
which pseudo indices below v a r e  cancelled. 
By Lemma 5-2.2 
t h i s  
set is a - f i n i t e ,  hence bounded by some o r d i n a l  a. 
< a. 
5.2.4 
Lemma. 
Let v<a*. 
Then t h e r e  e x i s t s  a 02<a such t h a t  
a > a 
implies t ( a )  > v. 
2 
Proof. 
The s e t  CV= I E  < a * [ €  E t [ a ]  b E ( v }  is 
a-recursively enumerable and bounded below a*; by Fact 5.2 it is 
a - f i n i t e .  
Since C,z 
domft-l) 
and t-' i s  a - p a r t i a l  recursive. 
by Fact 5.1 ti' [cV] is a - f i n i t e ,  hence bounded by u2ca. The lemma 
follows from t h e  d e f i n i t i o n s .  
We a r e  now ready t o  prove 
5.2.5 
Lemma. 
Let E be any index f o r  
f .  
Then t h e  set 
{B 1 aE ( B )  <$(B) 1 is bounded. 
Proof. 
Assume f o r  some index E f o r  f ,  t h e  s e t  
{ B [ @ ~ ( B )  
< g ( B ) }  is unbounded. 
Let t ( ~ )  
= E '  and let al be t h e  
- 1 
l e a s t  stage where to ( E ' )  = E. 
By Corollary 5.2.3 t h e r e  is a oo 
1 
such t h a t  no pseudo index smaller than E '  is cancelled p a s t  
s t a g e  ao. 
By Lemma 5.2.4 t h e r e  is a 
s o  t h a t  a > a2 implies 
t ( a )  > E ' .  
Since i B I @ E ( B )  < g(B)1 is unbounded, it has a member 
B '  2 maxi0 
al , a2 1. 
Certainly, QE (8 '1 S and hence < B  ' ,eE ( B '  > is 
defined. 
Let a '  = < B o 8 O E ( B ' ) > .  
By p r o p e r t i e s  of p a i r i n g  
functions (cf. G6del [ 6 ] ) ,  0 '  < a '  < a ,  and hence 
a '  > max {a0,a1,a2). 
From t h e  d e t a i l s  of t h e  construction E '  
must be cancelled no l a t e r  than s t a g e  a ' .  However, t h i s  implies 
f # @ E ,  c o n t r a d i c t i n g  t h e  hypothesis. 
0 
N e  remark t h a t  i n  both B l u m ' s  and Rabin's r e s u l t s  (a = w) 
t h e  complexity of t h e  constructed function exceeded t h e  given 

function on a l l  but a ' f i n i t e '  set of w. 
In the generalization, 
however, one analogue t o  f i n i t e  was a-finite (a-Rabin), while 
the other was bounded (a-Blum). 
The reason f o r  t h i s  is t h a t  the 
excluded set { $  I QC (8) < g ( $ )  although bounded does not appear 
a-recursive f o r  g nontotal. 
In 1291, Stoltenberg-Hansen 
proves 
an analogue t o  the Blum Theorem where f i n i t e  is, i n  f a c t ,  
replaced by a-finite. 
Furthermore, it is a l s o  seen i n  [291 t h a t  
an analogue holds 
even when a is not admissable. 
Definition. 
For any a-complexity measure 0 and a-recursive 
function s t h e  a-comptexity class bounded by s is 
C: 
= {(,I(, 
is t o t a l  & @,($) 5 s($) f o r  a l l  but an a-finite set 
of $1. 
0 
Thus C 
, o r  simply Cs , when 0 is understood, is the s e t  
of a l l  a-recursive functions whose complexity is bounded by s on 
a l l  but an a - f i n i t e  subset of a. 
We next prove a generalization of the Borodin Gap Theorem 
Our r e s u l t ,  the a-Gap Theorem, t e l l s  us t h a t  there e x i s t s  no 
uniform way t o  increase bounds on a-complexity c l a s s e s  t h a t  w i l l  
always yield larger classes. 
Another way of interpreting the 
r e s u l t  is t h e  a-step 
counting functions a r e  sparse r e l a t i v e  t o  
the a-recursive functions. 
5.4 a-Gap Theorem (Jacobs [ l o ] ) .  
For a l l  a-recursive functions 
a ( $ )  and r(B,y) (with r ( $ , y )  L y) we can find an a-recursive 
function s such t h a t  
(i) s ( B )  2 a ( $ )  f o r  a l l  $ c a , and 
(ii) For each E < a, OE($) 2 ~ ( $ 1  
implies 
>- r(B,s(B) 
f o r  a l l  but an a - f i n i t e  set of 0 .  
The a-Gap Theorem may also be viewed i n  terms of a-complexit 
classes. 

5.5 
Corollary. 
Assume t h e  hypothesis o f  t h e  a-Gap Theorem. 
Then w e  can f i n d  an a-recursive function s such t h a t  
(i) ~ ( $ 1  - 
> a(B) f o r  a l l  8 < a ,  and 
(ii) 
'XBS(B) 
C ~ ~ r ( ~ , s ( ~ )  
1 
0 
-1 
Proof. 
Let t and to be a s  i n  t h e  proof of Theorem 5.2. 
An a-recursive function s ( B )  w i l l  be defined i n  terms o f  a 
construction below. 
For each s t a g e  o < a ,  t h e  construction 
a 
s p l i t s  i n t o  substages 6 < a ,  where t h e  values sB a r e  computed. 
A f t e r  enough substages a r e  performed, some sa is chosen as t h e  
80 
value of s ( a )  . 
Construction. 
Stage 0. 
Set s ( 0 )  = a ( 0 ) .  
Stage a. 
(3 
Substage 0. 
S e t  so = a ( o )  
Substage B. 
a 
set sg = sup t ( u ,  s:) 
+ 1 
6<8 
I f  f o r  nc 
E '  ( t ( 0 )  
-1 
1. t 
+ 
and 
a 
2 -  
sB ( 0 - 1  
(a) 5 r ( u 8  si) 
t, ( € ' I  
then set s ( a )  = s:; 
go t o  s t a g e  a+l; 
else go t o  substage @+1. 
end of substage B. 
end of s t a g e  a .  
5.4.1 
Lemma. 
For each a < a t h e r e  e x i s t s  a B, 
< a such t h a t  
s ( a )  is defined a t  substage B, 
o f  s t a g e  a. 
Certainly, t h e  a-recursjveness o f  s ( a )  follows. For t h e  
moment we w i l l  assume Lemma 5.4.1 is proven. 
5.4.2 
Lemma. 
s ( a l  2 a ( a )  f o r  a l l  a < a. 

Proof. 
By a simple induction on 8, w e  see t h a t  a t  stage a, 
si 2 a(u) for a l l  8. 
The r e s u l t  follows by Lemma 5.4.1. 
5.4.3 
Lemma. 
For each & < a 
there exists a a, < a such that 
whenever a > a&: 
@,(a) 2 s ( a )  implies 
@ &  (01 > r ( a , s ( o )  1 .  
Proof. 
Let t(&) 
= E '  and l e t  E,= 
Cv z ~ ' l v €  r n g ( t ) l .  
E, is a-r.e. 
and bounded below a*; hence, applying Fact 5.2 
E& is a-finite. 
Define F& = t-l[+l 
= {a < a l t ( u )  5 ~ ( E ) I .  t - 1 
-1 
is 
a-partial recursive, E, 
is a-finite and EE 5 dom(t 
1; 
hence by Fact 5.1 F, 
is a-finite. 
Choose a1 < a 
so that F, is 
bounded above by al. 
Since & '  E r n g ( t ) ,  let a2 be such that 
-1 
o > a2 implies ta ( E ' )  +. 
5.4.4 
Claim. 
The required a, 
is max {al,a2}. 
Suppose 
o > max {al,a2). 
By Lemma 5.4.1, 
s ( a )  is defined 
a t  substage 
of a. 
By definition of u1 ,a2 , ti1 
(E ' ) (. 
and 
t ( a )  > E ' .  
If OE (a) 2 s (a) by the d e t a i l s  of the construction 
(since sa = s ( u ) )  it c a n l t  be t h a t  s ( u )  2 @,(a) ( r ( o , s ( a ) ) ;  
a 
hence it must be that r ( o , s ( a ) )  < @,(a) . 
From Lemma 5.4.3, 
we conclude that for E < a, the s e t  
C = {al@,(a) 2 S ( U )  
6 @,(a) 2 r ( a ,  s ( a ) ) I  
is bounded above by some a, 
(i.e. where the implication f a i l s  t o  
hold). 
Since s and r are a-recursive, it follows t h a t  C is 
a-recursive; hence, C is a-finite. 
Before verifying the l a s t  part we introduce preliminary 
5.4.5 
Lemma. 
For a < a, the set H = {@,(a) It(,) ( t ( a )  & 
til(t 
( E ) )  + & @& ( a ) + )  is bounded by some 
6' < a . 
Proof. 
F i r  a < a and let Du = {cl - 
< t ( u ) ~ t ( y l ( ~ ' ) +  
& 
@tZl(& 
l (a)+}. 
D, 
is a-r.e. 
and bounded below a*; hence, 

by Fact 5.2, Do is a-finite. Define g,: 
a* + a by 
( ~ ) i f t ~ ~ ( c ~ ) t ~ ~ - ~
(0)) 
t, 
(E') 
otherwise 
g, 
is a-partial recursive and Do 5 dom(ga); thus by Fact 5.1, 
g, [D,] 
is a-finite, and bounded by some 13 ' . The lemma follows 
from the observation that H = g, [Do] . 
Finally, 
Proof.(of Lemma 5.4.1): 
Fix a < a and assume s(oj is 
defined for all o' < a. 
By a simple induction, the sequence 
1s; 18 < a) is strictly increasing. This regarded as a one-to- 
one order preserving map of a iinto a, implies that rng(si) is 
cofinal with a. 
Let 8' < a be as in Lemma 5.4.5, 
that is, 
8' > (OE(o) It(€) 5 t(o) & til(t(€))+ 6 OE(ol+). By cofinality 
0 
of 1s;) 
there is a B O  < a, where s 
> 8' . Thus, at substage 
B0 , for all investigated E, @€(a) < si - 
< r(u, s" ). Hence, by 
0 
0 
u 
at most substage B0 of a, s(a) is defined; concluding s(o) = s , 
@a 
for some 8, 
< a . 
Most of the major results of abstract computational complex- 
ity theory (as found in Hartmanis and Hopcroft [7]) have been 
shown in [91 to generalize (in one form or another) to 
a-recursion theory. Besides those presented here, these include 
Blum's Speed-up, Lewis-Landweber-Robertson's Nonrecursively 
Enumerable Complexity Class and McCreight-Meyer's Honesty and 
Union Theorems. The generalization of the last result, the Union 
Theorem, required a rather extensive overhaul of the w-Proof. 
Namely, instead of a typical cancellation argument, the generali- 
zation necessitated a cancellation atop a finite injury priority 

construction. Further, the listing provided by a* did not 
suffice here. Consequently, a shorter listing together with a 
blocking strategy (cf. [27]) had to be implemented. 
References 
[I] Blum, M., "A machine-independent theory of the complexity of 
recursive functions," J. ACM 14 (1967) pp. 322-336. 
[21 Blum, M., and Marques, I., "On complexity properties of 
recursively enumerable sets," J. Symbolic Logic 38 (1973) 
579-593. 
[3] Borodin, A. ,"Computational complexity and the existence 
of complexity gaps," J. ACM 2 (1972) 185-194. 
[41 Constable, R., "The operator gap," J. ACM 19 (1972) 175-183. 
[5] Davis, M., Computability and UnsoZvabiZity, ~~Graw-Hill 
(1958), New York, N. Y. 
[61 Godel, K., 
The Consistency of the Continuum HypothesCs, 
Princeton Univ. Press, Princeton, New Jersey, 1940. 
[7] Hartmanis, J., and Hopcroft, J., "An overview of the theory 
of computational complexity," J. ACM - 
18 (19711, 444-475. 
[81 Hartmanis, J., and Stearns, R. E., "Computational complexity 
of recursive sequences," IEEE Proc. Fifth Annual Symp. on 
Switching Circuit Theory and Logical Design, 1964, 82-90. 
191 Jacobs, B. E., a-ComputationaZ CompZexity, Ph.D. Thesis, 
New York Univ., Tech. Rep. IMM-408, Courant Inst., NYU, 1975. 
[lo] Jacobs, B. E.,"On 
generalized computational complexity," 
J. Symb. Logic, 42 (1) (1977) 47-58. 
[ll] Jacobs, B. E., 
"The a-union theorem and generalized primi- 
tive recursion," Trans. AMS 237 (1978) 63-81. 
[12] Jacobs, B. E., "a-Naming and aSpeedup Theorems," Notre Dame 

J. Symb. Logic, XX (2) (April 1979) 241-261. 
[13] Jacobs, B. E., " a-Speedable and non a-speedable sets," 
Can. J. Math. ,. to appear. 
[14] Jockusch, C. G., "The degrees of hyperhyperimmune sets," 
J. Symb. Logic - 
34 (1969) 489-493. 
[15] Kripke, S., 
Transfinite recursion on admissible ordinals, 
I, 11, (abstracts), J. Symb. Logic 29 (1964) 161-162. 
[16] Kripke, S., The Theory of Transfinite Recursion, unpublished 
unpublished lecture notes by A. Thomas Tymoczko. 
[17.] Marques, I., "On degrees of unsolvability and complexity 
properties, 
" J. Symb. Logic (1975) 529-540. 
[18] McCreight, E. M., CZasses of Computabte Functions Defined 
by Bounds on Computation, Ph.D. Thesis, Computer Sci. Dept., 
Carnegie-Mellon Univ., Pittsburgh, Pa., 1969. 
[19] McCreight, E., and Meyer, A,, "Classes of computable 
functions 
Defined by bounds on computation," Preliminary 
report, Proc. ACM Symp. on Theory of Computing (1969) 79-88. 
[20] Meyer, A., and Fischer, P., ~8Computational 
speedup by effec- 
tive operators: 
J. Symb. Logic 37 (1972) 55-68. 
[21] Moll, R., and Meyer, A. R., "Honest bounds for complexity 
classes of recursive functions: J. Syrnb. Logic 39 (1974) 
127-138. 
[22] Platek, R., Foundations of Recursion Theory, Ph.D. Thesis, 
Stanford, 1966. 
[23] Rabin, M. O., "Degrees of difficulty of computing a function 
and a partial ordering of recursive sets," Tech. Rep. 2, 
Hebrew Univ., Jerusalem, Israel (1960). 
[24] Rogers, H., Theory of Recursive Functions and Effective 

Computability, McGraw-Hill, 1967, New York, N. Y. 
[25] Sacks, G. E., Righer Recursion Theory, Springer, Berlin, 
to appear. 
1261 Shoenfield, J. R., 
Degrees of UneoZvabitity, North-Holland, 
Amsterdam, 19 . 
[271 Shore, R. A., 
"Splitting an a-recursively enumerable set: 
Trans. Am. Math. Soc. 204 (1975) 65-78. 
1281 Soare, R., "Computational complexity, speedable and 
levelable sets,* J. Symb. Logic 42 (1977) 545-563. 
[291 Stoltenberg-Hansen, V., 
"On computational complexity in 
weakly admissible structures," Tech. Rept. ISBN 82-553-0342-1 
Inst. of Mathem., University of Oslo. 
[30] Young, P., "Easy constructions in complexity theory: 
gap and 
speedup theorems: Proc. AMS 37 (1973) 555-563. 

CEN TRO I N  TERN AZIONALE MATEMATICO ESTIVO 
(c.I.M.E. 
A SURVEY OF SET RECURSION 
DAG N ORMANN 

A SURYEX OF SET HXCURSION. 
Dag Normann, 
University of Oslo, Norway. 
a-recursion-theory, p -recursion-theory and recursion 
in normal type-3 objects has one thing in common, one 
investigates certain notions of computability on certsin 
sets, L(*), L(p) ~ n d  
the type-1 objects I respectively. But 
while in d -  
and p-recursion theory o m  mqy carry out the 
analysis within the structure L(4) resp. L(p) , we nust e;o 
outside I in order to capture the finer points concerning 
recursion in, say 3 ~ .  
There are several ways to do this. 
One way is to follow Sacks ( this volume ) and construct 
a hierarchy for the subsets of I recursive in 'E, or in 
general, in 3 ~ ,  
F. This involves bringing in a certain' 
superstructure of sets, e.g. ordinals and subsets of I, and 
history has shown that any finer analysis of 3~ involves 
the construction on one superstructure or another. 
In this paper we will take the full and most general 
consequence of this. We will start with an arbitrary set x 
and an arbitrary relation R and we will ask : About which 
other sets do x ,  R contain perfect inforaation? An alternative 
way of putting the question is : iVhich sets are *recursivet 
in q , H ?  

It turns out that when we have answered this question 
we have not only constructed a sensible notion of set-recursion 
but we have also fully captured and generalized recursion in 
norvnal functionals. So we have given an alternative to the 
defirdtion of recursion in normal functiollals given by Sacks 
( this volutne ) . 
We will now do a bit of History-forging and develop 
Set-recursion as it ought to have beendeveloped. 
* 
We have given a relation lf and sets x = (xl, ... 3 2  
and we will just find out which, operations on 2 relative 
to R we may within reason call set-recursive. We must 
forget absolute notions of finite computations and agree upon 
the following crucial point : Once we accept a set x as an 
argument of ? set-recursive function then this function may 
think that x is finite. 
In a- and p-recursion theory we investigate r.e. sets 
nnd recursion sets but the notion of a computation is rather 
innlicit. In Sackst definition of recursion in 3~ 
we feel 
that from a notation for an Hbset Ifa and an index for a 
lst order formula p we may compute the set defined by y 
over Hi , there i a  some sort of transfintte procedure 
leading from (8,e) to the set defined. 
Here we will take the full computatio~vrl point of view. 
We will define a class of pernittable computations by induction 
over the ordinals. 
This scheaatic approach is the same aa Kleene used when 
he first defined recursion in Mgher types. 
At the botto~n we need a few combinatorial operations : 
f (2) = xi (14) is set-recursive with indcr 
<l,i,k) 

f (;) 
= xi\ x 
(i, 
jgk) is rot-rccuraivt: rith 
j 
index (2 ,i, j ,k > 
f (;) 
= [xi,xJ) (I, 
j4k) is sat-recursive with 
index ( 3  ,i, j ,k> 
X'e will describe two methods of constructing new set-recursive 
functions from old ones. In the first we really think that 
x is finite : 
If f is set-recursive with index e,, we let 
g(;) 
= ygl 
(f(y,x2, ... ,x 1 )  
be aet-recursive 
n 
with indt~x (4,e,,k> . 
Less controversial is to close the set-recursive 
functions under composition : 
If fl, ... vfn are set-recursive with indices 
el, .*. 
'en respectively and they all accept the same nuqber 
of arguments, and h is set-recursive for n arguments and 
with index d then 
.!?(?I 
= h(fl(?), . . f n ( 1 )  is set-recursive with 
index ( 5 ,d ,el, . . . ,en,k> 
We have not brought in the R yet but the sirnplest 
way to do so is just by : 
f (2) = xin R is set-recursive relative to R with 
index ( 6  ,i ,n> 
The class of functions we have defined so far is well- 
known and called the functions rudimentary in R . But we 
have taken the liberty to enumerate the llalgorithms" 
for the 
rudimentary functions by the indices and as every recursion 
3 
theorist knows, given an. argument x 
and an index e for 
an algorithm we may uniformly in 2 and e compute f e) (?) 
( {elR(;)) 
. So we add the last part of the definition : 

R 4 
f(e,?) = Eel (x) is set-recursive relative to R 
with index <7,k> 
Theoretically we have now given seven clauses in an 
R 
inductive definition of the relation {el (34) = y , and such 
notions as denght of computation and subcomputations are 
easily defined. 
We may also prove the recursion-theorem and other 
standard helpful1 results in recursion theory. 
O u r  first lemma is trivial, but it is the most 
important result about set-recursion t 
Lemma - 
There is a set-recursive function f such that given 
-b 
e,x,x then f (e,x,;) 
is defined if and only if [el (y,?) 
are defined for all y E x  , and then 
Proof - 
Let g(e,x,E'I = yk/xx[e3(~,z) 
Then g(e,x,'jZ3 = P C? Vy x Ee3 (y,3 = 16 
f is constructed from g using a rudimentary function. 
Tho following results are simple but tedious and we 
leave them for the reader : 
1. 
The function f(x) = ordinal rank of x 
is set- 
recursive. 
2. 
If x 
is infinite then w is set-recursive in x . 
3. 
We 3ay set-recursively decide if a set x 
is a natural 
nuaber or not. 
4. 
g(x) = TC(x) is set-recursive. 
5. 
If x is infinite (<=7 rank x . ) w )  then Cl(x) 
= the closure of x under finite subsets, is set- 

recursive uniforaly in x . 
6. 
If x = I end a is sn F-notsti on for H~ then 8 is 
R 
a 
uniformly set-recursive in I, a relative to Y . 
3 
6. shows that if A 6 E ,  F, a then A 
is set-recursive 
in I, a relative to F , The opposite is also true, but the 
argument involves a cod in^ machinery which we won't give here. 
Theorem 
Let A S I, a s 1 . Let Y 
bc R normal type-3 functional. 
Then A is recursive in F, a if and only if A 
is 
set-recursive in I, a relative to F . 
+ 
A 
set or class A is called semi-set-recursive in x 
relative to H if there is nn index e such that 
R 
x E A <=) re3 (x,;) 
2 0 
We then also have the following result : A G Tp(2) is 
r.e, in 3 ~ ,  
F, R 
if and only if A is semi-set-recurstvc 
in I, a relative to F . 
This shows that the r.e. deeree-theory for 3~ 
may be 
represeneed as a theory for set-recursive d~gcees. 
Our final comparison with recursion in 3~ 
comes in 
showing that we have natural alternatives to the W-sets. 
Let x be given.and assume that x is transitive and 
closed under finite subsets. Each: computation [el (F,x) 
for 
4 
Y e X  has a certain length 
11 <e,?,x)l\ . Let 
M,(y) 
= [ z  : 3 e [e\(y,x) = z A Jl<e,y,x>l\ 
I Q ]  
Let M, 
= u 
Mc(y) . Then each I, 
is recursive in x and 
Y G X  
some y c x ,  and they will fully play the role of H-sets. 
We will not go deeply into degree-problems here, that 
is dealt with by Sacks. For each infinite set x with 
suitable closure-properties there will be the following 

natural degree-sfructure to investieate say on 
X 
g l  = ( a  : 38, J G  x I
e
x
>
 =.c 3 
using 
R - 
set-recursive reducibility 
b - 
set-recursive reducibility modulo elements of a given 
z + x  
C - 
set-recursive reducibility modulo elements of X: 
( corresponding to Sacks* absolute version of Post's 
problem). 
Thls ought .t;o be a rich area for future research. 

CENTRO I N  TERSAZIOh ALE MATEMATIC0 ESTIVO 
(c.I.M.E. 
PRIORITY ARGUMENTS I N  HIGHER RECURSION THEORY 
GERALD E. 
SACKS 

Centro Internazionale Matematico Estivo 
Priority Arguments in Higher Recursion Theory 
Gerald E. Sacks 

1. 
Regularity of a-R.E. Degrees 
This is the first of six lectures on priority arguments in 
higher recursion theory. The term "priority argument" refers to 
a mode of combinatorial reasoning introduced independently by 
Friedberg [l] and Muchnik (21 to obtain a positive solution to 
Post's problem, the existence of two recursively enumerable sets 
such that neither is recursive in the other. I will try to show 
how their idea lifts to three generalizations of ordinary recur- 
sion theory. The three are: 
a-recursion, where a is a C1 
admissible ordinal; 8-recursion, where 0 
is little more than 
a limit ordinal; and Kleene recursion in F, a normal object of 
type 3. 
Some of the results to be described are new and, in the 
case of Kleene recursion, not hitherto announced. Others are old 
but viewed, it is hoped, in the light of a new day. 
One obstacle encountered in all three generalizations is the 
failure of typical recursively enumerable objects to be regular. 
Today's lecture focuses on that problem in the case of a-recur- 
sion theory. 
But first a whirlwind review of the fundamentals of a- 
recursion. For any set x, let Fod(X) be the set of all first 
order definable subsets of X. 
L, G6del's universe of construc- 
tible sets, is definable by iterating Fod through the ordinals. 

L(i) 
= V { L ( ~ )  1 6 < A} 
(A is a limit). 
L = V { L ( 6 )  1 6 is an ordinal}. 
The Levy hierarchy of formulas of ZF is as follows. A formula 
is A. 
(also no 
or Co) if all of its quantifiers are 
bounded. A formula is Cn if it is of the form (ExIG, where 
G is Bn-l. A formula is Bn if it is of the form (x)G, 
where G is 
An 
is Cn n ". 
a is said to be C1 admissible (or simply admissible) if 
L(a) satisfies C1 replacement. To elaborate, let f be a 
function from L(a) into L(a) whose graph is definable over 
L(a) by means of some C1 
formula with parameters in L(a) . 
Then f [a] 
(= {f (b) I b E a)) 
is a member of L(a) for all 
a E L(a). 
A function g : a --> 
a is said to be a-recursive if the 
graph of g is C1 over L(a). Suppose A C a. A is said to 
be: a-recursive if the characteristic function of A is a- 
recursive, a-recursively enumerable if A is Z1 over L(a), 
and a-finite if A E L(a). 
If g is a-recursive and H is 
a-finite, then g[Hl 
(= {g(x) I x E HI) is a-finite. 
This 
last is nothing more than a restatement of the C1 
admissibil- 
ity of L(a). If A is a-recursive and H is a-finite, then 
A n H is a-finite. 
If A # 0, 
then A is a-recursively 
enumerable iff A is the range of an a-recursive function. 
There is a natural, one-to-one correspondence between a 
and L(a) that is A1 
over L(a). 
Standard arguments based on 
this correspondence yield: 
(a) an effective coding of the a- 
finite sets by ordinals less than ar and (b) an enumeration 

theorem for the a-recursively enumerable sets. (a) means there 
are a-recursive functions t and v withthe following proper- 
ties: for each 6, let Kg be the a-finite set 
It(%) I x < ~(6)); then {K6 1 6 < a} is an enumeration with- 
out repetitions of all a-finite sets. 6 is the canonical 
index of the a-finite set Kg. (b) means there exists a uni- 
versal, a-recursively enumerable set W. For each a-recur- 
sively enumerable set A, there exists a 6 such that 
A = {x I <x,6> E W}; 
such a 6 is termed an index for A, and the situation is 
summed up by saying A = W6. 
From now on let H, J, K, ... denote a-finite sets. A 
function f : a -> 
a is said to be weakly a-recursive in a 
set B c a if there exists an a-recursively enumerable R 
such that f(6) = y iff 
(1) 
(EH) (EJ) [<H,J,G,y> E R & H c B & J c a-B] 
for all 6, y < a. The matter is rendered in symbols by 
f Gwa B. The enumeration theorem for a-recursively enumerable 
sets yields one for weak a-recursive rednction procedures. 
{~}~(6) is said to be defined and equal to y if (1) holds 
with R replaced by WE. Thus f gwa B iff there is an E 
B 
such that f = { E }  . A is (by definition) weakly a-recursive 
in B if CA , the characteristic function of A, is weakly 
a-recursive in CB. Driscoll [ 3 ]  showed that there exists a 
C1 admissible a such that Gwa , restricted to the a- 
recursively enumerable sets, is not transitive. Shore [ 4 1  

characterizes all such a's. 
The following notion of reducibility is transitive. A is 
.a-recursive in B; in symbols A <a B, if there exist 
a- 
recursively enumerable R and S such that for all a-finite 
K : 
(2) 
K C A <-> 
(EH) (EJ) [<H,J,K> E R & H C B & K C a-B] 
and 
(3) 
K c a-A <-> 
(EH) (EJ) [<H,J,K> E s c H c B L K c a-B]. 
Clearly A 
B -> 
A <wa B, and <a is transitive. A and B 
are said to have the same a-degree (in symbols A E B) if 
a 
A < B and B <a A. 
a 
Proposition 1.1. 
Assume A is a-recursively enumerable. Then 
A < B iff there exists an a-recursively enumerable S satis- 
a 
fying clause (3) of the definition of Go. 
Proof. Since A is a-recursively enumerable, the set 
R =  {K I K C A )  
is also a-recursively enumerable. Then R, 
slightly modified, 
will satisfy clause (2) of the definition of <a. 
0 
Proposition 1.2. 
Assume A is a-recursively enumerable. Let 
A* be {6 1 K6 n A # 0). 
Then A* ra A, 
and 
for all B. 
Proof. There exists an a-recursive function t such that 

for all y. 
Then 
And so by 1.1, 
for all B. 
The substitution of A* (respectively A) for B 
in (1) yields A <a A* (respectively A* Ca A). 
A is said to be regular if A n 6 is a-finite for every 
6 < a. 
An 
a-recursive set is of necessity regular. An 
a- 
recursively enumerable set A need not be regular, but the main 
result of today's lecture is that A must have the same a- 
degree as some regular, a-recursively enumerable set B. 
Such 
a B has a dynamic property that is extremely useful in prior- 
ity arguments. Let f be an a-recursive enumeration of B 
without repetitions. 
(Assume B is unbounded.) 
Then 
In other words, for each a-finite K, there is a stage in the 
enumeration of B after which no element of K is added to B. 
If not, there would be a one-one a-recursive map of a onto 
the a-finite set B n K. 
Cf. 1.5 ( 2 ) .  
Let A c a, and relativize Godel's construction of L to 
L(A). Thus L(~,6+1) is the set of all first order definable 
subsets of <L(A,G),E,A>. 
(The predicate x E A is treated as 

atomic along with x E y.) 
Then A is regular iff 
L(A,a) = L(a). 
In addition, 
B Gwa A iff B is A1 
definable 
over <L(A,~),E,A>, where B is arbitrary and A is regular. 
* 
The C1 projecturn of a, denoted by alpa or a , is 
the least y 
such that 
1-1 
(Ef) [f is a-recursive 
& 
f : a into> 
y]. 
* 
a 
makes it possible to lift some combinatoric tricks from w 
to a. 
Note that there exists a nonregplar, a-recursively 
* 
enumerable set iff a < a. 
* 
Proposition 1.3. 
a 
is the least 
f3 
such that some a-recur- 
sively enumerable subset of 8 
is not a-finite. 
Proof. Suppose A is a-recursively enumerable and A C 6 for 
* 
some 6 < a . If A were not a-finite, then any a-recursive 
enumeration of A without repetitions would define a one-one 
map of a into 6. 
* 
Let f : a -> 
a 
be a one-one, a-recursive map. 
Then the 
range of f is a-recursively enumerable but not a-finite. 
R. B. Jensen has shown by means of a collapsing argument 
that 1.3 remains true when a .is replaced by an arbitrary limit 
ordinal. 
Theorem 1.4 (Sacks [S]). 
Let A be a-recursively enumerable. 
Then there exists a regular, a-recursively enumerable B of 
the same a-degree as A. 
Proof. Following Maass [6]. It is safe to assume 0 E A. 
Let 
A* be as in 1.2. 
Let f : a -> 
A* be a one-one, onto, 

a-recursive map, and.let 
p : a -> 
a 
be a one-one, 
a- 
recursive map. 
The desired B is defined by: 
<w,x> € B 
i f f  
(Ey) Ix < y 
& 
pf (y) < pf (x) 
h 
f (y) < w l .  
To see t h a t  B is regular, f i x  
T 
and define <w,x> E B~ 
by 
Y 
Note t h a t  
Suppose 
B n T~ 
is not 
a-finite. 
Then there e x i s t s  an 
i n f i n i t e  sequence y < y1 < y2 < ... such t h a t  f o r  a l l  i < j, 
But then (1) yields an infini.te descending sequence of ordinals. 
* 
To show 
A <a B, 
it s u f f i c e s  by 1.2 t o  show 
A 
Gwa B. 
Fix 
z. 
The set 
is a - f i n i t e  by 1.3, and s o  p'l 
[K] is a-f i n i t e .  
It follows 
there is a 
yo 
such t h a t  f o r  a l l  y, 
Let 
xo 
be the unique y > yo 
t h a t  minimizes 
p f ( y ) .  Then 
Note t h a t  f o r  a l l  x r  

Thus 
2 
TO prove B <a A, let K be an a-finite subset of a , 
and define 
K = 
u 
( { v I v < w  t pv<pf(x))-f[x]). 
<w,x>EK 
K 
is a-finite, and 
P 
Exercise 1.5 
(1) A predicate P (x,y) is uniformizable by a predicate 
Q(x,y) if 
(x) (y) fQ(x,y) -> 
P(x,y) I, 
and 
(XI [ (Ey)P (xry) -> 
(Ely)Q (x,y) 
I 
Assume A is regular. 
Show each P(x,y) Gwa A can be uni- 
formized by some Q(x,y) 
A. 
(2) Let f be an a-recursive enumeration of B without 
repetitions. Show 
(6) (Eu) (T) [T > u -> 
f (T) > 61 
holds iff B is regular. 

2. 
Existence of Hyperregular Sets 
Suppose A c a. 
A is said to be hyperregular if for every 
f <wa A and 6 < a, it is the case that 
Note that if A is hyperregular and B <a A, then B is 
hyperregular. Hyperregularity does not imply regularity, but 
note well the next lemma. 
Lemma 2.1. 
If A is a-recursively enumerable and hyperregular, 
then A is regular. 
Proof. Fix 6 to see A n 6 is a-finite. Assume A is the 
range of some a-recursive function g. 
Let 
uo(g(a) = X) if x E A 
f (x) = 
if x $ A. 
Since f <wa A, 
there is a y such that f (61 c y. 
Then 
A n 6 is g[yl n 6. 
13 
Lemma 2.2. 
A is regular and hyperregular iff 
(f) (6) 16 < a 
& 
f 
A --> 
f r 6 is a-finite] . 
Proob. Suppose A is regular and hyperregular. ~ i x  
6 < a 
and f <wa A. 
There exists an a-recursively enumerable R 
such that for all x, y < a: 
f (XI = y iff 

(1) 
(EH) (EK) [<H,K,x,y> E R 
& 
H C A 
& 
K C a-A]. 
According to exercise 1.5 (I), the regularity of A implies 
that any P(x,y) <,, 
A can be uniformized by some 
Q(x, y) 
A. 
It follows there are functions ElX, 
A 
such that for all x, there is a y such that 
Since A is hyperregular, there is a y such that 
A n y is a-finite, since A is regular. If A n y is 
substituted for A in (l), the result is an a-finite defini- 
tion of f r 6. 
Today's priority argument requires some familiar combina- 
toric considerations in an effective setting. Suppose B < a. 
B 
is an a-cardinal if there is no one-to-one, a-finite 
correspondence between 8 
and some 6 < 6 .  
In short 
L (a) [ $ 
is a cardinal] . 
Note that if olpa < a, then alpa is the greatest a-cardinal. 
If an a-finite set A has a-cardinality less than ulpa, 
then every a-recursively enumerable subset of H is a-finite 
by Proposition 1.3. 
An a-cardinal 
is said to be regular if there is no 
a-finite function with domain less than f3 
and range an un- 
bounded subset of 0. 
Otherwise 6 is singular. The next 
lemma is useful in many priority arguments, but is not needed 

today, so its proof is left for the reader. A function f C a* 
is said to be lI: 
if it is definable over L(a) by a 111 
formula. An a-cardinal 6 is 801 regular if there is no 
lI: 
.function with domain less than 6 and range an unbounded sub- 
set of 6. 
Lemma 2.3. 
If f3 
is a regular a-cardinal, then 0 
is IT: 
regular. 
An a-recursively enumerable set C is called complete if 
B < C for every 6-recursively enumerable B. 
The existence 
a 
of such a C, and the fact that it cannot be a-recursive, are 
consequences of the enumeration theorem. An a-recursively 
enumerable set is intermediate if it is neither complete nor 
a-recursive. 
Theorem 2.4. 
There exists an intermediate, hyperregular, a- 
recursively enumerable set. 
Proof. Let p : a -> 
a * 
be one-one, into, and a-recursive. 
Define 
t fl 
otherwise 
* 
for each 
E < a*. 
Thus {R€ I E < a. ) 
is a simultaneous a- 
recursive enumeration of all a-recursively enumerable sets. 
[clA is defined similarlyf thus 

is defined 
lclA(x) is I 
undefined otherwise. 
* 
for all E < a 
and x < a. 
It is helpful to think of an a-recursively set R as the 
union of a noncontracting, a-recursive sequence of a-finite 
sets. Let 
XEU I RE be an a-recursive function such for 
each 
E, 
R: 
is simply that part of RE enumerated prior to stage a of 
the simultaneous enumeration of RE (E < a ) .  
If B is an a- 
recursively enumerable set, then [E ] ( Y )  
can be a-recursively 
approximated as follows. Let B<' 
be the set of all ordinals 
enumerated in B prior to stage a of the enumeration of B. 
Then 
is defined and equal to 6 if there exist H and J such that 
(In order to make (1) single valued, take the "least" <H,J,y,G> 
that satisfies (2). In order to make (1) a total function of 
E, CJ 
and y, give (1) the value a if (2) cannot be satis- 
fied.) Thus (1) is an a-recursive function that converges to 
[ E ] ~ ( ~ ) .  
To be precise 
[ E ] ~ ( ~ )  
is defined and equal to 6 
only if for all sufficiently large o r  the value of (1) is 6. 

To prove the theorem a set B will be a-recursively 
enumerated with three sets of requirements in mind. 
(3) 
a-B is an unbounded subset of a. 
(4) 
If WE is unbounded, then 
JE B + Z. 
(5) 
For certain yls, the value of 
[ c ] r  (y) will be 
preserved. 
(3) and ( 4 )  combine to make B non-a-recursive. 
A re- 
quirement of type (4) is said to be positive because it is met 
by adding an element to B. 
Requirements of type (3) or (5) 
are said to be negative because they are met by keeping elements 
out of B. 
The negative character of (5) arises as follows. 
The computation of (1) is based on some H and J such that 
H C Ba and J C a-Ba. 
(1) is preserved by excluding all mem- 
bers of J from 3. 
Whenever the potential conflict between negative and posi- 
tive requirements becomes actual, a decision is made in favor of 
the requirement of higher priority. Priorities are indexed by 
* 
ordinals less than a , and "higher" means less than with res- 
pect to the usual wellordering of the ordinals. 
The construction of B consists of simultaneous a-recur- 
sive definitions of Xa I Ba, Xac I r(a,~) and Xac I m(a,c). 
Stage a. 
r (arc) is the least B 
such that 

6 
6
,
 
if 6 < a, and 
m(6,c) is designed to protect the computation of 
if (6) has a value less than a. Thus m(a,e) is the strict 
least upper bound of all ordinals in some J needed to satisfy 
( 2 )  when y = r(u,c). 
Otherwise m(u,c) = 0. 
Stage a ends with an attempt on a positive requirement. 
Let h be an a-recursive function that enumerates each ordinal 
* 
less than a 
unboundedly often. Suppose h(a) = E,. 
If 
~z~ n 8
'
'
 
= 8, and if there exists a 
such that 
then put the least such 6 
in B. Otherwise B' 
= B<'. 
The clause R 
n B<' 
= 8 is important. It implies: 
€0 
( 8 )  
For each c there is at most one stage a at which 
an ordinal is added to B for the sake of positive requirement 
( 4 ) .  
If 6 
is added to B at stage a and 6 < m(o,c), 
then 
positive requirement E is said to be injured at stage a. Let 
IE = {u I positive reg. E is injured at stage a). 

IE is a-recursively: enumerable. The assignment of priorities 
implies 
(9) 
IE is a-f inite and a-card (IE) < a-card ( e l .  
To prove (9) fix E < a . (7) yields h(u) < c 
for all 
a e IE. h[IEl is a-recursively enumerable, hence a-finite by 
1.3. 
h f IE is one-one by (8). 
So I& is a-finite, and has 
a-cardinality at most that of E. 
The function Xu I r(o,&) is nondecreasing. As u in- 
creases, r(u,~) changes its value only a-finitely many times 
by the same reasoning used to prove (9). Thus 
r(E) = lim r(ut~) 
u 
exists for each E < a*. TO prove (3) observe that r ( ~ )  
9 B 
and that r(py) > y for all Y < a- 
To prove (4) it suffices to show 
{ m ( a , ~ ~ )  
I 
E~ < E 
& 
u < a 1  and 
are bounded sets. The bound on R is established as in the 
proof of (9). The bound on m is more delicate. There is a 
stage uo such that for all E~ < E: 
- 1 
- 1 
p c0 defined --> 
p E~ < uo , 
and no element of R 
is added to B at or after stage uo 
0 
for the sake of requirement (2) as in clause (7) above. Then 
r
,
 
= r u o , c 0  for all E~ < E and o > a,. 

For each 
E < E, 
at any stage a > a. 
, rn(a,~~) 
0 
protects the computation (if there is one) of 
otherwise rn(u,co) = 0. 
If there is a computation of (lo), then 
it can never be subsequently injured, because all injuries to 
preservation (or positive) requirement c0 occurred prior to 
stage oo. 
For each eO < E, 
let u(E,) 
be the least a > a
.
 
, 
if there is such a a, such that a computation of (10) exists. 
The set of all such u(c0) corresponds to an a-recursively 
enumerable subset of c, and so is a-finite by 1.3. 
Let 
T be 
its supremum. Then rn(c,,~) = rn(~~,a) for all 
E~ < E and 
a > T. 
The hyperregularity of B will follow from (11). 
(11) 
If A is a-recursively enumerable but not hyperregu- 
lar, then there exists a regular a-cardinal 
f.? 
and a function 
f GWa A such that f r 8 is not a-finite. 
The proof of (11) is left as an exercise. 
(11) will be 
joined with (12) to show B is hyperregular. 
(12) 
Let 
f.? 
be a regular 8-cardinal, and assume [ ~ ] ~ ( y )  
is defined for all y < 6. Then there exist unboundedly many 
a's 
such that 
is defined for all y < 8. 

The proof of (12) is a closed unbounded sets argument that 
has been applied in the past by S. Friedman, D. Normann and 
other recursion theorists. Let h : 8 -> 
8 be an a-finite 
function such that for each 6 < 0, h'l(6) 
is an unbounded 
subset of 8. 
An a-finite function t : 8 -> 
a is defined by 
recursion. Let t (6) be the least a greater than 
sup {t(p) I Q < 6) and such that (13) is defined with y equal 
to h(6). 
t(6) exists since (13) equals [clB(y) for all 
sufficiently large a. 
a 
Let a, = SUP (t(6) I 6 < 8). 
Then (13) is defined for all 
y < 0 
when a = a*. 
To check this last assertion, fix y < B. 
The set (6 1 6 < 8 & h(6) = y 
has the same a-cardinality as 8. 
Thus there is a 6-sequence T of a ' s  
whose limit is aB and 
such that (13) is defined for every a in the sequence. For 
* 
the moment assume a < a. 
Since a 
is either regular or the 
limit of regular a-cardinals, it is safe to assume c < 8. 
The 
enumeration theorem for the a-recursively enumerable sets has 
all of the elementary properties associated with the enumeration 
theorem for ordinary recursion theory. It follows there exists 
an a-recursive function q such that 
for all y < fi 
and all x < a. 
Since 
E < 8 and f3 is an a- 
cardinal, it is not difficult to arrange 
(15) 
q(c,y) < 8 for all y < 8. 
By (14) a decision at stage a 
to protect the computation of 

is also a decision to protect the computation of (13). It 
follows from (9) that the set of stages a such that (13) is 
defined at stage a and undefined at some stage T > a is a- 
finite and has a-cardinality less than $. 
Since 0 
is regu- 
lar, it must be that (13) is defined by a fixed computation for 
all sufficiently large a in the f3-sequence T. 
But then that 
same computation will define (13) when o = Of3 ' the supremum 
of T. 
To finish the proof of (12). it is,necessary to remove the 
* 
assumption that a < a. 
Suppose a = a. 
Then there is a 
* 
yo < a 
such that q(e,y) < yo for all y < 6. 
It follows 
that for all sufficiently large o r  
(16) will not be injured 
for any y < 8, and so (13) will have attained its final value 
for all y < 8. 
* 
To see that B is hyperregular, fix E < a and assume 
[elB(y) is defined for all y < B. 
There exists an s(e,y) 
such that 
for all x. 
The left side of (17) is defined iff [ c ] ~ ( ~ )  
is 
defined for 
y < 8 by a single a-finite computation. 
By 
(13) there are unboundedly many a such that 
is defined. It follows from (9) that some a-finite computation 
of (18) is never injured. Consequently the right side of (17) 
is a-finite, and so B is hyperregular by (11). 

To show B is not complete, define an a-recursively 
enumerable C as follows. At stage a > 1 of the enumeration 
of C, add r(a,~) to C if the value of (6) is 1; other- 
wise 6' 
= c<'. 
Fix E < a* to see C is not weakly a- 
recursive in B via 
E. 
Clearly 
It suffices to show 
Let o be the first stage such that (6) has the value 0 
and 
r(u,~) is r(~). Since r(a,s) = r(e), the definition of 
XUE I r(a,e) implies that r(a,c) 9 C and that the computation 
of (6) at stage a will not be injured at any later stage. 
Thus (19) holds. 
The above is only a firsk step towards priority arguments 
in a-recursion theory, but it is a first step in the right 
direction. Deeper results are obtained with the help of O: 
and C: 
projecta and cof inal sequences, and their a-recursive 
approximations. 
Exercise 2.4. 
(i) Prove Lemma 2.3. 
(ii) Prove (11). 

3. 
Recursion on Inadmissible ordinals 
8-recursion theory is the study of recursion theory on 
arbitrary initial segments of L. 
The proper setting for 8- 
recursion theory is the Jensen J hierarchy, but the Gbdel 
hierarchy of the previous two lectures will suffice for present 
purposes. From now on B is a limit ordinal. The universe of 
recursion theory on fj is L(8). 
Since 8 need not be C1 
admissible, there need not be a natural wellordering of L(f3) 
of ordertype B. 
The standard wellordering of L (8) , origi- 
nated by Gbdel, has ordertype w8 (ordinal exponentiation). It 
possesses effectiveness and uniformity properties that are 
essential to recursion-theoretic arguments. In order to exploit 
them, it will be necessary in the course of a construction to do 
more than one thing at each stage. 
Let A c I,(@). 
A is said to be p-recursively enumerable 
if A is C1 definable over L(B) 
(with parameters in L(8) ) . 
A 
is p-recursive if both A and L(8)-A 
are 8-recursively 
enumerable. A is @-finite if A 
L(f3). 
Thus the basic 
definitions of 8-recursion theory differ from those of a- 
recursion theory only in that the universe is taken to be an 
initial segment of L rather than an initial segment of ordi- 
nals. A function f : L(B) --> 
L(B) is 8-recursive if its 
graph is C1 over L(8). 
Note that the intersection of a 8- 
recursive set and a 8-finite set need not be f3-finite. This 

last is perhaps the most bitter pill that must be swallowed by 
the would be 0-recursion theorist. 
Suppose A is 0-recursively enumerable. An enumeration 
of A is a 0-recursive function f : 0 -> 
L(0) such that 
A = U {f (6) 1 6 < 0). 
There is in general no hope of enumerat- 
ing A 
one element at a time as in a-recursion theory. 
The notions of < 
(weakly 0-recursive in) and < 
(0- 
w0 
B 
recursive in) are defined as in Lecture 1 with L(a) replaced 
by L(B). 
If 0 is C1 admissible, then B is 0-recursive 
iff B <0 0, where 0 
is the empty set. If 0 is not C1 
admissible, then it can happen that B is 0-recursive, but not 
B is said to be tamely 0-recursively enumerable (t.r.e.) 
if {H I H C B} is @-recursively enumerable. (H, J, K, ... 
denote 0-finite sets.) 
In the admissible case every r.e. set 
is t.r.e. 
If B is 0-r.e., but not t.r.e., then it is diffi- 
cult to approximate {clB in the style of Lecture 2, equation 
( 2 ) ,  since some a-finite H contained in B may not be con- 
tained in B<" for any a < 0. It turns out that failures of 
tameness are numerous and unavoidable when 0 is inadmissible, 
and so some new tricks are needed to do priority arguments In 
the inadmissible case. 
Two significant parameters are alcf(0) (the sigma one 
cofinality of 0) and alp(B) 
(the sigma one projectum of 0). 
alcf(0) is the least y < B such that for some 0-recur- 
sive function f, f[yJ is an unbounded subset of B. 
alp(B) 
(or simply B*) is defined by substituting 0 for 
a in the definition of a 
in Lecture 1. 

Maass [6J suggested the following division of inadmissible 
$Is, and it has proved useful. 
8 is said to be weakly inadmissible if B > olcf(6) > f3". 
Many, but far from all, ideas carry over from the admissible 
case to the weakly inadmissible case. For example, the solution 
to Post's problem carries over, but not the regular sets theorem. 
* 
$ 
is said to be strongly inadmissible if $ > ulcf(8). 
S. Friedman [ 7 ]  has shown that Post's problem has a positive 
solution, as in the admissible case, for some strongly inadmis- 
sible Bus, and a negative solution for others. 
Some of Jensen's fine structure results for L appear to 
play a necessary part in $-recursion theory. Define onp ($1 , 
the sigma n projectum of $, 
by replacing "6-recursive" in 
the definition of $* 
by "P:". 
Jensen has shown by a series 
of collapsing arguments that 
(1) 
If A s t: 
and A c 6 < onp(B), 
then A E L($). 
Clearly (1) is a powerful generalization of proposition 1.3, 
which was proved by purely dynamic (or combinatoric) methods. 
The trouble with collapsing arguments is that they do not as a 
rule relativize from L($) to L($) with an additional predi- 
cate A, that is the structure <L(A, $) ,€,A>, where A c L(8). 
Dynamic arguments do relativize. 
(1) can be proved by dynamic 
means if it is assumed that oncf ( $ 1  > unp ($1 . oncf ( B )  
is de- 
fined by substituting Z: 
for a-recursive in the definition of 
alcf (13). 

A 0-cardinal, w before, is an ordinal y < B 
such that 
L(B) 
[y is a cardinal]. An important consequence of (1) is 
the fact there must be a greatest B-cardinal, denoted by gc(B), 
if B 
is inadmissible. 
It canshappen that. B > gc(B) > B*. 
Let 
be the least y < 8 such that there exists a one- 
one, B-recursive map of y onto a. 
Proposition 3.1 (S. Friedman [ 7 1 ) .  
8 = max(8*,alcf (B) 
1 .  
A 
Proof. 
If B is admissible, then B = 6 = alcf (B) . Let B be 
weakly inadmissible. 
(The strongly inadmissible case is left to 
the reader with a warning that the following does not work.) 
Let 
g be a strictly increasing 8-recursive function with domain K 
(= alcf (8) ) 
and range unbounded in 8. Let p be a one-one, 
B-recursive map of B 
into B*. For each 6 < K, let p6 be 
that portion of the graph of p enumerated prior to stage g(6) 
of the natural enumeration of L(B). 
Define 
H6 = domain p6 - U {domain py I y < 6). 
The weak inadmissibility of B makes it possible to modify g 
without destroying its $-recursiveness so that the 0-cardinal- 
* 
ity of H6 is 6 . Let t6 be the least 8-finite, one-one 
* 
map of H6 onto B . ("Leastn means least with respect to the 
natural enumeration of L (8) . ) 
Define 
Then h is a one-one, B-recursive map of 6 onto 
K x 
. 0 
The one-to-one correspondence between alcf(B) and B, 
provided by 3.1 when 
B is weakly inadmissible, is extremely 

useful. A construction having the form of a C1 recursion, 
normally done in 6 steps, can now be done in alcf($) steps. 
It will then follow that the entire construction up to any 
intermediate stage takes place in some bounded part of L(B), 
the universe of the construction. Thus some vestige of 
1 
admissibility is retained in the weekly inadmissible case. This 
trick goes back to Driscoll's density theorem for metarecursion 
theory [ 3 ] ,  and is central in Shore's density theorem for a- 
recursion theory 181 . 
Assume A is a regular subset of L(B). 
The jump of A, 
denoted by A', is the complete (or universal) C1 set for the 
structure <L(B),E,A>. 
(Remember that the additional predicate, 
x E A, is treated as atomic.) If 6 = w ,  
then A' is simply 
the familiar Turing jump of A. The regularity of A 
has 
several helpful consequences: L(A,f3) = L(B); 
a predicate is 
A1 
over <L(@),c,A> if and only if it is weakly 6-recursive 
in A; and predicates of the latter sort can be uniformized by 
predicates of that sort. Cf. 1.5 (1). 
Further assume 6 is inadmissible over A, that is 
<L(B),E,A)> is inadmissible. The half-jump of A, denoted by 
A~'*, 
was discovered by S. Friedman in the course of studying 
Post's problem in the inadmissible case. It is in one view the 
complete A1 
set for the structure <L(B),E,A>, and so viewed 
has no counterpart in ordinary recursion theory. Let alcfA(B), 
A 
alpA(B) and BA be the relativizations of alcf (B), alp(6) 
A 
and 6 obtained by substituting "weakly B-recursive in A" 
for "6-recursive" in the absolute definitions. Let f Gw6 A 
be a function with domain alcfA(B) and range unbounded in B. 

is defined by 
<E,X,U> E A 1/2 
A 
<-> 
<L(f(6)) ,&,A> 
[{el (x) is defined], 
where E, x < 0 and 6 < olcfA(@). 
({rlA(x) is defined as in 
Lecture 1.) 
Theorem 3.2 (S. Friedman). Assume A is regular and B 
is 
inadmissible over A. 
Then 
(1) All2 CW0 A. 
(2) 
B CwB A -> 
B < A 
0 
( 3 )  A' GwB A1/2 
( 4 )  
A <8 All2 <@ A'. 
Proof. To prove (2), choose so and el so that 
A 
x E B <-> 
{co} (x) is defined, and 
A 
x 9 B <-> 
{el} (x) is defined. 
Then 
2 
1/2 
K c B <-> 
{ E ~ } ~  
x K x K~ C f3 
x K~ - A , 
and 
J C 8-B <-> 
J x cA C 02 x K - 
A 
where 
K~ 
is ulcfA(B). 
( 3 )  follows from 
x 9 A' - { x
A
(
 
(x) ) is undefined 
1 
A 
1/2 
- {(x),} 
x{(x)~} x K
~
C
 
@2 x 
A . 

TO prove (4) suppose All2 4@ A. 
Then by ( 3 ) .  
A' Cwg A, 
an impossibility by the usual diagonal argument that shows the 
Turing jump of A is not A1 
in A. 
Finally suppose 
A' < All2. 
Let C: 
be the complete Z2 set for <L(@),€,A>. 
6 
It will be shown in a moment that C$ 
GWB A'. 
Then cA 4 All2, 
2 wB 
and so for some B-recursively enumerable R, 
~ h u s  C
:
 
is A2 
over ( 6 )  
A
,
 
an impossibility by the 
usual diagonal argument that shows the complete C2 set is not 
A2. 
TO verify C; 
Gwg A', 
let R"(X,~,~) be a predicate 
A. 
over <L (6) ,€,A> such that 
Then 
According to 3.1 (relativized to A) there is a g GwB A such 
that g is a one-one map of kA 
onto 8. 
Then 
There exists xo , a @-recursive function of x, such that 
A 
x,y E A' <-> 
{x0) (y) is defined. 

A 
A 
Let {xl} (2) = {x0}. (g(z)). Then 
6 
<--> 
{xl} x BA C A'. 
0 
There is a paradoxical element in the above proof, namely 
the observation that < , the complete Z2 set (over A 
is 
weakly $-recursive in A'. 
It is tempting to identify C: 
with A", 
and then conclude (falsely) that A" GwB A'. 
But of 
course admissibility of 0 over A is needed to show < is 
equivalent to A". 
It follows from (1) and (2) of Theorem 3.2 that A 1/2 
is 
well defined on 0-degrees (i.e. the 0-degree of A determines 
the B-degree of A~"), 
and that A 'I2 
is rightfully called 
the complete Al 
set relative to A. 
( 4 )  yields a weak positive solution to Post's problem for 
L (0) . Let A = 0. 
Then 0112 is a 0-recursive set such that 
S. Friedman 191 has shown: if 0 = uL *w: , then o1I2 is the 
1 
only intermediate 0-recursively enumerable degree. His remark- 
able negative result demonstrates the impossibility of priority 
arguments in highly inadmissible situations. On the other hand 
he has obtained a strong positive solution to Post's problem 171 
via a genuine priority argument that succeeds for a large class 
of strongly inadmissible B's, 
in particular those 0's 
such 
that f3* is regular with respect to all 0-recursive functions. 
The next lecture will include his solution to Post's problem 
when a is weakly admissible. 

The proof of 3.2 (3), slightly modified and with A = 0, 
shows that every tamely 0-recursively enumerable set is 8- 
recursive in 0 l Y 2 .  
W. Maass has unearthed a great wealth of 
useful information concerning tame enumeration and regular sets 
in the weakly inadmissible case. 
Some of his results are as 
follows. 
Theorem 3.3 (Maass [6]). Assume 0 is weakly inadmissible and 
b is a $-degree. 
Then (i) , (ii) and (iii) are equivalent. 
(i) b contains a tamely 0-recursively enumerable set. 
(ii) b contains a 0-recursive set. 
(iii) b contains a regular, recursive, t. r. e. set. 
Theorem 3.4 (Maass [6]). Assume 0 is weakly inadmissible and 
b is a 0-degree. 
Then (i), (ii) and (iii) are equivalent. 
(i) b contains a regular 0-recursively enumerable set. 
(ii) b contains a 0-recursively enumerable set, and 
either 0112 4: b or 0 is weakly admissible over 0112. 
(iii) b contains a 0-immune B c L(o1cf (0)) such that B 
is a regular subset of L(olcf(B)) and is tamely 0-recursively 
enumerable over some A, 
where A c L(ulcf(B)), A GB B and 
A is tamely 0-recursively enumerable. 
B is 0-immune means: if K c B or K c L(alcf(0)) - B, 
then K E L (olcf (0) 
) . Clause (iii) of 3.4 is difficult to 
comprehend at first. 
In essence it says (modulo degrees) that 
being 0-r.e. is the same as being tamely 0-r.e. over something 
tamely 0-r.e. 
It follows that the construction of a 0-r.e. 
set can be approached somewhat indirectly in the weakly 
inadmissible case. 

Corollary 3.5 (Maass's Regular Sets Theorem) . Assume 8 
is 
weakly admissible over 0 and ol/*. 
Then each $-recursively 
enumerable set has the same $-degree as some regular $- 
recursively enumerable set. 
Corollary 3.6 (Homer & Sacks 1101 . Assume $ 
is weakly 
admissible over 0 and o1I2. Then the $-recursively enumer- 
able degrees are dense, that is between any two that are compar- 
able there is a third. 
3.6 is almost immediate from 3.4 and the proof of Shore's 
density theorem for the admissible case [8]. One aspect of the 
matter will be discussed in the next lecture. Note that the 
hypothesis of 3.6 holds when 
$ 
is admissible. Today's final 
result applies some of the thinking behind 3.3 to characterize 
the half-jump. 
Theorem 3.7 (Homer & Sacks [lo]). Assume $ 
is weakly inadmis- 
sible over 0, and weakly admissible over o ~ / ~ .  
Let b be a 
$-degree. Then (i) and (ii) are equivalent. 
(i) b is 8-recursively enumerable, and o
~
/
~
 
< b. 
(ii) There exists a tamely $-recursively enumerable degree 
1/2 
a such that al" 
= b and a < 0 . 
The proof that 3.7 (i) implies 3.7 (ii) is of course a 
priority argument. Time does not allow much discussion of its 
details. One point is worth singling out. The assumption of 
weak admissibility of 
$ 
over o1I2 not only provides a regu- 
lar representative for b, 
but also help to control the 8- 
recursive approximations of {€la 
needed in that part of the 

argument that insures 0112 $ a. Corollary 4.2 further 
clarifies the significance of weak admissibility over 0112. 
Maass [6] has shown: if 0 is weakly inadmissible, then the 
degrees of the tamely B-recursively enumerable sets are not an 
initial segment of degrees of the 0-recursively enumerable sets. 
Exercise 3.8. 
(1) Suppose B is inadmissible and B is a tamely B- 
recursively enumerable set. Show B < ol/*. 
B 
(2) Suppose ,3 
is weakly inadmissible. Show there exists 
a tamely 0-recursively enumerable C such that C E o1l2. 
B 

4. Weak Admissibility and Priority Arguments 
Today's lecture includes a positive solution to Post's 
problem in the weakly inadmissible case. The proof is similar 
to that given in lecture 2 for the admissible case, but there 
are some conceptual differences occasioned by the loss of 
admissibility. If time allows, some remarks on the strongly 
inadmissibility case will be made at the end of the lecture. 
It is a curious fact that the study of weak admissibility 
began (somewhat unconsciously) with the density theorems of 
Driscoll (31 and Shore [8]. Thenexttheorem, proved rather 
sketchily in [8], is central to the proof of density. 
Theorem 4.1 
(Shore). Suppose a is admissible and B is a 
regular, incomplete, a-recursively enumerable set. Then a 
is weakly admissible over B. 
Proof. Let B be a regular, a-recursively enumerable set, 
and let 
P 
denote ulpB(a), the sigma one projectum of a 
relative to B. 
First it is necessary to verify the 
relativization of Proposition 1.3 to B. 
With that end in 
mind, let D be El over <L(a),€,B>, and assume D c y 
for some y < p. 
It is necessary to show that D is a- 
finite. The first half of the proof of 1.3 is inapplicable, 
because <L(a),€,B> need not be admissible. anpa, the 
siqma n projectum of a, is defined by substituting En 
over L(a) 
for a-recursive in the definition of ulpa. 

Jensen has shown 
and E is Cn over L(a), then E is a-finite. 
Jensen's proof involves Skolem hulls and Mostowski collapses, 
and does not assume a is admissible. His proof does not 
relativize to B because the collapse of a subset of B has 
little chance of being an initial segment of B. 
D is C2 over L(a) . If y < o2pa, then (1) implies 
D is a-finite. So assume a2pa C y. 
Let t be a one-one, 
partial C2 
(over L(a)) map of u2pa onto a. 
Since a 
is admissible, there exists an a-recursive g such that 
(2) 
lim g(o,x) = t(x) 
u+a 
for every x in the domain of t. g is obtained by guessing 
at the value of t(x) within L(a). 
Admissibility is needed 
to show that all false values of t(x) less than the true 
value can be recognized as false inside L(u) for all suf fi- 
ciently large a. 
Let H be the C1 
Skolem hull in <L(~),E,B> of 
L(y) u {p}, where p is the parameter occurring in the C1 
definition of g. 
If H is bounded below a, then H, 
hence D, is a-finite. 
So assume H is unbounded in the 
hope of a contradiction. Fix y < a. 
There exists a unique 
x < a2pa such that t(x) = y. 
By (21, g(a,x) = y for all 
sufficiently large a. 
Since H is unbounded, there is a 
a, 
E H such that g(ao,x) = y. 
Since x, p E H, y E H. 
Thus H = L(a). H can be construed 9s the range of a one-one, 

partial C1 
(over <L(a) ,c,B>) map applied to L(y) u {PI. 
~ u t  
then there is a one-one, partial z;'~ map of something less 
than alpa onto a, a contradiction. 
B 
Now assume a is not weakly admissible over B with the 
intent of showing B is complete. Let 0 
denote alcfB(a), 
and let h : $ -> 
a be a one-one, strictly increasing map 
with unbounded range and a definition Z1 over <L(a) ,c,B>. 
Let C be an a-recursively enumerable set. The assumption 
that $ < p 
will be used to prove C < B. 
By Theorem 1.4, 
a 
it is safe to assume C is regular. Define 
The graph of j is a subset of $2 El definable over 
<L(a),e,B>. It was shown above that 1.3 remains true when 
relativized to B. 
Since $ < p ,  
it follows that j is a- 
finite. Then C n h ( ~ ) ,  regarded as function (of x) 
with 
domain $, 
is weakly a-recursive in B, 
and so C < B. 
O 
a 
Corollary 4.2. 
Suppose $ 
is weakly admissible and B is a 
regular, incomplete, $-recursively enumerable set. Then B 
is 
weakly admissible over B. 
The proof of 4.2 is virtually a replay of that of 4.1; 
however, Maass's notion of admissible collapse 161 is essential 
to any understanding of why this is so. 
S. Friedman [71 was the first to solve Post's problem in 
the weakly admissible case. His argument was an adaptation of 
Shore's "blocking' method [ll]. The proof of Theorem 4.3 below 
is a straightforward modification of the closed unbounded sets 

argument of Theorem 2.4. 
It is intended to suggest how 
admissibility proofs may be extended to the weakly inadmissible 
case. 
Theorem 4.3. 
Suppose 0 is weakly inadmissible. Then there 
exists a tamely @-recursively enumerable set B c alcf(6) 
such that 
alcfg(B) = alcf (0) 
1/2 
and 0 < B <@ 0 . 
0 
Proof. Let 
K 
denote alcf(0). By 3.1 there is a one-one, 
0-recursive map h of K 
onto 0. 
h is the remedy for all 
problems that arise in the course of compressing the proof of 
2.4 to the weakly admissible case. The construction as before 
takes place in stages, but now the stages are indexed by 
ordinals less than 
K 
Thus prior to stage a 
(a < K), only 
a 0-finite set of events has occurred. At stage a the 
structure 
L(sup h(y) 
Y<a 
fs examined to decide what happens next. 
Thanks to h the 
construction takes place in K 
steps, each one 0-finite, yet 
along the way the entire universe of L(0) is unraveled. 
With 
this understanding, 
0-recursive functions 
R: 
B<O 
and 
[ E I ~  
( Y )  
are defined as in 2.4. 

The set B C K 
is enumerated with four sets of 
requirements in mind. Let 
(1) 
K-B is an unbounded subset of 
K. 
(2) 
If 
K n WE is an unbounded subset of K, then 
WE n B # 0- 
(3) 
B<O 
For certain yes, the value of [ E ] ~  
(y) is pre- 
served. 
(4 
If 
K n Kg is an unbounded subset of K, then 
K6 n (K-B) # 0 .  
(Let {K* 1 6 < 8.1 
be a 8-r.e. enumeration 
of the @-finite sets.) 
(1) and (2) combine to make B non-@-recursive. 
(3) has 
as its objectives olcfB(a) = K 
and B <8 01i2. 
(Hyperregu- 
larity is analogous to alcfB(a) = K .  ) 
(4) insures that B is 
tamely 0-recursively enumerable. If (4) succeeds, then every 
8-finite K C B has 0-cardinality less than K, and conse- 
quently the set of all such K's 
is 0-recursively enumerable. 
In addition if [ E I ~ ( ~ )  
is defined, then it is defined by a 
8-finite computation whose positive part has 8-cardinality 
less than 
K ,  
and so is developed before the construction of 
B ends. 
Thus the true purpose of ( 4 )  is not to make B tame- 
ly 0-recursively enumerable, but rather to make sure that 
[ c ] r ( y )  converges to [ E I ~ ( ~ )  
as in the admissible case. Note that (1) and (4) together 
imply that each neighborhood condition, hence each computation, 
satisfied by B is an element of L ( K ) .  

Stage a is very much the same as it was in 2.4 save for 
some additional negative requirements for the sake of (4). A 
6-recursive function t(o,6) is devised that behaves as did 
r(u,~) in 2.4. 
t(o,6) is, if possible, a member of 
K6 n (K-B<'). 
Such a choice is possible if K6 is an unbounded 
subset of K, 
since B<' 
is a bounded subset of 
K .  
t (a,6) 
is kept out of B, 
unless it has to be put in for the sake of 
(2) for some E < 6. 
If that happens, the value of t(a,6) is 
increased. For each 6, the set of such increases is 6- 
finite and of 0-cardinality at most that of 6. The limit of 
t(o,B), as a - K, 
exists for the same reasons as the limit 
of r(a,~), as a -> 
a, in 2.4. 
The assumption of weak 
admissibility is used as follows. The set of a's 
such that 
t(a,6) increases is correlated with a 6-recursively enumer- 
able subset of E. 
Since E < 0 , the set in question, call 
it I, is 6-finite. 
(The proof of 1.3 works perfectly well 
in the weakly admissible case.) 
In addition the @-cardinality 
of I is less than B*. 
Since B* < K, 
the enumeration of I 
will be completed before the construction of B is finished. 
In other words weak admissibility implies the 6-recursive 
enumeration of a 6-finite set of 0-cardinality less than B* 
goes to completion at some intermediate stage of a construction 
taking place in K 
stages. 
In this manner the proof of 2.4 stretches to a proof of 
4.2 without too much fuss. Weak admissibility is strong enough 
to push through the priority argument developed for the admis- 
sible case. 
In order to enable the priority argument to 
achieve its ends, the set B is a subset of ulcf(6) rather 

than B, 
and requirements of type (4) are added to force 
computations from B to converge quickly. The proof that 
olcfB($) = alcf(f3) follows very closely the argument given in 
2.4 to establish hyperregularity. And the proof that 
B <B 0 
follows the argument given in 2.4 for incomplete- 
ness. 
One detail worth mentioning is that B <@ 0 
because 
B is tamely recursively enumerable. This last point is based 
on reasoning similar to that behind Theorem 3.2 (3). 0 
Corollary 4.3. 
Suppose 6 is weakly inadmissible. Then there 
exists a regular, $-recursive B such that 8 is weakly 
inadmissible over B and 0 CB B. 
Proof. Apply 3.3 to the B provided by 4.2. 
0 
There are still many open questions concerning the 0- 
recursively enumerable degrees when B 
is weakly inadmissible. 
(A f3-degree is said to be 0-r.e. if one of its representa- 
tives is 0-r.e.1 
For example, are the 8-recursively enumer- 
able degrees densely ordered? At the moment this question has 
plausible lines of attack in both positive and negative direc- 
tions. 
The principal results in the strongly inadmissible case 
are due to S. Friedman [7,9]. 
He has shown that there exist 
* 
incomparable B-recursively enumerable degrees if B 
is B- 
recursively regular. 
(This last means there is no B-recur- 
* 
sive function with domain less that $ 
and range an unbounded 
subset of 6.) 
The trick associated with negative requirements 
of type (4) in the proof of Theorem 4.2 is of some use in the 
strongly inadmissible case, but it fails to solve difficulties 

associated with a lack of tamely recursive enumerations. 
Friedman invokes an effective version of Jensen's 0-principle 
to help him guess the 8-finite subsets of the 0-recursively 
enumerable sets he constructs. 
In the opposite direction he 
has shown that there exists a B 
such that the only B- 
recursively enumerable degrees are O1 o1l2 and 0'. 
One 
such B 
is Nu * u  of L. 
The proof of this remarkable result 
1 
combines ideas from Silver's work on the Generalized Continuum 
Hypothesis with recursion theoretic ideas. Homer [12] has 
pointed out that the strongly inadmissible case has implica- 
tions for the weakly inadmissible case: if 6 is weakly 
inadmissible but strongly inadmissible over o
~
/
~
~
 
then the 
8-recursively enumerable degrees between o
~
/
~
 
and 0' 
can 
in some cases be identified with the y-recursively enumerable 
degrees for some strongly inadmissible y. 
Exercise 4.4. 
(1) Supply the details of the proof of Theorem 4.3. 
(2) Suppose B 
is weakly admissible and g : 6 -> 
B 
is 2:. 
Show there exists a 8-recursive t : B2 -> 
B 
such 
that lim t(u,x) 
is g(x) for all x < 6. 
u 

5. 
Kleene Recursion in 3~ 
Today's lecture and the next are devoted to Kleene's 
theory of recursion in normal objects of type 3. 
All that 
follows applies equally well to type 4 and higher, but it 
seemed discrete to avoid higher type complexities in order to 
achieve a more valiant exposition at the type 3 level. Today 
is largely review, and tomorrow is regular sets and Post's 
problem. 
2w 
is the set of all reals. 
3~ is the equality predi- 
s 
cate for sets of reals. Thus 
E(x,y) is true if x = y and 
false otherwise, where x, y C 2W. 
Let F be a function whose 
w 
domain is 2w 
and whose range is contained in w. 
Kleene 
[13] defines recursion in F by means of schemes not unlike 
those in common use at the first type level. Unraveling those 
schemes amounts to generating computations. If F is normal, 
then the computations lend themselves to a natural enumeration 
in the form of a hierarchy that resembles L. F is normal 
means 3~ 
is recursive in F. 
Since "recursive inw has not 
yet been defined, it may be best to think of a normal object as 
3 
consisting of a pair < E,F>, where F is arbitrary. 
The use of hierarchies to characterize Kleene recursion in 
the normal case originates with Shoenfield [14] and Grilliot [151. 
The idea is to construe F as a jump operator acting on sets 
of real's, and then to generate the sets recursive in F and a 
arbitrary real in a fashion analogous to the generation of the 

hyperarlthmetic sets by iteration of the Turing jump through 
the recursive ordinals. Nothing could be more reasonable once 
Kleene had shown that the hyperarithmetic sets (of integers) 
are just those sets recursive in 2 ~ .  
Let X C 2W. The F jump of X, denoted by jX, is the 
effective disjoint union of certain definable subsets of 2W. 
Let 
1 
be the e-th 
function (e-th according to some 
standard GGdel numbering of formulas) from 2W into w 
whose 
graph is definable over <2W,c,~> by means of a first order 
formula whose 
parameters are nonnegative integers, and 
whose atomic parts are of the form y E z and z E X, where 
y is an integer variable, z is a real variable and x de- 
notes X. 
X 
let < be {a I a E 2W 
& 
{ell(a) = 01. 
jx is the set of all <e,a,O> such that a E < , and 
all <e,a,y+l> such that 
where <X,a> is a set of reals that encodes the pair X, a. 
The first part of jX encodes all subsets of 2W de- 
finable from X via integer parameters, and the second part 
W 
encodes the F-images of all subsets of w 
definable via 
real parameters. 
The sets 6
'
 
and $ , and the function 
1 
l F  : oF -> 
Ordinals, are defined by a simultaneous recursion. The mem- 
bers of oF are reals that serve as notations for ordinals. 
F 
If a E oF, 
then lalF is the ordinal denoted by a. 
icl 
is the least ordinal without a notation in oF. 
For each 

F 
a < K , H 
is in essence the result of iterating the F 
jump a times. The only complexity in the following defini- 
tion occurs at limit stages. A notation for a limit ordinal X 
is introduced in a predicative fashion from below that corres- 
ponds to an effective closure property: 
if H is recursive 
in 3 ~ ,  
F and each member of H is a notation for an ordinal 
F 
less than K~ , then the supremum of the ordinals denoted by 
F 
members of H is an ordinal less than K ~ .  (For notational 
simplicity, the superscript F is often omitted below.) 
(1) 
<l,a> E 0, 
I<l,a>l = 0 
and Ho = 0 
(a E 2W). 
(2 
Suppose <e,a> E 0 and 
I<e,a>l = a. 
Then 
<2e,a> E 0, 
1<2e,a>l = o+l and Ha+l = jH,. 
<Ha, a> 
Suppose <m,a> E 0, 
I<m,a>l = o and We 
C 0. 
Then <3m* 
5e,a> E 0 and 
1 <3m* 
se,a> 1 = A, where A 
is the 
least limit ordinal greater than J<m,a>l and all Ibl 
such 
<Ha, a> 
that b E We 
In addition HA is the set of all <b,c> such that 
F 
F 
The hierarchy I H ~  I a < kl) 
of sets of reals is equiva- 
lent to a hierarchy of all the computations that arise in the 
computation of all functions (from 2W into w) recursive in 
F, 3 ~ ,  
a for all real a. 
3 
Eel( E,F,a) 
is said to be defined and equal to x if 
e = <eo,el>, 
Ha 
<eo,a> E 0, I<eo,a>l = a and {elln (a) = x. 

3 
To compute {el( E,F,a) is to iterate the F jump until 
eo is seen to be a notation for some ordinal a, 
and then to 
extract the value x 
in an elementary manner from Ha. 
u 
is 
regarded as the length of the computation of {e 1 ( 3 ~ , ~ ,  
a) , and 
the matter is expressed by 
I {el (3~,~,a) 
1 = a. 
Suppose f : 2@ -> 
2W. 
f is recursive in 3 ~ ,  
F if 
3 
there is an e such that f(a) = {el( E,F,a) for all a. 
A 
set R C 2@ is recursive in 3 ~ ,  
F if its characteristic 
function is. T.he symbol "<" means "recursive in". Thus 
3 
f < E, F, a means f is recursive in 3 ~ ,  
<F,a>, that is 
3 
for some e, 
f (b) = {el( E,F,a,b) for all b. 
An ordinal a 
is constructive in F, a if a 
is 
I<e,a>l 
F 
for some <e,a> E 0 . a 
is recursive in F, a if 
a 
is the height of a prewellordering of 2@ recursive in 
3 ~ ,  
F, a. Each constructive ordinal is recursive, but not 
conversely. 
Clause (3) above implies a powerful bounding principle: 
if f : 2' 
-> 
oF is recursive in 3 ~ ,  
F, a, then there 
exists a a 
constructive in F, a such that If(b) lF < a 
for 
all real b. 
It is a consequence that a set R c 2@ is recur- 
sive in 3 ~ ,  
F, a iff there exists an ordinal a 
constructive 
in F, a such that R is one-one reducible to H 
as 
follows. For some e, 
for all real b. 
A set R is recursively enumerable in F, a if there is 
an e such that for all b, 


Suppose ( a ) ,  (b) and (c) are accepted as guides. Then the 
"finite" sets are simply the sets recursive in 3 ~ ,  
F, a for 
some real a. And the bounding principle becomes: if 
{el (3~,~,-) 
is defined on some "finite" set, then the collec- 
tion of all relevant computations is contained in, and hence 
equal to, some "finite" set. 
(It now becomes very tempting to 
think that the bounding principle is equivalent to some global 
form of C1 admissibility, but this is far from true.) 
Let A 
be a class of "finite" sets, that is sets recur- 
sive in 3 ~ ,  
F, b for some real b. 
A 
is recursively 
enumerable in 3 ~ ,  
F, a if there is an e such that 
for all R C 2W. 
(<FIR> is a type 3 object that encodes the 
pair F, R.) 
Definition (4) is not as transparent as it seems. 
Note that the right side of (4) must not converge for any R 
that is not "finite", since all such R have been excluded 
from A 
in accord with (a) above. The requirement that every 
member of a recursively enumerable class be "finite" is more 
than a mere formality in the light of the next theorem and its 
corollary. Let -< be a wellordering of 2W. Normann [la] 
calls 4 F-recursively regular if there is no function 
3 
f < E, F, a for some a such that the domain of f is a 
proper initial segment of -( and the range of f is unbounded 
in 4. 
Theorem 5.1 (Sacks 1191 ) . Suppose -( is 3~-recursively 
regular, and is recursive in 3 ~ ,  
a for some a. Then the 
class 

{R I 
(Eb) (R < 3 ~ , b )  
I 
is not recursively enumerable in 3 ~ ,  
a for any a. 
Corollary 5.2. 
Suppose the cardinality of the continuum is 
regular. Then there exists a normal type 3 F such that the 
class 
is not recursively enumerable in F, a for any a. 
The proof of 5.1 is a forcing argument based on the first 
half of the next result. 
Theorem 5.3 (Normann [18] ) . Suppose -< is 3~-recursively 
J 
regular, and is recursive in 
E, a. 
Then (i) and (ii) hold. 
3 
(i) Call a set R "small" if R < E, b for some b and 
3 
R is bounded in<. 
Then there is a predicate P(brc) < E, a 
such that 
is an enumeration of all "small* sets. 
(ii) Suppose Q is a nonempty recursively enumerable (in 
3 ~ )  
subset of {c I c 4 
b} . Then there exists some c E Q 
such that c < 'E, 
a, b (uniformly) . 
The proof of (i) is a Gijdel style collapsing argument. 
(i) makes it possible to treat the collection of all "small" 
sets as a "finite" set. 
(i) is similar to a truth of a-recur- 
* 
sion theory: if a < a, then the collection of all a- 
* 
* 
finite subsets of a 
bounded below a 
is an a-finite set. 

(ii) follows from (i) by means of an argument not unlike that 
used in the proof of Grilliot's selection theorem. Grilliot 
[15] showed (with gaps filled in by Harrington and MacQueen 
[20]): 
suppose Q is a nonempty recursively enumerable (in 
'E) 
set of reals; then there exists a nonempty Qo C Q such 
that QO is recursive in *E. 
(If in addition there is a 
wellordering of zY 
recursive in 'E, 
then Qo can be cut 
down to a single real recursive in 'E.) 
It is not difficult to live with the anomaly of 5.1. 
Ob- 
F 
serve that the class {Hu ( u < rl) is recursive in 3 ~ ,  
F, 
since to be an Ha set is to be a hierarchy generated by 
F 
iterating the F jump short of the closure point 
K 
And 
every set recursive in 3 ~ ,  
F, b for some b has a primitive 
definition relative to some Hu. Thus the Ha sets are 
cofinal in the "finite" sets. and so it seems safe to restrict 
attention to recursively enumerable classes of Ho sets. The 
HZ sets are a bit more flexible than the HE sets. R is an 
F 
3 
H, 
set if R has the same degree 
(mod E,F) as some 
set. To be precise there exist eo and el such that 
3 
3 
R = {eo)( E,F,H,) 
and Ha = {el)( E,F,R). 
The collection of all H, 
sets is recursively enumerable in 
3 ~ ,  
F, and is closed under rudimentary operations such as 
pairing [19]. Another definition of H, 
set, perhaps more 
intrinsic, is: R is an H, 
set if R has the same degree 
3 
(mod E,F) 
as some prewellordering W of 2W such that 
3 
W < E, F, b for some b. 
The height of W is of course 
F 
some ordinal less than K ~ .  Thus the H, 
sets can be loosely 

identified with the ordinals in the universe generated by F. 
That universe has a useful description in terms of a relativ- 
ized version of Godel's 
L. 
X E L(a+l,F) 
if X C L(a,F) and X is first order 
definable with parameters over M(a,F). 
L(X,F) = U (L(a,F) I a < A) 
if 
is a limit. 
F 
F 
F 
It is not difficult to verify that L(tcl,F) and { H ~  
I a < tcl) 
are equivalent structures. This means that a transitive set X 
F 
belongs to L(tcl,F) 
iff the structure <XI€> is isomorphic to 
3 
some binary relation R < E, F, a for some a. 
Let L(F) be the language of ZF augmented by ranked 
a a 
variables x y . 
constants that name elements of L(F), 
and a function constant F. 
An ordinal T 
is said to be a-reflecting if for each C1 
sentence G of L(F) with parameters in w U {a}, 
it is the 
case that 
M(T,F) 
G implies M(K:,F) 
G . 
(K: 
is the least ordinal not constructive in F, a. ) 
The use 
of reflecting ordinals in the study of Kleene recursion goes 
back to the proof of the plus-one theorem [21]. A typical C~ 
F 
sentence is (Eo ) [<e.a> E Ha 1 . since each 
encodes all 
Y 
F 
first order facts about (Ha I a < y )  
in a positive fashion. 
To say T is a-reflecting is to say: an 8 satisfying a 
a 

A, 
formula (with parameters in o u {a)) 
is developed before 
stage T only if one is developed before stage y 
for some y 
recursive in F, a. 
Note that if y is recursive in F, a 
and <e,a> E HZ holds for some u < y, then the least such 
is recursive in F, a because it is first order definable 
F 
over Ha. 
Let r: 
be the greatest a-ref lecting ordinal. Some re- 
sults of Moschovakis 1171 and Harrington [221 show 
a 
A powerful characterization of K, 
due to Harrington, and its 
application to Post's problem for recursion in 3 ~ ,  
F, will be 
discussed in the next lecture. Very briefly: certain proper- 
ties of rr are needed to show that each requirement of nega- 
tive type is injured only "finitely" many times. 

6. 
Post's Problem and Regularity for 3~ 
It seems wise, before time runs out, to say explicitly 
what is meant by a positive solution to Post's problem for a 
normal type 3 object F. 
For the remainder of this lecture, 
assume F is normal in the most direct sense, that is F is 
F O I  
E , where Po is an arbitrary type 3 object. Let A 
F 
and B be classes of HZ sets, and let H be an H, 
set. 
A is said to be recursive 
B, F, H on the HZ sets (in 
symbols A < B, F, H) if there exists an e such that for 
F 
every H, 
set K, 
Note that the behavior of {~)(B,F,H,z) when Z is not an 
HZ set is left open; it may not even converge. 
Dictum 6.0. Post's problem for F has a positive solution if: 
F 
there exist an HZ set H and classes A and B of H, 
sets such that A and B are recursively enumerable in F, H I  
and such that 
A 
B, K 
and 
B + A ,  K 
for any 6 set K. 
Some of the reasoning that led to the above formulation of 
Post's problem was discussed in [191. Time permits only one 

aspect of the matter to be reviewed. Spector [23] observed 
that if A 
is a nonhyperarithmetic, I[; 
set of integers, 
1 
then every IT1 
set B of integers is hyperarithmetic in A. 
His argument with inessential changes shows: if A 
is a set 
of reals such that A 
is recursively enumerable in F, a for 
some real a, but not recursive in F, b for any real b, 
then every recursively enumerable (in F, c) set B of reals 
is recursive in F, A. 
It follows that Post's problem for F 
has to be formulated in terms of classes of sets of reals 
rather than sets of reals. This sort of conclusion was first 
reached at the type 2 level by Kreisel [ 2 4 ]  in the early days 
of metarecursion theory. 
Normann [I83 has shown that Post's problem has a positive 
3 
solution when F = 
E and there exists a 3~-recursively 
regular wellordering -< of 2° 
recursive in 3 ~ ,  
a for some 
real a. His proof relies heavily on a powerful reflection 
principle (Theorem 5.3 (ii) above) to show each negative 
requirement is injured at most countably many times. A count- 
able bound is not unexpected when 
1(1, 
the height of the 
wellordering 4 ,  
is aleph-one, but is certainly remarkable 
when 
> aleph-one. Normann derives reflection from a 
G6del style collapse that does not relativize from 3~ to an 
arbitrary normal type 3 F. The solution to Post's problem 
described below avoids collapsing arguments in favor of 
dynamic and combinatoric principles that make sense for all 
normal F. The countable bound on injury sets will be dropped. 
The dynamic approach relies on several parameters 
associated with F. 

F 
The greater projectum of F is denoted by 
P . It is the 
F 
F 
least o C rl such that there exists an H -set Iil with the 
following property: every $-set 
has the same degree (mod F) 
as cH1,HT> for some T < o. 
pF 
is analogous to a*. 
There 
F 
F 
exists a one-one map f from { H ~  
I IY < K
~
)
 
into 
{HE I 0 < pF} 
such that both f and i1 (where defined) are 
recursive in F and some #-set. 
The computability of f-I 
F 
is the most distinctive feature of p , and is essential for 
priority arguments. 
F 
The lesser projectum of F is denoted by n . It is the 
least o < I
C
 such that there exists an IiF-set 
Iil 
with the 
following property: 
there exists a recursively enumerable (in 
F 
F, H1) class of H -sets contained in {H, 
1 T < el, but not 
2 
recursive in F, Ii2 for any HF-set H . 
Proposition 6.1 
(i) nF < pF. 
(iil Suppose there exists a wellordering of 2W recursive 
in F, a for some real a. 
Then the least height attained by 
F 
any such wellordering equals p . 
(iii 
Suppose there exists a 3~-recursively regular 
wellordering of 2W recursive in 3 ~ ,  
a for some real a. 
3~ 
3~ 
Then n 
= p . 
Proof. To prove (iii) it suffices to fix b and show the 
3~ 
supremum of 
{K: 
I c < b) is less than rl . Normann I181 
shows that this supremum is at most 
K 
, where a is such 
that -4 
is recursive in 3 ~ ,  
a. 
As promised in the previous 
3~ 
lecture, it will be shown below that 
I
C
 
< I
C
 . The bound 

K
~
'
~
 
can also be derived directly from 5.3 (ii) via a result 
r 
of Harrington [ 2 2 ]  trr the effect that xzpb # K
:
 
o r  all b 
and c. 
F 
Let y 
K ~ .  The r.e. in F cofinality of y is denoted 
by recfF(y). 
It is the least a ( y 
such that there exists 
an IiF-set H1 with the following property: there exists a 
recursively enumerable (in F, HI) class A such that A is 
an unbounded subclass of {HT I 
T < y}, 
and such that the 
ordertype of {T I HT E A} is o. 
F 
If y < K~ , then recfp(y) is an F-cardinal. An 
F 
ordinal 6 < K~ is an F-cardinal if there is no one-one func- 
tion f that maps {H: 
I r < 6) into a proper initial segment 
F 
of itself and is recursive in F and some H -set. If 
F 
F 
p < K . then pF 
and nF are F-cardinals, and pF 
is the 
greatest F-cardinal. An example due to Ted Slaman shows p F 
can be a successor cardinal without being F-recursively 
regular. 
In a moment it will be shown that n and K~ have the 
same r.e. cofinality. This lemma is analogous to one of Shore 
1111 that says a* and a have the same tame L: 
cofinality. 
however the proof of the finite types result draws on reflec- 
tion phenomena that have no counterpart in a-recursion theory. 
Those phenomena originate in a theorem of Moschovakis that is 
central to the theory of Kleene recursion in objects of finite 
Theorem 6.2 (Moschovakis [17]). 
Let A be a recursively 
enumerable (in F) set of reals. Then there exists a 

recursively enumerable (in F) set B of reals such that 
for all real a. 
Proof. To say a 9 A is the same aa saying that some compu- 
tation indexed by a fails to converge. A convergent canpu- 
tation has the form of a wellfounded tree. Thus B must be 
defined eo that "<a,b> E B" means: 
the computation tree 
indexed by a has an infinite descending path encpded by b. 
For the sake of simplicity suppose A is oF. 
oF is 
both a typical, and a universal, recursively enumerable (in F) 
set. The inductive definition of oF readily yields a 
recursively enumerable (in F) predicate R (c ,d) such that: 
(1) 
if R(c,d) holds and c 
oF, then d E oF and 
lclF > !dlF; and 
(2) 
if c $3 oF, 
then there exists a d such that 
R(c,d) holds and d 9 oF. 
R(c,d) is an artful variation of the predicate: d 
indexes an immediate subcomputation of the computation indexed 
by d. 
<a,b> E B is defined by 
If a P A, then (Eb) [<a,b> E Bl 
by (2). 
The converse fol- 
lows from (1). 0 

Corollary 6.3. 
(i) (Moschovakis) The class of recursively enumerable 
(in F) predicates of reals is not closed under existential 
auantification. 
6.3 (ii) follows from 6.2 and the existence of a non- 
a 
recursive, recursively enumerable set of reals. 
K~ 
was 
defined above for an arbitrary real a relative to a normal 
type 3 F. 
The definition extends easily from reals to sets of 
the form 8. If 
1 a 1 
= u, then H: 
and a have the same 
Hu 
degree (mod F), and K 
is (by definition) K
:
.
 
F 
H, 
Lemma 6.4 (1251). 
If qF > y, then rl > sup {rr 
I 
IJ < y}. 
(In addition the supremum can be computed effectively from y.) 
The proof of 6.4 is technical, but not difficult. 
It 
begins with the observation that 
and makes use of the fact that qF 
is an F-cardinal. 
The 
parenthetical portion of 6.4 follows from 6.2. 
Theorem 6.5 ([251) . recfp(n) = recfF(K1). 
The proof of 6.5 is based on 6.4 (including the parentheti- 
cal part) and 6.2. 
Let H be a set of the form 8. 
The Harrington 
characterization of 
K
:
 
begins with a slight variant of 6.2: 
there exists a W e 1  number n such that 

for all e and A. 
If In) (F,e,~,blZ, then the ordinal 1 in1 (~,e,~,b) 
1 
is 
said to be a Moschovakis witness to the divergence of 
{el (F,H). 
Theorem 6.6 
(Harrington 1221 1. 
K
:
 
is the least 
such that 
for all er 
if {el(F,H) 
diverges, then there is a Moschovakis 
witness to its divergence at or below a. 
The proof of 6.6 combines the details of the proof of 6.2 
with the following basis theorem of Harrington & Kechris 1221: 
Suppose A is a recursively enumerable (in F, H) set of 
reals; if 2 W - ~  is nonempty, then it has a member c such 
H 
that K
:
"
 
< K
.
.
 
The basis theorem is applied countably many 
times in succession to obtain a.suitable b that encodes an 
infinite, descending path through the computation tree of 
{el (FIB). 
Theorem 6.7 
(Sacks [251) . If nF = pF, 
then Post's problem 
for F has a positive solution (in the sense of 6.0). 
The principal features of the proof of 6.7 are as follows. 
All requirements, positive and negative, are indexed by ordi- 
nals less than p. 
Among them are the usual Friedberg- 
Muchnik requirements designed to make the recursively enumer- 
able tin F) classes A and B incomparable with respect to 
F 
computations of height less than K ~ .  The remaining require- 
F 
ments have as their object the K~-subgenericity of A and B, 

that is 
All of the subgenericity requirements are negative. A typical 
one proceeds by committing to preservation carefully selected 
parts of the computation tree of {e)(F,A,H), 
where H is 
some 4-set. 
The parts are selected with the aim of locating 
F 
below K~ 
a Moschovakis witness to the divergence of 
{e)(F,A,H). 
The selection is careful to help make sure that 
all activity associated with the computation tree of 
F 
Eel(F,A,H) 
eventually comes to end at some stage prior to K ~ .  
It turns out that if no Moschovakis witness is developed below 
F 
K~ , then {ef(F,A,II) converges via a computation of length 
F 
less than K ~ .  Thus convergent computations are forced to con- 
F 
verge rapidly, that is below K~ , by forcing divergent compu- 
tations to diverge rapidly. This rather indirect approach 
seems necessary in order to bound the amount of activity associ- 
ated with each requirement. 
The requirements are divided into blocks as in Shore [ll], 
and the number of such blocks is A, 
the recfF(p). 
Since 
rl = p ,  
6.4 and 6.6 can be used to bound the activity within one 
block. 
If 6 < A, 
then the activity within the first 6 many 
blocks can be bounded below K~ 
with the help of 6.5, 6.4 and 
6.6. 
6.5 and the equality of s and p 
imply that 
r e ~ f ~ ( ~ ~ )  
= A. 
The parenthetical portion of 6.4 combines with 
6.6 to yield a recursively enumerable class {H:(~) 
I Y < 6) 
bounds the activity within block y. 
such that each H, (y) 
But then 
, where 6 
= sup a
)
 
1 y < 6 ,  bounds 

the activity within the first 6 many blocks. 
u(6) < K~ 
because 6 < recfF (kl) . 
The proof of 6.7 can be stretched to cover some of the 
F 
F 
F 
situations that occur when 0 < p. 
One such is: n < p , n 
and pF 
are the only uncountable F-cardinals, end 
F 
recfp (p) = 0 . Such an F has been devised by T. Slaman in a 
generic extension of L of his own making. 
Splitting and density theorems [ 2 5 ]  can be proved for the 
recursively enumerable (in F etc.) classes of 4-sets if 
recfF(p) = p = n, 
but it is unlikely that these results are 
the best possible. The above hypothesis has also been used by 
E, Griffor to obtain a minimal pair. 
He builds on minimal 
pair results of Normann [18] and others. 
The proof of the density theorem of course needs a regular 
sets theorem. Let A be a class of $-sets. 
A is said to 
F 
be regular if for each a < kl , the intersection of A and 
F 
H 
1 T < I 
is recursive in F and some H -set. 
Theorem 6.8 (Sacks [ 2 5 ] ) .  Let A be a recursively enumerable 
(in F etc. ) class of $-sets. 
Then there exists a regular, 
recursively enumerable (in F etc.) class B of $-sets 
such that A G F ,  B, H and B < F ,  A, H for some $-set 
H. 
Note that the above regular sets theorem does not require 
any assumptions about 
or p. 
Grazie dell'ascolto, e buon giorno. 

References 
[l] R. Friedberg, Two recursively enumerable sets of 
incomparable degrees of unsolvability, Proc. Nat. Acad. 
Sci. 43 (19571, 236-238. 
[2] A. A. Muchnik, On the unsolvability of the problem of 
reducibility in the theory of algorithms, Doklady Akad. 
Nauk SSSR 108 (19561, 194-197. 
[33 G. Driscoll, Metarecursively enumerable sets and their 
metadegrees, Jour. Symb. Log. 33 (19681, 389-411. 
141 R. Shore, The irregular and non-hyperregular a-r.e. 
degrees, Israel Jour. Math. 22 (19751, 28-41. 
[5] G. E. Sacks, Post's problem, admissible ordinals and 
regularity, Trans. Amer. Math. Soc. 124 (19661, 1-23. 
[6] W. Maass, Contributions to a- and 6-Recursion Theory, 
Habilitationschrift, University of Munich 1977. 
[71 S. Friedman, Recursion on Inadmissible Ordinals, Ph.D. 
Thesis, Massachusetts Institute of Technology 1976. 
[8] R. Shore, The recursively enumerable a-degrees are dense, 
Ann. of Math. Log. 9 (19761, 123-155. 
I93 S. Friedman, Negative solutions to Post's problem 11, to 
appear. 
[lOl S. Homer and G. E. Sacks, Inverting the half-jump, to 
appear. 
I 
R. Shore, Splitting an a-recursively enumerable set, Trans. 
Amer. Math. Soc. 204 (19751, 65-78. 
1121 S. Homer, Priority Arguments in 6-Recursion Theory, Ph.D. 
Thesis, Massachusetts Institute of Technology, 1978 
1131 S. C. Kleene, Recursive functionals and quantifiers of 
finite type, Trans. Amer. Math. Soc. 91 (19591, 1-52; and 
10.8 (19631, 106-142. 
[14] J. Shoenfield, A hierarchy based on a type 2 object, Trans. 
Amer. Math. Soc. 134 (19681, 103-108. 

[15] T. Grilliot, Selection functions for recursive functionals, 
Notre Dame Jour. Form. Log. 10 (19691, 229-234. 
1161 R. Gandy, General recursive functions of finite type and 
hierarchies of functions, University of Clermont-Ferrand 
1962. 
1171 Y. N. Moschovakis, Hyperanalytic predicates, .Trans. Amer. 
Math. SOC. 138 (19671, 249-282. 
[l81 D. Normann, Degrees of functionals, Ann. of Math. Log., to 
appear. 
[191 G. E. Sacks, Post's problem, absoluteness and recursion in 
finite types, 1978 Kleene Symposium volume, to appear. 
1203 L. Harrington and D. MacQueen, Grilliot's selection princi- 
ple, Jour. Symb. Log. 41 (1976), 153-158. 
[211 G. E. Sacks, The k-section of a type n object, Amer. Jour. 
Math. 99 (1977), 901-917. 
1221 L. Harrington, Contributions to recursion theory in higher 
types, Ph.D. Thesis, Massachusetts Institute of Technology 
1973. 
[23] C. Spector, Recursive well-orderings, Jour. Symb. Log. 20 
(19551, 151-163. 
[24] G. Kreisel, Set theoretic problems suggested by the notion 
of potential totality, in Infinitistic Methods (Pergamon 
Press, Oxford) 1961, 103-140. 
(253 G. E. Sacks, Three theorem on recursive enumerability in 
a finite type object, forthcoming. 
Harvard University 
Massachusetts Institute of Technology 
Acknowledgement: The author is grateful to the Centro Inter- 
nazionale Matematico Estivo for inviting him to lecture, and to 
the National Science Foundation for their support of the venture. 

CEN TRO I N  TERN AZIONALE MATEMATICO ESTIVO 
(c.I.M.E.) 
CONSTRUCTIONS I N  THE RECURSIVELY ENUMERABLE DEGREES 
ROBERT I. SOARE 

CONSTRUCTIONS IN THE RECURSIVELY ENUMERABLE DEGREES 
Robert I. Soare1 
CONTENTS 
Introduction 
Lecture 1. Simple sets, fixed points, and a completeness criterion 
for r. e. sets 
Lecture 2. 
The finite injury priority method 
Lecture 3. 
The infinite injury priority method 
Lecture 4. 
The minimal pair method 
Lecture 5. 
Embedding distributive lattices in the r. e. degrees 
Lecture 6. 
The non-diamond theorem 
Lecture 7. 
The Renaissance in classical recursion theory, the Sacks 
density theorem. and beyond 
'This work was partially supported by NSF Grant MCS-76-07033. 

CONSTRUCTIONS IN THE RECURSIVELY ENUMERABLE DEGREES 
Robert I. Soare 
University of Chicago 
INTRODUCTION 
In these lectures we survey some of the most important results and the 
fundamental methods concerning degrees of recursively enumerable (r. e. ) 
sets. We begin $1 with Post's simple sets and a recent elegant generaliza- 
tion of the recursion theorem. In $ 2 we give the finite injury priority method, 
the solution of Post's problem, and the Sacks splitting theorem, In 5 3 the 
infinite injury method is introduced and applied to prove the thickness lemma 
and the Sacks density theorem. 
In $4 and $5 we develop the minimal pair 
method for embedding distributive lattices in the r. e. degrees by maps pre- 
serving infimum6 as well as supremums. In $6 we present the non-diamond 
theorem which asserts that such embeddings cannot always preserve great- 
est and least elements. For background reading we suggest Rogers [17], 
Shoenfield [23], and Soare [25]. 
Our notation is standard as in Rogers [17], with a few additions. 
For 
sets A, B E o we say B is recursive in A (B < A) if there is a Turing 
-T 
reduction @ such that @(A) = B. 
Let A zT B denote that A ST 
B and 
B ST A. 
The degree of A, dg(A) = {B : B = A), 
Lower case bold-face 

letters 2 ,&, . . . denote degrees. Let {%Ie 
be an acceptable numbering 
e 
B 
of all Turing reductions. Let weA = {x:@~(A;x) converges), and W = We , 
so {wJ 
is an acceptable numbering of all t. e. sets. T h e m  of A 
ee o 
A 
i s  A' = {e : e l We ) . The jump is well-defined on degrees. An r. e. set A 
is complete if W < A for all e. For example, K = $' = {e : 
e c We) 
is 
e -T 
complete. We write d g ( ~ )  1 dg(B) if A IT 
B. 
Let 
d g ( ~ ) U  
dg(B)= d g ( A @ ~ )  
where A @ B  ={Zx:xcA) U(2xtl:xeB). 
A degree is r. e, if it contains an r. e. sea. The r. e. degrees (5 
,S , u) 
form an upper semi-lattice with least element 2 = dg(@ and greatest ele- 
ment 
= dg(p). 
Let @ 
(A; x) = y if ee with oracle A and input x 
evs 
As 
A 
yields output y in 
s steps. We also use {e)s (x) = y and {e) (x) = y for 
A 
Q~,;(X) 
= y and QefA;x)= y,respectively. Pix a l:l recursive function from 
w X o onto o and let <x, y> denote the image of the ordered pair (x, y) under 
this map. We identify a set A with its characteristic function, and let 
~ [ x )  
denote the restriction of this function to arguments (_ x . 
1. SIMPLE SETS, FMED POINT THEOREMS, 
AND A COMPLETENESS CRITERION FOR R. E. SETS 
The study of degrees of r. e. eets began with the famous paper of Post 
[14]. 
Post's problem was to find an r. e. set A of degree different from 2 
and 2. Post attempted to construct such an incomplete r. e. set A by 
considering structural properties on A such as simplicity which he hoped 
would guarantee incompleteness. Although unsuccessful, this approach led 
ultimately to a very pleasing fixed-point theorem which generalizes Kleene's 

recursion theorem and Which yields a necessary and sufficient condition for 
an r.e. set to be complete. 
An r. e. set C is creative if there is a recurrive fwction f(x) such 
that if Wx 
then f(x) e 
- Wx. 
For example, X is creative via the 
- 
identity function. For every creative set C, C contains an infinite r. e. set 
B = {bo, bt, . . .) where Wb 
= g, and W 
= Wb U (f(bn)) . Post defined 
o 
bn+ 1 
n 
a coinfinite r.e. set A to be simple if 
contains no infinite r.e. set. He 
hoped that if 
were sufficiently @thinn with respect to containment of 
infinite r. e. sets then A would be incomplete. Post constructed simple sets 
and proved them incomplete with respect to a stronger reducibility called 
m-reducibility. 
A set A is m-reducible to B (A C
-
 
8) if there is a 
recursive function f such that, for all1 x, x r A iff f(x) e B. It is easy to 
see that if C < 
A and C is creative, then A is creative (and thus not 
- m 
simple). Hence no simple set A can be m-complete. 
Theorem 1.1 (Post): 
There exists a simple set S. 
Proof. Fix a recursive enumeration {a ) 
of the r. e. set 
- 
s s r o  
A = {(e, x) : x r We & x > 2e). 
Define an r. e. set B 
A by enumerating 
a = (e,x) into 3 if there is no a = <e, y) for t < s and y #x. Since 
s 
t 
B is single-valued it represents the graph of some partial recursive (p. r. ) 
function JI; i. e. , +(x) = y iff (x, y> r B. 
Let S = range JI. 
(Intuitively, 
enumerate W until the first element +(e) > 2e appears in W and then 
e 
e 
put JI(e) into S.) 
The following facts give the simplicity of S. 
(1) S is r. e. (S is the range of a p. r. function. ) 
(2) % i s  infinite. 
To see this, note that S contains at most e elements 

out of {0,1,2,. . . , 2e), namely +(O),+(l), . . . ,+(e-1). 
Hence 
15 n [0,2e] 1 > e, so 'S is infinite. 
(3) If We i s  infinite, then W n S # $, because <e,x> e A for some 
e 
x > 2e and so $(e) is defined and +(e) e S A W . 
A simple set A i s  effectively simple if there is a recursive function f 
such that 
(Ve) [We C- 
=+ Pel < f(e)l* 
- 
where lwei is the cardinality of We. 
Note that Post's simple set i s  
effectively simple via f(e) = 2e. 
Post realized that simple sets could be complete (indeed S i s  complete 
by Corollary 1.5), and so he defined coinfinite r. e. sets with still thinner 
complements called hypersimple and hyperhypersimple. 
A coinfinite r. e. 
set A i s  hypersimple (h-simple) if there i s  no recursive function f which 
- 
majorizes 
A in the sense that for all n, f(n) 2 p-(n), 
where p- , the 
A 
A 
principal function of x, is defined by p-(n) = an, where x = a. < a < . . . . 
A 
1 
 h his i s  not Post's original definition but can easily be shown equivalent to it 
[17,p. 1391.) 
Clearly, h-simple sets are simple. 
The converse i s  false 
- 
since for Post's simple set S the function f(x) = 2x majorizes S. Further- 
more, h-simple sets a r e  not necessarily incomplete. Indeed, Dekker [2] 
proved that every nonzero r. e. degree contains an h-simple (and therefore 
simple) set. 
Theorem 1.2 (Dekker): 
F o r  every nonrecursive r. e. set A there 
is an h-simple set B t A. 
Proof. 
Let A = rng(f), f a 1:i recursive function, and let a = f(s), 

and As = {f(0). . . . , f(s)}. 
Define B 
I I: ( 3 t > s) [at < a#]}, the deficiency 
set of A for the enumeration f. 
Clearly B is Ci and hence r. e., and = 
- 
i s  infinite. Next, B is h-simple 
for if g(x) 2 p-(x) 
for some recursive 
B 
function g, then xc A iff x 4 {ao, a*, . . . ,a 
) , which would imply A 
g(x) 
recursive. Similarly, A < B because xc A iff xc {aO,ai,. . . , a  
1 . 
-T 
P, ( 4  
B 
Finally, B < A since to test whether s c B, we A-recursively compute 
-T 
t such that ~
~
[
a
~
]
 
= A[aS]. 
Now s c B iff aU < ae for some u such that 
s < u S t .  
n 
The crucial point about the deficiency set B is that any nondeficiency 
stage s e 5 i s  a "true" stage in the enumeration { A ~ ) ~  of A in that 
~ ~ [ f ( s ) ]  
= ~[f(s)]. These stages will prove very useful in our study of the 
infinite injury priority method in 53. 
Martin [lZ] found a fairly general sufficient condition for an r. e, set to 
be complete. His condition applied to many "effectivelygg nonrecursive r. e. 
sets including treative sets and effectively simple sets. ~achlan[S] modified 
Martinge condition so that it became both necessary and sufficient. Arslanov 
[1] then converted it to the following form which can be viewed as a generali- 
zation of Kleene's recursion theorem. It asserts that not only recursive 
functions b ut all those functions of r. e. degree less than 
have a fixed 
point. 
( ~ e c a l l  
that the recursion theorem [17, p. 1801 asserts that every 
recursive function f has a "fixed pointn n such that W = W 
n 
f(n). ) 
Theorem 1.3 (~rslanov): An r.e. set A is complete iff there is a 
function f < A such that W 
# W 
for all x. 
-T 
f(x) 
x 
Proof. 
(d) 
Trivial since {x: Wx = fl 
8'. 
- 

A 
(g) 
Assume (Vx) [Wf6) # Wx] where f(x) = {e) (x) and g(x) is 
the greatest element used in the latter computation. Let {
A
~
)
~
~
 
, 
{Ks)s ' 
O be recursive enumerations of A and K. 
Let m(x) = ps[xc Ks] if 
x c K, and m(x) = 0 otherwise. Define the recursive function 
A 
At 
At 
f (s,x) = {elt (x) where t L s is minimal such that {e) (x) is defined. By 
t 
the recursion theorem with parameters define the recursive function h by 
if x e  K 
W 
otherwise 
Since g s A we can define the function r < 
A by 
T 
-T 
Now if x e K and r(x) s m(x) then A 
[gh(x)] = A[gh(x)], so 
m(x) 
?(m(x), h(x)) = f (h(x)) and W f(h(x)) = Wh(x) contrary to the hypothesis on f. 
Hence, for all xc K, m(x) < r(x). 
Thus for all x, 
Corollary 1.4. 
Given an r. e. degree 5 , 2 '< 2 iff every function 
f c 2 has a fixed point. 
Corollary 1.5. 
An r.e. set A is complete if A is either 
(a) creative, o r  (b) effectively simple. 
Proof. 
(a) Let A be creative via g(x). Choose a t 
and define 
- 

(b) Let A be effectively simple via g(x). 
Define f < A by 
-T 
W 
= {ao, ai, . . . , a  
f(x) 
s(x9 * 
- 
where A = a < a C .., . In each case, it i s  clear that W 
f Wx for 
0 
i 
f(x) 
all x so A is complete by Theorem 1.3. 
n 
After Post's problem was solved by an entirely different method, some 
structural properties guaranteeing incompleteness were discovered [li], 
[26, p. 5501. 
2. 
THE FINITE INJURY PRIORITY METHOD 
A positive solution to Post's problem was finally achieved by 
Friedberg [3] and independently by Muchnik [13]. In their method, known as 
the priority method, the desired r. e. set is constructed by stages to meet a 
certain sequence of conditions {R ) 
called requirements. If n < m, 
n new 
requirement R 
i s  given priority over 
n 
Rm and action taken for R 
at 
m 
some stage s may at a later stage t > s be undone for the sake of R n* 
thereby injuring R 
at stage t. 
The original priority method of Friedberg 
m 
and Muchnik has the property that each requirement is injured at most 
finitely often. 
We illustrate the finite injury method by proving the Friedberg- 
Muchnik theorem using a variation of Sacks [I81 which is more powerful than 
the standard method and which will be used in $3. 
In our constructions, the 
requirements {R ) 
will be divided into the negative requirements 
e ec w 
N 
= R 
which attempt to keep elements out of the r. e. set A being con- 
e 
2e 
structed, and positive requirements 'e 
= R ~ e + i  
which attempt to put 

elements KO 
A. 
The negative requirements will be of the form C # Q! (A), 
e 
where C is a fixed nonrecursive r. e. set, so that the negative requirements 
together assert that C d T ~ .  
Sacks observed that the requirement Ne can 
be met by attempting to preserve agreement between Cs(x) and 
Oe,.(AS;x) 
rather than disagreement as one might suppose. 
(The point is 
that if we preserve this agreement sufficiently often and if C = Q (A) then 
e 
C will be recursive contrary to hypothesis. ) The positive requirements 
will ensure as in Theorem l.l that A is siriiple and hence nonrecursive. 
Theorem 2.1 (Friedberg-Muchnik): 
For every nonrecursive r. e. set 
C there i s  a simple set A such that C $ A (and hence j# < A < $'). 
T 
Proof. It clearly suffices to construct A to be coinfinite and to 
- 
satisfy, for all e, the requirements: 
Ne : 
C # Q ~ ( A )  , 
Pe: We infinite -7 We n A # $ . 
Let {Cs)s , 
be a recursive enumeration of C. 
Define A. 
= $. 
Given As 
define the following three recursive functions whose roles are obvious from 
their names: 
min{z: Q 
(A*[%]; x) defined) if z exists 
e*5 
(use function) 
u(e, x, s) = 
0 
otherwise 
(length function) 
1 ( e , )  = m={r w y  < x)[Cs(y) = Qe,s(~s:y)]) . 
(restraint function) 
r(e,s) =.max{u(e,x, s): x 5 ~ ( e ,  
s)) . 

F o r  each e 5 s, if W n As = $ and 
e,s 
then enumerate the least such x in A sti' 
Define A = us As . 
(~ntuitively, u(e,x, s) i s  the maximum element used in the above com- 
putation, and the elements x < r(e, s) are restrained from A 
by require4 
s t i  
N in order to preserve the length of agreement measured by I (e, s). ) The 
e 
negative requirement N i s  injured at stage s t i  by element x i f  
e 
x I. r(e, s) and xc A 
- As. 
These elements form an r. e. set: 
s t 1  
(injury set) Ie = {x: (3s)[x c Asti - As & x 5 r(e, s)]). 
Note that each I i s  finite because N i s  injured at most once for each 
e 
e 
Pi , i K e, whereupon P. is satisfied thereafter. 
(Positive requirements, 
1 
of course, are never injured.) 
Lemma 2.2. 
( \de)[c # q ( ~ ) ] .  
Proof. 
Assume for a contradiction that C = Q, (A). Then 
- 
e 
lim I (e, s) = oo. 
Choose st such that N 
i s  never injured after stage st. 
s 
e 
We shall recursively compute C(x) contrary to hypothesis. 
To compute 
C(p) for p E o find some s > s1 such that l(e, s) > p. 
It follows by induc- 
tion on t 2 s that 
and hbnce that Q, 
( A ~ ;  
p) = Q e ( ~ s ;  
p) = (P~(A; P) = C(P). Since s > sf, (2. 2) 
e,s 
clearly holds unless C (x) # Cs(x) for some t 2 s and x 5 p; but if x and t 
t 
are minimal then our use of "5 I (e, t)" rather than 
< l(e, t)" in the defi- 
nition of r(e, t) insures that the disagreement C (x) # @ 
(A~;x) is 
t 
e ,t 

preserved forever, contrary to the hypothesis that C = ee(A). 
Note that 
even though the Sacks strategy is always described as one which preserves 
agreements, it is crucial that we preserve at least one disagreement as well 
whenever possible. 
Lemma 2.3. 
(\de)[lim r(e.s) exists and i s  finite]. 
s 
Proof. 
By Lemma 1.1 choose p = Fx[C(x) # Se(~;x)]. Choose s* 
- 
sufficiently large such that, for all s 2 sB, 
( V x  < ~ ) r @ ~ , ~ ( A ~ ; x )  
= %(A: 41, 
( V x  5 p)[Cs(x) = C(x)l, and 
Ne is not injured at stage s. 
Case 1. 
(V s 2 s*)[\,,(A,; 
p) undefined]. 
Then r(e,s) = r(e,sl) for all 
s , 
sB. 
Case 2. 
4e,t(At; p) i s  defined for some t 2 s'. 
Then 4 
(As; P) = q , t ( A t i ~ )  
e,s 
for all s 2 t because l(e,s) 2 p, and so, by the definition of r(e,s), the 
computation @ 
(At; p) is preserved and N is not injured after stage sf. 
e ,t 
e 
Thus ae(A; p) = S 
(As; p). 
But C(p) # ae(A; p). 
Thus 
e,s 
Hence , r(e, t) = limsr(e, s). 
Lemma 2.4, 
( V  e)[We infinite d 
We n A # $1. 
Proof. 
By Lemma 1.2, let r(e) = limsr(e,s) and R(e) = 
- 
max(r(i): i ( el. 
Now if (3 
x)[xt We & x > RCe) & x > Ze] then 
we * A # $. 
Note that 
is infinite by the clause IBx > 2e 
in (2.1). and hence A 
is simple. 

Sacks invented-the above preservation method (which plays a crucial 
role in the later infinite injury argument) to prove the following theorem. 
Theorem 2.5 (Sacks Splitting Theorem [18]): 
Let B and C be r. e. sets 
such that C is nonrecursive. 
Then there exist r.e. sets A and A such 
0 
1 
that 
(a) 
AOU A 1 = B  and A O n A l =  $ ,  and 
(b) G I T ~ i ,  
for i = 0,i. 
Proof. 
Let  st 
and ( c ~ ) ~ ~  
be recursive enumerations of B 
- 
and C such that Bo = $ and ) B ~ + ~  
- Bs I = 1 for all s. It suffices to give 
recursive enumerations {A 
} 
i = O , l ,  satisfying the single positive 
i,s s c  0 '  
requirement 
P : x c B  s t l  - B s  @ [ X ~ A ~ , ~ + ~  
o r x c  A i , s t l l *  
and the negative requirements for i = 0 , 1  and all e, 
N:: 
c # \(Ai). 
Define A 
= $. 
Given A. 
define the recursive functions ll(e.s) 
i,O 
1,s 
i 
and r (e,s) as above but with A 
in place of A 
Let x c Bsti - Bs . 
i,s 
so 
i 
Choose <el, i*) to be the least <e, i) such that x ( r (e, s) and enumerate 
' Ai-i*,s+i. If (el,i*) fails to exist, enumerate x c A 
This 
0 , s t l  ' 
defines Ai, i = 0,1. 
i 
To see that the construction succeeds, define the injury set Ie as 
above but with Ai in place of A. 
It follows by induction on (e, i ) that, for 
i = 0, i and all e, 

(1) C # @e(Ai)8 
i 
(2) lim r (e, s) exists and is finite, and 
s 
(3) 1: 
is finite. 
D 
It can be shown [26, p. 5251 that the r. e. sets Ai a r e  automatically 
low, namely A: s T  
$I, where the jump of A was defined earlier to be 
- 
A 
At = {e: e r We ). By setting C = B in Theorem 2.5, it follows that any 
nonrecursive r. e. set B can be split a s  the disjoint union of low r. e. sets 
A. 
and A 
which a r e  Turing incomparable and such that 
i 
d g ( ~ )  
= dg(AO) U dg(Ai). 
Thus, there i s  no minimal r.e. degree. 
Finite injury arguments a r e  characterized by the fact that the injury 
set Ie i s  finite for each e. 
In $3 we will consider cases where I 
is 
e 
infinite although usually recursive. 
Note that Lemma 2.2 holds by virtually 
the same proof as above if we assume "Ie recursiven in place of "Ie finitet1. 
This is what allows the infinite injury method to succeed. 
3. THE INFINITE INJURY PRIORITY METHOD 
Shoenfield [22] and , independently, Sacks [19], [ZO], [21] discovered a 
technique for handling a requirement which may be injured infinitely often 
(namely, the injury set Ie may be infinite). 
Sacks considerably developed 
this technique into what he called the "infinite injury priority method" and he 
used it to prove many important results on r. e. degrees, the most striking 
of which is the density theorem which asserts that for any r.e. degrees 
d < 5 there i s  an r. e. degree 2 such that ,cJ < 2 < 2 . We now give a brief 
CI 
sketch of the method. 
More details and applications can be found in [26]. 

We wish to coostruct an r.e. set A where the negative requirements 
Ne are a s  in 9 2 and the positive requirements are of the form 
(where X C* Y denotes that X - Y i s  finite) so that a single positive 
requirement may contribute infinitely many elements to A. In the simplest 
cases, the r.e. sets {W 
1 
will be recursive. 
F o r  each Ne we 
p(e) e c w 
would like a restraint function ?(e, s) so that exactly as in f 2 we can 
enumerate x in A 
for the sake of Pe just if x c W 
and 
s +l 
p(e), s+l 
x > qi, s), for all i <_ e. The negative requirement Ne can now be injured 
infinitely often by those P., i < e, but the recursiveness of 
W 
i < e, will 
1 
P ~ I *  
enable us to meet Ne a s  in Lemma 2.2. 
The main difficulty will be that 
some P remains unsatisfied because of the restraint functions :(is s), 
e 
i 5 e, which may now be unbounded in s (i. e., lim sup G(i, s) = w). To 
satisfy P it clearly suffices to define "re, s) such that 
A 
(3.1) 
lim infs ~ ( e ,  
s )  < oo , 
C1 
where R(e, s) = max{$(i, s): i 5 e), because then P has a ltwindown through 
e 
the negative restraints at least infinitely often. 
The first obstacle to achieving (3.1) is that if we let ?(e, s) be r(e,s) 
a s  defined in f 2, then we may have lim r(e, s) = co for some e. ( F o r  
S 
example, suppose @ 
(X; 0) = C(0) just i f  n / x for some even n < s, but 
1 ss 
P eventually forces every even number into A so that Ql(A; 0) is unde- 
0 
fined. Then N1 is satisfied by divergence but 
C(0) = @ 
(As;O) for 
1 ,s 
almost every s, so limsu(l,O, 6) = a, lim r(1.s) = oo and PI is not 
S 
satisfied.) 
This difficulty arises only if there are infinitely many stages s 

such that As[u] # As+l [u] where u = ~ ( 1 . 0 ,  s). Thus, we can easily remove 
A 
the first obstacle by replacing Q 
everwhere by @ 
defined below, and 
e ,s 
e, s 
letting Z(e, s) be the resulting restraint function. If C # Qe(A) we then 
haee lim inf ?(e, s) < oo. 
S 
A 
The second obstacle to (3.1) i s  that lim R(e, s) = ao even though 
lid inf ;(i, 5) < oo for each i <,e. 
(For example, N and N may together 
S 
1 
2 
permanently restrain all elements because their restraint functions do not 
4 
drop back simultaneously.) 
Surprisingly, the Q 
solution to the first 
e,s 
obstacle automatically removes the second, as Lachlan first observed [7]. 
Suppose we wish to give a recursive enumeration {A } 
of an r.e. 
S B E  W 
set A. 
Given {A : 
t 
s), define 
t 
1 rnax(ASv {s)) 
otherwise ; 
if defined and u(e, x, s )  < as, 
$ 
(As;x) = 
e, s 
undefined 
othe w i s e ;  
if f 
(AS:x) i s  defined, 
e,s 
othe rwise; 
and 
If 
, 
i s  any recursive enumeration of an r. e. set A we refer 
to T as the set of true (nondefi~ienc~) 
stages of this enumeration. Note that 
T i s  infinite and T r A uniformly in A. 
If Qe(A; X) = y then clearly 
h 
lims {,.s(~s;x) = y a s  before. The crucial point about Q 
i s  that for any 
e, 6 
h 
true stage t any apparent computation Q (At;x) = y i s  a t r u e  computation 
e,t 

Qe(A;x) = y. 
Namely, using the fact that u(e,x.t) ( t  , we have 
because if qSt(At;x) i s  defined then 
u(e,x, t) < a 
and At[at] = ~ [ a ~ ]  
. 
t 
The simplest application of this method is the thickness lemma. 
F o r  
any set A and x 6 w, define the ncolumnn A(X) = {<y,z) : (y, z ) e A & y = x) , 
and 
= U {A"): 
z < x). 
A subset A S B i s  a - 
thick scbset of B if 
AtX) =* 
for all x, and B i s  piecewise recursive if B ( ~ )  i s  recursive 
for all x. (We write X =* Y if the symmetric difference 
(X - Y ) u ( Y  - X )  is finite.) 
Theorem 3 . 1  
(Thickness Lemma - Shoenfield [ 2 2 ]  ): 
Given a 
nonrecursive r. e. set C and a piecewise recursive r.e. set B there is a 
thick subset A of B such that C $ 
A. 
Proof. 
Fix recursive enumerations {B ) 
- 
s s c ; 
{=s}s. 0 of B and C. 
A 
, Let A = $. 
Given {A : 
t < s) define O 
(As) a s  above. Define the re- 
0 
t 
e,s 
A 
maining functions as in 5 2 with cb 
in place of 
cb 
, namely, 
e,s 
e,s 
A 
A 
(length function) f(e. 6) = max{x: (V Y < x)[CS(Y) = f ,s(As;~)l) . 
A 
(restraint function) :(e,s) 
= max{t(e, x, s): x 
f (e, s)) , 
h 
(injury set) 
1, =us$,s 
# 
where 
A 
Ie,s = {x: ( 3 v  Ss)[xI;(e,v) & 
- Av]}. 
To meet the requirements 
P : B(e) =* 
and 
Ne : C # %(A) , 
e 

(e) 
we enumerate x in A(') 
just if x r Bs+l and x > $(i. s) for all i 5 a . 
s+l 
Let A = us As ' 
Note that Te C A 
because N is injured by P. only if i < e. Thus 
e 
1 
A 
we have 5 
s T ~ ( c e )  because if x e A(<~', say x t A(<e), 
s 
then x e Ie just 
Fix e and assume by induction that C # ei(A) and A ( ~ )  =* B(i) for all 
h 
i < e. 
Then A ( < ~ )  =* B(<e) is recursive and hence I is recursive. 
e 
Lemma 3.2 (~njury Lemma): 
C # %(A). 
Proof. Assume for a contradiction that C = .Qle(A). Then 
- 
A 
lims ~ ( e ,  
s) = m. Fixing ie as an oracle we compute C, so C is recursive 
contrary to hypothesis. 
To compute C(p) for p t LI find some s such that 
i(e, s) > p and 
(Vx<p)(Vz)[z I 
u(e.x.s) 3 [r 4?e o r  z c As]]. 
Such s exists since C = a e ( ~ ) .  By the same remarks as in Lemma 2.2, it 
follows by induction on t 2 s that 
and hence that 
@ 
( A s ~ p ) = ' P , ( A s ; p ) = Q e ( A : ~ ) = c ( ~ ) -  
e,s 
Lemma 3.3 (Window Lemma): 
Let T be the set of true stages 
in the enumeration {A } 
of A. 
If C # Qi(A) then limt , :(is t) < m . 
s s t  W 
A 
( ~ e n c e .  since C # mi(A), for all i 5 e, lim 
R(e, t) < a, where 
t t T  
A R(e, s) = max{:(i, 
5 ) :  i S e) thereby satisfying (3.1). ) 
Proof. 
We know C j/ IPi(A) for all i 5 e. Fix i 5 e. Define 
- 
P = ~ [ C ( X )  
# Q).(A;x)]. Choose sf sufficiently large such that, for all s 2 st, 
1 

A 
Case 1. (v t 2 sl)[t t T =;> QiSt(At:p) undefined]. 
Then for any t 2 sf, 
A 
such that t E T , we have 
l(i, t) = p 
and 
:(i ,t) = max{u(i,x,sl): x< p}. 
Case 2. 
iiSt(At: p) is defined for some t t T I  t 2 st. Then ai(A; p) = 
. 
(As; p) for all s 2 t by (3.2). 
But C(p) # @&A; p). Hence, we have 
1, s 
A 
(V s 2 t) [f(i,s) = p & :(i, s) = :(i, t)]. 
d 
Theorem 3.4 
(Thickness Lemma - Strong Form ): 
Given a non- 
recursive r. e. set C and an r. e. set B there is an r. e. set A = B such 
that A < B and 
'T 
(a) (Ve)[c $,B(<~)] d 
[C $,A 
& A is a thick subset of B] 
(b) (V e ) [ ~  
PT B(< 
3 ( V i  5 e)[C # Qi(A) & 
8 B(~)]] . 
Furthermore, an index for A can be computed uniformly in indices for B 
and C. 
This strong form [26, p. 5201 follows by carefully examining the above 
proof and by replacing ;(e, s) in the definition of ;(el s) by 
A 
(modified length function) 
Ate, s) = max(x : (3 v <_ s)[x ~f (e, v) 
& ( V Y  ~ x ) [ ~ ~ [ ~ ( e , y ~ v ) l  
= A~[:(~.Y.V)~II . 
Corollary 3.5 (Sacks [21]): Let i0 
< i1 
< d < . . . be an infinite 
"2 
sequence of simultaneously r. e. degrees. 
Then there exists an r. e. upper 
bound 2 such that d < d < . . . < 2 < 2' 
(Hence, 2' is not a minimal 
NO 
-1 
upper bound for the sequence. ) 

Proof. 
Fix a recursive function h such that dg(W 
) = d 
for all x. 
h(x) 
3 
Define the r. e. set B by B(X) = { (x. y ) -: 
y t w ~ ( ~ $ .  Let C = K and 
apply Theorem 3.4 to obtain a thick r. e. subset A G B such that K IT 
A. 
By. thickness, 
= .(XI =+ A(x] 
Wh(x) - T 
so that d < dg(A) for all i. 
0 
"i 
The Sacks density theorem can be derived from the thickness lemma 
using the following results of Yates on index sets [31, pp. 312,3141 which can 
be proved without priority methods. If V is an r. e. set, let S t ZV denote 
3 
that there is a predicate R~ recursive in V such that x e S iff 
v 
Lemma A (Yates): 
{x: Wx sT V) t Z3 . 
v 
Lemma B (Yates): 
For any set S t C 
there is a recursive function 
3 
h(x) such that, for a11 x. Wh(x) 5T V 
and 
(a) x t S 5 (3 
e ) [ ~ ( ~ )  . 
v ir ( V i  < e)[w(i) 
is recursive]], 
h(x) 
T 
h(x1 
(el 
(b) x / S 3 (V e ) [ ~ ( ~ )  
is recursive 1. 
Theorem 3.6 (lndex Set Theorem - Yates [30]): 
Given r. e. sets C and 
C 
D such that D < C and S e Z 
there is a recursive function g(x) such 
T 
3 
that, for all x, 
(b) x t  S W W g(x) = T  C. 
Corollary 3.7  ensit it^ Theorem - Sacks [20]): If D and C are r. e. 
and D < C then there exists an r. e. set A such that D < A < C . 
T 
T 

Proof (Cor6llary 3.7): 
Let S = {x : Wx 
Dl. Then, by Lemma A, 
- 
T 
D 
s 6 z 
and hence S a zC 
Apply Theorem 3.6 to find g(x) such that 
3 
3 '  
DsTWg(x) IT C and Wx s T D  just if W &!(XI 
C. 
By the recursion theorem 
choose x 
such that Wx 
= W 
0 
. T h e n D X  W 
< C .  0 
0 
g(x0) 
T I3(xo) T 
Proof (Theorem 3.6): 
Fix V = C. S a Z
'
 
and h(x) the recursive 
- 
3 
function for S according to Lemma B. 
F o r  each x define the r. e. set Bx 
(e+i)= { ( e t ~ , ~ )  
:y t 
by ~
=
(
o
,
)
:
~
 
D 
and Bx 
W$;?)) . (Note that 
Bx 4 C for all x because W 
5. C and D STC. ) F o r  each x apply 
'T 
h(x) T 
Theorem 3.4(b) to Bx and C to find A x s  Bx, so that Ax ST Bx CT C . 
Moreover, for each x, D < A 
because A?) 
=* 
'
T
 
x 
B?) s T D  by 
Theorem 3.4(b) with e = 0. 
By the uniformity of Theorem 3.4, there i s  a 
recursive function g(x) such that W 
= Ax. Now if x / S then B
!
)
 
is 
g(x) 
recursive for all e > 0 by Lemma ~ ( b ) ,  
whence C $T Ax by Theorem 
3.4(b). 
If x E S then, by Lemma ~ ( a )  
and the definition of B, choose e such 
that 
~
(
~
1
 
s c & (V i)[O < i c e 3 B!) 
is recursive]. 
x 
T 
Hence, Bf 
zT D <T C. Therefore, by Theorem 3.4(b). 
A ( ~ )  =* 
B(e) s C ,  so that C IT 
Ax. 
Thus, Ax sT C b e u u a e  
x 
x 
T 
Ax ST Bx IT 
C* 
D 
The density theorem can also be proved directly without index sets 
[ 2 6 ,  p. 5251 by combining the infinite injury method with a clever coding 
method of Sacks. 

4. 
THE MINIMAL PAIR METHOD 
If P is any countable partially ordered set (poset), then the finite 
injury priority method enables us to embed P (by an order preserving 
map)into the r.e. degrees f? [Zl], and the infinite injury priority method 
allows P to be even embedded in any interval [z ,&I, for 2 .k c 
and 
a <& 
[15]. If P happens to be also a lattice then these embeddings 
N 
naturally preserve supremums (sups) but not necessarily infimums (infs). 
We now introduce a new method for embedding certain lattices into 
5 preserving both infs and sups. Consider the four element Boolean 
algebra 0 which we call the Diamond. 
In 54 we prove that the Diamond 
can be embedded into 5 preserving not only sups and infs but the least 
element as well. 
In 5 we replace the Diamond by an arbitrary countable 
distributive lattice. 
On the other hand, in 5 6 we prove the surprising 
fact that not even the Diamond can be embedded as a lattice in f? by a 
map preserving both least and greatest elements. 
A corollary is that the 
r. e. degrees are not closed under infs and thus fail to form a lattice. 
The embedding technique of 4 4 (called the minimal pair method 
because of Definition 4.1) is also one where some requirements are 
infinitary, but it is quite different from the infinite injury method of 
3. 
The version we present here (derived from [ 7 ] )  uses special stages 
analogous to the nondeficiency stages of 53 so that the negative restraints 
drop back simultaneously, and the proof closely resembles a finite injury 
As 
argument. For notational convenience we let {els (x) denote 
@ 
(AB: X) from now on. 
e,s 

Definition 4.1. 
Nonzero r, e. degrees 2 and & form a minimal 
pair if 
- 
Theorem 4.2 (Lachlan [4] - Yates [30]): 
There exists a minimal pair 
of r.e. degrees 2 and h . 
Corollary 4.3. 
The Diamond lattice can be embedded in 
pre- 
serving sups, infs, and least element. 
Proof. 
Let 5 = 5 V &  . Then {,$ ,2 ,k ,z) embeds the 
- 
Diamond lattice. 
l3 
Proof of Theorem 4.2. 
It suffices to construct r.e. sets A and B 
satisfying, fbr all e ,  i, j, the requirements 
Pte: A # Ge . 
'2e+l : B # We , and 
N 
A 
:{i) 
= {j}B = f total =.> f is recursive. 
( i , j )  
The following remark allows us to simplify the form of the negative 
requirements. 
Remark 4.4 (Posner): 
To satisfy all N 
, is j e w, it suffices to satisfy 
(i,j) 
for all e the requirement 
N: : 
{elA = {elB = f total + f ,is recursive. 
Proof. 
We may assume without loss of generality that we can arrange 
that A # B, say no e A - B. 
F o r  each i and j there i s  an index e such that 

The remark follows immediately. 0 
From now on we will replace all occurrences of negative requirements 
similar to N 0.j) by equivalent requirements N' 
and we will write the 
e '  
latter as Ne . 
Given {A ; 
t 5 s) and {B : t 5 s) we define as usual the functions 
t 
t 
As 
B 
(length function) 1 (e.s) = max{x: (V < x) [{els (y) = {els s(y)]} , 
(maximum length function) 
m(e,s) = max{ f (e,t) : t 5 s ) 
A stage s is called 0-maximal if l(0, s) > m(0, sai). Define the restraint 
function 
if s is 0-maximal , 
r(0, s) = 
the greatest 0-maximal stage t < s 
i" 
otherwise . 
(Notice that we can define the restraint function in terms of a stage s rather 
than an element z used in a computation at stage s since we may assume 
z 5 u ( A ~ ,  
e,x, s) s s, where u(As, e, x, s) is u(e, x, s) where A 
is the 
s 
oracle used in the computation. 
The strategy uo for meeting a single negative requirement N is to 
0 
allow x to enter AU B at stage s t 1  only if s is 0-maximal, and at most 
one of the sets A,B receives an element x at such a stage. Thus, if x 
- 
As 
s 
destroys one of the computations {0Is (p) = q o r  { o ) ~  (p) = q for some 
As 
Bs 
p < l(0, s), say { o ) ~  (p). then the other computation { o } ~  
(p) = q will be pre- 
served until the A-computation is restored, and outputs q again In this way 

B 
if {0}* = ( 0 )  
= f is a total function then f is recursive. 
(To compute 
As 
f ( ~ )  we find the least s such that p < 1(0, s) and we set f(p) = (0) 
(p). ) 
S 
Furthermore, lim inf 
r(0, s) < a, 
since lim inf r(0, s) = 0 unless there is 
s 
s 
a largest 0-maximal stage t ,  in which case r(0, s) = t for all s 2 t. 
This fundamental strategy of having one side o r  the other hold the 
computation at all times is applied to the other negative requirements Ne, 
e > 0, but with some crucial modifications to force the negative restraints 
to drop back simultaneously, thus creating mwindowsn through the restraints 
a s  in 5 3. 
F o r  example, to drop back simultaneously with N N must guess the 
0' 
1 
value of k = lim infs r(0, s). 
Thus, N must simultaneously play infinitely 
1 
many strategies 
kc o, one for each possible value of k. 
Each strategy 
"1 ' 
k 
u k  is played like a 
but with S = {s : r(0, s )  = k) in place of o a s  the set 
1 
0 
of stages during which it is active, and on which its length functions I and m 
a r e  defined. 
This allows uk to open its window more often since its length 
1 
k 
functions ignore the stages in w - S  . Strategy uk still succeeds if 
1 
any restraint it imposes is maintained during intermediate stages s / S k 
k 
while 
cr: 
i s  dormant. Thus, at stage s if k = r(0, s), we play ul , 
i 
maintain the restraints previously imposed by the dormant a 
i < k, and 
1' 
discard restraints imposed by u: . j > k. 
Thus if k = lim i d  r(0. s), then: 
s 
i 
(1) 
strategy u k  succeeds in meeting Nl; 
( 2 )  
the strategies ul, i < k, 
1 
impose finitely much restraint over the whole construction; and (3) the 
k 
strategies crj , j > k, drop all restraint at each stage s r S . Thus, the 
1 
entire restraint r(1, s) imposed by No and Ni together has 
lim ids r(1, s) < w . 

Construction of A and B. 
Stage s = 0. 
Do nothing. 
Stage s t 1  . 
Given As and Bs, define the restraint function 
r(e, s) for N 
by induction on e as follows. Define r(0, s) a s  above. 
e 
A stage s is let1)-maximal if 
Let . r(et1, s) be the maximum of 
0) r(e,s), 
(ii) those t < s such that r(e, t) < r(e, s), and 
(iii) those t < s such that r(e,t) = r(e, s) and t is (et1)-maximal, 
if s is not (et1)-maximal. 
Requirement P 
requires attention if 
2e 
(4-1, 
we,s n nS = ft , and 
(4.2) 
(3 
x)[x t W 
& 2e < x & r(e, s) < x] 
e,s 
and likewise for P 
with B in place of A. 
Choose the highest priority 
2et1 
requirement P which requires attention and the least x corresponding to 
e 
that e. Enumerate x in A id e is even (in B if e is odd). 
Lemma 1. 
( y e )  [lim ids r(e, s) < a]. 
Proof. 
We first prove the case e = 0. If there are infinitely many 
- 
Q~maximal 
stages then lim infs r(0,s) = 0. 
Otherwise lims r(O, s) is the 
largest 0-maximal stage. F o r  the inductive step, fix e and assume 
k = lim inf 
r(e, s). 
Then there are only finitely manv stages s such 
s 
that 
r(e, s) < k. 
Let t be the largest such. 
Let 

S = {s: r(e, s) = k). 
Either there are infinitely many (et1)-maximal stages in 
S, in which case Em inf l(et1. s) = max{t, k), o r  else there is a largest 
S 
(et1)-maximal stage v c S, in which case lim inf 
r(et1,s) = max{t, k,v). 
s 
Lemma 2. 
Every positive requirement is satisfied and acts at most 
once. 
Proof. 
Consider requirement P 
(since P 
is similar). First 
- 
2e 
2eti 
C 
A i s  infinite as usual by the second clause of (4.2). 
Now if We is infinite 
then W contains some x > lim inf r(e, s), and some such x is eventually 
e 
s 
enumerated in A satisfying P 2e ' 
Lemma 3. 
( v e )  [requirement N i s  met]. 
e 
Proof. 
Fix e and let k = lim inf r(e-1, s), and S = {s: r(e-1, s) = k). 
I 
s 
(1f e = 0 let S = o and k = 0.) 
Choose s t  such that no P i < e, acts 
iv 
after stage s t  and r(e-1, s) 2 k for all s 2 st. Now assume that 
{elA = {elB = f is a total function. To recursively compute f(p). p c o , 
:find an e-maximal stage s" e S, s n  
s t ,  such that ~ ( e ,  
st*) > p. 
Let 
AStt 
Bsn 
q = {e)stt (p) = {els 
(p). We will prove by induction on t that for all t 2 sn 
either 
A 
and hence that f(p) = q. 
Suppose that x destroys the last of the computations 
(i) o r  (ii). Now if x enters A V B at any stage s t 1  such that s t S then 
s must have been e-maximal, so both (i) and (ii) hold for t = s. But x can 
destroy at most one of the computations, so the other holds at t = s t l .  

Furthermore, x cannot enter A u B at stage s + l  for s / S, s > s", since 
r(e, s) 2 x  by clause (ii) in the definition of ~ ( e ,  
s). 
Q 
This construction can be modified in a number of ways. First, one 
can construct an r. e. sequence of r. e. degrees {2i: i e w} 
such that 
a a 
i s  a minimal pair for each i # j. 
Next, by allowing infinitary positive 
wiP-j 
requirements a s  in 5 3, one can construct a minimal pair 5 ,i 
of r. e. 
degrees which are high (i. e. . 
= 
= 2") (see Lachlan [4]). 
5. 
EMBEDDING DISTRIBUTIVE LATTICES IN THE R. E. DEGREES 
Using a fairly easy modification of the preceding method we will now 
replace the Diamond lattice of Theorem 4.2 by any countable distributive 
lattice. Since any countable distributive lattice can be embedded in the 
countable atomless Boolean algebra it suffices to prove the following. 
Theorem 5.1 (Lachlan-Thomason [29]): 
There i s  an embedding of a 
countable atomless Boolean algebra 8 into the r. e. degrees f? which pre- 
serves sups, infe, and least element. 
Proof. 
Let {a.: i c w} 
be any uniformly recursive sequence of 
- 
1 
recursive sets (i. e., ( ( x, i ) : x c ai} is a recursive relation) which forms 
an atomless Boolean algebra 73 under U , n , and complementation, con- 
tains o and has jd 
a s  its only finite member. 
We will construct r.e. sets 
Ai, i c y and define A 
= { <  i,x > : 
x r  A. & i c a) for a c 73. Notice that 
(I 
we immediately have 

(5.1) 
dr(Aa "g) 
= ds(AJ v dg(Ap) . 
(5.2) 
a Z B => de(A,) I dg(Ag) , and 
We will further meet for all i.a, 8 the requirements 
N 
A a 
a ! , , j :  { j 
= {jfp 
= f total 5 
f < A 
-T a n e '  
These requirements insure 
Note that (5.1)-(5.5) guarantee that the map a -, dg(A ) is the desired 
Q 
embedding, and (5.5) guarantees that the map i s  1: 1. (To see that the 
negative requirements insure (5.5) suppose: 
(1) dg(Aa) 5 dg(AB): but 
(2) a $ f3, say i r a - B. 
Then dg(Ai) (dg(Aa) I dg(A ) by (5.2) and (l), 
B 
but d g ( ~ , )  5 dg(A- ) by (2). 
Hence dg(Ai) 
dg(A 
-) = dg(A4 = 2 by 
B 
B"B 
(5.4)' contradicting A nonrecursive. ) 
i 
The strategy for meeting the negative requirements N 
begins 
(a9 B.j i 
a s  before. 
Denoting N 
by Ne , where a! = a 
= a. , and 
(ao B.j) 
i '  
i 
I2 
e = (il. i2. j ) 
we define the restraint function by induction on e exactly 
a s  in 5 4. 
However, new difficulties in proving Lemma 3 (that N 
i s  satis- 
e 
fied) require greater care in enumerating elements for the positive 
requirements. To meet requirement P <i.j > we will appoint followers 
x r w so-called because the eventual enumeration of x in A. will satisfy 

'<i, j > (although x may be cancelled before this happens). If x is a follower 
of P. and y a follower of P. then we say x has higher priority than y (x< y) 
1 
1 
if i < j o r  i = j and x was appointed before y. 
We will arrange for all 
followers x and y existing at stage s that 
x 4 y 
iff x < y. 
Construction of A 
i r o : 
i' 
Stage s =, 0. 
Do nothing. 
Stage s t 1 . Requirement P 
is satisfied if 
<i, j> 
A. 
A W. 
# 8. 
Requirement P 
requires attention if P 
<is j> 
<,, j> is not 
1,s 
J v  8 
satisfied and either 
(5.6) 
x t W. 
and x > r(<i, j) , s )  for some uncancelled follower x of 
$ 9 6  
P 
o r  
<i9j> ' 
(5,7) 
x e w .  
ioreveryuncancelledfollowerxof P 
. 
J I  s 
Ci, j) 
Let P 
be the highest priority requirement which requires 
<i, j> 
attention. If (5.6) holds for some x enumerate the least such x in A.. 
If 
(5.6) fails, and (5.7) holds, then appoint x = s t 1  a s  a follower of P <is j> 
In either case cancel all followers y of lower priority than x (i. e. . x d  y). 
(If no P 
requires attention, then do nothing.) 
Ci, j > 
Lemma 1. 
( v e )  [lim infs r(e, s) < a]. 
Proof. 
Exactly a s  in $4, Lemma 1. 
Lemma 2. 
(t/ e)[P receives attention at most finitely often and 
e 
i s  met 1. 
Proof. 
Fix e and chooge s 
such that for no el < e does Pel 
0 
receive attention after stage s 
Let k = lim ids r(e, s) by Lemma 1. Let 
0' 

e =  < i , j ) .  
Nowif P 
receives attention infinitely often, then some 
<i,j> 
follower x > k is appointed to follow P 
and x is never cancelled. 
Ci. j) 
Furthermore, x o W. by (5.7). 
Hence, there is a stage t t l  > s 
such that 
J 
0 
r(e,t) < x and x E W. 
Now x o r  some smaller follower of P is enumer - 
~ r t '  
e 
ated in A at stage t+l, P is met, and P never again requires attention. 
e 
e 
Therefore, P receives attention at most finitely often. Finally, P 
i s  
e 
(iIj) 
met because otherwise 
= W. , x t  W. for every uncancelled follower x of 
i 
J 
J 
P(i,j)and '(is j) receives attention infinitely often under (5.7). 
Lemma 3. 
( v u )  ( v  B) (V j) [requirement N 
Proof. 
Fix N 
= N 
- 
Choose k,S and stage s1 a s  in Lemma 3 
e 
(u,B,j)* 
A, 
of (4. Assume that {j) 
= { j t S  = f is a total function. 
A computation 
A 
{e)sv* '(x) is A ,-correct if A 
[u] = A,[u] 
where u = U(A,,~, e. x, s). 
6s 
To A 
-recursively compute f(p), find an e-maximal stage s t S, s > s', 
U
~
B
 
A 
such that l(e, s) > p and both computations {e) 
= q and 
A 
S 
{els S's(p) = q a r e  A 
-correct. 
We will show by induction on t that for 
u n B  
all t z  s either 
via an A 
-correct computation. 
Now if x destroys either computation 
a n  S 
(5.8) o r  (5.9) by entering A u u  A 
at stage t t i  then t must have been 
B 
e-maximal and t o S (as in Lemma 3 of 14) so &tJ 
computations existed at 
the end of stage t. 
By inductive hypothesis at least one computation, say 
(5.8). i s  A n B
-
~
~
~
~
~
~
~
.
 
Suppose x is enumerated in A at stage t t l ,  
u 
destroying this computation. Then x cancels at stage t t l  all followers y 

such that x < y (since these are exactly those followers y such that x< Y). 
Furthermore, z > t t l  2 u 
, , p) for any follower z later 
p =dfn U(Ap,t' 
appointed. But x 
uu =an~(Au,t, e, t, p) since the A-computation is des - 
troyed by x. 
Also A 
u ] since the Au-computation (5.8) 
u n ~ . t [ ~ u '  
= 
p[ u 
was A 
-correct. 
Hence A 
[ttl] = A 
[ttl], and u 5 t t l  so the 
ffn B 
ff - Brt 
fffi B 
B 
A computation (5.9) now becomes Au 
B - 
-correct. 
Corollary 5.2. 
Any countable distributive lattice can be embedded into 
the r.e. degrees f? by a map which preserves sups, ids, and least element. 
Embedding nondistributive lattices into f? is much more difficult. 
Lachlan [6] showed that the following two 5-element nondistributive lattices 
M (a modular lattice) and N (a nonmodular lattice) can be embedded in 5 
5 
5 
by a map preserving sups, infs, and least element. 
This partial success led many to believe in the Embedding Conjecture 
which asserted that every finite lattice can be embedded in 5 a s  a finite 
lattice. This conjecture was recently refuted by Lachlan and Soare [lo] who 
showed that the following lattice S8 cannot be embedded in f? a s  a lattice. 

The obstacle to embedding S8 is that for & to be the sup of the lower 
M5 lattice, an elaborate system of traces is required for enumerating ele- 
ments into the set of degree 2 .  This interferes with the delicate minimal 
pair machinery above which insures that 2 i s  the inf of a 
and a 
-0 
-1 ' 
The most important open question on 5 is that of the decidability of its 
elementary theory. Considerably more structural results (such a s  
embedding and nonembedding theorems) will be required to meet this goal. 
6. 
THE NON-DIAMOND THEOREM 
One might expect to extend Theorem 5.1 by constructing lattice 
embeddings which preserve both greatest a s  well a s  least elements. The 
following surprising theorem shows this is impossible even for the Diamond 
lattice. 
6.1 
Non-Diamond Theorem (Lachlan [4]): 
If 2 a n d 2  a r e  non- 
recursive r. e. degrees such that 2 u 
= 2' then there is a nonrecursive 
r. e. degree & such that 2 < 5 and ,$ < 5 . 
Proof. 
Let A and B be r. e. sets in degrees 5 , i  respectively, 
- 
and 
, , 
. {bs) , be recursive enumerations of A and B. 
Let 
As = {at: t 5 s) and Bs = {bt: t <_ s). 
We will construct coinfinite r. e. 
sets E and F such that one of these sets has the desired degree 2. We 
attempt to meet for each i and j, i < j, the requirement 
0 
As an aid in the construction we will also construct a A 
set D. 
2 
Since dg(A 8 B) = 21 we may assume (using the Recursion   he or em) that 

we can fix at the beginning bn index e such that D = {elA' 
Let u(k, s) 
denote the use function u(AsQ Bs,e,k, s). (For X = D, E o r  F, let Xs 
denote the elements in X at the end of stage s.) 
In order to insure that E < A and E < B we will enumerate a 
-T 
-T 
number x in E at stage s only if numbers c x  are enumerated in both A and B. 
For example, to satisfy the requirement R.: W. n E j $d suppose x c WiSs , 
1
1
 
a 1 x, and u < x 
for some k 
such that 
{e} ASQBS 
s 
s 
(k) = Ds(k) , 
u = u(k, s). 
We can now attack this requirement by inserting or extracting 
the attacker k from D according as D (k) = 0 Qr 1. 
Since D = {e}A'B 
S 
this forces a number z I u to be enumerated in either A or B. 
If z is 
enumerated in B then the attack is successful and we enumerate x in E 
satisfying R. forever. 
1 
If there are infinitely many unsuccessful attacks on R 
we must insure 
i' 
that F n W. # jif for all infinite W.. 
Thus, we do not attack as above unless 
J 
J 
there is t < s such that y c W. 
b < y, and u < y. 
Now after the attack, 
3,t' 
t 
if z is enumerated in A, then we can enumerate y in F and argue that 
F I A and F ST B. 
Thus we do not attack R. directly but rather require- 
T 
1 
ment P. 
via the attacker k = j. 
An attack on P. 
succeeds in 
1. j 
1.j 
satisfying P. 
forever so P. 
is never attacked again. Thus, D is A 0 
1. j 
1. j 
2 
because each j is inserted in (or extracted from) D finitely often, namely at 
most once for each P. . , i < j. 
1. J 
Construption. 
Stage s = 0. 
Do nothing. 
Stage s + 1 . Requirement P. 
requires attention if i < j, 
1. j 

P. isnotyetsatisfied(i.e., E s n W i s s = $  and F s n W .  
=fi, andthere 
1, j 
J * S  
i s  a pair (x, y) satisfying: 
AsCBBs 
(1) {els 
(j) = Ds(j) 
(3) x e Wi, , and 
(4) there is some t < s such that: 
(b) 
and 
A 8 B  
(c) (As@ BS)[u(j.t)l = (At@ Bt)[u(j.t)l 8 {el 
'(j) converges. 
(Note that these conditions imply u(j, s) = u(j, t). ) 
Choose the least (i, j > such that P. 
requires attention and the 
1, j 
least corresponding pair <x, y > . Insert o r  extract j from D to insure 
Ds+i(j) # Ds(j) 
Enumerate A and B until the first number z < u(j, t) 
appears in AU B. 
(If no such z appears, the construction stops. 
How- 
ever, i f  e is the index obtained by the recursion theorem satisfying 
D = {e}A8B, then z must appear.) 
If z appears in A, enumerate y in F. 
If z appears in B, enumerate x in E. 
0 
Lemma 1. 
The set D is A2 and hence D < f#. 
-T 
Proof. 
An integer j i s  inserted o r  removed from D only when some P. . 
- 
1sJ 
with i < j receives attention, but each P. 
receives attention at most once, 
1. j 
so j is inserted at most finitely often. 
Lemma 2. 
The sets E and F a r e  coinfinite, E IT 
A, E < B, and 
-T 
F I T A .  

Proof. 
The sets a r e  coinfinite by the conditions x > 2i, y > 2j of (2) 
- 
and (4). The < reductions follow by the usual permitting method. 
(For 
T 
example, to A-recursively decide whether x c E, find s such that a > x for 
t 
t >  s. 
Now x e  E iff x c  Es .) 
Lemma 3. 
If E i s  recursive, then 
(i) F i s  nonrecursive, and 
(it) F sT 
B. 
- 
Proof of (i). 
Fix i such that W. 
= E. 
If F is recursive, choose 
0 
lo 
the least j > i 
such that W. = F. Choose s 
such that for all s 2 s 
0 
J 
0 
0 '  
u(js s) = ~ ( j ,  
so) and (A 8 B)[u] = (AS O BS )[u], where u = u(j, so). Now 
0 
0 
since B is nonrecursive, there exist y > u and t > s 
such that y c W. 
0 
Jet0 
and y is permitted by B at stage t, i. e., such that (4)(a), (b) and ( c )  hold 
for y and any s > t. But since A is nonrecursive there exist infinitely many 
x c Wi satisfying (1),(2) and (3) for some s > t. Hence requirement P 
. 
0 
ios J 
receives attention, and either E 0 W. # $ o r  F n W. # $ contrary to 
'0 
J 
hypothesis. 
Proof of (ii). 
To prove F < B we may first assume that we know 
'T 
those finitely many y contributed to F by some P. 
with j <_ i 
F o r  each 
1. j 
0' 
remaining y, to decide whether y c F we B-recursively find the largest t 
such that b <_ y. 
Consider all j > i0 such that (4)(a), (4)(b) and the second 
t 
clause of (4)(c) hold for y and t. F o r  each such j find the least s I t  such that 
either: 
(5) 
(As@ BSICu(j.t)l f (At@ BtICuO.t)J. 
(in which case clause (4)(c) prevents P. 
for anv i from putting y into F after 
1.j 
stage s), o r  
( 6 )  
w. 
Fs f a .  
J *s 

in which case if'y r E for P. . then y r Fs. Note that if (5) fails then (6) must 
1.3 
hold because a s  in part (i) there are infinitely many x r W. 
satisfying (I), 
(2). 
1 0 
'and (3) and thus eligible to form a pair with y for P. ., so P. . will receive 
I,,* J 
lo* J 
'attention. 
Theorem 6.2 ( ~ a c h l a n  
[4]). 
If 2 ,i are r.e. degrees and $ is a 
degree ( 2  and 52 then there is an r.e. degree 
such that 2 
3 22 , 
,$<A. 
Proof. Fix r.e. sets A r 5 . B r & and indices e, i such that 
- 
{elA = {ilB = D for some set D r 2 .  Let { A ~ )  
and (8,) 
be re- 
cursive enumerations of A and B. As usual define the recursive length 
function , 
As 
Bs 
l(s) = max{x: (v Y < x)[{eIs 
(y) = {iIs (Y)] 1. 
For each x define an r.e. set Cx a s  follows. At stage s, if l(s) 7 k and 
As 
At 
{e), 
(x) # {e) (x) where t = max{v: v < s & l(v) > x), then enumerate in Cx 
t 
all s t  < s. 
(Hence, Cx contains all those stages t such that the common 
A 
& 
B. 
values y = {el+ '(x) = {i) '(x) is later replaced by a new common value 
A s 
s 
y1 = {els (x) = {iIs (x) at some stage s > t. 
Thus. for any s / Cx, if I(s) 7 x 
A s  
A 
B 
then {els (x) = {i)P(x) = {e) (x) = {i) (x).) Now set C = O  {Cx: x r u). 
C1earlyCisr.e.. D <  C, and C + A , B .  
0 
-T 
Corollary 6.3 ( ~ a c h l a n  
[4]). 
There are r. e. degrees 5 ,& with no 
infimum. Hence, the r. e. degrees do not form a lattice. 
Proof. Let 2 ,& be incomparable low r. e. degrees with fiuk = 0' 
P ' 
(obtain these by the Sacks splitting theorem.) Let 
be any degree below 
both2 and 2 . Now $ = $  
since 2' = 2'. so the relativization to 2 of 
Theorem 6.1 produces 5 7 2 , such that 2 < fi . 5 < 
and by Lemma 6.2 
we may assume that & is r. e. Thus 2 and 2 have no infimum in the 

upper semi-lattice of r. e. degrees o r  even in the upper semi-lattice of= 
degrees. 
0 
Recently, Jockusch has given an easy direct proof of Corollary 6.3. 
Jockusch has also noted that the method of Theorem 6.1 easily yields the 
following generalization. 
Let 
g = (2 : 2 is r. e. and one half of a minimal pair). 
No finite supremum of degrees in 
is 2'. Hence, by applying the Sacks 
splitting theorem to K there is a low degree which is not below any finite 
supremum of elements of g. 
Lachlan [ 4 ]  raised the question of whether incomparable r. e. degrees 
b 
satisfying 2 u 2 = 2' can ever have an infimum. Shoenfield and 
2.- 
- 
Soare [ 2 4 ]  and independently Lachlan [ 9 ]  showed that they could. Indeed, 
Lachlan combined a new method of preserving infimums with the. Sacks 
preservation method fj 2  to obtain the following pleasing generalization of the 
Sacks splitting theorem. 
Theorem 6.4 (Lachlan Splitting Theorem [9]): Let A be a nonrecursive 
r. e. set. There exist r. e. sets B , B 
and C such that 
0 
1' 
(a) C S T A  
(b) B ~ U B ~  
= A  and 
B 0 n B 1 = $  
(c) Bi,i CT Bi 8 C  , i =  0.1 
(d) dg(C) = dg(Bo B) C) A dg(B1 @ C). 

Thus, for any r. e. degree 2 > 
there a r e  incomparable r. e. 
degrees b = d g ( ~ o B  
C) and 
b 
= d g ( ~ ~  
8 C )  which have supremum 
-0 
-1 
a and infimum 2 = dg(C). 
U 

7. THE RENAISSANCE IN CLASSICAL RECURSION THEORY, 
THE SACKS DENSITY THEOREM AND BEYOND 
This lecture should be numbered Lecture 3.5 since it was delivered 
as a special lecture between Lectures 3 and 4 and relies on the material and 
methods developed in Lecture 3. 
The other six lectures were written before 
the actual meeting, while this lecture was written after the meeting. The 
main mathematical content of this lecture is the density theorem as well as 
some recent generalizations and related work. 
We begin, however, with 
some informal remarks which were inspired during the meeting and were not 
included in the earlier written text. The extra references given here are 
numbered to follow consecutively those of the previous lectures. 
The term ordinary recursion theory ( ORT) 
has occasionally been 
used to describe recursion theory on o to distinguish it from various forms 
of generalized recursion theory ( G R T )  
such a s  &-recursion theory, 
p-recursion theory, o r  recursion on higher types. The former term is of 
course a misnomer and has now been replaced by the term classical recur- 
sion theory (CRT). 
An analogy between classical recursion theory and classical art 
seems appropriate for these lectures delivered in Italy, the birthplace of the 
Renaissance. The art and architecture of the Italian Renaissance is 
characterized by balance, harmony, simplicity, and a self -contained world 
on a human scale. In a Renaissance courtyard the human figure feels at 
home and in scale with his surroundings, unlike the human figure standing 
before amonumental archor a modern skyscraper where it is dwarfed by the 

by the immense size of the architecture. Likewise, in CRT the universe is 
merely the natural numbers which the human mind can readily grasp, and not 
some large ordinal or higher type object. 
A Renaissance painting is 
characterized by simplicity of line and composition. The beauty of CRT lies 
in the great simplicity of its fundamental notions. For example, the notion 
of an r. e. set as one which can be effectively listed is one of the fewnotions 
in higher mathematics which can easily be explained to the common man. 
In a Renaissance painting one is immediately etruct by the symmetry 
and balance of the composition. Not only are the background buildings in 
s yrnmetry, but the composition of the figures themselves reveals a harmony 
and balance. For example, in a typical Renaissance painting, the gesture of 
each figure carries the eye to another figure and on to the next in carefully 
designed circular patterns, emphasizing a self-contained and harmonious 
world. In CRT the most beautiful work is characterized by a delicate balance 
and resolution of conflict between opposing requirements. The action taken 
for the negative require Ne must be sufficiently strong to satisfy Ne but not 
so strong as to prevent the next positive requirement Pe from being satis- 
fied. (In other words, Ne must not f i l l  the whole painting but must lie in 
balance on the canvas with Pe. ) This became dramatically apparent in our 
development of the infinite injury priority method in 5 3. 
Our naive first 
attempt to satisfy requirement Ne using the old restraint function r(e, s) 
would have thrown all the weight in favor of Ne, leaving P, forever un- 
satisfied. A proper balance was restored with the "hat trick" of keplacing 
r(e, s) everywhere by 
?(e, s) which enabled us still to satisfy Ne 
(Lemma 3.2 Injury Lemma) but yet to keep Ne in proper proportion 

(Lemma 3.3 Window Lemma) so that P saw a %vindow' through the wall 
e 
R(e,s) of restraint functions at least infinitely often (lim inf R(e,s) < a) 
and 
s 
so P was eventually satisfied. 
e 
In contrast, recursion theory on admissible ordinals (&-recursion 
theory) resembles a Gothic cathedral in that the human figure stands before 
lofty pointed spires carrying the eye ever higher toward the sky. This eye 
movement is not continuous, however, but proceeds step by step along the 
regular niches and protrueions of the Gothic lines just as the a- recursion 
theorist climbs ordinal by ordinal ever toward a. The Gothic architect 
thickened the walls of his cathedrals to the absolute limits in order to sup- 
port still higher spires. His thirst for height remained unquenched, however, 
until he later developed flying buttresses to support the walls and achieve the 
dramatically soaring Gothic spires of the cathedrals at Chartres o r  Notre 
Dame. In developing p-recursion theory the ordinal recursion theorist 
abandoned the thick walls of Z -admissibility for the flying buttresses of the 
i 
fine structure of L in his passion to carry recursion theory ever on into the 
heavens. 
Baroque painting of the sixteenth and seventheenth centuries i s  analo- 
gous to recursion on higher types. In a typical Baroque painting the human 
figures a r e  in a room with an open window in say the upper right corner. 
The figures a r e  arranged in a strong diagonal pattern from lower left to 
upper right, pointing toward the open window. 
The eye i s  carried 
dramatically by the composition and gestures of the figures toward the open 
window and a vast unknown space beyond. 
(Gone is the symmetry and self- 
contained world of the high Renaissance.) Analogously, in recursion on 

higher types the human mind is carried suddenly to a vast and unknown space 
whose geography i s  only hinted at by analogy with the human figures (CRT) in 
the foreground. 
Returning to the analogy between Renaissance art and CRT, the 
period of Graeco-Roman antiquity corresponds to the period for CRT of 
1931 -1944 which included the formal definitions of recursive functions, the 
existence of nonrecursive r. e. sets and their use in G5de11s Incompleteness 
Theorem. This period culminated in the remarkable 1944 paper of Post [14] 
in which he discarded the formalism associated with the development of 
recursive functions in the 1930's and revealed in a clear informal style the 
fundamental properties of r. e. sets. The period of 1945-1955 constitutes the 
Dark Ages when relatively little progress was made on Post's problem o r  
CRT with a few exceptions such a s  Dekker [2] and Kleene-Post [35]. 
The early Renaissance for CRT is the introduction of the priority 
method by Friedbsrg [3] and Muchnik [13]. 
The analogous artist of the 
Italian Renaissance i s  Giotto, the first of the great Florentine painters. The 
paintings of Giotto's contemporaries a r e  flat and two-dimensional. 
What a 
contrast to Giotto who gives his figures with light and shade and functional 
line such a massiveness and three-dimensional quality that we believe we 
could reach out and touch them. This dramatic beginning of the conversion 
of the flat canvas into a three-dimensional world i s  equivalent in CRT to the 
priority method of 5 2 which has been of central importance ever since. 
The Florentine school of painting developed over the next two 
centuries and into the high Renaissance a remarkably accurate mathematical 
perspective and drawing which not only created a full three-dimensional 

space for the figures on canvas but endowed them with a vibrant energy a s  
well. 
The Florentines said disparagingly of their rivals in Venice (who were 
renowned for their use of color and subtle hues like those of Venice itself) 
that the Venetians would be good painters if they could only learn to draw. 
This supreme emphasis on discipline and drawing corresponds in 
CRT to the emphasis on hard combinatorial arguments and ever more diffi- 
cult devices to resolve the conflict between opposing requirements. 
The 
high Renaiesance for CRT which continues to the present day began in the 
early 1960's with the introduction of the infinite injury priority method, 
whose development was described in Lecture 3. 
The most important and 
beautiful result during this period is the Sacks density theorem which re- 
mains the Mona Lisa for r. e. degrees. 
However, one difference between Renaissance art and CRT is that the 
beauty of a painting i s  instantly apparent while a difficult proof may stand for 
years before the theorem is sufficiently well understood to admit a simple 
proof revealing its inherent elegance and beauty. 
The following proof [25] of 
the density theory combines the simplified infinite injury method of Lecture 3  
with the original coding strategy of Sacks [20]. 
Before giving the proof of the density theorem we must develop a few 
more properties of the simplified infinite injury method of § 3. 
(More details 
can be found in [25]. ) Let C be a fixed nonrecursive r. e. set and A an 
r.e. 
set which we are constructing. Let {A,\ 
and 
{C,} sc 
be re- 
cursive enumerations of AandC' respectively. Let T be the true stages of 
the enumeration of 
A as defined in $3. 
Let the restraint function 3(e, s) 
A 
and the injury set Ie be defined a s  in $ 3  but with the length function 

A l(e, s) replaced everywhere by &(e, s) defined in 9 3 following 
Theorem 3.4. 
The point of I% 
is to record a length of agreement between Cv and 
2 
(AV) established at some stage v for a s  long a s  the 6 (A) side. re- 
e,v 
mains unchanged even though a change in the "C sideu at some stage s >v 
may cause ;(e,s) < ;(e,v). 
The use of & immediately yields by (3. 2) cer- 
tain convenient properties such a s  Remark 7.4 below and also 
Now virtually the same proofs a s  in Lemmas 3.2 and 3.3 establish 
the following lemmas. 
A 
Lemma 7.1 
(Injury Lemma): 
If 
C LTIe then C # Qe(A). 
Lemma 7.2 (Window Lemma): 
If C f Q ~ ( A )  
then limt 
;(e, t) < m. 
A 
( ~ e n c e ,  if C # Qi(A), for all i S e, then lim 
~ ( e ,  
t) < m, where 
t t T  
A 
R(e, s) = max{f.(i, s) : i 
e) . ) 
In Theorem 3.1 (Thickness Lemma), if we assume 
bT ("'1 
instead of B piecewise recursive, then the earlier 
A 
proof still suffices, because Ie CT A (<el =* B ( < ~ )  and the Injury Lemma 
.) 
 e em ma 7.1) requires only that C & T ~ e  . Indeed, locally we have proved 
that, for each e, 
=U{A!) 
: i <  e) and let Te be the set of 
Remark 7.3. 
Define As 
of the r.e. set A(<e). 
Let 
true stages in the enumeration { A ~  )sew 
e 
B(e, s) = mu{:(i,s) : i 5 e) . Then T ST A (< 
and if * Ie C_ A 
then 

(7.2) 
(V t t T ~ ) ( V X  
5 ~ ( e ,  
t))[;est(~t;x) 
= y * @,(A; x) = y] 
and 
(7.3) 
( v t  ~ T ~ ) ( v s  
2 t)[&(e,t) 5 &(e,s) & g(e, t) sfi(e, s)]. 
A 
Proof. 
Since 1 5 A(< 
(7.2) follows as (3.2) and (7.3) follows 
- 
e 
a s  (7.1). 
Remark 7.4. 
For A and B a s  in Lemma 3.1 we have automatically achieved 
ASTB. 
Proof. 
Fix e and assume that for all i < e we have B - effectively 
- 
computed g(i) such that 
= 45 
(B). 
Then B-effectively compute A (< e) 
g(i) 
and 
TO. 
NOW if x. B ( ~ ) ,  say x t B r ) ,  let tt = pt[t 2 s & t t T ~ ] .  Hence, 
x t A ( ~ )  
just if x t A$) by (7.3). 
All these remarks combined yield a proof of Theorem 3.4 (Thickness 
Lemma - Strong Form). 
Theorem 7.5 ( ~ e n s i t y  Theorem - Sacks [20]): Given r. e. Bets D and 
C such that D < C there exists an r. e. set A such that D < A < C. 
T 
T 
T 
Proof. 
Fix recursive enumerations {C ) 
- 
a s t d  {Ds)sto of C and D. 
Define A!') 
= { ( 0, y )  : y r D,) 
so that D < A. 
We shall arrange A < C 
'T 
-T 
a s  in Remark 7.4 by finding a C-recursive function g such that 
A(.) 
= @ 
(C) for all e. 
To make both inequalities strict, it suffices to 
s(e) 
meet, for all e > 0, the requirements 
Ne: C f ee(A) 
and Pe: A # Qe(D). 
To meet Pe we attempt to code C into A(e) so that if A = q ( D )  then C 
D 
contrary to hypothesis. 

Let A. 
= #. 
Given {A,: t 
s) define :(e, s) as in $ 2, and define 
r * D (e, s) = max{x: (V y < x)[As(y) = A 
Q, 
(Ds, Y)]). 
e .s 
Let < e,x, s )  denote <e, <x, s>> . For t <_ s, and e > i enumerate 
<e,x, t) in A 
just if <e,x, t) > ;(i, s) for all 0 < i <_ e, x L Cs+i and 
s t  i 
*D 
r < 1 (e,v) for all v. t-< v 
s. 
Let A = Us A, . 
(We visualize this coding strategy a s  follows. Fixing e, the elements 
{<e, x, y > : x, y e w) 
are arranged in a plane. 
A "coding marker" is assigned 
D 
to <e,x, t > at stage t if I (e, t) > x. 
The marker i s  later removed (forever) 
AD 
at some stage s > t if I (e, s) 5 x. 
If x r Cs+l then all elements (e, x, t>, 
t 
s, still possessing markers at stage s and not restrained with higher 
priority are enumerated in A s+i '1 
To see that A succeeds we shall verify the requirements by induction 
e) 
on e ahd simultaneously C-recursively define g(e) such that A( 
= Q g(e)(c)* 
(O) 
D < C. 
Fix e > 0 and assume, for 
Clearly, g(0) exists because A 
I T  
T 
all i, 0 < i < e, that 
(7.6) 
Ag) is recursive, and 
(7.7) 
A") = @ 
(C). where g(i) has been C-recursively computed. 
g(i) 
Lemma i. 
C # %(A) . 
Proof. 
Now A(<e) < D because A@) is recursive for O<i< e. 
Let 
7 
-T 
(<el 
ie be the injury set for Ne defined in $3. Then ieE 
A(<.) 
and hence I
e
~
~
. 
Thus, 
< D < C. Hence, C # Q ~ ( A )  
by the injury Lemma (Lemma7.1). 
-T 
T 

Lemma 2. 
A # Qe,D). 
Proof. 
By Lemma 1 and the Window Lemma (Lemma 7.2), 
A 
$(el = lim inf ~ ( e ,  
s) where B(e,s) = rnax{:(i,s):o 
< i 
e). 
If A = f (D) then 
s 
AD 
limsI (e,s) = co. Since D is r.e., we can D-recursively compute the modu- 
lus function: 
M(X) = (ps)(\d t 2 s)[: D(e, t) > XI. 
For x>;((e), x t C just if < e . x , ~ ( x ) )  t A. 
Hence. C S T A L  D con- 
T 
trary to hypothesis. 
(Note that M is a D-recursive function because D r. e. 
rD 
implies that M(x) = ( ~ s ) [ l  (e, s) > x & D~[u] 
= D[u]], where 
u = m a x ( u ( ~ ~ , e , y ,  
s): y l x )  .) 
Lemma 3. 
A'~) is recursive. 
Proof. 
By Lemn.a 2, let pe = (px)[A (x) # 9 
; x)]. Then 
AD 
lim inf I (e, s) = p . For x 2 p 
given x and t find s 2 t such ttat 
s 
e 
e 
AD 
I (e,s)=pe. Then < e , x . t > t A  justif <e,x,t) 
c A s .  
For x < p  e fix 
A 
s1 such that C [ >,= C[pe] and R(e,s) = B(e) for a11 s > st. Given t define 
st 
- 
Then < e , x , t > t  A justif <e,x,t> a Av,. 
Lemma 4. 
We can C-recursively compute g(e) such that 
Proof. 
Define T~ as in Remark 7.3. 
From {g(i) : 
i < e) , we 
- 
e 
C-recursively compute A 
andhence T . Fix (e,x,t). 
1f X / C  
then (e,x, t > / A. 
If x t C, say x t Cs , define 
Then (e,x,t > t A 
just if (e,x,t > t Avt by (7. 3) 

(Notice ihat we do not claim here that (7.6) and (7.7) can be combined 
to produce a C-recursive function g such that 
cp 
is the characteristic 
g(e) 
function of A(e) for all e > 0, but merely that A ( ~ )  
= QI 
(C). The point 
g(e! 
i s  that even though A ( ~ )  
i s  recursive for all e > 0, the proof of Lemma 3 
A 
above depends upon parameters p 
and R(e) which cannot be C-recursively 
e 
computed uniformly in e, and the proof of Lemma 4 clearly uses a C-oracle 
for each x.) 
The abbve coding procedure has many other applications such as the 
following. 
(The nonuniform version of the theorem follows immediately 
from the Sacks Splitting Theorem. The uniform version requires an infinite 
injury argument and was proved by Yates [ 3 i ]  using index sets.) 
Theorem 7.6 packs-~ates): Given any r. e. set C such that 
$ < 
C < 
$I 
there exists an r. e. set A such that A i s  Turing incom- 
parable with C. Furthermore, an index for A can be found uniformly from 
one for C. 
Proof. 
It suffices to meet for all e 2 0 the requirements 
Ne: G # QIe(A), and Pe: A # .Q),(C). 
Let K = {e: e c we) 3 8' . In place of 
T 
the hypothesis D < G of Theorem 7.5 we use the hypothesis C < K so that 
T 
T 
C and K play the former roles of D and C respectively. Let A. 
= 8. Given 
{Cs) S E  b, * 
sc w and { A ~ :  t C. s) a s  usual define 
A C 
1 (e, s) = m a 4  x: ( V y  < x)[As(y) = QI 
(Cs; Y)D. 
e ,s 
F o r  t ( s  enumerate < e,x,t > in A 
just if <e,x,t > > 3(i, s) for 
s t  i 
AC 
all i c e , x c K  
and x < l  (e,v).forall v, t i v i s .  Let A z U S A s .  
sti' 

F.ix e and assume by induction that, for all i < e, C # @.(A), 
1 
A { ei(C), and A ( ~ )  is recursive. The proofs above establish (with C a i d X  
in place of D and C respectively in Lemmas 2 and 3): C f 4 (A); A # Q) (C); 
e 
e 
and A(e) is recursive. 
0 
An interesting generalization of the density theorem has recently been 
discovered. 
Definition 7.7. 
An r. e. degree 2 is branching if there are incom- 
parable r.e. degrees 2 and 2 such that 2 is the infimum of 
and 2 
(2 = & 
g), and a is nonbranching otherwise. 
For example, Theor em 4.2 shows that 2 is branching, and it follows 
at once from Theorem 5. i that there are nonzero branching degrees. 
Lachlan [4] showed the existence of nonbranching degrees and recently 
Fejer [33] has proved them dense in the r. e. degrees. 
Theorem 7.8 
(Fejer Density Theorem): If 
are r. e. degrees 
then there i s  a nonbranching r. e. degree 2 such that $< 2 < s . 
Corollary 7.9 (Fejer Splitting   he or em): 
If a is a nonzero r. e. 
degree then there are nonbranching degrees B and 2 such that 2 = u 2. 
It follows that the nonbranching degrees when closed under 1) gen- 
erate all the r.e. degrees E . The nonbranching degrees are the first 
nontrivial definable subset of $ to be shown to be dense and hence to 
generate &. 
If, as suggested by Jockusch and Lerman, the r. e. degrees 
are given the order topology where a typical subasic open set has the form 
[Q,s) 
= {Q : b_< g) or (a, %I] = {h :k> .. 
a ) ,  then the branching degrees, 

together with 
a r e  precisely the isolated points. It follows from 
Theorem 7.8 that the Cantor-Bendixson rank of 
with this topology is i. 
The Sacks coding strategy of the density theorem has recently been 
applied to give a new result on index sets which immediately yields several 
index set results of Yates [25] and [26] a s  pointed out in [34]. 
The following 
result was first stated by Kallibekov [34] with an entirely different method of 
proof for infinite injury. 
Unfortunately, the verification that his ingenious 
method succeeds seems to contain an error. Stob [36] gave a completely 
different proof -by combining the Sacks coding strategy with the thickness 
lemma method of $3. 
Theorem 7.10. 
Let C and D be r.e. sets such that C I D and 
T 
D 
9 CTC C T  9'. Let S be any set in Cg. Then there is a uniformly r. e. 
sequence of r. e. sets {
A
~
)
~
~
 
such that for all k, 
k c S  * A k = = D  
k / S d 
A and C a r e  Turing incomparable. 
k 
In Stob's proof there i s  a new element beyond what we have seen here 
and in [25], since if k e S we may have for certain e that lim infs r(e,s) 
= m. 
Stob needed a new insight in this case to show that A k l T D .  
In a different direction another conjecture on r. e. degrees has 
recently been refuted. After seeing the density theorem, Shoenfield 
formulated a conjecture that the r.e. degrees 
form a dense structure as 
a partially ordered set analogously a s  the rationals form a dense structure 
a s  a linearly ordered set. Shoenfieldts conjecture implies that if 
q(xi,. . . , x , y) i s  a quantifier free formula of the language L(& U, 
0 , i )  
n 

and q,. . . , e 
then there exists 2 t R mch that (p (gi,. ..,sn,b) holds 
unless the existence of ]Z would lead to an winconsistency.m. The existence 
of a minimal pair (Theorem 4.2) refutes Shoenfieldfs conjecture. Jockusch 
then suggested that since minimal pairs are the source of much difficulty, 
perhaps Shoenfield's conjecture holds for the simple degrees, those nonzero 
degrees which are not half of a minmal pair. 
Recently, Klaus Ambos has 
refuted this by combining the Yates construction [30] of a simple degree with 
the Lachlan construction of a nonzero branching degree (3 5) to produce a 
simple branching degree. 
(Since simple degrees are closed upwardly, the 
branches must also be .simple. ) 

REFERENCES 
1. M. R. Arslanov, R.F. Nadirov and V. D. Solovev, Completeness criteria 
for recursively enumerable sets and some general theorems on fixed 
points, Matematica University News, 1977 (179) No.4. 
2. 
J. Dekker, A theorem on hypersimple sets, Proc. Amer.Math.Soc., 
5 (1954). 791-796. 
- 
3. R. M. Friedberg, Two recursively enumerable sets of incomparable 
degrees of unsolvability, Proc. Natl. Acad. Sciences, U. S. A. , 
43 (1957), 236-238. 
MR 18, 867. 
- 
4. 
A.H. 
Lachlan, Lower bounds for pairs of r.e. degrees, Proc. London 
Math. Soc. (3). 16 (1966). 537-569. 
MR 34 no.4126. 
- 
5. 
, Complete recursively enumerable sets, Proc. Amer. Math 
SOC. 2 (1968). 99-102. 
6. 
, Embedding nondistributive lattices in the recursively 
enumerable degrees, Conf. Mathematical Logic, London 1970, 
Lecture Notes in Math., no. 255, Springer-Verlag, Berlin and 
New York, 1972, pp. 149-177. 
7. 
, The priority method for the construction of recursively 
enumerable sets, Proc. Cambridge Summer School in Logic, 1971, 
Springer-Verlag, Berlin & New York, 1973. 
8. 
, A recursively enumerable degree which wid1 not split over 
all lesser ones, Ann. Math. Logic, 9 (1975), 307-365. 
9. 
, Decomposition of recursively enumerable degrees, Proc. 
Amer. Math. Soc., to appear. 
10. 
, and R.I. Soare, Not every finite lattice i s  embeddable in 
the recursively enumerable degrees, to appear. 

11. S. S. Marchenkov, A class of partial sets. Mathematicheskie Zametki 
Vol. 20, No. 4 (1976), 473-478. 
12. D. A. Martin. Completeness, the recursion theorem, and effectively 
simple sets, Proc. Amer. Math. Soc.. 
(1966). 838-842. 
13. A. A. Muchnik, On the unsolvability of the problem of reducibility in 
the theory of algorithms (Russian), Doklady Akademii Nauk, 
n. s., 108 (1956). 194-197. 
14. E.L. Poet, Recursively enumerable sets of positive integers and their 
decision problems, Bull. Amer. Math. Soc., 0 (1944), 
284- 3 1 6. 
15. R. W. Robinson, Interpolation and embedding in the recursively 
enumerable degrees, Annals Math. , 2 (1971), 285-314. 
1 6. 
, Jump restricted interpolation in the r. e. degrees, Annals 
Math., 2 (1971). 586-596. 
17. H. Rogers, Jr. , Theory of recursive functions and effective com- 
putability, McGraw-Hill, N. Y., 1967. 
18. G. E. Sacks, On the degrees less than 08, Annals Math., 71 (1963), 
211-231. 
19. 
, Recursive enumerability and the jump operator, T rans. 
Amer. Math. Soc., 108 (1963). 223-239. 
20. 
, The recursively enumerable degrees a r e  dense, Annals of 
Math. (2). 80 (1964). 300-312. 
- 
2 1. 
, Degrees of unsolvability, rev. ed., Annals of Math. 
Studies, No. 55, Princeton Univ. Press, Princeton, N. J. 1966. 
22. J. R. Shoenfield, Undecidable and creative theories, Fundamenta 
Mathematicae, - 
49 (1961), 171-179. 
23. 
, Degrees of unsolvability, North-Holland, Amsterdam 
1971. 

J. R. Shoenfield and R. I. Soare, The generalized diamond theorem, 
( ~ b s t r a c t )  Recursive function theory newsletter, 19 C1978), #219 
R.I. Soare, The infinite injury priority method, J.Symbolic Logic, 
41 (1976). 513-530. 
- 
, Computational complexity, speedable and levelable sets, 
J. Symbolic Logic, 42 (1 977), 545-563. 
, Recursively enumerable sets and degrees, Bull. A.M. S. 
Vol. 84, No.6 (1978), 1149-1181. 
, Recursively enumerable sets and degrees, (Omega Series), 
Springer-Verlag, Berlin and New York (to appear). 
S. K. Thomason, Sublattices of the recursively enumerable degrees, 
2. Math. Logik und Grundlagen d. Math., 17 (1971). 273-280. 
C.E. M. Yates, A minimal pair of r.e. degrees, J. Symbolic Logic, 
31 (1966), 159-168. 
- 
, On the degrees of index sets, Trans. Amer. Math. Soc., 
121, (1966), 309-328. 
- 
, On the degrees of index sets, 11. Trans. Amer. Math. Soc. 
135, (1969). 249-266. 
- 
P. A. Fejer, Ph.D. Dissertation, University of Chicago, 1980. 
See 
Density of nonbranching degrees (abstract 7 9 ~ - E 3 2 )  Notices 
A. M.S. 
June 1979, p. A-390. 
S. Kallibekov, Index sets of degrees of unsolvability, Algebra i Logika 
10 (1971), 316-326 (Russian). 
S. C. Kleene and E. L. Post, The upper semi-lattice of degrees of 
recursive unsolvability, Ann. of Math. (2) 59 (1954), 379-407. 
36. 
M. Stob, 
Index sets and degrees of unsolvability, to appear. 

CEK TRO Ih TERNAZIOh ALE MATEMATICO ESTIVO 
(c.I.M.E.) 
RECURSIVELY INVARIANT 
-RECURSION 
THEORY 
WOLFGANG MAAS 

Recursively Invariant (3-Recursion Theory 
(Preliminary Survey) 
Wolf gang Maass 
Massachusetts Institute of Technology, Cambridge, USA I 
In my lecture I want to sketch a new branch of generalized 
recursion theory: invariant (I-recursion theory. (3 is any limit 
ordinal in the following. 
A set A E Lp is called (3-recursively enumerable ( (3-r.e. ) 
if it is definable over LC) by some TI 
formula q (see 
Friedman and Sacks [I]). 
Observe that this is really a very 
intuitive definition. Generate successively the levels 
L0,LI,..,L8 ,.. (rd(3) of the constructible hierarchy up 
to (3 . Enumerate at every step y those elements z into A 
which satisfy Ll k q(z) 
and which have not already been 
enumerated before. 
The example shows that the general concept of a recursively 
enumerable set -as described by Post 121 in 1944- does not 
require any strong closure conditions of the underlying domain 
like admissiblity. 
*The author is supported by the Heisenberg-program of the 
Deutsche Forschungsgemeinschaft. 


Lemma 1 : I is a (3-recursive subset of L,, . In fact 
I = f x E Lp 1 Lo b [cardinality(x) < vlcfp ] f . 
The proof is not difficult but relies heavily on the fine 
structure of L (collapsing of Skolem hulls). 
Every (3-r.e. set A  can be enumerated in 
clcfp many 
steps, i.e. there exists a (l-recursive function f : ulcfp 
L 
y x ~ A y ,  
such that A =  U{Ay 
I x *  elcfp) . Thus 
every single x e A is enumerated after an i-finite number of 
steps. It is easy to see that I is the only recursively in- 
variant class of @-recursive bounded subsets of 
Lo which 
is in this sense coherent with the notion of a 0-r.e. set. 
Further for any i-finite subset K of A we have K 5 Ar 
for some i-finite . This property is important for priority 
constructions. It implies that every true i-finite neighborhood 
condition about A settles down at some point of the-construc- 
tion. 
Another useful property is the following : Every (3-recur- 
sive subset of an i-finite set is again i-finite. 
Consider for any limit ordinal p the structure 
Z 
ePP := 
<LF - I;I,F,T> 
where e := c P Lo * I 
and T is 
the canonical (3-recursive truth predicate for AO Lo formulas 
in Lo . dlo is construed as a set with urelements as 
in Barwise [3], where LP - I 
is the underlying collection 
of urelements. 

Theorem 2 : &e 
is an admissible structure with urelements. 
Foreveryset M c L p  : 
M is Z1( 4) 
zR 
= 
M is Z l ( ~ , )  
Q P  . 
Further the sets in the structure 
are exactly the i-finite 
P 
sets. 
Corollary 3 : 
Assume that (3 
is a countable limit ordinal. 
Let 
c, Lo be some 9-recursive language and let T be a 
p-r.e. set of sentences in the language * with i-finite dis- 
junctions and conjunctions. 
If every i-finite set To G T has a model, then T has a 
model. 
Proof of the Corollary : Apply the Barwise Compactness Theorem 
[?I 
to CLp. 
Remark : The compactness theorem does not hold for any larger 
notion of Itfiniten in Lp . 
The preceding compactness theorem (Corollary 3) can be 
used to show that for every countable (3 
invariant p-recursion 
theory can be characterized in terms of absoluteness or model 
theoretic invariance as this effect was called by Kreisel [4]. 
The concept of model theoretic invariance is useful in order to 
understand the mathematical meaning of computations in recursion 
theory. The situation is analogous as in first order logic where 
the completeness theorem gives a mathematical meaning to formal 
proofs. 
The connection between model theoretic invariance and re- 
cursive invariance is the following : The notion of a "finiten 

set is recursively invariant in every recursion theory which can 
be characterized in terms of model theoretic invariance. 
In order to get an intrinsic notion of a computation rela- 
tive to an oracle B q Lp one can extend the Kripke equation 
calculus in a canonical way. The essential rule allows to survey 
i-finite many subcomputations in a computation. Every computa- 
tion has the structure of an i-finitely branching tree : 
axioms of the form 2 C B , 
L & B , F ( E , ~ )  = 
where F 
is some rudimentary function 
We say that A is computable from B if the characteris- 
tic function of A can be computed from B in this equation 
calculus. We say that A is i-finitely computable from B if 
this can be done by using i-finite computations only. B is 
called semigeneric if every equation which can be computed from 
B can be computed from B with an i-finite computation.For a 
semigeneric set B the preceding two notions of reducibility 
coincide for every set A . 
Lemma 4 : 
a) For countable (3 
A is computable from B iff A is 
implicitly invariantly definable from B (see [ 6 ] ) .  
b) A is i-finitely computable from B iff there exists a 
0-r.e. set W such that for every x e Lo : 

cA(x) = i O 3 i-finite,K,H(< X,~,K,BI E W A K 4 B A H 5 Lp - B) 
(cA is the characteristic function of A ). 
c) B is semigeneric iff for every relation R s L p x  L 
of 
P 
the form 
R(X,Y) H 3 i-finite K,H( 
x,g,K,H, e W A K s B A H o L B- B) 
with W (3-r.e. 
and dom R i-finite 
there exists an 
i-finite function f G R with &om f = dom R . 
The relation in b) is not transitive and therefore we cod- 
sider instead the following reducibility relation : 
A Sf B : <=> 
there exists a (3-r.e. set W such that for 
all i-finite H,,H2 
HI S A 
3 
i-finite K,H(<H,,l,K,H, i W A K 5 B A H c Lp - B) 
and 
HZ 5 La - B U 3 i-finite K,H(< H2.2,K,H>rW r KGB A H sLp - B). 
The associated equivalence classes are called i-degrees. For 
admissible Q they coincide with the d-degrees. 
Every i-degree i a  recursively invariant. The i-degree 0 
(i.e. the equivalence class of the empty set) contains exactly 
the fl-recursive eets. As usual one gets immediately that there 
exists a maximal (3-r.e. i-degree 0' which is strictly greater 
than 0 . There is no trivial way to show the existence of an 
intermediate (3 -r. e. i-degree. 
Except for a few 
(where it is still open) one can 
understand the structure of the (9-r.e. (+degrees (see[l]) as a 
substructure of the I-degrees. 

Theorem 5 : For every limit ordinal 
there exist p-r.e. 
sets A , B such that A #i B 
and B $i A . 
The proof is given in the most interesting case where (3 is 
strongly inadmissible (i. e. u fcf p c (3*) by a priority construc- 
tion following Friedman [5]. The combinatorial principle 0 can 
here be eleminated (this may be helpful for applications to 
other inadmissible sets). 
Oberelcve that for every f3 
the i-degrees coincide with the 
degrees in the admissible collapse aO. 
Thus Theorem 5 
con- 
tains as a special case the solution of Post's Problem for some 
enormously fat admissible sets. 
Theorem 6 : For every limit ordinal (\ there exist 
p-r.e. 
sets A , B such that A is not computable from B 
and B 
is not computable from A . 
The proof is slightly more difficult than the proof of Theorem 
5 . We make A and B in addition semigeneric. For this one 
neede 0 .  
Theorem 7 : For many strongly inadmissible (3 
there are (3-r.e. 
sets A such that 0 ci A but S pi A for every simple set 
S (see [6] for the definition of simple). 
The proof is a first example of an infinite preservation stra- 
tegy in the strongly inadmissible case. Besides 0 it uses a 
new combinatorial argument . We expect that refinements of the 
applied strategy will lead to a splitting theorem for i-degrees. 

We had mentioned the definition of a semigeneric set be- 
cause at this point an important new effect arises in the step 
from al- 
to (3-recursion theory. Several equivalent definitions 
of nhyperregularninot-recurslon theopy lead to different classes 
in (I-recursion theory. For some strongly Inadmissible (3 there 
are C)-r.e. sets B such that every computation from B has an 
i-finite length but B is not eemigeneric. 
All details can be found in the forthcoming paper [6]. 
Literature 
[I] 
S.D.Friedman and G.E.Sacks, Inadmissible recursion theory, 
Bul1.Am.Math.Soc. 
83 (1977) 255-256 
[2] E.L.Post, Recursively enumerable sets of positive integers 
and their decision problems, Bu1l.Am.Math.Soc. 
50 (1944) 
284-3 1 6 
(31 J.Barwise, Admissible Sets and Structures, (Springer,Berlin, 
1975) 
[4] G.Kreir~e1, Model theoretic invariants: applications to re- 
oursive and hyperarithmetic operations, in: J.W.Addison, 
L.Henkin,, A.Tarsk1, eds . ,The Theory of Models (~orth 
Holland ,Amsterdam, 1965) 
f 51 S .D.Friedman, Post's problem without admissibility, 
to appear 
(63 W .Maass, Recureively invariant (3-recursion theory, 
to appear . 

