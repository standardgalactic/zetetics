5 Computability
What is computability theory?
Computability theory arose from the concept of an algorithm. Computability theory, also
called recursion theory, is now a branch of mathematical logic that originated in the
1930s, before there were computers, with the study of computable functions and Turing
degrees. The field has grown to include the study of generalized computability and defin-
ability. For the computer scientist, computability theory shows that there is a theoretical
limit to what computer programs can actually do.
Let ℕ= {0, 1, 2, 3, 4, . . . } be the set of natural numbers and let f be a function of the
form f : ℕ→ℕ. What does it mean to say that f is computable? One could say that f is
computable if there is an algorithm such that for each n ∈ℕ, the algorithm with input
n will produce the output f (n). This of course would require one to define the meaning
of an algorithm.
Questions
1.
Consider the function f : ℕ→ℕdefined by f (n) = n + 123,572. Is f computable?
2.
Consider the function f : ℕ→ℕdefined by f (n) = 7n. Is f computable?
3.
Consider the function f : ℕ→ℕdefined by f (n) = r, where r is the remainder
obtained after dividing n by 5. Is f computable?
4.
Suppose that the functions f : ℕ→ℕand g: ℕ→ℕare computable. Define the
function h: ℕ→ℕby h(n) = f (n) + g(n). Is h computable?
5.
Are all functions of the form f : ℕ→ℕcomputable?
6.
How many computable functions are there?
7.
Suppose that the function f : ℕ→ℕis computable and suppose that a function
g: ℕ→ℕsatisfies g(n) < f (n) for all n ∈ℕ. Is g computable?
Is it possible to give a mathematically precise definition of a computable function? Yes!
Alan Turing was one of the first mathematicians to give such a definition.
5.1 The informal concept
Computability theory is the branch of mathematical logic that studies and identifies
problems that are computationally solvable using different models of computation.
A central question of computer science is to address the limits of computing devices by
understanding the problems that computers can solve. In this section we shall discuss
the basic concepts that appear in the theory of computation.
https://doi.org/10.1515/9783110782073-005

5.1 The informal concept
౪
149
5.1.1 Decidable sets
A function f : ℕk →ℕis computable if there is an effective (algorithmic) procedure that
can evaluate f , that is, given any input n1, . . . , nk of k natural numbers, the algorithm
will evaluate f (n1, . . . , nk).
In this section, we will use pseudocode to describe our algorithms and procedures.
As you may know, pseudocode is a compact and informal high-level description of an
algorithm. Programmers use pseudocode to develop their algorithms.
The first computability concept that we discuss is the concept of a decidable set.
A set is decidable if there is an effective procedure which will determine whether or not
any legitimate candidate is a member of the set. An effective procedure is an algorithm
that can be carried out by following the specific steps of an algorithm.
Definition 5.1.1. Given any set S of natural numbers, we will say that S is decidable if
there is an effective procedure such that whenever one applies the procedure to any
natural number n, the procedure will eventually end and respond “yes” if n ∈S and
“no” if n ∉S.
Definition 5.1.1 applies only to subsets of ℕ, the set of natural numbers. This defini-
tion can be generalized to other sets as well.
Example 5.1.2. Let S = {n ∈ℕ: n is a prime number}. Show that S is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
If n = షor n = స, then let A=No.
If n > స, then perform the following:
Let A=Yes.
For j = హto n −స;
If j | n, then let A=No.
End of For Loop
Return A
End of Procedure
The above algorithm is summarized as follows: Given a natural number n, if n ≤1,
then return No and halt. If n > 1, then search the numbers 2, 3, 4, . . . , n −1 for a number
j such that j | n (j evenly divides n). If you find one, then return No and halt. If you do
not find such a number, then return Yes and halt. We note that j | n if and only if n = jk
for some k ∈ℕ.
In every step of an effective procedure, one must be able to use an algorithm to
decide if a condition is true. Can the truth of the condition “j | n” be checked by an
algorithm? One can effectively decide whether or not j | n holds by carrying out the
algorithm called long division. If the remainder is 0, then j | n. Otherwise, j ∤n.

150
౪
5 Computability
Example 5.1.3. Let S = {n ∈ℕ: n = 7q + 3 for some natural number q}. Show that S is
decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform long division by dividing n by ా.
If the remainder is 3, then return Yes.
If the remainder is not 3, then return No.
End of Procedure
In other words, given a number n, divide n by 7. If the remainder is 3, then return
Yes and halt. If the remainder is not 3, then return No and halt.
Example 5.1.4. Suppose that S ⊆ℕis decidable. Show that ℕ\ S is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform the procedure for deciding whether or not n ∈S.
If n ∈S, then return No.
If n ∉S, then return Yes.
End of Procedure
That is, given n, using the decision procedure for S, check to see if n belongs to S or
not. If n ∈S, then return No and halt. If n ∉S, then return Yes and halt.
Example 5.1.5. Let A ⊆ℕand B ⊆ℕbe decidable. Show that A \ B is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform the procedure for deciding whether or not n ∈A.
Perform the procedure for deciding whether or not n ∈B.
If n ∈A and n ∉B, then return Yes.
If n ∉A or n ∈B, then return No.
End of Procedure
Given n, using the decision procedure for A, check to see if n is a member of A or
not. Using the decision procedure for B, check to see if n belongs to B or not. If n ∈A and
n ∉B, then return Yes and halt. If n ∉A or n ∈B, then return No and halt.
Example 5.1.6. Let A ⊆ℕbe a finite set. Show that A is decidable.

5.1 The informal concept
౪
151
Solution. Let A = {k1, k2, . . . , kℓ} and n ∈ℕ. The procedure is described as follows:
Begin Procedure
Let R=No.
If n = kస, then let R=Yes.
If n = kహ, then let R=Yes.
...
If n = kℓ, then let R=Yes.
Return R.
End of Procedure
That is, given n, check to see if n is in the finite list k1, k2, . . . , kℓor not. If n is not in
the list, then return No and halt. If n is in the list, then return Yes and halt.
The notion of an effective procedure is somewhat vague and we have not yet given
a precise mathematical definition. We will shortly be giving just such a definition. There
are at least two different but equivalent ways to define an effective procedure: Turing
machines and register machines. There is also a more mathematical way of defining
computable functions which involves the definition of partial recursive functions.
Are all subsets of ℕdecidable? One can show that there are only countably many
effective procedures. Since 𝒫(ℕ) (power set of ℕ) is uncountable, it follows that the
majority of sets of natural numbers are not decidable.
5.1.2 Computable functions
Definition 5.1.7. Let k ≥1 be a natural number. A k-place total function has the form
f : ℕk →ℕand its domain is the entire set ℕk. A k-place partial function is a function
whose domain is a subset of ℕk and whose values are in ℕ. A total function will also be
viewed as a partial function. The empty function is the partial function that is undefined
for every input. When we say that f : ℕk →ℕis a partial function, we mean that the
domain of f is a subset of ℕk.
Example 5.1.8. Define the 2-place total function f : ℕ2 →ℕand the 2-place partial func-
tion g: ℕ2 →ℕby
f (m, n) = {m −n,
if m ≥n,
0,
if m < n,
g(m, n) = {m −n,
if m ≥n,
↑,
if m < n,
where ↑means that g(m, n) is undefined. So g(5, 2) is defined and (5, 2) is in the domain
of g; but g(2, 5) is undefined and thus, (2, 5) is not in the domain of g.

152
౪
5 Computability
We write ⃗x ∈ℕk to indicate that ⃗x is a k-tuple of the form x1, . . . , xk or ⟨x1, . . . , xk⟩,
depending on the context.
Definition 5.1.9. Let f be a k-place partial function. The function f is effectively com-
putable if there exists an effective procedure that satisfies the following:
1.
Given a k-tuple ⃗x in the domain of f , the procedure eventually halts and returns the
correct value for f ( ⃗x).
2.
Given a k-tuple ⃗x not in the domain of f , the procedure will not halt and thereby
will not return a value.
For example, the partial function for subtraction
g(m, n) = {m −n,
if m ≥n,
↑,
if m < n
is effectively computable because there is a procedure for subtracting natural numbers,
which we learned in elementary school. The procedure can be described as follows:
Begin Procedure
If m ≥n
compute r = m −n, return r and halt.
Else
Infinite Loop.
End of Procedure
An infinite loop is a procedure that does not terminate, that is, it runs forever. The
empty function is effectively computable by the following procedure:
Begin Procedure
Infinite Loop.
End of Procedure
The concept of a decidable set can now be described in terms of functions. Let
S ⊆ℕk. We say that S is decidable if its characteristic function (which is total)
CS( ⃗x) = {1,
if ⃗x ∈S,
0,
if ⃗x ∉S
is effectively computable. Thus, S is decidable if its characteristic function CS is a com-
putable total function.

5.1 The informal concept
౪
153
Remark 5.1.10. If S ⊆ℕk is decidable, we can use the computable total function CS to
construct another effectively computable partial function, namely, we can use the fact
that CS( ⃗x) = 1 if ⃗x is in S and CS( ⃗x) = 0 if ⃗x is not in S, for any ⃗x ∈ℕk.
Definition 5.1.11. A set S ⊆ℕk is semi-decidable if its semi-characteristic function
cS( ⃗x) = {1,
if ⃗x ∈S,
↑,
if ⃗x ∉S
is an effectively computable partial function.
Remark 5.1.12. Thus, a set S is semi-decidable if there is an effective procedure so that
for any input ⃗x ∈ℕk the procedure will halt and return “yes” if and only if ⃗x ∈S. Thus,
if ⃗x ∉S, then the procedure will not halt (that is, cS( ⃗x) is undefined).
Any decidable set is also semi-decidable; for example, suppose that S is a decidable
subset of ℕk. Then the following procedure shows that S is semi-decidable.
Begin Procedure
Run CS( ⃗x)
If output = స
return సand halt.
Else
Infinite Loop.
End of Procedure
A universal 2-place partial function
Now, let us just consider those effective procedures that have only one natural num-
ber as input and return at most one natural number as output. Suppose that we have
adopted a fixed method of encoding each of these procedures P by a single natural num-
ber w. Suppose, further, that each such code w can be effectively decoded in such a way
to retrieve the program P (this can be done). Then the following 2-place “universal func-
tion”
Φ(w, x) = the result of applying the procedure coded by w to the input x
is an effectively computable partial function. It is to be understood that Φ(w, x) is unde-
fined (that is, does not halt) when the procedure coded by w fails to halt and return an
output.
Remark 5.1.13. We present an effective procedure that can be used to show that Φ is
effectively computable. The procedure has inputs w and x.

154
౪
5 Computability
Begin Procedure
Decode w into a procedure P.
If P is not a valid procedure, then infinite loop.
Execute procedure P with input x; set r = return value.
If r = empty
Infinite Loop.
Else
Return r and halt.
End of Procedure
The function Φ is not total for at least two reasons: Some natural numbers w will
not decode and produce a procedure. If w does decode into a valid procedure, then this
procedure may not yield an output. We shall write Φ(w, x)↓to mean that the procedure
in Remark 5.1.13 halts with inputs w and x and returns an output value. Thus, Φ(w, x)↓
means that the procedure coded by w with input x halts and returns an output value.
The notation Φ(w, x)↑means that the procedure fails to halt.
Using the universal function Φ we can enumerate all of the 1-place effectively com-
putable partial functions. First, note that for any 1-place effectively computable partial
function f there is a natural number e that encodes the procedure for f . Thus,
f (x) = Φ(e, x)
for all x ∈ℕ.
For this reason, we shall use the notation ⟦e⟧to denote the corresponding function f .
Hence, ⟦e⟧(x) = f (x) = Φ(e, x) for all x ∈ℕ.
Thus, for any natural number e, we will now let ⟦e⟧be the partial computable func-
tion defined by ⟦e⟧(x) = Φ(e, x). Of course, some natural numbers e may not code a
procedure and then ⟦e⟧may be the empty function. In any case, we can conclude that
every 1-place effectively computable partial function appears in the list
⟦0⟧, ⟦1⟧, ⟦2⟧, ⟦3⟧, ⟦4⟧, . . . .
(5.1)
Since an effectively computable function can be computed by more than one procedure,
a computable function may have more than one representation in the list (5.1).
In computability theory, the halting problem can be stated as follows: Given a com-
puter program, decide whether the program will eventually halt when it is executed
with a given input or the program will run forever.
Definition 5.1.14 (Turing). Define the halting relation H on ℕby
⟨w, x⟩∈H
iff
⟦w⟧(x)↓,
where ⟦w⟧(x)↓means that the procedure coded by w with input x halts and has an output
value.

5.1 The informal concept
౪
155
Of course, ⟦w⟧(x)↓is equivalent to Φ(w, x)↓. Is the relation H decidable? Is there a
procedure that will determine whether or not a program coded by w with input x halts?
Alan Turing proved in 1936 that no such procedure exists.
Theorem 5.1.15 (Turing). The halting relation H is not decidable.
Proof. Suppose, to the contrary, that H is decidable. Thus, the characteristic function CH
defined by
CH(w, x) = {1,
if ⟨w, x⟩∈H,
0,
if ⟨w, x⟩∉H
(5.2)
is effectively computable. Define the partial function f : ℕ→ℕby
f (n) = {1,
if CH(n, n) = 0,
↑,
if CH(n, n) = 1.
(5.3)
It follows that f is an effectively computable partial function (see Remark 5.1.10). Thus,
there is a procedure P that evaluates f . So, if CH(n, n) = 1, then the procedure P with in-
put n, which attempts to evaluate f (n), will not halt. Since f is an effectively computable
partial function, there is a natural number e such that ⟦e⟧= f . There are two cases to
consider: Either CH(e, e) = 0 or CH(e, e) = 1.
Case 1. Suppose CH(e, e) = 0. Thus, f (e) = 1 and so ⟦e⟧(e) = 1. Hence, ⟨e, e⟩∈H because
the procedure coded by e with input e halts. Therefore, (5.2) implies that CH(e, e) = 1,
which is a contradiction.
Case 2. Suppose CH(e, e) = 1. Thus, by (5.3), f (e) is undefined because the procedure that
attempts to evaluate f (e) does not halt. Since ⟦e⟧= f , we conclude that ⟦e⟧(e) does not
halt. Hence, CH(e, e) = 0, which is a contradiction.
Turing’s proof presents an example of a diagonal argument, which was introduced
by Georg Cantor in 1873 to prove that the set of real numbers is uncountable.
Even though the halting relation is not decidable, it is semi-decidable as ⟨w, x⟩∈H
if and only if Φ(w, x)↓. Thus, the semi-characteristic function cH satisfies
cH(w, x) = {1,
if ⟨w, x⟩∈H,
↑,
if ⟨w, x⟩∉H
and is an effectively computable partial function. The following psuedocode offers an
effective procedure for evaluating cH(w, x) (see Remark 5.1.12 and Definition 5.1.9):

156
౪
5 Computability
Begin Procedure
Execute procedure Φ(w, x).
Return సand halt.
End of Procedure
Definition 5.1.16. Define the subset K on ℕby
K = {x ∈ℕ: Φ(x, x)↓} = {x ∈ℕ: ⟦x⟧(x)↓}.
The set K is semi-decidable as the following procedure indicates:
Begin Procedure
Execute procedure Φ(x, x).
Return సand halt.
End of Procedure
Theorem 5.1.17 (Kleene). Let S be a subset of ℕk. Then S is decidable if and only if both S
and its complement S = ℕk \ S are semi-decidable.
Proof. Let S ⊆ℕk.
(⇒). Assume that S is decidable. Then, as we have seen before, S is semi-decidable be-
cause the following effective procedure applies:
Begin Procedure
Run CS( ⃗x)
If output = స
return సand halt.
Else
Infinite Loop.
End of Procedure
By replacing “output = 1” in the above procedure with “output = 0,” we obtain an
effective procedure that shows that S is semi-decidable.
(⇐). Assume that S and S are semi-decidable. Thus, the partial functions cS and cS are
effectively computable. We shall prove that S is decidable, using a “system timer” as
follows: Run the cS( ⃗x)-procedure for one minute and then freeze it. Now, in another
part of executable memory, run the cS( ⃗x)-procedure for one minute and then freeze it.
Now continue the cS( ⃗x)-procedure for one minute and then freeze it, and then continue
the cS( ⃗x)-procedure for one minute and then freeze it. Keep alternating this “sharing of

5.1 The informal concept
౪
157
system time” until one of the procedures halts and yields an output of 1. If cS( ⃗x) = 1, then
return 1. If cS( ⃗x) = 1, then return 0.
Theorem 5.1.18. Let k be a natural number.
1.
A k-place relation is semi-decidable if and only if the relation is the domain of some
effectively computable partial function.
2.
A partial function f is effectively computable if and only if {⟨⃗x, y⟩: f ( ⃗x) = y} is a
semi-decidable relation.
Proof. Let S ⊆ℕk.
1.
We prove that a k-place relation is semi-decidable if and only if the relation is the
domain of some effectively computable partial function.
(⇒). Suppose that S ⊆ℕk is semi-decidable. Thus, by definition, the function cS is
an effectively computable function. Since
cS( ⃗x) = {1,
if ⃗x ∈S,
↑,
if ⃗x ∉S,
we see that S is the domain of some effectively computable partial function.
(⇐). Suppose that S ⊆ℕk is the domain of some effectively computable partial
function, say f . We note that the following procedure evaluates cS:
Begin Procedure
Run f( ⃗x).
Return సand halt.
End of Procedure
Since the procedure f ( ⃗x) halts if and only if ⃗x ∈S, we conclude that cS is an effec-
tively computable function.
2.
We shall prove that a partial function f is effectively computable if and only if the
set G = {⟨⃗x, y⟩: f ( ⃗x) = y} is a semi-decidable relation.
(⇒). Let f be effectively computable. Consider the following procedure with inputs
⃗x and y:
Begin Procedure
Run f( ⃗x).
If output = y
Return సand halt.
Else
Infinite Loop
End of Procedure

158
౪
5 Computability
Thus, the above effective procedure evaluates cG. Therefore, G is semi-decidable.
(⇐). Let G = {⟨⃗x, y⟩: f ( ⃗x) = y} be a semi-decidable relation and let cG be the semi-
characteristic function of G, which is a computable partial function. Given ⃗x, execute
the following procedure:
Begin Procedure
Let n = ష.
(L)
For j = షto n;
Run cG( ⃗x, j) for n + సminutes.
If cG( ⃗x, j) has halted and cG( ⃗x, j) = స, then return j and go to (E).
End for Loop
Let n = n + సand go to (L).
(E)
Halt (End of Procedure)
If f ( ⃗x)↓, then this procedure will eventually halt and return the value f ( ⃗x). If f ( ⃗x)↑,
then this procedure will not halt. Therefore, f is effectively computable.
Let us explain what the above procedure does. We know that G is semi-decidable.
Thus, there is a procedure P such that when given an input ⟨⃗x, y⟩, the procedure
will halt and return “yes” if and only if ⟨⃗x, y⟩∈G. We now try to compute f ( ⃗x), if
it is defined. The plan is to use the procedure P to check ⟨⃗x, 0⟩, ⟨⃗x, 1⟩, ⟨⃗x, 2⟩, . . . for
membership in G. To do this, we must budget our time by using a method called
“dovetailing.” We execute the following steps:
(1) Spend 1 minute testing whether ⟨⃗x, 0⟩is in G.
(2) Spend 2 minutes each on ⟨⃗x, 0⟩and ⟨⃗x, 1⟩testing for membership in G.
(3) Spend 3 minutes each on ⟨⃗x, 0⟩, ⟨⃗x, 1⟩, ⟨⃗x, 2⟩testing for membership in G.
...
...
If at a step we find an ⟨⃗x, k⟩∈G, then we return the value k and halt. If f ( ⃗x)↓, then
this process will eventually halt and return the correct value for f ( ⃗x). On the other
hand, if f ( ⃗x)↑, then this process will not halt, that is, the process will run forever.
Therefore, the partial function f is effectively computable.
Exercises 5.1.
1. Let A ⊆ℕand B ⊆ℕbe decidable. Show that A ∩B is decidable, that is, let n ∈ℕ
and identify an effective procedure that decides whether or not n ∈A ∩B.
2. Let A and B be decidable subsets of ℕ. Show that A ∪B is decidable.
3. Let A and B be semi-decidable subsets of ℕ. Show that A ∩B is semi-decidable.
4. Let A and B be semi-decidable subsets of ℕ. Show that A ∪B is semi-decidable.
5. Let R ⊆ℕ2 be a decidable relation. Show that the set {x : ⟨x, i⟩∈ℝ}, domain of R,
is semi-decidable. (Review the proof of Theorem 5.1.18(2).)
6. Suppose that f : ℕ→ℕis a computable partial function. Show that the domain of
f , {x ∈ℕ: f (x)↓}, is semi-decidable.

5.2 Formalizations—an overview
౪
159
7. Let f : ℕ→ℕbe a total computable function. Show that the range {f (x) : x ∈ℕ} is
semi-decidable.
5.2 Formalizations—an overview
In the preceding section, we used the term “effectively computable” to refer to an in-
tuitive notion of an effective (algorithmic) procedure. In this section we present an
overview of three different (but equivalent) methods that allow one to replace the no-
tion of effectively computable with one that is mathematically precise. One of these
methods will be developed in more detail in Sections 5.3 and 5.4. It is important to
emphasize that these three approaches are equivalent (see Theorems 5.2.20 and 5.2.11).
5.2.1 Turing machines
A Turing machine is a device that manipulates symbols on a tape according to a set of
instructions. Despite its simplicity, a Turing machine can be adapted to simulate the logic
of any computer algorithm. The Turing machine is not intended as a practical method for
implementing algorithms, but rather as a hypothetical device representing a computing
machine. Turing machines help computer scientists understand the limits of mechanical
computation.
A Turing machine has a potentially infinite tape, marked into squares and a tape
head which has an arrow pointing at the square on the tape that is currently being ad-
dressed. Each square can hold a symbol or a blank space. The symbols must be taken
from a given alphabet Σ. Initially, the tape contains only the input string (word) and is
blank everywhere else (see Figure 5.1).
Figure 5.1: A tape with an input string from the alphabet Σ = {a, t, 3}.
A Turing machine instruction commands the machine to perform the simple steps
indicated below:
(a) read the tape square under the tape head,
(b) write a symbol on the tape in that square,
(c) move the tape head to the left or right, and
(d) proceed to a new instruction.
Steps (b) through (d) all depend upon what symbol appears on the tape square being
scanned before the instruction is executed. The machine can be in any one of finitely

160
౪
5 Computability
many “states” q1, q2, . . . , qr. A machine instruction has the form ⟨state, read, write, move,
next-state⟩. A program for a Turing machine consists of a finite set of Turing machine
instructions.
Words and alphabets
Consider the set consisting of the English alphabet {a, b, c, d, . . . , x, y, z}. A finite string
or word over this alphabet is a string of letters; for example, aaactu and zadw are two
strings (words) of letters over the English alphabet.
We will now consider more general alphabets. Let Σ be a finite set of symbols. Then
Σ∗is the set of all words over the alphabet Σ (including the empty word λ). For example,
let Σ = {1, b, c}. Then
Σ∗= {λ, 1, a, b, 1a, a1, bbb, abcabc, . . . }.
We shall denote the “empty” word with the symbol λ, and this symbol is not allowed to
occur in any alphabet.
Turing machine instructions
An instruction has the form ⟨qi, Sj, Sk, D, qm⟩, where qi is the current state, Sj and Sk are
symbols in Σ (the given alphabet), D is either R or L (right or left), and qm is the next
state. If the machine is in state qi, then the instruction ⟨qi, Sj, Sk, D, qm⟩tells the machine
to look at the square currently under the tape head (the arrow) and do the following (in
order):
1.
If the square contains symbol Sj, then replace it with the symbol Sk.
2.
If D = R, then move the tape head to the next square on the right; if D = L, then
move the tape head to the next square on the left.
3.
Go into state qm.
4.
Let S be the current symbol in the square under the tape head.
5.
Now execute the instruction that has state qm and symbol S as its first two compo-
nents. If there is no such instruction, then halt!
We will not allow the symbol B to be used in any alphabet. The capital letter B will
be used to represent a “blank” symbol (that is, an empty square). Thus, an instruction
⟨qi, Sj, B, D, qm⟩means to “erase” symbol Sj and the instruction ⟨qi, B, Sk, D, qm⟩means
that if the square is blank, then write the given symbol Sk into this square. A Turing
machine cannot have two different instructions that have the same first two components.
Suppose that we are working in the two-letter alphabet Σ = {a, b} and we want to
write a Turing machine that takes a word in this alphabet as input and will append the
letter a to each such word (on the right). For example, if the tape has the initial input
abb, then after running the machine the tape should have the output abba. Figure 5.2
illustrates another example. Such a Turing machine is given in Example 5.2.1 below.

5.2 Formalizations—an overview
౪
161
Figure 5.2: The Turing input and output.
Example 5.2.1. Let Σ = {a, b} be a two-letter alphabet. We will present a Turing ma-
chine M which consists of six instructions with just three states q1, q2, q3, where q1 is
designated as being the initial state. The state q3 will be the halt state, that is, the ma-
chine will stop operating. When we start this machine in state q1 it will scan the first
letter and then will eventually append the letter a to the word on the right. We show in
Figure 5.3 how this machine executes the program on the input word ab. The box above
the tape head identifies the “current” state of the machine. We have
⟨q1, a, a, R, q1⟩
⟨q1, b, b, R, q1⟩
⟨q1, B, a, L, q2⟩
⟨q2, a, a, L, q2⟩
⟨q2, b, b, L, q2⟩
⟨q2, B, B, R, q3⟩.
(M)
Example 5.2.2. Let Σ = {a, b} be a two-letter alphabet. Let f : Σ∗→Σ∗be the 1-place
function defined by f (w) = wa, where w ∈Σ∗is any word in the alphabet Σ. The machine
M in Example 5.2.1 computes the total function f . So we can say that the function f is
Turing computable. Note that f (λ) = a, where λ is the empty word.
Now suppose that Σ is a finite alphabet (the blank B does not count as a member
of Σ). Let Σ∗be the set of all words over this alphabet (that is, Σ∗is the set of all finite
strings, including the empty string, consisting of members of Σ).
Definition 5.2.3. Suppose that f is a k-place partial function from (Σ∗)k into Σ∗. We will
say that f is Turing computable if there exists a Turing machine M that, when started
in its initial state scanning the first symbol of a k-tuple
⃗w of words (written on the tape,
with a blank square between words, and with the rest of the tape blank), behaves as
follows:
1.
If f ( ⃗w)↓(i. e., ⃗w is in the domain of f ), then M eventually halts and returns the value
f ( ⃗w), which is the word on the tape whose first letter is under the tape head and
whose last letter is followed by a blank square.
2.
If f ( ⃗w)↑(i. e.,
⃗w is not in the domain of f ), then M never halts.

162
౪
5 Computability
Figure 5.3: The machine runs with input ab and halts with output aba.
Turing developed these ideas prior to the introduction of modern digital computers.
After World War II, Turing played an active role in the development of early comput-
ers and in the emerging field of artificial intelligence. During the war, he also worked
on deciphering the German battlefield code Enigma, which was militarily important
work that remained classified until after Turing’s death. Turing’s remarkable contribu-
tions to the war effort have been celebrated in recent years. However, before his death,
Turing was persecuted by the English judicial system on account of his sexual orienta-
tion.
Turing computability of functions on ℕk
The definition of Turing computability can be adapted to k-place functions on ℕ. One
way to do this is to use the single-letter alphabet Σ = {1} and represent the natural num-
bers 0, 1, 2, 3, 4, . . . as follows: 1, 11, 111, 1111, 11111, . . . . Thus, the 3-tuple ⟨3, 0, 5⟩would be
represented on a Turing tape as

5.2 Formalizations—an overview
౪
163
1 1 1 1
1
1 1 1 1 1 1 .
It turns out that every computable function (like the ones in Section 5.1.2) on the nat-
ural numbers is Turing computable. For example, the function f (m, n) = mn is Turing
computable. Thus, there is a Turing machine such that when given the input ⟨m, n⟩, the
machine will halt with the output mn. For example, if this machine were given the input
⟨3, 4⟩represented on the tape as
1 1 1 1
1 1 1 1 1 ,
then the machine would halt with the output
1 1 1 1 1 1 1 1 1 1 1 1 1 ,
which represents 12.
5.2.2 Register machines
In theoretical computer science a register machine is an abstract machine that is used in
a manner similar to that of a Turing machine. Furthermore, every Turing computable
function on the natural numbers can be computed by a register machine and vice
versa.
A register machine is a conceptual computing device with a finite number of regis-
ters, numbered 0, 1, 2, . . . , K. Each register is capable of storing a natural number of any
magnitude—there is no limit to the size of this number. The operation of the machine
is determined by a program. A program is a finite sequence of instructions, drawn from
the following list:
–
I r (where 0 ≤r ≤K). “Increment r.” This instruction results in an increase of the
contents of register r by 1. The machine then proceeds to the next instruction in the
program (if any).
–
D r (where 0 ≤r ≤K). “Decrement r.” The effect of this instruction depends on
the number in register r. If that number is nonzero, it is decreased by 1 and the
machine proceeds not to the next instruction, but to the following one. However, if
the number in register r is zero, then the machine proceeds to the next instruction.
In other words, the machine attempts to decrement register r and if it is successful,
then it skips one instruction.
–
J q (where q is an integer—positive, negative, or zero). “Jump q.” All registers remain
unchanged. The machine takes as its next instruction the q-th instruction following
this one (if q ≥0) or the |q|-th instruction preceding this one (if q < 0). The machine
halts if there is no such instruction in the program. Thus, the instruction J 0 results
in an infinite loop, by repeating this one instruction over and over again.

164
౪
5 Computability
This programming language has only these three types of instructions. (Strictly speak-
ing, in these instructions, r and q are numerals, not numbers, that is, an instruction
should be a sequence of symbols. If we use base-10 numerals, then the alphabet is
I, D, J, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, −. An instruction is a correctly formed word over this alpha-
bet.) A register program will halt when the machine cannot find the “next” instruction.
Example 5.2.4 (CLEAR 7). Consider the following program, called “CLEAR 7,” which will
replace the contents of register 7 with the number 0. The comments (on the right) are
added to explain the individual steps in the program.
D
7
Try to decrement register 7.
J
2
Halt when zero.
J
−హ
Go back and repeat.
The program has three instructions and halts by seeking a fourth instruction. In
addition, we can replace 7 with any register number and obtain a program that will
clear that particular register, for example, the following program CLEAR 3 will clear
register 3.
D
3
J
2
J
−హ
Example 5.2.5 (MOVE r to s). Let r and s be different register numbers. Consider the fol-
lowing program, called “MOVE r to s,” which will move the number in register r into
register s. This program “calls” on the CLEAR program.
CLEAR
s
Ensure that register s is set to zero.
D
r
Decrement register r.
J
3
Halt when zero.
I
s
Increment register s.
J
−఺
Go back and repeat.
The above program leaves a zero in register r and contains seven instructions. The
program halts by seeking an eighth instruction.
Example 5.2.6 (ADD 1 to 2 and 3). Consider the following program, called “ADD 1 to 2
and 3,” which will add the number in register 1 to the numbers in register 2 and regis-
ter 3.

5.2 Formalizations—an overview
౪
165
D
1
Decrement register 1.
J
4
Halt when zero.
I
2
Increment register 2.
I
3
Increment register 3.
J
−఻
Go back and repeat.
This program leaves a zero in register 1. Moreover, the program has five instructions
and halts by seeking a sixth instruction. It is clear how to adapt this program to add any
register to one or more registers.
Example 5.2.7 (COPY from r to s (using t)). Consider the following program, called “COPY
from r to s (using t),” which copies the number in register r to register s (leaving register
r unchanged). The program “calls” on the programs CLEAR, MOVE, and ADD.
CLEAR
s
Set register s to zero.
MOVE
r to t
ADD
t to r and s
When this program terminates, register r contains the same value as it did when
the program began. The program contains 15 instructions and halts by seeking a 16th
instruction.
Example 5.2.8. Let R0, R1, R2, R3 denote registers 0, 1, 2, and 3. Suppose that x and y
are in registers 1 and 2. The following program will put the sum x + y in register 0. The
comments on the right depict the register contents at each step of the program.
Rష
Rస
Rహ
R఺
CLEAR
0
ష
x
y
MOVE
1 to 3
ష
0
y
x
ADD
3 to 1 and 0
x
x
y
0
MOVE
2 to 3
x
x
0
y
ADD
3 to 2 and 0
x + y
x
y
0
At the end of this program, registers 1 and 2 contain the same value as they did
when the program began. The program has 27 instructions and halts by seeking a 28th
instruction.
Definition 5.2.9. Suppose that f : ℕn
→
ℕis an n-place partial function. Then f
is register-machine computable if there exists a register program P that, whenever
⃗x = ⟨x1, x2, . . . , xn⟩and x1 is in register 1, x2 is in register 2, . . . , xn is in register n, and 0
is in the other registers, behaves as follows:

166
౪
5 Computability
1.
If f ( ⃗x)↓(i. e., ⃗x is in the domain of f ), then P eventually halts and returns the value
f ( ⃗x) in register 0. Furthermore, the program halts by seeking a (p + 1)st instruction
when the program P contains p instructions.
2.
If f ( ⃗x)↑(i. e., ⃗x is not in the domain of f ), then P never halts.
Example 5.2.10. Let f : ℕ2 →ℕbe defined by f (x, y) = x + y. Example 5.2.8 shows that f
is register-machine computable.
Theorem 5.2.11. Let f : ℕ2 →ℕbe a partial function. Then f is Turing computable if and
only if f is register-machine computable.
5.2.3 Primitive recursiveness and partial search
For a third formalization of the computability concept, we will define a certain class of
partial functions on ℕto be the smallest class that contains a few simple functions and is
also closed under certain constructions that generate more complicated functions. This
particular formalization requires no particular type of computing device.
For the initial functions, we take the following very simple total functions:
–
For each k ≥0, the zero function ̊f : ℕk →ℕdefined by the equation
̊f (x1, . . . , xk) = 0
is an initial function. The constant 0 is viewed as a 0-place initial function.
–
The successor function S: ℕ→ℕdefined by the equation
S(x) = x + 1
is an initial function.
–
For all natural numbers 1 ≤i ≤k, the projection function Ik
i : ℕk →ℕdefined by
the equation
Ik
i (x1, . . . , xk) = xi
is an initial function. The function Ik
i just selects the i-th component as its value.
We next identify two ways to generate new functions from the initial functions and those
that have already been constructed. Recall that when f : ℕ→ℕand g: ℕ→ℕ, we can
construct the composite function (f ∘g): ℕ→ℕdefined by
(f ∘g)(n) = f (g(n))
for all n ∈ℕ. We will generalize this operation in our next definition.

5.2 Formalizations—an overview
౪
167
Definition 5.2.12. Let n ≥1 and k ≥1. Suppose that f : ℕn →ℕand gi: ℕk →ℕfor each
i = 1, 2, . . . , n. Then we can define the function h: ℕk →ℕby composition as follows:
h( ⃗x) = f (g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x)).
In Definition 5.2.12, if f and g1, g2, . . . , gn are partial functions, then h( ⃗x) is defined if
and only if g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x) and f (g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x)) are all defined.
Example 5.2.13. Let n = 3, let k = 2, let f : ℕ3 →ℕbe defined by f (a, b, c) = ab + c, and
let g1(x, y) = 2x, g2(x, y) = 2y, and g3(x, y) = x + y. Then
h(x, y) = f (g1(x, y), g2(x, y), g3(x, y)) = f (2x, 2y, x + y)
= (2x)(2y) + (x + y) = 4xy + x + y.
Another method that we will use to generate functions is called primitive recursion.
Recall (Section 1.1.4) that if we have a function g: ℕ→ℕand an element a ∈ℕ, then
we can define a function h: ℕ→ℕby the following recursion:
1.
h(0) = a,
2.
h(n + 1) = g(h(n)), for all n ∈ℕ.
We will now generalize this definition.
Definition 5.2.14. Let k ≥1 and suppose that f : ℕk →ℕand g: ℕk+2 →ℕ. Then we
can define a function h: ℕk+1 →ℕby the following primitive recursion:
(1) h( ⃗x, 0) = f ( ⃗x),
(2) h( ⃗x, n + 1) = g(h( ⃗x, n), ⃗x, n), for all n ∈ℕ.
In Definition 5.2.14, if f and g are partial functions, then h( ⃗x, n + 1) is defined if
and only if h( ⃗x, n) and g(h( ⃗x, n), ⃗x, n) are both defined. Furthermore, the function h is
uniquely defined by the above conditions (1) and (2). In fact, Theorem 1.1.27 implies that
the function h exists and is unique.
Example 5.2.15. Let k = 2. Let f : ℕ2 →ℕbe defined by f (a, b) = (a+1)b and g: ℕ4 →ℕ
be defined by g(w, x, y, z) = wx + yz. Then we can define a function h: ℕ3 →ℕby the
following primitive recursion:
(1) h(x, y, 0) = f (x, y) = (x + 1)y,
(2) h(x, y, n + 1) = g(h(x, y, n), x, y, n), for all n ∈ℕ.
Since we have the value h(x, y, 0), we can evaluate h(x, y, 1) as follows:
h(x, y, 1) = g(h(x, y, 0), x, y, 0) = g((x + 1)y, x, y, 0) = (x + 1)yx + y ⋅0 = (x2 + x)y.
Now that we have the value h(x, y, 1), we can evaluate h(x, y, 2) as follows:

168
౪
5 Computability
h(x, y, 2) = g(h(x, y, 1), x, y, 1) = g((x2 + x)y, x, y, 1) = (x3 + x2)y + y ⋅1 = (x3 + x2 + 1)y.
Continuing in this manner we can evaluate h(x, y, n) for any natural number n.
Now that we have the initial functions and two methods of producing functions, we
can define the smallest set that contains the initial functions and all the functions that
can be generated from the initial functions using composition and primitive recursion.
Definition 5.2.16. A function f : ℕk →ℕis said to be primitive recursive if f can be con-
structed starting with the zero, successor, and projection functions using composition
and primitive recursion.
Thus, if the functions f : ℕn →ℕand gi: ℕk →ℕfor each i = 1, 2, . . . , n are primitive
recursive, then function h: ℕk →ℕdefined by the composition
h( ⃗x) = f (g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x))
is also primitive recursive. Furthermore, if f : ℕk →ℕand g: ℕk+2 →ℕare primitive
recursive, the function h: ℕk+1 →ℕthat satisfies
(1) h( ⃗x, 0) = f ( ⃗x),
(2) h( ⃗x, n + 1) = g(h( ⃗x, n), ⃗x, n), for all n ∈ℕ,
is also primitive recursive.
Again, the collection of all primitive recursive functions is the smallest set that
contains the initial functions and is closed under composition and primitive recursion.
Thus, the collection of primitive recursive functions is the smallest set 𝒞that contains
the zero, successor, and projection functions and whenever a function f is constructed
from functions in 𝒞using composition or primitive recursion, f is also in 𝒞.
Example 5.2.17. Show that the function h: ℕ3 →ℕthat satisfies
(1) h(x, y, 0) = y,
(2) h(x, y, n + 1) = h(x, y, n) + 2, for all n ∈ℕ,
is primitive recursive.
Solution. According to Definition 5.2.14, we need to find primitive recursive functions
f and g that satisfy:
(a) h(x, y, 0) = f (x, y), where f is a 2-place function,
(b) h(x, y, n + 1) = g(h(x, y, n), x, y, n), for all n ∈ℕ, where g is a 4-place function.
The function h has two parts of its definition, namely (1) and (2). We will find the func-
tions f and g by using the following tree to show how h is built up from certain primitive
recursive functions. The left branch below focuses on part (1) of the definition of h and
the right branch addresses part (2) of this definition.

5.2 Formalizations—an overview
౪
169
h
h(x, y, 0) = y
= I2
2(x, y)
= f (x, y)
w = h(x, y, n)
h(x, y, n + 1) = w + 2
= (w + 1) + 1
= S(w) + 1
= S(S(w))
= S(S(I4
1 (w, x, y, n)))
= g(w, x, y, n)
The function f defined by f (x, y) = I2
2(x, y) is an initial function, so f is primitive recur-
sive. The function g defined by g(w, x, y, n) = S(S(I4
1 (w, x, y, n))) is primitive recursive
because g is the result of composing initial functions. Thus, h is a primitive recursive
function.
We note that every primitive recursive function is a total function. This is because
the initial functions are all total, the composition of total functions is total, and a function
obtained by primitive recursion from total functions is also total.
We will show in Section 5.3 that many of the common functions on ℕare primitive
recursive. For example, we shall show that the operations of addition and multiplication
on the natural numbers are primitive recursive.
It seems clear that every primitive recursive function should be regarded as be-
ing effectively computable. The initial functions are computable and the composition of
computable functions produces a computable function. Whenever h is obtained by prim-
itive recursion from computable functions f and g, then it is easy to see how one can ef-
fectively find h( ⃗x, 99), by first finding h( ⃗x, 0) and then working one’s way up as in Exam-
ple 5.2.15. Therefore, h is computable. However, in order to generate all of the effectively
computable functions on the natural numbers, we need to have one more operation.
Before we formally identify this new operation, we begin with a motivating discussion.
Let us take a function g(x, y). Let x ∈ℕand suppose there is at least one value of y
which makes g(x, y) = 0 and we want to find the least value of y for which g(x, y) = 0.
There is an effective method for doing this. We know that y is a natural number. We
first set y = 0 and then compute g(x, y); if we get 0 we stop, because we have found
the least y such that g(x, y) = 0; but if not, we try the next natural number 1. We try
y = 0, 1, 2, 3 . . . until we reach the first value such that g(x, y) = 0. Then we define h(x) =
y and thereby get a new function. When we know that there is such a value, then this
method will terminate in a finite amount of time with the correct answer. Moreover, if
h(x) is a function that computes the least y such that g(x, y) = 0, then h is computable.
We will say that h is produced from g by minimization.
However, we do not always know that there is a y where g(x, y) = 0. Hence the
project of testing y = 0, 1, 2, 3, . . . may never terminate. If we run the test anyway, which

170
౪
5 Computability
is called unbounded minimization, we will get h to be a partial function. For this reason,
we will refer to unbounded minimization as partial search because such searches may
not be successful and thus can produce a partial function.
Since we will be working with partial functions, we will use the notation h( ⃗x)↓to
indicate that the function h is defined at ⃗x, and we will write h( ⃗x)↑when h is undefined
at ⃗x. Moreover, when we say that h: ℕk →ℕis a partial function, we mean that the
domain of h may be a proper subset of ℕk. We now introduce the μ-operator, which
searches for the least natural number that yields a functional value of 0.
Definition 5.2.18. Let g be a (k+1)-place function on ℕ. We say that the k-place function
h is obtained (constructed) from g by partial search if h satisfies
h( ⃗x) = μy(g( ⃗x, y) = 0),
that is, for each ⃗x ∈ℕk, we have h( ⃗x)↓and h( ⃗x) = y if and only if y satisfies the following
two conditions:
1.
g( ⃗x, y)↓and g( ⃗x, y) = 0,
2.
g( ⃗x, s)↓and g( ⃗x, s) > 0 for all s < y.
When the function g in Definition 5.2.18 is effectively computable, then so is h be-
cause we can evaluate h( ⃗x) by investigating the values g( ⃗x, 0), g( ⃗x, 1), . . . , g( ⃗x, i) (in this
order) until we find the first solution y to the equation g( ⃗x, y) = 0. If there is no such y,
then the search will never end.
Using the initial functions and the operations of composition, primitive recursion,
and partial search, we can now define a class of functions that includes the primitive
recursive functions.
Definition 5.2.19. A function is partial recursive if it can be generated by starting with
the initial functions and using the operations of composition, primitive recursion, and
partial search.
The collection of partial recursive functions is the smallest set that contains the ini-
tial functions and is closed under composition, primitive recursion, and partial search.
Such functions can be partial functions, because the operation of partial search can pro-
duce partial functions. However, the expression “partial recursive” is an inseparable
phrase, that is, it should be thought of as “partial-recursive.”
In Section 5.2.1, we said that a partial function f : ℕk →ℕis Turing computable
when there is a Turing machine that will evaluate f . Thus, the definition of a Turing
computable function is very different from the definition of a partial recursive function.
Is there a connection between these two dissimilar ways of defining functions? Alan
Turing was the first to prove the following striking result.
Theorem 5.2.20 (Turing). Let f : ℕk →ℕbe a partial function. Then f is partial recursive
if and only if f is Turing computable.

5.2 Formalizations—an overview
౪
171
There are mathematically formal definitions of a function being Turing computable,
register-machine computable, and partial recursive. All three of these computational
processes are equivalent, that is, all three approaches define the same class of functions.
However, we have not given a formal definition of a function being computable. This is
because the notion of being computable is intuitive and consequently cannot be given a
precise formal definition. A thesis identified by Alonzo Church and Alan Turing relates
the informal idea of being computable to the formal ideas presented in this section. It is
an observation that has been verified by very strong evidence.
Church-Turing Thesis. Let f be a partial function on the natural numbers. Then the fol-
lowing are equivalent:
–
f is computable;
–
f is Turing computable;
–
f is register-machine computable;
–
f is partial recursive.
Exercises 5.2.
1. Let Σ = {a, b} be a two-letter alphabet. Let f : Σ∗→Σ∗be the 1-place Turing com-
putable function defined by the Turing machine (TM), where q1 is the initial state.
Evaluate f (aabb), f (aba), and f (bbaa). We have
⟨q1, a, b, R, q2⟩
⟨q1, b, a, R, q2⟩
⟨q1, B, a, R, q2⟩
⟨q2, a, b, L, q3⟩
⟨q2, b, a, R, q2⟩
⟨q2, B, a, L, q3⟩.
(TM)
2. Let Σ = {a, b} be a two-letter alphabet. Let f : Σ∗→Σ∗be the 1-place function defined
by f (w) = wbb for all w ∈Σ∗. Show that the function f is Turing computable. Then
verify that your machine, when given the input ab, will produce abbb as its output.
3. Let Σ = {a, b} be a two-letter alphabet. Let f : Σ∗→Σ∗be the 1-place function that
will switch the first letter of every nonempty word in Σ∗to the “other” letter. For
example, f (aabb) = babb and f (bbb) = abb. Show that f is Turing computable. Then
verify that your machine, when given the input aab, will produce bab as its output.
4. Let Σ = {a, b} be a two-letter alphabet. Let f : Σ∗→Σ∗be the 1-place function that
will take any nonempty word in Σ∗and change every occurrence of the letter a in
the word to the letter b and will not change any occurrence of letter b in the word.
For example, f (aaba) = bbbb and f (baa) = bbb. Show that f is Turing computable.
Then verify that your machine, when given the input aab, will produce bbb as its
output.
5. Give a register-machine program that computes f (x, y) = max{x −y, 0}.
6. Give a register-machine program that computes f (x, y) = x ⋅y.

172
౪
5 Computability
7. Give a register-machine program that computes f (x, y) = max{x, y}.
8. Let h: ℕ4 →ℕ, f : ℕ→ℕ, g: ℕ→ℕbe primitive recursive functions. Using
Definitions 5.2.12 and 5.2.16, show that the function k(x, y, z) = h(f (x), z, g(y), 2) is
primitive recursive.
9. Show that function p defined by (a) and (b) below is a primitive recursive function:
(a) p(m, 0) = m,
(b) p(m, n + 1) = p(m, n) + 1.
Prove that p(m, n) = m + n by induction on n.
10. Show that function h defined by (a) and (b) below is a primitive recursive function:
(a) h(m, 0) = 0,
(b) h(m, n + 1) = h(m, n) + m.
Prove that h(m, n) = mn by induction on n.
Exercise Notes: For Exercise 5, x is in register 1 and y is in register 2. Now move
register 1 into register 0. Keep decrementing registers 2 and 0 until register 2 contains 0.
For Exercise 6, x is in register 1 and y is in register 2. Register 0 initially contains the value
0. Copy register 1 into register 3. Each time you can decrement register 2, add register 3
to register 0 and then copy register 1 into register 3. For Exercise 7, x is in register 1
and y is in register 2. Copy registers 1 and 2 into registers 3 and 4, respectively. Start
decrementing registers 1 and 2. The first such register who gets to 0 had the smallest
initial value.
5.3 Recursive functions
In the previous section, we discovered that the concept of a computable function on the
natural numbers has several equivalent definitions (there are more). In this section, we
will focus our attention on the class of functions that are recursive. Recursive functions
include the primitive recursive functions and are closed under a search operation sim-
ilar to that of partial search (see Definition 5.2.18).
Recalling Definition 5.2.16, a function f from ℕk to ℕis primitive recursive if it can
be constructed starting with the zero, successor, and projection functions using com-
position and primitive recursion. Primitive recursion and composition are the key op-
erations that are used to build the primitive recursive functions. Primitive recursive
functions are the computable functions that form an important building block on the
way to capture all of the computable functions. Most of the functions normally studied
in number theory are primitive recursive; for example, addition, division, factorial, ex-
ponentiation, and the n-th prime are all primitive recursive functions. Let us revisit the
initial functions that were introduced in Section 5.2.3 and the operations of composition
and primitive recursion.

5.3 Recursive functions
౪
173
Definition 5.3.1. The initial functions are defined as follows:
–
For each k ≥0, the zero function ̊f : ℕk →ℕis defined by ̊f (x1, . . . , xk) = 0. The
constant 0 is viewed as a 0-place zero function.
–
The successor function S: ℕ→ℕis defined by S(x) = x + 1.
–
For all 1 ≤i ≤k, the projection function Ik
i : ℕk →ℕis defined by the equation
Ik
i (x1, . . . , xk) = xi.
Definition 5.3.2. Let n ≥1 and k ≥1. Suppose that f : ℕn →ℕand gi: ℕk →ℕfor each
i = 1, 2, . . . , n. We can then form the composite function h: ℕk →ℕ, which is defined by
h( ⃗x) = f (g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x)).
The composition
h( ⃗x) = f (g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x))
can be illustrated as a tree with a vertex having (n + 1) branches:
h
f
g1
g2
⋅⋅⋅
gn
Here, f must be an n-place function and g1, . . . , gn must all have the same number of
places as the function h.
The projection functions can be used to avoid the apparent rigidity in terms of the
arity of the functions used in composition. By using compositions with various projec-
tion functions, it is possible to pass a subset of the arguments of one function to another
function. For example, if g and h are 2-place functions, then the function
f (a, b, c) = g(h(c, a), h(a, b))
can be obtained by a composition of projection functions, namely,
f (a, b, c) = g(h(I3
3(a, b, c), I3
1 (a, b, c)), h(I3
1 (a, b, c), I3
2(a, b, c))).
Definition 5.3.3. Let k ≥1 and suppose that f : ℕk →ℕand g: ℕk+2 →ℕ. Then we can
define a function h: ℕk+1 →ℕby the following primitive recursion:
(1) h( ⃗x, 0) = f ( ⃗x),
(2) h( ⃗x, n + 1) = g(h( ⃗x, n), ⃗x, n), for all n ∈ℕ.
We note that Theorem 1.1.27 implies that the function h in Definition 5.3.3 exists and
is unique. The construction of this function h from the functions f and g is illustrated
by the following tree, where the left branch illustrates the “base step” (1) and the right
branch illustrates the “inductive step” (2).

174
౪
5 Computability
h
h( ⃗x, 0) = f ( ⃗x)
w = h( ⃗x, n)
h( ⃗x, n + 1) = g(w, ⃗x, n)
Note that g must have two more places than f and one more place than h. For example, if
h is a 2-place function, then g must be a 3-place function and f must be a 1-place function.
Definition 5.3.4. A function f from ℕk to ℕis primitive recursive if it can be constructed
starting with the zero, successor, and/or projection functions using composition and/or
primitive recursion.
Recall that the operation of partial search may not be successful. Consequently, this
operation can produce a partial function. The set of recursive functions is obtained by
requiring an additional closure condition which is a modification of the partial search
operation. This modification, when applicable, will always produce a total function.
Definition 5.3.5. Let g: ℕk+1 →ℕbe a total function. Suppose that for all
⃗x ∈ℕk,
there is a y ∈ℕsuch that g( ⃗x, y) = 0. We say that the k-place function h is obtained
(constructed) from g by total search if h satisfies
h( ⃗x) = μy(g( ⃗x, y) = 0),
that is,
h( ⃗x) = the least y such that g( ⃗x, y) = 0.
Definition 5.3.6. A function f from ℕk to ℕis recursive if it can be constructed start-
ing with the zero, successor, and/or projection functions using composition, primitive
recursion, and/or total search.
We observe that every recursive function is a total function. Moreover, every prim-
itive recursive function is a recursive function, and every recursive function is a partial
recursive function. We note that there are recursive functions that are not primitive re-
cursive, and there are partial recursive functions that are not recursive. In Chapter 6,
we will show that there is a close relationship between deductions in number theory
and recursive functions.
The set of recursive functions can be defined by recursion (see Section 1.1.5). Let B
be the set that consists of the zero, successor, and projection functions. Let ℱbe the set of
operations that correspond to composition, primitive recursion, and total search. Then,
as in Theorem 1.1.24, we can inductively define the sets of functions:
(1) C0 = B,
(2) Cn+1 = Cn ∪ℱ[Cn], for all n ∈ℕ.

5.3 Recursive functions
౪
175
Then C = ⋃n∈ℕCn is the set of all the recursive functions. Moreover, if a set contains
the zero, successor, and projection functions and is closed under composition, primitive
recursion, and total search, then the set contains all of the recursive functions.
We will now begin to show that many of the functions on the natural numbers that
we use in mathematics are (primitive) recursive. Each function that we construct can
be used to construct additional (primitive) recursive functions.
Proposition 5.3.7. The addition function h(x, y) = x + y is primitive recursive.
Proof. Observe that:
–
x + 0 = x,
–
x + (n + 1) = (x + n) + 1, for all n ∈ℕ.
Thus, letting h(x, y) = x + y, we have:
–
h(x, 0) = x,
–
h(x, n + 1) = h(x, n) + 1, for all n ∈ℕ.
We will now show that h is primitive recursive. We must find primitive recursive func-
tions f and g that satisfy Definition 5.3.3:
(1) h(x, 0) = f (x), where f is a 1-place function,
(2) h(x, n + 1) = g(h(x, n), x, n), for all n ∈ℕ, where g is a 3-place function.
The function h has two parts of its definition, namely items (1) and (2). We will find the
two functions f and g by using the following tree to show how h is built up from certain
primitive recursive functions. The left branch focuses on part (1) of the definition of h
and the right branch addresses part (2) of this definition.
h
h(x, 0) = x
= I1
1(x)
w = h(x, n)
h(x, n + 1) = w + 1
= S(w)
= S(I3
1 (w, x, n))
The desired function f is f (x) = I1
1(x), which is an initial function and therefore prim-
itive recursive. The desired function g is g(w, x, n) = S(I3
1 (w, x, n)), which is primitive
recursive because it is the result of composing initial functions. Hence, h is a primitive
recursive function.
The symbol “󳨃→” is read as “maps to.” This symbol gives us an easier way to identify
a function. The notation ⟨x, y⟩󳨃→x + y indicates that the function is a 2-place function
with input ⟨x, y⟩and output x + y.

176
౪
5 Computability
Proposition 5.3.8. Let k ∈ℕ. The constant function ⃗x 󳨃→k is primitive recursive.
Let k ∈ℕ. The constant function ⃗x 󳨃→k is primitive recursive because it is the
result of composing initial functions. For example, suppose k = 3 and let h(x, y, z, w) = 3.
Observe that
h(x, y, z, w) = 3 = S(S(S(0))) = S3(0) = S3( ̊f (x, y, z, w)),
where ̊f is the 4-place zero function. Since h is the composition of initial functions, it is
primitive recursive. For k ≥1 we shall let kf denote the constant function kf ( ⃗x) = k, for
all ⃗x ∈ℕk. The constant i = Si(0) shall be viewed as a 0-place constant function.
Proposition 5.3.9. The multiplication function ⟨x, y⟩󳨃→x × y is primitive recursive.
Proof. We note that:
(1) x × 0 = 0,
(2) x × (n + 1) = (x × n) + x, for all n ∈ℕ.
We will find the functions f and g by using the following tree to show how h is built up
from certain primitive recursive functions. The following left branch focuses on part (1)
of the definition of h and the right branch addresses part (2) of this definition.
h
h(x, 0) = 0
= ̊f (x)
w = h(x, n)
h(x, n + 1) = w + x
= I3
1 (w, x, n) + I3
2(w, x, n)
The desired function f is f (x) = ̊f (x), the zero function which is primitive recursive. The
desired function g is g(w, x, n) = I3
1 (w, x, n) + I3
2(w, x, n), which is primitive recursive
because addition is primitive recursive. Therefore, h is primitive recursive.
Since the function h(x, y) = x × y is primitive recursive, we see that
h(I2
1 (x, y), I2
1 (x, y)) = x × x = x2,
h(3f (x, y), I2
1 (x, y)) = 3 × x = 3x
are primitive recursive. Propositions 5.3.7, 5.3.8, and 5.3.9 imply that any polynomial
function with coefficients from ℕis primitive recursive. Thus, p(z, y, z) = 3xy8 + z2 is
primitive recursive.
Remark 5.3.10. Given any (primitive) recursive function f , we can define another func-
tion by replacing any of the variables in f with constants or by interchanging and/or

5.3 Recursive functions
౪
177
repeating the variables of f . The new function will then be (primitive) recursive. This
follows by composing f with the appropriate projection and constant functions.
Proposition 5.3.11. The exponentiation function ⟨x, y⟩󳨃→xy is primitive recursive.
Proof. Since
–
x0 = 1,
–
xn+1 = xn × x for all n ∈ℕ,
one can now show, in a manner similar to that in the proof of Proposition 5.3.9, that
exponentiation is primitive recursive.
The exponentiation function ⟨x, y⟩󳨃→yx is also primitive recursive. This is estab-
lished by composing certain projection functions with the primitive recursive function
in Proposition 5.3.11; namely, let h(x, y) = xy. Define the function g by
g(x, y) = h(I2
2(x, y), I2
1 (x, y)) = h(y, x) = yx.
Since g is constructed by composing primitive recursive functions, it follows that g is
primitive recursive. Since h(3, 4)
̸= g(3, 4), xy and yx are different functions.
Proposition 5.3.12. The factorial function x 󳨃→x! is primitive recursive.
Proof. We have:
–
0! = 1,
–
(n + 1)! = n! × (n + 1), for all n ∈ℕ.
Thus, letting h(x) = x!, we see that:
–
h(0) = 1,
–
h(n + 1) = h(n) × (n + 1), for all n ∈ℕ.
The following tree shows that h is primitive recursive.
h
h(0) = 1
w = h(n)
h(n + 1) = w × (n + 1)
= w × S(n)
= I2
1 (w, n) × S(I2
2(w, n))
Here, 1 is a 0-place primitive recursive function and g(w, n) = I2
1 (w, n) × S(I2
2(w, n)) is a
2-place primitive recursive function.

178
౪
5 Computability
Proposition 5.3.13. The predecessor function pred(x) = x −1 (where pred(0) = 0) is
primitive recursive.
Proof. We have:
–
pred(0) = 0,
–
pred(n + 1) = n, for all n ∈ℕ.
Thus, letting h(x) = pred(x), we see that:
–
h(0) = 0,
–
h(n + 1) = n, for all n ∈ℕ.
The following tree shows that h is primitive recursive.
h
h(0) = 0
w = h(n)
h(n + 1) = n
= I2
2(w, n)
Here, 0 is a 0-place primitive recursive function and g(w, n) = I2
2(w, n) is a 2-place prim-
itive recursive function.
Proposition 5.3.14. The proper subtraction function x
∘−y is primitive recursive, where
x ∘−y is defined by x ∘−y = max{x −y, 0}.
Proof. To see this, observe that:
–
x ∘−0 = x,
–
x ∘−(n + 1) = pred(x ∘−n), for all n ∈ℕ.
Thus, letting h(x, y) = x ∘−y, we see that:
–
h(x, 0) = x,
–
h(x, n + 1) = pred(h(x, n)), for all n ∈ℕ.
The following tree shows that h is primitive recursive.
h
h(x, 0) = x
= I1
1(x)
w = h(x, n)
h(x, n + 1) = pred(w)
= pred(I3
1 (w, x, n))

5.3 Recursive functions
౪
179
Here, I1
1 is a 1-place projection function and g(w, x, n) = pred(I3
1 (w, x, n)) is a 3-place
primitive recursive function.
We are now ready to show that bounded sums and products are recursive. First,
we review summation and product notation. Let f : ℕ→ℕand n ∈ℕ. The summation
notation ∑t<n f (t) and the product notation ∏t<n f (t) are defined as follows:
∑
t<n
f (t) = f (0) + f (1) + f (2) + ⋅⋅⋅+ f (n −1),
∏
t<n
f (t) = f (0) × f (1) × f (2) × ⋅⋅⋅× f (n −1),
where ∑t<0 f (t) = 0 and ∏t<0 f (t) = 1. Observe that
∑
t<(n+1)
f (t) = (∑
t<n
f (t)) + f (n)
and
∏
t<(n+1)
f (t) = (∏
t<n
f (t)) × f (n).
Proposition 5.3.15. Suppose that f : ℕk+1 →ℕis (primitive) recursive. Then the summa-
tion function s and the product function p defined by
s( ⃗x, y) = ∑
t<y
f ( ⃗x, t)
and
p( ⃗x, y) = ∏
t<y
f ( ⃗x, t)
are (primitive) recursive.
Proof. Since addition and multiplication are primitive recursive, the functions s and p
are defined, respectively, by primitive recursion as follows:
(1) s( ⃗x, 0) = 0,
(2) s( ⃗x, n + 1) = s( ⃗x, n) + f ( ⃗x, n), for all n ∈ℕ;
(1) p( ⃗x, 0) = 1
(2) p( ⃗x, n + 1) = p( ⃗x, n) × f ( ⃗x, n), for all n ∈ℕ.
Proposition 5.3.16. Define the function z by
z(x) = {1,
if x = 0,
0,
if x > 0.
Then z is primitive recursive.
Proof. We have z(x) = 1 ∘−x, and 1 ∘−x is primitive recursive (see Remark 5.3.10). To see
why z(x) = 1 ∘−x, observe that:
–
z(x) = 1 if and only if x = 0 if and only if 1 ∘−x = 1,
–
z(x) = 0 if and only if x > 0 if and only if 1 ∘−x = 0.
Another way to show that z is primitive recursive is to observe that:

180
౪
5 Computability
(1) z(0) = 1,
(2) z(n + 1) = 0, for all n ∈ℕ.
Thus, one can define z by primitive recursion as illustrated in the following tree.
z
z(0) = 1
w = z(n)
z(n + 1) = 0
= ̊f (w, n)
Here, 1 is a 0-place constant function and ̊f (w, n) is the 2-place zero function.
Proposition 5.3.17. Define the function h by
h(x, y) = {1,
if x ≤y,
0,
if x > y.
(5.4)
Then h is primitive recursive.
Proof. Clearly the function z(x ∘−y) is the composition of primitive recursive functions.
To see that h(x, y) = z(x ∘−y) satisfies (5.4), note that:
–
h(x, y) = 1 if and only if x ≤y if and only if x ∘−y = 0 if and only if z(x ∘−y) = 1,
–
h(x, y) = 0 if and only if x > y if and only if x ∘−y > 0 if and only if z(x ∘−y) = 0.
Thus, the function defined by (5.4) is primitive recursive.
We have been building recursive functions. We can thus build a recursive relation
by using its characteristic function.
Definition 5.3.18. Let k ≥1. We say that a k-place relation R on ℕis (primitive) recur-
sive if its characteristic function is (primitive) recursive.
In other words, a k-place relation R on ℕis (primitive) recursive if the function
CR(x1, x2, . . . , xk) = {1,
if ⟨x1, x2, . . . , xk⟩∈R,
0,
if ⟨x1, x2, . . . , xk⟩∉R
is (primitive) recursive. Thus, Proposition 5.3.17 shows that the 2-place relation
{⟨x, y⟩: x ≤y}
is primitive recursive. Proposition 5.3.16 shows that the set {0} is primitive recursive.

5.3 Recursive functions
౪
181
Given an n-place (primitive) recursive relation R and n k-place (primitive) recursive
functions g1, g2, . . . , gn, we can define the k-place relation Q by
Q = { ⃗x : ⟨g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x)⟩∈R}.
Since the characteristic function for Q is equal to the composition
CQ( ⃗x) = CR(g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x)),
it follows that the relation Q is also (primitive) recursive. This observation shall be re-
ferred to as the substitution rule.
For any n-place relation R on ℕ, we shall write R( ⃗x) to mean ⃗x ∈R. Thus, the substi-
tution rule states that if R is (primitive) recursive and g1, g2, . . . , gn are k-place (primitive)
recursive functions, then a relation Q that satisfies
Q( ⃗x)
if and only if
R(g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x))
(5.5)
is also (primitive) recursive.
Proposition 5.3.19. Show that the relation {⟨x, y⟩: x ≥y} is primitive recursive.
Proof. Let Q = {⟨x, y⟩: x ≥y}. We know by Proposition 5.3.17 that ≤is primitive recur-
sive. Recall that x ≥y if and only if y ≤x. Since
Q(x, y)
if and only if
I2
2(x, y) ≤I2
1 (x, y),
the substitution rule implies that the relation Q is primitive recursive.
Example 5.3.20. Show that the relation {⟨x, y⟩: x ≤y + 1} is primitive recursive.
Solution. Let Q be the relation {⟨x, y⟩: x ≤y + 1}. We know that ≤is primitive recursive
by Proposition 5.3.17. Since the successor function S(y) = y+1 is primitive recursive and
Q(x, y)
iff
x ≤S(y)
iff
I2
1 (x, y) ≤S(I2
2(x, y)),
the substitution rule implies that the relation {⟨x, y⟩: x ≤y + 1} is primitive recursive.
From two k-place relations R and Q on ℕ, we define the following three new rela-
tions:
–
R = { ⃗x ∈ℕk : not R( ⃗x)},
–
R ∩Q = { ⃗x ∈ℕk : R( ⃗x) and Q( ⃗x)},
–
R ∪Q = { ⃗x ∈ℕk : R( ⃗x) or Q( ⃗x)}.

182
౪
5 Computability
The relation R is called the complement of R and satisfies R( ⃗x) if and only if ⃗x ∉R. The
relation R ∩Q is the intersection of R and Q, and the relation R ∪Q is the union of the
relations R and Q.
Theorem 5.3.21. Suppose that R and Q are k-place (primitive) recursive relations. Then
the following relations are also (primitive) recursive:
1.
R = { ⃗x ∈ℕk : not R( ⃗x)},
2.
R ∩Q = { ⃗x ∈ℕk : R( ⃗x) and Q( ⃗x)},
3.
R ∪Q = { ⃗x ∈ℕk : R( ⃗x) or Q( ⃗x)}.
Proof. Let CR and CQ be the respective characteristic functions of the relations R and Q.
Assuming that CR and CQ are (primitive) recursive, we shall show that the relations R,
R ∩Q, and R ∪Q are also (primitive) recursive.
1.
First we show that CR( ⃗x) = z(CR( ⃗x)). Observe that
CR( ⃗x) = 1
iff
CR( ⃗x) = 0
iff
z(CR( ⃗x)) = 1.
Furthermore,
CR( ⃗x) = 0
iff
CR( ⃗x) = 1
iff
z(CR( ⃗x)) = 0.
Thus, CR( ⃗x) = z(CR( ⃗x)), which is a composition of (primitive) recursive functions.
Hence, R is a (primitive) recursive relation.
2.
One can easily check that CR∩Q( ⃗x) = CR( ⃗x) × CQ( ⃗x), which is a composition of (prim-
itive) recursive functions. Hence, R ∩Q is a (primitive) recursive relation.
3.
First we show that CR∪Q( ⃗x) = 1 ∘−z(CR( ⃗x) + CQ( ⃗x)). Note that
CR∪Q( ⃗x) = 1
iff
CR( ⃗x) + CQ( ⃗x) ≥1
iff
z(CR( ⃗x) + CQ( ⃗x)) = 0
iff
1 ∘−z(CR( ⃗x) + CQ( ⃗x)) = 1.
Moreover,
CR∪Q( ⃗x) = 0
iff
CR( ⃗x) + CQ( ⃗x) = 0
iff
z(CR( ⃗x) + CQ( ⃗x)) = 1
iff
1 ∘−z(CR( ⃗x) + CQ( ⃗x)) = 0.
Thus, CR∪Q( ⃗x) = 1 ∘−z(CR( ⃗x)+CQ( ⃗x)), a composition of (primitive) recursive functions.
Therefore, R ∪Q is a (primitive) recursive relation.

5.3 Recursive functions
౪
183
By a pertinent application of the projection functions, Theorem 5.3.21 implies that
the conjunction and disjunction of any two (primitive) recursive relations are also
(primitive) recursive. For example, if R(x, y) and S(y, z) are recursive, then the rela-
tion P(x, y, z) defined by “R(x, y) and S(y, z)” is also recursive.
From Theorem 5.3.21(2)(3), using a proof by induction, one can now show that any
finite intersection or union of recursive sets is also recursive.
Corollary 5.3.22. Let n ∈ℕand suppose that R1, R2, . . . , Rn are k-place (primitive) recur-
sive relations. Then
⋂
1≤i≤n
Ri
and
⋃
1≤i≤n
Ri
are (primitive) recursive.
We now apply Theorem 5.3.21 to show that the relations <, >, and = are primitive
recursive.
Proposition 5.3.23. The following relations are primitive recursive:
1.
{⟨x, y⟩: x < y},
2.
{⟨x, y⟩: x > y},
3.
{⟨x, y⟩: x = y}.
Proof. We show that the relations are primitive recursive as follows:
1.
Theorem 5.3.21(1) implies that {⟨x, y⟩: x < y} is primitive recursive, since < is the
complement of the relation ≥, which is primitive recursive by Proposition 5.3.19.
2.
Theorem 5.3.21(1) implies that {⟨x, y⟩: x > y} is primitive recursive, as > is the
complement of the relation ≤, which is primitive recursive by Proposition 5.3.17.
3.
Clearly, E = {⟨x, y⟩: x = y} is the intersection of ≤and ≥. Propositions 5.3.17
and 5.3.19 and Theorem 5.3.21(2) imply that E is primitive recursive.
We can now prove that any finite set of natural numbers is primitive recursive.
Proposition 5.3.24. Let A = {n1, n2, . . . , nk} be a finite set of natural numbers. Then A is
primitive recursive.
Proof. Let ni ∈A, where 1 ≤i ≤k. We first show that the singleton {ni} is primitive
recursive. Let nif be the constant function defined by nif (x) = ni, for all x ∈ℕ. The
function nif is primitive recursive by Proposition 5.3.8. Clearly, x ∈{ni} if and only if
x = ni. It follows from the substitution rule that {ni} is primitive recursive. To formally
establish this, let I1
1 be the 1-place projection function. By Proposition 5.3.23, the relation
x = y is primitive recursive. As
x ∈{ni}
iff
I1
1(x) = nif (x),

184
౪
5 Computability
the substitution rule (see (5.5)) implies that {ni} is primitive recursive. Hence, since A =
⋃1≤i≤k{ni}, Corollary 5.3.22(2) implies that A is primitive recursive.
We now show that the graph of a recursive function is itself recursive. The converse
also holds (see Exercise 14).
Proposition 5.3.25. Let f : ℕn →ℕbe a (primitive) recursive function. Then the relation
G = {⟨⃗x, y⟩: f ( ⃗x) = y}, the graph of f , is (primitive) recursive.
Proof. Since the relation = is primitive recursive and
G( ⃗x, y)
if and only if
f ( ⃗x) = y,
it follows from the substitution rule that G is a (primitive) recursive relation. More
specifically, since ⃗x denotes the n-tuple x1, x2, . . . , xn, we see that In+1
i
( ⃗x, y) = xi for each
1 ≤i ≤n and In+1
n+1( ⃗x, y) = y. For every ⃗x ∈ℕn and y ∈ℕ, define
g1( ⃗x, y) = f (In+1
1
( ⃗x, y), . . . , In+1
n
( ⃗x, y))
and
g2( ⃗x, y) = In+1
n+1( ⃗x, y).
Then g1 and g2 are (primitive) recursive, where g1( ⃗x, y) = f ( ⃗x) and g2( ⃗x, y) = y. Thus,
G( ⃗x, y)
if and only if
g1( ⃗x, y) = g2( ⃗x, y).
As the relation = is primitive recursive, the substitution rule (see (5.5)) implies that the
relation G is (primitive) recursive.
The next theorem gives a condition for which one can define a (primitive) recursive
function by cases.
Theorem 5.3.26. Let Q be a k-place (primitive) recursive relation. If f and g are k-place
(primitive) recursive functions, then the k-place function h defined by
h( ⃗x) = {f ( ⃗x),
if Q( ⃗x),
g( ⃗x),
if not Q( ⃗x)
is also (primitive) recursive.
Proof. Note that
h( ⃗x) = (f ( ⃗x) × CQ( ⃗x)) + (g( ⃗x) × CQ( ⃗x)),
which is (primitive) recursive by Propositions 5.3.9 and 5.3.7 and Theorem 5.3.21.
Theorem 5.3.26 can be extended to more than just two exclusive cases. For example,
suppose that f1, f2, f3, f4 are k-place (primitive) recursive functions and suppose that R
and Q are k-place (primitive) recursive relations. Then Theorem 5.3.21 implies that the
function h: ℕk →ℕdefined by

5.3 Recursive functions
౪
185
h( ⃗x) =
{
{
{
{
{
{
{
{
{
{
{
f1( ⃗x),
if Q( ⃗x) and R( ⃗x),
f2( ⃗x),
if Q( ⃗x) and not R( ⃗x),
f3( ⃗x),
if R( ⃗x) and not Q( ⃗x),
f4( ⃗x),
if not Q( ⃗x) and not R( ⃗x)
is also (primitive) recursive. In the above definition of h, no two of the four cases occur
at the same time, that is, the cases are exclusive. Furthermore, for each ⃗x exactly one of
these cases holds.
As another example, let f1, f2, f3, f4 be k-place (primitive) recursive functions and
let Q1, Q2, Q3 be k-place (primitive) recursive relations. Suppose that the relations are
exclusive, that is, for any ⃗x, no two of the relations Q1( ⃗x), Q2( ⃗x), and Q3( ⃗x) hold at the
same time. Then the function h: ℕk →ℕdefined by
h( ⃗x) =
{
{
{
{
{
{
{
{
{
{
{
f1( ⃗x),
if Q1( ⃗x),
f2( ⃗x),
if Q2( ⃗x),
f3( ⃗x),
if Q3( ⃗x),
f4( ⃗x),
if none of the above hold
is (primitive) recursive.
Bounded number quantifiers are very useful when one wants to put some restric-
tion on the numbers being quantified. To say that all natural numbers x < 9 satisfy the
property P(x), we shall write (∀x < 9)P(x). Similarly, to say that some natural num-
ber x < 4 satisfies P(x), we can write (∃x < 4)P(x).
Definition 5.3.27 (Bounded number quantifiers). When a is a specific number, we write
(∀x < a)P(x) to mean that for every natural number x < a, P(x) is true. We also write
(∃x < a)P(x) to assert that for some natural number x < a, P(x) is true.
In our proof of the next theorem we will be using the 1-place function pos defined by
pos(x) = {1,
if x > 0,
0,
if x = 0.
(5.6)
In Exercise 3, one is asked to prove that pos is primitive recursive.
Theorem 5.3.28. If Q is a (k + 1)-place (primitive) recursive relation, then the two follow-
ing (k + 1)-place relations are also (primitive) recursive:
1.
R = {⟨⃗x, y⟩: (∀t < y)Q( ⃗x, t)},
2.
P = {⟨⃗x, y⟩: (∃t < y)Q( ⃗x, t)}.
Proof. Let Q be a (k + 1)-place (primitive) recursive relation. Thus, the characteristic
function CQ is (primitive) recursive. The characteristic function of the relation R is
CR( ⃗x, y) = ∏
t<y
CQ( ⃗x, t),

186
౪
5 Computability
which is (primitive) recursive by Proposition 5.3.15. Furthermore, the characteristic
function of the relation P is
CP( ⃗x, y) = pos(∑
t<y
CQ( ⃗x, t)),
which is also (primitive) recursive by Exercise 3 and Proposition 5.3.15.
Theorem 5.3.28 implies that whenever Q is a (k + 1)-place (primitive) recursive re-
lation and we define a (k + 1)-place relation R by
R( ⃗x, y)
if and only if
(∀t < y)Q( ⃗x, t),
then R is (primitive) recursive. Similarly, if we define a (k + 1)-place relation P by
P( ⃗x, y)
if and only if
(∃t < y)Q( ⃗x, t),
we can conclude that P is (primitive) recursive.
Example 5.3.29. Show that the 2-place relation R = {⟨x, y⟩: (∃q < y + 1)(x × q = y)} is
primitive recursive.
Solution. Observe that the 3-place relation Q defined by
Q(x, q, y)
if and only if
x × q = y
is primitive recursive by Proposition 5.3.25. Define the 3-place relation P by
P(x, y, z)
if and only if
(∃q < z)(x × q = y).
Theorem 5.3.28(2) implies that P is primitive recursive. Now let g1(x, y) = I2
1 (x, y),
g2(x, y) = I2
2(x, y), and g3(x, y) = S(I2
2(x, y)). Clearly, g1, g2, and g3 are primitive recursive
functions. By the substitution rule (see page 181) the relation
P(g1(x, y), g2(x, y), g3(x, y))
is primitive recursive. Observe that
P(g1(x, y), g2(x, y), g3(x, y))
iff
P(x, y, y + 1)
iff
(∃q < y + 1)(x × q = y)
iff
R(x, y).
Therefore, the relation R is primitive recursive.
Proposition 5.3.30. The divisibility relation x | y is primitive recursive.

5.3 Recursive functions
౪
187
Proof. Since x | y if and only if x × q = y for some q, we must show that the relation
{⟨x, y⟩: x × q = y for some q}
is primitive recursive. To verify this, observe that
x | y
iff
∃q(x × q = y)
iff
(∃q ≤y)(x × q = y)
iff
(∃q < y + 1)(x × q = y).
Example 5.3.29 now implies that the divisibility relation x | y is primitive recursive.
Remark 5.3.31. It now follows that if we define a relation using bounded quantifiers,
constants, (primitive) recursive relations, (primitive) recursive functions, and the three
logical connectives “and”, “or”, and “not”, then the relation is (primitive) recursive.
Proposition 5.3.32. The set {2, 3, 5, 7, . . . } of prime numbers is primitive recursive.
Proof. We show that the 1-place relation {x ∈ℕ: x is a prime} is primitive recursive.
Observe that
x is a prime
iff
1 < x and (∀a < x)(∀b < x)(a × b
̸= x),
where the relations < and ̸= are primitive recursive, and the function × is also primitive
recursive. Therefore, the set of primes forms a primitive recursive set.
5.3.1 Bounded search
The total search operator (see Definition 5.3.5), also called the μ-operator, provides a
method for defining a function whose value is the least number that satisfies a particular
condition. We will now define a search operation that will only perform a search when
there is an upper bound on the number of the searches allowed, that is, the search will
terminate after looking at finitely many cases.
Definition 5.3.33. Let R be a (k + 1)-place relation on ℕ. For each ⃗x ∈ℕk, define the
number (μt < y)R( ⃗x, t) by
(μt < y)R( ⃗x, t) = {the least t that satisfies t < y and R( ⃗x, t),
y,
if no such t exists.
Thus, for any (k + 1)-place relation R on ℕ, we can define the following total (k + 1)-
place function f : ℕk+1 →ℕby
f ( ⃗x, y) = (μt < y)R( ⃗x, t).

188
౪
5 Computability
The function f is said to be defined by bounded minimization or bounded search. Observe
that f ( ⃗x, y) = y if and only if there is no t < y that satisfies R( ⃗x, t).
For example, consider the 2-place relation “t is a prime and t > x.” So we can define
the 2-place function f : ℕ2 →ℕby
f (x, y) = (μt < y)[t is a prime and t > x].
To illustrate how to evaluate this function, we obtain
f (4, 9) = (μt < 9)[t is a prime and t > 4] = 5,
f (4, 20) = (μt < 20)[t is a prime and t > 4] = 5,
f (9, 4) = (μt < 4)[t is a prime and t > 9] = 4,
f (9, 0) = (μt < 0)[t is a prime and t > 9] = 0.
Theorem 5.3.34. If R is a (primitive) recursive relation, then the function
f ( ⃗x, y) = (μt < y)R( ⃗x, t)
is (primitive) recursive.
Proof. We will show that f can be defined by primitive recursion. Observe that:
(1) f ( ⃗x, 0) = 0,
(2) f ( ⃗x, n + 1) =
{
{
{
{
{
{
{
f ( ⃗x, n),
if f ( ⃗x, n) < n,
n,
if f ( ⃗x, n) = n and R( ⃗x, n),
n + 1,
if f ( ⃗x, n) = n and not R( ⃗x, n),
for all n ∈ℕ.
Thus, we get the following tree, where g is (primitive) recursive (see Proposition 5.3.23,
Remark 5.3.31, and Theorem 5.3.26).
f
f ( ⃗x, 0) = 0
= ̊f ( ⃗x)
w = f ( ⃗x, n)
f ( ⃗x, n + 1) =
{
{
{
{
{
{
{
w,
if w < n,
n,
if w = n & R( ⃗x, n),
n + 1,
if w = n & ¬R( ⃗x, n)
= g(w, ⃗x, n)
Euclid proved that there are infinitely many prime numbers. So the function
h: ℕ→ℕdefined in our next theorem is a total function.

5.3 Recursive functions
౪
189
Theorem 5.3.35. Let h: ℕ→ℕbe defined by
h(x) = the smallest prime number that is strictly larger than x.
(5.7)
Then h is primitive recursive.
Proof. First we prove that for every natural number x there is a prime number p such
that x < p ≤x! + 1. Note that every prime number q ≤x evenly divides x!. We know that
every natural number greater than 1 is divisible by a prime. Since x! + 1 > 1, the natural
number x! + 1 is divisible by a prime p. Because p evenly divides x! + 1, it follows that p
does not evenly divide x!. Therefore, x < p ≤x! + 1. It now follows that
h(x) = (μt < (x! + 2))[t is a prime and t > x].
(5.8)
The predicate
t is a prime and t > x
is primitive recursive by Propositions 5.3.32 and 5.3.23 and Theorem 5.3.21(2). Also, the
function x 󳨃→x! is primitive recursive by Proposition 5.3.12. So f : ℕ→ℕdefined by
f (x) = x! + 2 is primitive recursive. Theorem 5.3.34 implies that the function
⟨x, y⟩󳨃→(μt < y)[t is a prime and t > x]
is primitive recursive. Therefore, by composition, the function h satisfying (5.8) is also
primitive recursive.
For each x ∈ℕ, let px be the (x + 1)-st prime number. Thus,
p0 = 2,
p1 = 3,
p2 = 5,
p3 = 7,
p4 = 11, . . . , p25 = 101, . . . .
One can easily prove, by induction, that px > x + 1 for all x ∈ℕ.
Proposition 5.3.36. The function x 󳨃→px is primitive recursive.
Proof. Let g be defined by g(x) = px. Now let h be the primitive recursive function in
Theorem 5.3.35. Then g can be defined by primitive recursion as follows:
(1) g(0) = 2,
(2) g(n + 1) = h(g(n)), for all n ∈ℕ.
Thus, the function g is primitive recursive.
An important feature of the natural numbers is that one can code a finite sequence
of natural numbers by a single natural number. The fundamental theorem of arithmetic
(see Theorem 1.1.29 on page 11) states that every natural number x has a unique prime

190
౪
5 Computability
factorization. This theorem allows us to encode any finite tuple of natural numbers by
a single natural number using the following bracket notation:
[ ] = 1,
[x, y] = 2x+13y+1,
[x, y, z] = 2x+13y+15z+1,
...
[x0, x1, . . . , xk] = 2x0+13x1+15x2+1 ⋅⋅⋅pxk+1
k
,
(5.9)
where [ ] encodes the “empty” tuple and pk denotes the (k + 1)-st prime. For example,
[2, 1] = 72 and [2, 1, 0] = 360. Let S be the set of all finite sequences (tuples) of natural
numbers. Then the function h: S →ℕdefined by h(⟨x0, x1, . . . , xk⟩) = [x0, x1, . . . , xk] is
one-to-one; however, h is not onto since 10 = 2 × 5 is not a value of this function.
Theorem 5.3.37. Let k be a natural number. The function h: ℕk+1 →ℕdefined by
h(x0, x1, . . . , xk) = [x0, x1, . . . , xk]
(5.10)
is primitive recursive.
Proof. Let k ∈ℕ. As h(x0, x1, . . . , xk) = 2x0+13x1+15x2+1 ⋅⋅⋅pxk+1
k
, it follows from Proposi-
tion 5.3.15 that h is primitive recursive because exponentiation is primitive recursive
(see Propositions 5.3.11).
Let s be a natural number which codes a sequence, that is, s = [a0, a1, a2, . . . , ak]
for some finite (k + 1)-tuple of natural numbers a0, a1, a2, . . . , ak. We will next show that
there is a primitive recursive “decoding” function ⟨s, i⟩󳨃→(s)i such that (s)i = ai for
each i ≤k. For example, since [2, 1] = 72, we have (72)0 = 2 and (72)1 = 1.
Proposition 5.3.38. A primitive recursive decoding function ⟨s, i⟩󳨃→(s)i exists.
Proof. For a prime number q, the largest exponent e such that qe | s is also the least
natural number k such that qk+1 ∤s, that is, e = μk(qk+1 ∤s). Since q ≥2 and qe | s,
we have e < qe ≤s. Hence, e = (μk < s)(qk+1 ∤s). Thus, the exponent of q in the prime
factorization of s is equal to
(μk < s)(qk+1 ∤s).
When q = pi, the (i + 1)-st prime, define
(s)∗
i = (μk < s)(pk+1
i
∤s),

5.3 Recursive functions
౪
191
which is the largest exponent of pi in the prime factorization of s. For our decoding
function we need one less than the exponent of the prime pi in the prime factorization
of s. Thus, we have
(s)i = (s)∗
i
∘−1 = (μk < s)(pk+1
i
∤s) ∘−1,
which is primitive recursive since the far right hand side of the above equations involves
the composition of primitive recursive functions (see Theorems 5.3.34 and 5.3.21(1) and
Propositions 5.3.36 and 5.3.14).
Note that (s)i is defined for all s, i ∈ℕ, even when s does not code a sequence.
Definition 5.3.39. A natural number s is called a sequence number if s = [ ] or s =
[a0, a1, a2, . . . , ak] for some (k + 1)-tuple of natural numbers a0, a1, a2, . . . , ak.
For example, 1 and 108 are sequence numbers because 1 = [ ] and [1, 2] = 2233 = 108,
but 10 is not a sequence number.
Proposition 5.3.40. The set of sequence numbers is primitive recursive.
Proof. See Exercise 11.
One can prove (by induction) that n + 1 < pn for all natural numbers n. Let x ∈ℕ
and let k be the smallest such that pk ∤x. So x ≥1. If k = 0, then k < x. If k > 0, then
pk−1 | x. Thus, pk−1 ≤x and hence, k = (k −1) + 1 < pk−1 ≤x, that is, k < x. Therefore, if
k is the smallest such that pk ∤x, then k < x. This justifies the upper bound of x on the
μ-operator in the following proposition.
Proposition 5.3.41. The function lh(x) = (μk < x)(pk ∤x) is primitive recursive.
Proof. This holds because lh(x) = (μk < x)(pk ∤x) and the right hand side of this
equation is primitive recursive.
The function lh(x) is called the length function and gives the length of a sequence
coded by x; for example, since 360 = 23 × 32 × 5 = [2, 1, 0] and p3 = 7 is the least prime
that does not divide 360, we have lh(360) = 3. In general, if x = [a0, a1, a2, . . . , ak], then
lh(x) = k + 1. In addition, (x)lh(x) ∘−1 = ak is the last component of the sequence. We note
that lh(0) = 0 by Definition 5.3.33.
Let x = [a0, a1, a2, . . . , ak] be a sequence number and let y ≤k + 1. Consider the
function ⟨x, y⟩󳨃→x ↾y defined by
x ↾y = [a0, a1, a2, . . . , ay−1].
We say that x ↾y is the restriction of x to y and gives us the code for the sequence
consisting of the first y components of the sequence coded by x.
Proposition 5.3.42. The function ⟨x, y⟩󳨃→x ↾y is primitive recursive.

192
౪
5 Computability
Proof. This holds because
x ↾y = ∏
t<y
p(x)∗
t
t
(5.11)
and the right hand side of (5.11) is a composition of primitive recursive functions.
For example, if x = [a0, a1, . . . , ak] and y ≤k + 1, then
x ↾y = [a0, a1, . . . , ay−1] = pa0+1
0
pa1+1
1
⋅⋅⋅p
ay−1+1
y−1
= p(x)∗
0
0
p(x)∗
1
1
⋅⋅⋅p
(x)∗
y−1
y−1
= ∏
t<y
p(x)∗
t
t
.
Furthermore, if k = lh(x) ∘−1, then x ↾k = [a0, a1, a2, . . . , ak−1] results in the deletion of
the last component in the sequence coded by x.
Let x = [a0, a1, a2, . . . , ak] and y = [b0, b1, b2, . . . , bℓ] be two sequence numbers. Con-
sider the function ⟨x, y⟩󳨃→x ∗y defined by
x ∗y = [a0, a1, a2, . . . , ak, b0, b1, b2, . . . , bℓ].
We say that x ∗y is the concatenation of x to y.
Proposition 5.3.43. The concatenation function ⟨x, y⟩󳨃→x ∗y is primitive recursive.
Proof. We must show that there is a 2-place primitive recursive function such that if x
and y are sequence numbers, then ⟨x, y⟩󳨃→x ∗y. This is done by defining
x ∗y = x × ∏
t<lh(y)
p(y)∗
t
t+lh(x),
which is a composition of primitive recursive functions.
Since [2, 1] = 23 × 32 = 72,
72 ∗72 = [2, 1] ∗[2, 1] = [2, 1, 2, 1] = 72 × 53 × 72 = 441, 000.
Moreover, if x is a sequence number and i ∈ℕ, then x ∗[i] is the sequence number of
the sequence obtained by adjoining i at the end of the sequence coded by x. We note that
x ∗y is defined for all x and y in ℕ, even if x and y are not sequence numbers.
We can define the operation of concatenation of more than two sequence numbers.
Suppose that x0, x1, . . . xk−1 are sequence numbers. Then we can concatenate all of the
sequences coded by x0, x1, . . . xk−1, denoted by∗t<k xt, as follows:
∗
t<k
xt = x0 ∗x1 ∗⋅⋅⋅∗xk−1,
where on the right hand side of the above equation the operation ∗is associative.

5.3 Recursive functions
౪
193
Proposition 5.3.44. Let f be a (primitive) recursive (k + 1)-place function. Then the func-
tion ⟨⃗x, y⟩󳨃→∗t<y f ( ⃗x, t) is (primitive) recursive.
Proof. Note that the function ⟨⃗x, y⟩󳨃→∗t<y f ( ⃗x, t) can be defined by primitive recursion
as follows:
(1) ∗t<0 f ( ⃗x, t) = 1,
(2) ∗t<(n+1) f ( ⃗x, t) = (∗t<n f ( ⃗x, t)) ∗f (x, n), for all n ∈ℕ.
Therefore, the function ⟨⃗x, y⟩󳨃→∗t<y f ( ⃗x, t) is (primitive) recursive.
For any (k + 1)-place function f , we define a new (k + 1)-place function f by
f ( ⃗x, y) = [f ( ⃗x, 0), f ( ⃗x, 1), . . . , f ( ⃗x, y −1)] = ∏
t<y
pf ( ⃗x,t)+1
t
.
So the function f encodes the first y values f ( ⃗x, 0), f ( ⃗x, 1), . . . , f ( ⃗x, y −1) of f as a single
natural number. For example, f ( ⃗x, 0) = [ ] = 1 and f ( ⃗x, 2) = [f ( ⃗x, 0), f ( ⃗x, 1)]. Clearly,
f ( ⃗x, y) is always a sequence number of length y.
Proposition 5.3.45. Let f be a (primitive) recursive (k +1)-place function. Then the (k +1)-
place function f is (primitive) recursive.
Proof. Since f ( ⃗x, y) = ∏t<y pf ( ⃗x,t)+1
t
, we see that the right hand side of this equation is a
composition of (primitive) recursive functions.
Given any (k +2)-place function g, there exists a unique (k +1)-place function h that
satisfies the equation
h( ⃗x, y) = g(h( ⃗x, y), ⃗x, y),
where we must first know the value of
h( ⃗x, y) = [h( ⃗x, 0), h( ⃗x, 1), . . . , h( ⃗x, y −1)]
before we can evaluate h( ⃗x, y). For example,
h( ⃗x, 0) = g([ ], ⃗x, 0),
h( ⃗x, 1) = g([h( ⃗x, 0)], ⃗x, 1),
h( ⃗x, 2) = g([h( ⃗x, 0), h( ⃗x, 1)], ⃗x, 2),
(󳵳)
...
h( ⃗x, n) = g([h( ⃗x, 0), h( ⃗x, 1), . . . , h( ⃗x, n −1)], ⃗x, n),
h( ⃗x, n + 1) = g([h( ⃗x, 0), h( ⃗x, 1), . . . , h( ⃗x, n −1), h( ⃗x, n)], ⃗x, n + 1).

194
౪
5 Computability
The definition of a function by primitive recursion allows one to define the value
of a function h( ⃗x, n + 1) in terms of its preceding value h( ⃗x, n) (see Definition 5.2.14).
The above (󳵳) clearly illustrates how to define the value of a function in terms of all
its preceding values, namely, by coding the sequence of preceding values as a sequence
number. In computability theory, a course-of-values recursion is a technique for defining
number-theoretic functions by recursion.
Proposition 5.3.46 (Course of values recursion). Let g be a (primitive) recursive (k + 2)-
place function. Then the (k + 1)-place function h that satisfies
h( ⃗x, n) = g(h( ⃗x, n), ⃗x, n), for all ⃗x and n,
is (primitive) recursive.
Proof. To prove that h is (primitive) recursive, we first show (paradoxically) that h is
(primitive) recursive. Note that h satisfies the primitive recursion:
(1) h( ⃗x, 0) = 1,
(2) h( ⃗x, n + 1) = h( ⃗x, n) ∗[g(h( ⃗x, n)), ⃗x, n)], for all n ∈ℕ.
Thus, h is (primitive) recursive. Since (h( ⃗x, n+1))n = h( ⃗x, n), we conclude that h is (prim-
itive) recursive. From (2), we also conclude that
(h( ⃗x, n + 1))n = (h( ⃗x, n) ∗[g(h( ⃗x, n)), ⃗x, n)])n.
Thus, h( ⃗x, n) = g(h( ⃗x, y), ⃗x, n).
We end this section by showing how the total search operation can be used to con-
struct a recursive function.
Proposition 5.3.47. Let R ⊆ℕk+1 be a recursive relation such that for all ⃗x ∈ℕk there is
a p ∈ℕsuch that R( ⃗x, p). Then the function f : ℕk →ℕdefined by
f ( ⃗x) = the least p ∈ℕsuch that R( ⃗x, p)
(5.12)
is recursive and R( ⃗x, f ( ⃗x)) for all ⃗x ∈ℕk.
Proof. Since for all ⃗x ∈ℕk there exists a p ∈ℕsuch that R( ⃗x, p), the function f : ℕk →ℕ
defined by (5.12) satisfies f ( ⃗x) = μp(1
∘−CR( ⃗x, p) = 0). Therefore, f is recursive and
R( ⃗x, f ( ⃗x)) for all ⃗x ∈ℕk.
Exercises 5.3.
1. Show that the function f : ℕ→ℕdefined by f (x) = x2 is primitive recursive.
2. Show that the function f : ℕ→ℕdefined by
f (n) = {1,
if n is even,
0,
if n is odd

5.4 Recursively enumerable sets and relations
౪
195
is primitive recursive.
*3. Show that the function pos defined by (5.6) is primitive recursive.
4. Let f : ℕ→ℕand the 2-place relation Q be (primitive) recursive. Show, as in Ex-
ample 5.3.29, that R = {⟨x, y⟩: (∃q < f (y))Q(x, q)} is (primitive) recursive.
5. Show that the set {i2 : i ∈ℕ} is primitive recursive.
6. Show that the set {2i : i ∈ℕ} is primitive recursive.
7. Using definition by cases, show that the following functions f : ℕ2 →ℕare primi-
tive recursive:
(a) f (x, y) = |x −y|,
(b) f (x, y) = max{x, y},
(c) f (x, y) = min{x, y}.
8. Find a nontotal 2-place function g such that the function h defined by
h(x) = μy(g(x, y) = 0),
that is,
h(x) = the least y such that g(x, y) = 0,
is a total function.
9. For each i ∈ℕ, by Proposition 5.3.38, the function t 󳨃→(t)i is primitive recursive.
Evaluate (24)0, (24)1, (45)0, (45)1, (45)2, (23)0, and (23)1.
10. Define m: ℕk+1 →ℕby m( ⃗x, n) = max{f ( ⃗x, i) : 0 ≤i ≤n}, where f : ℕk+1 →ℕis
(primitive) recursive. Show that m is (primitive) recursive.
*11. Prove Proposition 5.3.40.
12. For each n ∈ℕ, let An be a recursive subset of ℕ. Show that ⋂n
i=0 Ai and ⋃n
i=0 Ai are
recursive, for all n ∈ℕ.
13. Let g: ℕ→ℕbe (primitive) recursive. Let g(0)(i) = i and whenever p ≥1, let
g(p) = g ∘g ∘⋅⋅⋅∘g
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
p-times
.
Define f : ℕ2 →ℕby f (i, n) = g(n)(i). Show that f is (primitive) recursive.
*14. Let f : ℕk →ℕbe a total function. Show that if the graph of f is recursive, then f is
recursive.
5.4 Recursively enumerable sets and relations
Some sets of natural numbers are recursive and some are almost recursive. Recall that
a recursive nonempty set A ⊆ℕis one whose characteristic function CA is recursive.
Using CA, one can effectively enumerate the elements of A. Let k0 ∈A and define the
function f : ℕ→ℕby

196
౪
5 Computability
f (n) = {n,
if CA(n) = 1,
k0,
if CA(n) = 0.
Clearly, f is a recursive function and the range of f is equal to A. Thus, we can list all the
values of f as follows: f (0), f (1), f (2), . . . . This listing also effectively enumerates all of the
elements of A. Theorem 5.3.21 implies that ℕ\ A is recursive. Thus, in a similar manner,
we can effectively enumerate the elements of ℕ\ A (if nonempty). This motivates our
next definition.
Definition 5.4.1. A set A ⊆ℕis recursively enumerable if and only if A = ⌀or there is a
recursive function f : ℕ→ℕsuch that A is the range of f .
The function f in Definition 5.4.1 is not required to be one-to-one. However, Exer-
cise 7 shows that every infinite recursively enumerable subset of ℕis the range of a
one-to-one recursive function.
A recursively enumerable set of natural numbers can be viewed as being “almost
recursive.” A recursively enumerable set is also said to be semi-recursive. There is an
alternative interpretation of a set being recursively enumerable.
Proposition 5.4.2. A set A ⊆ℕis recursively enumerable if and only if there is a 2-place
recursive relation R such that A = {n ∈ℕ: ∃pR(n, p)}.
Proof. Let A ⊆ℕ.
(⇒). Assume that A is recursively enumerable. Let f : ℕ→ℕbe a recursive function
such that A equals the range of f . Consider the relation
R = {⟨n, p⟩: n = f (p)}.
Since the relation = is primitive recursive, the substitution rule (see (5.5) on page 181)
implies that the relation R is recursive. Clearly, A = {n ∈ℕ: ∃pR(n, p)}.
(⇐). Assume that A = {n ∈ℕ: ∃pR(n, p)} for some recursive relation R. If A = ⌀, then
we are done. So let k ∈A. By Proposition 5.3.38, the “decoding” operation (s)i is defined
for all s, i ∈ℕ. Let f : ℕ→ℕbe defined by
f (n) = {(n)0,
if R((n)0, (n)1),
k,
if not R((n)0, (n)1).
Then f is recursive (see Proposition 5.3.38) and the range of f is A.
Proposition 5.4.2 allows us to broaden the definition of recursively enumerable.
Definition 5.4.3. A relation P ⊆ℕk is recursively enumerable if and only if there is a
(k + 1)-place recursive relation R such that

5.4 Recursively enumerable sets and relations
౪
197
P( ⃗x)
iff
∃pR( ⃗x, p)
for all ⃗x ∈ℕk.
Our goal now is to establish a surprising result: Every total partial recursive func-
tion is, in fact, a recursive function (see Theorem 5.4.12).
Theorem 5.4.4 (Selection theorem). Let S ⊆ℕk+1 be recursively enumerable and suppose
that for all ⃗x ∈ℕk there exists an i ∈ℕsuch that S( ⃗x, i). Then there is a recursive function
f : ℕk →ℕsuch that S( ⃗x, f ( ⃗x)) for all ⃗x ∈ℕk.
Proof. Given that S is recursively enumerable, there is a recursive relation R such that
S( ⃗x, i)
iff
∃jR( ⃗x, i, j).
Suppose that for all ⃗x ∈ℕk there exists an i ∈ℕsuch that S( ⃗x, i). Thus, for all ⃗x ∈ℕk
there are i, j ∈ℕsuch that R( ⃗x, i, j). Define h: ℕk →ℕby
h( ⃗x) = the least p ∈ℕsuch that R( ⃗x, (p)0, (p)1).
Note that h( ⃗x) = μp(1
∘−CR( ⃗x, (p)0, (p)1) = 0) and this is obtained from the recursive
function g( ⃗x, p) = 1 ∘−CR( ⃗x, (p)0, (p)1) by a total search (Definition 5.3.5). So h is recursive.
Define f : ℕk →ℕby f ( ⃗x) = (h( ⃗x))0. Thus, f is recursive and S( ⃗x, f ( ⃗x)) for all ⃗x ∈ℕk.
We now show that the set of recursively enumerable relations is closed under re-
cursive substitutions, conjunction, and disjunction.
Lemma 5.4.5. Suppose that P is an n-place recursively enumerable relation and that
g1, g2, . . . , gn are k-place recursive functions. Then the k-place relation Q defined by
Q( ⃗x)
iff
P(g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x))
is recursively enumerable.
Proof. Given that P is recursively enumerable, there is an (n+1)-place recursive relation
R such that P(x1, . . . , xn) iff ∃iR(x1, . . . , xn, i). Thus, for all ⃗x ∈ℕk, we have
Q( ⃗x)
iff
P(g1( ⃗x), . . . , gn( ⃗x))
iff
∃iR(g1( ⃗x), . . . , gn( ⃗x), i).
By the substitution rule, the relation R(g1( ⃗x), . . . , gn( ⃗x), i) is recursive. Therefore, Q is
recursively enumerable.
Lemma 5.4.6. Let R ⊆ℕk and Q ⊆ℕk.
1.
If R is a recursive relation, then R is recursively enumerable.
2.
If R and Q are recursively enumerable relations, then the following relations are also
recursively enumerable:

198
౪
5 Computability
(a) R ∩Q = { ⃗x ∈ℕk : R( ⃗x) and Q( ⃗x)},
(b) R ∪Q = { ⃗x ∈ℕk : R( ⃗x) or Q( ⃗x)}.
Proof. Suppose that R ⊆ℕk and Q ⊆ℕk.
1.
Let R be a recursive relation. The relation S ⊆ℕk+1 defined by S( ⃗x, p) iff R( ⃗x) is
recursive, as S is the result of a composition of R with the projection functions
Ik+1
i
(x1, . . . , xk, p) = xi, where 1 ≤i ≤k. Clearly, R( ⃗x) iff ∃pS( ⃗x, p). So R is recursively
enumerable.
2.
Assume that R and Q are recursively enumerable. Therefore, there are recursive
relations S ⊆ℕk+1 and U ⊆ℕk+1 such that
(R( ⃗x)
iff
∃pS( ⃗x, p))
and
(Q( ⃗x)
iff
∃pU( ⃗x, p)).
Thus,
(R( ⃗x) and S( ⃗x))
iff
∃p(S( ⃗x, (p)0) and U( ⃗x, (p)1)),
(R( ⃗x) or S( ⃗x))
iff
∃p(S( ⃗x, p) or U( ⃗x, p)).
Therefore, Theorem 5.3.21 and the substitution rule imply that the conjunction
“R( ⃗x) and S( ⃗x)” and disjunction “R( ⃗x) or S( ⃗x)” are recursively enumerable.
By a suitable use of the projection functions, part 2 of Lemma 5.4.6 implies that
the conjunction and disjunction of any two recursively enumerable relations are re-
cursively enumerable. For example, if R(x, y) and S(y, z) are recursively enumerable,
then the relation P(x, y, z) defined by “R(x, y) and S(y, z)” is recursively enumerable.
Moreover, by applying a proof by induction, part 2 of Lemma 5.4.6 implies that the con-
junction or disjunction of any finite number of recursively enumerable relations is also
recursively enumerable.
Corollary 5.4.7. Let n ∈ℕand suppose that R1, R2, . . . , Rn are k-place recursively enu-
merable relations. Then
1.
⋀n
i=1 Ri( ⃗x) = R1( ⃗x) ∧R2( ⃗x) ∧⋅⋅⋅∧Rn( ⃗x) is recursively enumerable,
2.
⋁n
i=1 Ri( ⃗x) = R1( ⃗x) ∨R2( ⃗x) ∨⋅⋅⋅∨Rn( ⃗x) is recursively enumerable.
We will now show that the set of recursively enumerable relations is closed under
the bounded number quantifiers and the existential quantifier.
Lemma 5.4.8. Let Q ⊆ℕk+1 be recursively enumerable and let n ∈ℕ. Then:
1.
The relation (∀i < n)Q( ⃗x, i) is recursively enumerable.
2.
The relation (∃i < n)Q( ⃗x, i) is recursively enumerable.
3.
The relation ∃iQ( ⃗x, i) is recursively enumerable.
Proof. Let Q ⊆ℕk+1 be recursively enumerable. Thus, there is a recursive relation R
such that

5.4 Recursively enumerable sets and relations
౪
199
Q( ⃗x, i)
iff
∃jR( ⃗x, i, j).
The desired conclusion follows from the following equivalences:
(∀i < n)Q( ⃗x, i)
iff
(∀i < n)∃jR( ⃗x, i, j)
iff
∃j(∀i < n)R( ⃗x, i, (j)i),
(5.13)
(∃i < n)Q( ⃗x, i)
iff
(∃i < n)∃jR( ⃗x, i, j)
iff
∃j(∃i < n)R( ⃗x, i, j),
(5.14)
∃iQ( ⃗x, i)
iff
∃i∃jR( ⃗x, i, j)
iff
∃kR( ⃗x, (k)0, (k)1).
(5.15)
To confirm (5.13), given that for each i < n there is a ji ∈ℕsuch that R( ⃗x, i, ji), let j be the
sequence number j = [j0, j1, . . . , jn−1]. Then (∀i < n)R( ⃗x, i, (j)i). Thus, ∃j(∀i < n)R( ⃗x, i, (j)i).
The converse holds similarly. Theorem 5.3.28 implies that the right hand sides of (5.13)
and (5.14) are recursively enumerable, and the substitution rule implies that the right
hand side of (5.15) is recursively enumerable.
The set of partial recursive functions can be defined by induction (see Section 1.1.5).
Let B be the set consisting only of the zero, successor, and projection functions. Let ℱ
be the set of functional operations that correspond to composition, primitive recursion,
and partial search. Then, as in Theorem 1.1.24, we inductively define the following sets
of functions:
(1) C0 = B,
(2) Cn+1 = Cn ∪ℱ[Cn], for all n ∈ℕ.
Then C = ⋃n∈ℕCn is the set of all the partial recursive functions. Moreover, whenever
a set contains the zero, successor, and projection functions and it is closed under com-
position, primitive recursion, and partial search, then the set contains all of the partial
recursive functions (see Exercise 5(b) on page 15). We will apply this observation in the
proof of our next theorem. First we give a definition.
Definition 5.4.9. Let h be a k-place partial recursive function. Then the graph of h is the
(k + 1)-place relation
Gh = {( ⃗x, y) : h( ⃗x) = y}.
The next theorem shows that there exists a close connection between partial recur-
sive functions and recursively enumerable relations.
Theorem 5.4.10. For every partial recursive function h, the graph of h is recursively enu-
merable.
Proof. Let S be the set of all partial recursive functions whose graph is recursively enu-
merable. We shall prove by induction that S contains all partial recursive functions.
Base step: We must show that every initial function is in S. To do this, let h be an
initial function. Since h is a recursive function, Gh is recursive by Proposition 5.3.25.
Lemma 5.4.6(1) now implies that the relation Gh is recursively enumerable.

200
౪
5 Computability
Inductive step: We must show that S is closed under (1) composition, (2) primitive re-
cursion, and (3) partial search. Let f , g, g1, g2, . . . , gn be partial recursive functions and
assume that all of these functions are in S, that is, assume the induction hypothesis
Gf , Gg, Gg1, . . . , Ggn are recursively enumerable.
(IH)
We now establish closure under the above identified operations (1), (2), and (3).
(1) Assume that f : ℕn →ℕand gi: ℕk →ℕfor each i = 1, 2, . . . , n. We must show that
function h: ℕk →ℕdefined by the composition
h( ⃗x) = f (g1( ⃗x), g2( ⃗x), . . . , gn( ⃗x))
is also in S. Since
h( ⃗x) = y
iff
∃v1 ⋅⋅⋅∃vn(
n
⋀
i=1
gi( ⃗x) = vi and f (v1, v2, . . . , vn) = y),
(IH), Corollary 5.4.7, and Exercise 11 imply that Gh is recursively enumerable.
(2) Assume that f : ℕk →ℕand g: ℕk+2 →ℕ. We must show that the function
h: ℕk+1 →ℕdefined by the primitive recursion
(a) h( ⃗x, 0) = f ( ⃗x),
(b) h( ⃗x, n + 1) = g(h( ⃗x, n), ⃗x, n), for all n ∈ℕ,
is also in S. Because
h( ⃗x, n) = y
iff
∃p(f ( ⃗x) = (p)0 and (∀i < n)(g((p)i, ⃗x, i) = (p)i+1) and (p)n = y),
Lemmas 5.4.5, 5.4.6, and 5.4.8(1)(2) and (IH) imply that Gh is recursively enumerable.
(3) Assume that g is a (k + 1)-place function. We must show that the k-place function h
defined by the partial search
h( ⃗x) = μy(g( ⃗x, y) = 0)
is in S. Since
h( ⃗x) = y
iff
g( ⃗x, y) = 0 and (∀i < y)∃v(g( ⃗x, s) = v and v > 0),
Lemmas 5.4.6 and 5.4.8(1)(2) and (IH) imply that Gh is recursively enumerable.
Theorem 5.4.10 and a modification of the proof of Theorem 5.4.4 (see Exercise 5) now
imply the following equivalence.
Theorem 5.4.11. Let h: ℕk →ℕbe a partial function. Then h is partial recursive if and
only if Gh is recursively enumerable.
Theorems 5.4.10 and 5.4.4 also imply that every total partial recursive function is
recursive.

5.4 Recursively enumerable sets and relations
౪
201
Theorem 5.4.12. Let h: ℕk →ℕbe a total partial recursive function. Then h is a recursive
function.
Proof. Let h be a total partial recursive function. Theorem 5.4.10 implies the relation
Gh( ⃗x, y)
iff
h(x) = y
(5.16)
is recursively enumerable. Since h is total, we know that for all ⃗x ∈ℕk, there is a y
such that Gh( ⃗x, y). The selection theorem (Theorem 5.4.4) implies that there is a recursive
function f : ℕk →ℕsuch that Gh( ⃗x, f ( ⃗x)) for all ⃗x ∈ℕk. Therefore, by (5.16), we conclude
that h( ⃗x) = f ( ⃗x) for all ⃗x ∈ℕk, that is, h is a recursive function.
5.4.1 Decidability revisited
In Section 5.1.1 we presented a definition of a decidable (semi-decidable) set. However,
this definition was given in terms of the intuitive concept of an “effective procedure.”
Because of Theorems 5.2.11 and 5.2.20 and the Church–Turing thesis, we can now give a
mathematically precise definition of a set being decidable (semi-decidable).
Definition 5.4.13. Let S ⊆ℕk. Then S is decidable if its characteristic function
CS( ⃗x) = {1,
if ⃗x ∈S,
0,
if ⃗x ∉S
is partial recursive. Moreover, S is semi-decidable if its semi-characteristic function
cS( ⃗x) = {1,
if ⃗x ∈S
↑,
if ⃗x ∉S
is partial recursive.
In light of Theorem 5.4.12, the above definition of a set being decidable can be made
stronger. Our next result confirms this by showing that a relation is decidable if and only
if its characteristic function is recursive.
Theorem 5.4.14. Let S ⊆ℕk. Then S is decidable if and only if S is recursive.
Proof. Assume that S is decidable. Thus, the characteristic function CS is total and par-
tial recursive. Theorem 5.4.12 implies that CS is recursive, so S is recursive. Conversely,
suppose that S is recursive. Then CS is recursive and hence, it is partial recursive. There-
fore, S is decidable.
Theorem 5.4.15. Let S ⊆ℕk. Then S is semi-decidable if and only if S is recursively enu-
merable.
Proof. Assume that S is semi-decidable. So cS is partial recursive. By Theorem 5.4.10, the
graph GcS( ⃗x, y) of cS is recursively enumerable. Since

202
౪
5 Computability
⃗x ∈S
iff
∃yGcS( ⃗x, y),
Lemma 5.4.8(3) implies that S is recursively enumerable.
For the converse, suppose that S is recursively enumerable. Definition 5.4.3 implies
that there is a recursive (k + 1)-place relation R such that
S( ⃗x)
iff
∃pR( ⃗x, p).
Since R is recursive, the characteristic function CR is recursive. Let h be the partial re-
cursive function
h( ⃗x) = μp(1 ∘−CR( ⃗x, p) = 0),
where h is the result of applying partial search (see Definition 5.2.18) to the recursive
function g( ⃗x, p) = 1 ∘−CR( ⃗x, p). Then CR( ⃗x, h( ⃗x)) is the semi-characteristic function of S.
Therefore, S is semi-decidable.
We now show that a relation is recursive if and only if the relation and its comple-
ment are recursively enumerable.
Theorem 5.4.16. Let P ⊆ℕk. Then P is recursive if and only if P and ℕk \P are recursively
enumerable.
Proof. Let P ⊆ℕk. Then P and ℕk \ P are recursive. Lemma 5.4.6(1) implies that both
of these sets are recursively enumerable. Now assume that P and ℕk \ P are recursively
enumerable. Thus, there are recursive (k + 1)-relations R and S such that
⃗x ∈P
iff
∃iR( ⃗x, i),
(5.17)
⃗x ∉P
iff
∃iS( ⃗x, i),
(5.18)
for all ⃗x ∈ℕk. Hence, for all ⃗x ∈ℕk, there exists an i such that R( ⃗x, i) or S( ⃗x, i). By
Lemma 5.4.6(2b), the relation “R( ⃗x, i) or S( ⃗x, i)” is recursive. So, by total search, the func-
tion h: ℕk →ℕdefined by
h( ⃗x) = μi(R( ⃗x, i)
or
S( ⃗x, i))
is recursive. Since ⃗x ∈P iff R( ⃗x, h( ⃗x)), it follows that P is recursive.
In Section 5.1.1 we presented an intuitive argument that was designed only to con-
firm Theorem 5.1.17. Theorems 5.4.14, 5.4.15, and 5.4.16 now provide a mathematically
rigorous proof of Theorem 5.1.17, which is restated below.
Theorem 5.4.17 (Kleene). Let S ⊆ℕk. Then S is decidable if and only if S and its comple-
ment ℕk \ S are semi-decidable.

5.4 Recursively enumerable sets and relations
౪
203
Exercises 5.4.
1. Let f : ℕ→ℕbe recursive. Show that the semi-characteristic function of the range
of f , {f (x) : x ∈ℕ}, is partial recursive.
2. Let f : ℕ→ℕbe a recursive bijection. Show that f −1 is recursive.
3. Let A ⊆ℕbe the nonempty range of a partial recursive function. Show that A is
recursively enumerable.
4. Let A ⊆ℕbe recursively enumerable. Show that A is the domain of a partial re-
cursive function.
*5. Let h: ℕk →ℕbe a partial function. Show that if Gh is recursively enumerable,
then h is partial recursive.
*6. Let f : ℕ→ℕbe a recursive function. Show that if f is strictly increasing, then its
range {f (x) : x ∈ℕ} is recursive.
*7. Let f : ℕ→ℕbe recursive, where ran(f ) = {f (x) : x ∈ℕ} is infinite.
(a) For all n ∈ℕ, show that there is an i > n such that (∀j ≤n)(f (j)
̸= f (i)).
(b) For all n ∈ℕ, let i be the least such that i > n and (∀j ≤n)(f (j)
̸= f (i)). Show
that (∀j < i)(f (j)
̸= f (i)).
(c) Define g: ℕ→ℕby
g(n) = the least i ∈ℕsuch that i > n and (∀j < i)(f (j)
̸= f (i)).
Show that g is recursive. Clearly, n < g(n) for all n ∈ℕ.
(d) Define h: ℕ→ℕby h(0) = 0 and h(n + 1) = g(h(n)). Thus, h is recursive.
Show that h(n) < h(n + 1) for all n ∈ℕ. Hence, h is one-to-one and strictly
increasing.
(e) Show that f (h(n))
̸= f (j) for all j < h(n), for each n ∈ℕ.
(f) Show that v: ℕ→ℕdefined by v(n) = f (h(n)) is one-to-one.
(g) Let y ∈ran(f ) and let i ∈ℕbe the least such that f (i) = y. Therefore, (∀j <
i)(f (j)
̸= f (i)). Show that i = h(n) for some n. Now conclude that ran(v) =
ran(f ).
8. Let A ⊆ℕbe an infinite recursive set. Show that A is the range of a strictly increas-
ing recursive function.
9. Let A ⊆ℕbe an infinite recursively enumerable set. Show that there is an infinite
recursive set B such that B ⊆A.
10. Prove Corollary 5.4.7.
*11. Let Q ⊆ℕk+n be recursively enumerable. Prove that the relation
∃i1∃i2 . . . ∃inR( ⃗x, i1, i2, . . . , in),
where ⃗x ∈ℕk, is recursively enumerable.
Exercise Notes: For Exercise 7(c), see Proposition 5.3.47. For Exercise 7(f), if not, then
by (d) there exists an n such that h(n) < i < h(n + 1). Exercise 7 shows that every infi-

204
౪
5 Computability
nite recursively enumerable subset of ℕis the range of a one-to-one recursive function.
For Exercise 9, by Definition 5.4.1 there is a recursive function f : ℕ→ℕsuch that A
is the range of f . Use f to construct a strictly increasing recursive function h such that
the range of h is a subset of A; Exercise 6 (above) implies that the range of h is recur-
sive.

