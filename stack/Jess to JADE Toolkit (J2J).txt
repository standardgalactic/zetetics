Jess to JADE Toolkit (J2J)
A Rule-Based Solution Supporting Intelligent and Adaptive Agents
Master Thesis
Joël Vogt
August 2008
Thesis supervisors:
Prof. Dr. Jacques Pasquier-Rocha
and
Dr. Patrik Fuhrer
Software Engineering Group
Marco Savini
Information Systems Research Group
Software Engineering Group
Department of Informatics
University of Fribourg (Switzerland)

“May fortune favor the foolish.”
Admiral James T. Kirk
“Never send a human to do a machine’s job.”
Agent Smith

Acknowledgements
I shall use this ﬁrst Section of my thesis to convey my profound gratitude to those who
have supported me during this thesis and during my studies.
First my loving family: without your encouragement and patients I would never had the
privilege to study at the University of Fribourg.
I shall continue with my excellent supervisors Dr. Patrik Fuhrer and Marco Savini. They
have greatly helped to deﬁne my thesis and oﬀered most valuable input. I also thank
Professor Dr. Jacques Pasquier and Professor Dr. Andreas Meier for letting me write this
thesis in their research groups. Next is Minh Tuan Guyen at the Software Engineering
Group. He was always open to help and gave valuable assistance. I shall continue with
my fellow colleagues at the Information Systems Research Group, who were ever there to
help when I needed advice and I thank again Professor Dr. Andreas Meier for oﬀering
me an employment in his Research Group.
A special thanks to my father Markus, Daniel Fasel and Darius Zumstein for proof-reading
my thesis. And also many thanks to Andreas Ruppen, the developer of the MediMAS
project. He was always ready to oﬀer help and share his knowledge.
I shall not forget those who, three and a half years ago, have persuaded me to attend
university. I express my thankfulness to Professor Dr. Knut Hinkelmann for his tireless
support during my bachelor thesis. I shall furthermore express my great appreciation
to Sybille Bühler, Professor Sabine Künzi, Professor Dr. Trung Dinh from the Fach-
hochschule Nordwestschweiz and Dr. Serge Reichlin and Dr. Tony Dyson from Medgate.
And of course, last but not least, my utmost thanks to my friends!
ii

Abstract
The motivation for this thesis came with the aim to develop a ﬂexible and extensible
workﬂow automation tool kit for the healthcare domain by combining multi-agent and
rule-based technologies. The rule-based paradigm oﬀers a natural way to codify knowl-
edge and promotes reusability. A multi-agent system provides an extensible and scalable
environment for distributed systems. These technologies combined, provide a ﬂexible,
extensible and scalable distributed system.
The frameworks chosen are the rule-based system Jess and the open source multi-agent
framework JADE. Both are implemented in Java. Jess is a fast rule-based system shell
than can contain large numbers of rules.
Because rules are interpreted, rules can be
updated, deleted and added during run-time. JADE is fully FIPA-standard compliant
and has support for platforms with limited resources, such as mobile devices. Since both
frameworks are written in Java, almost any modern platform is supported.
The tool kit developed for this thesis is called the Jess to JADE (J2J) tool kit. It is not
restricted to process automation but can be applied to variety of applications that decide
to use the rule-based paradigm to codify the decision making of JADE agents.
The J2J tool kit is managed by a single class. Agents that use Jess to reason do not ex-
tend that class, instead they are each service users of their own J2J object. This permits
to add the J2J tool kit to existing JADE multi-agent environments, without “breaking”
the existing class hierarchies.
Furthermore, a generic representation of the JADE domain speciﬁc ontology is created
by the J2J tool kit. This generic ontology representation is decoupled from the logic
to create concrete representation of the ontology, such as Jess templates. Instead, the
mapping to a speciﬁc format is conducted by a given Visitor object. This approach has
the advantage that the domain speciﬁc ontology is not limited to a single application and
it assures interoperability, since the knowledge artifacts of the subsystems are based on
the same semantics.
In addition, the J2J tool kit oﬀers a command line interface to remotely access the Jess
interface of an agent. Through this interface, the rules and the working memory of the
intelligent agent’s Jess instance can be altered and monitored during run time.
Keywords: Multi-Agent Systems, Rule-Based Systems, Jess, JADE, Java, Process Man-
agement
iii

Table of Contents
1
Introduction
1
1.1
Motivation and Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2
Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.3
Organization
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4
Notations and Conventions . . . . . . . . . . . . . . . . . . . . . . . . . .
4
I
Motivation
6
2
Business Process Modeling
7
2.1
From Functional to Process-Oriented Organization . . . . . . . . . . . . .
7
2.2
Business Process Modeling . . . . . . . . . . . . . . . . . . . . . . . . . .
7
2.2.1
Event-Driven Process Chains
. . . . . . . . . . . . . . . . . . . .
8
2.2.2
Activity Diagrams
. . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.2.3
Comparing Event-driven Process Chains and Activity Diagrams .
12
3
Case Study: Hospital and Laboratory
15
3.1
Regular Case
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.2
Physician Calling the Laboratory Assistant . . . . . . . . . . . . . . . . .
17
3.3
Laboratory Assistant Calling Physician . . . . . . . . . . . . . . . . . . .
19
3.4
Laboratory Assistant has Critical Laboratory Results . . . . . . . . . . .
20
II
Background
22
4
Software Agents
23
4.1
What is an Agent? What is an Intelligent Agent? . . . . . . . . . . . . .
24
4.1.1
Properties of an Agent . . . . . . . . . . . . . . . . . . . . . . . .
24
4.1.2
Properties of an Agent Environment
. . . . . . . . . . . . . . . .
24
4.2
Architectures
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
iv

Table of Contents
v
4.2.1
Logic Based Agents Architectures . . . . . . . . . . . . . . . . . .
26
4.2.2
Reactive Agent Architectures
. . . . . . . . . . . . . . . . . . . .
26
4.2.3
Hybrid Agent Architectures . . . . . . . . . . . . . . . . . . . . .
26
4.2.4
BDI Architectures
. . . . . . . . . . . . . . . . . . . . . . . . . .
27
4.3
Communication and Coordination . . . . . . . . . . . . . . . . . . . . . .
27
4.3.1
FIPA Message Speciﬁcations . . . . . . . . . . . . . . . . . . . . .
28
4.3.2
FIPA-Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
4.4
Ontologies in a Multi-Agent Environment
. . . . . . . . . . . . . . . . .
30
4.5
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
4.5.1
Multi-Agent System for Electronic Health Record Management
.
31
4.5.2
Multi-Agent System for Process Automation . . . . . . . . . . . .
31
4.5.3
Multi-Agent System for Sensor Web Management . . . . . . . . .
31
5
JADE: An Agent Framework
33
5.1
The JADE Architecture
. . . . . . . . . . . . . . . . . . . . . . . . . . .
34
5.1.1
Important Platform Management Services
. . . . . . . . . . . . .
34
5.1.2
Administration and Debugging Tools . . . . . . . . . . . . . . . .
35
5.2
Agent Communication Implementation . . . . . . . . . . . . . . . . . . .
36
5.2.1
Sending and Receiving Messages . . . . . . . . . . . . . . . . . . .
36
5.2.2
Implementational Details of the JADE Messaging Service . . . . .
36
5.2.3
Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
5.3
Use of Ontologies in JADE . . . . . . . . . . . . . . . . . . . . . . . . . .
39
5.3.1
Protégé
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
6
Rule-Based Systems
42
6.1
Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
6.2
The Architecture of Rule-Based Systems . . . . . . . . . . . . . . . . . .
44
6.2.1
Inference Engine
. . . . . . . . . . . . . . . . . . . . . . . . . . .
44
6.2.2
Working Memory . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
6.2.3
Rule Base . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
6.2.4
Pattern Matcher
. . . . . . . . . . . . . . . . . . . . . . . . . . .
46
6.2.5
Agenda
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.2.6
Execution Engine . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.3
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.3.1
Rule-Based Expert System in the Medical Domain
. . . . . . . .
47
6.3.2
Workﬂow Automation
. . . . . . . . . . . . . . . . . . . . . . . .
47
6.3.3
Rule-Based System for Monitoring
. . . . . . . . . . . . . . . . .
48
7
The Jess Rule-Based System
49
7.1
Running Jess
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
7.2
The Jess Rule Language . . . . . . . . . . . . . . . . . . . . . . . . . . .
50

Table of Contents
vi
7.3
Working with Java Classes and Objects . . . . . . . . . . . . . . . . . . .
51
7.3.1
Java Objects
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
7.3.2
Java Class Members
. . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4
Working Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4.1
Unordered Facts
. . . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4.2
Shadow Facts . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4.3
Ordered Facts . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7.5
Rules
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7.5.1
Slot Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
7.5.2
Pattern bindings
. . . . . . . . . . . . . . . . . . . . . . . . . . .
55
7.5.3
Conditional Elements . . . . . . . . . . . . . . . . . . . . . . . . .
55
III Implementation
58
8
Jess and JADE Integration: The Matrix Example
59
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
8.1.1
Agent Organization . . . . . . . . . . . . . . . . . . . . . . . . . .
61
8.1.2
Agents Environment
. . . . . . . . . . . . . . . . . . . . . . . . .
61
8.2
The Matrix Workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
8.2.1
State of a Matrix Agent in Jess . . . . . . . . . . . . . . . . . . .
63
8.2.2
Implementation of The Matrix Workﬂow With Jess . . . . . . . .
64
8.3
Agents Communication . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
8.3.1
Agent Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
8.3.2
The Matrix Ontology . . . . . . . . . . . . . . . . . . . . . . . . .
73
8.3.3
Using the Communication Conﬁguration Factory
. . . . . . . . .
75
8.4
Agent Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
8.4.1
Internal Behaviors
. . . . . . . . . . . . . . . . . . . . . . . . . .
77
8.4.2
Communicational Behaviors . . . . . . . . . . . . . . . . . . . . .
77
8.5
Software Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
8.5.1
TheMatrixAgent
. . . . . . . . . . . . . . . . . . . . . . . . . . .
80
8.5.2
Slave Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
8.5.3
Master Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
8.5.4
Jess Administration Agent . . . . . . . . . . . . . . . . . . . . . .
83
9
Remote Jess Administration
84
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
9.2
Using the Jess Administration Agent . . . . . . . . . . . . . . . . . . . .
84
9.3
Agents Communication . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
9.3.1
Jess Administration Ontology . . . . . . . . . . . . . . . . . . . .
85
9.4
Agent Behaviors and related Classes
. . . . . . . . . . . . . . . . . . . .
86

Table of Contents
vii
9.4.1
Communicational Behaviors . . . . . . . . . . . . . . . . . . . . .
87
9.4.2
Implementation of the Agent Conversations
. . . . . . . . . . . .
87
9.5
Jess Administration Agents
. . . . . . . . . . . . . . . . . . . . . . . . .
92
10 Jess and JADE Integration: The Jess 2 JADE Tool Kit
94
10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
10.2 Agent Communication Conﬁguration . . . . . . . . . . . . . . . . . . . .
95
10.3 Agent Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
10.3.1 Communicational Behaviors . . . . . . . . . . . . . . . . . . . . .
97
10.3.2 Message Templates . . . . . . . . . . . . . . . . . . . . . . . . . .
100
10.4 Software Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
10.4.1 JessableAgent . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
10.5 Jess and JADE Integration Object
. . . . . . . . . . . . . . . . . . . . .
103
10.5.1 Jess Integration
. . . . . . . . . . . . . . . . . . . . . . . . . . .
104
10.5.2 Jess Engine Manager . . . . . . . . . . . . . . . . . . . . . . . . .
105
10.5.3 Jess Output Routing . . . . . . . . . . . . . . . . . . . . . . . . .
106
10.6 Ontology Management . . . . . . . . . . . . . . . . . . . . . . . . . . . .
108
10.6.1 Ontology Tree Manager
. . . . . . . . . . . . . . . . . . . . . . .
110
10.6.2 Ontology Visitors . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
10.6.3 Ontology Dependant Managers
. . . . . . . . . . . . . . . . . . .
116
10.7 Jess Functions for JADE and Function Management . . . . . . . . . . . .
117
10.7.1 Jess Integrated Behaviors
. . . . . . . . . . . . . . . . . . . . . .
121
10.8 A Brief Discussion of an Oracle Agent Without Rule Engine . . . . . . .
125
11 Using the J2J Tool Kit to Add Jess to MediMAS
128
11.1 Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
128
11.2 Creating a Jess Administration Agent
. . . . . . . . . . . . . . . . . . .
129
11.3 Modifying the MediMAS Ontology
. . . . . . . . . . . . . . . . . . . . .
130
11.3.1 Create a Communication Conﬁguration Factory for the MediMAS
ontology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
11.4 Adding Jess Support to MediMAS
. . . . . . . . . . . . . . . . . . . . .
131
11.4.1 Extending JessCNC
. . . . . . . . . . . . . . . . . . . . . . . . .
131
11.4.2 Making the MediMAS Alert Manager Agent Jessable . . . . . . .
131
11.4.3 Creating a Jessable Behavior to Handle the Alert Notiﬁcation
. .
132
11.4.4 Implementing the Alert Notiﬁcation Logic with Jess Rules . . . .
135
11.4.5 Adding a JADE Aware Jess User Function . . . . . . . . . . . . .
136
11.5 Changing the Behavior at Run Time
. . . . . . . . . . . . . . . . . . . .
137
11.5.1 Sending Alerts To the Head of Laboratory . . . . . . . . . . . . .
137
11.5.2 Reacting to Laboratory Results with H5N1 . . . . . . . . . . . . .
137
11.6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
139

Table of Contents
viii
12 Conclusion
140
12.1 Achievements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
140
12.2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
142
IV Appendix
146
A Healthcare Business Processes at the HCF and LCF
147
B Messaging Serivce UML Sequence Diagrams
152
C Installing and Running the Matrix
157
D Algorithms
158
D.1 Creating the JTree of the Ontology . . . . . . . . . . . . . . . . . . . . .
158
D.2 Sorting the Ontology Classes
. . . . . . . . . . . . . . . . . . . . . . . .
159
D.3 Creating the Ontology Composite
. . . . . . . . . . . . . . . . . . . . .
160
E Common Acronyms
162
F
License of the Documentation
164
G Website of the Project
165
H CD-ROM
167
References
169
Referenced Web Ressources
172

List of Figures
2.1
Splits possible with Event-driven Process Chains (EPC) logical connec-
tors [13, p. 33] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3.1
The context in which actors communicate (obtained from [19]) . . . . . .
15
3.2
Layers of the current communication infrastructure (obtained from [19]) .
17
3.3
Physician requests the laboratory analysis results
. . . . . . . . . . . . .
18
3.4
Physician tries to reach the Laboratory Assistant by phone . . . . . . . .
19
3.5
Laboratory assistant tries to reach the physician by phone
. . . . . . . .
20
3.6
The laboratory assistant has critical laboratory results
. . . . . . . . . .
21
4.1
An agent senses information from its environment and acts upon it. Its
action can aﬀect the environment [Woo02, p. 16] . . . . . . . . . . . . . .
24
4.2
Foundation for Intelligent Physical Agents (FIPA) Request Interaction
Protocol (obtained from [8]) . . . . . . . . . . . . . . . . . . . . . . . . .
29
4.3
Ontology-Based Communication Model [5] . . . . . . . . . . . . . . . . .
30
5.1
The Graphical User Interface (GUI) of the Remote Monitoring Agent (RMA) 35
5.2
High-level overview of message delivery with JADE (obtained from [BCG07,
p. 134], red demarcation added) . . . . . . . . . . . . . . . . . . . . . . .
37
5.3
A simple JADE ontology with three additional classes . . . . . . . . . . .
40
5.4
Screenshot of the Protégé ontology editor . . . . . . . . . . . . . . . . . .
41
6.1
The architecture of a typical rule-based system [Hil03, p. 20] . . . . . . .
44
6.2
The Rete network generated for the rules detect-klingon and raise-shields . .
46
8.1
The results of a combat between one Chosen One agent and two Smith
agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
8.2
The multi-agent environment
. . . . . . . . . . . . . . . . . . . . . . . .
61
8.3
Phases in a slave agent’s life . . . . . . . . . . . . . . . . . . . . . . . . .
63
8.4
Initialization Workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . .
64
8.5
Main Workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
ix

List of Figures
x
8.6
Slave agent registration process
. . . . . . . . . . . . . . . . . . . . . . .
70
8.7
Main workﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
8.8
Matrix Ontology
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
8.9
Behaviors to ﬁnd the master agent and conduct a set of setup tasks . . .
77
8.10 CommandMeResponder jessable behavior . . . . . . . . . . . . . . . . . .
80
8.11 Class hierarchy for agents in the Matrix environment . . . . . . . . . . .
81
9.1
Remote Jess administration interface . . . . . . . . . . . . . . . . . . . .
85
9.2
Jess Administration Ontology . . . . . . . . . . . . . . . . . . . . . . . .
86
9.3
"Register Me" and "Update Buﬀer" based on the FIPA-Request-Protocol
89
9.4
Steps performed to create a JTree representation of the ontology used by Jess 91
9.5
Class hierarchy for agents in the Jess Administration environment . . . .
92
10.1 Abstract Factory to create agent communication related objects . . . . .
95
10.2 Classes involved in the message template creation process . . . . . . . . .
101
10.3 Object composition for the message template created by the createProtocol-
InitialisationWithAction method
. . . . . . . . . . . . . . . . . . . . . . . . .
102
10.4 High-level overview of the JADE and Jess integration . . . . . . . . . . .
103
10.5 JessCNC and managers . . . . . . . . . . . . . . . . . . . . . . . . . . . .
104
10.6 JessEngineManager class . . . . . . . . . . . . . . . . . . . . . . . . . . . .
106
10.7 AgentOutputWriter and Strategies
. . . . . . . . . . . . . . . . . . . . . . .
107
10.8 Jess output routing with the AgentOutputWriter
. . . . . . . . . . . . . . .
108
10.9 Composite for the ontology managed by the Ontology Tree Manager . . .
109
10.10Ontology Management Classes . . . . . . . . . . . . . . . . . . . . . . . .
110
10.11A new Observer registering itself with the concrete Subject . . . . . . . .
111
10.12Simple class hierarchy for the sorting example . . . . . . . . . . . . . . .
113
10.13Steps performed to construct a composite structure of the ontology of
Figure 10.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
10.14Ontology Composite Visitor Class Diagram . . . . . . . . . . . . . . . . .
114
10.15A Visitor visiting a ConceptElement subtree . . . . . . . . . . . . . . . . .
115
10.16JADE aware Jess function and Jess Function Manager
. . . . . . . . . .
118
10.17Jessable behavior class hierarchy used for the Matrix
. . . . . . . . . . .
121
10.18Beginning and end of prepareResponse . . . . . . . . . . . . . . . . . . . .
124
10.19Object interaction for command-agent
. . . . . . . . . . . . . . . . . . . .
125
10.20Object interaction for return-fact-to-current-behaviour . . . . . . . . . . . . .
125
11.1 The JessMedicalAdmin class . . . . . . . . . . . . . . . . . . . . . . . . . .
129
11.2 Extract of the MediMAS ontology . . . . . . . . . . . . . . . . . . . . . .
130
11.3 The class hierarchy of the JessableAlertManagerAgent class
. . . . . . . . .
132
11.4 The class hierarchy of the AgentHandleAlertActionsBehaviour class . . . . . .
133
11.5 The class hierarchy of the ChangeAlertCheckTime class
. . . . . . . . . . .
136

List of Figures
xi
12.1 Eliminating the single point of failure by providing redundancy with backup
agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
B.1 Step 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
B.2 Step 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
154
B.3 Step 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
155
B.4 Step 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
G.1 Screenshot of the project’s oﬃcial web-page
. . . . . . . . . . . . . . . .
166
H.1 Tree view of the content of the CD-ROM . . . . . . . . . . . . . . . . . .
168
H.2 The CD-ROM of this project
. . . . . . . . . . . . . . . . . . . . . . . .
168

List of Tables
2.1
Elements of the EPC notation [SW01, p. 11–14] . . . . . . . . . . . . . .
9
2.2
Elements of the Uniﬁed Modeling Language (UML) Activity Diagram no-
tation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
2.3
Mapping EPC elements to UML 2.0 Activity Diagram elements [KL06, p. 5] 13
2.4
Additional EPC process elements to UML 2.0 Activity Diagram elements [KL06,
p. 6] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2.5
Mapping EPC control ﬂow to UML 2.0 Activity Diagram elements [KL06,
p. 6] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2.6
Mapping EPC splits and joins UML 2.0 Activity Diagram elements [KL06,
p. 7] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
10.1 Steps performed by the buildSimpleTree of Code extract D.2 for the class
hierarchy in Figure 10.12 . . . . . . . . . . . . . . . . . . . . . . . . . . .
113
xii

List of Code extracts
5.1
Composing and sending a message . . . . . . . . . . . . . . . . . . . . . .
36
5.2
Receiving a message
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
5.3
ExampleOntology class source code
. . . . . . . . . . . . . . . . . . . . . .
39
5.4
Sell class source code . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
6.1
Deﬁning a template and asserting a fact
. . . . . . . . . . . . . . . . . .
45
6.2
Writing rules
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
7.1
Using the Jess Java API . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
8.1
Train new agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
64
8.2
Assign opponents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
8.3
Check agent’s health . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
8.4
Remove opponent relations for killed agent . . . . . . . . . . . . . . . . .
65
8.5
Add new key to the working memory . . . . . . . . . . . . . . . . . . . .
66
8.6
Wait . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
8.7
Die . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
8.8
Assert an attack fact and select new attacker . . . . . . . . . . . . . . . .
68
8.9
Attack! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
8.10 Reduce opponents life . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
8.11 Opponent killed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
8.12 Opponent still alive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
8.13 Content of a FindMe message . . . . . . . . . . . . . . . . . . . . . . . . .
71
8.14 Content of a CommandMe message . . . . . . . . . . . . . . . . . . . . . .
73
8.15 Extending the CommunicationConﬁgurationFactory to set the ontology, content
language and codec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
8.16 Creating a request performative message for the FIPA-Request-Protocol .
76
8.17 Creating an Initiator behavior by extending RequestInitiatorTemplate . . . .
79
8.18 Creating a Responder behavior by extending RequestResponderTemplate . .
79
8.19 Implementation of the CommandMe responder class . . . . . . . . . . . . .
81
8.20 Setup method of the TheMatrixAgent class
. . . . . . . . . . . . . . . . . .
82
8.21 Setup of a slave agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
xiii

List of Code extracts
xiv
8.22 Setup the Oracle agent . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
9.1
Adding a JadeMessageOutputStrategy
. . . . . . . . . . . . . . . . . . . . .
88
9.2
Updating a Jess Administration agent’s Jess output console . . . . . . . .
88
9.4
Implementation of the ExecuteJessCommandInitiator behavior . . . . . . . .
89
9.3
Implementation of the ExecuteJessCommandResponder behavior
. . . . . .
89
9.5
Parenthesized representation of the ontology . . . . . . . . . . . . . . . .
90
9.6
A simple tree that is parsed according to Figures 9.4(a) to 9.4(h)
. . . .
91
10.1 createFIPARequestMessage instance method
. . . . . . . . . . . . . . . . .
97
10.2 createAgentConﬁgObject instance method of the abstract class Communication-
ConﬁgurationFactory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
10.3 RequestInitiatorTemplate
. . . . . . . . . . . . . . . . . . . . . . . . . .
98
10.4 RequestResponderTemplate
. . . . . . . . . . . . . . . . . . . . . . . . .
100
10.5 createProtocolInitialisationWithAction instance method
. . . . . . . . . . . . .
101
10.6 Initializing JessCNC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
105
10.7 Jess template for FindMe
. . . . . . . . . . . . . . . . . . . . . . . . . . .
115
10.8 treeChanged instance method of the Jade2JessVisitor class . . . . . . . . . .
117
10.9 Registering JADE aware Jess functions . . . . . . . . . . . . . . . . . . .
117
10.10Algorithm for the command-agent Jess user function
. . . . . . . . . . . .
120
10.11Algorithm for the return-fact-to-current-behaviour Jess user function . . . . .
121
10.12FIPA-Request abstract Responder behavior with Jess support
. . . . . .
123
10.13ChangeMeResponder without Jess rule-engine
. . . . . . . . . . . . . . . .
126
11.1 The handleAlert method of the AgentHandleAlertActionsBehaviour class . . . .
129
11.2 The instructions to set the address of the master and load the behaviors
needed to communicate with the master agent . . . . . . . . . . . . . . .
130
11.3 Extending JessCNC to add a new JADE aware Jess user function . . . . .
131
11.4 Making the AlertManagerAgent Jessable . . . . . . . . . . . . . . . . . . . .
132
11.5 Conﬁguring the OntologyTreeManager class for the MediMAS ontology . . .
132
11.6 Making the AlertManagerAgent Jessable . . . . . . . . . . . . . . . . . . . .
133
11.7 The call method of the ChangeAlertCheckTime class
. . . . . . . . . . . . .
137
11.8 Handle urgent and critical cases . . . . . . . . . . . . . . . . . . . . . . .
137
11.9 Notify the Swiss Ministry of Health if a H5N1 case appears . . . . . . . .
138
11.10A test fact for the h5n1-found rule of Code extract 11.9 . . . . . . . . . . .
138
11.11The SendEmail class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
138
D.1 Algorithm to create a JTree that contains the ontology . . . . . . . . . .
158
D.2 Sorting the classes of the ontology . . . . . . . . . . . . . . . . . . . . . .
160
D.3 Algorithm that creates the composite representing the ontology
. . . . .
161

1
Introduction
1.1
Motivation and Goals . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2
Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.3
Organization
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.4
Notations and Conventions . . . . . . . . . . . . . . . . . . . . .
4
E-health has become a driving factor in the healthcare sector. It enables the automation
of clinical processes and increases eﬃciency. This is critical in order to fulﬁl the medical
requirements of our society. Wireless mobile technology in particular can be rolled out
relatively cheaply and quickly. E-health is not simply about digitalizing existing pro-
cesses but to discover new ways to increase eﬃciency and eﬀectiveness of the healthcare
system. Thus it aims at driving down cost, reducing complexity and improving service for
patients [3]. E-health processes seldom reside within a single organizational unit. Rather,
they span several organizations, are partly automated and include diﬀerent actors such
as patients, nurses, laboratory personnel or physicians. The ICT infrastructure that sup-
ports these processes is likely to be heterogeneous. Furthermore, processes in the health-
care domain are dynamic in order to meet the changing needs of the patients [ASC+03, p.
83–84]. A number of solutions have been proposed to support processes in diﬀerent areas
of the healthcare sector. [HS06] present a rule-based approach to provide more ﬂexible
information system infrastructure and thus make business processes more agile. They
explain that business requirements for health assurances change rapidly. They argue that
an approach to increase the ﬂexibility of business process is the automation of certain
tasks based on business rules. By specifying the processes in a business-rule layer that
accesses the ICT infrastructure required for the given process through a web-service layer,
changes in the business environment can be met more eﬃciently. Another interesting ap-
proach is presented by [PJDH03]. They have developed a framework to support patient
scheduling processes in a hospital environment. The authors explain that these processes
are very dynamic and require an solution that can quickly adapt to the patients’ need.
They propose a competitive, multi-agent environment to support the entire treatment
process of a patient. Every patient and relevant resource in the hospital is represented
by an agent. The patents’ agents compete for the scarce resources and negotiate to ﬁnd
an overall optimal solution.
A third example that is the initiator of this thesis, is MediMAS. MediMAS stands for
Medical Multi-Agent Systems and is being developed by the Software Engineering Re-
search Group at the University of Fribourg, Switzerland. The project was initiated to
1

1.1.
Motivation and Goals
2
improve laboratory results exchange processes between the Laboratoire Cantonal de Fri-
bourg and the Hôpital Cantonal de Fribourg by adding a multi-agent system layer on
top of the existing legacy ICT infrastructure. Each actor taking part in the process (i.e.
physician, laboratory assistant) is represented by a software agent. MediMAS is being
further developed through students projects at bachelor and master level [18]. This mas-
ter thesis developed a framework for MediMAS to integrate JADE and Jess to make
MediMAS more ﬂexible and adaptive to changing process requirements.
1.1 Motivation and Goals
While a multi-agent environment developed with JADE provides a scalable, fail-safe
distributed environment, it does not provide the means to change an agent behavior at
run-time. Rather, if an agent’s business logic needs to be changed, the agent has to be
stopped, the new classes loaded and the agent restarted. This limits its suitability to
support ﬂexible processes that require high availability, such as the processes supported
by MediMAS. The two following examples shall clarify this:
1. The head of the laboratory has decided that she wants to be notiﬁed of every result
that is classiﬁed as critical and urgent.
2. A new strain of H5N1 was discovered in Switzerland. The Swiss Ministry of Health
requires immediate notiﬁcation if this strain is found in a human.
These seemingly simple requirements would make it necessary to take down MediMAS
for the update. While the ﬁrst requirement is probably not that urgent and could be
performed during a night shift, the second requirement would likely require to take the
system down while it is being actively used. A solution to this problem is to separate the
business logic execution from the other parts of the system, i.e. underlying multi-agent
framework, and have the source code that represents the business logic interpreted and
executed directly. Additionally, it would also be advantageous if the activities could be
written in declarative way, instead of describing the process with procedural instructions,
and let the rule-based system decide on the order in which the activities are executed.
Such an activity for for the H5N1 example could be: "If there is a laboratory result with
H5N1 then inform the Swiss Ministry of Health". If a laboratory result is submitted
to the system that contains information on a H5N1 case, this activity is performed. if-
then statements are the typical characteristic of rule-based systems. As mentioned in
the introduction, a rule-based approach is indeed suitable to control processes. The rule-
based system shell chosen for this tool kit is Jess. Jess is fully integrated in Java and
can thus interact seamlessly with JADE. The Jess execution engine is an interpreter, the
source code can be changed during run-time.
This leads to the goals of this thesis:
• Reﬁnement of the study and of the description of the application domain and its
diﬀerent workﬂows.
This part has to be cleanly and extensively described in a
standard way, under the supervision of Marco Savini who is a member of Prof.
Andreas Meier’s group.
• Extension of the MediMAS application by integrating JADE agents and the Jess
rule engine: i.e. develop a richer version of the existing application, MediMAS 2.0.

1.2.
Schedule
3
This would allow users to declaratively and dynamically conﬁgure the behaviors of
the agents.
These objectives were accomplished. The tool kit developed is generic and can be used
for any JADE environment, not only MediMAS. In fact, it was developed independently
of MediMAS with the prototype called "the Matrix".
1.2 Schedule
October - December 2007 (approx. 100h of work):
• Reading of the bachelor thesis report of [Rup07].
• Study and lecture of following topics: agents, ontology, rule engines,. . .
• First contact with JADE, installation and conﬁguration of the working environment,
ﬁrst tests.
• Installation of the MediMAS application and playing with it.
• Study of the application domain of the laboratory/hospital, reformulating/docu-
menting the various workﬂows (cf. Marco Savini).
• Documentation of the ﬁrst theoretical part of the master thesis (agents, ontology,
business rules, rule engines,. . . ) and of the application domain description (labora-
tory/hospital).
January – February 2008 (approx. 290h of work):
• End of the documentation of the ﬁrst theoretical part of the master thesis and of
the application domain description.
• First integration tests JADE/Jess.
• Integration of Jess with one of the MediMAS agents.
• Thinking about the integration and description of the business rules in MediMAS,
and integration with the "simulator".
• Roughly deﬁne the software architecture of MediMAS 2.0.
March – Avril 2008 (approx. 290h of work):
• Refactoring of the MediMAS application.
• Developing MediMAS 2.0: deployment of Jess integration, interaction with the
"simulator".
• Tests, debugging, and technical documentation (javadoc, UML diagrams . . . ).
• Drafting the structure of the ﬁnal report.

1.3.
Organization
4
May - August 2008 (approx. 220h of work):
• Writing of the ﬁnal documentation.
• Final presentation to the research group and demo of the application.
1.3 Organization
This thesis is structured as follows:
• Chapter 1 gives an introduction to this thesis and poses the motivation and goals
that initiated this project.
• Part I focuses on business process modeling and dicusses the case study that lead
to the creation of MediMAS. It contains the following chapters:
– Chapter 2 discusses and compares UML Acitivity Diagrams and Event-driven
Process Chains used to model business processes and workﬂows.
– Chapter 3 presents the case study that led to the creation of MediMAS.
• Part II elaborates on the theoretical foundations needed to develop the Jess and
JADE integraton.
– Chapter 4 discusses software agents in general.
– Chapter 5 introduces the multi-agent framework JADE, which is used for this
thesis.
– Chapter 6 provides an introduction to rule-based systems.
– Chapter 7 elaborates on the rule-based system shell Jess. It is used in this
thesis to handle the business logic on an agent.
• Part III discusses in details the integration approch chosen in this thesis.
It is
subdivided in:
– Chapter 10 presents "the Matrix". It is a prototype developed to demonstrate
how the Jess and JADE integration tool kit developed can be used.
– Chapter 9 comments on the remote Jess Administration module of the Jess
and JADE integration tool kit.
– Chapter 10 delves into the details of the integration tool kit.
– Chapter 11 explains the application of the Jess and JADE integration tool kit
for MediMAS.
– Chapter 12 closes this thesis with a conclusion.
1.4 Notations and Conventions
• Formatting conventions:
– Bold and italic are used for emphasis and to signify the ﬁrst use of a term.
– SansSerif is used for web addresses.
– Code is used in all Java code and generally for anything that would be typed
literally when programming, including keywords, constants, method names,
and variables, class names, and interface names.

1.4.
Notations and Conventions
5
• The present report is divided in Chapters. Chapters are broken down into Sec-
tions. Where necessary, sections are further broken down into Subsections, and
Subsections may contain some Paragraphs.
• Figures, Tables and Code extracts are numbered inside a Chapter. For example, a
reference to Figure j of Chapter i will be noted Figure i.j.
• As far as gender is concerned, I systematically select the feminine when possible.
• Source code is displayed as follows:
1 CommunicationConfigFactory
cf = JessCommunication . getInstance ( ) ;
cf . setAgent ( this . myAgent ) ;
3 RegisterMe rm = new RegisterMe ( ) ;

Part I
Motivation
6

2
Business Process Modeling
2.1
From Functional to Process-Oriented Organization . . . . . .
7
2.2
Business Process Modeling . . . . . . . . . . . . . . . . . . . . .
7
2.2.1
Event-Driven Process Chains . . . . . . . . . . . . . . . . . . .
8
2.2.2
Activity Diagrams
. . . . . . . . . . . . . . . . . . . . . . . . .
10
2.2.3
Comparing Event-driven Process Chains and Activity Diagrams
12
2.1 From Functional to Process-Oriented
Organization
Changes in the economical situation have forced companies to restructure their organiza-
tion from a functional to a process orientation. Before this paradigm shift, organizations
focused on the execution and improvement of individual functions. Services and products
however, are rarely created by a single functional unit. Thus business processes cut across
several functional business units and will likely also include partners that are outside of an
organization. The coordination between diﬀerent functional units is often costly [All05,
p. 12–14],[BKR03, p. 2]. The use of Information and Communications Technology (ICT)
helped to increase process cycle time but they could not eliminate the structural issues
caused by a company’s internal structure [BKR03, p. 2]. To reduce existing interfaces,
organizations started to implement cross-functional processes by changing the organiza-
tional structure from a functional oriented organization to a process oriented one [All05,
p. 12–14],[BKR03, p. 2].
Rummler and Brache deﬁne "business process" as follows: "A business process is a series
of steps designed to produce a product or service. Some processes [...] may be contained
wholly within a function. However, most processes [...] are cross-functional, spanning the
"while space" between the boxes on the organization chart."[RB90, p. 45].
2.2 Business Process Modeling
Several business process modeling languages have been developed. Common examples
are Petri-Nets, UML Activity Diagram, data ﬂow diagrams and EPC [RvdAtHW06, p.
7

2.2.
Business Process Modeling
8
2]. It was opted to use two process modeling languages in this thesis: EPC and Activity
Diagram.
EPC have found wide acceptance in the industry to model business processes in orga-
nizations [NR02, p. 64],[vdA99, p. 1], [Krc04, p. 122]. EPC are targeted at business
people. They are easy to understand and to use. EPC serve to describe the business
logic of processes and the requirements of a business process but are not necessarily used
for precise, formal speciﬁcations [vdA99, p. 4]. Thus readers not familiar with ICT will
likely be able to interpret EPC diagrams than the more IT-oriented Activity Diagram.
The Activity Diagram notation is a high-level tool to model the sequence of steps that
an information system will execute to achieve a goal. The Activity Diagram modeling
language is part of UML, which has established itself as the de-facto standard for software
modeling and design [RvdAtHW06, p. 1],[Kec06, p. 18].
Both modeling languages are described in the following Sections.
2.2.1 Event-Driven Process Chains
Figure 2.1: Splits possible with EPC logical connectors [13, p. 33]
The EPC notation has been developed by Scheer, Keller and Nüttgens and is part of the
Architecture of Integrated Information System (ARIS) framework. The ARIS framework
integrates diﬀerent views of an organization. It is centered around business processes
to provide a coherent and holistic model of an organization
[SW01, p. 6]. The EPC
notation contains the elements shown in Table 2.1:
Element
Description
Functions (i.e. activities or process steps) that take an input state
and transform it into one or more output states.
A function is
depicted as a rounded rectangle.
Events describe the occurrence of a condition. They are pre- and/or
post conditions of functions. An event is depicted as a hexagon.

2.2.
Business Process Modeling
9
Logical connectors in EPC are used to model non-linear process
paths.
They connect functions and events.
The EPC notation
oﬀers the following logical connectors:
AND: Lets a process execute tasks in parallel. Is is depicted with
∧.
OR: Chooses between one or more alternatives. It is depicted with
∨.
XOR: Chooses either one of two possibilities. It is depicted with
⊗(or simply XOR).
EPC supports the splits and joins shown in Figure 2.1. As shown
in Figure 2.1, the connectors OR and XOR cannot be preceeded
directly by an event. This is due to the fact that events do not
have decisional competencies. Hence, it cannot be decided which
path to follow. The diﬀerent process paths after a split can, but
not have to, be rejoined. If they are, the join logical connector has
to be of the same type as the split logical connector [13, p. 35].
Control ﬂow elements connect elements of the types stated above
to create a chronological-logical sequence of functions and events.
A control ﬂow element is depicted as a dashed arrow.
An Organizational unit element describes an organization or person
in an organization.
A Information object element describes an object of the real world.
A Information ﬂow element describes the interaction type with
data (i.e. read, write, update).
An Association element associates resources to organizational
units.
A Process path element sets a pointer to another process.
Table 2.1: Elements of the EPC notation [SW01, p. 11–14]
Critisism
The EPC speciﬁcations have been criticized for their lack of proper semantics and syn-
tax, hence resulting in possibly ambiguous process descriptions. This is unfortunate, since
business processes are at least partly embedded in information systems that demand the
use of formalism to run the modeled business processes [NR02],[vdA99]. Diﬀerent ap-
proaches to resolve this issue have been proposed.
[vdA99] suggests to map EPC to
Petri-Nets (due to the nature of Petri-Nets, the OR ∨connector has to be omitted).
Petri-Net notation is based on well deﬁned mathematical foundations and is provided
with a large set of analysis tools.
[NR02] argue that mapping EPC to Petri-Nets only works when accepting certain restric-

2.2.
Business Process Modeling
10
tions. Thus the original EPC may not be fully reproduced with such an approach. In
their approach, they have therefore deﬁned syntax and semantics for the EPC modeling
language.
The issues surrounding the formalism of EPC will not be discussed any further. It would
go beyond the scope of this thesis. Additionally, the technical part of this thesis will use
Activity Diagram. Activity Diagram have precise semantics [Kec06, p. 16].
2.2.2 Activity Diagrams
UML is being continuously developed. The last major update was from UML version
1.5 to version 2.0 in 2005. Several diagrams were updated. For example the concepts on
which Activity Diagram are based were completely revised [Kec06, p. 17–19].
Activity Diagrams are used to model processes at diﬀerent stages in a software project.
In the analysis and deﬁnition phase, they serve as a tool to model and document business
processes. During the design phase, they are used to model internal system processes,
which is their main area of use. These processes then are implemented during the imple-
mentation phase [Kec06, p. 216].
An Activity Diagram can contain three types of ActivityNodes:
ExecutableNode: An ExecutableNode is a node that can conduct a task, for example
an Action.
ObjectNode: An ObjectNode can store data in an Activity Diagram, for example a
Datastore.
ControlNode: A ControlNode coordinates the control ﬂow between nodes in an Activity.
Examples are start and stop nodes or logical connectors.
ActivityEdges are directed edges that connect ActivityNodes in sequential order.
An
Activity starts with an InitialNode and terminates with a FinalNode. An Activity may
contain several InitialNodes and FinalNodes [Kec06, p. 250–251]. The Activity Diagram
modeling language is very expressive. A comprehensive discussion of every element would
go beyond the scope of this thesis. The rest of this Section describes the elements that
are of relevance for this thesis.
Element
Description
An Action is an ExecutableNode.
It is a function or task that
represents the smallest unit of execution in the given model and
will not be subdivided further. Most of the remaining elements
in an Activity serve for creating constructs such as sequences of
Actions or group or structure actions.
Actions can be provided
with LocalPreconditions/Postconditions that have to be true prior
or after the execution [Kec06, p. 217].
A ControlFlow is a directed edge that connects ActivityNodes. It
represents the order in which ActivityNodes are executed [Kec06,
p. 218].
An ActivityPartition (swim lanes) associates ActivityNodes with a
speciﬁc resource (i.e. actors) [Kec06, p. 219–220].

2.2.
Business Process Modeling
11
An ObjectNode represents an object. Objects are created and con-
sumed by Actions. The ObjectFlow transports an object from an
Action to another. Objects are denoted as squares. Alternatively,
the object can be depicted using the pin notation. The state of the
object may be added in square brackets.
Signal sending and receiving is used for asynchronous communi-
cation. Signals are sent by a SendSignalAction node, which is a
type of Action node that sends messages asynchronously. Signals
are received by AcceptEventAction node, which is a type of Action
node that waits for signals. A SendSignalAction node has exactly
one AcceptEventAction associated to it. The third type of asyn-
chronous signals supported by UML are TimeEvents: A signal is
sent at given time intervals [Kec06, p. 235].
The starting point of control ﬂow within an Activity is the Ini-
tialNode. An Activity may contain two types of termination nodes:
An ActivityFinalNode terminates the Activity when it is reached,
a FlowFinalNode only ends its control ﬂow [Kec06, p. 250–251].
A DecisionNode splits one incoming control ﬂow in several disjunct
alternatives (i.e. XOR). Each outgoing control ﬂow has a guard
associated to it (in square bracket) that deﬁnes the condition that
must be met for it to be selected [Kec06, p. 252–253].
A MergeNode merges several incoming control ﬂows to a single
control ﬂow. If a MergeNode is directly followed by another De-
cisionNode, both notation elements can be depicted as a single
element [Kec06, p. 253].
A ForkNode splits a control ﬂow in several parallel control ﬂows.
Control ﬂows can be synchronized again with the JoinNode [Kec06,
p. 258].
Table 2.2: Elements of the UML Activity Diagram notation
Critisism
[RvdAtHW06] have analyzed the UML 2.0 Activity Diagram notation in order to evaluate
their strengths and weaknesses as a language for business process modeling. Their eval-

2.2.
Business Process Modeling
12
uation is based on the Workﬂow Patterns framework (see [17] for more details). In their
paper they conclude that the Activity Diagram modeling language oﬀers comprehensive
support for control ﬂow and data perspective (creating and using data, interaction with
data, etc. [RvdAtHW06, p. 4]). Its support for organizational or resource related aspects
however is limited [RvdAtHW06, p. 8].
2.2.3 Comparing Event-driven Process Chains and Activity
Diagrams
Business people tend view information systems from a diﬀerent perspective than Infor-
mation Technology (IT) people. They are more interested in high-level description of
cross-functional and cross organizational processes. Their generated value, costs, changes
to the organization, etc. IT people on the other hand tend to view business processes
from a more formal and implementation focused perspective. As mentioned in Chap-
ter 2.2, this may also have an inﬂuence on the choice of the business process modeling
language. To create a bridge between the worlds, [KL06] developed a “UML 2 proﬁle
for EPCs based on a 1 - 1 mapping with UML 2 Activity Diagrams” [KL06, p. 1]. The
following tables contain the mappings between EPC and Activity Diagram identiﬁed by
[KL06]. Only those of interest for this thesis are given.
EPC Element
EPC Notation
UML
2
Base
Class
UML Profile
Elementary Func-
tion
Action
Event
Control Flow
Start Event
Initial Node

2.2.
Business Process Modeling
13
End Event
Final Node
Table 2.3: Mapping EPC elements to UML 2.0 Activity Diagram elements [KL06, p. 5]
EPC Element
EPC Notation
UML
2
Base
Class
UML Profile
Organization
Unit
Activity Partition
Table 2.4: Additional EPC process elements to UML 2.0 Activity Diagram ele-
ments [KL06, p. 6]
EPC Element
EPC Notation
UML
2
Base
Class
UML Profile
Organization ﬂow
control
ActivityPartition
Table 2.5: Mapping EPC control ﬂow to UML 2.0 Activity Diagram elements [KL06, p.
6]
EPC Element
EPC Notation
UML 2 Base Class
UML Profile
AND
ForkNode

2.2.
Business Process Modeling
14
AND
JoinNode
< < e . F u n c t i o n > >
A
X
Y
OR
MergeNode
OR
ForkNode with guards
XOR
DecisionNode
with
guards
XOR
MergeNode
Table 2.6: Mapping EPC splits and joins UML 2.0 Activity Diagram elements [KL06, p.
7]

3
Case Study: Hospital and Laboratory
3.1
Regular Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.2
Physician Calling the Laboratory Assistant . . . . . . . . . . .
17
3.3
Laboratory Assistant Calling Physician
. . . . . . . . . . . . .
19
3.4
Laboratory Assistant has Critical Laboratory Results
. . . .
20
The LCF (the French acronym for Laboratoire Cantonal de Fribourg) is commissioned
by the HCF (the French acronym for Hôpital Cantonal de Fribourg) to run analyses on
certain types of samples submitted by a physician from the cantonal hospital of Fribourg.
The cantonal laboratory of Fribourg consists of several departments such as hematology,
chemistry and microbiology.
Once the analysis results are available, they are communi-
Figure 3.1: The context in which actors communicate (obtained from [19])
cated to the physician who made the request [Rup07, p. 33]. Each department conducts
15

16
and communicates their analyses independently. The current organization of the cantonal
laboratory of Fribourg is shown in Figure 3.1 [Rup07, p. 33]. [Rup07, p. 34] identiﬁed
four stakeholders directly or indirectly involved in the process: (i) the physician, (ii) the
laboratory assistant, (iii) the head of laboratory (iv) and the patient.
They use the following communication patterns:
• physician →patient: The physician informs the patient of his / her disease state.
• laboratory assistant →physician: The laboratory assistant communicates the
laboratory results to the physician.
• physician →laboratory assistant: The physician makes a request to the labo-
ratory assistant.
• ∗→head of laboratory →∗: The head of laboratory is informed of any anoma-
lies.
• laboratory assistant →laboratory assistant: Laboratory assistants commu-
nicate internally.
Obviously other actors are involved in running a hospital or a laboratory. They are,
however, not of interest in the (to be) examined context and are, therefore, not considered.
[Rup07, p. 34] notes that the system shown in Figure 3.1 can be viewed as a distributed
system. The actors can communicate using (i) an information system and (ii) the phone,
thus synchronization of the communication ﬂow between diﬀerent stakeholders cannot
be guaranteed. The shared information of interest in this context is the analysis results
from the laboratory. [Rup07, p. 34] explains that the system, in its current state, cannot
guarantee information conﬁdentiality, integrity and availability. This is due to the fact
that stakeholders may choose to communicate information over the phone. Under normal
circumstances, physician and laboratory assistants exchange laboratory results over the
medical legacy application WinDMLAB [2]. In this case, transactions are logged and data
integrity and security is guaranteed by the application. This, however, is not the case
if actors decide to transmit information verbally over the phone. Reasons for doing so
include that the physician cannot ﬁnd the information she needs in the system or does, for
some reason, not wish to use WinDMLAB. The phone is also used when the laboratory
assistant realizes that the laboratory results (or parts of them) just obtained are critical
and must immediately be brought to the physician’s attention. Simply submitting the
information in WinDMLAB will not guarantee the delivery in time.
Communication
of laboratory analysis over the phone is error-prone: Besides the ideal case, in which
the analysis results are communicated correctly the ﬁrst time, the least worrying case
is that a physician receives the laboratory results more than once. But, in the worst
case, one cannot exclude that the information will never reach the physician. Because
communication over the phone is not logged, it is impossible to determine, at a later
point, when and where the information was lost or modiﬁed. In the medical domain this
could have fatal consequences. Thus it is this communication channel that holds the most
potential for improvement.
Figure 3.2 depicts the communication platform currently used to store and transmit the
laboratory results between the diﬀerent stakeholders. As indicated above, the communi-
cation system consists of two layers: the phone infrastructure layer and the information
system layer. The information system layer is divided in two sub layers: the ICT infras-
tructure and WinDMLAB. The phone infrastructure is placed at the highest layer. The
mindful reader might have noted that the patient, while an important stakeholder, does

3.1.
Regular Case
17
Figure 3.2: Layers of the current communication infrastructure (obtained from [19])
not have any direct interaction with the communication platform and hence fully depends
on the physician to inform her or him of the laboratory results. The rest of this Chapter
will elaborate on four diﬀerent use cases. The business processes in the remaining of this
Chapter are viewed from the business perspective and independent of the implementa-
tion. Therefore, the EPC modeling language is used with two slight adoptions for the
sake of clarity: swim lanes are used instead of organizational unit elements and each
step is marked with a letter to which will be referred to in the text. The UML Activity
Diagrams of these business processes can be found in Appendix A.
3.1 Regular Case
This workﬂow describes the procedure normally followed by physicians and laboratory
assistants to exchange data. The workﬂow is depicted in Figure 3.3. The following steps
are executed: A physician needs to lookup the patient’s laboratory results and medical
record. a) She uses WinDMLAB to access the information she needs. If the information is
available, b) she studies the laboratory results and c) treats the patient. If the laboratory
results are not yet in the system d) she has to decide whether or not (she wants) to try
to reach the laboratory assistant by phone again. e) If she has tried too many times,
she tries to call the laboratory assistant (Section 3.2), f) Otherwise, she waits for a given
time period and tries again to access the data using WinDMLAB.
3.2 Physician Calling the Laboratory Assistant
This workﬂow is followed either when the physician unsuccessfully tried (several times)
to access the laboratory results on WinDMLAB or when the physician simply prefers to
use the phone. The reader notes that this process, shown in Figure 3.4, is already more

3.2.
Physician Calling the Laboratory Assistant
18
Figure 3.3: Physician requests the laboratory analysis results
complex than the normal case described in Section 3.1. Based on the availability of the
stakeholders, the physician must decide on who to contact.
This speciﬁc case might lead to a second speciﬁc case [Rup07, p. 35–36]. Additionally,
the stakeholders do not communicate via WinDMLAB but over the phone. Hence the
communication between the peers is not logged.
If this case occurs, the physician does the following: a) She tries to call the laboratory
assistant. b) If the laboratory assistant is not available (1% probability [Rup07, p. 36])
and she has already tried to reach him for more than three times, she calls the head of
laboratory. c) If the head of laboratory is available, the physician is given the results.
If the head of laboratory is not available, d) she has no other option but to wait for a
given time and a) start the process over again. There are no security checks to assure
that the physician will get the laboratory results. If both the head of laboratory and
the laboratory assistant are not reachable, this workﬂow has no guaranteed end (i.e. in
theory might loop indeﬁnitely). This could have potentially fatal consequences [Rup07,
p. 36]. d) If the laboratory assistant is not available (1% probability) and the physician
has tried less than three times, she waits a certain time period and a) tries again. If
the laboratory assistant is available (99% probability [Rup07, p. 36]), e) she asks for

3.3.
Laboratory Assistant Calling Physician
19
Figure 3.4: Physician tries to reach the Laboratory Assistant by phone
the laboratory results. f) The laboratory assistant gives her the current state of the
results. g) If she gets the results, she treats the patient, h) otherwise, speciﬁc case two is
activated, described in Section 3.3.
3.3 Laboratory Assistant Calling Physician
This workﬂow, depicted in Figure 3.5, applies to the situation where the physician could
reach the laboratory assistant by phone but the laboratory did not, at that time, have
the laboratory results ready and promised to call back once the analysis is complete.
The reader will notice that the ﬁrst part of the workﬂow uses the same pattern as the
former process, discussed in Section 3.2. But with the roles inverted: It is the laboratory
assistant who tries to contact the physician once the analysis is complete. In this case,
the following happens: a) The laboratory assistant tries to call the physician. If she is
not available, d) she waits for a given time period and tries again to reach the physician.
If she tried to reach her for more than three times and still cannot reach her, b) she will
tries to reach the head of laboratory and, c) if she can be reached, communicates the
results. If the the head of laboratory is not available, the laboratory assistant has to try
again at a later point in time. e) If the physician is available, she verbally communicates
the results to the physician. Again, the same problems occur as in special case one in
Section 3.1: There is no guarantee that the stakeholders will ever be reached, nor are
control mechanisms established to log what has been transmitted, when and by whom.

3.4.
Laboratory Assistant has Critical Laboratory Results
20
Figure 3.5: Laboratory assistant tries to reach the physician by phone
3.4 Laboratory Assistant has Critical Laboratory
Results
Besides the three workﬂows already discussed, a situation can occur in which the labora-
tory results reveal an imminent danger to the patient and require the physician to act as
soon as possible. In this case, the following workﬂow applies (shown in Figure 3.6): Like
in the regular case (see Section 3.1), a) the laboratory assistant enters the laboratory
results in WinDMLAB. b) If at least one part of the analysis result is critical, she tries
to call the physician. f) If the physician is not available, she waits a given time and tries
again later. c) If she has tried three times and she still cannot reach the physician, she
contacts the head of laboratory and if she is reachable, d) communicates the results. It is
then up to them to make sure the analysis results are transmitted to the right physician.
If the head of laboratory cannot be reached and because the situation is critical, e) the
laboratory assistant has no other choice but to personally bring the laboratory results to
the medical service to which the patient has been assigned. g) If the physician can be
reached, she communicates the results and h) the physician can treat the patient.
These four use cases have shown the processes between diﬀerent stakeholders at the can-
tonal laboratory and the cantonal hospital of Fribourg. It was explained that a potential

3.4.
Laboratory Assistant has Critical Laboratory Results
21
Figure 3.6: The laboratory assistant has critical laboratory results
worst case scenario might cost human lives [Rup07, p. 36]. To improve the current sys-
tem, [Rup07, p. 36] suggested and developed a new solution that aims to reduce human
errors and reduce the situation in which diﬀerent stakeholders are not available.

Part II
Background
22

4
Software Agents
4.1
What is an Agent? What is an Intelligent Agent?
. . . . . .
24
4.1.1
Properties of an Agent . . . . . . . . . . . . . . . . . . . . . . .
24
4.1.2
Properties of an Agent Environment . . . . . . . . . . . . . . .
24
4.2
Architectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
4.2.1
Logic Based Agents Architectures . . . . . . . . . . . . . . . . .
26
4.2.2
Reactive Agent Architectures . . . . . . . . . . . . . . . . . . .
26
4.2.3
Hybrid Agent Architectures . . . . . . . . . . . . . . . . . . . .
26
4.2.4
BDI Architectures
. . . . . . . . . . . . . . . . . . . . . . . . .
27
4.3
Communication and Coordination
. . . . . . . . . . . . . . . .
27
4.3.1
FIPA Message Speciﬁcations
. . . . . . . . . . . . . . . . . . .
28
4.3.2
FIPA-Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
4.4
Ontologies in a Multi-Agent Environment
. . . . . . . . . . .
30
4.5
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
4.5.1
Multi-Agent System for Electronic Health Record Management
31
4.5.2
Multi-Agent System for Process Automation
. . . . . . . . . .
31
4.5.3
Multi-Agent System for Sensor Web Management . . . . . . . .
31
The software agent paradigm is a suitable approach to provide workﬂow automation and
support. Entities in a business process are represented as autonomous agents that collab-
orate with their peer in their environment to achieve their given goal [Woo02, p. 245–247].
This Chapter gives an introduction to intelligent agents. Section 4.1 comments on the
deﬁnition of an agent and the environment an agent can exist in. Section 4.2 presents dif-
ferent agent architectures followed by a discussion on agent communication in Section 4.3.
Section 4.4 elaborates on ontologies, which play a central role in agent communication.
Section 4.5 closes this Chapter with a brief introduction of three concrete multi-agent
systems.
23

4.1.
What is an Agent? What is an Intelligent Agent?
24
4.1 What is an Agent? What is an Intelligent Agent?
There is not a single deﬁnition of the term agent. It is generally agreed that an agent
is a special software component that is autonomous, behaves like a human agent at the
service of its clients and follows its own agenda [BCG07, p. 3]. This thesis is on multi-
agent systems. The deﬁnition of the term “agent” is taken from Professor Wooldridge, an
expert in the ﬁeld of multi-agent systems. He deﬁnes the term “agent” as follows:
“An agent is a computer system that is situated in some environment, and that is capable
of autonomous action in this environment in order to meet its design objectives.” [Woo02,
p. 15].
4.1.1 Properties of an Agent
An agent should have the following attributes [WJ95, p. 4–5]:
autonomy: An autonomous agent can act without intervention from humans or other
agents.
social ability: An agent with social abilities will communicate with other agents or hu-
mans. Communication is via some agent-communication language.
reactivity: An agent perceives its environment (digital and/or physical) and reacts to
changes in the environment.
pro-activeness: The agent may have goal-directed behaviors that are not simply caused
by changes in the environment.
4.1.2 Properties of an Agent Environment
Figure 4.1: An agent senses information from its environment and acts upon it. Its action
can aﬀect the environment [Woo02, p. 16]
An agent exists in an environment. As depicted in Figure 4.1, through its sensors it
perceives information and data (referred to as “percept” [RN03, p. 32])) of its environment
and generates actions through actuators (also referred to as eﬀectors) that can aﬀect the
environment [Woo02, p. 16],[BWH07, p. 3]. The environment an agent exists in “is
the aggregate of surrounding things, conditions, or inﬂuences with which the agent is

4.2.
Architectures
25
interacting.” [RH05, p. 19]. In the context of an agent software, those inputs include
keystrokes, ﬁle contents, network packets to which the agent reacts by displaying, writing
data to a ﬁle or transmitting data over the network [RN03, p. 32]. An agent can possess a
number of actions (referred to as eﬀectoric capability), with some actions being restricted
to a limited set of situations. The same action executed by an agent twice, in apparently
identical circumstances, might yield diﬀerent eﬀects. This is due to the fact that an agent
is unlikely to have full control over its environment but will have at best partial control,
meaning it can inﬂuence it. An agent must also be prepared to accept failures [Woo02,
p. 16].
[RN03, p. 41–42] have identiﬁed the following dimensions to classify the properties of an
agent environment:
Fully observable vs. partially observable If the agent knows the complete state of its
environment through its sensors that are relevant to the choice of action at each
point in time, the environment is fully observable. If the agent can only perceive
parts of the environment, it is partially observable.
Deterministic vs. strategic vs. stochastic If the next state of the environment com-
pletely depends on its current state and the action executed by an agent, the envi-
ronment is deterministic. If the environment is deterministic except for the actions
of other agents, the environment is strategic. If none of the two mentioned states
apply, it is stochastic.
Episodic vs. sequential The agent’s experience in an episodic environment is divided
into atomic episodes. An agent performs in an action based on what it perceives
and thus does not depend on the actions taken in previous episodes. In a sequential
environment, however, an action taken in an episode could have eﬀects in future
episodes.
Static vs. dynamic A static environment does not change while the agent is deciding
which action it should execute next; a dynamic environment, however, does change
while the agent deliberates.
Discrete vs. continuous If only a limited set of distinct, clearly deﬁned precepts and
actions of the agent exist, the environment is called discrete. Otherwise, it is referred
to as continuous.
Single-agent vs. multi-agent An environment is called multi-agent if two or more en-
tities exist that aim to maximize their performance measure and depend on each
others behavior. An environment with only one agent is a single-agent environ-
ment.
In a competetive multi-agent environment, agents try to maximize their
performance measures at the expenses of other agents (as an example [RN03, p. 32]
state chess). In a cooperative multi-agent environment, agents are not competing
at the expense of other agents.
4.2 Architectures
The central task of an agent is to decide which action it shall choose to best satisfy its
design objectives. Several agent architectures have been proposed, ranging from purely
reactive architectures to those that reason about their actions. In between lie hybrid

4.2.
Architectures
26
architectures. Agent architectures can be classiﬁed in four groups: (i) logic based, (ii) re-
active, (iii) Beliefs, Desires and Intentions (BDI) and (iv) hybrid [BCG07, p. 4],[Woo02].
4.2.1 Logic Based Agents Architectures
Logic based architectures views decision making as deduction. An agent’s decision mak-
ing strategy is encoded in logical theory [Woo02, p.
54].
An action is chosen using
reasoning mechanisms. The logical based architecture ﬁnds its root in knowledge-based
system techniques [BCG07, p. 4]. The logic based approach has the advantage that it has
clean semantics. The disadvantages are, however, that, due to the computational com-
plexity of theorem prooﬁng, a logic based agent might not be able to operate eﬀectively
in an environment with time constraints. Additionally, it can be challenging to translate
the real world into accurate, adequate symbolic description [Woo02, p. 54] [BCG07, p. 4].
4.2.2 Reactive Agent Architectures
Reactive agent architectures do not have any central symbolic model and use no symbolic
reasoning. An agent’s decision making is accomplished through a set of task-accomplishing
behaviors. Each behavior can be thought of as an action which continually perceives input
and maps it to an action to perform. The reactive paradigm was strongly inﬂuenced by
Rodney Brooks, the author of the subsumption architecture. He developed the subsump-
tion architecture to concretize his ideas. The subsumption architecture can ﬁre several
behaviors simultaneously. To choose which behaviors will be ﬁred, the subsumption ar-
chitecture arranges behaviors in a hierarchy where the lower levels have higher priority
than the higher levels [Woo02, p. 90–91]. The strength of the subsumption architecture
is the computational simplicity, since the subsumption architecture does not plan; it per-
ceives and acts, thus it performs better in a dynamic environment than a logic based
agent. The disadvantage of the subsumption architecture is that the perceived informa-
tion alone might be insuﬃcient. Additionally, it is almost impossible to design agents that
can learn from past experiences because they lack of an internal state. Furthermore, since
the intelligence is to emerge from the interaction between diﬀerent behavior, designing
agents to perform speciﬁc tasks is diﬃcult [BCG07, p. 5].
4.2.3 Hybrid Agent Architectures
Hybrid agents architectures include both reactive and proactive behaviors. The diﬀerent
behavior types are classiﬁed in various subsystems that are arranged in hierarchy of
interacting layers. Two possibilities exist for the information and control ﬂow between
layers: horizontal layering and vertical layering.
In a horizontal layered architecture,
the software layers are directly connected to the sensory input and action output. Each
layer acts like an agent and makes suggestions on how to act. In the vertical layered
architecture, the sensory input ﬂows from layer to layer and only one layer at a time is
active [BCG07, p. 5–6].

4.3.
Communication and Coordination
27
4.2.4 BDI Architectures
BDI architectures have their origins in philosophy, in the theory of human practical rea-
soning. Intentions play a central role in the theory of human practical reasoning. The
BDI paradigm treats computer programs as if they had a “mental state”. In the context
of BDI architectures, Beliefs, Desires and Intentions can be deﬁned as follows [BWH07,
p. 15–16]:
Beliefs: Beliefs make up the agent’s knowledge about its environment. They can be out
of date or inaccurate.
Desires: Desires are state of aﬀairs the agent might want to achieve. Desires do not
mean that the agent acts up on it, only that they have the potential to inﬂuence
its actions. Desires can be mutually incompatible with one another.
Intentions: Intentions, in the context of BDI, are states of mind, in particular aimed
towards some future state of aﬀairs. Intentions can be either goals delegated to
an agent or an option selected from a set of available options. This option then
becomes an intention.
Practical reasoning is directed towards actions. Considering conﬂicting beliefs and de-
sires, the agent chooses for or against competing options [BWH07, p. 17–18]. [BWH07, p.
18] explains that “Human practical reasoning seems to consist of two distinct activities:
deliberation (ﬁxing upon states of aﬀairs that we want to achieve, i.e. our intentions);
and means-ends reasoning (deciding how to act so as to bring about our intentions).”.
The process, during which an agent chooses his intentions, is known as deliberation. In-
tentions have the properties that the agent will attempt to achieve them, they persist
until they are achieved or they have become obsolete. A chosen intention will constrain
the space of possible intentions the agent has to consider and they are strongly related to
believes about the future (the agent believes that under normal circumstances, achieving
the intention is possible) [BWH07, p. 18–19].
The process to decide how the chosen intentions will be achieved, given the available
means (actions that can be performed in the agent environment), is known as means-
ends reasoning. In the artiﬁcial intelligence domain, means-ends reasoning is called plan-
ning [BWH07, p.
19].
A planner system takes the following inputs: (i) the agent’s
intentions/goals, (ii) the agent’s beliefs about its environment (iii) and the actions avail-
able to the agent, to generate a plan to accomplish the selected goals/intentions [BWH07,
p. 19].
4.3 Communication and Coordination
In a multi-agent environment, in addition to communicating with users and system re-
sources, agents need to communicate with other agents in their environment to cooperate,
collaborate and negotiate. Agents use an Agent Communication Language (ACL) to com-
municate with their peers. An ACL relies on speech act theory that provides separation
between communicative acts and content language. Several ACL have been developed.
Currently the most used is FIPA ACL [BCG07, p. 6]. One of the main features of FIPA
ACL is the support of several content languages and managing conversation through
predeﬁned interaction protocols [BCG07, p. 6].

4.3.
Communication and Coordination
28
In an agent community, agents will to coordinate their activities to assure that they are
coherent. Because, according to [BCG07, p. 6], “(1) agents’ goals may cause conﬂicts
among agents’ actions, (2) agents’ goals may be interdependent, (3) agents may have
diﬀerent capabilities and diﬀerent knowledge, and (4) agents’ goals may be more rapidly
achieved if diﬀerent agents work on each of them”.
The approaches to handle coordination among agents include [BCG07, p. 7–8]:
Organizational structuring: Agents are organized in a master/slave hierarchy.
The
master agent has to assure global coherence: it can gather information from other
agents, make plans, coordinate and assign tasks in the group.
Contracting: In this approach, an agent can take the role of a contractor or of a manager.
If an agent cannot solve a task with the local resources/expertise at its disposal, it
takes the role of a manager and decompose the problem into subproblems and tries
to ﬁnd agents with the necessary resources/expertise that are willing to solve the
subproblems.
Multi-agent planning: To avoid conﬂicting actions or interactions, using this approach
agents build a multi-agent plan to achieve their goals. During execution, additional
planning and replanning can occur. Multi-agent planning can be either centralized
or distributed.
Negotiation: Negotiation is a communication process for agents to ﬁnd a common ac-
cepted agreement on something. Negotiation can be either competitive or coopera-
tive. Cooperative negotiation is used when agents share a common goal or have to
achieve a common task. Hence the multi-agent system was created to pursue that
goal. Competitive negotiation, on the other hand, is when agents are not in the
ﬁrst place cooperative but have their own, conﬂicting goals and are “not a priori co-
operative, share information or willing to back down for the greater good” [BCG07,
p. 8].
4.3.1 FIPA Message Speciﬁcations
The IEEE standard organization FIPA promotes the interoperability of agent-based tech-
nologies [9]. Part of the FIPA standard speciﬁes the structure of the asynchronous mes-
sages agents exchange to communicate. The list of parameters that can be set in an ACL
message can be found in [6]. The parameters that are used depend on the context in
which the message is sent. The only required parameter, in a FIPA-compliant message,
is performative [6]. A performative is the action the receiver is expected to execute. Perfor-
mative is also referred to as communicative act [BCG07, p. 65]. In this thesis, both are
used interchangeably. Commonly, an ACL message also contains the parameters sender,
receiver and content [6].
4.3.2 FIPA-Protocols
The FIPA standard speciﬁes a set of protocols to structure the conversations between
agents.
Protocols specify the roles of the participating agents and the messages ex-
changed [7].
The protocol on which every conversation is based in this thesis is the
FIPA-Request-Interaction-Protocol1.
1FIPA-Request-Interaction-Protocol and FIPA-Request-Protocol are used interchangeably in this thesis.

4.3.
Communication and Coordination
29
FIPA-Request-Interaction-Protocol
*+,-./012034.,5646768
+9:4:;465
,;54:7:<;94
5012034
50=230
;>500
=;:8250
:9=65?.@690!A!:9=65?
:9=65?.503284!A!:9=65?
B;>500@C
B50=230@C
B;>500@!;9@
964:=:7;4:69!907033;5DC
 
Figure 4.2: FIPA Request Interaction Protocol (obtained from [8])
The FIPA-Request-Interaction-Protocol deﬁnes the interaction between two agents. The
message exchange is shown in Figure 4.2. The agent that starts the conversation is referred
to as the initiator. The receiver as the participant. The initiator wants the participant
to perform a certain action. It sends a message containing a Request performative and
the action the agent is to perform. The participant may accept or refuse to perform the
action. If the participant refuses, it replies with a refuse, otherwise, it replies with an
accept. The accept can be omitted if the participant performs the action in a short time
period [8]. Once the participant has completed the action, it replies with either [8]:
failure The agent was not able to successfully complete the action.
inform-done The action was completed successfully.
Inform-result The action was completed successfully and the result from the action is
returned to the initiator.

4.4.
Ontologies in a Multi-Agent Environment
30
4.4 Ontologies in a Multi-Agent Environment
Figure 4.3: Ontology-Based Communication Model [5]
In addition to being able to exchange messages, agents need to understand the messages
they are exchanging. Thus they need to share “a vocabulary of predicates, functions, and
constants” [RN03, p. 261] with an ontology (depicted in Figure 4.3). The term ontology
has its root in Greek philosophy but is now extensively used in the domain of computer
science [GPFLC04, p. 3]. In the context of this thesis, the latter is of interest. Several
deﬁnitions of the term ontology can be found; one of the most cited is suggested by
Gruber:
“An ontology is an explicit speciﬁcation of a conceptualization” [Gru93, p. 1].
A number of ontology languages have been developed. The FIPA standard for agent-
based technology adopted the frame-based knowledge model of Open Knowledge Base
Connectivity (OKBC) which is, in the FIPA standard, referred to as FIPA-Meta-Ontology.
The FIPA standard states that agents can use a knowledge representation language of
their choosing. However to be FIPA compliant, they need to be able to provide a mapping
to the FIPA-Meta-Ontology for knowledge communication [5].
A brief overview of the OKBC knowledge model is given below (for more information on
OKBC, the reader is invited to consult the OKBC speciﬁcations in [15]):
Frame: “A frame is a primitive object that represents an entity in the domain of dis-
course” [CFF+98]. A class frame represents a class, an individual frame an indi-
vidual object. A class (aka concept) is a set of entities. Entities are said to be
instances of that class. An entity can be an instance of several classes. Classes that
contain themselves classes, are known as meta-classes. Entities that are not classes
are referred to as individuals. Classes can be organized in a hierarchy of subclasses.
Slot: Slots (aka attributes) deﬁne the characteristics of a frame. A slot has a set slot-
values (entities) associated with it.
Facet: A facet is ternary relation between a slot, its value and the slot’s frame (individual
or class). A slot frame can for example deﬁne the cardinality, type of a slot and
default value [GPFLC04, p. 51].
The FIPA standard suggests two ways to manage ontology: (i) agents use explicit, declar-
ative represented ontologies that are stored somewhere or, (ii) ontologies are implicitly
represented in the agents’ code.
It is also permitted for agents to use both approaches.
For the former approach, the ontology service in an agent community is managed by a
dedicated Ontology Agent (OA). The FIPA standard deﬁnes a set of functionalities that
an OA can implement, such as publishing ontologies for other agents to discover, trans-
lation between diﬀerent ontologies or ontologies maintenance (i.e. upload, download or

4.5.
Applications
31
modify ontologies). An OA does not have to oﬀer all functionalities. However, it must
be able to notify clients if a requested functionality is not implemented. How ontologies
are stored is not speciﬁed by the FIPA standard [5].
4.5 Applications
This Section brieﬂy describes three implementations of multi-agent systems.
4.5.1 Multi-Agent System for Electronic Health Record
Management
[TP07] propose a multi-agent system called "agent-based electronic health record system"
(ABEHRS) to provide access to electronic health record information that are distributed
among several medical institutions. They argue that electronic health records of patients
are likely to be inconsistent as a result of being maintained in serval location. With the
growing need for healthcare providers to share patients’ health records and a centralized
approach to managing electronic health records, the authors argue that "the creation of a
digital health information network is essential to our modern health care system" [TP07,
p. 306]. Their framework is based on multi-agent swarm system. The individual agent
by itself has only limited abilities. However, as a swarm they can perform complex tasks.
The swarm approach was taken from societies in biology (i.e. bees, ants) [TP07, p. 308].
The ABEHRS framework permits distributed electronic health records of patients to self
organize [TP07, p. 306].
4.5.2 Multi-Agent System for Process Automation
[JNF+00] explain that business activities need to be able to execute quicker at lower
cost and with increased quality in an environment that includes several organizations
and legacy information systems. The authors propose an agent-based approach. Each
activity in a business process is represented by an agent.
Agents can negotiate with
their peers to "come to mutually acceptable agreements that coordinate their interde-
pendent sub-activities" [JNF+00, p. 2]. This permits, the authors argue, a more ﬂexible,
adaptive and agile process management, compared to traditional workﬂow management
systems [JNF+00, p. 2].
4.5.3 Multi-Agent System for Sensor Web Management
Remote sensing missions for Earth Science conducted by NASA uses a network of dy-
namic, seamlessly interconnected sensors. Critical events, such as hurricane detections,
have to be handled quickly [SHC+07, p. 1]. NASA is developing a new sensor web based
on a multi-agent architecture for communication and negotiation. The future sensor web
for Earth Science will consists of interlinked platforms equipped with onboard information
processing systems that can coordinate their activities with other platforms [SHC+07, p.
1]. NASA is developing the multi-agent framework "Multi-agent Architecture for Coor-
dinated, Responsive Observations" (MACRO) to support the future sensor web. Agents

4.5.
Applications
32
can describe their sensors in the Sensor Markup Language and perform collective obser-
vations [SHC+07, p. 2].

5
JADE: An Agent Framework
5.1
The JADE Architecture
. . . . . . . . . . . . . . . . . . . . . .
34
5.1.1
Important Platform Management Services . . . . . . . . . . . .
34
5.1.2
Administration and Debugging Tools . . . . . . . . . . . . . . .
35
5.2
Agent Communication Implementation
. . . . . . . . . . . . .
36
5.2.1
Sending and Receiving Messages
. . . . . . . . . . . . . . . . .
36
5.2.2
Implementational Details of the JADE Messaging Service
. . .
36
5.2.3
Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
5.3
Use of Ontologies in JADE . . . . . . . . . . . . . . . . . . . . .
39
5.3.1
Protégé
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
The Java Agent Development Framework (JADE) is an open source, fully FIPA compliant
middleware, for multi-agent systems written in Java. Development began in late 1998 by
the Telecom Italia. JADE was open sourced and distributed by Telecom Italia under the
Library Gnu Public License (LGPL) in 2000. Other organizations, such as Motorola and
France Telecom R&D, have become members of the board [BCG07, p. 29–30].
JADE is not domain or application speciﬁc. It oﬀers the basic middleware functionalities
for distributed applications, based on the multi-agents paradigm. A JADE environment
has the interesting properties that [BCG07, p. 30–31]:
• Agents are autonomous and proactive: they have their own thread of execution and
do not pass their object reference to other agents. They control their life cycle and
autonomously decide when to perform their next action.
• Agents can refuse to execute an action and are loosely coupled: JADE agents
use asynchronous, message-based communication. A sender addresses the receiver
by using its unique name, not its object reference. Messages might even be sent
without specifying a known sender, by sending it to a group of agents or to a proxy
agent that will handle delivery to the appropriate agents. Additionally, a receiver
can autonomously decide which messages it wants to process in the order of its
choosing and which messages it wants to discard.
• The system is peer-to-peer: Agents have unique identiﬁers (the AgentIdentiﬁer
(AID)) to directly address each other, they can join and leave the host platform at
their choosing. Agents can look up other agents in the yellow pages (provided by
the Agent Management System (AMS) and Directory Facilitator (DF) agents).
33

5.1.
The JADE Architecture
34
5.1 The JADE Architecture
A JADE agent platform consists of one ore more container distributed over a network.
JADE containers are Java processes that provide the JADE run-time and the services
required for hosting and executing JADE agents. The main container is of special im-
portance. It represents the bootstrap point of an agent platform and launches the other
containers. Containers are identiﬁed by their logical name (by default the main container
is called “Main Container”, the others “Container-1” etc.) [BCG07, p. 32]. The main
container has the following additional functionalities [BCG07, p. 32–33]:
• Managing the Container Table (CT): The CT holds the object reference and trans-
port address of each container that is part of its agent platform.
• Managing the Global Agent Descriptor Table (GADT): The GADT registers each
agent in the platform with their location and status.
• Hosting the DF and AMS agents that provide the functionality of agent manage-
ment, white pages and yellow pages services.
Each container has a Local Agent Descriptor Table (LADT) and (except for the main
container) a local GADT cache to not have the GADT as a bottleneck. When a container
needs to deliver a message, it looks up the agent’s address in its LADT. Only if the
lookup is unsuccessful, it will attempt to ﬁnd it in the GADT and store the result in its
GADT cache. To prevent the main container from being the single point of failure, JADE
oﬀers replication mechanisms that enable the agent platform to function when the main
container is unavailable [BCG07, p. 33].
5.1.1 Important Platform Management Services
According to the FIPA standard, the three most important services in a FIPA agent
platform are the Message Transport Service (MTS), AMS and DF [BCG07, p. 39]:
Message Transport Service: The MTS manages the transportation of ACL messages
between agents within an agent platform and agents in other agent platforms. The
MTS implements all Message Transport Protocol (MTP) speciﬁcations deﬁned by
FIPA. By default, a HTTP-based MTP is activated. It is identiﬁed by an Uniform
Resource Locator (URL) and accessible over a HTTP socket. Internally, JADE
uses the more performant Internal Message Transport Protocol (IMTP) [BCG07,
p. 39]. IMTP is a proprietary protocol used to transport messages between agents
as well as internal commands for the management of the agent platform and status
monitoring of the containers. By default IMTP is based on Java Remote Method
Invocation (RMI). In a "Java Platform, Micro Edition environment", where RMI
is not available, it uses a proprietary TCP socket protocol [BCG07, p. 41].
Agent Management System: The AMS agent manages the operations of an agent plat-
form including registration and deletion of agents. Every agent in the agent platform
must register with the AMS to obtain an AID. The AMS keeps a directory with
all agents including their state. When an agent is deregistered from the AMS, it
terminates. The agent’s AID is freed and can be reused by other agents that might
request it. An AMS agent can request and force an agent to execute management
functions (e.g. terminate execution). A platform has only one AMS agent [BCG07,
p. 15–16].

5.1.
The JADE Architecture
35
Directory Facilitator: A DF provides the yellow pages service for an agent platform.
Agents that wish to publish their service, can request a registration of their agent de-
scription. A DF must maintain an accurate and complete list of its registered agents
and answer queries with the most accurate information on a non-discriminatory
basis. An agent platform can contain one or more DF agents that create a federa-
tion [BCG07, p. 15].
5.1.2 Administration and Debugging Tools
Figure 5.1: The GUI of the RMA
The JADE framework includes a set of agents to ease development and administration
of a JADE agent platform:
Remote Monitoring Agent: The RMA is an administration tool that oﬀers a GUI to
access and visualize one or more agent platforms. An example is given in Figure 5.1.
The left panel shows a agent tree. It contains three types of nodes: agent platforms,
containers and agents. Each node’s life cycle in the tree can be manipulated (e.g.
agents can be killed, frozen, migrated, saved) and new nodes added.
A RMA
subscribes with the AMS and received all platform-level events [BCG07, p. 43].
Dummy Agent: The dummy agent is a useful tool mainly used during development.
Its only function is to send and receive custom made ACL messages to test “real”
agents’ reactions. The dummy agent is used via a GUI [BCG07, p. 44].
Sniﬀer Agent: The sniﬀer agent sniﬀs and displays the communication ﬂow and content
in real time between a set of selected agents. It does this by subscribing itself to the
AMS and is then notiﬁed of all events and messages related to the selected agents.
Agents can be added or removed in real time to the group of sniﬀed agents. The
messages sniﬀed can be viewed and saved [BCG07, p. 44–46].
Introspector Agent: The introspector agent can monitor and control in real time the life
cycle of an agent (e.g. which behaviors are executing, sleeping, reacting to messages
from other agents) [BCG07, p. 46].

5.2.
Agent Communication Implementation
36
Log Manager Agent: The log Management Agent facilitates the dynamic and distributed
logging management. It provides a GUI to conﬁgure the log level of each component
in a JADE platform including application-speciﬁc nodes during run time [BCG07,
p. 46].
5.2 Agent Communication Implementation
Providing an infrastructure for agents to exchange messages is a fundamental role of
JADE. This Section discusses the implementation of the agent communication in JADE.
Section 5.2.1 brieﬂy describes how messages are sent and received from a programmer’s
point of view. Section 5.2.2 delves into the implementational details of the objects in-
volved and their roles, when a message is sent from an agent to another. Section 5.2.3
explains behaviors that implement agent actions of an agent in a JADE environment.
5.2.1 Sending and Receiving Messages
1 ACLMessage msg = new ACLMessage(ACLMessage .REQUEST) ;
msg. setLanguage ( "A−Language " ) ;
3 msg. setOntology ( "An−Ontology " ) ;
msg. setContent ( " Hello
world ! " ) ;
5 msg. setReceiver (new AID ( " Agent Doe" , AID .ISLOCALNAME) ) ;
this . myAgent . send (msg) ;
Code extract 5.1: Composing and sending a message
ACLMessage msg = this . myAgent . receive ( MessageTemplate . MatchPerformative (ACLMessage .REQUEST) ) ;
2
i f
(msg !=
null )
{ . . . }
Code extract 5.2: Receiving a message
Agents messages are asynchronous. Each agent has a mailbox to store incoming messages.
By calling the agent’s receive method, the message next in the queue is fetched. receive
can be provided with a message template to return only a message that matches a pattern
deﬁned by the template, for example a speciﬁc type of agent action and a given FIPA-
protocol.
A simple example of how a message is sent from a behavior is shown in Code extract 5.1.
When an ACLMessage is created, the performative is passed as constructor argument (line
1). In lines 2–5 the content language, ontology and message content are set. The values in
this example are purely ﬁctional. The message is sent by calling the agent’s send method
in line 6.
Receiving a message is shown in Code extract 5.2. In this example, receive will only return
a message if there is a message in the agent’s mailbox that matches the template speciﬁed
as an argument (a message with a Request performative). In line 2, the behavior tests
whether or not there is a message, otherwise, the behavior does not execute further. Both
examples assume that they are executed from within a behavior.
5.2.2 Implementational Details of the JADE Messaging Service
JADE is developed with ﬂexibility and extensibility in mind: its kernel uses a modular
approach in which each service is a separate module. The architectural design is based
on the concepts of aspect oriented programming that advocates a "clean separation of

5.2.
Agent Communication Implementation
37
Figure 5.2: High-level overview of message delivery with JADE (obtained from [BCG07,
p. 134], red demarcation added)
concerns" [BCG07, p. 131]. The approach chosen for the implementation is the use
of composition ﬁlter: each object is equipped with two ﬁlter chains: the ﬁlters of the
incoming chain are executed before the method of the object is to be invoked and the
ﬁlters of the outgoing chain are called before the object invokes the method of another
object [BCG07, p. 131–132].
The core of JADE consists of a ﬁlter architecture that can be distributed over several
containers. Each container resides on a node. A container hosts a set of agents and
a node a set of services.
Services may be composed of several components.
To give
a concrete example of such a service, the rest of this Section describes how a message
is transpored in JADE. A high-level description of this process is shown in Figure 5.2.
The red boxes labeled with Step 1 to 4 correspond to the UML Sequence Diagrams
of Figure B.1, Figure B.2, Figure B.3 and Figure B.4 in Appendix B. When an agent
request a service, such as sending a message, the request is passed to its container which
forwards it to the service that is responsible to perform the operation. The service may
implement the functionality directly or commit a vertical command. A vertical command
is implemented in the class jade.core.GenericCommand. It embeds the functionality and
accepts a set of parameters. The vertical command will access a component of the service
to perform the task. This is referred to as the outgoing sink. Before the outgoing sink
is reached, it passes through the outgoing ﬁlter chain and each ﬁlter may perform a
service speciﬁc task with the command or simply pass the command to the next ﬁlter
in the chain. Every service may oﬀer a ﬁlter that will access its service. A service may
overreach several platforms. The node to node interaction is referred to as horizontal
command. A horizontal command is also implemented with the jade.core.GenericCommand
class. The component within a service that accepts the horizontal from another node, is
referred to as slice. A slice may either perform the command directly or execute another
vertical command. Before the target service component is reached, the incoming ﬁlter
chain is passed. The target service is refer to as incoming sink. Every service may provide

5.2.
Agent Communication Implementation
38
incoming ﬁlters [BCG07, p. 132–134].
5.2.3 Behaviors
An agent object does not contain any task related instructions. It contains a set of behav-
iors that implement its actions. Behaviors can be seen as threats. The agent contains a
scheduler that uses a "round-robin non-preemptive scheduling policy" [BCTR00, p. 25]
for the behaviors in the agent’s ready queue [BCTR00, p. 24–25]. In this thesis, the
distinction between two types of behaviors is made:
• Behaviors that handle internal tasks of an agent and which then may, as result, also
require communication with the outside world. In this thesis, they are referred to
as internal behaviors.
• Behaviors that are directly involved in a request/response communication pattern
between agents in the environment. In this thesis, they are referred to as commu-
nicational behaviors.
The former remains in the "internals" of an agent and thus does not expose an interface
which, to maintain interoperability with other agents, is subject to standardization. The
latter on the other hand, should adhere to common standards. Standardized communi-
cation interfaces are necessary to have loosely coupled agents that can interoperate with
other agents that implement the same standard. This also permits to reuse agents and
behaviors in a new environment without having to rewrite major parts of the code.
The JADE framework provides a set of predeﬁned behavior classes for each actor taking
part in the diﬀerent FIPA protocol based conversations. The skeleton of the main commu-
nication ﬂow during an agent conversation based on a FIPA-protocol, is managed by the
Template Methods of these abstract classes. For steps that cannot be implemented in ad-
vance, the Template Method (the Template Method design pattern is discussed [GHJV95,
p. 325]) calls hook operations which the subclasses can implement. Thus to implement
behaviors that are in compliance with the FIPA standard, the behavior classes for the
FIPA-protocol that best meet the communication, can be subclassed and the hook oper-
ations that are of interest are overwritten.
Naming Convention for FIPA-Rquest-Initiator-Protocol based Behaviors
Due to the nature of FIPA-Request-Interaction-Protocol based conversations (see Sec-
tionn 4.3.2), each conversation is centered around the agent action that the initiator
requests the participant to perform. This permits to make the following conventions for
behaviors developed in this thesis:
• For each initiator behavior, there is exactly one corresponding responder behavior.
• For each agent action used, there is exactly one corresponding "initiator, responder"
behavior pair.
These simple conventions increase maintainability and extensibility of agents and their
behaviors: It prevents from having to test an incoming agent action for its class in a
behaviors code. This ultimately simpliﬁes adding new actions and behaviors: To add
the support for a new agent action, the initiator and responder each have to add a new
behavior, other behaviors are not aﬀected. It also simpliﬁes debugging since the source

5.3.
Use of Ontologies in JADE
39
of an agent action related error can be narrowed down to two behaviors.
Additionally, the naming convention, in this thesis, for behaviors that implement agent
FIPA-Request-Interaction-Protocol is as follows: In each conversation, the initiator’s be-
havior’s name consists of the agent action and "Initiator" as suﬃx, and for the participant
the behavior’s name consist of agent action and "Responder" suﬃx. Furthermore, for ev-
ery conversation, the initiator creates a message containing a Request performative with
the agent action and passes the message as a constructor argument to the Initiator be-
havior. As an example, based on a conversation discussed in Section 8.4.2, the behaviors
for the "Attack" conversation are AttackInitiator and AttackResponder.
5.3 Use of Ontologies in JADE
JADE relies heavily on ontologies for agent communication. It oﬀers a framework for
developers to model domain speciﬁc ontologies. JADE does not use an Ontology Agent
(OA) (see Section 4.4 for ontology management in multi-agent systems). Ontologies are
written in Java and thus are directly represented as Java objects in the agents’ code [BM,
p. 8]. The JADE upper ontology is deﬁned in the content reference model. It contains:
• Concept, i.e. classes that are set of entities,
• AgentAction, a subset of Concept that is a set of all actions agents can perform and
• Predicate that state something about the status of the world and are either true or
false [BCG07, p. 80].
An ontology is an instance of a class that extends the Java class jade.content.onto.Ontology.
The concepts, agent actions and predicates of the domain speciﬁc ontology, are added as
instances of PredicateSchema, AgentAgentSchema or ConceptSchema, respectively. For each
concept, predicate and agent action of the ontology, the proper Java classes have to be
developed. They must implement the interfaces Concept, AgentAction or Predicate [BCG07,
p. 81–82]. In JADE, each ontology normally extends the basic ontology (not to confuse
with extending Java classes) that is an instance of the jade.content.onto.BasicOntology. The
basic ontology is represented as a Singleton (the Singleton design pattern is discussed
in [GHJV95, p. 127]). It contains
• primitive types,
• aggregate types and
• domain independent predicates and concepts [BCG07, p. 82].
As an example: to declare that the JADE ontology 01 extends ontology 02. Ontology 02
is passed as an argument to the super constructor of the ontology 01. Ontology 01 includes
all concepts, agent actions and predicates from 02 [BCG07, p. 82].
An example with a simple ontology, without inheritance, is shown in Figure 5.3. The the
ontology contains three classes in addition to the default structure speciﬁed by JADE;
a concept Computer, an agent action Sell and predicate Owns. The ontology itself is an
instance of the class ExampleOntology. The source code for the ExampleOntology is shown
in Code extract 5.3.
public class ExampleOntology extends jade . content . onto . Ontology
{
2
/ /NAME
public
static
f i n a l
String ONTOLOGY_NAME = " Example " ;
4
/ /
The singleton
instance
of
t h i s
ontology

5.3.
Use of Ontologies in JADE
40
Figure 5.3: A simple JADE ontology with three additional classes
private
static
R e f l e c t i v e I n t r o s p e c t o r
i n t r o s p e c t = new R e f l e c t i v e I n t r o s p e c t o r ( ) ;
6
private
static
Ontology
theInstance = new ExampleOntology ( ) ;
public
static
Ontology
getInstance ( )
{
8
return
theInstance ;
}
10
/ / VOCABULARY
public
static
f i n a l
String OWNS_ITEM=" item " ;
12
public
static
f i n a l
String OWNS="Owns" ;
public
static
f i n a l
String SELL_ITEM=" item " ;
14
public
static
f i n a l
String SELL=" Sell " ;
public
static
f i n a l
String COMPUTER=" Computer " ;
16
private ExampleOntology ( ) {
18
super (ONTOLOGY_NAME,
BasicOntology . getInstance ( ) ) ;
try
{
20
/ /
adding Concept ( s )
ConceptSchema computerSchema = new ConceptSchema (COMPUTER) ;
22
add ( computerSchema ,
ontology . jessmgmt . Computer . class ) ;
/ /
adding AgentAction ( s )
24
AgentActionSchema sellSchema = new AgentActionSchema (SELL) ;
add ( sellSchema ,
ontology . jessmgmt . Sell . class ) ;
26
/ /
adding
Predicate ( s )
PredicateSchema ownsSchema = new PredicateSchema (OWNS) ;
28
add (ownsSchema ,
ontology . jessmgmt .Owns. class ) ;
sellSchema . add (SELL_ITEM , computerSchema ,
ObjectSchema .MANDATORY) ;
30
ownsSchema . add (OWNS_ITEM, computerSchema ,
ObjectSchema .MANDATORY) ;
} catch ( java . lang . Exception e )
{ e . printStackTrace ( ) ; }
32
}
}
Code extract 5.3: ExampleOntology class source code
The ontology classes are simple Java classes. Code extract 5.4 shows the Java implemen-
tation of the class Sell.
1 public class
Sell implements AgentAction
{
private Computer item ;
3
public void setItem ( Computer value )
{
this . item=value ;
5
}
public Computer getItem ( )
{
7
return
this . item ;
}
9 }
Code extract 5.4: Sell class source code

5.3.
Use of Ontologies in JADE
41
5.3.1 Protégé
Figure 5.4: Screenshot of the Protégé ontology editor
JADE ontologies can be modeled with the open source ontology editor framework Pro-
tégé [25]. A screenshot of Protégé is shown in Figure 5.4. The Ontology Bean Generator
Protégé plugin maps the ontology modeled with Protégé to Java classes that can be used
by JADE [29].

6
Rule-Based Systems
6.1
Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
6.2
The Architecture of Rule-Based Systems
. . . . . . . . . . . .
44
6.2.1
Inference Engine . . . . . . . . . . . . . . . . . . . . . . . . . .
44
6.2.2
Working Memory . . . . . . . . . . . . . . . . . . . . . . . . . .
45
6.2.3
Rule Base . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
6.2.4
Pattern Matcher
. . . . . . . . . . . . . . . . . . . . . . . . . .
46
6.2.5
Agenda
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.2.6
Execution Engine . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.3
Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.3.1
Rule-Based Expert System in the Medical Domain . . . . . . .
47
6.3.2
Workﬂow Automation . . . . . . . . . . . . . . . . . . . . . . .
47
6.3.3
Rule-Based System for Monitoring . . . . . . . . . . . . . . . .
48
Rule-based systems model intelligent behavior based on task-speciﬁc problem-solving
knowledge of human experts [HR85, p. 921],[GFN89, p. 120],[Hil03, p. 18]. Rule-based
systems are widely used in many application areas.
Examples of rule-based systems
frameworks are Jess [12], Prolog [14], CLIPS [23] and JRules [16]. [Hil03, p. 19] explains
that many server applications integrate rule-based systems or have Application Program-
ming Interface (API)s to do so. Thus, rule-based systems have become ubiquitous, even
though they might not be mentioned explicitly. In the 1970s and 1980s, rule-based sys-
tems were used in the domain of artiﬁcial intelligence research [Hil03, p. 18] in the study
of cognitive models, problem solving and learning systems [GFN89, p. 120]. Rule-based
systems were also applied to problems in engineering, computer conﬁguration tasks and
oil exploration [GFN89, p. 120]. The success of rule-based systems to match or exceed
the performance of their human counterparts in speciﬁc, limited situations led to the
belief that one day, sophisticated rule-based systems would be able to reproduce general
human intelligence. Over time, it became evident that the complexity of common sense,
which underpins the general human reasoning, was vastly underestimated [Hil03, p. 18].
According to [HR85, p. 921], rule-based systems share the following properties:
1. “They incorporate practical human knowledge in conditional if-then rules,”
42

6.1.
Rules
43
2. “their skill increases at a rate proportional to the enlargement of their knowledge
bases,”
3. “they can solve a wide range of possibly complex problems by selecting relevant
rules and then combining the results in appropriate ways,”
4. “they adaptively determine the best sequence of rules to execute, and”
5. “they explain their conclusions by retracing their actual lines of reasoning and trans-
lating the logic of each rule employed into natural language.”
6.1 Rules
Unlike in procedural or object-oriented paradigm where the developer writes a sequence
of instructions that the computer has to execute in the given order, rules are written in
a declarative way: the programmer speciﬁes what but not how it is done [Hil03, p. 15].
In rule-based systems, knowledge is represented as heuristics (i.e. “rules of thumb”) that
specify which actions have to be performed in a given situation [22]. Thus, the operating
concept radically diﬀers from the von Neumann architectures. Rule-based programs must
therefore, be executed in a run time system that can identify the heuristic rules applicable
to the problems at hand and apply those rules to solve or reduce problems [HR85, p. 923].
Using this approach has several advantages: Rules are intended to be single chunks of
know-how which “reﬂect the learned, appropriate, eﬀective distinctions that people use
to make sophisticated high-level decisions.” [HR85, p.
925].
This makes rules easier
to understand compared to procedural programs [Hil03, p. 16]. Furthermore, due to
its representation as a single “chunk” of information, the knowledge base is inherently
modular and thus, simpliﬁes adding, removing and updating of rules without aﬀecting
the overall performance of a rule-based system [vMSB84, p. 305]. Additionally, because
the control-ﬂow is chosen by the run time system, the program can be more ﬂexible when
the input is fragmented or with limited constraints [Hil03, p. 16].
Rules are comparable to if-then statements. As an example: a rule-based system on a
Star Fleet ship might have the following rule:
IF
Klingon ship is approaching
THEN
Raise shields
END
The antecedent (if part) of a rule is often referred to as the left-hand side (abbreviated
LHS), predicate or premise and consequent (then part) as right hand side (abbreviated
RHS), action or conclusions. The set of information the rule can work with is called the
domain [Hil03, p. 17]. Rule-based systems use the rules to derive conclusions from the
premises. Two common methods of reasoning, when using inference rules, are forward
and backward chaining [Hil03, p. 116],[BS84, p. 4–5].
forward-chaining: Forward-chaining is also called data-directed inference. The engine
executes the RHSs of rules based on the data it knows.
backward-chaining: Backward-chaining follows a goal-driven strategy. As with forward-
chaining, rules are if-then statements but the behavior is diﬀerent. The approach

6.2.
The Architecture of Rule-Based Systems
44
can be seen as “depth-ﬁrst” [BS84, p. 49]. The system starts from a rule it wants
to ﬁre but with an if clause that only partly matches [Hil03, p. 116] and “works
"backward" through inference rules, i.e., from right to left, to ﬁnd the data that
establish that goal” [BS84, p. 5].
6.2 The Architecture of Rule-Based Systems
Figure 6.1: The architecture of a typical rule-based system [Hil03, p. 20]
The ﬁrst rule-based systems were tightly integrated with the speciﬁc application they
were developed for. Thus, new rule-based systems had to be written from scratch. The
EMYCIN, a derivate from MYCIN (it stands for Empty MYCIN) was developed as a
generic framework for rule-based systems, without the domain knowledge of the MYCIN.
It was the ﬁrst of its kind. This approach of developing a framework without a domain-
speciﬁc knowledge is followed by most modern rule-based systems [Hil03, p. 19]. Ac-
cording to [Hil03, p. 19 – 20], the architecture of a rule-based system has the following
components:
• A inference engine which consists of (i) a pattern matcher and (ii) an agenda
• an execution engine,
• a rule base,
• and a working memory.
[HR85, p. 924] labels the part that stores long term facts and rules as the knowledge base.
The architecture of a rule-based system is depicted in Figure 6.1. The components are
brieﬂy described in the following sections.
6.2.1 Inference Engine
The inference engine is the central part of a rule-based system. It controls the process of
applying rules to the facts in the working memory and solving the problems. [Hil03, p.

6.2.
The Architecture of Rule-Based Systems
45
20] explains that a rule-based system usually involves an iterative cycle that runs through
the following steps:
1. The pattern matcher compares all rules to the working memory and decides which
rules should be activated during the current cycle, resulting in an unordered list of
active rules that, together with the rules activated in the previous iteration, make
up the conﬂict set.
2. The next step is called conﬂict resolution. The conﬂict set is ordered to form the
agenda: the set of rules of which RHSs will be ﬁred (i.e. executed). The rule-based
system does this based on its conﬂict resolution strategy. Developers have little
control over this process.
3. In the last step, the ﬁrst rule of the agenda is ﬁred. Partial results are stored again
in the working memory. Many rule-based systems use sophisticated methods to
minimize redundant work. Also results from the pattern matcher and the agendas
conﬂict resolution are preserved across iterations.
To better illustrate functionality of the parts of the rule-based system, the example with
the incoming Klingon ship is continued. The rule-based system used for this example is
Jess.
6.2.2 Working Memory
The working memory, also called the fact base, is the database of assertions. The working
memory can contain both premises and conclusions derived from the rules. The infor-
mation in the working memory is typically indexed for fast search operations [Hil03, p.
21–22].
In the example introduced above, a new fact representing an incoming Klingon ship, is
asserted. The fact is of the class klingonShip (referred to as template in Jess). The template
deﬁnition and fact assertion is shown in Code extract 6.1.
1 ( deftemplate
klingonShip
( s l o t
type )
( s l o t
range ) )
3 ( assert
( klingonShip
( type
" h o s t i l e " )
( range 1000) ) )
Code extract 6.1: Deﬁning a template and asserting a fact
The working memory contains now one fact:
f-0
(MAIN::klingonShip (type "hostile") (range 1000))
6.2.3 Rule Base
The rule base contains the rules available to the rule-based system. They can be stored
in plain ASCII but are often compiled by the rule compiler to be used more eﬃciently
by the rule inference engine [Hil03, p. 21]. The rule-based system used for this thesis,
Jess, uses the Rete algorithm. The Rete algorithm preprocesses the rules and creates an
interconnected network that consists of the tests made in the LHS of the rules. If several
rules have the same test, the test is only represented once and shared among the rules
that contain it, to increase eﬃciency of the pattern matching. When a fact is added to
or removed from the working memory, the fact traverses the nodes in the network from

6.2.
The Architecture of Rule-Based Systems
46
the top until it reaches a matching rule at the bottom (if there is any) [Hil03, p. 136–
140]. This is far more eﬃcient than checking the LHS of each rule against the working
memory [Hil03, p. 135].
Figure 6.2: The Rete network generated for the rules detect-klingon and raise-shields
The rule-based system of the Star Fleet computer has two rules that are shown in Code
extract 6.2
1 ( defrule
detect−klingon
( klingonShip
( type
" h o s t i l e " ) )
3
=>
( p r i n t o u t
t
" Klingon
A l e r t
Captain ! "
c r l f ) )
5
( defrule
raise−shields
7
( klingonShip
( type
" h o s t i l e " )
{ range < 2000})
=>
9
( p r i n t o u t
t
" Raise
shields ! "
c r l f ) )
Code extract 6.2: Writing rules
The simpliﬁed representation of the Rete network, created by the rule compiler for the
rules of Code extract 6.2, is shown in Figure 6.2.
6.2.4 Pattern Matcher
The pattern matcher decides which rules apply to the assertions in the working memory.
This step is often the most expensive, in the sense of computational power, executed
by the inference engine. If the working memory contains a large number of facts and
each rule has several premises, the pattern matcher has to search through millions of
combinations to determine which facts match the rules. The Rete algorithm reduces the
execution time of this step [Hil03, p. 136–137].
Both rules apply to the newly assert fact. The (rule,facts) pairs are passed to the agenda.

6.3.
Applications
47
6.2.5 Agenda
The set of activated rules that could ﬁre, selected by the inference engine, is passed to
the agenda, which uses a conﬂict resolution strategy to determine, depending on diﬀerent
criteria (e.g. age of the premises, complexity of a rule, priority), which rule should ﬁre
ﬁrst.
The agenda decides to ﬁrst ﬁre raise-shields and then detect-klingon:
==> Activation: MAIN::raise-shields :
f-0
==> Activation: MAIN::detect-klingon :
f-0
6.2.6 Execution Engine
The execution engine ﬁres the RHS of the activated rules. Modern rule-based systems
can not only modify, add and remove facts in the working memory but also execute other
instructions. In Jess, a full programming environment is available, including all Java
classes installed.
Both rules are ﬁred in the order chosen by the agenda. They print the following output
to the console:
Raise shields!
Klingon Alert Captain!
6.3 Applications
This Section brieﬂy presents three applications of rule-based systems.
6.3.1 Rule-Based Expert System in the Medical Domain
The "Protocol Assistant" is a rule-based medical expert system used in the domain
parotid tumors. It was developed to assist users either as a wizard that guides a user
through a decision making process or to provide assistance to ﬁnd relevant information on
parotid tumors. It is accessed via a web interface. The Protocol Assistant uses diﬀerent
categories of clinical evidence that are weighted according to their "goodness" [Bri98,
p.1], i.e. the level of quality. By clicking on a decision node, the user is provided with all
the relevant information objects. The authors of the Protocol Assistant point out that
presenting all the relevant information object instead of only most relevant objects, is a
key advantage of their application. The rule-based system used for the Protocol Assistant
is Jess. It was chosen for its good integration with Java [Bri98, p. 7].
6.3.2 Workﬂow Automation
Business processes are likely to be adapted over time to meet the demands in a dynamic
business environment. [KRSR98] propose a rule-based workﬂow coordination approach
to provide the ﬂexibility needed to adapt to change. The system is implemented using an

6.3.
Applications
48
active object-oriented database and Event-Condition-Action (ECA) rules. Implementing
coordination policies in ECA rules permits to codify knowledge independently of concrete
workﬂows and eases modiﬁcation and reusability [KRSR98].
6.3.3 Rule-Based System for Monitoring
The Spaceport Processing Systems Branch is responsible for the Space Shuttle prelaunch
checkout at the NASA’s Kennedy Space Center. The Launch Processing System (LPS)
supports the diﬀerent actors involved in this process. It monitors the space shuttle as
well as ground equipment, control instruments, etc. In total, around 50’000 parameters
are monitored and controled, including temperatures, voltages, pressures, etc. After the
Columbia accident in 2003, it was decided to improve LPS by increasing the insight and
the situation awareness as well as the ability to better monitor contractors. To address this
problem, NASA developed the "NASA Engineering Shuttle Telemetry Agent" (NESTA)
as a complement to the existing LPS. NESTA uses the rule-based system Jess. The data
sources of LPS are distributed over a local network. An agent can be attached to up
to four data sources. An engineer speciﬁes with Jess rules which measurements she is
interested in and what action is executed if a given rule is ﬁred (e.g. send an e-mail or
page the engineer) [SDL+05, p. 1–6].

7
The Jess Rule-Based System
7.1
Running Jess . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
7.2
The Jess Rule Language
. . . . . . . . . . . . . . . . . . . . . .
50
7.3
Working with Java Classes and Objects . . . . . . . . . . . . .
51
7.3.1
Java Objects
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
7.3.2
Java Class Members . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4
Working Memory
. . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4.1
Unordered Facts
. . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4.2
Shadow Facts . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
7.4.3
Ordered Facts . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7.5
Rules
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
7.5.1
Slot Constraints
. . . . . . . . . . . . . . . . . . . . . . . . . .
54
7.5.2
Pattern bindings . . . . . . . . . . . . . . . . . . . . . . . . . .
55
7.5.3
Conditional Elements
. . . . . . . . . . . . . . . . . . . . . . .
55
Jess [12] is a rule-based system shell entirely written in Java. It is developed at the Sandia
National Laboratories in Livermore, California. Jess was inspired by the open-source
expert system shell C Language Integrated Production System (CLIPS). Jess itself is not
open-source, though the source code can be acquired by obtaining a license. Academic
institutions can apply for a license for free and the binaries are available for download
at no cost for 30 days usage [12]. Jess programs are written in the Jess rule language
(a List Processing (LISP) like syntax) or in XML and are interpreted by Jess rule-based
system [11].
This Chapter gives an introduction to Jess.
Further documentation is
available at [12] and [Hil03].
7.1 Running Jess
1 Rete jess = new Rete ( ) ;
Jesp jesp = new Jesp ( " m y r u l e f i l e " ,
jess ) ;
3 jesp . parse ( false ) ;
/ / at some point ,
the Java program needs to
run Jess :
5 jess . run ( ) ;
Code extract 7.1: Using the Jess Java API
49

7.2.
The Jess Rule Language
50
There are several ways to run Jess:
Standalone: Jess can be executed as a standalone program. The Jess instructions are
written in a ASCII ﬁle that is read by the interpreter.
Interactive command-line interface: Jess oﬀers a command-line interface to dynami-
cally write the Jess program.
Java API: Jess is entirely written in Java. It can be embedded in a Java program and
accessed through its Java API. An example of how the Java API of Jess is used
is shown in Code extract 7.1. The object that encapsulates the Jess rule-based
system is instantiated in line 1. The Jess parser object is instantiated in line 2 with
the ﬁle that contains the Jess instructions and the Jess rule-based system object as
argument. To run Jess, the instance method run of the Rete instance is called.
7.2 The Jess Rule Language
The fundamental unit in the Jess rule language are tokens. Tokens can be either symbols,
numbers, strings or comments. Internally, all Jess values are represented by instances of
the jess.Value class [Hil03, p. 43].
Symbols The symbol concept can be compared to identiﬁers in Java. A symbol is a
sequence that can contain letters, numbers, and the following punctuation marks:
$, *, ., =, +, /, <, >, _, ? and #. The ﬁrst character of a symbol may not be a number
or punctuation mark or $, $ and =. These characters may however appear at other
positions in the sequence.
Jess symbols are case sensitive.
Some symbols have
specials meanings: The symbol nil is equivalent to the keyword null in Java, TRUE
and FALSE are boolean values and when printed (e.g. when printing a message on
the console with printout t) crlf will cause carriage return [Hil03, p. 42].
Numbers The Jess parser uses java.lang.Int.parseInt and java.lang.Double.parseDouble to parse
integer and ﬂoating points from values. The types are inferred when the token is
parsed [Hil03, p. 43].
Strings Strings in Jess are denoted using “. Like in Java, embedded quote symbols are
escaped with backslashes. Other escape sequences known in Java are not recognized,
e.g. \n will not cause a carriage return [Hil03, p. 44].
Comments Jess supports two types of comments: LISP-style comments with semicolon
; or C style comment, appearing between the delimiters /* and */ [Hil03, p. 44].
Lists are the basic unit of structures in Jess. They are both a central way of structuring
code and data. A list consists of an enclosing set of parentheses with zero or more tokens
or other lists, e.g.:
1 (+ 1 2)
(+ 1 (∗2 4) )
3 ( p r i n t o u t
t
" hello ,
world ! "
c r l f )
The ﬁrst element of a list is called the head. In many cases, the head of the list is special.
For a function call, the head is the name of the function [Hil03, p. 45–46]. In the example
above, + and printout are the function names, followed by their arguments. The function
list will add 1 and 2, the second ﬁrst multiply 2 by 4 and add the value to 1 and the third
example print hello, world! on the console. Jess has diﬀerent ways of interpreting

7.3.
Working with Java Classes and Objects
51
lists, depending of the context in which they appear. This will be elaborated as this
Section continues.
Programming variables in Jess start with a ?. Unlike variables in Java, Jess variables
are untyped and can thus have any value of any type assigned. A value is assigned to a
variable with the bind function [Hil03, p. 47–48]. The following examples assignees ”Foo
Bar“ to the variable ?x:
1 ( bind ?x "Foo Bar " )
Every variable created at the top-level of a Jess program are cleared when the reset
function is called. reset re-initiates the working memory. To create variables that are not
cleared with reset, Jess oﬀers the possibility of using global variables. Global variables are
created with the defglobal function and must begin and end with a * [Hil03, p. 48–49]. The
following example shows how the string ”bar“ is assigned to the global variable ?*foo*.
With the bind function, new values can be assigned to global variables.
1 ( defglobal ?∗foo∗= " bar " )
In Jess, control ﬂow is handled by functions as well. Jess includes control ﬂow functions
if, while, for, try and foreach [Hil03, p. 50–53]. The listing below shows an if and while
example:
1
( bind ? i
10)
( i f
(> ? i
5) then
3
( p r i n t o u t
t
"Go"
c r l f )
else
( p r i n t o u t
t
" stop "
c r l f ) )
5
( while (> ? i
1)
(−−? i ) )
In this simple example, the integer 10 is assigned to the variable ?i. Because ?i is larger
than 5, Go is displayed on the console. Following that, in the while loop ?i is reduced to 1.
Other control ﬂow are not discussed in this thesis. The reader is invited to consult the
Jess manual at [12].
7.3 Working with Java Classes and Objects
As already mentioned above, a very powerful feature of Jess is the integration with Java.
This Section gives as a basic introduction on how to use the Java API of Jess.
7.3.1 Java Objects
Java objects are instantiated with the new function. The new function creates an object
and returns the pointer of that object that can be assigned to a variable with the bind
function. To avoid typing the full qualiﬁed name of a class, the class can be imported
with the import function [Hil03, p. 63]. Java methods are called with the call function.
For instance methods, call can be omitted [Hil03, p. 64–66]. In the following example,
the Vector class is imported, an object of the Vector class instantiated and a string value
"test" is added to that object by calling its put method:
( import java . u t i l . Vector )
2 ( bind ?v (new Vector ) )
(? v put
" t e s t " )
4 ; or
with
the
c a l l
function
( c a l l
?v put
" t e s t " )

7.4.
Working Memory
52
Jess will automatically convert the type of the argument passed to a Java method to the
so called target type [Hil03, p. 63].
7.3.2 Java Class Members
As mentioned in the previous Section, Java class methods must be called with the
call function.
Class ﬁelds can be read and modiﬁed with get-member respectively set-
member [Hil03, p. 66–70] or, in a Java like syntax, with Member.Field. In the following
example, Math.random is called and Math.PI printed:
1 ( c a l l
Math random)
( p r i n t o u t
t
( Math . PI )
c r l f )
7.4 Working Memory
The working memory, or fact base, contains a set of information objects called facts. Facts
are a core element of Jess since rules only react to facts being added, deleted or changed.
Rules are discussed in Section 7.5. Jess knows three types of facts: pure facts, unordered
facts and shadow facts. The structure of facts are deﬁned by templates (comparable to
Java classes that deﬁne the structure of objects). Templates can be created with the
deftemplate or defclass construct or in some cases, automatically.
This Section discusses the three fact types Jess uses, with a special focus on shadow facts
and a set of commands to manipulate the working memory.
7.4.1 Unordered Facts
Templates for unordered facts are deﬁned with the deftemplate construct followed by the
name of the fact, and zero or more slots. The name of deftemplate is the head of the
facts. Additionally, a deftemplate construct can be described with a description between
two ” [Hil03, p. 82]. In this example, a template is created for bank accounts and one
bank account is loaded into the working memory using assert.
( deftemplate
account
2
( s l o t number )
( s l o t
balance )
4
( s l o t
currency ) )
( assert
( account
( number
211)
( balance 500)
( currency CHF) ) )
The order in which the slots are listed is irrelevant and not every slot has to be used [Hil03,
p. 83].
7.4.2 Shadow Facts
Shadow facts are unordered fact that serve as a bridges between Java objects of the
application that communicates with Jess and the facts in the working memory of the Jess
instance that is used by that application. Its slots corresponds to the properties of the
Java Beans class the shadow fact represents. Shadow facts are however not the objects
themselves but “shadows” of the objects in the application. Shadow fact templates can
be created automatically by telling Jess that a given template is derived from a given

7.5.
Rules
53
Java class.
The following example explains how shadow facts are used. It consists of a Java Bean
Notebook that has two ﬁelds which are accessed through getters and setters.
1 public class Notebook implements S e r i a l i z a b l e
{
private
String hostname ;
3
private
String
type ;
5
public void setHostname ( String hostname )
{ this . hostname = hostname ; }
public
String getHostname ( )
{ return
this . hostname ; }
7
public void setType ( String
type )
{ this . type = type ; }
public
String
getType
( )
{ return
this . type ; }
9 }
Jess oﬀers two possibilities to connect a Java class to a Jess template:
1
( deftemplate Notebook ( declare
( from−class Notebook ) ) )
; or
3 ( defclass Notebook Notebook )
The slots do not have to be speciﬁed, Jess uses the java.beans.Introspector API to obtain
the properties. To add a shadow fact from within the Java application that uses Jess,
the add method of the Rete object is called. This example assumes that the Rete object
is jess:
1 Notebook nb = new Notebook ( ) ;
nb . setHostname ( " Galadriel " ) ;
3 nb . setType ( " Thinkpad " ) ;
jess . add ( nb ) ;
To add a shadow fact from within Jess, a Java object ﬁst has to be instantiated and
added to the working memory:
( bind ?n (new Notebook ) )
2
( add ?n )
; or
4
( definstance Notebook (new Notebook )
To synchronize a Java object with its shadow fact, the update method is used.
update
takes a reference of a shadow fact as argument.
7.4.3 Ordered Facts
Ordered facts are ﬂat lists. They do not have a structure of named ﬁelds deﬁned by a
template. Thus the order of the values matters, e.g.:
( l o c a t i o n
"N 51:25:07.4 "
"W 124:01:50.7 " )
7.5 Rules
Jess supports both forward-chaining and backward-chaining rules (brieﬂy described in
Section 6.1). Every time changes to the working memory occur (a fact is added, modiﬁed
or removed), activation records for the rules that match the aﬀected facts are added to
or removed from the agenda (see Section 6.2.5). Thus the pattern matching of the LHS
of a rule to a fact is performed at this stage, not when the rule is ﬁred. The RHS of
the activated rules in the agenda are ﬁred one at the time when the run command is
issued. [Hil03, p. 96–98].

7.5.
Rules
54
Rules are created with the defrule, followed by a symbol that is the name of the rule and
an optional documentation string. The => symbol separates the LHS from the RHS. It
can be read as then. The LHS consists of zero or more conditions and the RHS of zero
or more actions.
7.5.1 Slot Constraints
In most cases, a set of constraints describe which conditions facts must satisfy to activate
the given rule. Jess oﬀers (i) Literal constraints (ii) Variable constraints (iii) Connective
constraints (iv) Predicate constraints (v) Return value constraints.
Each constraint type
is brieﬂy introduced in the following Sections.
Literal constraints
Literal constrains specify which exact slots values a fact must have to satisfy this con-
straints [Hil03, p. 101], e.g.:
1
( person
(name " jon doe " )
( age 40) ) )
This pattern matches facts of the type person with the name “jon doe” and age 40.
Variable constraints
Variable constraints bind matched values to variables. These variables are accessible in
the scope of the rule [Hil03, p. 102]. The same variable can appear in several patterns
but must contain the same value, e.g.:
1 ( person
(name ?n ) )
Connective constraints
Literal values and variables can be connected with the connective constraints. In a single
expression, several connective constraints can be combined. the connective constraints
are & and, | or and
not [Hil03, p. 110–111]. e.g.:
1 ( console
( output
" hello " | " world " ) )
This test is true for console facts that contain an output slot with either the value "hello"
or "world".
Predicate constraints
Predicate constraints permit to use predicate functions (any boolean function that returns
either TRUE or FALSE). A predicate function has to be preceded by a :. To apply the
predicate function to the value of a slot, the value has to be bound to a variable with the
& connective [Hil03, p. 105–106], e.g.;
1 ( product
( price ?p&: (> ?p 100) ) )
This matches any product that has a price higher than 100.

7.5.
Rules
55
Return value constraints
Return value constrains are used to compare the return value of a function to the value
of a slot [Hil03, p. 106–107], e.g.:
1 ( product
( price ?p =(∗2 50) ) )
This matches product facts that have price slot with the value 100.
7.5.2 Pattern bindings
Pattern bindings is used to save a pointer to a fact that has been matched in the LHS of
a rule to a variable. This permits to manipulate the fact with functions retract, modify or
duplicate in the RHS of the rule [Hil03, p. 107], e.g.:
1
( defrule bind−me
?a <−( f a c t )
3
=>
( r e t r a c t ?a ) )
In this example, the rule matches every fact of the type fact, saves a pointer to the current
fact in variable ?a and removes it from the working memory.
7.5.3 Conditional Elements
While slot constrains are applied to the values of individual facts, conditional elements
permit to group patterns for matching entire facts and relationships between facts. One
conditional element, test, does not imply facts at all. Each conditional element is brieﬂy
explained in this Section.
"and" Conditional Element
The and conditional element can enclose a number of patterns that all have to be matched
for the and conditional element to be valid [Hil03, p. 107], e.g.:
( defrule
and−rule
2
(and ( system−up )
( network−working ) )
4
=>)
This rule ﬁres only if a fact of the type system-up and a fact of the type network-working
are in the working memory.
"or" Conditional Element
The or conditional element encloses a list of patterns, of which at least one has to be
matched for it to be true [Hil03, p. 108], e.g.:
( defrule
or−rule
2
( or ( f l i g h t −a v a i l a b l e )
( car−available ) )
=>)
This rule ﬁres if at least a ﬂight-available fact or a car-available is in the working memory.

7.5.
Rules
56
"not" Conditional Element
The not conditional element applies to the nonexistence of a fact in the working mem-
ory [Hil03, p. 112]. Two examples following examples shall bring clarity:
1
( defrule on−remove
( not ( network−working ) )
3
=>)
5
( defrule
o n l y −f l i g h t
( f l i g h t
( number ?n ) )
7
( not ( t r a i n ) )
=>)
The ﬁrst rule ﬁres if a network-working fact is removed from the working memory. The
second rule ﬁres if there is a ﬂight fact in the working memory but not a train fact.
"exists" Conditional Element
The exists conditional element is true if there exists a fact that matches its pattern in the
working memory [Hil03, p. 112], e.g.:
( defrule
check−flight
2
( exists
( f l i g h t
( destination
" Vancouver " ) ) )
=>)
This rule ﬁres if there is at least one fact in the working memory of the type ﬂight with
the string value Vancouver as the value of its slot destination.
"test" Conditional Element
A test conditional element does not evaluate a pattern that matches a fact. Instead, it
matches against a boolean function.
1
( defrule
t e s t
( t e s t
(eq (+ 1 1) )
2)
3
=>)
This pattern is independent of any facts. It will always evaluate to true. According
to [10], the test conditional element is used "when there is no preceding pattern, or with
time-varying return values" [10].
"logical" Conditional Element
The logical conditional elements deﬁnes dependencies between a fact matched in the LHS
of a rule with a fact asserted in the RHS of the same rule. The depending fact is also
removed when the fact it logically depends is retracted from the working memory [Hil03,
p. 115], e.g.:
1 ( defrule
logical−test
( l o g i c a l
( foo ) )
3
=>
( assert
( bar ) ) )
5
( bind ?x ( assert
( foo ) ) )
7
==> f−0 (MAIN : : foo )
<Fact−0>
9
( run )
==> f−1 (MAIN : : bar )

7.5.
Rules
57
11 1
( facts )
13 f−0
(MAIN : : foo )
f−1
(MAIN : : bar )
15 For a
t o t a l
of 2 facts
in module MAIN.
( r e t r a c t ?x )
17
<== f−0 (MAIN : : foo )
<== f−1 (MAIN : : bar )
19 ( facts )
For a
t o t a l
of 0 facts
in module MAIN.
This example shows how a logical fact is removed when the fact it depends on is retracted
from the working memory.

Part III
Implementation
58

8
Jess and JADE Integration: The
Matrix Example
8.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
8.1.1
Agent Organization . . . . . . . . . . . . . . . . . . . . . . . . .
61
8.1.2
Agents Environment . . . . . . . . . . . . . . . . . . . . . . . .
61
8.2
The Matrix Workﬂow . . . . . . . . . . . . . . . . . . . . . . . .
63
8.2.1
State of a Matrix Agent in Jess . . . . . . . . . . . . . . . . . .
63
8.2.2
Implementation of The Matrix Workﬂow With Jess . . . . . . .
64
8.3
Agents Communication . . . . . . . . . . . . . . . . . . . . . . .
69
8.3.1
Agent Interaction . . . . . . . . . . . . . . . . . . . . . . . . . .
70
8.3.2
The Matrix Ontology . . . . . . . . . . . . . . . . . . . . . . . .
73
8.3.3
Using the Communication Conﬁguration Factory . . . . . . . .
75
8.4
Agent Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
8.4.1
Internal Behaviors
. . . . . . . . . . . . . . . . . . . . . . . . .
77
8.4.2
Communicational Behaviors . . . . . . . . . . . . . . . . . . . .
77
8.5
Software Agents
. . . . . . . . . . . . . . . . . . . . . . . . . . .
80
8.5.1
TheMatrixAgent . . . . . . . . . . . . . . . . . . . . . . . . . .
80
8.5.2
Slave Agents
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
8.5.3
Master Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
8.5.4
Jess Administration Agent . . . . . . . . . . . . . . . . . . . . .
83
8.1 Introduction
The Matrix was developed to explore the possibility of using Jess in a multi-agent system
to manage the decision making and working memory of an intelligent agent. The idea of
the Matrix is based on the "The Matrix Trilogy" [30] movies. At one point in the second
movie, the main character Neo, who is the Chosen One, has to ﬁght a set of hostile agents
Smiths that try to kill him. This prototype "replays" this combat. It prints the results
59

8.1.
Introduction
60
Figure 8.1: The results of a combat between one Chosen One agent and two Smith agents
of the combat to the console and to every remote Jess Administration agent, shown in
Figure 8.1 (see Chapter 9 for details on remote Jess Administration). The reader is in-
vited to test the Matrix by following the instructions in Appendix C.
The agents participating in the Matrix form a master/slave hierarchy. The master agent
is called "Oracle agent". It manages and coordinates activities between all slave agents.
It is fully aware of its environment and of each agent’s state. The intelligence of the
Oracle agent is handled by Jess. Instead of hard-coding the business logic in Java as
JADE agent behaviors, JADE is merely used for the agent communication: JADE ba-
sically accepts a message and passes the content of the message to Jess. Based on the
current information obtained of its environment and what it has "learned" in the past,
Jess reasons about the future actions it must take. This could be simply storing the data
it obtained or ask the Oracle agent to send a message to one of its slaves. The multi-agent
environment is depicted in Figure 8.2. The Jess Administration domain, used to manage
the Jess instance of the master agent, is discussed in Chapter 9.
This Chapter explains how the Jess 2 JADE (J2J) tool kit (elaborated in details in
Chapter 10) developed for this thesis, can be used to support process automation. The
rest of this Section describes the coordination among the agents and the agent environ-
ment.
Section 8.2 gives a detailed description of Jess rules developed to manage the
Matrix environment. Agent communication related aspects are described in Section 8.3
followed by Section 8.4 in which agent behaviors and the conversations they support are
described. Section 8.5 closes this Chapter with a discussion on the agent classes of the
Matrix environment.

8.1.
Introduction
61
Figure 8.2: The multi-agent environment
8.1.1 Agent Organization
The coordination among the agents is based on the Organizational structuring approach:
The master agent, in this context referred to as the "Oracle agent", manages information
about each agent. It is fully aware of its environment and coordinates and assigns tasks
to slave agents to ensure that the system is in a coherent state. The other agents are
purely reactive (agent architectures are introduced in Section 4.2). They do not keep a
state of their own and do not have any sort of intelligence. Thus every action executed
by a slave agent, except for looking up the "Oracle agent" with the DF and asking for
its ﬁrst action, is coordinated by the Oracle agent. A third type of agent that does not
directly take part in the process executed by the Oracle agent and its slaves is the Jess
Administration agent (discussed in Section 9.2). It is not required for the Matrix to run
but oﬀers a useful interface to access and manage the Jess rule-engine of the "Oracle
agent" and to view the ontology that is used by the "Oracle agent" and its slaves to
communicate.
8.1.2 Agents Environment
The agents’ environment is, based on the deﬁnition of [RN03, p. 39], "artiﬁcial". Their
percepts are messages from other agents and for some agents keyboard input and mouse
clicks. They act on the environment by sending messages to other agents or by writing

8.1.
Introduction
62
the output to an output device such as the console. As stated above, this environment
has two distinct types of agents, reactive agents and one intelligent agent. For both types,
the environment from their perspective is described according to the dimensions cited in
Section 4.1.2.
Master Agent’s Environment
From the perspective of the Oracle agent, the environment is:
• Partially observable The Oracle agent cannot obtain all information that are
relevant for deciding which action it should execute next through its sensors. This
is because other agents do not keep a state of their own. Thus the Oracle agent
must keep an internal state to keep track of its environment.
• Strategic The environment is deterministic (the next state of the environment
depends on the current state of the environment and the master agent’s next action).
It is strategic however because other agents’ action (currently only a administrator
agent for the Oracle agent) can also have an inﬂuence on the environment.
• Sequential The environment is sequential because the Oracle agent’s current de-
cision depends on events and decisions made in the past, not only on the current
state of the environment.
• Dynamic The environment can change in the course of time: New agents can be
added that have to be taken into consideration, software and hardware failure may
make part of the environment unavailable, etc.
• Continuous The environment has no deﬁned limited amount of states, the agent
can take a continuous set of actions and over a continuous time period.
• Multi-agent From the Oracle agent’s point of view, it is a cooperative multi-agent
system.
The Oracle agent does not compete with other agents to maximize its
performance measurements.
Slave Agent’s Environment
From a slave agent’s point of view, the environment is:
• Fully observable A slave agent keeps no inner state, it can perceive all information
it needs to act from its environment since it gets its instructions from a master agent.
• Stochastic The next state of the environment may not depend on the current state
of the environment and the agent’s action.
• Episodic The agent perceives information from its environment and acts upon it,
it does not include percepts made in the past to inﬂuence the current decision.
• Dynamic The agent constantly receives input from its environment on which it
has to act.
• Mainly discrete The set of actions available to the agent are ﬁnite as well as the
percepts from its environment.
• Multi-agent A slave agent is in a competitive multi-agent system. Slave agent’s
compete for orders from the Oracle agent and to survive the combat.

8.2.
The Matrix Workﬂow
63
8.2 The Matrix Workﬂow
The ﬁght between the agents that are at enmity with each other executes the processes
depicted in the UML Activity Diagrams of Figure 8.4 and Figure 8.5. The message ﬂow
between the participating agents for the same processes are depicted with the Sequence
Diagrams of Figure 8.6 and Figure 8.7.
When launched, every agent registers itself
with the Oracle agent. The Oracle agent will decide on the agents strength, health and
armor and assign the agent to its potential opponents (i.e. (Smith1, Chosen One) tuple).
When the agent has received the conﬁrmation that it has been registered, it will send a
Command Me request to ask the Oracle agent what it is supposed to do next. If the agent
is still alive (only the Oracle agent knows that), the agent will receive a Wait and wait
for further instructions. If the agent has opponents, the agent will get the order to attack
one of his opponents. The attacking agent then sends a message to its victim saying it
has been attacked, upon which the victim will ask the Oracle agent what it should do
(again with Command Me). If the agent is dead (the Oracle agent has sent Die), the
agent also waits but will not be contacted in the future by the Oracle agent. If there are
still opponents left that are alive, the Oracle agent will pick another agent and order it
to attack its opponent. This process ends when either all Smith agents are terminated or
the Chosen One agent has been beaten.
8.2.1 State of a Matrix Agent in Jess
Registered
Dead
Attacked
Waiting
Attacking
Trained
when (healthstate < 0)
receiving attack orders
done
getting attacked
when (healthstate > 0)
get attributes
Figure 8.3: Phases in a slave agent’s life
All agents known to Jess are slave agents of the type CombatAgent. They each have the
same comportment. A slave agent’s life phases are shown in the UML State Diagram of
Figure 8.3. It passes through the following phases: At ﬁrst the agent is registered. This is
followed by a "training session" during which the agent receives its attributes healthstate,
armor and power. It is then ready and waits. In this state, it can obtain orders to attack
an other agent or be attacked itself. When it is attacked, its healthstate may be reduced.
If the agent is still alive, it waits again, otherwise it dies and terminates.

8.2.
The Matrix Workﬂow
64
8.2.2 Implementation of The Matrix Workﬂow With Jess
This Section discusses the Jess rules that implement the process. Each Jess rule managed
by the Oracle agent’s Jess instance is shown in this Section. They are mapped to their
corresponding activities in the Activity Diagrams in Figure 8.4 and Figure 8.5.
Initialization Workﬂow
Oracle agent
Find Me!
Assign
Opponent
Train
new Agent
Find Me!
Combat Agent
 [0 < opponent not yet assigned]
 [all opponents assigned]
Figure 8.4: Initialization Workﬂow
When agent ﬁrst registers itself with the Oracle agent, its properties are empty. The
Oracle agent "discovers" the agent’s property by training it and associates the new agent
with its opponents. This workﬂow is shown in Figure 8.4. The Activity Diagram does
not show the data used for the process. Each action is described in the remaining of this
Section.
• Train new Agent When an agent is newly added to the working memory, its
properties are not set. The Oracle agent "trains" the agent to make it ready for
combat. The values are chosen randomly. A Chosen One agent is better trained
than a Smith agent, otherwise it would not be able to ﬁght a large number of Smith
agents.
( defrule MAIN : : train−agent−smith
2
?newbie <−(SmithAgent
( power 0.0)
( healthstate
0.0)
( armor 0.0) )
=>
4
( modify ?newbie
( power (+
(∗
( c a l l
Math random)
20.0)
5.0) )
6
( healthstate
(+
(∗
( c a l l
Math random)
10.0)
5.0) )
( armor (+
(∗
( c a l l
Math random)
10.0)
5.0) ) )
8
( p r i n t o u t
t
"new agent smith "
c r l f )
( focus INIT−SYS) )
10

8.2.
The Matrix Workﬂow
65
( defrule MAIN : : train−agent−chosenone
12
?newbie <−(ChosenOne ( power 0.0)
( healthstate
0.0)
( armor 0.0) )
=>
14
( modify ?newbie
( power (+
(∗
( c a l l
Math random)
30.0)
10.0) )
16
( healthstate
(+
(∗
( c a l l
Math random)
90.0)
40.0) )
( armor (+
(∗
( c a l l
Math random)
10.0)
6.0) ) )
18
( p r i n t o u t
t
"new agent neo "
c r l f )
( focus INIT−SYS) )
Code extract 8.1: Train new agent
• Assign Opponent After an agent is trained, relations between the new agent and
its opponents are set.
1 ( defrule INIT−SYS : : set−opponent
?neo <−(ChosenOne ( agentName ?con )
( healthstate ?hsc&: (> ?hsc 0) ) )
3
?smith <−(SmithAgent
( agentName ?sn )
( healthstate ?hss&: (> ?hss 0) ) )
( not ( Attackable
(badGuy ?sn )
( goodGuy ?con ) ) )
5
=>
( assert
( Attackable
(badGuy ?sn )
( goodGuy ?con ) ) )
7
( p r i n t o u t
t
"New opponents :
badguy
i s
" ?sn " and goodguy " ?con
c r l f ) )
Code extract 8.2: Assign opponents
Main workﬂow
The UML Activity Diagram of Figure 8.5 depicts the workﬂow during which Combat
agents ﬁght each other. The data used by the activities are mostly omitted to avoid
bloating the diagram.
• Check Agent’s Health Depending on whether or not there is a Killed fact in the
working memory assigned to the agent that has sent the current CommandMe, the
agent is going to wait or die.
1 ( defrule AGENT−FATE: : agent−alive
; entry
point
i f
agent
i s
a l i v e
?cm <−(CommandMe ( slave ?s ) )
3
?agent <−( CombatAgent ( agentName ?s )
{ healthstate > 0})
=>
5
( p r i n t o u t
t
" agent
" ?s "
i s
g e t ti n g a wait "
c r l f )
( assert
( Wait
( slave ?s )
( secret
" " ) ) )
7
( return ) )
9 ( defrule AGENT−FATE: : agent−dead
; entry
point
i f
agent
i s dead
?cm <−(CommandMe ( slave ?s )
( secret ?sc ) )
11
?agent <−( CombatAgent ( agentName ?s )
)
( exists
( Attackable
{badGuy == ?s
| |
goodGuy ==?s } ) )
13
( K i l l e d
( victim ?s ) )
=>
15
( assert
( Die
( slave ?s )
( secret ?sc ) ) )
( focus CLEANUP) )
Code extract 8.3: Check agent’s health
• Remove Opponent Relations for Killed Agent A dead agent cannot partic-
ipate in the ﬁght. Therefore, all relations to its opponents are removed from the
working memory.
( defrule CLEANUP: : cleanup−attackable−smith
2
?die <−( Die
( slave ?v ) )
? attackable <−(Attackable
(badGuy ?v ) )
4
=>
( r e t r a c t ? attackable )
6
( p r i n t o u t
t
" r e t r a c t i n g
s ett in g s
f o r
smith
" ?v
c r l f ) )

8.2.
The Matrix Workﬂow
66
Die!
Remove 
Opponent Relations
For Killed Agent
Command Me!
Check
Agent's Health
Select
new Attacker
Opponent
Killded
Attack!
attack
Set
Key Secret
key
Assert
Key
key
Assert
Attack
attack
Opponent
Still Alive
Wait
Wait
You have been attacked!
You have been attacked!
Command Me!
Attack!
Die!
Oracle Agent
Combat Agent
Reduce
Opponents Life
 [agent killed]
 [agent has wrong key]
 [key exists]
 [opponents left]
 [agent alive]
 [opponents < 0]
 [opponents > 0]
 [no opponents left]
 [key not exist]
 [agent has correct key]
 [opponent's healthstate > 0]
 [opponent's healthstate < 0]
Figure 8.5: Main Workﬂow
8 ( defrule CLEANUP: : cleanup−attackable−neo
?die <−( Die
( slave ?v ) )
10
? attackable <−(Attackable
( goodGuy ?v ) )
=>
12
( r e t r a c t ? attackable )
( p r i n t o u t
t
" r e t r a c t i n g
s ett in g s
f o r neo " ?v
c r l f ) )
Code extract 8.4: Remove opponent relations for killed agent
• "Assert Key" and "Set Key Secret" If no key is yet created, a Key fact is added
to the working memory and a secret is assigned to the key. The key is basically a
token that an agent must possess to receive orders to attack.
1 ( defrule AGENT−FATE: : assert−key−fact
; only
create a key
i f
a
f i g h t
i s
possible
(CommandMe ( slave ?s ) )
3
?agent <−( CombatAgent ( agentName ?s )
( healthstate ?hsc&: (> ?hsc 0) ) )
( exists
( Attackable
{badGuy == ?s
| |
goodGuy ==?s } ) )
5
( not ( Key ) )

8.2.
The Matrix Workﬂow
67
=>
7
( p r i n t o u t
t
"
asserting key "
c r l f )
( assert
( Key ( secret
" i l l u m i n a t i " ) ) )
9
( focus FIRST−KEY−ASSIGNMENT) )
11 ( defrule FIRST−KEY−ASSIGNMENT : : assign−key
?cm <−(CommandMe)
13
?key <−( Key ( secret ?sc ) )
=>
15
( p r i n t o u t
t
" assigning new secret "
c r l f )
( modify ?cm ( secret ?sc ) )
17
( return ) )
Code extract 8.5: Add new key to the working memory
• Wait Every agent that is alive (i.e. its healthstate is higher than 0) is ordered to
Wait.
1 ( defrule LIFE−STATE : : send−wait−neo
( declare
( auto−focus TRUE) )
3
( Key ( secret ?sc ) )
(CommandMe ( slave ?s )
{ secret == ?sc } )
5
(ChosenOne ( agentName ?s )
( healthstate ?hscc &: (> ?hscc 0) ) )
( SmithAgent
( agentName ?sa )
( healthstate ?hscs &: (> ?hscs 0) ) )
7
( Attackable
( goodGuy ?s )
(badGuy ?sa ) )
?w <−( Wait
( slave ?s ) )
9
=>
( p r i n t o u t
t
" Sending
l i f e s t a t e
to
agent
" ?s
c r l f )
11
(command−agent ?w ?s )
( return−fact−to−current−behaviour ?w)
13
( r e t r a c t ?w)
( clear−focus−stack )
15
( focus DETERMINE−COMBAT) )
17 ( defrule LIFE−STATE : : send−wait−smith
( declare
( auto−focus TRUE) )
19
( Key ( secret ?sc ) )
(CommandMe ( slave ?s )
{ secret == ?sc } )
21
( SmithAgent
( agentName ?s )
( healthstate ?hscs &: (> ?hscs 0) ) )
(ChosenOne ( agentName ?co )
( healthstate ?hscc &: (> ?hscc 0) ) )
23
( Attackable
(badGuy ?s )
( goodGuy ?co ) )
?w <−( Wait
( slave ?s ) )
25
=>
( p r i n t o u t
t
" Sending
l i f e s t a t e
to
agent
" ?s
c r l f )
27
(command−agent ?w ?s )
( r e t r a c t ?w)
29
( clear−focus−stack )
( focus DETERMINE−COMBAT) )
31
( defrule LIFE−STATE : : wrong−key
33
( declare
( auto−focus TRUE) )
?cm <−(CommandMe ( slave ?s )
( secret ?sc ) )
35
( CombatAgent ( agentName ?s )
( healthstate ?hscca &: (> ?hscca 0) ) )
( Key { secret
!= ?sc }
( secret ?ssc ) )
37
?w <−( Wait
( slave ?s ) )
=>
39
( p r i n t o u t
t
" agent
" ?s " has the wrong key .
presented
" ?sc "
expected
" ?ssc
c r l f )
(command−agent ?w ?s )
41
( r e t r a c t ?w)
( r e t r a c t ?cm)
43
( h a l t ) )
Code extract 8.6: Wait
• Die An agent that had been killed previously by another agent is sent a Die order. If
there are no more agents left that can ﬁght each other, the workﬂow is terminated.
1 ( defrule LIFE−STATE : : send−die
( declare
( auto−focus TRUE) )
3
?d <−( Die
( slave ?s ) )

8.2.
The Matrix Workﬂow
68
( not ( Attackable
{goodGuy == ?s
| |
badGuy == ?s } ) )
5
( exists
( Attackable ) ) ;
there
are
s t i l l
opponents
l e f t
( exists
( SmithAgent
( healthstate ?hscs &: (> ?hscs 0) ) ) )
7
( exists
(ChosenOne ( healthstate ?hscc &: (> ?hscc 0) ) ) )
=>
9
(command−agent ?d ?s )
( p r i n t o u t
t
" dying
information
sent
to
" ?s
c r l f )
11
( clear−focus−stack )
( focus DETERMINE−COMBAT) )
13
( defrule LIFE−STATE : : send−die−end−of−combat
15
( declare
( auto−focus TRUE) )
?d <−( Die
( slave ?s ) )
17
?cm <−(CommandMe ( slave ?s ) )
( or
19
( not (ChosenOne ( healthstate ?hscc &: (> ?hscc 0) ) ) )
( not ( SmithAgent
( healthstate ?hscs &: (> ?hscs 0) ) ) ) )
21
=>
(command−agent ?d ?s )
23
( r e t r a c t ?d )
( r e t r a c t ?cm)
25
( p r i n t o u t
t
" dying
information
sent
to
" ?s " i t ’ s
f i n a l l y
over now"
c r l f )
( h a l t ) )
Code extract 8.7: Die
• Assert Attack and Select new Attacker If the agent that has sent CommandMe is
dead, a totally new opponents pair has to be found (rule attack-after-die). Otherwise,
the agent that has sent the CommandMe is considered to be the attacker and a new
opponent is assigned to it.
( defrule DETERMINE−COMBAT: : attack−for−neo
2
?cm <−(CommandMe ( slave ?s )
( secret ?sc ) )
?key <−( Key ( secret ?sc ) )
4
?neo <−(ChosenOne ( agentName ?s )
( power ?p ) )
?smith <−( SmithAgent
( agentName ?sn )
( healthstate ?hscs &: (> ?hscs 0) ) )
6
?at <−( Attackable
( goodGuy ?s )
(badGuy ?sn ) )
( not ( K i l l e d
( victim ?s )
( k i l l e r
?sn ) ) )
8
=>
( p r i n t o u t
t
"New f i g h t
between " ?s " and " ?sn "
the
secret
i s " ?sc
c r l f )
10
( assert
( Attack
( victim ?sn )
( attacker ?s )
( strength ?p )
( secret ?sc ) ) )
( r e t r a c t ?cm)
12
( return ) )
14 ( defrule DETERMINE−COMBAT: : attack−for−smith
?cm <−(CommandMe ( slave ?s )
( secret ?sc ) )
16
?key <−( Key ( secret ?sc ) )
?neo <−(ChosenOne ( agentName ?sn )
( power ?p )
( healthstate ?hscc &: (> ?hscc 0) ) )
18
?smith <−( SmithAgent
( agentName ?s ) )
?at <−( Attackable
( goodGuy ?sn )
(badGuy ?s ) )
20
( not ( K i l l e d
( victim ?s )
( k i l l e r
?sn ) ) )
=>
22
( p r i n t o u t
t
"New f i g h t
between " ?s " and " ?sn "
the
secret
i s " ?sc
c r l f )
( assert
( Attack
( victim ?sn )
( attacker ?s )
( strength ?p )
( secret ?sc ) ) )
24
( r e t r a c t ?cm)
( return ) )
26
( defrule DETERMINE−COMBAT: : attack−after−die
; only
smiths can die
without
the process
stopping
28
?d <−( Die
( slave ?slave ) )
?cm <−(CommandMe ( slave ?slave ) )
30
( Key ( secret ?sc ) )
?neo <−(ChosenOne ( agentName ?s )
( power ?p )
( healthstate ?hscc &: (> ?hscc 0) ) )
32
?smith <−( SmithAgent
( agentName ?sn )
( healthstate ?hscs &: (> ?hscs 0) ) )
?at <−( Attackable
( goodGuy ?s )
(badGuy ?sn ) )
34
=>
( p r i n t o u t
t ?slave
"
died New f i g h t
between " ?s " and " ?sn "
the
secret
i s " ?sc
c r l f
)
36
( assert
( Attack
( victim ?sn )
( attacker ?s )
( strength ?p )
( secret ?sc ) ) )
( r e t r a c t ?cm)

8.3.
Agents Communication
69
38
( r e t r a c t ?d )
( return ) )
Code extract 8.8: Assert an attack fact and select new attacker
• Attack! The newly asserted Attack fact is sent to the agent that is is set as the
attacker.
1 ( defrule COMBAT−INIT : : enter−combat
( declare
( auto−focus TRUE) )
3
?a <−( Attack
( attacker ?at )
( secret ?s ) )
=>
5
(command−agent ?a ?at ) )
Code extract 8.9: Attack!
• Reduce Opponents Life The victim’s healthstate is reduced by the amount the
attack exceeds its armor level.
1 ( defrule COMBAT−INIT : : execute−attack
( declare
( salience −100) )
3
?a <−( Attack
( attacker ?at )
( vi ctim ?v )
( strength ? st ) )
?ca <−( CombatAgent ( agentName ?v )
( healthstate ?hs )
( armor ?ar ) )
5
=>
( p r i n t o u t
t
" Reducing
l i f e
of
agent
" ?v "
to
" (−(+ ?hs ?ar ) ? st )
c r l f )
7
( modify ?ca ( healthstate (−(+ ?hs ?ar ) ? st ) ) )
( focus COMBAT) )
Code extract 8.10: Reduce opponents life
• Opponent Killed If the opponent is killed, a Killed fact that contains a reference
to the victim, is set. When the victim sends a CommandMe fact, it will be notiﬁed
that it has died.
( defrule COMBAT: : agent−killed
2
( CombatAgent { healthstate <= 0 }
( agentName ?v ) )
?a <−( Attack
( victim ?v )
( strength ? st )
( attacker ?at ) )
4
=>
( r e t r a c t ?a )
6
( p r i n t o u t
t
" Agent " ?v " has died , he
w i l l
be
n o t i f i e d
soon "
c r l f )
( assert
( K i l l e d
( victim ?v )
( k i l l e r
?at ) ) ) )
Code extract 8.11: Opponent killed
• Opponent Still Alive If the attack was not strong enough to kill the opponent,
the opponent remains in the system and will be the attacker next time it sends a
CommandMe with the valid key.
1 ( defrule COMBAT: : agent−still−alive
( CombatAgent ( healthstate ?hsc&: (> ?hsc 0) )
( agentName ?name) )
3
?a <−( Attack
( victim ?v )
( strength ? st )
( attacker ?at ) )
=>
5
( p r i n t o u t
t
" Agent " ?name "
i s
s t i l l
a l i v e "
c r l f )
( r e t r a c t ?a ) )
Code extract 8.12: Opponent still alive
8.3 Agents Communication
The communication between agents in the Matrix is fully compliant with the FIPA stan-
dard. The content is based on clear deﬁned semantics. Agents’ behaviors used in this

8.3.
Agents Communication
70
thesis extend the FIPA-protocol classes provided by the JADE framework. Each behavior
pair (for the initiator and the participant) handles exactly one agent action type. Hence
a sequence of tests inside a behavior to determine which operations have to be executed,
can be omitted. Instead, each behavior on the participant’s side uses a message template
that is tailored to a given action with a given FIPA-protocol and message performative.
The diﬀerent aspects of communications between agent are discussed in this Section.
8.3.1 Agent Interaction
The agent interaction in the context of the Matrix main workﬂow can be divided into two
phases, as already discussed in Section 8.2. Both steps are discusses below with focus on
the messages the agents send. The reader shall note two distinctions from UML standard
sequence diagrams:
• They do not represent objects sending messages to each other but agents commu-
nicating. This is more coarse grained and is caused by several objects that have to
communicate.
• Additionally, the signals contain performatives (Request) and in parenthesis the
action the receiving agent is to execute, not, as it is normally shown in Sequence
Diagrams, method calls and parameters.
Agent Initialization
OracleAgent : OracleAgent
Neo : ChosenOneAgent
DirectoryFacilitator
Request(register)
1: 
inform(Result)
6: 
Request(search)
3: 
Request(FindMe)
5: 
Inform(Done)
2: 
Inform(Result)
4: 
Figure 8.6: Slave agent registration process
Figure 8.6 shows the set of messages sent when an agent registers itself. With message
1, the Oracle agent registers itself with the DF.
It can now be looked up by other
agents in the environment. Message 3 is the query the slave agent sends to the DF to

8.3.
Agents Communication
71
( ( action
2
( agent−identifier
:name OracleAgent@wlan−per21−244−231 . u n i f r . ch :1099/JADE
4
: addresses
( sequence http : / / wlan−per21−244−231 . u n i f r . ch :7778/ acc ) )
6
( FindMe
: newAgent
8
(ChosenOne
: agentName Neo@wlan−per21−244−231 . u n i f r . ch :1099/JADE
10
: power 0.0
: healthstate
0.0
12
: armor
0.0)
: master OracleAgent@wlan−per21−244−231 . u n i f r . ch :1099/JADE) ) )
Code extract 8.13: Content of a FindMe message
look up the Oracle agent. The fourth message is the reply that contains the requested
data.
If the Oracle agent is not yet online, the result in the reply would be empty.
The slave agent would try the lookup again at a later point in time.
Now that the
slave agent has the Oracle agent’s Uniform Resource Identiﬁer (URI), it sends a FindMe
message to tell the Oracle agent to register it and to decide on its properties, namely
the power, healthstate and armor. An example of a FindMe message content is shown
in Code extract 8.13. The Oracle agent replies to this message by returning the slave
agent’s attributes it "found" (actually generated randomly). The reader may note that
the agent action FindMe is not used directly in the content of the message but inserted in
an action construct. The SL content language requires that agent actions are inserted into
an instance of a jade.content.onto.basic.Action class that associates the agent action with the
AID (ﬁeld agent-identiﬁer) of the agent that is to perform the action [BCG07, p. 87]. The
creation of messages is discusses in Section 10.2. The ontology used in this domain is
presented in Section 8.3.2.
Main Process
A simple scenario of the main workﬂow with two agents is shown in Figure 8.7. First, the
Smith1 agent sends a CommandMe message to the Oracle agent (ﬁrst message). The Oracle
agent conﬁrms that it has received the request (message 2) and sends a Wait (message 3).
Smith 1 conﬁrms that it has processed the message (message 4). In this case, the Oracle
agent does not send any further instructions to Smith1. This is because no opponent
has yet been registered. The registration process of Neo is done with messages 5 and 6,
as discussed in the Section above. Agent Neo sends a CommandMe action in message 7,
which is conﬁrmed by the Oracle agent. The situation now is the following: the Oracle
agent is aware that there are two opponents, both with health levels above 0 and there is
no current combat ongoing. It still sends a Wait message to Neo, which is directly followed
by an Attack message (message 9 and 10). The communication is asynchronous and in this
situation it is not important for the Oracle agent to wait for the conﬁrmation that agent
Neo has processed the Wait action. The slave agent Neo conﬁrms both former messages
with messages 11 and 12. Neo reacts to the Attack message by informing Smith1 that it
has been attacked with a UveBeenAttacked message. This message contains the token (not
shown in Figure 8.7) needed to be recognized by the Oracle agent as the agent replying
to the attack (message 13 and conﬁrmation message 14). This prompts Smith1 to send
again a CommandMe request in message 15, this time with the valid token. This message

8.3.
Agents Communication
72
OracleAgent : OracleAgent
Neo : ChosenOneAgent
Smith1 : SmithAgent
Inform(Done)
2: 
Request(Wait)
3: 
Inform(Done)
14: 
(Request(CommandMe)
15: 
Request(Die)
17: 
Request(CommandMe)
7: 
Inform(Done)
11: 
Inform(Done)
12: 
Request(UveBeenAttacked)
13: 
Request(FindMe)
5: 
Request(CommandMe)
1: 
Inform(Done)
4: 
Inform(Done)
8: 
Request(Wait)
9: 
Request(Attack)
10: 
Inform(Done)
16: 
Inform(Done)
18: 
Inform(Done)
6: 
Figure 8.7: Main workﬂow
is shown in Code extract 8.14. The body of this message contains an action construct, as
explained above, with the AID of the agent that is intended to perform the action. The
CommandMe action has three attributes: the secret, i.e. the token that permits an agent
to get additional orders besides Wait, the slave that is sending this message and the master
that handles this action. The Oracle agent conﬁrms that he is processing the message
with message 16 and sends a message requesting the slave to execute a Die action. Hence
the attack from the Neo agent was more than the current healthstate and armor of the
Smith1 agent combined could withstand. This caused the Oracle agent to declare Smith1
dead next time it contactes the Oracle agent. There are no more opponents left, the
system is now idle.
Every interaction is based on the FIPA-Request-Protocol, described in Section 4.3.2.
One might note that every interaction contains two communicative acts: a Request send
by the initiator and a Inform send as a reply by the participant. The original FIPA-
Request-Protocol foresees that an Agree is sent by the participant after it has received
the Request and before it has sent the message containing an Inform performative. This
step is however optional and can be omitted if the action is performed very quickly [8].
This is the case with all actions performed in the given scenario.

8.3.
Agents Communication
73
1
( ( action
( agent−identifier
3
:name OracleAgent@wlan−per21−244−231 . u n i f r . ch :1099/JADE
: addresses
5
( sequence http : / / wlan−per21−244−231 . u n i f r . ch :7778/ acc ) )
(CommandMe
7
: secret
i l l u m i n a t i
: slave Smith1@wlan−per21−244−231 . u n i f r . ch :1099/JADE
9
: master OracleAgent ) ) )
Code extract 8.14: Content of a CommandMe message
8.3.2 The Matrix Ontology
Figure 8.8: Matrix Ontology
The Matrix ontology is used by agents that take part in the workﬂow that represents
a combat between a set of agents of the type SmithAgent and one agent of the type
ChosenOne. The ontology is shown in Figure 8.8. This ontology is used by JADE and
Jess and also contains concepts and properties that are only used by Jess. Section 10.6.1
describes the algorithm that transforms the JADE ontology into Jess templates. The
elements deﬁned by JADE will not be elaborated on. They are the following: Concept,
Predicate, AID and AgentAction. The reader is invited to read more on the JADE content
reference model in [BCG07, p. 80].
This ontology was modeled with Protégé. The concepts and predicates are the following:
• MatrixAgent MatrixAgent contains every agent involved in the Matrix process. It
has one attribute, agentName that contains the name of the agent. The value should
be the AID of the agent.
• CombatAgent CombatAgent is the set of agents directly involved in the combat.
It deﬁnes the following attributes: armor which deﬁnes the amount of the attack
that is absorbed without harming the attacked agent, healthstate, which states the

8.3.
Agents Communication
74
current health of an agent and power, which states with which strength an agent
can attack another agent.
• ChosenOne The ChosenOne set should contain no more than one instance. This
instance is the opponents of all agents that are instances of the set SmithAgent.
• SmithAgent The SmithAgent set contains instances that are opponents of the agent
instance of the ChosenOne set.
• OracleAgent The OracleAgent set has with the current implementation one in-
stance, namely the master agent.
• FindMe A FindMe instance is the action sent by each new agent to request regis-
tration. Its attributes are newAgent, it contains the values of the agent sending the
request and master, the string value of the AID of the master.
• MatrixAction MatrixAction is the set of all actions set during the main workﬂow. It
deﬁnes the attribute secret, which contains the token an agent must possess to be
recognized by the Oracle agent as the agent authorized to get further instructions
besides Wait.
• MatrixCombatAction A MatrixCombatAction is an action that is involved in an
attack act. It speciﬁes the attributes victim that holds the string value of the AID
of the agent that has been attacked and attacker, the string value of the AID of the
attacking agent.
• UveBeenAttacked A UveBeenAttacked instance is sent to the attacked agent by
the attacker to inform the victim of its fate.
• Attack An Attack instance is used by the Oracle agent to signal one of its slave
agents that it must attack the opponent speciﬁed in the victim attribute. It deﬁnes
the attribute strength, which contains the strength of the attack.
• NonCombatAction Instances of the set NonCombatAction are used for actions that
are not related to an attack act. It deﬁnes the attribute slave. The value of this
attribute is the string value of the AID of the agent that receives a given instance.
• LifeStateAction Instances of this set are agent action that tell an agent whether
it is alive or dead.
• Wait A Wait instance is issued to an agent that has requested to be commanded and
is still alive. An agent may receive several Wait instances before the main workﬂow
is terminated.
• Die A Die instance is issued once to an agent which healthstate is 0 or less.
• CommandMe CommandMe is the set of requests sent by agents who are alive and
wish to know what the Oracle agent has in mind for them.
• Attackable An Attackable instance relates two opponents. It speciﬁes the follow-
ing attributes: badGuy that holds the string value of the AID of a SmithAgent and
goodGuy, the string value of the AID of a ChosenOne.
• Killed A Killed instance relates the agent that has been killed and the agent that
killed it. It deﬁnes two attributes: victim that holds the string value of the AID on
an agent who has died and killer, the string value of the AID of the agent that killed
the victim.

8.3.
Agents Communication
75
1 public class MatrixCommunication extends CommunicationConfigFactory
{
3
private
static
MatrixCommunication
Singleton ;
5
public
static
MatrixCommunication
getInstance ( )
{
i f
( Singleton == null )
7
Singleton = new MatrixCommunication ( ) ;
return
Singleton ;
9
}
11
private
MatrixCommunication ( )
{
this . setCodec (new SLCodec ( ) ) ;
13
this . setContentLanguage (FIPANames . ContentLanguage . FIPA_SL0 ) ;
this . setOntology ( The_MatrixOntology . getInstance ( ) ) ;
15
this . setOntologyName ( The_MatrixOntology .ONTOLOGY_NAME) ;
}
17 }
Code extract 8.15: Extending the CommunicationConﬁgurationFactory to set the ontology,
content language and codec
• Attacked An Attacked instance relate two agents involved in one attack act. For
each new act, a new Attacked instance is created. It deﬁnes two attributes: victim,
the string value of the AID of the agent that was attacked and attacker, the string
value of the attacker’s AID.
• Key A Key instance holds the token, stored as a string value in the attribute secret
used by a slave agent to be recognized as the agent with current "attack" access to
the Oracle agent.
8.3.3 Using the Communication Conﬁguration Factory
This Section explains how the Communication Conﬁguration Factory (described in Sec-
tion 10.2), is used for agents in the Matrix environment.
Extending the CommunicationConﬁgurationFactory class
The Communication Conﬁguration Factory provides methods to create diﬀerent types
of objects that are relevant to agent communication. A concrete factory has to specify
which ontology, content language and codec is used. This is achieved by extending the
CommunicationConﬁgurationFactory with a concrete factory that calls the protected setters
as shown in Code extract 8.15. The setters for the communication relevant parameters
are called in the private constructor of the concrete factory class. Due to the nature of
this concrete factory, only one instance of this class is needed, as long as it is globally
accessible. The Singleton design pattern is thus the natural choice.
Creating a message
An agent that wishes to send a message using the Communication Conﬁguration Factory
calls the Factory Method that creates a message for the performative and FIPA-Protocol
the agent requires. The example, shown in Code extract 8.16, is for the Request perfor-
mative and the FIPA-Request-Protocol. First, the agent action is created (lines 1–4). At
line 5, the AID of the receiver is created. The Communication Conﬁguration Factory is

8.4.
Agent Behaviors
76
1 UveBeenAttacked uba = new UveBeenAttacked ( ) ;
uba . setVictim (mca. getVictim ( ) ) ;
3 uba . setAttacker (mca. getAttacker ( ) ) ;
uba . setSecret (mca. getSecret ( ) ) ;
5 AID aid = new AID (mca. getVictim ( ) , AID . ISGUID ) ;
CommunicationConfigFactory
cf
7
= MatrixCommunication . getInstance ( ) ;
ACLMessage attack = null ;
9 try
{
attack = cf . createFIPARequestMessage ( this . myAgent ,
aid , uba ) ;
11 } catch ( CodecException e )
{
e . printStackTrace ( ) ;
13 } catch ( OntologyException e )
{
e . printStackTrace ( ) ;
15 }
this . myAgent . addBehaviour (new UveBeenAttackedInitiator ( this . myAgent ,
attack ) ) ;
17
19 \ subsubsection { Setting
the agent content language and ontology }
\ l i s t i n g r e f { l i s t i n g : j j i : agentconf } shows the sequence of
steps
to
configure
the
content
manager of an agent
with a Communication Configuration
Factory . An
agent requests a
Singleton
of
the Communication Configuration
Factory
i t
wishes to access
( l i n e
1) .
Next ,
the
agent
c a l l s
the
\ src { createAgentConfigObject }
to
receive a \ src { AgentConfigObject }
object
( l i n e
2) .
I t
then
c a l l s
the
\ src { AgentConfigObject }
getters
to
get
the
content
language ,
codec and ontology
in
l i n e 3−−5.
21 \ begin { l s t l i s t i n g } [ language=JAVA, float , caption ={ Configuring an agent ’ s content manager with
the Communication Configuration
Factory } , label ={ l i s t i n g : j j i : agentconf } ]
CommunicationConfigFactory
cf = MatrixCommunication . getInstance ( ) ;
23 AgentConfigObject aco = cf . createAgentConfigObject ( ) ;
t h i s . getContentManager ( ) . registerLanguage ( aco . getCodec ( ) ,
25
aco . getContentLanguage ( ) ) ;
t h i s . getContentManager ( ) . registerOntology ( aco . getOntology ( ) ) ;
Code extract 8.16: Creating a request performative message for the FIPA-Request-
Protocol
accessed as a Singleton in line 6–7. An ACLMessage variable is created in line 8. At line
10, the createFIPARequestMessage method is called with the current Agent, the receiver’s
AID and the action is to perform as argument. The agent that is to send the message
must also be passed as argument. This is necessary for the Communication Conﬁgura-
tion Factory to access the content manager in order to transform the Java objects into
the deﬁned content representation. The createFIPARequestMessage can throw exceptions
which have to be caught by the client. In this example, the message is passed to as an
argument to the constructor of a UveBeenAttackedInitiator behavior (a subclass of the Sim-
pleAcheivedBehaviour), which will send the message to the designated recipient (line 16).
8.4 Agent Behaviors
This Section discusses internal and communicational behaviors developed for the Matrix
system. The conventions to name and structure communicational behaviors is discussed
in Section 4.3.2.

8.4.
Agent Behaviors
77
FindOracleTemplate
+FindOracleTemplate( Agent a, long peroid )
#onTick() : void
#loadBehaviorsAndRegistrationMessage( AID oracle )
FindOracleJessAdmin
#loadBehaviorsAndRegistrationMessage( AID oracle )
FindOracleMatrix
#loadBehaviorsAndRegistrationMessage( AID oracle )
Figure 8.9: Behaviors to ﬁnd the master agent and conduct a set of setup tasks
8.4.1 Internal Behaviors
Setup Behavior
Every agent has a behavior of the type FindOracle that conducts a set of setup tasks. The
class diagram is shown in Figure 8.9. The FindOracleTemplate abstract class implements
the Template Method onTick that, once it has found the master agent (i.e. the Oracle
agent), calls the primitive operation loadBehaviorsAndRegistrationMessage. For each agent
type that needs to communicate with the master agent, a subclass has to be written that
implements the loadBehaviorsAndRegistrationMessage method. These are agents taking part
in the Matrix combat and Jess Administration agents. For both types, the concrete im-
plementations will send registration requests; for slave agents taking part in the Matrix
workﬂow it is the FindMe requests (see Code extract 8.14). Jess Administration agents
register themselves with the Oracle agent by sending a RegisterMe request (to be able to
communicate with the Jess instance hosted by the Oracle agent) and a RegisterOntologyLis-
tener to get updates of the ontology used by Jess. The Remote Jess Administration is
discussed in Chapter 9.
Get Orders
The GetOrders behavior is an internal behavior that is used by a slave agent to initiate a
CommandMe conversation. This behavior is activated on two occasions:
• The Oracle agnet conﬁrms that the slave agent which has just sent a FindMe request,
is registered (FindMeInitiator behavior).
• The slave agent has received a UveBeenAttacked agent action from its enemy.
This behavior is instantiated once per agent and then "recycled".
8.4.2 Communicational Behaviors
This Section ﬁrst describes the conversations that take place between agents in the Ma-
trix environment, followed by an explanation of how a new communicational behavior is
implemented.

8.4.
Agent Behaviors
78
Agent Conversations for the Matrix
• "Attack" Conversation An attack conversation is carried out by the Oracle agent
and a slave agent.
The Oracle sends a Request performative that contains an
Attack agent action to a slave agent. The slave agent reacts to the agent action by
initializing a "You have been attacked" conversation with the slave agent the Oracle
agent decided it has to attack.
• "You Have Been Attacked" Conversation This conversation is between the
attacking slave agent and its victim. The attacker sends a Request performative
containing a UveBeenAttacked agent action that contains the token (called secret)
the slave agent needs to be recognized by the Oracle agent as the agent responding
to the Attack command. The participant’s UveBeenAttackedResponder re-activates a
OneShotBehavior that initialized the "Command Me" conversation with the Oracle
agent.
• "Die" Conversation A "Die" conversation takes place between the Oracle agent
and a slave agent that has recently requested to be commanded. The slave agent
was killed in a previous ﬁght but does not yet know this. The Oracle agent sends
a Request performative containing a Die agent action. The slave agent responds by
writing to the console that is has died.
• "Wait" Conversation A "Wait" conversation is between the Oracle agent and
a slave agent that requested to be commanded and is still alive. The slave agent
receives the message but does not do anything.
• "Find Me" Conversation A "Find Me" conversation takes place between a slave
agent and the Oracle agent. A slave agent registers itself with the Oracle agent
and requests that the Oracle agent discovers its properties (health, armor, power).
It does so by sending an Inform communicative act that contains a FindMe which
in turn contains incomplete information on the sender. The Oracle agent activates
upon reception of FindMe message its FindMeResponder behavior. This behavior adds
the agent to the working memory of Jess, runs Jess to reason on its newly added
fact and returns update to the slave agent. The slave agents merely prints the
information to the console.
• "Command Me" Conversation After a slave agent of the type ChosenOne or
SmithAgent is registered with the Oracle agent, it can ask the Oracle agent to
provide it with new orders. It starts a "Command Me" conversation by sending
CommandMe agent action. The Oracle agent replies to this request by returning a
simple Done.
Adding a New Communicational Behavior
This Section discusses how new FIPA-Request-Protocol behaviors are added by extend-
ing the classes RequestInitatorTemplate and RequestResponderTemplate to implement a new
conversation. The conversation in this example is "Find Me". Unless stated otherwise,
the algorithm of these methods is of no importance for this Section.
To create a new Initiator behavior, the RequestInitatorTemplate is extended and the hook
method that accepts the expected performative and predicate overwritten, as shown in

8.4.
Agent Behaviors
79
public class
FindMeInitiator
extends RequestInitiatorTemplate
{
2
private
static
f i n a l
long serialVersionUID = 4858773633255342724L ;
4
public
FindMeInitiator ( Agent a , ACLMessage msg)
{
super (a , msg) ;
6
}
8
protected void executeInformResult
( Concept agentAction ,
Object
resultValue , ACLMessage msg)
{
/ / do something
10
}
}
Code extract 8.17: Creating an Initiator behavior by extending RequestInitiatorTemplate
1 public class FindMeResponder extends RequestResponderTemplate {
3
public FinMeResponder ( Agent a ,
MessageTemplate mt )
{
super (a , mt ) ;
5
}
7
private
static
f i n a l
long serialVersionUID = 5898353514161562132L ;
9
protected
Predicate
executeAction
( Concept agentAction ) throws NotUnderstoodException ,
RefuseException {
FindMe fm = ( FindMe )
agentAction ;
11
/ / do something
Result
r = new Result ( ) ;
13
r . setValue ( "SOMERESULT" ) ;
this . setMessagePerformative (ACLMessage .INFORM) ;
15
return
r ;
}
17 }
Code extract 8.18: Creating a Responder behavior by extending RequestResponderTemplate
Code extract 8.17. If the initiator does not intend to handle the Inform returned by the
participant, no hook method has to be overwritten.
A Responder behavior is created by extending RequestResponderTemplate. An example
based on the FindMeResponder class is given in Code extract 8.18. To execute successfully,
this method has to set at some point the message performative by calling setMessagePer-
formative (line 14) and returning a predicate of the type Result or Done. It is to be noted
that the agent action does not have to be set for the predicate, this is handled by the
Template Method. Thus for a Done, the predicate can simply be returned by calling return
new Done(). For the Result, the result created by the behavior has to be added to it by
calling its method setValue (line 13).
Adding a new Jessable Communicational Behavior
This example shows how the CommandMeResponder class (shown in the Class Diagram of
Figure 8.10), which is a concrete Jessable behavior, is realized. Jessable Behaviors are
discussed in Section 10.7.1. It implements the participant’s behavior in a "Command
Me" conversation based on the FIPA-Request-Protocol. The implementation is shown in
Code extract 8.19. In addition to overwriting executeAction, a concrete Jessable behavior
has to implement setCommunicationConﬁgFactory to specify which concrete communication
factory is to be used and thus which ontology. executeAction does the following: it adds

8.5.
Software Agents
80
CommandMeResponder
+setCommunicationConfigurationFactory() : CommunicationConfigurationFactory
#executeAction( Concept agentAction ) : Predicate
JessableRequestResponderTemplate
+onEnd:int()
+getConcepts() : Vector<Concept>
+registerWithJessFunctionManager() : void
+removeAsCurrent() : void
+setAsCurrent() : void
+unregisterWithJessFunctionManager() : void
+addOntologyConcept( Concept concept )
#doAtBeginning() : void
#doAtEnd() : void
Figure 8.10: CommandMeResponder jessable behavior
the agent action to Jess’s working memory (line 9), sets the Jess module which contains
the rules that should run ﬁrst when Jess is executed and runs Jess (lines 10–11). This
behavior does not collect any concepts during Jess’s execution.
8.5 Software Agents
This Section discusses the software agents for the Matrix environment. For reasons of
compatibility with MediMAS [18], every Matrix agent has an agent state instance ﬁeld,
it is however not used since the Matrix slave agents are stateless.
The class hierarchy for
agents in the Matrix is shown in Figure 8.11. All classes inherit from the TheMatrixAgent
abstract class that extends the JADE Agent class.
8.5.1 TheMatrixAgent
The TheMatrixAgent abstract class deﬁnes a set of primitive methods that the setup method
calls. It speciﬁes the following instance ﬁelds which can be accessed through setters and
getters:
• self This instance ﬁeld holds a MatrixAgent instance of itself. The agent sends this
object during the registration process to register itself with the Oracle agent.
• oa This instance ﬁeld holds the AID of the Oracle agent.
• state This instance ﬁeld is of the type AgentState. It is currently not used.
The following Template Method is implemented:
• setup This Template Method is shown in Code extract 8.20.
At lines 2–6 the
agent’s content manager is setup. This is described in details in Section 10.2. Next,

8.5.
Software Agents
81
1 public class CommandMeResponder extends JessableRequestResponderTemplate
{
3
public CommandMeResponder( Agent a ,
MessageTemplate mt )
{
super (a , mt ) ;
5
}
7
protected
Predicate
executeAction
( Concept agentAction ) throws NotUnderstoodException ,
RefuseException {
CommandMe cm = (CommandMe)
agentAction ;
9
this . jessCNC . getJessEngineManager ( ) . addFactToJess (cm) ;
this . jessCNC . getJessEngineManager ( ) . setModuleFocus ( "AGENT−FATE" ) ;
11
this . jessCNC . getJessEngineManager ( ) . runJess ( ) ;
this . setMessagePerformative (ACLMessage .INFORM) ;
13
return new Done ( ) ;
}
15
public CommunicationConfigFactory setCommunicationConfigFactory ( )
{
17
return MatrixCommunication . getInstance ( ) ;
}
19 }
Code extract 8.19: Implementation of the CommandMe responder class
TheMatrixAgent
#setup() : void
#prepareAgent() : void
#loadInitialBehaviors() : void
#takeDown() : void
+setAgentObjectShell() : void
+getOA() : AID
+setOA( AID oa ) : void
+getSelf() : MatrixAgent
+setSelf( MatrixAgent self )
ChosenOne
#prepareAgent() : void
#loadInitialBehaviors() : void
+setAgentObjectShell() : void
OracleAgent
#prepareAgent() : void
#loadInitialBehaviors() : void
+setAgentObjectShell() : void
SmithAgent
#prepareAgent() : void
#loadInitialBehaviors() : void
+setAgentObjectShell() : void
JessableAgent
+getJessCNC() : JessCNC
JessCNC
Figure 8.11: Class hierarchy for agents in the Matrix environment
it calls the primitive operation prepareAgent. Subclasses can add additional setup
instructions in this method. At line 9, it loads the behaviors the agent wants to
load at initialization time. At lines 9–11 a WaitResponder behavior is loaded.
Subclasses have to implement the following primitive operations:
• prepareAgent This method permits subclasses to add additional agent setup in-
structions.
• loadInitialBehaviours Subclasses can add additional behaviors that have to be
loaded during setup.
• setAgentOntologyObjectShell This method creates and conﬁgures the agent’s
instance from the ontology which it will use to register itself with the Oracle agent.

8.5.
Software Agents
82
1
protected void setup ( )
{
CommunicationConfigFactory
cf = MatrixCommunication . getInstance ( ) ;
3
AgentConfigObject aco = cf . createAgentConfigObject ( ) ;
this . getContentManager ( ) . registerLanguage ( aco . getCodec ( ) ,
5
aco . getContentLanguage ( ) ) ;
this . getContentManager ( ) . registerOntology ( aco . getOntology ( ) ) ;
7
this . setAgentOntologyObjectShell ( ) ;
this . prepareAgent ( ) ;
9
this . l o a d I n i t i a l B e h a v i o u r s ( ) ;
MessageTemplateFactory mtf =
11
FipaRequestFactory . getInstance ( ) ;
this . addBehaviour (new WaitResponder ( this ,
mtf . c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n ( this ,
Wait . class ) ) ) ;
13
System . out . p r i n t l n ( this . s e l f . getClass ( ) + "
agent
" + this . getLocalName ( ) + "
i s
ready " ) ;
}
Code extract 8.20: Setup method of the TheMatrixAgent class
8.5.2 Slave Agents
Slave agents in the Matrix environment are either of the type SmithAgent or ChosenOne.
Both classes extend TheMatrixAgent to implement the methods setAgentOntologyObjectShell
to set their agent type of the ontology and loadInitialBehaviours to load a FindOracleMatrix
behavior which will handle the registration process with the Oracle agent; prepareAgent
is left empty. Except for the agent type set with setAgentOntologyObjectShell, the imple-
mentation is otherwise the same. The implementation for the class SmithAgent is shown
in Code extract 8.21.
public void setAgentOntologyObjectShell ( )
{
2
ontology . matrix . SmithAgent
sa = new ontology . matrix . SmithAgent ( ) ;
sa . setAgentName ( this . getAID ( ) . getName ( ) ) ;
4
sa . setArmor (0) ;
sa . setHealthstate (0) ;
6
sa . setPower (0) ;
this . setSelf ( sa ) ;
8
}
10
protected void
l o a d I n i t i a l B e h a v i o u r s ( )
{
this . addBehaviour (new FindOracleMatrix ( this ,10000) ) ;
12
}
Code extract 8.21: Setup of a slave agent
8.5.3 Master Agent
The OracleAgent class extends TheMatrixAgent class and implements the JessableAgent in-
terface.
The methods of interest are shown in Code extract 8.22.
loadInitialBehaviours
loads the behaviors for the Matrix domain and for the Jess Administration domain. Each
behavior is provided with a message template to restrict its activation to a certain conver-
sation type. The prepareAgent method instantiates JessCNC and additionally conﬁgures
its ontology manager to use messages that use the Jade Administration ontology, which
it will apply to communicate with Jess Administration agents (lines 17–20). The Oracle
agent then registers itself with the DF to enable its slaves to look it up (lines 21–28).
protected void
l o a d I n i t i a l B e h a v i o u r s ( )
{
2
MessageTemplateFactory mtf
= FipaRequestFactory . getInstance ( ) ;
4
this . addBehaviour (new FindMeResponder ( this ,
mtf . c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n ( this , FindMe . class ) ) ) ;

8.5.
Software Agents
83
6
this . addBehaviour (new CommandMeResponder( this ,
mtf . c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n ( this , CommandMe. class ) ) ) ;
8
this . addBehaviour (new RegisterMeResponder ( this ,
mtf . c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n ( this ,
RegisterMe . class ) ) ) ;
10
this . addBehaviour (new ExecuteJessCommandResponder ( this ,
mtf . c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n ( this , ExecuteJessCommand . class ) ) ) ;
12
this . addBehaviour (new RegisterOntologyTreeListenerResponder ( this ,
mtf . c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n ( this ,
RegisterOntologyTreeListener . class ) ) )
;
14
}
16
protected void prepareAgent ( )
{
this . jessCNC
= new JessCNC( this ) ;
18
CommunicationConfigFactory
cf = JessCommunication . getInstance ( ) ;
AgentConfigObject aco = cf . createAgentConfigObject ( ) ;
20
this . getContentManager ( ) . registerOntology ( aco . getOntology ( ) ) ;
DFAgentDescription
dfd = new DFAgentDescription ( ) ;
22
dfd . setName ( getAID ( ) ) ;
ServiceDescription sd = new ServiceDescription ( ) ;
24
sd . setType ( " Oracle−Agent " ) ;
sd . setName ( " Oracle−Agent " ) ;
26
dfd . addServices ( sd ) ;
try
{
28
DFService . r e g i s t e r ( this ,
dfd ) ;
} catch ( FIPAException
fe )
{
30
fe . printStackTrace ( ) ;
}
32
}
34
public JessCNC getJessCNC ( )
{
return
this . jessCNC ;
36
}
Code extract 8.22: Setup the Oracle agent
8.5.4 Jess Administration Agent
To administer the Jess instance of the Oracle agent remotely, a concrete Jess Administra-
tion agent was created, called JessAdministrationAgent. The GUI of the Jess Administration
agent is shown in Figure 8.1. The JessAdministrationAgent extends the abstract class Ab-
stractJessAdminAgent and implements registerWithMasterAgentAndLoadBehaviors. This method
adds a FindOracleJessAdmin behavior to its agent. The FindOracleJessAdmin bahavior reg-
isters the agent with the Oracle agent and loads the required behaviors. Remote Jess
Administration is discussed in details in Chapter 9.

9
Remote Jess Administration
9.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
9.2
Using the Jess Administration Agent
. . . . . . . . . . . . . .
84
9.3
Agents Communication . . . . . . . . . . . . . . . . . . . . . . .
85
9.3.1
Jess Administration Ontology . . . . . . . . . . . . . . . . . . .
85
9.4
Agent Behaviors and related Classes . . . . . . . . . . . . . . .
86
9.4.1
Communicational Behaviors . . . . . . . . . . . . . . . . . . . .
87
9.4.2
Implementation of the Agent Conversations . . . . . . . . . . .
87
9.5
Jess Administration Agents
. . . . . . . . . . . . . . . . . . . .
92
9.1 Introduction
A Jess Administration agent permits to work with Jess similar to having direct console
access to a Jess instance. It it is an autonomous part of the J2J tool kit. This Chapter
explains the implementation of the remote Jess Administration. Section 9.2 explains how
the Jess Administration is used. The next Section, Section 9.3, describes the ontology
that the master agent and Jess Administration agents use to communicate. In Section 9.4,
the possible conversations between a Jess Administration agent and a master agent as
well as the necessary extensions written to enable these conversations, are discussed. The
abstract Jess Administration agent class is elaborated on in Section 9.5.
9.2 Using the Jess Administration Agent
As indicated in Figure 8.2, a master agent can be accessed by special agents to remotely
administer its Jess rule-engine instance.
These agents are called Jess Administration
agents.
The GUI of Jess Administration agent is shown in Figure 9.1.
Each part is
marked with a red frame. The current implementation covers basic features: sending
Jess commands, receiving Jess output and viewing the ontology. To give an example of
how the remote Jess Administration agent can be used, the rule MAIN::train-agent-chosenone
is replaced during run time to add only low attribute values to a Chosen One agent, thus
84

9.3.
Agents Communication
85
Figure 9.1: Remote Jess administration interface
reducing the likelihood that it can win. The new rule prints "NEW RULE TO SET
NEO’s ATTRIBUTES", after is was transmitted by having clicked on the eval button.
The following output shows that the agent Neo is weakened and loses the ﬁght.
JESS OUTPUT NEW RULE TO SET NEO’s ATTRIBUTES
JESS OUTPUT New opponents: badguy is ...
...
JESS OUTPUT Reducing life of agent Neo@Kaleena.local...
JESS OUTPUT Agent Neo@Kaleena.local:1099/JADE has died,...
Agent Smith14 is still alive and waiting
...
JESS OUTPUT retracting settings for neoNeo@Kaleena.loca...
JESS OUTPUT dying information sent to Neo@Kaleena.local:..
9.3 Agents Communication
For the Jess Administration agent to be able to communicate with the master, a new
ontology was developed and the corresponding Communication Conﬁguration Factory
implemented (see Section 10.2 for details on the Communication Conﬁguration Factory).
The ontology is elaborated on in this Section.
9.3.1 Jess Administration Ontology
The Jess Administration ontology, shown in Figure 9.2, deﬁnes the semantics of the
content communicated between Jess Administration agents and the master agent that

9.4.
Agent Behaviors and related Classes
86
Figure 9.2: Jess Administration Ontology
hosts Jess. Unlike the Matrix ontology, it is not used by Jess itself and therefore not
mapped to Jess templates. The elements deﬁned by JADE will not be elaborated on.
They are the following: Concept, Predicate, AID and AgentAction. The reader is invited to
read more on the JADE content reference model in [BCG07, p. 80].
The Jess Administration ontology consists of the following sets:
• RegisterOntologyListener A RegisterOntologyListener is sent by an agent that
wishes to be notiﬁed of changes to the ontology. It speciﬁes the attribute agent-
Name which contains the AID of the subscriber.
• RegisterMe A RegisterMe instance is sent by an agent that wants to be able to
access Jess remotely and obtain output generated by Jess. It deﬁnes the attribute
agentName which contains the AID of the subscriber.
• UnRegisterMe An UnRegisterMe instance is sent by an agent that does not wish to
be provided with Jess related messages anymore. The attribute agentName contains
the AID of the agent that is unregistering.
• UpdateBuﬀer An UpdateBuffer instance is sent to a Jess Administration agent.
It contains new output generated by Jess. The output is stored in the attribute
content.
• ExecuteJessCommand An ExecuteJessCommand instance is sent by a Jess Ad-
ministration agent to the master agent hosting Jess. It requests Jess to execute an
arbitrary Jess command. The command is stored in the attribute content.
• OntologyTreeChanged An OntologyTreeChanged instance is sent whenever the on-
tology tree is changed to every agent registered as an ontology listener. It deﬁnes
two attributes; agentName contains the AID of the recipient and the attribute content
the structure of the tree.
9.4 Agent Behaviors and related Classes
This Section ﬁrst states each conversation that the communicational behaviors implement.
It then explains how these conversations are implemented by extending classes of the J2J
tool kit.

9.4.
Agent Behaviors and related Classes
87
9.4.1 Communicational Behaviors
A Jess Administration agent and a master agent that hosts Jess use the following con-
versations:
Agent Conversations for Jess Administration
This Section discusses the conversations between administration agent (or agents) and
the master server that hosts Jess.
• "Register Me" Conversation A "Register Me" conversation occurs when a Jess
Administration agent requests to be registered with the master agent to receive
the output generated by Jess.
The Jess Administration agent sends an Inform
performative containing a RegisterMe agent action. The master agent activates its
RegisterMeResponder behavior that adds the agent to the list of agents which will be
notiﬁed whenever Jess generates output.
• "Update Buﬀer" Conversation When a Jess Administration agent is registered
with the master agent, the master agent notiﬁes each registered agent whenever Jess
generates output by sending a Request performative containing an UpdateBuffer agent
action which has the latest console output as content. The participant responses to
this message by calling its UpdateBufferResponder behavior which extracts the string
value and updates the object that displays the value.
• "Execute Jess Command" Conversation A Jess Administration agent that
wants to execute a Jess command on the master agent starts the "Execute Jess
Command" conversation by sending a Request performative that contains an Exe-
cuteJessCommand agent action with the Jess command as string value. The master
activates its ExecuteJessCommandResponder behavior which passes the command to
Jess. If the command is successful, the agent returns an Inform performative with
a Done predicate, otherwise it returns a Failure performative with the error message
provided by Jess as the content of a Result predicate. The results are displayed by
the initiator.
• "Register Ontology Tree Listener" Conversation A Jess Administration agent
that wishes to be notiﬁed when the ontology used by Jess changes, starts this con-
versation by sending a Request performative containing a RegisterOntologyTreeListner.
The master agent adds the agent to the list of agents that want to be notiﬁed of
updates to the ontology tree.
• "Ontology Tree Changed" Conversation Every time the ontology tree used by
Jess is updated, the master agent starts an "Ontology Tree Changed" conversation
with each agent registered as an Ontology Tree Listener by sending a Request
performative with an OntologyTreeChanged agent action that contains the ontology
tree in a fully parenthesized syntax.
9.4.2 Implementation of the Agent Conversations
The conversations for the Jess Administration focus: (i) on relaying commands to Jess
and the output generated by Jess to the Jess console and (ii) on providing the structure of
the ontology used by the Jess engine.
For both participating agents, the implementation

9.4.
Agent Behaviors and related Classes
88
protected
Predicate
executeAction
( Concept agentAction ) {
2
RegisterMe rm = ( RegisterMe )
agentAction ;
JessableAgent
ja = ( JessableAgent )
this . myAgent ;
4
ja . getJessCNC ( ) . getAgentOutputWriter ( ) . addStrategy (rm . getAgentName ( ) . getName ( ) , new
JadeMessgeOutputStrategy ( this . myAgent , rm . getAgentName ( ) ) ) ;
this . setMessagePerformative (ACLMessage .INFORM) ;
6
return new Done ( ) ;
}
Code extract 9.1: Adding a JadeMessageOutputStrategy
required on the Jess Administration agent’s side and on the master agent’s side are
explained.
Jess Console Input and Output
This Section ﬁrst explain the registration process for a Jess Administration agent to
receive Jess console output and how the output generated by Jess and the command sent
to the Jess engine, are transmitted.
Registration for Console Output and Receiving the Output
Before an agent can
receive Jess output remotely, it must register itself with the AgentOutputWriter object. The
agent accomplishes this by initiating a "Register Me" conversation (for Jess Administra-
tion, not Matrix slaves), as discussed in Section 9.4.1). The master agent’s RegisterMeRe-
sponder behavior adds a new JadeMessageOutputStrategy instance to the AgentOutputWriter
object. It sets the agent’s name as the key of the Strategy (the Strategy design pattern is
discussed in [GHJV95, p. 315]). Strategies are stored in a HashMap object. The JadeMes-
sageOutputStrategy class extends the JessOutputStrategy class. The AgentOutputWriter class
and the JessOutputStrategy class are discussed in Section 10.5.3. A JadeMessageOutputStrat-
egy object sends the string it receives from its Context (i.e. an AgentOutputWriter instance)
to its agent. The executeAction method of the RegisterMeResponder behavior is shown in
Code extract 9.1. For each agent that wishes to receive Jess output, a new Strategy is
instantiated.
When the writeOutput method of a JadeMessageOutputStrategy is called, it initiates an "Up-
date Buﬀer" conversation with its designated agent and transmits the output. The re-
ceiver’s UpdateBufferResponder accepts the message and passes it to the Jess Administration
agent’s GUI object to update its text ﬁeld. This is shown in Code extract 9.2.
The
Sequence Diagram of Figure 9.3 depicts the agent communication for the conversations
"Register Me" and "Update Buﬀer" between the master agent "OracleAgent" and one
administration agent "Admin". The participants in the Sequence Diagram are agents,
not objects, and their interaction is based on ACLMessages not, methods calls.
1
protected
Predicate
executeAction
( Concept agentAction ) {
UpdateBuffer ub = ( UpdateBuffer )
agentAction ;
3
( ( JessAdminAgent )
this . myAgent ) . getJessAdminGui ( ) . updateOutput ( ub . getContent ( ) ) ;
this . setMessagePerformative (ACLMessage .INFORM) ;
5
return new Done ( ) ;
}
Code extract 9.2: Updating a Jess Administration agent’s Jess output console

9.4.
Agent Behaviors and related Classes
89
OracleAgent : OracleAgent
Admin : JessAdminAgent
Adds a new 
JadeMessageOutputStrategy to 
its AgentOutputWriter object
At some point, Jess runs and 
generates output, which is 
passed to its AgentOutputWriter
"Update Buffer" Communication
"Register Me" Communication
Request(UpdateBuffer)
3: 
Inform(Done)
2: 
Request(RegisterMe)
1: 
Inform(Done)
4: 
Figure 9.3: "Register Me" and "Update Buﬀer" based on the FIPA-Request-Protocol
protected void executeInformResult
( Concept agentAction ,
Object
resultValue , ACLMessage msg)
{
2
JessAdminAgent jaa = ( JessAdminAgent )
this . myAgent ;
jaa . getJessAdminGui ( ) . updateOutput ( resultValue . t o S t r i n g ( ) ) ;
4
}
Code extract 9.4: Implementation of the ExecuteJessCommandInitiator behavior
When the eval button is clicked (see Figure 9.1), the content of the text ﬁeld is read and
sent to the master agent by initializing a "Execute Jess Command" conversation. The
ExecuteJessCommandResponder behavior adds the command to Jess by calling the Jess
Engine Manager’s executeJessCommand method. If the command is valid, the behavior
replies by sending an Inform Done. Otherwise it throws a JessException. The exception is
protected
Predicate
executeAction
( Concept agentAction ) {
2
ExecuteJessCommand ejc = ( ExecuteJessCommand )
agentAction ;
JessableAgent
ja = ( JessableAgent )
this . myAgent ;
4
Predicate p = null ;
try
{
6
ja . getJessCNC ( ) . getJessEngineManager ( ) . executeJessCommand ( ejc . getContent ( ) ) ;
this . setMessagePerformative (ACLMessage .INFORM) ;
8
p = new Done ( ) ;
} catch ( JessException e )
{
10
Result
r e s u l t = new Result ( ) ;
r e s u l t . setValue ( e . getMessage ( ) ) ;
12
p = r e s u l t ;
this . setMessagePerformative (ACLMessage . FAILURE) ;
14
}
return p ;
16
}
Code extract 9.3: Implementation of the ExecuteJessCommandResponder behavior

9.4.
Agent Behaviors and related Classes
90
handled and the error message returned as a Failure. The information is passed to the
GUI of the Jess Administration agent and displayed. The executeAction method of the
ExecuteJessCommandResponder behavior is shown in Code extract 9.3, the handler method
of the ExecuteJessCommandInitiator behavior in Code extract 9.4.
Ontology Display
This Section ﬁrst explains the classes that have to be added to the master agent for a
Jess Administration agent to receive information on the ontology followed by a discussion
on how the ontology information is handled by the Jess Administration agent.
Adding Observer and Visitor
To add support on the master’s side for transmitting
the ontology remotely, two classes had to be added: An Observer of the Ontology Tree
Manager and a Visitor that traverses the ontology on behalf of the Observer (the Observer
design pattern is described in [GHJV95, p. 293], the Visitor design pattern in [GHJV95,
p.
331]).
The ontology management is part of the J2J tool kit.
It is discussed in
Section 10.6. The new Observer is the RemoteTreeListenerManager class, its new Visitor is
the LispingTreeVisitor class:
• RemoteTreeListenerManager The RemoteTreeListenerManager class extends the
abstract class TreeUser, as shown in Figure 10.10. It forwards the string representa-
tion of the ontology generated by its Visitor, LispingTreeVisitor, to a set of agents that
have applied to receive updates of the ontology. Hence the RemoteTreeListenerManager
object of the master agent can be seen as the Subject and the registered agents as
its Observers. The Subject initiates a "Ontology Tree Changed" conversation (Sec-
tion 9.4.1) to push the entire representation of the ontology to the Observers. This
is the opposite to the approach chosen by the Ontology Tree Manager where the
Observers pull the information they require. The Remote Tree Listener Manager
updates its Observers on two occasions: when the Ontology Tree Manager notiﬁes
the RemoteTreeListenerManager object that the ontology has changed and every time
a new agent registers itself. The Subject will only update Observers that have a
time stamp older than the last update. A new agent has its time stamp set to 0,
thus it will get the update.
For an agent to receive information on the ontology composite, it has to register
itself by initializing a "Register Me" conversation, as discussed in Section 9.4.1.
• LispingTreeVisitor A LispingTreeVisitor implements the OntologyVisitor interface, as
shown in the UML Class Diagram of Figure 10.14. It creates string representation
of the ontology using a fully parenthesized syntax (similar to the programming
language LISP, therefore the name LISPing). Code extract 9.5 shows the result for
the Matrix ontology, depicted in Figure 8.8. This syntax was chosen due to the fact
that it is easy to create and parse and has, with two parenthesis per node, little
overhead. The current implementation ignores attributes.
1 (ROOT( Concept ( AgentAction ( MatrixAction ( MatrixCombatAction ( UveBeenAttacked ) ( Attack ) ) (
NonCombatAction ( LifeStateAction ( Wait ) ( Die ) ) (CommandMe) ) ) ( FindMe ) ) ( MatrixAgent (
CombatAgent ( SmithAgent ) (ChosenOne) ) ( OracleAgent ) ) ) ( Predicate ( Attacked ) (NoGo) (
Attackable ) ( K i l l e d ) ( Key ) ) )
Code extract 9.5: Parenthesized representation of the ontology

9.4.
Agent Behaviors and related Classes
91
Parsing the Ontology Representation
The ontology string representation sent to a
Jess Administration agent is parsed and transformed into a JTree. The transformation is
handled by the Jess Administration agent’s OntologyTreeChangedResponder behavior. The
transformation is implemented in two steps:
1. The character stream is parsed and divided into substrings. Each node and paren-
thesis is a string object. These objects are stored in a Vector.
2. The Vector generated in the previous step is read to generate a JTree that contains
each class in the ontology.
1 ( Root (A(B) ) (C) )
Code extract 9.6: A simple tree that is parsed according to Figures 9.4(a) to 9.4(h)
(a)
(b)
(c)
(d)
(e)
(f)
(g)
(h)
Figure 9.4: Steps performed to create a JTree representation of the ontology used by Jess
The algorithm performing the second step is discussed in detail in Appendix D, Sec-
tion D.1. The algorithm ﬁrst creates a "(String, DefaultMutableTreeNode)" pair for every
String object created in the ﬁrst step and adds these pairs in a Vector in the same order
as the Strings in the Vector created in the ﬁrst step. The second element of each pair is
set to null. The DefaultMutableTreeNode class is used to create nodes of a JTree. For each
pair in the new Vector, the algorithm executes the following steps: If the ﬁrst element of
the current pair is a left parenthesis, it is ignored. If it is a right parenthesis, it means
that the end of a list has been reached and the element on top of the stack is the ﬁrst
element in a list. The element on top of the stack is popped and, if the stack is not
empty, it is assigned as a child of the DefaultMutableTreeNode instance of the elment that is
now on the top of the stack (if the DefaultMutableTreeNode of the popped elment or of the
element that is now on the top of the stack is null, a new DefaultMutableTreeNode has to be
created for each reference that is null). If the stack is empty, the root of the ontology has
been reached. If the ﬁrst element of the current pair is not a parenthesis, it is a node in
the ontology tree representation and pushed onto the stack. To illustrate this algorithm,
Figures 9.4(a) to 9.4(h) depict each step performed by the algorithm of the second step
for the tree of Code extract 9.6.

9.5.
Jess Administration Agents
92
9.5 Jess Administration Agents
JessAdminAgentGui
+JessAdminAgentGui()
+JessAdminAgentGui( JessAdminAgent myAgent )
-initGui() : void
+updateOutput( String s ) : void
+setJTreeRoot( DefaultMutableTreeNode root ) : void
AbstractJessAdminAgent
+getJessAdminGui() : JessAdminGui
#onGuiEvent( GuiEvent ev ) : void
+getMaster() : AID
+setMaster( oa ) : void
+registerWithMasterAgentAndLoadBehaviors()
+loadDefaultBehaviors()
GuiAgent
+postGuiEvent( GuiEvent e ) : void
#onGuiEvent( GuiEvent ev ) : void
Figure 9.5: Class hierarchy for agents in the Jess Administration environment
The AbstractJessAdminAgent abstract class extends the GuiAgent class of the JADE frame-
work.
It aids the implementation of a GUI for JADE agents.
The class hierarchy is
depicted in Figure 9.5. A screenshot of a Jess Administration agent’s GUI is shown in
Figure 9.1. The AbstractJessAdminAgent conﬁgures its content manager and instantiates the
GUI object. Specifying AID of the master agent is delegated to its subclasses. The agent
GUI was developed with the GUI designer plugin Jigloo [1] and will not be discussed
further. The AbstractJessAdminAgent class is discussed in the next Section.
AbstractJessAdminAgent
This abstract class has the following methods:
• setMaster This method is called by a subclass to set the AID of the master agent.
• getMaster This method is called by adherent classes that require to know the AID
of the master agent the Jess Administration agent needs to contact.
• setup This method conﬁgures the agent and then calls its instance method reg-
isterWithMasterAgentAndLoadBehaviors to set the master agent’s name and load the
behaviors that are required to communicate with the master agent.
• getJessAdminGui This method returns a pointer to the GUI object of the Jess
Administration agent.
• registerWithMasterAgentAndLoadBehaviors This abstract method is to be
implemented by its subclasses to set the master agent and load the behaviors nec-
essary to communicate with the master agent.
• onGuiEvent is speciﬁed by its super class. It is left empty.
• loadDefaultBehaviors This method loads the default behaviors needed for the
remote Jess Administration agent to communicate with the master agent. It has to
be called by a subclass once the master agent is known.

9.5.
Jess Administration Agents
93
• gUI This instance ﬁeld holds a reference to the GUI object of the agent.
• master This instance ﬁeld holds the AID of the master agent. A subclass sets the
value of this ﬁeld by calling setMaster.

10
Jess and JADE Integration: The
Jess 2 JADE Tool Kit
“This is your last chance. After this, there is no turning back. You take the blue pill -
the story ends, you wake up in your bed and believe whatever you want to believe. You
take the red pill - you stay in Wonderland and I show you how deep the rabbit-hole
goes.”
Morpheus
10.1 Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
10.2 Agent Communication Conﬁguration . . . . . . . . . . . . . . .
95
10.3 Agent Behaviors . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
10.3.1 Communicational Behaviors . . . . . . . . . . . . . . . . . . . .
97
10.3.2 Message Templates . . . . . . . . . . . . . . . . . . . . . . . . .
100
10.4 Software Agents
. . . . . . . . . . . . . . . . . . . . . . . . . . . 102
10.4.1 JessableAgent . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
10.5 Jess and JADE Integration Object . . . . . . . . . . . . . . . . 103
10.5.1 Jess Integration
. . . . . . . . . . . . . . . . . . . . . . . . . .
104
10.5.2 Jess Engine Manager . . . . . . . . . . . . . . . . . . . . . . . .
105
10.5.3 Jess Output Routing . . . . . . . . . . . . . . . . . . . . . . . .
106
10.6 Ontology Management
. . . . . . . . . . . . . . . . . . . . . . . 108
10.6.1 Ontology Tree Manager
. . . . . . . . . . . . . . . . . . . . . .
110
10.6.2 Ontology Visitors . . . . . . . . . . . . . . . . . . . . . . . . . .
114
10.6.3 Ontology Dependant Managers . . . . . . . . . . . . . . . . . .
116
10.7 Jess Functions for JADE and Function Management . . . . . 117
10.7.1 Jess Integrated Behaviors
. . . . . . . . . . . . . . . . . . . . .
121
10.8 A Brief Discussion of an Oracle Agent Without Rule Engine 125
94

10.1.
Introduction
95
10.1 Introduction
Chapter 8 explained by means of "the Matrix" example how the J2J tool kit, developed
for this thesis, is used. This Chapter discusses in detail how the toolkit is implemented.
In this Chapter, an agent that uses Jess to reason is referred to as a master agent. Sec-
tion 10.2 elaborates on the generic agent communication issues. Section 10.3 describes
generic behavior classes. In Section 10.4, the interface to access an agent’s Jess instance,
is discussed. Section 10.5 introduces the class JessCNC that is the point of contact for
accessing the J2J tool kit. Section 10.6 delves into the details of the ontology manage-
ment. Next, the framework to add JADE-integrated Jess user functions is explained in
Section 10.7. This Chapter closes with a brief discussion in Section 10.8 of a master agent
for the Matrix environment that is implemented without Jess.
10.2 Agent Communication Conﬁguration
CommunicationConfigurationFactory
+createAgentConfigObject() : AgentConfigObject
+createFIpaRequestMessage( Agent myAgent, AID receiver, AgentAction agentAction ) : ACLMessage
#setCodec( Codec codec ) : void
#getCodec() : Codec
#setContentLanguage( String contentLanguage ) : void
#getContentLanguage() : String
#getOntology() : Ontology
#setOntology( Ontology ontoloy ) : void
#getOntologyName() : String
#setOntologyName( String ontologyName ) : void
+unnamed1()
AgentConfigObject
+getCodec() : Codec
+getContentLanguage() : String
+setCodec( Codec codec ) : void
+setContentLanguage( String contentLanguage ) : void
+getOntology() : Ontology
+setOntology( Ontology ontology ) : void
MatrixCommunication
+getInstance() : MatrixCommunication
-MatrixCommunication()
JessCommunication
+getInstance() : JessCommunication
-JessCommunication()
ACLMessage
<<use>>
<<use>>
Figure 10.1: Abstract Factory to create agent communication related objects
When an agent sends a message to another agent in JADE, it has to create an instance of
the class ACLMessage. After that, it sets the receivers, the content language, the ontology
and the content. This sequence of steps can be automated. Two assumptions are made:
• The steps involved in creating a message for a given communicative act and a
FIPA-protocol will follow the same pattern.
• The content in a given domain using a given ontology will use the same codec and
content language.
Two types of objects are interested in the parameters that deﬁne the syntax and semantics
of the information transferred in a multi-agent environment:
• ACLMessages objects

10.2.
Agent Communication Conﬁguration
96
• and the agents’ content managers that transform the content of a message from
their string or bytes representation to Java POJOs and back from their Java object
representation to a string or bytes.
Because both the ACLMessage and the content managers depend on the same information,
it would make sense to store this information in one single class and have the conﬁgura-
tion objects for the content managers and ACLMessages created by the same class. The
Factory methods (the Factory method design pattern is described in [GHJV95, p. 107])
to create conﬁguration objects and the diﬀerent ACLMessages for each communicative act
and FIPA-protocol can thus be reused for every ontology. Based on these considerations,
an Abstract Factory (this design pattern is discussed in [GHJV95, p. 87]) was developed.
For each ontology, the Abstract Factory is extended. A child class only needs to specify
the ontology, the content language and the codec. The class diagram of the Abstract
Factory is shown in Figure 10.1. The ACLMessage class (its interface is omitted in the
diagram) is part of the JADE framework and will not be elaborated on in this Section.
The rest of this Section discusses the Abstract Factory. It illustrates on the basis of the
child class for the Matrix ontology how the Abstract Factory is extended and used to
create messages and to conﬁgure the content manager of an agent.
Classes
• CommunicationConﬁgurationFactory The CommunicationConﬁgurationFactory is
an abstract class that contains methods to create AgentConﬁgObjects and ACLMes-
sages. It deﬁnes the following private instance ﬁelds:
– codec speciﬁes the codec for the content language.
– contentLanguage states the content language used for messages.
– ontology holds a pointer the ontology object.
– ontologyName contains the string value of the ontology name.
The ﬁelds are accessed through private setters and getters. The subclasses of the
CommunicationConﬁgurationFactory class have to call these methods to set the proper
values. As mentioned above, for each communicative act and FIPA-protocol for
which messages are to be created, a Factory method has to be implemented. The
Matrix application only relies on the FIPA-Request-Protocol and only the initial re-
quest message has to be build from scratch (the replies are generated automatically
by calling the createReply method of a received ACLMessage instance). The method
to create the request message for a FIPA-Request-Protocol performative is shown in
Code extract 10.1. createFIPARequestMessage accepts as argument a pointer to the
current Agent object, the AID of the receiver and the AgentAction the receiving agent
is to perform (line 1). At line 2, an ACLMessage is instantiated and its constructor
provided with the argument ACLMessage.REQUEST to specify that this message is
used for a FIPA Request performative. Lines 3–5 conﬁgure the content language,
the ontology and the receiver of the ACLMessage. In line 6–8 a Action is instanti-
ated and provided with the receiver that is expected to perform the action and the
AgentAction the receiver is to perform. Line 9 calls the agent’s content manager that
transforms the Java objects into the speciﬁed content representation. The ready
message is returned to the caller at line 10.
Agent conﬁguration objects are created by calling the createAgentConﬁgObject in-

10.3.
Agent Behaviors
97
1
public ACLMessage createFIPARequestMessage ( Agent myAgent , AID receiver ,
AgentAction
agentAction ) throws CodecException ,
OntologyException
{
ACLMessage msg = new ACLMessage(ACLMessage .REQUEST) ;
3
msg. setLanguage ( this . getContentLanguage ( ) ) ;
msg. setOntology ( this . getOntologyName ( ) ) ;
5
msg. addReceiver ( receiver ) ;
Action a = new Action ( ) ;
7
a . setActor ( receiver ) ;
a . setAction ( agentAction ) ;
9
myAgent . getContentManager ( ) . f i l l C o n t e n t (msg, a ) ;
return msg;
11
}
Code extract 10.1: createFIPARequestMessage instance method
1
public AgentConfigObject
createAgentConfigObject ( )
{
AgentConfigObject aco = new AgentConfigObject ( ) ;
3
aco . setCodec ( this . getCodec ( ) ) ;
aco . setContentLanguage ( this . getContentLanguage ( ) ) ;
5
aco . setOntology ( this . getOntology ( ) ) ;
return aco ;
7
}
Code extract 10.2: createAgentConﬁgObject
instance
method
of
the
abstract
class
CommunicationConﬁgurationFactory
stance method, shown in Code extract 10.2. An AgentConﬁgObject object is created
in line 1. Lines 3–5 set the content codec, the language and a pointer to the ontol-
ogy that the content manager of the agent is to use. The ready object is returns in
line 6.
• AgentConﬁgObject The AgentConﬁgObject is a simple JavaBean that encapsulates
information an agent’s content manager needs to be able to use an ontology. It
deﬁnes the following instance ﬁelds:
– codec Contains the codec the agent’s content manger is to use.
– contentLanguage Contains the content language the agent’s content man-
ager is to use
– ontology contains the pointer to the ontology object the agent’s content man-
ager is to use.
10.3 Agent Behaviors
This Section discusses the behaviors class templates. Class templates were implemented
as part of the generic toolkit. No generic internal behaviors are provided with this toolkit.
Behaviors that are tightly linked with the J2J tool kit, referred to as Jessable behaviors,
are elaborated on in Section 10.7.1 due to their tight integration with Jess.
10.3.1 Communicational Behaviors
Abstract FIPA-Request-Protocol Behaviors
The JADE framework provides two implementations for the FIPA-Request-Protocol:

10.3.
Agent Behaviors
98
• The AchieveREInitiator and AchieveREResponder
• The SimpleAchieveREInitiator and SimpleAchieveREResponder
The former is a more heavy weight implementation. Both take as constructor argument
an ACLMessage that initiates the protocol, thus the initiator themselves contain the steps
to send the initial message. The SimpleAchieveREInitiator and the SimpleAchieveREResponder
are the lightweight implementation of the AchieveREInitiator and AchieveREResponder. The
main diﬀerence is that heavyweight implementations can delegate states of the protocol
to other, application speciﬁc behaviors [BCTR00, p. 8]. For the Matrix, the lightweight
behaviors were suﬃcient.
The SimpleAchieveREResponder and SimpleAchieveREResponder
abstract class are both extended with the RequestInitiatorTemplate abstract class respec-
tively the RequestResponderTemplate. These classes implement hook operations that can
be overwritten by their subclasses. The RequestInitiatorTemplate and RequestResponderTem-
plate are described in the rest of this Section.
• RequestInitiatorTemplate The RequestInitiatorTemplate, shown in Code extract 10.3,
is used by the initiator of a FIPA-Request-Protocol based conversation. As stated
in the preceding section, the message to initiate the protocol is not created by the
behavior but passed as a constructor argument to the behavior. This class contains
two template methods, handleInform and handleFailure. handleInform is called when the
participant successfully performed the action and returns either a Done to indicate
that the communicative act was successful or Result to return results created by the
performative. A subclass has to, depending on what kind of response is expected,
either overwrite executeInformDone (called in line 24) or executeInformResult (called in
line 28).
executeInformDone expects as arguments an agent action and a message.
This permits the hook operation to access the entire message, if required. execute-
InformResult expects, in addition to the agent action and the ACLMessage, the result
returned by the participant.
The SimpleAchieveREResponder calls handleFailure when the participant could not suc-
cessfully execute the performative requested by the initiator and returns a failure.
If the failed performative was to return a Done predicate, the executeFailureDone
operation in line 48 is called. Otherwise, if a result predicate was excepted, execute-
FailureResult is executed (line 52).
1 public abstract class
RequestInitiatorTemplate extends SimpleAchieveREInitiator
{
3
public
RequestInitiatorTemplate ( Agent a , ACLMessage msg)
{
super (a , msg) ;
5
this . setProtocol (msg) ;
}
7
9
public
RequestInitiatorTemplate ( Agent a , ACLMessage msg,
DataStore
store )
{
super (a , msg,
store ) ;
11
this . setProtocol (msg) ;
}
13
private void
setProtocol
(ACLMessage msg)
{
15
msg. setProtocol (FIPANames . I n t e r a c t i o n P r o t o c o l .FIPA_REQUEST) ;
}
17
protected void handleInform (ACLMessage msg) {
19
try
{
ContentElement ce = this . myAgent . getContentManager ( ) . extractContent (msg) ;
21
i f
( ce instanceof Done)
{
Done done = (Done) ce ;
23
Action
action = ( Action ) done . getAction ( ) ;
this . executeInformDone ( action . getAction ( ) , msg) ;

10.3.
Agent Behaviors
99
25
}
i f
( ce instanceof
Result )
{
27
Result
r e s u l t = ( Result ) ce ;
this . executeInformResult ( r e s u l t . getAction ( ) ,
r e s u l t . getValue ( ) , msg) ;
29
}
} catch ( UngroundedException e )
{
31
e . printStackTrace ( ) ;
} catch ( CodecException e )
{
33
e . printStackTrace ( ) ;
} catch ( OntologyException e )
{
35
e . printStackTrace ( ) ;
}
37
}
39
protected void executeInformResult
( Concept agentAction ,
Object
resultValue ,
ACLMessage msg)
{ }
41
protected void executeInformDone
( Concept agentAction ,
Predicate
condition , ACLMessage
msg)
{ }
43
protected void handleFailure (ACLMessage msg) {
try
{
45
ContentElement ce = this . myAgent . getContentManager ( ) . extractContent (msg) ;
i f
( ce instanceof Done)
{
47
Done done = (Done) ce ;
this . executeFailureDone ( done . getAction ( ) , msg) ;
49
}
i f
( ce instanceof
Result )
{
51
Result
r e s u l t = ( Result ) ce ;
this . executeFailureResult ( r e s u l t . getAction ( ) ,
r e s u l t . getValue ( ) , msg) ;
53
}
} catch ( UngroundedException e )
{
55
e . printStackTrace ( ) ;
} catch ( CodecException e )
{
57
e . printStackTrace ( ) ;
} catch ( OntologyException e )
{
59
e . printStackTrace ( ) ;
}
61
}
Code extract 10.3: RequestInitiatorTemplate
• RequestResponderTemplate The RequestResponderTemplate behavior, shown in
Code extract 10.4, is used by the participant in a FIPA-Request-Protocol. It con-
tains the Template Method prepareResponse that generalizes the algorithm for ac-
cepting a message containing a Request performative. The algorithm extracts the
action and calls a hook operation that a subclass has to overwrite in order to exe-
cute the performative requested by the initiator. This class requires a more detailed
description than its peer. At the beginning and at the end of the Template Method,
the hook operations doAtBeginning (line 15) and doAtEnd (line 35) are called. These
methods can be overwritten by their subclasses to handle tasks that should always
be executed before the agent action is handled and when the behavior has ﬁnished
executing the agent action. Because a JADE agents use cooperative multi-tasking
by default and not preemptive multi-tasking to schedule behaviors [BCTR00, p.
25], it is guaranteed that a running behavior will not be interrupted to run another
behavior of the same agent without its consent, thus no additional multi-threading
handling is necessary. In lines 16–19, the message reply is automatically created
and the agent action extracted from the incoming message. At line 20, the han-
dling of the agent action is delegated to the subclass by calling the hook operation
executeAction which accepts as argument the incoming agent action. To successfully
execute, this method has to return a predicate of the type Done or Result and, at
some point, set the message performative by calling setMessagePerformative. The

10.3.
Agent Behaviors
100
instance messagePerfomative (line 3) is set to −1. This value will cause JADE to
throw an error. By calling setMessagePerformative the subclass sets the messagePer-
formative ﬁeld to a valid value. The message performative is set at line 26 with the
messagePerfomative value.
1 public class RequestResponderTemplate extends SimpleAchieveREResponder {
3
private
int
messagePerformative = −1;
5
public RequestResponderTemplate ( Agent a ,
MessageTemplate mt )
{
super (a , mt ) ;
7
}
9
private
static
f i n a l
long serialVersionUID = −7103764786428162858L ;
11
protected void doAtBeginning ( )
{ }
13
protected void doAtEnd ( )
{ }
protected ACLMessage prepareResponse (ACLMessage request ) throws NotUnderstoodException
,
RefuseException
{
15
this . doAtBeginning ( ) ;
ACLMessage reply = request . createReply ( ) ;
17
try
{
Action a = ( Action )
this . myAgent . getContentManager ( ) . extractContent ( request ) ;
19
Concept agentAction =
a . getAction ( ) ;
Predicate p = this . executeAction ( agentAction ) ;
21
i f
( p instanceof Done)
{
( ( Done) p ) . setAction ( a ) ;
23
}
else
i f
( p instanceof
Result )
{
( ( Result ) p ) . setAction ( a ) ;
25
}
reply . setPerformative ( this . messagePerformative ) ;
27
this . myAgent . getContentManager ( ) . f i l l C o n t e n t ( reply , p ) ;
} catch ( UngroundedException e )
{
29
e . printStackTrace ( ) ;
} catch ( CodecException e )
{
31
e . printStackTrace ( ) ;
} catch ( OntologyException e )
{
33
e . printStackTrace ( ) ;
}
f i n a l l y
{
35
this . doAtEnd ( ) ;
}
37
return
reply ;
}
39
protected
Predicate
executeAction
( Concept agentAction ) throws NotUnderstoodException ,
RefuseException {
41
return
null ;
}
43
protected void setMessagePerformative ( int
messagePerformative )
{
45
this . messagePerformative = messagePerformative ;
}
47 }
Code extract 10.4: RequestResponderTemplate
10.3.2 Message Templates
The Section above on agent communication stated that the participating agent accepts
the incoming message and activates the proper Response behavior. To restrict a behavior
that reacts to messages from being activated for every incoming message, the agent’s
receive method called within a behavior has to be provided with the message template.
receive will return the ﬁrst message that matches the pattern deﬁned by the template.
A SimpleAchieveREResponder accepts a template as a constructor argument. An Abstract

10.3.
Agent Behaviors
101
MessageTemplateFactory
+createProtocolInitializationWitchAction( Class action ) : MessageTemplate
FIPARequestFactory
+FipaRequestFactory( Agent myAgent )
+createProtocolInitializationWithAction( Class action ) : MesageTemplate
MatchActionExpression
+MatchActionExpression( Class action, Agent agent )
+match( ACLMessage msg ) : boolean
MatchExpression
MessageTemplate
AndExpression
Literal
<<use>>
Figure 10.2: Classes involved in the message template creation process
1 public MessageTemplate
c r e a t e P r o t o c o l I n i t i a l i s a t i o n W i t h A c t i o n (
Class
action )
{
3
MessageTemplate fipaRequestInit = MessageTemplate . and ( MessageTemplate
. MatchProtocol (FIPANames . I n t e r a c t i o n P r o t o c o l .FIPA_REQUEST) ,
5
MessageTemplate . MatchPerformative (ACLMessage .REQUEST) ) ;
MessageTemplate
a c t i o n F i l t e r = new MessageTemplate (
7
new MatchActionExpression ( action ,
this . myAgent ) ) ;
return MessageTemplate . and ( fipaRequestInit ,
a c t i o n F i l t e r ) ;
9 }
Code extract 10.5: createProtocolInitialisationWithAction instance method
Factory was developed to automate the creation of message templates. The Class Diagram
is shown in Figure 10.2. Classes and interfaces of the JADE framework (MessageTemplate,
Literal, MatchActionExpression, AndExpression) have their interface omitted.
Abstract Factory
MessageTemplateFactory
The Abstract Factory MessageTemplateFactory currently de-
ﬁnes one method signature to create message templates. createProtocolInitialisationWithAction
expects a Java class object of an agent action as argument and returns a message tem-
plate for the FIPA-protocol type and step in the conversation. For each FIPA-protocol
used, a concrete factory should be developed.
FipaRequestFactory
The concrete factory for the FIPA-Request-Protocol is the Fi-
paRequestFactory class. In addition to the createProtocolInitialisationWithAction it oﬀers a class
method getInstance to access its Singleton object. The implementation of the createPro-
tocolInitialisationWithAction for the FIPA-Request-Protocol is shown in Code extract 10.5.
This method generates a template that matches a message with the following properties:
it is a Request performative of a FIPA-Request-Protocol conversation and contains an
agent action that is the instance of a class this method received as an argument. An ob-
ject diagram of the object structure created by this method is shown in Figure 10.3. For

10.4.
Software Agents
102
the sake of simplicity, the diagram is not fully UML conform. The object ﬁelds contain
the name of class ﬁelds instead their values and the agent action class is referenced to as
"AnAgentAction.class" to indicate that this ﬁeld will hold a reference to an agent action
class object.
 : Literal
matchValue = "InteractionProtocol.
FIPA_REQUEST"
slotName = "MessageTemplate.
PROTOCOL"
 : Literal
slotName = "MessageTemplate.
PERFORMATIVE"
matchValue = "ACLMessage.
REQUEST"
 : MatchActionExpression
action = "AnAgentAction.class"
fipaRequestInit : AndExpression
actionFilter : MessageTemplate
 : MessageTemplate
 : MessageTemplate
 : AndExpression
-toMatch
- op2
- op1
-toMatch
- op1
-toMatch
- op2
Figure 10.3: Object composition for the message template created by the createProtocol-
InitialisationWithAction method
Template Extension
• MatchActionExpression To match the agent action of an incoming message, the
MatchActionExpression was developed.
It implements the MatchExpression interface
and can thus be used in any template.
10.4 Software Agents
This Section introduces the interface to access the Jess instance of an agent.
10.4.1 JessableAgent
JessableAgent is an interface for agents to implement that use Jess to reason. It speciﬁes
one instance method:
getJessCNC This method is to return the JessCNC1 instance of the agent.
The approach of keeping the Jess relevant objects in the JessCNC object and letting an
agent implement the JessableAgent interface was chosen in favor of developing an abstract
Jess agent. With this approach, the Jess implementation can be added to existing agents
without having a larger impact on their class structure.

10.5.
Jess and JADE Integration Object
103
Figure 10.4: High-level overview of the JADE and Jess integration
10.5 Jess and JADE Integration Object
This Section describes the class that manages the Jade and Jess integration. A high-level
overview of the system is depicted in Figure 10.4. It shows how the system is assembled of
several subsystems and reveals the interaction points between sub systems. The picture
shows that the integration is managed by the Jess Command and Control (JessCnC)
object. Inside this object, two objects stand out:
• The Jess engine that manages the working memory and rules to reason on facts
that are in the working memory. Only Jess Engine Manager has a pointer to that
object, all other objects have to go through Jess Engine Manager to access it.
• The ontology that structures the working memory and deﬁnes the semantics of
the ACLMessages contents. The ontology is never accessed directly by objects that
require its service. It is managed by the Ontology Tree Manager which lets other
managers that fulﬁll a speciﬁc service, access it through Visitor objects.
The J2J tool kit can be used to control the entire business logic of an agent. In this case
behaviors can be seen as channels used by Jess to communicate with other agents. It
can however also be used to replace a certain subset of the decision making and thus also
have part of the agent’s intelligence managed by standard behaviors.

10.5.
Jess and JADE Integration Object
104
JessCNC
+jessCNC( Agent masterAgent )
#startJess() : void
#oadOntologyTreeManagers() : void
#jessDependentManagers() : void
#addInitialFunctionsToJess() : void
#stopJess() : void
#restartJess() : void
+getJessEngineManager() : JessEngineManager
+getOntologyTreeManager() : OntologyTreeManager
+getRemoteTreeListenerManager() : RemoteTreeListenerManager<String>
+getJessFunctionManager() : JessFunctionsManager
+getOntologyClassManager() : OntologyClassManager<Map<String, Class<Concept>>>
+getAgentOutputWriter() : AgentOutputWriter
+configureMasterForJessRemoteAdministration()
OntologyClassManager<Map<String, Class<Concept>>>
RemoteTreeListenerManager<String>
Jade2JessOntologyManager<String>
OntologyTreeManager
-unnamed1 : AgentOutputWriter
JessFunctionsManager
JessEngineManager
AgentOutputWriter
Figure 10.5: JessCNC and managers
10.5.1 Jess Integration
The core of the integration approach chosen for this thesis forms the class JessCNC. It
contains a set of manager classes. Each manager assumes certain functionalities. Jess-
CNC oﬀers an interface to access to these managers and handles their integration. It
additionally contains the instance method conﬁgureMasterForJessRemoteAdministration that
will conﬁgure a master agent to communicate with remote Jess Administration agents.
The Class Diagram of JessCNC and the classes it uses is shown in the class diagram of
Figure 10.5. The interfaces of the adjacent classes are omitted.
The initialization of a JessCNC object is shown in Code extract 10.6. It is divided in two
steps:
1. It ﬁrst loads the ontology and instantiates objects that will use the ontology (line
3 and lines 28–33). These objects are Observers that need the ontology to perform
their tasks. Each Observer receives a Visitor object that will traverse the ontol-
ogy for them and return information the Observers require. The Ontology Tree
Manager, the object that manages the ontology, is the Subject that will notify its
Observers when the ontology is changed or is newly created. The Observers must
therefore register themselves with the Ontology Tree Manager. This is described in
detail in Section 10.6.1.
2. Once the ontology is loaded into memory and the ontology Observers (also referred
to as listeners) are ready, the second step is executed to prepare and launch the
Jess rule-engine. It starts by instantiating a AgentOutputWriter object (line 8) (more
in Section 10.5.3) and then instantiates the JessEngineManager (line 10), the object
that controls access to the Jess rule-engine (Section 10.5.2).
This order of initialization steps is important: Jess will cause errors if it contains rules
that use unknown templates. Because all templates in this implementation are generated
from the ontology created for JADE, the ontology has to be loaded ﬁrst. The algorithm
1CNC stands for Command aN d Control and is a reference to the TV Series Babylon 5 [24]

10.5.
Jess and JADE Integration Object
105
veriﬁes whether if it is the ﬁrst time startJess is executed (line 13). This check is necessary
for the JADE to Jess Ontology Manager, the manager that maps the JADE ontology to
Jess templates. The manager will restart Jess if the ontology class structure is altered
or none is available. The updateTree method of the Ontology Tree Manager rebuilds the
ontology tree and causes all Observers to update their representation of the ontology and
in some cases perform additional tasks for their clients. This would cause the JADE to
Jess Ontology Manager to restart Jess with new templates, thus causing an undesired
inﬁnite loop. Therefore, JessCnC and the JADE to Jess Ontology Manager need to treat
the ﬁrst time startJess is called as a special case. This is further discussed in Section 10.6.3.
Next, managers that require a valid reference to a Jess Engine Manager are started by
calling the method JessDependentManagers in line 17. In this implementation this is merely
the Jess Function Mangager (line 36). Next, new Jess functions are added to Jess (line
18) and Jess is started (line 19). Finally, the AgentOutputWriter object is added to the Jess
engine (line 20).
1
public JessCNC( Agent masterAgent )
{
this . masterAgent = masterAgent ;
3
this . loadOntologyTreeManagers ( ) ;
this . startJess ( ) ;
5
}
protected void
startJess ( )
{
7
try
{
this . out = new AgentOutputWriter ( ) ;
9
FileReader
JessDefaultRules = null ;
URL u r l = getClass ( ) . getResource ( " / expertSystem / r u l e f i l e s / ipd . clp " ) ;
11
JessDefaultRules = new FileReader ( u r l . getPath ( ) ) ;
this . jem = new JessEngineManager ( this ,
JessDefaultRules ) ;
13
i f
( this . f i r s t T i m e )
{
this . getOntologyTreeManager ( ) . updateTree ( ) ;
15
this . f i r s t T i m e = false ;
}
17
this . JessDependentManagers ( ) ;
this . addInitialFunctionsToJess ( ) ;
19
this . jem . i n i t i a l i z e J e s s ( ) ;
this . jem . setAgentOutputWriter ( this . out ) ;
21
} catch ( FileNotFoundException e1 )
{
e1 . printStackTrace ( ) ;
23
} catch ( JessException e )
{
e . printStackTrace ( ) ;
25
}
}
27
protected void loadOntologyTreeManagers ( )
{
29
this . treebeard = new OntologyTreeManager ( ) ;
this . classReg = new OntologyClassManager (new C l a s s C o l l e c t o r V i s i t o r ( ) ,
this .
getOntologyTreeManager ( ) ) ;
31
this . j2jom = new Jade2JessOntologyManager (new Jade2JessVisitor ( ) ,
this .
getOntologyTreeManager ( ) , this ,
this . f i r s t T i m e ) ;
this . remoteTL = new RemoteTreeListenerManager (new LispingTreeVisitor ( ) ,
this .
getOntologyTreeManager ( ) ,
this . masterAgent ) ;
33
}
35
protected void JessDependentManagers ( )
{
this . j f r
= new JessFunctionsManager ( this ) ;
37
}
Code extract 10.6: Initializing JessCNC
10.5.2 Jess Engine Manager
The JessEngineManager class (see UML Class Diagram of Figure 10.6) encapsulates a
jess.Rete object. The jess.Rete class implements the Jess rule-engine. At initialization

10.5.
Jess and JADE Integration Object
106
JessEngineManager
~JessEngineManager( JessCNC jesscnc, FileReader jessDefaultRules )
#initializeJess() : void
#setAgentOutputWriter( AgentOutputWriter aow ) : void
+setModuleFocus( String module ) : void
+runJess() : void
#addFunctionToJess( Userfunction func ) : void
+clearModuleFocusStack() : void
+popCurentModuleFromStack( String expectedModule ) : String
+getCurrentModule() : String
+setCurrentModule( String module ) : void
+updateObjectInJess( Object o ) : void
+queryJess( String query, ValueVector value ) : Iterator
+addFactToJess( Object fact ) : void
+removeFactsFromJess( int i ) : void
+executeJessCommand( String command ) : void
+evalJessExcpression( String command ) : void
+removeShadowFactFromJess( Object o ) : void
#getInitializationModule() : String
#setInitializationModule( String initializationModule ) : void
+getGlobalContext() : Context
Rete
Figure 10.6: JessEngineManager class
time, a Jess Engine Manager stores the location of the ﬁle that contains the Jess rules
and instantiates the Jess rule-engine. The rule ﬁle is only parsed when initializeJess is
called. This class contains the following instance ﬁelds:
• jess This instance ﬁeld contains a reference to the Jess jess.Rete class.
• initializationModule This ﬁeld contains the name of the Jess module that is to
have the focus when the rule engine starts to run. It may be empty. It is set by call-
ing setInitializationModule and accessed with the instance method getInitializationModule.
• conﬁg This instance ﬁeld contains a java.io.FileReader object with the location of
the default rule ﬁle. The rules are parsed when initializeJess is called for the reasons
stated in Section 10.5.1. initializeJess parses the rule ﬁle into the Jess rule-engine
and calls its reset method to initialize the working memory.
To add a new AgentOutputWriter, the setAgentOutputWriter is called with an AgentOutputWriter
instance as argument. This object replaces the default routers set in Jess, thus all output
generated by Jess is passed to the AgentOutputWriter object (this is discussed in the next
Section). The other methods forward requests to the Rete object, in some cases oﬀering
a simpliﬁed interface.
10.5.3 Jess Output Routing
The Jess API oﬀers methods to manipulate the I/O routers [Hil03, p. 319]. The Jess
function printout takes as ﬁrst argument the output router, e.g.
(printout t "message") to
which the string message is passed. By default this is t. New routers can be added with
the instance method addOutputRouter and passing the new router name and the object itself
to which the output is sent to when the router is called. For this this implementation,
only the output routers were changed. An output router is java.io.Writer object. It was
decided to replace the default routers with an own router for the master agent. The
reason for this decision is simplicity: when writing Jess rules, the developer should not

10.5.
Jess and JADE Integration Object
107
AgentOutputWriter
~AgentOutputWriter()
+close() : void
+flush() : void
+write( char[] cbuf, int off, int len ) : void
+addStrategy( String name, JessOutputStrategy strategy ) : void
+removeStrategy( String name ) : void
JadeMessageOutputStrategy
+writeOutput( String output ) : void
ConsoleOutputStrategy
+writeOutput( String output ) : void
JessOutputStrategy
+writeOutput( String output ) : void
Figure 10.7: AgentOutputWriter and Strategies
worry about whether or not a rule should route the output to the master agent’s router
or to the Jess default router. The new router class oﬀers a central point to which all
Jess output is sent. It then decides to which destinations it will forward the output.
Jess remains unaware of how the output is further processed. The Java I/O library is
based on the Decorator design pattern [Eck06, p. 915] (more on the Decorator design
pattern in [GHJV95, p. 175]). Thus rather than creating one object to handle the entire
I/O algorithm, functionality is shared among several objects, which can be be connected.
The new Jess router for this thesis is the class AgentOutputWriter. It is wrapped inside
a java.io.BufferedWriter to increase I/O operations which is decorated by a java.io.PrintWriter
to format the output [Eck06, p. 930]. This conﬁguration is done by the Jess Engine
manager when its instance method setAgentOutputWriter is called. The class diagram of
the AgentOutputWriter and its adherent Strategies is shown in Figure 10.7. This diagram
assumes that two Strategies have already been added, a Strategy to print the output to
stdout and a Strategy that sends a message to a Jess Administration agent (discussed in
Section 9.4.2) that wishes to be notiﬁed when Jess generates output.
When the write instance method of an AgentOutputWriter object is called, it accepts a charac-
ter array, transforms it into a string and then iterates over a set of Strategies which handle
the output. This process is shown in the Sequence Diagram of Figure 10.8. The output
handling of the Strategies is omitted.
The motivation for choosing strategies instead
of developing additional Decorators is the following: new Strategies can be added (and
removed) to the Context without having to worry about the nesting of the Decorators;
adding new Decorators would require to keep a pointer of the last Decorator which would
in addition need a method to add a child. This would be contradictory to the Decorator’s
philosophy of "Changing the skin of an object" [GHJV95, p. 179]. It would resemble
changing its guts, which is the metaphor for what Strategy pattern does [GHJV95, p.
179]. To adhere to the philosophy of the Decorator would require to, every time a new
Decorator is added during run time, to rewrap the current object structure and add it
back to Jess. In the author’s opinion, this would increase the complexity compared to
that of adding a new Strategy.
Jess Output Strategies
Jess Output Strategies extend the JessOutputStrategy abstract class, as depicted in Fig-
ure 10.7. The JadeMessageOutputStrategy is part of the Remote Jess Administration and

10.6.
Ontology Management
108
 : JadeMessgeOutputStrategy
 : ConsoleOutputStrategy
aow : AgentOutputWriter
jessto : PrintWriter
 : BufferedWriter
jess : Rete
transfers the string
 into a character 
array and buffers 
the stream
writeOutput("text")
5: 
writeOutput("text")
6: 
write("text")
2: 
write(['t','e','x','t'])
4: 
flushBuffer
3: 
print("text")
1: 
Figure 10.8: Jess output routing with the AgentOutputWriter
discussed in Section 9.4.2. It deﬁnes two instance methods: writeOutput that accepts the
text string and processes it further and the hook operation onRemove that can be over-
written if the subclass needs to perform additional steps when the Strategy is removed,
for example closing open connections. One default Strategy is implemented:
• ConsoleOutputStrategy The ConsoleOutputStrategy writes the output the console,
by calling System.out.println().
10.6 Ontology Management
The management of the ontology forms an integral part of Jess management object. It
is located in the Ontology Tree Manager. Because the master agent uses Jess (instead
of agent behaviors) for the business intelligence, a mapping between the ontology repre-
sentation used by JADE and the ontology representation used by Jess is needed. The
approach chosen for this thesis is the following:
1. The ontology is modeled using the Protégé framework and with the Protégé Bean
Generator Plugin (see Section 5.3.1 of Chapter 5), the ontology for JADE is gener-
ated.
2. The Ontology Tree Manager reads the ontology and creates a Composite object
tree (based on the Composite design pattern [GHJV95, p. 165]) in which each node
represents one class in the ontology. A node contains in addition to pointers to its
parent and child nodes the name of the class it represents and its Class object.
3. The Ontology Tree Manager is the Subject to which a set of Observers are attached
that are notiﬁed when the ontology changes.
The Observers are referred to as

10.6.
Ontology Management
109
managers in this thesis.
Manager themselves do not contain the algorithms to
traverse the ontology. Each manager has its own Visitor which traverses the tree
and generates an output their manager can use.
Ontology Composite
OntologyElement<V>
+OntologyElement( String name )
+accept( OntologyVisitor<?> visitor )
+addJavaClass( Class<V>javaClass ) : void
+addChild( OntologyElementchild ) : void
+getChildren() : List<OntologyElement>
+getName() : String
+getParent() : OntologyElement
+setParent( OntologyElementparent ) : void
+getJavaClass() : Class<V>
+setJavaClass( Class<?>javaClass ) : void
PredicateClass<Predicate>
+accept( OntologyVisitor<?> visitor )
ConceptClass<Concept>
+accept( OntologyVisitor<?> visitor )
OntologyRootClass<Concept>
+accept( OntologyVisitor<?> visitor )
Figure 10.9: Composite for the ontology managed by the Ontology Tree Manager
The ontology is represented as a object composition. Each node represents a class in the
ontology. The Class Diagram for the ontology Composite is depicted in Figure 10.9. The
distinction between leafs and composites is not made. A leaf is a composite with the child
null. The classes in the Composite do not contain operations that operate on the nodes.
These operations are packaged separately in Visitors. This is discussed in more detail in
Section 10.6.2. The classes used in for the ontology Composite are the following:
• Ontology Element OntologyElement is a generic abstract class. It implements meth-
ods to manipulate the following ﬁelds:
– children Is a java.util.Vector that contains the node’s children. If the node is a
leaf, children is null.
– parent Contains the parent of the node. For the root node, parent is null.
– javaClass Contains the class object of the JADE ontology class it represents.
– name Contains the string value of the JADE ontology’s Java class name.
The OntologyElement class deﬁnes the abstract method accept. This method accepts
OntologyVisitor object that needs to access the node. Every subclass must implement
this methods separately owing to the fact that it has to call the Visitor method
that is explicitly assigned to its class. An example is depicted in Figure 10.15.
• Ontology Root Class The OntologyRootClass creates an "artiﬁcial" root for the
object hierarchy. As shown in [BCG07, p. 81], an ontology, as deﬁned by the content
reference model of JADE. consists of three predeﬁned classes: Predicate, Concept and
AgentAction as a subclass of Concept. They do not have a direct root class. A common
root does however simplify traversing the tree. Instead of "polluting" the hierarchy

10.6.
Ontology Management
110
with classes that will never be used by representing the whole content reference
model of JADE, this artiﬁcial root was created.
• Concept Class A ConceptClass object represents a class that is a subclass of the
jade.content.Concept interface. This includes subclasses of jade.content.AgentAction.
• Predicate Class A PredicateClass object represents a class that subclasses
jade.content.Predicate.
10.6.1 Ontology Tree Manager
+Jade2JessOntologyManager( OntologyVisitor<String> visitor, OntologyTreeManager ontologyTreeManager, JessCNC jesscnc, boolean firstTime )
-loadJadeOntologyIntoJess() : void
+treeChanged() : void
Jade2JessOntologyManager<String>
OntologyClassManager<Map<String, Class<Concept>>>
#OntologyClassManager( OntologyVisitor<Map<String, Class<Concept>>> visitor, OntologyTreeManager ontologyTreeManager )
+getActionInitiatorBehaviourTuble( Stringname ) : Tuple<Class<AgentAction>,Class<Behaviour>>
+getOntologyConceptNames() : Set<String>
+addJessableBehaviour( Stringname, Class<Behaviour>jessableBehaviour ) : void
+addOntologyConcept( Stringname, Class<Concept>agentAction ) : void
+getOntologyConcept( Stringname ) : Class<Concept>
+treeChanged() : void
RemoteTreeListenerManager<String>
+registerRemoteListener( AID listener ) : void
+removeRemoteListener( AID listener ) : void
#updateListeners() : void
+treeChanged() : void
#RemoteTreeListenerManager( OntologyVisitor visitor, OntologyTreeManager ontologyTreeManager, Agent myAgent )
TreeUser<V>
#TreeUser( OntologyVisitor<V> visitor, OntologyTreeManager ontologyTreeManager )
#getOntologyTreeManager() : OntologyTreeManager
#getVisitor() : OntologyVisitor<V>
OntologyTreeManager
-unnamed1 : AgentOutputWriter
~OntologyTreeManager()
+updateTree() : void
-loadOntologyElementClasses() : void
+getRoot() : OntologyElement<V>
+getConceptRoot() : OntologyElement<V>
+getPredicateRoot() : OntologyElement<V>
-setupTree() : void
-createOntologyElement( String oeName, String className ) : OntologyElement<V>
-buildSimpleTree() : Vector[]
-buildVisitorWorthyTree( Vector[] tree ) : void
#updateObservers() : void
+registerOntologyTreeObserver( OntologyTreeObserverotl ) : void
#getLastUpdate() : long
#setLastUpdate( longlastUpdate ) : void
TreeSubject
OntologyTreeObserver
+treeChanged() : void
Figure 10.10: Ontology Management Classes
The Ontology Tree Manager covers two crucial tasks: it generates the composite tree
representing the ontology and oﬀers an interface to access the root of the ontology and
the root of the subtrees Concept and Predicate. The class diagram for the OntologyTree-
Manager and its surrounding managers (i.e. Observers) is shown in Figure 10.10. The
RemoteTreeListenerManager class is part of the Jess Remote Administration and discussed
in Section 9.4.2. This Section elaborates on the Subject of in the Observer pattern, thus
the classes TreeSubject and OntologyTreeManager. Both classes are described, followed by
detailed discussion on how the composite hierarchy is created.

10.6.
Ontology Management
111
• TreeSubject The TreeSubject class contains two private instance ﬁelds:
aSubject : OntologyTreeManager
anObserver : TreeUser
Registers the new 
Observer
Pulls the data is 
requires from the 
Subject and 
processes it
updateObservers
2: 
treeChanged()
3: 
registerOntologyTreeObserver(this)
1: 
getRoot()
4: 
Figure 10.11: A new Observer registering itself with the concrete Subject
– Observers A java.util.Vector that contains tuples (using the helper class expert-
System.mgmt.utils.Tuple) of Long and OntologyTreeObserver. The ﬁrst value is the
time when the Observer was last updated, the second value is a reference to
that Observer. Observers are added by calling registerOntologyTreeObserver. The
algorithm performed by registerOntologyTreeObservers is shown in Figure 10.11.
It shows a new Observer that is being attached to the Subject.
The par-
ticipants in this example are an arbitrary Observer of the type TreeUser and
a concrete Subject of the type OntologyTreeManager. The algorithm does the
following:
1. A TreeUser object registers itself with the Subject by calling registerOntolo-
gyTreeObserver with its reference as an argument (step 1).
2. A new Tuple is created containing a reference of the Observer. The update
time is set to 0.
3. The Subject calls its instance method updateObservers (step 2).
4. updateObservers calls treeChanged of each Observer that has an update
time smaller than lastUpdate (step 3).
treeChanged causes an Observer
to "pulling" the Subject’s data (step 4). Next, the update time of the
Observer is set to the current system time in milliseconds.
– lastUpdate A Long value stating the time in milliseconds when the ontology
composite was last updated.
This ﬁeld is accessed and modiﬁed with the
protected methods getLastUpdate and setLastUpdate.
• OntologyTreeManager The OntologyTreeManager is the concrete Subject that cre-
ates the ontology composite and oﬀers an interface to its Observers to access the
ontology. Its instance ﬁelds are:

10.6.
Ontology Management
112
– ontologyClasses This instance ﬁeld is a HashMap that stores each OntologyEle-
ment node in the ontology composite managed by the Ontology Tree Manager.
The key of a value is the class name the node represents. This ﬁeld is used dur-
ing the ontology composite creation to quickly access nodes that have already
been created.
– factories This instance ﬁeld is a HashMap.
The values are the Java class
objects nodes in the ontology Composite: OntologyRootClass, ConceptClass and
OntologyRootClass. The keys are the simple name of the classes. This ﬁeld is
used to simplify the creation of the ontology Composite. It is accessed by the
private instance method createOntologyElement. It takes two string arguments:
The class name of the concrete composite element and the class name of the
class the node is to represent. It returns an instance of a concrete OntologyEle-
ment subclass.
– root This instance ﬁeld is of the type OntologyElement. It stores a reference to
the root of the ontology composite. This ﬁeld is accessed with the instance
method getRoot.
– conceptRoot This instance ﬁeld is of the type OntologyElement. It stores a
reference to the top-level of the Concepts subtree. This ﬁeld is accessed with
the instance method getConceptRoot.
– predicateRoot This instance ﬁeld is of the type OntologyElement. It stores a
reference to the top-level of the Predicates subtree. This ﬁeld is accessed with
the instance method getPredicateRoot.
In addition to the methods for the ﬁelds that were described above, the OntologyTree-
Manager implements the following methods:
– setupTree This method creates the top-level and the second-level of the on-
tology composite. Every new node is attached to either one of them, excluding
to the root node.
– buildSimpleTree This method reads the ontology classes from the ﬁle system
and adds the classes to a data structure from which the ontology composite
can be generated.
– buildVisitorWorthyTree This method generates the ontology composite
that will be used by the Visitors of its Observers.
– updateTree This method causes the Ontology Tree Manager to generate the
ontology composite and notify its Observers that the ontology has changed by
executing updateObservers.
The composite generation is discussed in detail in the next Section.
Creating the Jade Ontology Composite
An ontology composite managed by the Ontology Tree Manager is created in three stages:
1. The top of the tree is created. The top consists of the artiﬁcial root of the type
OntologyRootClass and its two children PredicateClass and ConceptClass. This structure
has to be generated in a separate step from the rest of the ontology because it cannot
be generated from the information available on the ﬁle system and from the ontology
instance.

10.6.
Ontology Management
113
2. The ontology Java classes that were created by Protégé are loaded from the ﬁle sys-
tem and their names and class objects added to two Vectors: one Vector containing
the name of the class and one Vector the Class objects. A class has its name and
Class object at the same position in both Vectors. The classes are sorted to be in the
following order: The class at position p in the Vector has to be at a higher level in
the tree than the class at the position p + 1, if p + 1 is below p in the ontology class
hierarchy. This permits to create the ontology composite top-down and knowing
that, if the class has a parent, it has already been processed and can be attached
to it.
Basically the sorting algorithm works as follows: It uses two vectors: one vector
that contains the unsorted classes read from the ﬁle system and one vector that
will contain the classes in the order deﬁned above. In the implemenation of this
algorithm with the method buildSimpleTree, shown in Code extract D.2, these are the
Vectors domainOntologyContent for the unsorted classes and stringResult (respectively
classResult for the Class objects) for the sorted classes. The algorithm loops over the
vector that contains the unsorted classes and executes the following steps until all
classes have been sorted and the vector containing the unsorted classes is empty:
It removes the ﬁrst elment of the vector containing the unsorted classes and stores
it in the variable current. If the current element’s parent is not in the in the vec-
tor containing the unsorted classes, it is added to vector that contains the sorted
classes and the next iteration of the loop is started. Otherwise, the current class
is placed at the position of its parent in the vector containing the unsorted classes
and current is set the parent (of the previously current class) for which the next
iteration is started. The implementation of this algorithm is explained in detail in
Appendix D, Section D.2.
Figure 10.12: Simple class hierarchy for the sorting example
Step
C
DOC
R
0
C3
C4
C1
C5
C2
1
C1
C4
C3
C5
C2
2
C4
C3
C5
C2
C1
3
C2
C3
C5
C4
C1
4
C3
C5
C4
C1
C2
5
C5
C4
C1
C2
C3
6
C4
C1
C2
C3
C5
7
C1
C2
C3
C5
C4
Table 10.1: Steps performed by the buildSimpleTree of Code extract D.2 for the class hier-
archy in Figure 10.12

10.6.
Ontology Management
114
An example of how this sort works is given for the class hierarchy shown in Fig-
ure 10.12. Table 10.1 contains each step executed by the algorithm. Step 0 shows
the order of the classes after they were loaded from the ﬁle system. Each row shows
the state of the Vectors after a iteration is performed. The variable current repre-
sented by row C. The arrays are domainOntologyContent, in column DOC and the
ﬁnal result (Vectors classResult and stringResult), in column R. The entries that are
underlined in column DOC and C are the entries that were swapped.
3. The Vector array created in second step is used to create the ontology Composite.
The Composite structure of the ontology is created top down. Each child node is
attached to its parents node. This is shown in Figures 10.13(a) to 10.13(e) for the
example given in Figure 10.12. The example shows the construction of the tree,
top down, from left to right. The reader shall note that the order of nodes at the
same level is not of relevance. The implementation of this algorithm is described in
details in Appendix D, Section D.3.
(a)
(b)
(c)
(d)
(e)
Figure 10.13: Steps performed to construct a composite structure of the ontology of Fig-
ure 10.12
10.6.2 Ontology Visitors
LispingTreeVisitor<String>
+visitConcreteConceptClass( ConceptClass  self ) : void
+visitConcretePredicateClass( PredicateClass  self ) : void
+visitConcreteOntologyRootClass( OntologyRootClass  self ) : void
+getResults() : String
OntologyVisitor<V>
+visitConcreteConceptClass( ConceptClass  self ) : void
+visitConcretePredicateClass( PredicateClass  self ) : void
+visitConcreteOntologyRootClass( OntologyRootClass  self ) : void
+getResults() : V
Jade2JessVisitor<String>
+visitConcreteConceptClass( ConceptClass  self ) : void
+visitConcretePredicateClass( PredicateClass  self ) : void
+visitConcreteOntologyRootClass( OntologyRootClass  self ) : void
+getResults() : String
ClassCollectorVisitor<Map<String, Class<Concept>>>
+visitConcreteConceptClass( ConceptClass  self ) : void
+visitConcretePredicateClass( PredicateClass  self ) : void
+visitConcreteOntologyRootClass( OntologyRootClass  self ) : void
+getResults() : Map<String, Class<Concept>>
Figure 10.14: Ontology Composite Visitor Class Diagram

10.6.
Ontology Management
115
aSubject : OntologyTreeManager
visitor : ClassCollectorVisitor
conceptRoot : ConceptClass
 : OntologyClassManager
 : ConceptClass
 : ConceptClass
treeChanged
1: 
getName
5: 
getJavaClass
6: 
getChildren
7: 
accept(this)
8: 
getName
10: 
getJavaClass
11: 
getChildren
12: 
accept(this)
13: 
getName
15: 
getJavaClass
16: 
getChildren
17: 
visitConcreteConceptClass(this)
4: 
getConceptRoot
2: 
accept(visitor)
3: 
getResults
18: 
visitConcreteConceptClass(this)
9: 
visitConcreteConceptClass(this)
14: 
Figure 10.15: A Visitor visiting a ConceptElement subtree
An Observer of the ontology composite does not access the ontology Composite itself,
instead, it uses a Visitor which "knows" how the tree is traversed to collect the informa-
tion the Observer needs. An example in Figure 10.15 is given with a OntologyClassManager
Observer that uses its ClassCollector Visitor to traverse the ontology composite containing
a parent node with two child nodes. The Visitor and the nodes collaborate to traverse the
composite. The manager accesses the ontology composite when the Ontology Tree Man-
ager calls its treeChanged method. A OntologyClassManager is only interested in Concepts,
hence it calls getConceptRoot of the OntologyTreeManager. When the Visitor has ﬁnished,
the Ontology Class Manager accesses the Visitor’s results by calling getResults.
The Class Diagram depicted in Figure 10.14 shows the OntologyVisitor and the concrete
Visitor implementations that were developed for this thesis. The LispingTreeVistor class is
part of the Jess Remote Administration and discussed in Section 9.4.2. The remaining
Visitors are described in the rest of this Section.
• OntologyVisitor OntologyVisitor is a generic interface. It deﬁnes an operation sig-
nature for each class in the Composite structure introduced in Section 10.6 and
getResults that returns a result of the type of the parameter the subclass speciﬁes.
• Jade2JessVisitor The Jade2JessVisitor maps the ontology to a Jess template hierar-
chy for Jess and JADE to be able to interoperate seamlessly. An example template
for the FindMe agent action is shown in Code extract 10.7.
1 ( deftemplate FindMe extends AgentAction
( declare
( from−class ontology . matrix . FindMe ) ) ) ;
Code extract 10.7: Jess template for FindMe

10.6.
Ontology Management
116
This entry only speciﬁes the header of the template. Jess is be able to automatically
determine the slots of the template based on the setters and getters methods of the
class speciﬁed with the from-class declaration.
• ClassCollectorVisitor A ClassCollectorVisitor traverses the Concept subtree and col-
lects the name and the class object of each node.
10.6.3 Ontology Dependant Managers
As shown in Figure 10.4, a set of managers depend on the ontology to perform their work.
These managers and their superclass and interface are discussed in this Section.
• OntologyTreeObserver The OntologyTreeObserver interface is the type of Observer
known to a TreeSubject. It deﬁnes one abstract method for its subclasses to imple-
ment:
– treeChanged This method is called by a TreeSubject object when its ontology
is changed.
• TreeUser The TreeUser abstract generic class has two instance ﬁelds:
– visitor This instance ﬁeld is of the generic type OntologyVisitor<V>. It is set
during constrution time by passing a concrete OntologyVisitor as constructor
argument.
– treebeard This instance ﬁeld holds a reference to the OntologyTreeManager
object that is the Subject of the Observer.
It implements the following method that are to be used by its subclasses:
– getOntologyTreeManager This method returns the OntologyTreeManager of
the Observer object.
– getVisitor This method returns the concrete OntologyVisitor of the Observer
object.
– TreeUser In addition to setting the values of the instance ﬁelds, the construc-
tor registers the Observer with the OntologyTreeManager.
• Jade2JessOntologyManager The Jade2JessOntologyManager assures interoperabil-
ity between JADE and Jess by mapping the ontology used by JADE to Jess tem-
plates. This permits for both applications to seamlessly exchange information ob-
jects. The JADE to Jess Ontology Manager uses a Jade2JessVisitor that traverses the
tree and returns a string with the template headers. Changes to the template struc-
ture of Jess may have fundamental consequences for the working memory of Jess.
The Jade2JessOntologyManager therefore restarts Jess when the ontology it changed.
However the ﬁrst time this manager runs, this case has to be handled specially. As
shown in Code extract 10.6 in Section 10.5.1, startJess is ﬁrst called when JessCNC
is instantiated. At this stage, the ontology composite has not yet been created by
the Ontology Tree Manager. When the Ontology Tree Manager is called, it will
cause all its Observers to update their representation of the ontology, causing the
Jade2JessVisitor to restart JessCNC and so forth. JessCNC and Jade2JessVisitor thus
need a boolean value to coordinate the initialization. The treeChanged method of
the Jade2JessVisitor class is shown in Code extract 10.8.

10.7.
Jess Functions for JADE and Function Management
117
1
public void treeChanged ( )
{
i f
( ! this . f i r s t T i m e )
3
this . jesscnc . stopJess ( ) ;
this . getOntologyTreeManager ( ) . getRoot ( ) . accept ( this . g e t V i s i t o r ( ) ) ;
5
this . loadJadeOntologyIntoJess ( ) ;
i f
( ! this . f i r s t T i m e )
7
this . jesscnc . startJess ( ) ;
}
Code extract 10.8: treeChanged instance method of the Jade2JessVisitor class
• OntologyClassManager The OntologyClassManager provides the Jess Function Man-
ager with access to class objects of the classes in the ontology. Further, it maps
agent actions to behaviors, based on the rules discussed in Section 10.3.1. This class
contains the following instance ﬁelds:
– ontologyConceptClassManager This ﬁeld is a HashMap that contains the
class objects of the Concept classes in the ontology. This hash is created by
the manager’s Visitor. Single elements of this hash are accessed by passing
the key of an element as argument to the instance method getOntologyCon-
cept. A list of all keys of this hash is fetched by calling the instance method
getOntologyConceptNames.
– abmap The abmap ﬁeld is a HashMap that contains tuples of (agent action,
behavior). A key of such a tuple is the class name of the agent action. A
(agent action, behavior) tuple is fetched through the instance method getAc-
tionInitiatorBehaviourTuple. Currently the values of this hash are hard coded in
the constructor, to serve as a proof of concept.
10.7 Jess Functions for JADE and Function
Management
private void
addInitialFunctionsToJess ( )
{
2
this . jfm . registerJadeJessFunction (new CommandAgent( this . masterAgent ,
this . jfm ,
this .
classReg ) ) ;
this . jfm . registerJadeJessFunction (new ReturnFactToCurrentBehaviour ( this . masterAgent ,
this .
jfm , this . classReg ) ) ;
4
}
Code extract 10.9: Registering JADE aware Jess functions
A set of Jess functions to access JADE seamlessly from within Jess were developed for this
thesis. They are managed by an instance of the JessFunctionManager class. Jess functions
are registered with the Jess Function Manager when the JessCNC object of the master
agent is instantiated, as shown in Code extract 10.9. These functions are coupled with
Jessable behaviors, discussed in Section 10.7.1. The Jess Function Manager maintains
a pointer to every Jess function. Additionally, it registers each Jess function with the
Jess Engine Manager that registers the functions with Jess. The Class Diagram for the
Jess functions and the Jess Function Manager is shown in Figure 10.16. This Section

10.7.
Jess Functions for JADE and Function Management
118
JessFunctionsManager
~JessFunctionsManager( JessCNC jesscnc )
+setCommunicationConfigFactory( CommunicationConfiguratiionFactory communicationConfigFactory ) : void
+addJessableBehaviour( Integer behaviourHash, JessableBehaviour jb ) : void
+registerJadeJessFunction( JadeJessFunction jjf ) : void
+removeJessableBehaviour( Integer behaviourHash ) : void
+setCurrentBehaviour( Integer current ) : void
+removeAsCurrentBehaviour() : void
JadeJessFunction
+JadeJessFunction( Agent myAgent, JessFunctionsManager jfr, OntologyClassManager ocr )
+setCommunicationConfigFactory( CommunicationConfiguratiionFactory commConfigFactory ) : void
#getCommunicationConfigFactory() : CommunicationConfiguratiionFactory
#getOntologyClassRegistry() : OntologyClassManager
#getAgent() : Agent
#getJessFunctionManager() : JessFunctionsManager
#jessFactToJadeOntologyInstance( Fact fact, Context context ) : Concept
ReturnFactToCurrentBehavior
+getName() : String
+call( ValueVector vv, Context context ) : Value
CommandAgent
+getName() : String
+call( ValueVector vv, Context context ) : Value
Userfunction
+getName() : String
+call( ValueVector vv, Context context ) : Value
Figure 10.16: JADE aware Jess function and Jess Function Manager
discusses the Jess functions developed for this thesis and the Jess Function Manager.
The integration with Jessable behaviors is discussed in Section 10.7.1.
JessFunctionsManager
This class provides the means of communication between Jess
functions that communicate with JADE and Jessable behaviors. Functions and behaviors
that require to interact register with the JessFunctionsManager. The JessFunctionsManager
class deﬁnes the following instance ﬁelds:
• jessableBehaviours This ﬁeld is a HashMap that contains the Jessable behaviors
that are known to the JessFunctionsManager. The key of a Jessable behavior is an
integer generated with the behavior’s hashCode instance method which provides a
unique value for an object [Fla05, p. 133]. This value is used by a behavior to
identify itself with the JessFunctionsManager.
A behavior registers itself by call-
ing addJessableBehaviour It is removed with removeJessableBehaviour and the hash of
the behavior as argument. The current behavior is accessed by calling getCurrent-
Behaviour. If no behavior is registered a NoCurrentBehaviourRegistered exception is
raised.
• currentBehaviour This integer holds the identiﬁcation number of the Jessable
behavior that is currently running. If no behavior is running, the value is −1. A
behavior sets itself as current behavior by calling setCurrentBehaviour and removes
itself as current behavior by calling removeAsCurrentBehaviour.

10.7.
Jess Functions for JADE and Function Management
119
• jessFunctions This ﬁeld is a Vector<JadeJessFunction> that contains functions that
communicate with JADE. They are of the type JadeJessFunction.
A function is
added by calling registerJadeJessFunction.
• jesscnc This ﬁeld contains a reference to the master agent’s JessCNC object. Its
value is set when the manager is instantiated.
A JADE aware Jess function can require to send messages to agents in the master’s
environment. To create a message for the proper FIPA protocol, it needs access to the
instance of a CommunicationConﬁgFactory. Owing to the fact that it cannot be known at
compile time on which FIPA protocol the conversation will be based, the FIPA protocol
has to be speciﬁed at run time. The approach chosen for this implementation is to let
the current behavior set the concrete CommunicationConﬁgFactory. This approach has the
advantage that Jess does not have to be aware of communication related issues. The
disadvantage is however that only one FIPA protocol is supported per Jessable behavior.
To set the CommunicationConﬁgFactory a behavior calls the following method:
• setCommunicationConﬁgFactory This method sets the setCommunicationConﬁg-
Factory for each Jess function object known to the Jess Function Manager.
JadeJessFunction
JadeJessFunction is an abstract class from which all JADE aware
functions inherit. It implements the jess.Userfunction interface to be recognized by Jess as
a Jess user function. It contains instance ﬁelds and methods required by its subclasses to
communicate with the current behavior and other agents. It deﬁnes the following instance
ﬁelds:
• myAgent This instance ﬁeld contains a reference to the master agent on which
Jess runs. It can be accessed by a subclass through the protected method getAgent.
• jessFunctionManager This instance ﬁelds contains reference to a JessFunctionMan-
ager with which the Jess function is registered. Subclasses can access it by calling
the protected method getJessFunctionManager.
• ocr This instance ﬁeld holds a reference to the JessCNC’s OntologyClassManager in-
stance. Subclasses access it by calling the protected method getOntologyClassManager.
• commConﬁgFactory This instance ﬁeld holds a reference to the concrete Ontolo-
gyClassManager class set by the Jessable behavior during run-time. Subclasses access
this ﬁeld through the protected method getCommunicationConﬁgFactory.
A goal of the integration approach chosen for this thesis is to keep Jess "unaware" of
interactions with the "outside world", i.e. Java classes that depend on it. Thus, when a
fact is asserted that is to be used outside Jess, it should not be asserted any diﬀerently
from facts that are only used internally by Jess. However natively only shadow facts
are connected to POJOs. Thus, if a fact is asserted that is meant to be used by the
surrounding Java application, a shadow fact has to be created by calling deﬁnstance (or
ﬁrst instantiated as a normal Java object and then added to the working memory by
calling add). To avoid this, the JadeJessFunction class contains a protected instance method
that converts a Jess fact into a POJO of the same type. This is possible because Jess and
JADE both use the same ontology. The convention is handled by the following method:
jessFactToJadeOntologyInstance jessFactToJadeOntologyInstance takes a Fact and Context
instance as argument and returns a Concept of the same type as the fact with the

10.7.
Jess Functions for JADE and Function Management
120
public Value
c a l l ( ValueVector vv ,
Context
context ) throws JessException
{
2
i f
( vv . size ( )
!=
3)
throw new JessException ( this . getName ( ) ,
4
"Wrong number of arguments " , vv . size ( ) −1) ;
AgentAction
action = ( AgentAction )
this . jessFactToJadeOntologyInstance ( vv . get (1) . factValue
( context ) ,
context ) ;
6
String
reciever = vv . get (2) . stringValue ( context ) ;
Tuple <Class <AgentAction > , Class <Behaviour >> abt = this . getOntologyClassManager ( ) .
getActionInitiatorBehaviourTuble ( action . getClass ( ) . getName ( ) ) ;
8
try
{
AID rec = new AID ( reciever , AID . ISGUID ) ;
10
ACLMessage msg = this . getCommunicationConfigFactory ( ) . createFIPARequestMessage ( rec ,
action ) ;
Constructor <Behaviour > c = abt . getSecondElement ( ) . getDeclaredConstructor ( Agent . class ,
ACLMessage . class ) ;
12
c . setAccessible ( true ) ;
Behaviour b = c . newInstance ( this . getAgent ( ) , msg) ;
14
this . getAgent ( ) . addBehaviour ( b ) ;
} catch ( InstantiationException e )
{
16
/ / Exception
handling ,
code omitted
}
18
return
Funcall .TRUE;
}
Code extract 10.10: Algorithm for the command-agent Jess user function
fact’s content. The reader shall note that this method will not work for facts that
are of the type Predicate.
CommandAgent
An instance of this class is used to send an agent action to an agent.
It takes as argument the agent action and the String value of the AID of the receiver; e.g.
(command-agent ?a ?r) where ?a is a variable containing an AgentAction and ?r a variable
containing the String value of the AID of the receiver. The implementation of the command-
agent function is shown in Code extract 10.10. This function takes precisely two arguments
(the ﬁrst value of the vector is the function itself), otherwise a JessException is thrown
(lines 2–4). Next, the fact is converted to an AgentAction of the ontology used by the agents
in the multi-agent system. This is achieved by calling jessFactToJadeOntologyInstance and
passing the fact (ﬁrst argument) and context as an argument (line 5). At line 9, the
receiver is extracted and at line 10 the Ontology Class Manager is called to get the
behavior that matches the given agent action. As stated in Section 10.3.1, every agent
action corresponds to a conversation, thus it is not necessary to specify which behavior
is used when calling command-agent. In lines 9–14, an AID object containing the address
of the receiver is created. It is passed with the agent action as a constructor argument
to the ACLMessage created by calling the Communication Conﬁguration Factory set by
the behavior that is currently running. Using the Java reﬂection API, a new behavior
instance is created from the class object in the tuple that was returned from the Ontology
Class Manager. The current agent and the ACLMessage is passed as constructor argument
of the behavior (lines 11–12). This behavior is added to the agent’s behavior list to be
executed (line 14). This function returns a Funcall.TRUE since there is no other data to
return.
ReturnFactToCurrentBehaviour
This class implements the (return-fact-to-current-behaviour)
Jess function. With this functions, facts (currently only Concepts) can be returned to the
behavior that is running by calling (return-fact-to-current-behaviour ?c), where ?c is a variable

10.7.
Jess Functions for JADE and Function Management
121
1
public Value
c a l l ( ValueVector vv ,
Context
context ) throws JessException
{
try
{
3
Concept concept = this . jessFactToJadeOntologyInstance ( vv . get (1) . factValue ( context ) ,
context ) ;
this . getJessFunctionManager ( ) . getCurrentBehaviour ( ) . addOntologyConcept ( concept ) ;
5
} catch ( NoCurrentBehaviourRegistered e )
{
throw new JessException ( this . getName ( ) ,
"No Jessable Behaviour
registered " , e . getCause ( )
) ;
7
}
return
Funcall .TRUE;
9
}
Code extract 10.11: Algorithm for the return-fact-to-current-behaviour Jess user function
containing a Concept instance that is to be returned to the active Jessable behavior. While
facts can of course always be retrieved by using the query interface of Jess, this function
oﬀers an easy alternative to return facts that are intermediate results without having to
store these facts separately or interrupt Jess to let the current behavior run a query. The
algorithm for this function is shown in Code extract 10.11. First the fact is converted to
its corresponding type in the ontology in line 3 and in line 4 the concept is added to its
behavior. When Jess has ﬁnished executing, the current behavior can fetch the results
by calling its instance method getConcepts.
10.7.1 Jess Integrated Behaviors
JessableBehavior
+registerWithJessFunctionManager() : void
+unregisterWithJessFunctionManager() : void
+setAsCurrent() : void
+removeAsCurrent() : void
+addOntologyConcept( Concept concept ) : void
+setCommunicationConfigurationFactory() : CommunicationConfigurationFactory
RequestResponderTemplate
+RequestResponderTemplate( Agent a, MessageTemplate mt )
#doAtBeginning() : void
#doAtEnd() : void
#prepareResponse( ACLMessage request ) : ACLMessage
#executeAction( Concept agentAction ) : Predicate
#setMessagePerformative( int messagePerformative ) : void
JessableRequestResponderTemplate
+onEnd:int()
+getConcepts() : Vector<Concept>
+registerWithJessFunctionManager() : void
+removeAsCurrent() : void
+setAsCurrent() : void
+unregisterWithJessFunctionManager() : void
+addOntologyConcept( Concept concept )
#doAtBeginning() : void
#doAtEnd() : void
Figure 10.17: Jessable behavior class hierarchy used for the Matrix
A Jess integrated behavior, known a Jessable Behavior in this thesis, is a behavior that
is tightly coupled with the Jess Function Manager. The behavior is not solely a service
user of JessCNC and its managers. Some objects are aware of the Jessable behavior that
is running. A Jessable behavior extends the JessableBehaviour interface. For this thesis,
the abstract Jessable behavior JessableRequestResponderTemplate for the participant in a
FIPA-Request-Protocol was developed. It inherits from the RequestResponderTemplate class.
The Class Diagram is shown in Figure 10.17. Each participant shown on Figure 10.17

10.7.
Jess Functions for JADE and Function Management
122
is described, followed by an detailed description of the interaction between a Jessable
behavior and JADE aware functions.
Jessable Classes
• JessableBehaviour The JessableBehaviour interface speciﬁes the following method
signatures that its subclasses have to implement:
– registerWithJessFunctionManager This method is to register the behav-
ior with the JessFunctionManager object of the master agent.
– unregisterWithJessFunctionManager This method is to remove the be-
havior from the list of known Jessable behaviors of the JessFunctionManager
object.
– setAsCurrent This method is to notify the Jess Function Manager of the
current behavior.
– removeAsCurrent This method is to notify the Jess Function Manager.
– addOntologyConcept This method is to add a Concept object to the behav-
ior.
– setCommunicationConﬁgFactory This method is to return the concrete
CommunicationConﬁgFactory.
• JessableRequestResponderTemplate This class extends the RequestResponderTem-
plate (see Section 10.3.1) and adds the additional functionalities required by a Jess-
able behavior. The source code is shown in Code extract 10.12. JessableRequestRe-
sponderTemplate has three instance ﬁelds:
– jessCNC This instance ﬁeld holds a reference to the JessCNC object of the
master agent. It is assigned during construction (line 14).
– concepts This HashMap contains concepts added by a JADE aware Jess func-
tion. When a concept is added, the class name for the concept is accessed and
set as key for that entry.
– toClear This instance ﬁeld is set to true when the current behavior accesses
the concepts that were added (line 8–9) causing the Vector to be emptied before
new Concepts are added again (line 48–50).
This class implements the hook operations doAtBeginning, doAtEnd and onEnd and the
primitive operation registerWithJessFunctionManager:
– doAtBeginning This method is called every time the behavior runs. It calls
its method setAsCurrent which notiﬁes the Jess Function Manager that it is the
current behavior (line 34). It then informs the Jess Function Manager of the
current Communication Conﬁguration Factory (line 19).
– doAtEnd This method is called when the behavior ﬁnished handling the re-
quest. It informs the Jess Function Manager that is no longer the current
behavior. The Communication Conﬁguration Factory is not removed, it will
simply be updated by the next Jessable behavior.
– onEnd This is a hook operation of the Behavior class. It is for subclasses to
add termination code for the behavior. This implementation calls the super
class implementation of the same method and deregisters itself with the Jess
Function Manager (lines 42–44).

10.7.
Jess Functions for JADE and Function Management
123
– registerWithJessFunctionManager This method registers the behavior
with the Jess Function Manager. The bahavior passes its hash code and its ref-
erence as argument to Jess Function Manager’s addJessableBehaviour instance
method (line 26). registerWithJessFunctionManager is called when the behavior is
instantiated (line 15).
1 public
abstract
class JessableRequestResponderTemplate extends
RequestResponderTemplate implements JessableBehaviour
{
3
protected JessCNC jessCNC = null ;
private
Vector <Concept> concepts = new Vector <Concept >() ;
5
private
boolean toClear = false ;
7
protected Vector <Concept> getConcepts
( )
{
this . toClear = true ;
9
return
this . concepts ;
}
11
public JessableRequestResponderTemplate ( Agent a ,
MessageTemplate mt )
{
13
super (a , mt ) ;
this . jessCNC
= ( ( JessableAgent ) this . myAgent ) . getJessCNC ( ) ;
15
this . registerWithJessFunctionManager ( ) ;
}
17
protected void doAtBeginning ( )
{
19
this . setAsCurrent ( ) ;
this . jessCNC . getJessFunctionManager ( ) . setCommunicationConfigFactory ( this .
setCommunicationConfigFactory ( ) ) ;
21
}
23
protected void doAtEnd ( )
{
this . removeAsCurrent ( ) ;
}
25
public void registerWithJessFunctionManager ( )
{
this . jessCNC . getJessFunctionManager ( ) . addJessableBehaviour ( this . hashCode ( ) ,
this ) ;
27
}
29
public void removeAsCurrent ( )
{
this . jessCNC . getJessFunctionManager ( ) . removeAsCurrentBehaviour ( ) ;
31
}
33
public void setAsCurrent ( )
{
this . jessCNC . getJessFunctionManager ( ) . setCurrentBehaviour ( this . hashCode ( ) ) ;
35
}
37
public void unregisterWithJessFunctionManager ( )
{
this . jessCNC . getJessFunctionManager ( ) . removeJessableBehaviour ( this . hashCode ( ) ) ;
39
}
41
public
int onEnd ( )
{
int tmp = super . onEnd ( ) ;
43
this . unregisterWithJessFunctionManager ( ) ;
return tmp ;
45
}
47
public void addOntologyConcept ( Concept concept )
{
i f
( this . toClear )
{
49
this . concepts . clear ( ) ;
this . toClear = false ;
51
}
this . concepts . add ( concept ) ;
53
}
}
Code extract 10.12: FIPA-Request abstract Responder behavior with Jess support

10.7.
Jess Functions for JADE and Function Management
124
aCF : CommunicationConfigFactory
 : ReturnFactToCurrentBehaviour
jfm : JessFunctionManager
b : aJessableBehavior
master : OracleAgent
JessCNC : JessCNC
 : CommandAgent
The two 
intermediate 
sequence 
diagrams occur 
here
setCommunicationConfigFactory
10: 
setCommunicationConfigFactory(aCF)
11: 
prepareResponse
2: 
doAtBeginning
3: 
executeAction
12: 
doAtEnd
13: 
setAsCurrent
4: 
getJessFunctionRegistry
7: 
setCommunicationConfigFactory
8: 
setCommunicationConfigFactory(aCF)
9: 
getJessFunctionRegistry
5: 
addJessableBehaviour(a hash)
6: 
removeAsCurrent
14: 
getJessFunctionRegistry
15: 
removeAsCurrentBehaviour
16: 
action
1: 
Figure 10.18: Beginning and end of prepareResponse
Interaction Between a Jessable Behavior and JADE Aware Functions
An example was created to illustrate the interaction between a Jessable behavior and
JADE aware Jess functions.
Due to its size, it is divided in the Sequence Diagrams
of Figure 10.18, Figure 10.19 and Figure 10.19. Figure 10.18 shows the beginning and
the end of the example. The example demonstrates the following: A concrete Jessable
behavior extends the JessableRequestResponderTemplate class. It ﬁrst runs Jess which at
some point ﬁres a rule that calls the return-fact-to-current-behaviour function and another
rule that calls command-agent. It is assumed that the system is set up, thus all objects
that require registration have already done so.

10.8.
A Brief Discussion of an Oracle Agent Without Rule Engine
125
b : ARequestInitiatorbehavior
 : OntologyClassManager
master : OracleAgent
JessCNC : JessCNC
JessEngineManager
aJessableBehavior
 : CommandAgent
a : AgentAction
jess : Rete
1: 
run
4: 
getJessEngineManager
2: 
runJess
3: 
getActionInitiatorBehaviourTuble
9: 
newInstance (master,a)
10: 
7: 
addBehaviour(b)
12: 
jessFactToJadeOntologyInstance
6: 
getOntologyClassRegistry
8: 
getAgent
11: 
call(fact, context)
5: 
Figure 10.19: Object interaction for command-agent
 : ReturnFactToCurrentBehaviour
jfm : JessFunctionManager
JessCNC : JessCNC
JessEngineManager
aJessableBehavior
c : Concept
jess : Rete
jessFactToJadeOntologyInstance
6: 
getJessFunctionRegistry
8: 
getCurrentBehaviour
9: 
7: 
addOntologyConcept(c)
10: 
run
4: 
executeAction
1: 
getJessEngineManager
2: 
runJess
3: 
call(fact, context)
5: 
Figure 10.20: Object interaction for return-fact-to-current-behaviour
10.8 A Brief Discussion of an Oracle Agent Without
Rule Engine
To verify the assumption that using a rule-engine instead of hard coding the business logic
in Java, a Oracle agent without Jess was developed, however only with the basic func-
tionalities. The Oracle agent that does not use Jess has the same ontology, protocol and

10.8.
A Brief Discussion of an Oracle Agent Without Rule Engine
126
content language as the Oracle agent that uses Jess, hence the interface remains the same,
the slave agents do not have to be modiﬁed. The implementation of the handleRequest
of the CommandMeResponder behavior class is shown in Code extract 10.13. The reader
shall note that this is based on a older version of this project but the quintessence remain
the same. The implementation for this rather short example seems to be simpler to be
implemented in Java than in Jess. This however quickly changes when one considers the
possible eﬀects of adding new logic to the agent. Jess handles the order in which rules
execute, with Java, the programmer will have to pay close attention where the next if
or while statement will be added. The author believes that Jess is a far more superior
tool to manage large amount of rules without loosing complete oversight. Additionally,
the Java code will have to contain logic to address the working memory management,
possibility by using a database. Thus the logic will be mixed with data handling code
that adds nothing to the business logic. This also applies for example if one wishes to
add logging functionality. Jess has an elegant event handling interface for object that
could for example log the activities of Jess. And, as shown with the Jess Administration
agent (Chapter 9), Jess rules can be added and removed on th ﬂy. A Java implementation
would require to stop the agent, update the class and start the agent again.
public class CommandMeResponder extends AchieveREResponder {
2
protected ACLMessage handleRequest (ACLMessage request )
throws NotUnderstoodException ,
RefuseException
{
4
ACLMessage reply = null ;
this . oa = ( agents . OracleAgent )
this . myAgent ;
6
try
{
reply = request . createReply ( ) ;
8
Action a = ( Action ) oa . getContentManager ( ) . extractContent ( request ) ;
CommandMe commandRequest = (CommandMe) a . getAction ( ) ;
10
MatrixCombatAction mca = null ;
i f
( ! this . isLockedFor ( commandRequest . getSecret ( ) ) )
{
12
throw new Unauthorised ( ) ;
}
14
ontology . matrix . CombatAgent slave = ( CombatAgent )
this . oa . getAgent ( commandRequest .
getSlave ( ) ) ;
double requesterHealth = slave . getHealthstate ( ) ;
16
String
secret = null ;
i f
( requesterHealth > 0)
{
18
double health = 0;
ontology . matrix . CombatAgent victi m = this . getNextTarget ( ( CombatAgent )
this . oa . getAgent
( slave . getAgentName ( ) ) ) ;
20
i f
( victim == null )
throw new Unauthorised ( ) ;
22
Attack
attack = new Attack ( ) ;
health = health −( slave . getPower ( ) + Math . random ( )
∗5.0) ;
24
vi ctim . setHealthstate ( ( float )
health ) ;
attack . setAttacker ( slave . getAgentName ( ) ) ;
26
attack . setVictim ( victim . getAgentName ( ) ) ;
mca = attack ;
28
secret = this . createSecret ( ) ;
}
else
i f
( requesterHealth <= 0)
{
30
Die die = new Die ( ) ;
die . setVictim ( slave . getAgentName ( ) ) ;
32
die . setAttacker ( request . getSender ( ) . getName ( ) ) ;
this . oa . unregisterAgent ( slave . getAgentName ( ) ) ;
34
mca = die ;
secret = " " ;
/ / reset
lock ,
the agent
i s
going
to
die ,
there
i s no more communication
between agents
36
}
this . setLockFor ( secret ) ;
38
mca. setSecret ( secret ) ;
CommunicationConfig
cf
40
= MatrixCommunication . getInstance ( ) ;
ACLMessage orderMsg = cf . createFIPARequestMessage ( this . myAgent ,
request . getSender ( ) ,mca)
;
42
this . r e gi s t e r P r ep a r e R e su l t N o t if i c a t i o n (new CommandSlaveAgent ( oa ,
orderMsg ,
this . getDataStore ( ) ) ) ;

10.8.
A Brief Discussion of an Oracle Agent Without Rule Engine
127
44
ContentElementList
cel = new ContentElementList ( ) ;
cel . add ( a ) ;
46
reply . setPerformative (ACLMessage .AGREE) ;
oa . getContentManager ( ) . f i l l C o n t e n t ( reply ,
cel ) ;
48
} catch ( UngroundedException e )
{
e . printStackTrace ( ) ;
50
} catch ( CodecException e )
{
e . printStackTrace ( ) ;
52
} catch ( OntologyException e )
{
e . printStackTrace ( ) ;
54
}
return
reply ;
56
}
Code extract 10.13: ChangeMeResponder without Jess rule-engine

11
Using the J2J Tool Kit to Add Jess
to MediMAS
11.1 Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
11.2 Creating a Jess Administration Agent
. . . . . . . . . . . . . 129
11.3 Modifying the MediMAS Ontology
. . . . . . . . . . . . . . . 130
11.3.1 Create a Communication Conﬁguration Factory for the Medi-
MAS ontology
. . . . . . . . . . . . . . . . . . . . . . . . . . .
131
11.4 Adding Jess Support to MediMAS
. . . . . . . . . . . . . . . 131
11.4.1 Extending JessCNC
. . . . . . . . . . . . . . . . . . . . . . . .
131
11.4.2 Making the MediMAS Alert Manager Agent Jessable
. . . . .
131
11.4.3 Creating a Jessable Behavior to Handle the Alert Notiﬁcation
132
11.4.4 Implementing the Alert Notiﬁcation Logic with Jess Rules
. .
135
11.4.5 Adding a JADE Aware Jess User Function
. . . . . . . . . . .
136
11.5 Changing the Behavior at Run Time
. . . . . . . . . . . . . . 137
11.5.1 Sending Alerts To the Head of Laboratory . . . . . . . . . . . .
137
11.5.2 Reacting to Laboratory Results with H5N1
. . . . . . . . . . .
137
11.6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
11.1 Introduction
In the introduction of this thesis it was stated that this thesis was initiated to make Med-
iMAS more adaptive to changing requirements of the healthcare workﬂows it supports.
It was argued that using a rule-based system to handle the business logic was a suitable
solution. Processes can be described in declarative way instead of writing procedures.
Furthermore, if the rule-based system engine is an interpreter, rules can be changed on
the ﬂy. In the current Part, a tool kit has been developed that integrates Jess and JADE.
This tool kit, called the J2J tool kit, is now applied to MediMAS: MediMAS contains
a set of alerts. Alerts are classiﬁed, among other criteria, according to their criticality
and their degree of urgency. Alerts that are critical or urgent (or both) are monitored by
128

11.2.
Creating a Jess Administration Agent
129
MediMAS and, if they are not handled by their dedicated receiver within a given time
period, sent again or escalated. This is depicted in the Event-driven Process Chains of
Figure 3.3, Figure 3.4, Figure 3.5 and Figure 3.6 in Chapter 3. This logic is currently
written in Java in the AgentHandleAlertActionsBehaviour class. The algorithm that conducts
these veriﬁcations is shown in Code extract 11.1.
protected void handleAlert ( Concept concept
)
{
2
AlertAction
a l e r t = ( AlertAction ) concept ;
long
l a s t a l e r t t i m e
= a l e r t . getLastAlertTime ( ) . getTime ( ) ;
4
long currenttime
= new Date ( ) . getTime ( ) ;
6
int
i n t v a l = 1000 ∗HospitalConstants .NORMAL_PENDINGTIME ;
i f
(
a l e r t . g e t C r i t i c a l ( ) == true
)
8
i n t v a l =
1000 ∗HospitalConstants . CRITICAL_PENDINGTIME ;
else
i f
(
a l e r t . getUrgent ( ) == true
)
10
i n t v a l =
1000 ∗HospitalConstants .URGENT_PENDINGTIME ;
i f
(
( currenttime −l a s t a l e r t t i m e ) >= i n t v a l
)
{
12
/ /
Update
a l e r t
infos
in
the database
this . updateAlert (
a l e r t
) ;
14
/ /
Send a l e r t
to
requester
/
( and )
l a b d i r e c t o r
this . sendAlert
(
a l e r t
) ;
16
}
}
Code extract 11.1: The handleAlert method of the AgentHandleAlertActionsBehaviour class
Modifying the logic of this behavior in run-time is currently not possible. It was therefore
decided to use Jess to handle the decision making for the alert management. In addition,
a new JADE aware Jess user function was added. This new Jess user function permits
to modify the time intervals in which the behavior that processes the alert action, runs.
This Chapter explains how the J2J tool kit is added to MediMAS. It is structured as
follows: Section 11.2 discusses the implementation of the remote Jess Administration
agent developed for MediMAS. In Section 11.3, the slight changes that were made to the
MediMAS ontology, are commented. Section 11.4 explains the approach chosen to apply
the J2J tool kit to MediMAS followed by an example in Section 11.5 of how the alert
notiﬁcation of the Alert Manager agent can be changed during run time with Jess. In
Appendix C, the libraries that have to be known to the MediMAS project, are listed.
11.2 Creating a Jess Administration Agent
JessMedicalAdmin
+registerWithMasterAgentAndLoadBehaviors()
AbstractJessAdminAgent
+getJessAdminGui() : JessAdminGui
#onGuiEvent( GuiEvent ev ) : void
+getMaster() : AID
+setMaster( oa ) : void
+registerWithMasterAgentAndLoadBehaviors()
+loadDefaultBehaviors()
Figure 11.1: The JessMedicalAdmin class
To write a concrete Jess Administration agent, the AbstractJessAdminAgent abstract class
has to be extended and its abstract instance method registerWithMasterAgentAndLoadBehav-

11.3.
Modifying the MediMAS Ontology
130
iors implemented. The remote Jess Administration agent class for MediMAS is JessMed-
icalAdmin, as depicted in Figure 11.1. The implementation of the registerWithMasterAgen-
tAndLoadBehaviors instance method must ﬁrst lookup the master agent that is to be ad-
ministered remotely and then, as shown in Code extract 11.2 call the methods setMaster
and loadDefaultBehaviors. In this example, the AID of the master agent that was queried,
is stored in the variable rba.
1 this . setMaster ( rba ) ;
this . loadDefaultBehaviors ( ) ;
Code extract 11.2: The instructions to set the address of the master and load the
behaviors needed to communicate with the master agent
11.3 Modifying the MediMAS Ontology
Figure 11.2: Extract of the MediMAS ontology
The MediMAS ontology had to be slightly modiﬁed for this Chapter. The aﬀected classes
of the MediMAS ontology, AlertAction and Time, are shown in Figure 11.2.
Time, with
the slot time, was added to represent a time in Jess.
This is required to determine
whether or not an AlertAction is due. Additionally, a String slot icd10 (more on International
Classiﬁcation of Diseases 10 (ICD-10) in [21]) was added to the AlertAction class. This
change was not mandatory and is currently not supported by MediMAS. It is however
useful to demonstrate how MediMAS could also react to certain diseases in a speciﬁc way.

11.4.
Adding Jess Support to MediMAS
131
11.3.1 Create a Communication Conﬁguration Factory for the
MediMAS ontology
A Communication Conﬁguration Factory can be added for the MediMAS ontology. Since
MediMAS already creates message in its own way, it is, strictly speaking, only needed for
JessJadeFunctions that want to send messages. Such functions are not used for MediMAS.
Thus, a Communication Conﬁguration Factory was not developed.
11.4 Adding Jess Support to MediMAS
This Section describes in detail how the J2J tool kit was added to MediMAS. Frist the
JessCNC class is extended to add a new JADE aware Jess user function to the Jess engine.
This is explained in Section 11.4.1. In Section 11.4.2, the new Alert Manager agent with
Jess support is discussed and Section 11.4.3 elaborates on the new behavior that uses Jess
to decide how to treat alerts. Section 11.4.4 explains the Jess rules that handle the alert
management logic. Section 11.4.5 presents the JADE aware Jess user function developed
for MediMAS to set the time intervals between the alert notiﬁcation.
11.4.1 Extending JessCNC
Because a new JADE aware Jess user function was required, JessCNC had to be extended
and the instance method addInitialFunctionsToJess overwritten to add the newly developed
JADE aware Jess user function to the Jess engine. The new class is called MediMAS-
JessCNC (see Figure 11.3). Its addInitialFunctionsToJess is shown in Code extract 11.3. It
ﬁrst calls the method addInitialFunctionsToJess of its parent class to add the default JADE
aware Jess user functions (line 2) and then adds the class ChangeAlertCheckTime. This class
implements the Jess user function change-alert-check-time, described in Section 11.4.5.
protected void
addInitialFunctionsToJess ( )
{
2
super . addInitialFunctionsToJess ( ) ;
this . getJessFunctionManager ( ) . registerJadeJessFunction (new ChangeAlertCheckTime ( this .
masterAgent ,
this . getJessFunctionManager ( ) ,
this . getOntologyClassManager ( ) ) ) ;
4
}
Code extract 11.3: Extending JessCNC to add a new JADE aware Jess user function
11.4.2 Making the MediMAS Alert Manager Agent Jessable
Instead of changing the current AlertManagerAgent class, it is extended with the JessableAl-
ertManagerAgent class that implements the JessableAgent interface of the J2J tool kit. The
class hierarchy is depicted in Figure 11.3 (the parent classes of the AlertManagerAgent class
and the interface of the JessCNC class are omitted). The source code is shown in Code
extract 11.4. It contains one instance ﬁeld (line 2):
• jesscnc This instance ﬁeld holds the JessCNC object of the master agent.
This class implements two instance methods:
• getJessCNC This method provides access to the master agent’s JessCNC object.

11.4.
Adding Jess Support to MediMAS
132
AlertManagerAgent
+setAgentHandleAlert() : void
#initMe() : void
+getMyState() : AlertManagerAgentState
#setup() : void
MediMASJessCNC
+addInitialFunctionsToJess() : void
JessableAlertManagerAgent
#setup() : void
+getJessCNC() : JessCNC
JessableAgent
+getJessCNC() : JessCNC
JessCNC
Figure 11.3: The class hierarchy of the JessableAlertManagerAgent class
• setup This method conﬁgures the agent. It frst calls the setup method of its parent
class (line 8) and then instantiates a MediMASJessCNC object (line 9). In line 10,
the conﬁgureMasterForJessRemoteAdministration method of the agent’s JessCNC object
is called. This method conﬁgures the agent for the remote Jess Administration.
public class JessableAlertManagerAgent extends AlertManagerAgent implements JessableAgent
{
2
private JessCNC jesscnc ;
public JessCNC getJessCNC ( )
{
4
return
this . jesscnc ;
}
6
public void setup ( )
{
8
super . setup ( ) ;
this . jesscnc = new MediMASJessCNC( this ) ;
10
this . jesscnc . configureMasterForJessRemoteAdministration ( ) ;
}
12 }
Code extract 11.4: Making the AlertManagerAgent Jessable
Next, the OntologyTreeManager class (discussed in Section 10.6) has to be edited to read
the proper ontology: The static String ﬁeld DOMAIN_ONTOLOGY must contain the relative
path of the directory that stores the classes of the ontology. The static Ontology ﬁeld
ONTOLOGY must contain the reference to the current ontology object. This is shown in
Code extract 11.5.
private
static
String DOMAIN_ONTOLOGY = " h o s p i t a l / ontology " ;
2 private
static
Ontology ONTOLOGY =
HospitalOntology . getInstance ( ) ;
Code extract 11.5: Conﬁguring the OntologyTreeManager class for the MediMAS ontology
The reader shall note that the Ontology Tree Manager only works for ontologies created
with Protégé and if all the class ﬁles are in the same directory. Additionally, only single
inheritance is supported.
11.4.3 Creating a Jessable Behavior to Handle the Alert
Notiﬁcation
The AgentHandleAlertActionsBehaviour class that currently manages the alert notiﬁcation,
is extended and the method that hard codes the alert notiﬁcation logic (shown in Code

11.4.
Adding Jess Support to MediMAS
133
JessableBehavior
+registerWithJessFunctionManager() : void
+unregisterWithJessFunctionManager() : void
+setAsCurrent() : void
+removeAsCurrent() : void
+addOntologyConcept( Concept concept ) : void
+setCommunicationConfigurationFactory() : CommunicationConfigurationFactory
JessAgentHandleAlertActionsBehaviour
+JessAgentHandleAlertActionsBehaviour()
+handleAlert() : void
+registerWithJessFunctionManager() : void
+removeAsCurrent() : void
+setAsCurrent() : void
+unregisterWithJessFunctionManager() : void
+getConcepts() : Vector<Concept>
+setCommunicationConfigFactory() : CommunicationConfigurationFactory
+addOntologyConcept() : void
AgentHandleAlertActionsBehaviour
+onStart() : void
#handleAlert() : void
#updateAlert() : void
#sendAlert() : void
+onEnd() : void
Figure 11.4: The class hierarchy of the AgentHandleAlertActionsBehaviour class
extract 11.1), is overwritten. It was decided to make this behavior Jessable. The class
hierarchy of the JessAgentHandleAlertActionsBehaviour class is shown in Figure 11.4. The
parent classes of the AgentHandleAlertActionsBehaviour class are omitted.
Jess can be used from any sort of behavior, it need not be Jessable. However, a Jessable
behavior can communicate with JadeJessFunctions. This feature is useful for the imple-
mentation of the alert notiﬁcation handling with Jess. When a rule responds to an alert,
it updates certain ﬁelds of the alerts it responded to. Instead of having to run a query
on the working memory to ﬁnd the facts that were changed, a rule can simply call the
JADE aware Jess user function return-fact-to-current-behaviour to return the modiﬁed facts
to the current behavior. In the author’s opinion, this is easier than running a query on
the working memory after Jess has ﬁnished executing.
Implementing the JessAgentHandleAlertActionsBehaviour class
public class JessAgentHandleAlertActionsBehaviour extends
2
AgentHandleAlertActionsBehaviour implements JessableBehaviour
{
private JessCNC jesscnc = ( ( JessableAgent )
this . myAgent ) . getJessCNC ( ) ;
4
private
Vector <Concept> returnedConcepts = new Vector <Concept >() ;
private WorkingMemoryMarker marker ;
6
public JessAgentHandleAlertActionsBehaviour ( Agent agent ,
Vector <?> concepts )
{
8
super ( agent , concepts ) ;
this . registerWithJessFunctionManager ( ) ;
10
this . marker = this . jesscnc . getJessEngineManager ( ) . mark ( ) ;
}
12
protected void handleAlert ( Concept concept
)
{
14
this . setAsCurrent ( ) ;
AlertAction
a l e r t = ( AlertAction ) concept ;
16
Time time = new Time ( ) ;
time . setTime (new Date ( ) ) ;
18
this . jesscnc . getJessEngineManager ( ) . resetToMark ( this . marker ) ;
this . jesscnc . getJessEngineManager ( ) . addFactToJess ( a l e r t ) ;
20
this . jesscnc . getJessEngineManager ( ) . addFactToJess ( time ) ;
this . jesscnc . getJessEngineManager ( ) . setModuleFocus ( "IMPORTANT" ) ;
22
this . jesscnc . getJessEngineManager ( ) . runJess ( ) ;
AlertAction aa = null ;
24
for
( Concept c :
this . returnedConcepts )
{
aa = ( AlertAction ) c ;
26
this . updateAlert ( aa ) ;

11.4.
Adding Jess Support to MediMAS
134
this . sendAlert
( aa ) ;
28
}
this . returnedConcepts . clear ( ) ;
30
this . removeAsCurrent ( ) ;
}
32
public void registerWithJessFunctionManager ( )
{
34
this . jesscnc . getJessFunctionManager ( ) . addJessableBehaviour ( this . hashCode ( ) ,
this ) ;
}
36
public void removeAsCurrent ( )
{
38
this . jesscnc . getJessFunctionManager ( ) . removeAsCurrentBehaviour ( ) ;
}
40
public void setAsCurrent ( )
{
42
this . jesscnc . getJessFunctionManager ( ) . setCurrentBehaviour ( this . hashCode ( ) ) ;
}
44
public void unregisterWithJessFunctionManager ( )
{
46
this . jesscnc . getJessFunctionManager ( ) . removeJessableBehaviour ( this . hashCode ( ) ) ;
}
48
protected Vector <Concept> getConcepts
( )
{ return
null ; }
50
public
CommunicationConfiguratiionFactory
setCommunicationConfigFactory ( )
{
return
null ; }
52
public void addOntologyConcept ( Concept concept )
{
54
this . returnedConcepts . add ( concept ) ;
}
56 }
Code extract 11.6: Making the AlertManagerAgent Jessable
The implementation of the JessAgentHandleAlertActionsBehaviour behavior is shown in Code
extract 11.6. This class adds the following private instance ﬁelds in lines 3–5:
• jesscnc This instance ﬁelds holds the reference to the JessCNC instance of the
master agent for shorter access.
• returnedConcepts This instance ﬁeld will contain the Concept instances returned
by Jess rules that called return-fact-to-current-behaviour.
• marker This instance ﬁeld is of the type WorkingMemoryMarker. It is used to store a
snapshot (a given state at a given time) of the working memory of the Jess engine.
The constructor initializes the object by ﬁrst calling the constructor of its parent class
(line 8). The object then registers itself with the Jess Function Manager by calling its
method registerWithJessFunctionManager (line 9). Next, it records the current state of the
working memory to which the working memory will be resetted every time before Jess is
used (line 10).
The main method of the JessAgentHandleAlertActionsBehaviour class is the following:
• handleAlert This method is called for each AlertAction object. This method ﬁrst
notiﬁes the Jess Function Manager that its object is the current behavior (line 14).
It then casts its argument into an AlertAction and creates a new Time object that is
set to the current time (line 15–17). Next, the working memory is set to a known
state by calling the method resetToMark of the Jess Engine Manager and providing
it with the WorkingMemoryMarker object created when the behavior was instantiated
(line 18). This is necessary for the two reasons:
– The facts are shadow facts. Calling reset will reinitialize each shadow fact but
will not remove them from the working memory [Hil03, 94].

11.4.
Adding Jess Support to MediMAS
135
– Keeping AlertAction facts in the working memory until they expire is problem-
atic. AlertActions that have not been treaten by their dedicated recipient are
loaded by the MediMAS framework from the database and added again to
Jess. If a given alert is already in the working memory of Jess, it will be added
again to the working memory. This is because the same alert is added as a
new AlertAction object.
In lines 19–20, the AlertAction and the fact that represents the current system time
(an instance of the class Time) are added to the working memory. The Jess module
IMPORTANT that contain rules which should be able to run ﬁrst, is set in line 21.
In line 22, Jess is executed. When the Jess rule-engine has completed reasoning,
the facts (in this case it is only going to be at most one, the AgentAction fact the
behavior was launched for) that were added by calling return-fact-to-current-behaviour
are passed as argument to the functions updateAlert and sendAlert (lines 23–28). The
Vector object that contained the returned facts is cleared (line 29) and the behavior
deregisters itself by calling removeAsCurrent (line 30).
Java does not support multiple inheritance of classes. Thus, the methods not commented
in this Section are implemented in a default way.
The JessAgentHandleAlertActionsBehaviour object has to be instantiated by the Alert Man-
ager agent’s AgentHandlePendingResultBehaviour behavior instead of the AgentHandleAlertAc-
tionsBehaviour. This is the only class of the MediMAS framework that needed to be altered.
11.4.4 Implementing the Alert Notiﬁcation Logic with Jess Rules
Default rules are stored in expertSystem/rulefiles/ipd.clp (relative path). The two
default rules for MediMAS are critical-alert and urgent-alert. They replace the Java algorithm
of Code extract 11.1. They are both in the default module MAIN. In addition, a module
IMPORTANT was deﬁned to contain prioritized rules. It is currently empty. Each element
is described in the following Sections.
Rule for Critical Alert Actions
This rule ﬁres if a critical alert (the slot critical is true) that has not been treated by
the recipient within the last 10 minutes, is in the working memory. In the right hand
side (RHS) of the rule, the number of times this alert was raised in vain is increased (the
slot nbOfAlerts) and the slot lastAlert time that contains the last time this alert was raised,
is set the current time. The fact is returned to the current behavior with return-fact-to-
current-behavior and removed from the working memory.
( defrule MAIN : : c r i t i c a l −a l e r t
2
( Time ( time ?now) )
?a <−( AlertAction
4
( c r i t i c a l TRUE)
( nlab ?nlab )
6
( senderPID ?sp )
( requesterPID ?rp )
8
( lastAlertTime ? l &:( >=
(−(?now getTime )
(? l
getTime ) )
10000) )
( nbOfAlerts ?nboa&:( > 7 ?nboa ) ) )
10
=>
( modify ?a
12
( nbOfAlerts
(+ ?nboa 1) )
( lastAlertTime ?now) )
14
( p r i n t o u t
t
" C r i t i c a l
A l e r t NLAB " ?nlab
" Sender " ?sp "
Requester
" ?rp
c r l f )

11.4.
Adding Jess Support to MediMAS
136
( return−fact−to−current−behaviour ?a )
16
( r e t r a c t ?a ) )
Rule for Urgent Alert Actions
This rules ﬁres if an AlertAction that is urgent is in the working memory and has not been
treated during the last 30 minutes by its recipient. The RHS of this rule is identical to
the RHS of the critical-alert rule discussed above.
( defrule MAIN : : urgent−alert
2
( Time ( time ?now) )
?a <−( AlertAction
4
( urgent TRUE)
( nlab ?nlab )
6
( senderPID ?sp )
( requesterPID ?rp )
8
( lastAlertTime ? l &:( >= (−(?now getTime )
(? l
getTime ) )
30000) )
( nbOfAlerts ?nboa&:( > 7 ?nboa ) ) )
10
=>
( modify ?a
12
( nbOfAlerts
(+ ?nboa 1) )
( lastAlertTime ?now) )
14
( p r i n t o u t
t
" Urgent
A l e r t NLAB " ?nlab
" Sender " ?sp "
Requester
" ?rp
c r l f )
( return−fact−to−current−behaviour ?a )
16
( r e t r a c t ?a ) )
Module for High Priority Rules
An additional module IMPORTANT was deﬁned which will contain prioritized rules. It has
the focus when Jess runs and thus its rule will ﬁre before the rules in MAIN.
11.4.5 Adding a JADE Aware Jess User Function
JadeJessFunction
+JadeJessFunction( Agent myAgent, JessFunctionsManager jfr, OntologyClassManager ocr )
+setCommunicationConfigFactory( CommunicationConfiguratiionFactory commConfigFactory ) : void
#getCommunicationConfigFactory() : CommunicationConfiguratiionFactory
#getOntologyClassRegistry() : OntologyClassManager
#getAgent() : Agent
#getJessFunctionManager() : JessFunctionsManager
#jessFactToJadeOntologyInstance( Fact fact, Context context ) : Concept
Userfunction
+getName() : String
+call( ValueVector vv, Context context ) : Value
ChangeAlertCheckTime
+call() : Value
+getName() : String
Figure 11.5: The class hierarchy of the ChangeAlertCheckTime class
change-alert-check-time is a JADE aware Jess user function added for MediMAS. With this
function, the time intervals of the ticker behavior AgentHandlePendingResultBehaviour that
runs the JessAgentHandleAlertActionsBehaviour behavior, can be changed during run time.
This is done by calling (change-alert-check-time TIME) where TIME is the time interval in

11.5.
Changing the Behavior at Run Time
137
milliseconds. The change-alert-check-time Jess user function is implemented with the class
ChangeAlertCheckTime (see Figure 11.5). This class extends the abstract class JadeJess-
Function. The call method of the ChangeAlertCheckTime class is shown in Code extract 11.7.
In line 2, the function’s agent is casted into a JessableAlertManagerAgent object. In line 3,
the setAgentHandleAlert method of the JessableAlertManagerAgent object is called with the
value provided by the ValueVector as argument. The setAgentHandleAlert instance method
creates a new AgentHandlePendingResultBehaviour behavior with the time interval speciﬁed
as argument.
public Value
c a l l ( ValueVector arg0 ,
Context arg1 ) throws JessException
{
2
JessableAlertManagerAgent jama = ( JessableAlertManagerAgent )
this . getAgent ( ) ;
jama . setAgentHandleAlert ( arg0 . get (1) . intValue ( arg1 ) ) ;
4
return
Funcall .TRUE;
}
Code extract 11.7: The call method of the ChangeAlertCheckTime class
11.5 Changing the Behavior at Run Time
The rules in Section 11.4.4 do not add additional value to MediMAS. They simply replace
the hard coded Java algorithm of Code extract 11.1. Indeed, with the J2J tool kit, the
alert notiﬁcation logic can be modiﬁed during run time by accessing the Jess instance of
the Alert Manager agent with a remote Jess Administration agent. In the introduction
of this thesis, two examples were given that would beneﬁt from system that can have its
comportment changed during run time. The examples were:
1. The head of the laboratory has decided that she wants to be notiﬁed of every result
that is classiﬁed as critical and urgent.
2. A new strain of H5N1 was discovered in Switzerland. The Swiss Ministry of Health
requires immediate notiﬁcation if this strain is found in a human.
Both requests are implemented with Jess rules in the following Subsections. These rules
can be added on the ﬂy with the Jess Administration agent.
11.5.1 Sending Alerts To the Head of Laboratory
1 ( defrule MAIN : : urgent−and−critical−alert
?a <−( AlertAction
3
( c r i t i c a l TRUE)
( urgent TRUE)
5
( nlab ?nlab )
( senderPID ?sp )
7
( requesterPID ?rp ) )
=>
9
( p r i n t o u t
t
" Urgent
A l e r t NLAB " ?nlab
" Sender " ?sp "
Requester
" ?rp
c r l f ) )
Code extract 11.8: Handle urgent and critical cases
Rule urgent-and-critical-alert in Code extract 11.8 ﬁres if a AlertAction that is critical and ur-
gent is in the working memory. This example rule simply prints a message to the console.
11.5.2 Reacting to Laboratory Results with H5N1

11.5.
Changing the Behavior at Run Time
138
1 ( defrule IMPORTANT : : h5n1−found
?a <−( AlertAction
( icd10 ? icd &:(= ? icd
" J09 " ) )
( nlab ?nlab ) )
3
=>
( p r i n t o u t
t
" bird
f l u e
case located
in
lab
order
" ?nlab
c r l f
" contact
swiss
m i n i s t r y
of
health "
c r l f )
5
( r e t r a c t ?a ) )
Code extract 11.9: Notify the Swiss Ministry of Health if a H5N1 case appears
Rule h5n1-found in Code extract 11.9 ﬁres for every AlertAction in the working memory with
the value of the slot icd10 set to "J09", the ICD-10 code for the avian inﬂuenza virus [20].
This rule prints a warning to the console. The reader shall note that the icd10 slot is
currently not used by MediMAS. It was added for this Chapter. To test the rule, the
following fact of Code extract 11.10 can be asserted with the Jess Administration agent:
1
( assert
(MAIN : : AlertAction
3
( senderPID 10)
( urgent TRUE)
5
( c r i t i c a l TRUE)
( requesterPID
3)
7
( nlab
’ nlab−117 ’ )
( nbOfAlerts
1)
9
( lastAlertTime
(new java . u t i l . Date ) )
( n o t i f i c a t i o n T i m e
(new java . u t i l . Date ) )
11
( icd10
" J09 " ) ) )
Code extract 11.10: A test fact for the h5n1-found rule of Code extract 11.9
A more sophisticated version of this rule would not only print a warning to the console
but, for example, call a Jess user function to send an e-mail to the Swiss Ministry of
Health. The following example shall clarify this idea: It shall be assumed that MediMAS
has a class MediMASMail that has an instance method sendEMailTo. This method takes an
e-mail address and a Concept instance as argument. Furthermore, it is assumed that the
following JADE aware Jess user function send-email, implemented with the class SendEmail,
takes an e-mail address and a fact as argument to send the fact to the owner of the e-mail
address (i.e. line 4 of Code extract 11.9 would be (send-email “alert@bag.admin.ch” ?a)).
This Jess function would call sendEMailTo of a MediMASMail object to send an e-mail. The
source code of the SendEmail class is shown in Code extract 11.11
1 public class SendMail extends JadeJessFunction
{
public
String getName ( )
{
3
return
" send−email " ;
}
5
public Value
c a l l ( ValueVector vv ,
Context
context ) throws JessException
{
i f
( vv . size ( )
!=
3)
7
throw new JessException ( this . getName ( ) ,
"Wrong number of arguments " , vv . size ( ) −1) ;
9
MediMASMail m = new MediMASMail ( ) ;
String
receiver = vv . get (1) . stringValue ( context ) ;
11
Concept concept = this . jessFactToJadeOntologyInstance ( vv . get (2) . factValue ( context ) ,
context ) ;
m. sendEMailTo ( receiver ,
concept ) ;
13
return
Funcall .TRUE;
}
15 }
Code extract 11.11: The SendEmail class

11.6.
Conclusion
139
11.6 Conclusion
This Chapter demonstrated that the J2J tool kit can be applied, with only minor changes,
to a new environment and in a diﬀerent context. This being a result of the modular design
of the J2J tool kit.
It is the author’s oppinion that handling the alert notiﬁcation management with the Jess
does indeed oﬀer considerable advantages compared to hard coding the decision making
in Java instructions:
• The alert notiﬁcation module with Jess is ﬂexible: new rules can be added during
run time.
• As it was shown with the Jess user function change-alert-check-time, the remote Jess
Administration can potentially be used to manage the entire agent, not only its Jess
instance.
• The alert notiﬁcation module can easily be logged through the event listener inter-
face of Jess, without "polluting" the business logic with code needed for the logging
mechanism.
• By switching on the verbose mode of Jess, the alert notiﬁcation can be monitored
in real time.

12
Conclusion
12.1 Achievements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
12.2 Future Work
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
12.1 Achievements
In the ﬁrst part of this thesis, the business processes that support the exchange of labora-
tory results between the Laboratoire Cantonal de Fribourg and the Hôpital Cantonal de
Fribourg are reviewed and modeled with the EPC notation. The potential for improve-
ment of these processes let the development of MediMAS and the J2J tool kit.
The main goal of this thesis is the development of the J2J tool kit. It permits the use of
Jess to handle the entire intelligence of a software agent or only a subset of the decision
making. Jess, it was argued, has the following properties that make it an ideal choice to
handle the decision making:
1. Decision making is written in a descriptive way: the knowledge engineer describes
what happens when the working memory is in a given state, not when.
2. The Jess engine is an interpreter, thus rules can be added and removed during run
time.
3. Jess is written in Java and can seamlessly interact with Java applications.
Combined with the multi-agent framework JADE that lays the foundation for a (i) scal-
able, (ii) distributed and (iii) failsafe environment, it oﬀers a comprehensive framework
for the development of ﬂexible, extensible and scalable distributed systems. The J2J tool
kit provides seamless integration between Jess and JADE with the goal that a knowl-
edge engineer does not have to be familiar with JADE or Java to write rules and a Java
developer does not need to master Jess to develop a multi-agent system with Jess. Ad-
ditionally, the J2J tool kit can be easily integrated in an existing multi-agent system
without requiring major changes to its design and implementation. The following design
choices have contributed to these goals:
• The intelligent agent as a service user: An agent is a service user of the
class that manages the JADE and Jess integration, it does not have to extend an
abstract class. It merely needs to implement an interface to permit its adherent
objects (e.g. behaviors) to use its instance of the class JessCNC which manages
140

12.1.
Achievements
141
the Jess and JADE integration. Providing the Jess and JADE integration with an
abstract agent class would severely limit its usefulness for an existing multi-agent
system because it would require to alter the existing system’s class hierarchy. This
is due to the fact that Java does not provide multi-inheritance of classes, only of
interfaces.
• Interoperability: The knowledge artifacts managed by JADE and Jess are based
on the same semantics and thus can seamlessly be exchanged between both systems
without loss of information or cumbersome transformation rules. This is achieved
by creating a generic representation of the domain speciﬁc ontology already used
by the JADE agents, which can be mapped to diﬀerent formats such as templates
that represent classes in Jess or the string representation of the ontology that is sent
to the remote Jess Administration agents. The mapping from the generic ontology
representation to a speciﬁc format is achieved with Visitors and is not part of the
generic ontology representation. Hence the generic ontology representation can be
easily mapped to a variety of formats by adding new Visitors.
• JADE services for Jess: The instance of the Jess rule-engine of a particular agent
that uses the J2J tool kit, can communicate with other agents in its host agent’s
environment or with the agent’s behavior, without needing to use the Java API,
by calling Jess user functions that were implemented as part of the J2J tool kit.
If these functions are provided with a fact as argument, the fact is automatically
transformed into a Java object that can be used by JADE. This is possible since
both systems use the same ontology.
• Remote Administration: The Jess instance of an agent can be accessed remotely
through a command line interface to remotely update the knowledge base. Thus
rules can be added and removed and facts added, removed and modiﬁed during run
time. The remove Jess Administration interface is also a useful tool for debugging.
• Generic tool kit: The J2J tool kit is not bound to a speciﬁc domain nor does it
dictate a certain type of agent organization. This thesis was initiated to improve
MediMAS. Agents in the MediMAS environment handle the coordination primarily
based on "organizational structuring". The Alert Manager agent, which is the mas-
ter agent, coordinates the activities of its slaves that represent the actors involved
in a healthcare process. Therefore, the Matrix example which was used to develop
and test the framework, uses the same type of agent organization. Nevertheless,
the J2J tool kit can easily be used for any type of agent and agent system.
• Modular design: The design of the J2J tool kit is based on loosely coupled classes
by applying design patterns. New functionalities can be added without modifying
the existing tool kit, thus further promoting the use of the J2J tool kit in a wide
variety of applications.
The J2J tool kit was successfully applied in two diﬀerent multi-agent environments: ﬁrst
the Matrix, which consists of one master agent and several reactive slave agents. The
master agent coordinates the entire workﬂow and is fully aware of each slave agent’s
state. In the second use case, the J2J tool kit was added to an already existing multi-
agent framework, MediMAS. The J2J tool kit is not, as it is the case with the master agent
in the Matrix environment, in charge of the entire process. Instead, the Alert Manager,
which is the master agent in the MediMAS environment, uses Jess only to decide how to

12.2.
Future Work
142
react to individual alerts based on their current state. The other actions in the workﬂow
are assigned to behaviors.
12.2 Future Work
The J2J tool kit will be deployed and further developed by the Software Engineering
Research Group. In this Section, the author makes a set of recommendations for the
future development of the tool kit:
Conﬁguration File:
Currently the J2J tool kit does not use a central conﬁguration ﬁle.
Thus it is required to import the source code of the J2J tool kit into a project that uses
the tool kit to change certain values, notably the path for the ontology class ﬁles and the
reference to the current ontology instance in the class OntoloyTreeManager. The relative
path to the ﬁle that contains the default rules is hard coded as well in the JessCNC class.
The author recommends to implement a central conﬁguration ﬁle for the J2J tool kit.
Automatic Generation of "(agent action, behavior)" Pairs:
Part of the service
provided by the OntologyClassManager class are "(Agent Action, Behavior)" pairs. This
speciﬁc functionality of the OntologyClassManager class is used for the command-agent Jess
user function.
The command-agent function takes an AgentAction instance and the AID
object of the recipient as argument. It sends the agent action to the recipient with an
ACLMessage. This ACLMessage object is passed as constructor argument to the behavior
that corresponds to the agent action. An agent action can be assigned unambiguously
to a behavior if the conventions deﬁned in Section 5.2.3 are followed. That is, for every
agent action, there is exactly one behavior to initiate a FIPA-Request conversation and
one behavior to react to a FIPA-Request conversation. Currently the generation of these
pairs is hard coded in the constructor of the OntologyClassManager class, as a proof of
concept. The list of "(agent action, behavior)" pairs can be generated automatically by
looking up, for every agent action, the behavior that contains the agent action’s name and
the suﬃx "Initiator", assuming the behaviors are named as recommended in Section 5.2.3.
Further Development of Remote Jess Administration:
New functionalities could be
added to the remote Jess Administration, such as:
• Improving the GUI of the remote Jess Administration agent. The current imple-
mentation is a prototype.
• Saving newly added rules as default rules and permanently deleting existing rules.
• Displaying the attributes of the ontology classes.
• Uploading a new rule ﬁle.
• Dumping the current state of the working memory to the ﬁle system.
• Authentication and Authorization: Currently there is no access restriction imple-
mented. In a testing environment with dummy data, this is not an issue but it
would be required, if ever real data were to be processed.

12.2.
Future Work
143
Improved Facts to Object Mapping:
The algorithm that maps facts passed to JADE
aware Jess user functions, located in the abstract class JadeJessFunction, can only trans-
form facts that are concepts in the JADE ontology into objects, not predicates. Further-
more, lists are not supported as well. This algorithm should be improved to support all
types of facts.
Support for Multiple Ontologies:
An Ontology Tree Manager is limited to one ontol-
ogy. It would be useful to have an Ontology Tree Manager that could manage several
ontologies.
As an example, an Ontology Tree Manager could manage one enterprise
ontology and one information ontology. The enterprise ontology models the context in
which the multi-agent system executes, such as employees, processes and activities. The
information ontology describes the information objects, their attributes and the relation-
ships between the information objects. The terms enterprise ontology and information
ontology are discussed in [ABH+98, p. 44].
Adding Support for UMLS:
The Uniﬁed Medical Language System (UMLS) frame-
work provides the means to develop applications ”that behave as if they "understand" the
meaning of the language of biomedicine and health“ [26]. UMLS can be used in a wide
range of applications that interact with medical data in a variety of medical domains, e.g.
patient care, index, cataloging biomedical literature, health service billing [27]. UMLS
could be used to classify laboratory results by their medical content. The author recom-
mends to use a separate Ontology Agent for UMLS, due to the frameworks high resource
requirements [28].
Add Support for Backup Agents:
Agents that fulﬁll critical tasks and are unique in a
multi-agent environment, for example the master agent in the context of a master/slave
organization, represent a single point of failure for the multi-agent environment they exist
in. The risks posed by this single point of failure could be mitigated by adding backup
agents for the critical agents. When a critical agent fails, one of its backup agents takes
over; the system continues to function. The author suggests the following approach to
explore: In the master’s sub environment, each agent knows all of its peers. The master
agent forwards every change of its state (e.g. a fact or a rule is added or removed from the
knowledge base) to its backup agents, making the backup agents identical copies of the
master agent. When the master agent is inactive, its sends "still alive" messages to its
backup agents, for them to know the master agent is still operational. When the backup
agents do not receive a message from the master agent, either an update of the state of
the master agent or a "still alive" message, they have to assume that the master agent is
down. The backup agents start a negotiation process to determine which backup agent
will take over as master. The new master registers itself with the Directory Facilitator
Agent as the master agent. After a given time period, the slave agents notice, by the
absence of acknowledges to their messages from the master agent that the master agent
is not responding anymore. They lookup the master agent in the Directory Facilitator
agent and resend the messages. The failure recovery will only work for hardware failures
owing to the fact that a software bug should aﬀect the backup agents as well. Thus each
master must run on a separate computer. Additionally, the slave agents will have to be
slightly adapted to handle the non-responsiveness of the master agent.
A simple example with two slave agents, one Directory Facilitator agent and one master

12.2.
Future Work
144
(a) Master agent operates normally
(b) Master agent fails
(c) Backup agents negotiate and slave lookup the
new master
(d) The system continues to function
Figure 12.1: Eliminating the single point of failure by providing redundancy with backup
agents
agent with three backup agents assigned, is given in Figures 12.1(a) to 12.1(d). Fig-
ure 12.1(a) shows the system when it functions normally. The agents Slave 1 and Slave 2
send message m1 respectively message m2 to the master agent. Both are acknowledged by
the master agent and also forwarded to its backup agents. In Figure 12.1(b), the master
agent malfunctions and cannot acknowledge the messages m3 and m4. Furthermore, the
backup agents receive no signal from the master agent. After a given timeout period, the
master agent is presumed dead. The backup agents start a negotiation process to decide
which agent is going to act as master agent. In this example, agent Backup 1 is chosen
and registers itself with the Directory Facilitator agent as the new master agent. The
slave agents, after a given time out period, lookup the new master agent in the Direc-
tory Facilitator agent and receive the address of the agent Backup 1. This is shown in
Figure 12.1(c). Next, as depicted in Figure 12.1(d), the slave agents send the messages
m3 and m4 again to the acting master agent. The new master agent acknowledges the
messages and forwards both messages to the remaining backup agents. The system did
not fail.
When a new backup agent enters the system, it looks up the master agent and registers
itself with the master agent. If there is no master agent in the system, the new backup

12.2.
Future Work
145
agent becomes the master agent.
The forwarding of the messages from the master agent to its slaves could be implemented
by using the event listener interface of Jess [Hil03, p. 418–419]. For each even of interest,
a given event listener could react to the event by forwarding the event to the backup
agents.
MediMAS with Multiple Intelligent Agents:
It would be interesting to develop a
diﬀerent MediMAS framework with several intelligent agents. The decision making could
be distributed among each agent that represents an actor in the healthcare workﬂow. For
example, instead of having the Alert Manager agent as the only intelligent agent in the
MediMAS environment, each laboratory agent could use Jess. Thus there would not be a
single intelligent master agent but a set of intelligent laboratory agents that would need
to negotiate to execute the workﬂows they are designed to support. This would eliminate
the single point of failure at the cost of more negotiation and the lack of one agent with
the global view.

Part IV
Appendix
146

A
Healthcare Business Processes at the
HCF and LCF
These images were designed by Minh Tuan Nguyen and Patrik Fuhrer of the Software
Engineering Group, University of Fribourg, Switzerland.
147

148

149

150

151

B
Messaging Serivce UML Sequence
Diagrams
The following UML Sequence Diagrams correspond to the red demarcations of Figure 5.2,
Page 37.
152

153
myCommandProcessor : CommandProcessor
firstDownFilter : OutgoingEncodingFilter
ch : AgentContainerImpl
s : CommandSourceSink
cmd : GenericCommand
msg : GenericMessage
 : MessageManager
outBox : Outbox
next : SinksFilter
sender : Agent
sender is unlocked
in the LADT
Inactive 
intermediate filters 
omitted.
filter(cmd)
8: 
accept(cmd )
9: 
next(cmd)
11: 
postProcess(cmd)
18: 
releaseLocalAgent(reveiver)
10: 
"Send-Message",
"jade.core.messaging.Messaging"
3: 
tobeSend
4: 
processOutgoing(cmd)
7: 
addParam(gmsg)
5: 
addParam(receiver)
6: 
handleSendMessage(cmd )
14: 
deliver(gmsg, dest, MessagingService )
15: 
deliver(gmsg, dest, MessagingService )
16: 
accept(cmd )
12: 
postProcess(cmd)
17: 
consume(cmd)
13: 
send
1: 
handleSend(msg)
2: 
Figure B.1: Step 1

154
targetSlice : MessagingProxy
impl : MainContainerImpl
ch : MessagingService
 : AgentContainerImpl
pm : PendingMsg
outBox : Outbox
 : Deliverer
cid
14: 
deliverInLocalPlatfrom(msg, receiverID)
9: 
getMain
11: 
getContainerID(receiverID)
13: 
oneShotDeliver(cid, msg, receiverID)
15: 
getSlice(cid.getName()
16: 
dispatchLocally(msg.getSender(), msg, receiverID)
17: 
impl
12: 
msg
4: 
ch
8: 
receiverID
6: 
pm
2: 
get
1: 
deliverNow(msg, receiver)
10: 
getMessage
3: 
getReceiver
5: 
getChannel
7: 
Figure B.2: Step 2

155
targetSlice : MessagingProxy
slice : ServiceComponent
cmd : GenericCommand
adaptee : NodeRMIImpl
ch : MessagingService
n : NodeAdapter
Horziontal 
Command for 
Messaging Service
Paramter setting 
not shown
2: 
accept(cmd)
3: 
serveHorizontalCommand(cmd)
5: 
dispatchLocally(msg.getSender(), msg, receiverID)
1: 
accept(cmd)
4: 
getSlice("Messaging")
6: 
serve(cmd)
7: 
Figure B.3: Step 3

156
firstUpFilter : IncomingEncodingFilter
processor : CommandProcessor
msgQueue : MessageQueue
gCmd : GenericCommand
slice : ServiceComponent
 : AgentContainerImpl
next : SinksFilter
n : NodeAdapter
reciever : Agent
Prompts a vertical 
mssage to be sent 
to the notification 
service. This step 
is omitted
Inactive 
intermediate Fitlers
 are omitted
Setting parameters
 based on the 
values of the 
incoming generic 
command
accept(gCmd)
7: 
filter(cmd)
8: 
filter(gCmd)
6: 
"Send-Message",
"jade.core.messaging.Messaging"
2: 
gCmd
3: 
postMessage(msg)
12: 
handleSendMessage(cmd)
9: 
postMessage(msg,receiverID)
10: 
postMessageToLocalAgent(msg, receiverID)
11: 
serve(cmd)
1: 
serveVerticalCommand(gCmd)
4: 
processIncoming(gCmd)
5: 
addLast(msg)
13: 
doWake
14: 
Figure B.4: Step 4

C
Installing and Running the Matrix
To run the Matrix, the following libraries must be in the class path:
• JADE: For the multi-agent framework
– http.jar
– iiop.jar
– jade.jar
– jadeTools.jar
– commons-codec-1.3.jar
• Jess: For the rule-based system
– jess.jar
• Jigloo: For the GUI framework used by the remote Jess Administration
agent
– appFramework-1.0.jar
– jnlp.jar
– looks-2.1.4.jar
blah blah run ant and set proﬁle
157

D
Algorithms
D.1 Creating the JTree of the Ontology
1 private void createJTree ( )
{
Vector <Tuple<String ,
DefaultMutableTreeNode >> helper = new Vector <Tuple <String ,
DefaultMutableTreeNode > >() ;
3
Tuple <String ,
DefaultMutableTreeNode > t = null ;
for
( String s :
this . parseme )
{
5
t
= new Tuple <String ,
DefaultMutableTreeNode >() ;
t . setFirstElement ( s ) ;
7
t . setSecondElement ( null ) ;
helper . add ( t ) ;
9
}
Stack <Tuple <String ,
DefaultMutableTreeNode >> main = new Stack <Tuple <String ,
DefaultMutableTreeNode > >() ;
11
Tuple <String ,
DefaultMutableTreeNode > c h i l d = null ;
Tuple <String ,
DefaultMutableTreeNode > parent = null ;
13
Tuple <String ,
DefaultMutableTreeNode > root = null ;
for
( Tuple <String ,
DefaultMutableTreeNode > tn
:
helper )
{
15
i f
( " ( " . equals ( tn . getFirstElement ( ) ) )
continue ;
17
i f
( " ) " . equals ( tn . getFirstElement ( ) ) )
{
c h i l d = main . pop ( ) ;
19
i f
( c h i l d . getSecondElement ( ) == null )
c h i l d . setSecondElement (new DefaultMutableTreeNode ( c h i l d . getFirstElement ( ) ) ) ;
21
i f
( main . size ( ) > 0)
{
parent = main . peek ( ) ;
23
i f
( parent . getSecondElement ( ) == null )
parent . setSecondElement (new DefaultMutableTreeNode ( parent . getFirstElement ( ) ) ) ;
25
parent . getSecondElement ( ) . add ( c h i l d . getSecondElement ( ) ) ;
}
else
{
27
root = c h i l d ;
break ;
29
}
continue ;
31
}
main . push ( tn ) ;
33
}
JessAdminAgent jaa = ( JessAdminAgent )
this . myAgent ;
35
jaa . getJessAdminGui ( ) . setJTreeRoot ( root . getSecondElement ( ) ) ;
}
Code extract D.1: Algorithm to create a JTree that contains the ontology
The algorithm of Code extract D.1 is located in the class OntologyTreeChangedResponder. It
uses a vector of strings to generate a JTree that represents the ontology used by Jess. In
line 2, the Vector that will contain “String, DefaultMutableTreeNode” pairs is declared an line 3
declares the Tuple variable to store a “String, DefaultMutableTreeNode” pair. The String of such
158

D.2.
Sorting the Ontology Classes
159
an object holds the name of a node in the ontology tree, the DefaultMutableTreeNode the
corresponding node in the JTree. The for loop in lines 4–9 creates, for each String object of
the Vector containing the names of the ontology classes, a “String, DefaultMutableTreeNode”
object and adds it to the helper Vector. Lines 10–13 declare and initialize the variables
required to create the JTree. The JTree is created in the for loop in lines 14–34: If the
ﬁrst element of the current object contains a left parenthesis, it is dropped (line 15–16).
If the ﬁrst element of the current object contains a right parenthesis, it indicates that
the end of a list has been reached, thus the next element in the stack main that contains
the nodes of the ontology that have not yet been added to the JTree, is popped (lines
17–19). If the second element of the current object is null, a DefaultMutableTreeNode with
the name of the ontology class it represents is instantiated (line 20). If there are still
nodes left to be treated (line 21), the parent of the current object is accessed and the
current object is linked to its parent (lines 22–25). If the parent node does not yet have a
DefaultMutaleTreeNode object, a DefaultMutableTreeNode object is instantiated and a reference
to that object is saved as the second element of the current object (line 24). If there are
no more objects left in main, the current object is the root (line 27) and the loop is exited.
If the current object is not a parenthesis, it is pushed onto the main stack (line 32). In
line 34 the GUI object of the behavior’s agent is accessed and the second element of the
root object set as the root of the JTree root (line 35).
D.2 Sorting the Ontology Classes
The algorithm to sort the classes in the ontology is shown in Code extract D.2. The two
dimensional Vector that will contain the ﬁnal result is created at lines 2–5. Line 6 states the
directory location of the ontology Java classes. At line 8 and 9 two Vector<String> objects
are created. The instance methods getConceptNames and getPredicateNames of the ontology
object return all class names in lower case. Because for dynamic loading of Java classes
will require the correct name of the Java class, the directoryContent Vector is required. A
class at position p is in directoryContent is the same class as in searchDirContent. The classes
are read from the ﬁle system. Each class that is in the directory and in the lists returned
by the ontology object is added to domainOntologyContent (line 10–12, not shown in the
source code extract). At lines 13–15 additional variables are declared that will be used
by the sorting algorithm. If the ontology contains elements, the ﬁrst element is taken
(lines 16–17). The classes names in domainOntologyContent are in lower case, therefore the
proper class name has to be ﬁrst looked up in searchDirContent to get the position of the
class in the Vector and access the original name of the class in directoryContent. This name
is needed to dynamically load the class (lines 19–22). At lines 23-25, the super class is
accessed, dynamically loaded and the name transformed to lower case for the lookup.
The if statement at line 27 is true for a class that either has no super class in the ontology
because it is at the highest level or because its parent node has already been processed
and removed from domainOntologyContent. Thus the element in current is not at the top of
the tree, it is added back to domainOntologyContent at the position of its parent and the
parent is set as the current element (lines 27–30). Next, he current iteration is skipped
(line 31).
If the current class does not have a super class in domainOntologyContent, the class’s name
and Class object are added to stringResult, respectively classResult (lines 33–34). If there
are still classes left to be sorted, ﬁrst element of domainOntologyContent is removed and set
as the value of current. Otherwise, current is set to null and the loop is exited (lines 35–38).

D.3.
Creating the Ontology Composite
160
private
Vector [ ]
buildSimpleTree ( )
{
2
Vector <String > stringResult = new Vector <String >() ;
Vector <Class > classResult = new Vector <Class >() ;
4
Vector [ ]
r e s u l t = new Vector [ 2 ] ;
r e s u l t [ 0 ] = stringResult ;
r e s u l t [ 1 ] = classResult ;
6
String
ontologyDirName = this . getClass ( ) . getResource ( " / "+ DOMAIN_ONTOLOGY) . getPath ( ) ;
F i l e
ontologyDir = new F i l e ( ontologyDirName ) ;
8
Vector <String > directoryContent = new Vector <String >() ;
Vector <String > searchDirContent = new Vector <String >() ;
10
/ / not shown :
l i s t i n g
the
d i r e c t o r y
that
contains
the
ontology and adding the
class names
to
ontologyDirName and ontologyDir .
List <String > domainOntologyContent ;
/ / not shown : Each class
in
the
ontology
i s added to
domainOntologyContent
.
12
try
{
String className = null ;
Class superClass = null ;
14
String superClassName = null ;
String
tempSuperClass = null ;
String
current = null ;
Class <?> currentClass = null ;
16
i f
( domainOntologyContent . size ( ) > 0)
current = domainOntologyContent . remove (0) ;
18
while
( current
!=
null )
{
className = directoryContent
20
. get ( searchDirContent . indexOf ( current ) ) ;
className = className . substring (0 , className . indexOf ( " . " ) ) ;
22
currentClass = Class . forName (DOMAIN_ONTOLOGY. replace ( ’ / ’ ,
’ . ’ )+ " . " + className ) ;
superClass = currentClass . getSuperclass ( ) ;
24
superClassName = superClass . getName ( ) ;
tempSuperClass = superClass . getSimpleName ( ) . toLowerCase ( ) ;
26
i f
( domainOntologyContent . contains ( tempSuperClass ) )
{
domainOntologyContent . set ( domainOntologyContent
28
. indexOf ( tempSuperClass ) ,
current ) ; ;
current = tempSuperClass ;
30
currentClass = superClass ;
continue ;
32
}
stringResult . add ( currentClass . getName ( ) ) ;
34
classResult . add ( currentClass ) ;
i f
( domainOntologyContent . size ( ) > 0)
36
current = domainOntologyContent . remove (0) ;
else
38
current = null ;
}
40
} catch ( ClassNotFoundException e )
{
e . printStackTrace ( ) ;
42
}
return
r e s u l t ;
44
}
Code extract D.2: Sorting the classes of the ontology
D.3 Creating the Ontology Composite
The algorithm that builds the ontology composite is shown in Code extract D.3. The
instance method buildVisitorWorthyTree takes a two dimensional Vector array, created by
buildSimpleTree, as argument. At lines 2–7 variables are declared that will be used by the
algorithm. As long as there are classes that have not yet been added to the ontology
composite (line 8), the following is done: The class that is at the beginning of currentS
and currentC is removed from these Vectors and its super class loaded (9–12). If the super
class is already part of the ﬁnal composite tree, the (future) parent node is looked up
the in the ontoloyClasses hash (lines 13–14). Otherwise, possible interfaces the class may
extend are fetched and each looked up in the ontologyClasses hash. A result will be found
for the classes are the direct child nodes of the second-level nodes in the initial ontology
composite.
The for loop is aboarded is aboarded as soon as a parent is found (lines

D.3.
Creating the Ontology Composite
161
15–22). The current node is created with the createOntologyElement Factory method, the
parent and child relationships are set for the current node and the parent of the node,
and the current node is added to the ontoloyClasses hash since it now part of the tree and
can accept child nodes (lines 23–27). The loop is exited when all classes have been added
to the ontology composite.
private void
buildVisitorWorthyTree ( Vector [ ]
tree )
{
2
Vector <String > className = tree [ 0 ] ;
Vector <Class > classClass = tree [ 1 ] ;
String
currentS = null ;
Class currentC = null ;
4
String
superClassS = null ;
Class superClassC = null ;
Class [ ]
i n t e r f a c e s = null ;
6
OntologyElement parent = null ;
OntologyElement currentE = null ;
boolean found = false ;
8
while
( className . size ( ) > 0)
{
currentS = className . remove (0) ;
10
currentC = classClass . remove (0) ;
superClassC = currentC . getSuperclass ( ) ;
12
superClassS = superClassC . getName ( ) ;
i f
( this . ontoloyClasses . containsKey ( superClassS ) ) {
14
parent = this . ontoloyClasses . get ( superClassS ) ;
}
else
{
16
i n t e r f a c e s = currentC . getInterfaces ( ) ;
for
( Class c :
i n t e r f a c e s )
18
i f
( this . ontoloyClasses . containsKey ( c . getName ( ) ) )
{
parent = this . ontoloyClasses . get ( c . getName ( ) ) ;
20
break ;
}
22
}
currentE = this . createOntologyElement ( parent . getClass ( ) . getSimpleName ( ) ,
currentS ) ;
24
currentE . setJavaClass ( currentC ) ;
parent . addChild ( currentE ) ;
26
currentE . setParent ( parent ) ;
this . ontoloyClasses . put ( currentE . getName ( ) ,
currentE ) ;
28
}
}
Code extract D.3: Algorithm that creates the composite representing the ontology

E
Common Acronyms
ACL Agent Communication Language
ADs Activity Diagrams
AD Activity Diagram
AID AgentIdentiﬁer
AMS Agent Management System
API Application Programming Interface
ARIS Architecture of Integrated Information System
BDI Beliefs, Desires and Intentions
BPM Business Process Management
CLIPS C Language Integrated Production System
CT Container Table
DF Directory Facilitator
DF Directory Facilitator
EPC Event-Driven Process Chain
EPC Event-driven Process Chains
FIPA Foundation for Intelligent Physical Agents
GADT Global Agent Descriptor Table
GUI Graphical User Interface
ICD-10 International Classiﬁcation of Diseases 10
ICT Information and Communications Technology
IMTP Internal Message Transport Protocol
IT Information Technology
J2J Jess 2 JADE
JADE Java Agent Development Framework
162

163
JessCnC Jess Command and Control
LADT Local Agent Descriptor Table
LEAP Lightweight Extensible Agent Platform
LGPL Library Gnu Public License
LHS left-hand side
LISP List Processing
MTP Message Transport Protocol
MTS Message Transport Service
OA Ontology Agent
OKBC Open Knowledge Base Connectivity
OWL Web Ontology Language
PDA Personal Digital Assistant
RHS right hand side
RMA Remote Monitoring Agent
RMI Remote Method Invocation
UMLS Uniﬁed Medical Language System
UML Uniﬁed Modeling Language
URI Uniform Resource Identiﬁer
URL Uniform Resource Locator
eEPC extended Event-Driven Process Chain

F
License of the Documentation
Copyright (c) 2008 Joël Vogt.
Permission is granted to copy, distribute and/or modify this document under the terms
of the GNU Free Documentation License, Version 1.2 or any later version published by
the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no
Back-Cover Texts.
The GNU Free Documentation Licence can be read from [4].
164

G
Website of the Project
A web-page was created for this project: http://www.gmipsoft.com/rﬁd1. On this page you
will ﬁnd:
• The API of the project.
• This binaries and sources of this documentation.
• The binaries and sources of the.
• Parts of the content (see H).
Figure G.1 provides a screenshot of this website.
1This URL is a shortcut to http://diuf.unifr.ch/softeng/student-projects/completed/guinard/
index.html
165

166
Figure G.1: Screenshot of the project’s oﬃcial web-page

H
CD-ROM
On the CD-ROM Figure H.2 of the project you will ﬁnd:
• The source code, Ant ﬁles and compiled binaries of the.
• The APIs of the.
• The binaries and sources of this documentation.
• Various documents that were of great use during this bachelor thesis.
Figure H.1 provides a tree view of the CD-ROM.
The content of the CD-ROM can also be downloaded from the oﬃcial website of the
project (see G).
167

168
|-- api
|
|-- javadoc_myapplication
//API of the application.
|
‘-- javadoc_framework
|-- bachelor_thesis
//Binaries (pdf, ps, etc.) and
|
|-- appendix
//sources of this document
|
|-- codes
//and of the presentation.
|
|-- figures
//Sources of the figures.
|
‘-- chapters
|
|-- introduction
|
‘-- chapter1
|-- software
//this work.
|-- Java
‘-- Eclipse
Figure H.1: Tree view of the content of the CD-ROM
Figure H.2: The CD-ROM of this project

References
[ABH+98]
A. Abecker, A. Bernardi, K. Hinkelmann, O. Kuhn, M. Sintek, and
K. DFKI.
Toward a technology for organizational memories.
Intelli-
gent Systems and Their Applications, IEEE [see also IEEE Intelligent
Systems], 13(3):40–48, 1998.
[All05]
T. Allweyer.
Geschäftsprozessmanagement: Strategie, Entwurf, Imple-
mentierung, Controlling. W3L-Verl, 2005.
[ASC+03]
K. Anyanwu, A. Sheth, J. Cardoso, J. Miller, and K. Kochut. Healthcare
Enterprise Process Development and Integration. Journal of Research and
Practice in Information Technology, 35(2):83–98, 2003.
[BCG07]
Fabio Bellifemine, Giovanni Caire, and Dominic Greenwood. Developing
Multi-Agent Systems with JADE. John Wiley & Sons Ltd., The Atrium,
Southern Gate, Chichester, West Sussex PO19 8SQ, England, 2007.
[BCTR00]
F. Bellifemine, G. Caire, T. Trucco, and G. Rimassa. JADE Programmer’s
Guide. Italy: CSELT SpA, 2:120–122, 2000.
[BKR03]
J. Becker, M. Kugeler, and M. Rosemann. Process Management: A Guide
for the Design of Business Processes. Springer, 2003.
[BM]
D. Briola and V. Mascardi. Integrating a FIPA-compliant Ontology Agent
within a FIPA-compliant framework.
[Bri98]
British Computer Society’s Specialist Group on Expert Systems. Internet-
based Decision Support for Evidence-based Medicine. Expert Systems ’98,
1998.
[BS84]
B.G. Buchanan and E.H. Shortliﬀe.
Rule Based Expert Systems: The
Mycin Experiments of the Stanford Heuristic Programming Project (The
Addison-Wesley series in artiﬁcial intelligence). Addison-Wesley Long-
man Publishing Co., Inc. Boston, MA, USA, 1984.
[BWH07]
Rafael H. Bordini, Michael Wooldridge, and Jomi Fred Hübner. Program-
ming Multi-Agent Systems in AgentSpeak using Jason (Wiley Series in
Agent Technology). John Wiley & Sons, 2007.
[CFF+98]
V.K. Chaudhri, A. Farquhar, R. Fikes, P.D. Karp, and J.P. Rice. Open
Knowledge Base Connectivity 2.0. 3—Proposed—, 1998.
169

References
170
[Eck06]
Bruce Eckel. Thinking in Java, 4th edition. Prentice Hall PTR, 4 edition
edition, 2006.
[Fla05]
D. Flanagan. Java in a Nutshell. O’Reilly Media, Inc., 2005.
[GFN89]
A. GUPTA, C. FORGY, and A. NEWELL.
High-Speed Implementa-
tions of Rule-Based Systems. ACM Transactions on Computer Systems,
7(2):119–146, 1989.
[GHJV95]
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design
Patterns Elements of Reusable Object-Oriented Software. Addison-Wesley,
Indianapolis IN USA, 1995.
[GPFLC04]
A. Gómez-Pèrez, M. Fernàndez-Lòpez, and O. Corcho. Ontological En-
gineering: With Examples from the Areas of Knowledge Management,
E-Commerce and the Semantic Web. Springer, 2004.
[Gru93]
T.R. Gruber. A translation approach to portable ontology speciﬁcations.
Knowledge Acquisition, 5(2):199–220, 1993.
[Hil03]
Ernest Friedman Hill. Jess in Action: Java Rule-Based Systems. Manning
Publications Co., Greenwich, CT, USA, 2003.
[HR85]
F. Hayes-Roth.
Rule-based systems.
Communications of the ACM,
28(9):921–932, 1985.
[HS06]
S. Hüsemann and M. Schäfer. Building ﬂexible eHealth processes using
business rules, 2006.
[JNF+00]
NR Jennings, TJ Norman, P. Faratin, P. O’Brien, and B. Odgers. AU-
TONOMOUS AGENTS FOR BUSINESS PROCESS MANAGEMENT.
Applied Artiﬁcial Intelligence, 14(2):145–189, 2000.
[Kec06]
Christoph Kecher. UML 2.0 Das umfassende Handbuch. Galileo Press,
Bonn, second edition, 2006.
[KL06]
B. Korherr and B. List. A UML 2 Proﬁle for Event Driven Process Chains,
2006.
[Krc04]
H. Krcmar. Informationsmanagement. Springer, Berlin, fourth edition,
2004.
[KRSR98]
Gerti Kappel, S. Rausch-Schott, and Werner Retschitzegger. Coordina-
tion in workﬂow management systems - a rule-based approach. In Coor-
dination Technology for Collaborative Applications - Organizations, Pro-
cesses, and Agents [ASIAN 1996 Workshop], pages 99–120, London, UK,
1998. Springer-Verlag.
[NR02]
M. Nüttgens and F.J. Rump. Syntax und Semantik Ereignisgesteuerter
Prozessketten (EPK), 2002.
[PJDH03]
T.O. Paulussen, N.R. Jennings, K.S. Decker, and A. Heinzl. Distributed
Patient Scheduling in Hospitals.
Proceedings of the Eighteenth Inter-
national Joint Conference on Artiﬁcial Intelligence (IJCAI-03). Morgan
Kaufmann, 2003.
[RB90]
G.A. Rummler and A.P. Brache. Improving Performance: How to Manage
the White Space on the Organization Chart. Jossey-Bass, 1990.

References
171
[RH05]
C. Rouﬀand M.G. Hinchey. Agent Technology from a Formal Perspective.
Springer, 2005.
[RN03]
S.J. Russell and P. Norvig. Artiﬁcial intelligence: a modern approach.
Prentice-Hall, Inc. Upper Saddle River, NJ, USA, Upper Saddle River,
New Jersey 07458, second edition, 2003.
[Rup07]
Andreas Ruppen. Systèmes multi agents medimas: Etude de cas dans le
domaine du e-health care, 2007.
[RvdAtHW06] Nick Russell, Wil M. P. van der Aalst, Arthur H. M. ter Hofstede, and
Petia Wohed. On the suitability of UML 2.0 activity diagrams for business
process modelling, 2006.
[SDL+05]
G.S. Semmel, S.R. Davis, K.W. Leucht, D.A. Rowe, K.E. Smith, and
L. Bölöni. NESTA: NASA Engineering Shuttle Telemetry Agent. Pro-
ceedings of the 20th National Conference on Artiﬁcial Intelligence and the
17th Innovative Applications of Artiﬁcial Intelligence Conference, pages
1491–1498, 2005.
[SHC+07]
D. Suri, A. Howell, A.T. Center, D. Schmidt, G. Biswas, J. Kinnebrew,
W. Otte, and N. Shankaran. A Multi-Agent Architecture provides Smart
Sensing for the NASA Sensor Web. Aerospace Conference, 2007 IEEE,
pages 1–9, 2007.
[SW01]
JW Schmidt and D.I.A. Wienberg. A Comparison of Event-driven Pro-
cess Chains and UML Activity Diagram for Denoting Business Processes,
2001.
[TP07]
Ben Tse and Raman Paranjape. Macroscopic Modeling of Information
Flow in an Agent-Based Electronic Health Record System. In Architec-
tural Design of Multi-Agent Systems: Technologies and Techniques, chap-
ter XVI, pages 305–334. Information Science Reference, 2007.
[vdA99]
WMP van der Aalst. Formalization and veriﬁcation of event-driven pro-
cess chains. Information and Software Technology, 41(10):639–650, 1999.
[vMSB84]
W. van Melle, E.H. Shortliﬀe, and B.G. Buchanan. EMYCIN: A Knowl-
edge Engineer’s Tool for Constructing Rule-Based Expert Systems, 1984.
[WJ95]
M. Wooldridge and N.R. Jennings. Intelligent Agents: Theory and Prac-
tice. The Knowledge Engineering Review, 10(2):115–152, 1995.
[Woo02]
M. Wooldridge. An Introduction to MultiAgent Systems, 1-14, 2002.

Referenced Web Ressources
[1] CloudGarden. Jigloo swt/swing gui builder for eclipse and websphere. http://www.
cloudgarden.com/jigloo/ (visited: 01.06.2008).
[2] DATAMED AG. WinDMLAB : das erprobte laborinformationsystem. http://www.
datamed.ch/ (visited: 09.03.2007).
[3] G. Eysenbach. What is e-health? J Med Internet Res, 3(2), Jun 2001.
[4] Free Documentation Licence (GNU FDL). http://www.gnu.org/licenses/fdl.
txt (accessed July 30, 2005).
[5] FIPA. FIPA Ontology Service Speciﬁcation, 2001. http://www.fipa.org/specs/
fipa00086/XC00086D.html (visited: 13.02.2008). ix
[6] FIPA. FIPA ACL Message Structure Speciﬁcation, 2002. http://www.fipa.org/
specs/fipa00061/SC00061G.html (visited: 24.05.2008).
[7] FIPA.
Interaction
Protocol
Speciﬁcation,
2002.
http://www.fipa.org/
repository/ips.php3 (visited 24.05.2008).
[8] FIPA. FIPA Request Interaction Protocol Speciﬁcation, 2003. http://www.fipa.
org/specs/fipa00026/SC00026H.html (visited: 22.04.2008). ix
[9] FIPA.
Welcome to the Foundation for Intelligent Physical Agents, 2008. http:
//www.fipa.org/ (visited 09.07.2008).
[10] Ernest J. Friedman-Hill. 6. Making Your Own Rules, 2007. http://www.jessrules.
com/jess/docs/70/rules.html (visited: 07.06.2008).
[11] Ernest J. Friedman-Hill. Jess the Rule Engine for the JavaTM Platform, 2007. http:
//herzberg.ca.sandia.gov/ (visited: 29.12.2007).
[12] Ernest J. Friedman-Hill. Jess, the Rule Engine for the Java Platform, 2008. http:
//www.jessrules.com/ (visited: 01.06.2008).
[13] Knut Hinkelmann. 5.3 Modellierung in ARIS, 2005. http://moodle.fhso.ch/mod/
resource/view.php?id=410 (visited: 4.3.2008). ix
[14] J.P.E. Hodgson. Prolog: The ISO Standard Documents, 1999. http://pauillac.
inria.fr/~deransar/prolog/docs.html (visited: 01.06.2008).
[15] DARPA HPKB.
Open Knowledge Base Connectivity Home Page, 1995.
http:
//www.ai.sri.com/~okbc/ (visited: 01.02.2008).
172

Referenced Web Ressources
173
[16] ILOG.
ILOG JRules, 2008.
http://www.ilog.com/products/jrules/ (visited:
01.06.2008).
[17] Workﬂow Patterns Initiative. Welcome to the Workﬂow Patterns home page, 2007.
http://www.workflowpatterns.com (visited: 31.05.2008).
[18] M. T. Nguyen, P. Fuhrer, J. Pasquier-Rocha, and Andreas Ruppen. (Medical Multi-
Agent Systems), 2008. http://diuf.unifr.ch/softeng/projects/medimas/ (vis-
ited: 03.06.2008).
[19] Minh Tuan Nguyen, 2008. http://diuf.unifr.ch/people/nguyenmi/download/
MediMAS/Figures/19052008/ (visited: 27.06.2008). ix
[20] World Health Organization.
Diseases of the respiratory system (j00-j99),
2007.
http://www.who.int/classifications/apps/icd/icd10online/?gj09.
htm+j09 (visited: 24.06.2008).
[21] World Health Organization. International classiﬁcation of diseases (icd), 2008. http:
//www.who.int/classifications/icd/en/ (visited: 24.06.2008).
[22] Gary Riley. What is CLIPS?, 2007. http://www.ghg.net/clips/WhatIsCLIPS.
html (visited: 25.12.2007).
[23] Gary Riley.
A Tool for Building Expert Systems, 2008.
http://clipsrules.
sourceforge.net/ (visited: 01.06.2008).
[24] J. Michael Straczynski.
Bablyon 5, 1993.
http://www.babylon5.com (visited:
03.06.2008).
[25] Protégé team. The Protégé Ontology Editor and Knowledge Acquisition System,
2008. http://protege.stanford.edu/ (visited: 14.06.2008).
[26] U.S. National Library of Medicine. About the UMLS R⃝Resources, 2006. http:
//www.nlm.nih.gov/research/umls/about_umls.html (visited: 08.11.2007).
[27] U.S. National Library of Medicine. Section 2 Metathesaurus, 2007. http://www.
nlm.nih.gov/research/umls/meta2.html (visited: 8.11.2007).
[28] U.S. National Library of Medicine. Section 7, UMLS DVD, 2008. http://www.nlm.
nih.gov/research/umls/meta7.html (visited: 28.7.2008).
[29] C.J. van Aart. Ontologybeangenerator, 2007. http://protege.cim3.net/cgi-bin/
wiki.pl?OntologyBeanGenerator (visited: 15.06.2008).
[30] Larry Wachowski and Andy Wachowski.
The Matrix, 1999–2003.
http://
whatisthematrix.warnerbros.com/ (visited: 02.06.2008).

