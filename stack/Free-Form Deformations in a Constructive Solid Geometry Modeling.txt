Brigham Young University 
Brigham Young University 
BYU ScholarsArchive 
BYU ScholarsArchive 
Theses and Dissertations 
1986-04-01 
Free-Form Deformations in a Constructive Solid Geometry 
Free-Form Deformations in a Constructive Solid Geometry 
Modeling System 
Modeling System 
Scott R. Parry 
Brigham Young University - Provo 
Follow this and additional works at: https://scholarsarchive.byu.edu/etd 
 Part of the Civil and Environmental Engineering Commons 
BYU ScholarsArchive Citation 
BYU ScholarsArchive Citation 
Parry, Scott R., "Free-Form Deformations in a Constructive Solid Geometry Modeling System" (1986). 
Theses and Dissertations. 4255. 
https://scholarsarchive.byu.edu/etd/4255 
This Dissertation is brought to you for free and open access by BYU ScholarsArchive. It has been accepted for 
inclusion in Theses and Dissertations by an authorized administrator of BYU ScholarsArchive. For more 
information, please contact scholarsarchive@byu.edu, ellen_amatangelo@byu.edu. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
FREE-FORM DEFORMATIONS IN A 
CONSTRUCTIVE SOLID GEOMETRY MODELING SYSTEM 
A Dissertation 
Presented to the 
Department of Civil Engineering 
Brigham Young University 
In Partial Fulfillment 
of the Requirements ior the Degree 
Do~tor of Philosophy 
by 
Scott R. Parry 
April H)86 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
This dbscrtation, by Scott R. Parry, is accepted in its present form by 
the Department of Civil Engineering of Brigham Young University as 
satisfying the dissertation requirement for the degree of Doctor of Philosophy. 
18 M/\I\..'-'1 l'1kb 
Date 
Thomas W. Sederberg, Commi ee Chairman 
N. Christiansen, Committee Member 
e Member 
N. Christiansen, Department Chairman 
II 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
©1986 
SCOTT R. PARRY 
All ~ights ~eserved 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
ACKNO~EDGEMENTS 
I would first like to express my appreciation to fellow students Rob 
Zundel and Kevin West for taking me "under their wings" as a new graduate 
student. 
I sincerely thank 
t he professors of the BYU Civ!l Engineering 
department for their generous service. Gratitude is extended to the faculty of 
the graphics la.b -
Dr. Michael B. Stephenson, Dr. Steven E. Benzley and Dr. 
Bruce J. Nay -
who were always willing to answer a question or provide 
thoul~htful insights. I am particularly grateful for the encouragement, counsel 
and friendship of Dr. Henry N. Christiansen. His willingness to provide 
funding is also appreciated. 
Dr. Ron Goldman or Control Data des~rves credit for his helpful 
suggestions in preparing this dissertation. 
I have been extremely fortunate to have Dr. Thomas Vi. Sederberg as 
my advisor. I am thankful for his valuable guidance and schooling, and have 
been edified by his fine character and scholarly example. It has ,truly been an 
honor to be his first Ph.D. student. 
I cannot overlook the immeasurable support and teachings of my 
parents: John \V. and Elizabeth A. Parry. 
And finally, I acknowledge my loving wife, Lisa, and sons, Ryan and 
Andy. who share with me this degree. To my wife I express my aeepest 
gratitude for her patience and devotion throughout my college studies. 
m 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
T .ABLE OF CONTENTS 
LIST OF FIGURES .......................................................................... .......... 
vi 
LIST OF TABLES ...................................................................................... 
viii 
Chapter 1: 
INTRODUCTION .............................................. ......................... ............... 
1 
Chapter 2: 
PIECEWISE ALGEBRAIC SURFACE PATCHES .................................... 
6 
Tetrahedral Primitive .... ... ............. ........... ..... ............. ... ..... ... ..... ....... .... 
7 
Cross-Boundary Derivative Continuity .................................................. 
11 
Control Point Movement ....................................................................... 
12 
Chapter 3: 
FREE .. FORM DEFORMATION ................................................................. 
16 
!\1athematical Formulation .................................................................... 
19 
Deformation Domain ........... ...... ............ .................... ............................. 
22 
Inversion "''''',.,'' '" ", ,."" "'" ,,,. """'" .. "",, .. '"""",, ""....... ..... ...... ....... 
26 
Continuity Contr'ol ................................................................................. 
28 
Examples ........................................................................... ..................... 
30 
Chapter 4: 
FREE-FORM DEFORMATION AND SOLID MODELING ...................... 
35 
CSG !\'1cthod ......... ............................... ............. ......... ........... ................. 
36 
Chapter 5: 
DATA STRUCTURES AND PRIMITNE PROCESSING ................ ......... 
40 
CSG Node Definition ............................................................................. 
40 
Primitive Definition ................................................................................ 
41 
Primitive Processing 
44 
Iv 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 6: 
ADAPTIVE SUBDIVlSION ........................................................................ 
46 
Subdividing Triangles ............................................................................ 
47 
Adaptive Subdivision Algoritilm ............................................................ 
53 
Chapter 7: 
HIDDEN SURFACE REMOVAL 
56 
Scan Line Algorithm .............................................................................. 
57 
CSG Scan Line Algorithm ...................................................................... 
58 
Crl?:ating in-out lists .......................................................................... 
59 
Combining in-out list~ .............................................................. :........ 
60 
Deten .. .ining visibility across a span .................................................. 
63 
Finding intersecting segments ...................... ".................................. 
65 
Other implementation considerations ............................................... 
65 
Chapter 8: 
SUMMARY A.Nu FUTURE DE\lELOPMENTS ........................................ 
67 
Future Developments ............................................................................. 
69 
REFERENCES ........................................................................ ................... 
71 
APPENDIX ................................................................................................. 
76 
Initial Primitive Definition ..................................................................... 
77 
v 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
LIST OF FIGURES 
Figure 1 - Control Point Lattice for Cubic Algebraic Surbcp. Patch ......... 
9 
Figure 2 - Algebraic Surface Patches of Degree 1-4 .. ................................. 
9 
Figure 3 - Altering the Weight of a Control Point ..................................... 
10 
Figure 4 - C 1 Cubic Algebraic Surface Patches .......................................... 
11 
Figure 5 - Implicit Solid Defined with Parallelpiped ................................... 
13 
Figure 0 - rvloving a Control Point ........................ ..................................... 
13 
Figure 7 - Loc~l Coordinate System ........................................................... 
17 
Figure 8 - Undisplaced Control Points ....................................................... 
17 
Figure 9 - Control Points in Deformed Position ......................................... 
18 
Figure 10 - Deformed Sidewalls .................................................................. 
18 
Figure 11 - Two Bicubic Patches ................................................................ 
23 
Figure 12 - Local FFD ................... ........... ........ .... .... .......... ..... .... ... ............ 
23 
Figure 13 - Intersecting Sphere and Plane .................................................. 
24 
Figure 14 - Deiormed Sphere and Plane ..................................................... 
24 
Fi~ure 15 - Piecewise Continuous FFDs ..................................................... 
27 
Figure 16 - Local C k Control Points ........................................................... 
29 
Figure 17 - C- 1, GO,Ol and C 2 Local Deformations ................................... 
29 
Figure 18 - Volume Preserving FFD ........................................................ '" 
31 
Figure 19 - Local FFD ................................................................................ 
31 
:Figure 20 - Global FFD .......... .............. ............... .... ....... ..... ....................... 
32 
Figure 21 - Telephone Receivers ................................................................. 
32 
vi 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Figure 22 - Trophy ............................................................... '" ... ................. 
33 
Figure 23 - Deformed and Undeformed Cans and Bottles .......................... 
33 
Figure 24 - CSG Model ..................... ............................... ............ ............... 
38 
Figure 25 - CSG Tree .......... ............ ....... ........ ............. ............... ................ 
38 
Figure 26 - Separation Resulting from Subdivision .................................... 
47 
Figure 27 - Recursive Subdivision ............................................................... 
49 
Figure 28 - Exception ror the R.ecursion Algorithm ................................... 
50 
Figure 29A - 0, 1 and 2 Uniform Subdivisions ............................................ 
51 
Figure 29B - 4 and 7 Uniform Subdivisions ................................................ 
52 
Figure 30 ~- Normal Criterion Set at 10 
0 
.................................................. 
55 
Figure 31 - Normal Criterion Set at 5 
0 
............................ ........................ 
55 
Figure 32 - Example of In-out List Combinations ...................................... 
60 
Figure 33 - Primitive 1 (A,B) -
Primitive 2 (C,D) .................................. 
64 
Figure 34 - Primitive 1 (A,B) n Primitive 2 (C,D) .................................. 
64 
Figure 35 - eSG Model with FFD .............................. ................................ 
68 
Figure 36 - Triangle and Vertex Numbering ..... .. ........ .............................. 
77 
vii 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
LIST OF TABLES 
Table 1 - Boolean Node .............................................................................. 
40 
Table 2 - Primitive Node ............................................................................ 
41 
Table 3 - Vertex A:trays .................................... ....... . ..... ............ ................ 
42 
Table 4 - Triangle Arrays .............................. ................. .................. .......... . 
43 
Table 5 - Boolean Combination Rules .... ...... ...................... ........ ................ 
62 
Table 6 - Simplifications for In-out List Combinations ....................... ....... 
62 
Table 7 - Initial Values for Sphere Primitive ............ .... ............................. 
79 
Table 8 - Initial Values for Cylinder Primitive ........................................... 
81 
Table 9 - Initial Values for Block Primitive ............................................... 
82 
vlll 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 1 
INTRODUCTION 
No one will question that computers are revolution:zing the design 
industry. It is pointed out in [Bezier84] that before CAD/C_AJv!, a surface \-.-as 
defined by tracing cross sect.ions on a drawing and then carving these sections 
in wood, plastic or metal. The final model was determined by someone 
interpolating between the sections. This labor intensive art is being replaced 
by techniques of (;omputer aided geometric design. 
The need of the automotive and airline industries to automate the 
design and manufacture of objects with curved surfaces helped to motivate the 
development of curve and surface technology. Coons and Ferguson, in the early 
sixties, made two significant contributions in developing (:. mathematical 
system for curve and surface definition [Coons641, [Ferguson641, [Forrest72j. 
First, they emp!oyed vector-valued, parametric 
d~finit.ions of curves and 
surfaces. Second, their representations were piecewise, eliminating the need to 
express an entire surface by a single equation. The piecewise approach allows 
surfaces to be built up by piecing surface patches together with specified 
continuity conditions. These were not merely computer implementations of 
well tried manual met.hods, but new methods specifically tailored to the new 
computing capability. 
Coons' method was best suited for defining exist.ing surfaces. Other 
methods were introduced for developing new surfaces. Probably the two most 
noteworthy of these are Bezier [Bezier74] and B-spline [Gordon74] curves and 
1 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
surfaces. Many of todays modeling systems are based on these two techniques. 
Bezier and de Casteljau developed the Bezier method indepen.dently in 
the early sixties as part of CAD syst.ems for two differi:.nt French car 
companies. The underlying theory is based on the use of Bernstein polynomials 
as blending functions. 
This method provides a mathematical relationship 
between a set of points in space known as control points and the shape of the 
surface. The surface is predictably related to the locations of these control 
points. In the e~rly seventies, Gordon and Riesenfeld applied the spline and 
B-spline tb.eories to CAD and showed that B-spline curves and surfaces are a 
generalization of Bezier curves and surfaces. 
Since the mid-seventies there has been a thrust toward modeling objects 
as a whole. This is known as solid geometric modeling and its goal is to 
provide a mathematically complete definition of any physical, manufacturable 
object. 
This means that the model should be able to provide enough 
information about the object it represents to enable the object to be 
automatica.lly manufactured, depicted or analyzed. Many schemes, as surveyed 
in [RequicbaSO], [RequichaS2] and [RequichaS3], have been developed such as 
pure primitive instancing, spatial occupancy enumeration, cell decompositions, 
con::>trlJctive 
solid 
geometry 
(CSG), 
sweep 
representations, 
boundary 
representations (B-rep). S2veral combinations or hybrids of these have also 
been proposed. 
Probably the two most prominent solid modeling schemes are esc and 
B-rep. CSG consists of modeling by the use of boolean combinations (union, 
intersection and difference) of volume primitives such ac:; prisms, pyramids, 
cylinders, cones, spheres and tori. A more detailed look at the esc method is 
found in chapter 4. The B-rep modeling technique views each volume as a 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
3 
collection of bounding surfaces consisting of a finite number of faces. Each face 
is defined by a list of edges and vertices as well as the connectivity among the 
elements. The model also keeps track of which side of each face lies inside the 
solid. Valid boundary representations are difficult and tedious to construct 
and systems which use t.hem often convert to them from other representations 
such as eSG. 
The fields of solid modeling and surface modeling have been deve!.oping 
ratiler independei:ii iy. Surface modeling has dealt primarily with parametric 
surface patches. These patches are generally referred to as free-form surfaces, 
or sculptured surfaces, which suggest that they can be shaped with flexibility 
akin to clay in a sculptor's hands. For this reason, planes, quadrics and tori 
are generally not considered to be free-form. Most solid modeling systems use 
surfaces that are planar, quadric or toroidaL 
R~~ently, the capability of 
defining fillets and blended surfaces has also been introduced [Middleditch85]' 
[Hoffmann85], [Rockwood86], [Owen86]. Other than that, free-form surfaces 
have seen little use in solid modeling. 
This problem of defining a solid geometric model or an object bounded 
by free-form surfaces has long been identified as an important research rrontier 
in solid modeling. Most of the approaches to this problem can be classified 
into one of three cat egories. 
1. Combining e.r;Sl;Tlg free-form surface and solid modeling techniques. 
This extends the surface domain of a solid modeling system to include 
free-form parametric surface patches. It is currently the most popular 
approach and some applications can be found in IKalay82J, IJared841, 
[Chiyokura83j, \Varady84], [Riesenfc!d83j, [Sarraga,84], [Steinberg8-1:, 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
IThomas84j, and IKimura84J. 
This method must overcome several 
difficulties such as ensuring representational validity in using the free-
form surfaces in a general manner. These problems are described in 
[Requicha82]. 
2. Trivariate parametric hyperpateh. The hyperpatch is used as a solid 
modeling primitive. 
Thi~ method has been used for years by the 
analysis community and has many fine applications such as finite 
element mesh generation IStanton77], ICasale85j. [Farouki85] discusses 
adding a fourth parameter of time to cr~ate a time-space swath useful 
for motion definition. 
3. Implicit surfaces. There has been limited investigation of modeling 
directly with volumes bounded by implicit or algebraic surfaces. 
Calculating curves of surface intersection and deciding whether a point 
lies inside a volume is much easier with this definition, especiaHy when 
the surfaces are of low degree. However, free-form sha.pe definition 
lends itself more naturally to parametric equa.tious than to implicit 
equations. Sabin was one of the early investigators of modeling with 
algebraic 
surfaces 
[Sabin68]. 
The work 
in 
[Ricci73], 
[S~rr81j, 
[Rockwood86], [Owen86j, [Hofi'mann85j and [Slinn82] explores modeling 
implicit surfaces other than quadrics, but each of these were special 
cases in which the implicit equation was not a polynomial. [Scderberg85J 
introduced modeling with piecewise algebraic surface patches. 
Of the approaches to free-form modeling just surveyed, this dissertation 
builds most directly on [Sederberg85j, which is presented as background 
material in the next chapter. From this method is developed a technique to 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
6 
deform a solid model in a free-form manner. This technique is referred to as 
free-form deformation or FFD. Free-form deformatioa represents a fresh 
approach to free-form solit] modeling and does not fall into any of the above 
three categories. The technique can be used with any solid modeling system, 
such as CSG or B-rep. It can deform surface primitives of any type or degree 
including planes, quadrics, parametric surface patches or implicitly defined 
surfaces. The deformation can be applied either globally or locally. Local 
deformations can be imposed with any desired degree of derivative continuity. 
A parametric surface patch is a mapping from R2 to R3 (two-
dimensional real parameter space to three-dimensional Cartesian space). The 
FFD presented herein is a mapping from R3 to RS through a trivariate 
Bernstein polynomial. An earlier use of R3 to R3 mapping is found in Barr's 
innovative paper on regular deformations of solids [BarrS4j. While not a free-
form modeling technique, Barr's idea of twisting, bending and tapering of solid 
primitives is a powerful and elegant design tool. 
This dissertation nrresents the FFD method and discusses its annlication 
.. 
to a CSG based solid modeler. Chapter 3 expounds the mathematical theory 
and general application of FFD including giobai and local application and 
continuity constraints. Chapters 4 through 6 discuss the implementation of 
FFD in a solid modeler. ChdPter 4 introduce.; the CSG based modeling system 
and cbapter 5 explains the primitive and model data structure. Adaptive 
subdivision is presented in chapter 6. The hidden surface removal technique 
that is key to solving the CSG visibility problem is explained in chapter 7. 
Results are summarized and future improvements are discussed in the finai 
chapter. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 2 
PIECEWISE ALGEBRAIC SURF ACE PATCHES 
This chapter examines piecewise algebraic surface patches as an 
introduction to the FFD technique. 
There are basically two methods for defining a surface: para.metric 
equations or implicit equations. A parametrically defined surface takes the 
form x = X(8,t), Y = Y(8,t) and z = Z(8,t). A surface is defined implicitly by 
an equation of the form !(x,y,z) = o. The surface is called an algebraic 
surface if f(x,y,z) is a polynomial. 
An algebraic surface patch is defined by bounding an algebraic surface 
with a tetrahedron or a parallelpiped. The surface defines two half spaces 
(f(x,y,z)<O and l(x,y,z»O) and the boolean intersection of either haIr space 
with the tetrahedron or parallelpiped can be considered a volume building 
block for modeling purposes. The primiiive contains a regular iattice or 
control point'5, and weights are assigned to these points to provide a 
meaningful way to control the shape of the surface inside the patch. 
The advantage of this method is that the algebraic surface inside the 
patch is defined in a free-form manner and the degree of the surface can be 
much lower than typical parametric surface patches. 
It is shown in 
[Sederberg83] that any polynomial parametric surface can be expressed in an 
implicit equation. For example, a general bicubic patch can be expressed in an 
implicit equation of degree 18. By contrast, a.n algebraic surface of degree five 
has more scalar coefficients th3.n 3. bicubic patch (56 vs. 48). While it is not 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
7 
clear what relationship there is between modeiing flexibility and the number of 
coefficients, algebraic surface patches of degree as low as three can address 
many free-form modeling applications. 
Tetrahedral Primitive 
The algebraic surface patch definition will be described for the 
tetrahedral primitive. It is appropriate t,o work in trivariate barycentric 
coordinates because they provide a local coordiI!~te system for defining an 
, 
algebraic surface witilin a. specified region of the tetrahedron. 
[Bohm84] 
provides a good discussion on bivariate barycentric coordinates and 
IBarnhill84] presents trivariate barycentric coordinates. Let 8, t, u and v be 
the barycentric coordinates that are connected by the relation 8+t+U+V = 1. 
Consider an arbitrary tetrahedron with vertices V nOOO, V 0,,00, V oo,,(h and 
V 000" where the Vs are non-coplanar points in three space. The barycentric 
coordinates of &, point P in three space are the values 8,t,U,V such that 
n 
__ " 
-'- ," 
...L •• V _ _ _.L •• V __ _ 
:c -" ... nOOO ... 
~ " OnOO .... ,. oonO ..... ooon, 
• .41 •• , ... 
1 ~ 1 
.:7 .... \At." -
..... 
Cartesian coordinates are actually a special case of barycentric 
coordinates rei which the defining tetrahedron has vertices, V ,,000=(0,0,0), 
V OnOO=(l,O,O), V OOno=(O,l,O) and V 000,,=(0,0,1) in which case x=t, y=f.l, and 
z=v. 
General barycentric coordinates are linearly related to Cartesian 
coordinates. Therefore, any algebraic surface g(x.y,z)=O can be expressed in 
barycentric coordinates as /(s,t,u,v)=O by a linear change of variables. 
Consider the scalar function defined by the polynomial equation 
tV = f(s,t,u,v). Adopt the notation s=(s,t,u,v), so that j(e)=f(8,t,U,t'). 
This function assig,llS a unique value w=/(s) to each point with barycentric 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
8 
coordinates 8. A contour Bur/ace of the function is comprised of all points 8 
for which / (8) is a constant. Clearly, all contours are algebraic surfaces, and 
any algebraic surface can be viewed as the contour of a scalar function field. 
An algebraic surface patch is defined as the contour /(s) = 0 clipped by th~ 
tetrahedron. 
The tetrahedral clipping is expressed by the inequality 
8,t,U,tJ>0. 
What remains is to define the function field w = I (s) in such a way 
that it is reasonably easy to predict where the contour surface w = 0 lies. 
Trivariate Bernstein polynomials as described in lBOhm84] provide such a 
definition. A degree n algebraic surface patch can be defined using Bernstein 
polynomials as follows. First, impose a lattice of control points V ijkl on the 
tetrahedron such that 
.. 
_ i.. ~r 
.... Lv 
__ ... .!. v _ . ~~ ,r 
: : f. , ........ n. :. : . f. • f _ • ., 
" ijkl -
.. "GOO' 
• 0,,00' 
• ou"o'" 
~ 000", 
',J,"',':::::'V,;"'" J'" n. ... ,-,t. 
n 
n 
n 
n 
A degree n patch requires (n + 1)( n +2)( n +3)/6 control points. The control 
points for the case n=3 are shown in figure 1. Notice that V 1110 is hidden in 
this view. 
Now assign a weight Wijkl to each control point. The function w=/{s) 
is defined by 
I( t 
) 
'\' 
n! 
i.j I: l 
s, , u , v = 
LJ 
Wijlel. I • 1 k I I t 8 , U V ! 
i ... j ... k+l=" 
J • J. 
. . 
i,j,k,l >0; s+t+u+v=l. 
This compietes the scheme for defining an algebraic surface patch rOi a 
tetrahedral primitive. Sample algebraic surface patches of degrees one through 
four of this primitive are illustrated in figure 2. 
The weights tt'ijkl control f (9) in a manner which makes it reasonably 
easy to predict the location of the contour surface f (8 )=0. A control point 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
0030 
Figure 1 - Control Point Lattice ior Cubic Algebraic Surface Patch 
Figure 2 - Algebraic Surface Patches of Degree 1-4 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
10 
weight influences the function! (s) most directly in the vicinity of the control 
point. In fact, the contribution of a particular control point's weight to the 
function! (s) can be shown to be maximal at the control point. Qualitatively, 
this means that if !(Vijkl ) is negative (positive), then decreasing (increasing) 
the value of Wijkl will tend to push the surface 1(8 )=0 away from V ijkl, 
wh:~r".::.s ir::!reasi~g (de~re~Ing) th~ 'V"lu~ or U'ij;;: ",m to:!nd to attract. the 
surrac~ towards V ijkl' This type of control is illustrated in figure 3 which 
shows a series of four cubic algebraic surface patches whose control point 
weights are identical except for the weight of the topmost vertex. The value 
of that weight is zero in the bottom right surface, and is increa..c:ingly negative 
in the other three surfaces. As can be seen, the effect of modifying one weight 
Figure 3 - Altering the Weight of a Control Point 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
11 
tends to be quite local, especially for comer control points. 
Cross-Boundary Derivative Continuity 
This algebraic surface patch formulation inherits most of the tools of 
Bezier curves and surfaces: one can subdivide the suriace by subdiving the 
tetrahedron, perform degree elevation aud reduction, and impose cross-
bounda.ry derivative cont,inuity. Derivative continuity is achieved simply by 
imposing derivative continuity on the functions /(8) of two adjacent 
tetrahedrons. This procedure is discussed in IAlfeld84]. Figure 4 illustiates 
two Cl cubic algebraic surface patches. While it is easy to join two algebraic 
surface patches arbitrarily smoothly, it is not clear at present how easily this 
Figure 4 - Cl Cubic Algebraic Surface Patches 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
12 
can be done for an extended mesh of patches. 
Defining the patches within a parallelpiped has the adv9.utage that they 
are easier to piece together than tetrahedrons. Let the defining function for a 
parallelpiped be a trivariate tensor product Bernstein polynomial and let I, m 
The degree of the algebraic surface is now l+m+n. Figure 5 shows au implicit 
solid in line drawing iorm defined with the parallelpiped primitive. (See figure 
19 for a shaded image.) 
Control Point Movement 
A tremendous amount a flexibility could be obtained if the control 
points are allowed to move from their latticial positions. Figure 6 illustrates 
the movement of one control point and its effect on the piecewise algebraic 
suriace. Uniortunately, this flexibility comes at the expense or gignificantly 
raising the degree of the surface. 
The analysis of this degree elevation is most easily performed on the 
tetrahedral piecewise algebraic surface definition. Consider the relationship 
between the Cartesian coordinates X and the barycentric coordinates (s ,t, u, v) 
before and after moving the control point. Let V iikl = (z ,y ,Z )iitl be the 
Cartesian 
coordinates 
of 
the 
control 
points 
and 
let 
X( s ,t, u) = 
(z(s,t,u), y{s,t,u), z(a,t,u)) be the Cartedan coordinates of an arbitrary point. 
in space. Then it is easy to sho· .... that 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
• 
• 
Figure 5 - Implicit Solid Defined with Parallelpiped 
• 
• 
• 
Figure 6 - Moving a Control Point 
13 
• 
• 
• 
• 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
14 
V( A 
, 
.J \ -
P 
V 
n! 
iti k(l 
t 
)' 
~ ", ~ , .. } -
L.J 
ilkl. , . 'k 'I , s 
u 
- s - - u , 
i+i+k+l=n 
I . J. . . 
i,i,k,l >0. 
.As long as the control points 'Viikl remain in their latticial positions, 
there is a iinear reiationship between 8,t,u and :Jt,y,z. Even though X(s,t,u) 
is a degree n vector-valued Bernstein polynomial, it is a degree one power 
basis polynomial. This can be seen either by expanding out the summation (in 
which case all terms of degree greater than one cancel), or by verifying that 
the factorization can be made 
X(s,t,u) = [sV nOOO+tVonOO+uVoono+(l-s-t-u)VOOOnJ[s+t+u+(l-s-t-u)]n-l. 
However, as soon as a control point moves from its !atticial position, X(S,t,U) 
becomes a degree n function in the power basis as well as in the Bernstein 
basis. 
Let p be the degree of the deformed surface -
that is, the surface after 
movement of a control point. Note that the surface is originally of degree n. 
Geometrkally, the degree of a surface is the number of times it is intersected 
by a iine. Thus, p can be determined by computing how man] times a line 
intersects the deformed surface. To define a line, arbitrarily pick two unique 
planes. A plane in x,y,z space can be expressed Ax+By+Cz+D:.;O. The points 
in 
s,t, u 
space 
which 
map 
to 
this 
plane 
satisfy 
the 
equation 
Ax(s,t,tt)+By(s,t,u)+Cz(s,t,u)+D=O which is a degree n surface in s,t,u. 
According to Bezout's theorem, two such surfaces intersect in a space curve of 
degree n2 in 8,t,u space which evidently corresponds to a straight line in x ,y ,z 
space. This space curve intersects the undeformed surface in n3 points which 
must also be the number of times that a straight line intersects the deformed 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
16 
By similar reasoning, an arbitrary surface of degree q in 8, t, u becomes 
a surface of degree qn2 after deformation. Likewise, a deformation defined by 
a parallelpiped of degree I, m and n, in general, elevates a surface of degree q 
to one of degree q(/+m+n )2. 
Although the degrep. of the surface increases dramatically, this does not 
appear t.o be a serious drawback. In fact, experience suggests that this free-
iorm deformation (FFD) poss':?sses several surprisingly valuable characteristics .. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 3 
FREE-FORM DEFORMATION 
The control point movement discussed in the previous chapter gives rise 
to free-form deformation. 
Control point movement provided another 
dir.aension of flexibility for modeling the shape of a piecewise algebraic surface. 
However, the deformation [unction can be appiied to any geometric entity, not 
just to piecewise algebraic surfaces. 
The derormation technique is initiated by engulfing the rp.gion to be 
derormed by a parallelpiped defined by a local origin and three noncoplanar 
vectors. This volume can include the €:ntire model or can be localized in a 
specific 3.r~a. Figure 7 illustrates three vectors S, T and U, originating at Xo, 
that surround a set or boxes and spheres. Anything inside the region will be 
deformed and any part outside will remain unaffected. 
Pianes of controi points are defined aiong each vector. The number oi 
planes can be chosen independently ill each direction. These control points 
define the degr~e of the deformation. For a derormation of degree l,m,n there 
are 1+1 planes in the S direction, m + 1 planes in the T direction and n + 1 
planes in the U direction. In figure 8 1=1, m=2 and n=3. The control points 
are illustrated by small white diamonds. Generally a small number of control 
points suffice. 
A deformation is now specified by moving these control points from 
their undispiaced, iatticial positions. Figure 9 shows the displaced control 
points and the deformed model. Notice how this deformation has infiu('nced 
18 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
17 
Figure 7 - Local Coordinate System 
1-
~~~--'f-~ 
.. 
-"-".: 
-. 
. --
-
,-
.. '. ) . . . .  
..-
.. 
-. .: -
" 
--
. '  
--
-.• 
-' 
-
• 
0 
~. 
• 
.. 
-
.. 
-
-- -"""'L 
-
~ 
• 
_ 
Figure 8 - Undisplaeed Control Points 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
18 
Figure 9 - Control Points in Deformed Position 
--
-
. 
-
~ 
. 
. 
.. 
- --
-
Ie" 
. 
-
-
~ 
-
..,_ 
_ 
_ 
.. 
. ..... 
. ! 
-
~ 
----~----
Figure 10 - Deformed Sidewalls 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
HI 
the spheres and boxes. If sidewalls are placed defining the original undeformed 
paiallelpiped, figure 10 illustrates how the (transparent) "..,aUs derorm. 
Movement of a control point influences a localized region similar to the effect 
of a control point on a Bezier curve or surface. This ten.dency arises rrom 
using Bernstein polynomials in the mathematical definition or FiD. 
Mathematica; Formulation 
FFD is defined in terms or tensor product trivariate Bernstein 
polynomials. 
The parallelpiped defined above creates a local coordinate 
system. The local (s,t,u) coordinates of any point X can be easily founei using 
linear algebra to solve the equation: 
X=Xo+sS+tT+uU. 
Now s, t and u can be round by Cramer's rule: 
s = 
TXU'(X - Xo) 
TXU,S 
SXU'(X - Xo) 
t = --S-X-U-'T-~ 
u= SXT·(X - Xo) 
SXT·U 
The point X is inside the parallelpipcd region if 0 < B <1, 0 <t <1 2.nd 0 <!! <1. 
There are (/+l)x(m+l)x(n+l) control points that rorm the lattice. The 
location or ea.ch contiO} point P tile is defined by 
. 
. 
k 
Pi'le = Xo + .!.S + ..LT + -u, 
1 
I 
m 
n 
where ;=0,1, .. ,1; j=O,I, ... ,m; k=O,l, ... ,n. 
The deformed position XJfd of an arbitrary point X is found by first 
computing its iocal coordinate position (s,t, u) as previously outlined. If the 
point lies in the region to be deformed, the vector valued tr~varia.te Bernstein 
",,,hr"nrni., 1 ic: ",v., 1"., t ""I, 
1'-',,--'----- - -.----.--. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
20 
Note that the control points are actually vector valued coefficients of the 
trivariate Bernstein polynomial. 
This factor, as with Bezier curves and 
surfaces, affords us the meaningful relationship between the deformation and 
control point movement. It can be shown from the previous equation that 
edges of the parallelpiped map into Bezier curves. By setting two of the local 
(8, t ,u) coordinates to zero or one, the polynomial simplifies to a Bezier curv~ 
at one of the edges. This curve is defined by the respective control points of 
the edge. By setting one of the local coordinates to zero or one, i~ can been 
seen that the side walls map into tensor product Bezier surface patches. These 
side walls are defined by the control points that lie on the respective faces. 
This is illustrated in figure 10. 
One difficulty is that it is relatively expensive, especially when the 
degree is high, to evaluate a trivariate Bernstein polynomial. When one 
applies the deformation, many points will be sampled and ~valuated. It is more 
efficient to convert the Bernstein polynomial to the standard power polynomial 
basis which can then be evaluated using nested multiplication. A standard 
trivariate power basis polynomial is defined as 
P 
)_PO 
iik 
(s,t,u - L.JC- iilts t u . 
ii" 
The roHowing algorithm outlines the conversion from Bernstein to standard 
basis. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
FOR i=O TO 1 DO 
FOR j=O TO m DO 
FOR k=O TO n DO 
FOR q=O TO k-l DO 
P;j'=P;j' - r: ~P;jl/[; 1 
{END FOR q} 
\ 
Pijk=PijkX f ~l 
{END FOR k} 
\ 
{END FORj} 
{END FOR i} 
FOR i=O TO I DO 
FOR j=O TO n DO 
FOR k=O TO m DO 
FOR q=O TO k-l DO 
Pikj=PiI~r r :lXPiqj/!~l 
{END FOR q} 
t 
P;'j=P;'jX [; 1 
{END FOR k} 
{END FORj} 
{END FOR i} 
FOR i=O TO m DO 
FOR j=O TO n DO 
FOR k=O TO I DO 
FOR q=O TO k-l D[~l 
(l' 
PL",=PL."·-
xP .. /1 I 
InJ 
... J 
q 
9111 I a 
{END FOR q} 
t . ) 
Plnj=PlnjX [~l 
{END FOR k} 
{EI\TJ) FOR j} 
{EI\TD FOR i} 
21 
The algorithm converts P jjk Crom a vector valued Bernstein polynomial 
coefficient to a vector valued power basis polynomial coefficient. Now using 
the power basis polynomiai, P( s,t, u) can be efficiently evaluated by the 
following algorithm. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
fOR i=O TO I DO 
FOR j=O TO m DO 
FOR k=n-l DOWNTO 0 DO 
Pn=uXPj Ie k+l+Pn 
{END FOR k} 
•• 
1 
{END FORj} 
{END FOR i} 
FOR i=O TO I DO 
FOR j=m-l DOWNTO 0 DO 
Pi'O=txP; '+10+P j'O 
{END FOR j} 
.1. 
1 
{END FOR i} 
FOR i=i-l DOWNTO 0 DO 
PiOO=SXPi+l oo+PiOO 
{END FOR i} 
• , 
Upon the conclusion of the nested multiplication, P( 8,t, u )=Pooo. When 
implementing this algorithm, one may want to use temporary variables so that 
the origil1al control points are not destroyed in the evaluation. 
The deformation could also be formulated in terms of other polynomial 
basis such 
8."l tensor product B-spiines or non-tensor product Bernstein 
polynomials. The choice of basis made here is for simplicity. 
Deformation Domain 
FFDs are versatile and can be applied to virtually any geometric model. 
Deforming a polygonal model consists of deforming the vertices of the polygons 
while maintaining the original connectivity. An in-depth look at polygonal 
deformation is found in ISederberg86a]. Any curve, surface or solid of any 
database can be deformed. Figure 11 illustrates two slope continuou!' bicubic 
boundary of the two patches. It can be shown that any rational polynomial 
parametric surface remains rational polynomial parametric after deformation. 
If the parametric surface is given by x = f(fr,f3), y = g(a:,f3) and z = h(fr.f3) 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
23 
Figure 11 - Two Bicubic Patches 
. 
. 
. 
. 
-
-- 'lJ 
-. -- . 
-
I -
. 
-
, 
. 
----
.---. 
-
~ 
<'! 
• 
-
" 
._ 
• 
-U--=--_J. 
.: 
~ 
_ _ 
~--
,;:-.' __ 
Figure 12 - Local FFD 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
24 
Figure 13 - Intersecting Sphere and Plane 
. 
'" 
-
~ 
. 
•• 
_. 
_ .. J~ 
_. 
~ 
___ ~... 
--
1'. 
• 
-. 
-
--, 
-
. ~ 
-
. 
-
-. 
~ 
. 
\ 
-
-
~---~---,,--
-
_ 
.. 
1 __ 
• 
Figure 14 - Deformed Sphere and Plane 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
25 
and the FFD is given by X ffd = X(x,y,z), then by substitution, the deformed 
parametric surface patch is given by X ffd(a,{3) = X(f(a,,8),g(a,,B),h(a,,B)). 
Figure 13 shows a sphere intersected by a plane, and in figure 14, both 
are deformed by the same FFD. The sphere and the plane could be defined 
parametrically or by implicit equation; the resulting deCormation is the same 
under either definition. The circular intersection oC figure 13 can be expressed 
in term5 of rational quadratic polynomials. Just as surfaces remain rational 
polynomial parametric under FFD, so also the deformed curve in fi?:ure 14 
remains rational polynomial parametric. 
This is an important characteristic for a eSG modeling system. If the 
primitives are planes or quadrics and one performs FFD after all the boolean 
operations are perCormed, all intersection curves would be parametric. Of 
course the parametric definition enables rapid cOJn!,>utation of points on the 
surface. Using quadrics and planes for primitives also has the advantage that 
both can be expressed parametrically and implicitly. The implicit definition 
provides a simple point classification test - is the point inside, outside or on 
the surface. Ciassifying a point on a deformed quadric requires one first to 
compute the local (8 ,t, u) coordinates of the point, a process that. will be 
referred to as inversion, and then to substitute the coordinates back into the 
implicit equation. If the implicit equation evaluates to zero, the point is on the 
surface of the solid. By convention, if it evaluates to a negative number, it lies 
inside the volume and iC it evalu~tes to a positive number, it lies outside the 
volume. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
28 
Inversion 
The inversion of parametric curves and surfaces can be done in closed 
form and is discussed in [Sederberg83j. However, a closed form inversion 
equation for a trivariate polynomial does not generally exist. In other words, it 
is not generally possible to express the undeformed coordinates (8, t, u) as 
rational polynomial functions of the deformed coordinates (x,y,z). This forces 
an iterative solution to the inversion problem, and principally two methods can 
be used: subdivision and a numerical solution such as Newton's method. 
The subdivision method is an extension of the subdivision technique 
used for curves and surfaces expiained in lBChm84j. In the case of a curve, 
two new sets of control points specify two contiguous pieces of the curve. The 
control points define a convex hull that encases the curve. If a point is not 
inside the convex hull, then it is guaranteed not to lie on that segment or the 
curve. After repeated subdivisions, a curve segment can be approximated by a 
line segment and the parameter value of the poi!!t can be closely approximated 
using linea.r interpola.tion. Surfaces are subdivided in two p~rameter directions 
and the classification of a point on the surface is similar to the method used 
for curves. A surface is subdivided until it approximates a plane, at which 
time the parameters of the point can be comput~c! hy solving a quadratic 
equation or by further subdivision. 
Extending this method to the deformation volume~, 5uhdivision of the 
lattice is performed in all three parameter directions. A point is potentially in 
the volume if it is contained within the convex hull of the control points. 
Repetition of the subdivision process generates control point lattices covering 
successively finer regions. Eventually, a region of acceptably small volume is 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
27 
found which contains the point, and its (8,t, 11) coordinates are bounded by the 
(8, t, 11) range of the region. 
The inversion problem can be solved numerically by evaluating a system 
of three trivariate polynom,als: x = f t( 8,t, 11), Y = f 2( 8,t, 'U) and z = f a( 8,t, 11). 
From the local coordinate system, one can use the fact that a point is inside 
the deformation region ir 8, t and 11 all are between 0 and 1. Newton's 
method will converge quadratically provided that a sufficiently accurate 
starting value is known and the inverse of the Jacohia.n matrix at the starting 
point exists [Burden81]. The subdivision process may be a good method for 
generating a initial appcoximation. A similar approach is taken in [Casale84]. 
Figure 15 - Piecewise Continuous FFDs 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Continuity Control 
In discussing continuity across the boundary of a deformation, it is 
necessary first to examine the application of two or more FFDs in a piecewise 
manner. The continuity of a local deformation as in figure 12 will be a special 
case of this discussion. 
Consider continuity in terms of a local surface parameterizatinn whp.re 
V 
and 
w 
denote 
local 
parameter: 
and 
a 
surface 
is 
defined 
by 
(s,t,u) = (s(v,w),t(v,w),u(v,w)). Let two adjacent FFDs X 1(SI,t.,ul) and 
X 2(s2,t2,U2) share a common boundary 81 = 82 = o. Using the chain rule, the 
first derivatives oi the deformed surface are found: 
axj(v,w) 
av 
oXj(v,w) 
ow 
aXj 
8s 
aXj 
lJt 
aXj au 
= -_.- + -_.- + --.-
as 
ov 
at 
av 
au 
av 
oXj 
as 
oXj 
at 
aXj 
au 
= -_.- + --.- + --.-
as 
aw 
at 
ow 
au aw· 
as 
at 
au 
as 
at 
au 
. 
Note that av' av' av ' ow' aw and aware all mdependent of the 
deformation. Now sufficient conditions for first degree or derivative continuity 
are that 
aX!(O,t,u) 
oXz(O,t,u) 
8X1(O,t, u) 8X2(O,t, u) 
as 
as 
au 
au 
These conditions, and those for higher degree continuity, are straightforward 
extensions of the continuity conditions required for Bezier curves and tensor 
product Bezier surfaces. A discussion of these conditions can be found in 
!BOhm84j. 
Figure 15 illustrates two adjacent FFDs. The cylinder in the upper 
right corner shows the control points in their undeformcd position. Denoting 
28 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
29 
Figure 16 - Local Gil: Control Points 
. "  
,--~--
-~----
... 
" '. 
. 
,. -.' 
. 
. 
, 
. 
~ 
:~ ,~~' :;::-~~ 
-
- -::-'=:---~~-" --::-=->;:: .. ~ .' 
_. :~.-
. 
• 
I 
• ~---------- -- --.. '----- --- --
---~-~":"_~..;:":=- --.-
- ~ 
••• 
~-
~_ 
-
1-
• 
Figure 17 - G~l, GU, Gi and G? Local Derormations 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
30 
continuity by Gk , where k specifies continuity to the kth degree, the cross 
boundary continuity between the two deformations in the upper left is GO. 
The orientation of the two FFDs in the bottom example results in Gl 
continuity across the common boundary. 
Local deformations require the same constraints if one imagines 
undeformed neighboring lattices. Continuity can be maintained across each 
face of the local deformation by imposing these conditions for each face that 
the surface intersects. Figures 16 and 17 illustrate an example of a local FFD 
where only one face intersects the surface. It can be seen that sufficient 
conditions for a ak local deformation aTI;' to not move the controls points on 
the k planes adjacent to the interface plane. 
One can also apply FFDs in a hierarchical manner. This enables 
substantial ilexibility for creating and refining both locally and globally with a 
series of deformations. 
Examples 
An interesting note on FFDs is that there exists a family of volume 
preserving deformations. Figure 18 illustrates one such example where the 
deformed can still holds exactly 12 ounces. 
An. explanation of such 
deformations is found in [Sederberg86b1. 
Figures 19-21 show how three deformations were performed in a 
hierarchical manner to mold a rounded bar into a telephone receiver. The 
rounded bar was created as a degree 2X2X2 piecewise algebraic surface. The 
C 1 deformai:on in figure 19 was applied to both ends of the har foHo'\':d by a 
global FFD as illustrated in figure 20. The final product of figure 21 is an 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
31 
'-_. "r" 
.~. 
. 
"'-.:_ .••. 
!..........o_--
_ 
t~--::-; _ .. ,_ _ 
~ 
. __ 
~ 
_ 
.-0 
. 
. -~--
-. --~ 
-.'-
--; - --
--
\t-" 
Figure i9 - Local FFD 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
32 
Figure 20 - Global FFD 
. 
. 
. . 
~~. 
• 
" ~ 
. ~:" c .' ',_ 
'. 
~- ---
-:'-~-~-.--------'- - -
~---------
.--- ~- -
- -- ~-- -' -- --:-----
.. 
. 
• 
0:" 
• 
-=---
_ 
. -
'. 
-. 
-
, 
____ =t._-____ 
=---__ 
_ __ _ 
.. _ .: 
-r'.,. 
'. 
. 
_ 
-
-.. 
-
Figure 21 - Telepholl~ Receivers 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
33 
-----.--' - - -
--
-. 
j--
--
~ ....: 
.. -
. 
.~--
Figure 22 - Trophy 
. 
.~~ 
.. 
,. 
; 
2> 
. 
.;--
..:.... 
~ -. 
- :,.-
, 
~-.:: 
. -ri' 
-
! 
-.. 
• 
Figure 23 - Deformed and Undeformcd Cans a.nd Bottles 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
34 
implicit solid just like the original bar. (The chord was generated as a volume 
of revolution and a subsequent global FFD.) 
Figures 22 and 23 indicate more uses of FFDs. The handles of figure 22 
were made with a single global deformation applied to a cylinder. And finally, 
a surrealistic image of deformed and undeformed cans and bottles is shown in 
figure 23. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 4 
FREE-FORM DEFORMATION AND SOLID MODELING 
Chapter 1 introduced the fields of surface and solid modeling. It is 
important to understand why these two areas of computer aided geometric 
design h1).ve had difficulties merging and how FFD resolves some of the 
differences between them. 
Solid geometric modeling, as mentioned previously, is interested in 
defining 20 object that ca.n be analyzed as a whole. Curves of intersection 
along with point classification are vital to the geometric analysis. These are 
two of the areas that are most difficult for parametric or free-form surface 
modeling. It has been shown in [Sederberg83j that generally the curve of 
intersection oi two parametric polynomial surfaces is not a 
parametri~ 
polynomial curve. Also, it is usually very expensive to compute that curve of 
intBl"Section. For example, the curve of intersection of two bicubic patches is 
generally of degree 324. By contrast, two quadric surfaces intersect in a curve 
of degree four and, as mentioned, this curve can be expressed parametrically 
(although a square root is required) and easily generated. 
Another problem arises ill representing the topology of intersect.ing 
free-form surface patches. After a patch is intersected by a second surface, it 
may no longer have a four sided topology. It may change to three, five or 
more sides or have a hole in it. 
Of course the major disadvantage of implicitly defined solids is the 
inability to use them to design in a free-form manner .. 
35 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
3& 
h call ba seen, after the presentation of FFDs in chapter 3, ho .... , 
significant this new approach is to these h:ro areas of design. One can take 
virtually any traditional solid modeling scheme and apply a deformation to 
model in a free-form manner. 
The discussioll in the previous chapter 
highlighted how primitives in a eSG environment can be used with FFD. The 
deformed cylinders of figure 22 illustrate how powerful simple quadrics can 
become. One can model with implicit quadrics in a free form manner and still 
effectively satisfy the needs of solid modeling. 
The remainder of this dissertation will discuss applying FFDs to a eSG 
based modeling system. It is suggested in [Atherton83] that effective eSG 
modeling is approached from a "dual solid modeling scenario." There ai-e 
basically two uses of a eSG model: one requiring a very accurate definition for 
manufacturing and one for creation and visualization. The direction taken 
here is to provide efficient and informative imagery of the FFDs in a eSG 
environment. 
CSG Method 
The eSG, or constructive solid geometry, method is based on combining 
primitives by volumetric boolean set operations. Each boolean combination 
forms a new solid. The basic operations of two solids are defined as: 
Union <U) - the volume found in either, 
intersection (n) - the voiume that both have in commOD, 
Difference (-) - the volume of the first not found in the second. 
CSG is based on the principle that if two objects are known t.o be valid 
solids, then their boolean combination is also a valid solid. This is always true 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
37 
if the definition or bool~an operation re modified to mean "regularized" boolean 
operation as defined in IRequichaBOj. 
The eSG representation is an (ordered) binary tree. Terminal nodes, or 
leaves, represent primitives. 
E~~h internal node defines a hoolean set 
operation applied to the left and right nodes, or children, it points to. This 
tree data structure is commonly referred to as the eSG tree. 
The eSG method is powerful in that one c~n logically build complex 
solids from simple primitives. Requicha said in a study of solid modeling 
representations and geometric modeling systems (GMS) IRequicha80j: 
eSG is the only scheme with a. potentially large domain and syntactically 
guaranteed validity. eSG represe:lt.ations also are concise and easy to create. 
These considerations lead to the choice of eSG as one of the representation 
schemes used internally by the GMS, and of a CSG-based input language as 
the main facility for creating new geometry. 
Figure 24 illustrates n, simple example. Four primitives are shown on 
the bottom row. Let A be the red block, B be the orange cylinder, C the 
yellow~ cylinder and D the ;vhite block. The second fe,\' shows the unicl:l of A 
and B and the union of C and D. The top image illustrates (ALJB) -
(CLJD). (The (CLJD) solid is rotated before the ciiiierence is made.) Figur,:; 
25 shows another way of representing the eSG tree of figure 24. (Note that 
each internal or boolean node requires two children, but the tree does not have 
to be full at \!ad.i. level.) 
Transformations such as scaling, rotation and translation can be applied 
at any node of the eSG tree. These transformations will affect the node and 
all its children. The new FFD capability cr.n also be o.pplied in a similar 
manner. Applying a transformation or deformation at the top or head node 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
38 
Figure 24 - CSG Model 
Figure 25 - CSG Tree 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
30 
would be the same as applying it to each individual primitive of the tree. Of 
course one would have to be aware of other deformations and transrormations 
applied throughout the tree and apply them in the correct order. This ability 
to apply FFDs anywhere on the eSG tree adds flexibility in the creation of a 
solid. 
The next rew chapters will discuss development and implementation of 
the eSG system with the FFD capability. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 5 
DATA STRUCTURES AND PRIMITIVE PROCESSING 
The system is wJ~aten in FORTRAN 77 so that it can be incorporated 
into future enhancements of MOVIE.BYU. Therefore, recursion has been 
simulated for tree traversal and the CSG tree is defined as an array of node 
information. 
CSG Node Definition 
The csc tree is initially defined with a pointer to the head node. Each 
boolean node contains the boolean operator, pointers to its left and right 
children and pointers to the der01'mations and transrormations applied at that 
node. 
A primitive node contains the primitive type, color and shading 
inCormation and pointers to the deformations and transrormations specifically 
applied to the primitive" Table 1 illust.rat.es a. boolean node with I being the 
location oC the node in the array. A primitive node is shown in table 2 with J 
as the array location. 
1 
Not Used 
/+1 
Operator: 1 Union: 2 Diff; 3 Inter. 
1+2 
Pointer to Left Child 
1+9 
Pointer to Ril!:ht Child 
1+.4 
Number or FFDs and Transformations (n) 
1+5 
FFD (nelrative) or Transrormation (positive) 
1+6 
... 
I+,t+n 
Last FFD or Transrormation 
Table 1 - Boolean Node 
,(0 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
J 
Type: -1 Sphere' -2 CYlinder' -3 Block 
J+l 
Color Number 
J~~ 
Shadinl!' Flag: 0 Smooth' 1 Uniform 
-
J+9 
Number of FFDs and Transformations (n) 
J+J 
.FFD {negative) or Transformation {~ositivE:) 
J+5 
... 
J+9+n 
Last FFD or Transformation 
Table 2 - Primitive Node 
As long as it defines a syntactically correct tree, any primitive or 
boolean node can be pointed to as many times as necessary, thus simplifying a 
large tree array. 
Primitive Definition 
For the purpose of shaded imagery, the primitives are represented as 
polygon surfaces. This makes available many techniques developed for the 
display of polygons found in INewman791 and [Foley82] and the scan line 
algorithm for eSG in [Atherton83J. 
The challenge is to polygonalize a 
primitive that could be defined, with the FFD capability, in many 
unpredict.able ways. Clearly an adaptive subdivision technique is required. 
To decrease subdivision and display time, polygon vertex information is 
!'~p!'esented in three systems: base coordinates for slJbdivision, viewing 
coordinates for normal and color calculation and screen coordinates for hidden 
::iuriace removal. Table 3 lists the information fli! ea~h vertex stored in two 
arrays: RNODES and NODE. NODE contains pointers to all the polygons 
that share that vertex. There are a ma.ximum of eight polygons that ca!) share 
one vertex and there are eight locations available. This is used for ~vt'r:tging 
normals for smooth shading and for calculating color information. The color is 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
42 
a packed RGB (red, green and blue) value appropriate for the hidden surface 
algorithm. 
RNODES 
1 
X Viewing Coordinate 
!J 
y 
" 
" 
9 
Z 
" 
" 
4 
X Normal Coordinate 
5 
y 
" 
" 
6 
Z 
" 
" 
7 
X Base Coordinate 
8 
y 
" 
" 
9 
Z " 
" 
NODE 
1 
Number of Polygons Sharing Vertex 
!J 
Pointer to Polygon Sharing Vertex 
... 
9 
... 
10 
Color 
11 
X Screen Coordinate 
1!J 
y 
" 
" 
19 
Z 
" 
" 
Table 3 - Vertex Arrays 
Adaptive subdivision reqUlres that the primitives be tessellated into 
triangles. Table 4 lists the information for each triangle stored in two al1~ys: 
ITRIAR and TRIND. The first three locations in ITRIAR give the triangle 
connectivity~ in a counterclockwise order, and the next three point to the 
triangle's neighbors. It is important to preserve sharp edg~s in primitives such 
as cubes. Location 7 indicat~s if a side of a triangle lies on such a~ edge. 
Again the color here is a packed RGB value used for uniform polygon shading. 
The triangle normals in TRIND can be used directly to calculate the color 
(uniform shading) or be averaged (smooth shading). These normals are also 
used, as are the change in X and Y scr~en coordinates stored in ITRiAR~ for 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
43 
adaptive subdivision. 
ITR;tAR 
1 
Pointer to Vertex 
2 
" 
" 
3 
" 
" 
4 
Pointer to Neighbor 
,r; 
" 
" 
6 
" 
" 
7 
Edge Flag 
8 
Color 
9 
Change in X Screen Coord. I 
10 
Change in Y Screen Coord. 
I 
TRIND 
1 
X Normal Component 
2 
Y 
" 
" 
9 
Z " 
" 
Table 4 - Triangle Arrays 
There are other popular methods for storing polygonal data such as the 
winged-edge data structure described in [Baumgart72j and [Braid80j, but for 
the use of scan line and adaptive subdivision algorithms, this information is 
sufficient. 
There are three types of primitives: spheres, cylinders and blocks. Each 
type has a local coordinate system. When a user first instances a primitive, its 
position and scale are defined by this local system. The sphere is centered at 
the origin with a unit radius. The cylInder has !!. r~dius of 1 and a length of 2. 
It is centered at the origin with its axis aiong the Y axis. The block 15 
centered at the origin with height, width and thickness all equal to 2. 
All three primitive types have the same bounding box and the Xo. S, T 
and U vectors for the box can be chosen ior global deformation as (-1, -1, -1), 
(1,-1,-1), (-I,l,-I).and (-1,-1,1). 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
As can be seen from figure 29 in chapter 6, the sphere and the cylinder 
are initially polygonalized as a cube. As each triangle is subdivided, the newly 
created vertices are mapped to the surface of the respective primitive. 
Other primitives can easHy be added. (It is surprising how far spheres, 
cylinders and blocks can go with the deformation capability.) To define a 
primitive that can be easily subdivided requires creating a base primitive with 
2. similar topology. This topology would be one in which after converting to 
primitive coordinates, there would exist a fairly even distribution or polygons 
over the surface of the primitive. For example, a pyramid would be a good 
base for a cone. A rectangular shaped block with a rectangular sectioned hole 
might make a good torus base. New primitives like these can be added by 
simply coding up a primitive defining routine and an initial primitive 
definition. The initial definition consists of enough information to start the 
subdivision process, including a minimum number of nodlO's and triangles. 
(Examples and a complete description or the initial conditions are given in the 
appenrlix.) 
Primitive Processing 
The csa model is generated by traversing the tree and processing each 
primitive. During traversal, a stack keeps track of the boolean nodes visited. 
'When a primitive is discovered, the stack contains all the primitive's parents. 
From this stack, an ordered iist is generated of all the deformations and 
transformations that affect the primitive. The transrormation to convert to 
viewing coordinates is added at the end of the list. The transrormations are 
4X4 matrices and where possible, are concatenated together. Unfortunately, 
all the deformations and transformations cannot he combined. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
45 
The initial primitive information is loaded into the vertex and triangle 
arrays. The primitive is then processed according to these steps: 
1) Subdivide the primitive a minimum number of times, 
2) Pass all nodes through FFDs and concatenated transformations, 
3) Convert all nodes to screen space 
(orthogonal o. perspective projertion); 
4) Find all triangle normals, 
5) Find ail change in X and Y screen space, 
6) Perform adaptive s1Jbdivision, 
7) Calculate color for each node (smooth) or triangle (uniform), 
8) Send all polygons to the hidden surface processor. 
The next chapter details steps 1 and 6. The last st,ep takes the edges or 
each polygon and loads them into an in:l.ctive edge iist. 'When all primitives 
have been processed, a csa key is formed from the tree to direct the 
determination or which primitives are visible. And finally, the hidden surface 
algorithm is invoked to process all the edges. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 6 
ADAPTIVE SUBDMSION 
Adaptive subdivision techniques have been explored by many who 
render curved surfaces [Nyddeger72], [Catmu1l74j, [Clark79j, [Lane79j and 
[Lane80j. The process is to subdivide the surface patch until it is within a 
tolerance oi being geometrically flat or it is the size of a single picture element. 
The subdivision is performed in R2 parameter space and the surface points are 
generated in the mapping to R3 Cartesian space. The approach taken here is 
to subdivide in R3 space since the FFD function is an R3 to R3 mapping. The 
faces of the base cube are parametric and therefore easy to subdivide. A 
function for each primitive converts these to primitive coordinates which are 
then transformed and/or deformed. 
Algorithms that adaptively subdivide on the basis of the local curvature 
surface tan experience continuity problems. The problem arises in 
subdividing one edge and not its shared edge neighbor. This causes a hole or 
crack in the surface and is illustrat.ed by the dark region in figure 26. Since the 
cracks are very small in parametric surface subdivision, some ignore the 
problem \Lane79). 
[Nyddeger72j discusses the creation of filler polygons. 
Others have forced the shared edges t.o remain planar [Clark79j. This problem 
is critical in this application since each vertex can be deformed after the 
subdivision which may result in very noticeable hoi.es. 
A solution is to require each polygon to contain all the vertices that are 
on any of its edges. For example, this would require the left poiygon in figure 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
47 
Figure 26 - Separation Resulting from Subdivision 
26 to be made up or five vertices. This approach introduces non-planar 
"polygons" which is acceptable ror a scan line display algorithm such as 
discllssed in INaySl]. However) there is added complexity in maintaining a list 
or all possible vertices ror a single polygon. For example, one large polygon 
that is nearly planar may have a. sizable Dumber of neighbors. The large 
polygon must be defined by all the vertices it shares with its neighbors to 
avoid the occurrences of holes. The solution taken here uses only triangles. 
Subdividing Tria.ngles 
Each triangle always has three triangle neighbors, one for each edge. 
To ensure a fairly uniform size for a subdivided triangle, each triangle has a 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
48 
side designated to be subdivided next. Let this edge be called the long side 
(even though this has nothing to do with its size relative to the other sides). 
When a triangle is subdivided, the two sides that were not divided become the 
long sides of the two new triangles that are formed. This keeps triangles from 
taking on unmanageable shapes after repeated subdivisions. 
In the data structure, the edge that is form~d by the vertices pointed to 
in the second and third locations in ITRIAR designate the long side. The 
pointer to the second triangle neighbor in this array is the triangle neighbor to 
the long side. 
When a triangle is divided, a new vertex is created and added to the 
vertex arrays. Two new triangles are formed and one is added to the triangle 
arrays while t.he other replaces the triangle that was subdivided. 
The 
subdivided triangle's neighbor to the long side must also be subdivided. If this 
neighbor shares the same long side edge, then both are subdivided and all four 
new triangles share the new vertex. Otherwise, the algorithm recursively 
subdivides until it finds two triangles that share the same long side. The 
algorithm basically outlines as: 
RECSUB(~~ 
J = fs long side neighbor 
If I and J do not share the same lona side 
then RECSUB( 1) 
• 
SUBDIVIDE{I,1) 
RECSUB is the recursive routine for triangle I and SUBDIVIDE subdivides 
triangles I and J. 
A simple example is illustrated in figure 27. Figure 27a shows triangles 
A, B, C, D and E with their respective long sides indicated by .the dot t ed 
lines. Triangle A is to be subdivided. Figure 27b illustrates the search path 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Figure 27 - Recursive Subdivision 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
60 
and tha.t the recursion terminates by finding triangles D and E with the same 
long side. In figure 27c through 27f, triangles E through A are subdivided. 
The new long sides are also indicated. 
Usually, the initial definition of the long side is arbitrary. The original 
information for each primitive using the base cube is the corner vertices of the 
cube and two triangles for each face. The diagonal on each face is designated 
as the long side for the two triangles on the respective face. Initially, it is 
easiest to assign pairs of triangles the same long side. This assures that the 
recursion will terminate. Figure 28 illustrates a set of triangles in which the 
recursion will not terminate. The long sides are indicated by the previous 
convention. This initial configuration should be avoided. 
Figure 28· Exception for the Recursion Algorithm 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
61 
Block Primitive 
Sphere Primitive 
Cylinder Primitive 
Figure 29A - 0, 1 and 2 Uniform Subdivisions 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
62 
Block Primitive 
Sphere Primitive 
if:T ~i":~-f.;i.; ,7... _ - " 
it< '~C-
CIJ:lX~~~ 
x 
l,.lX~ 
x 
\ 
~~\ X >( "V/;MI/l 
~ , 
Cylinder Primitive 
Figure 2gB - 4 and 7 Uniform Subdivisions 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
63 
The numbering of the initial twdve triangles is such that each face on 
the cube has one of the first six triangles. This makes it easy to create a 
uniform subdivision throughout the cube. A loop subdividing the first half of 
the triangles will divide all the triangle pairs without invoking recursion. 
Figure 29 shows uniform subdivisions of 0, 1, 2, 4 and 7 for each of the three 
primitives. 
Adaptive Subdivision Algorithm 
The adaptive subdivision is controlled by two criteria: screen space and 
curvature. The user sets the largest change in X or Y screen space and a 
maximum angle of curvature for e:.~h ro1ygon of the primitive. If a polygon is 
au,· laigei than the screen parameter or if the angle between a triangle's 
normal and any of its neighbor's normal is greater than the user specified 
value, it is subdivided. Sometimes a minimum number of uniform subdivisions 
is required. For example, a deformation may be localized to a single polygon 
and no vertices would be deformed resulting in no detection of curvature. 
Therefore, step 1 of the primitive processing explained in the previous chapter 
calls for the minimum subdivisions. 
The adapiive subdivision aigorithm begins by placing all triangles of the 
primitive that have been defined initially and are created from the uniform 
subdivision on a stack. 
The following outlines the adaptive subdivision 
algorithm. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Pop triangle I off the stack 
Do while there are more triangles on the stack 
Test Ion the subdivision criteria 
Do while I doesn't pass the criteria 
Subdivide I 
For all new vertices 
Pass through FFDs and transformations 
Convert to screen coordinates 
For ali new and modified triangles 
Find normal 
54 
Find change in X and Y screen coordinates 
Push all new triangles on the stack 
{End do while I doesn$t pass} 
{End do while there are more} 
The algorithm only updates inrormation for the new vertices and the 
new and modified triangles. Even though the new triangles formed by 
subdividing I are pushed on the stack, I is never pushed back on; it is 
subdivided until it passes the screen and normal criteria. 
Figures 30 and 31 illustrat9 a biock with a "humped" shaped 
<ieformation applied to the quadrant of the top face closest to the viewer. The 
maximum angle between polygon normals was specified as 10
0 for figure 30 
and 5 0 for figure 31. Notice how the triangles dissipate even across the 
undeforlUEd side walls. 
The edge flag of the ITRIAR array prevents the testing of the 
curvature condition across a primitive discontinuity. Multiple vertices are 
actually defined along such a discontinuity. This is necessary to obtain the 
correct shading. 
The initial edge flag values along with all the initial 
information for each primitive type is listed in the appendix. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
55 
Figure 30 - Normal Criterion Set at 10 0 
Figure 31 -Normal Criterion Set at 50 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter '1 
BIDDEN SURF ACE REMOVAL 
There are basically three ways to generate shaded surface images from a 
CSG model: 
1. Construct a boundary surface model irom the volumetric boolean 
operations specified in the CSG tree and apply a hidden surface removal 
algorithm on the resulting surface m0del. [Voe!cker77] discusses this 
approach. 
2. Fire a ray through each picture element and Cor each ray, create a 
list of all ray intersections with the CSG primitives converted into 
screen space. To determine the visibility at a picture element, classify 
the ray-solid intersections for each primitive and combine classifications 
according to the CSG tree. The complete description of this method is 
found in [Roth82J. 
3. Perform a scan line hidden surface algorithm for all the primitives 
and use the ray firing technique at the ends of a scan line span to 
determine the visible segment. Atherton was the first to explore this 
technique [Atherton83]. 
The scan line approach was shown in lAtherton83] to be an order of magnitude 
faster than using the ray firing technique for each picture element. The 
discussion of this scan line method is preceded by an overview of the 
50 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
57 
traditional scan line algorithm. 
Scan I .. ine Algorithm 
Instead of considering the entire image at once, scan line algorithms 
solve the hidden surface problem one scan line at a time. Processed along each 
scan line are polygon segments: the intersection of a polygon and the 
horizontal plane of the scan line. The hidden suriace problem is then deciding 
which segments are visible. There are four basic steps to the algorithm: 
1. Sort all polygon edges in Y so that only those edges interseciing the 
current scan line are examined. 
2. Sort all segments in X across each scan line 
3. Divide the scan line into smaller sections called sample spans, within 
which the same segment is visible. 
4. Through a Z search, determine the visible segment in the sample 
span. 
The Y sort is usually a bucket sort and the X sort is most efficient with 
a bubble sort when one takes advantage of scan line coherence. Coherence 
means that the edges that intersect at one scan line are likely to intersect the 
next scan line. Thus, the initial X sort list is the sorted segments of the 
previous scan line. Processing then begins by updating the list with edges that 
have terminated and/or new ones that begin on the scan line. 
The creation of sample spans takes advantage of point-to-point 
coherence along a scan line. The major difference between scan line algorithms 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
58 
is how thes8 sample spans are defined. The most straightCorward method is to 
set span limits as the beginning of one segment and the beginning of the next 
segment in the X sort list [Romney70j, [Bouknight70j. Ir there are penetrating 
polygons, the span has to subdivided at points of intersection. A more 
"aggressive" selection of a longer span is made by Watkins [Watkins70j. In 
t.his implementation, the left end of the sample ~pan is fixed and the right end 
"floats" until the span represented is simple enough to compute directly which 
segment is visible. The "floating" span is used because a min-max test 
performed in the Z direction is faster than havjng to sort every segment in a 
span. A fine comparison of the different scan line hidden surface algorithms is 
found in [Sutherland74]. 
CSG SCI m Line Algorithm 
The difference between the CSG scan line algorithm and a typical scan 
line algorithm is that visibility is not based on the closest segment to the 
viewer. The decision of which segment is visible is a function of all the 
segments in a sample span. Therefore, all the segments need to be processed 
together and the traditional span definition is required. After defiiling such a 
span, the algorithm performs the following steps: 
1. Sort all segments in Z at each end of the span 
2. Create in-out lists for all primitives at the ends of the span. If the 
priiiiitive is not in the sampie span, it is designated as empty. 
3. Combine in-out lists according to the CSG tree. 
4. Determine visibility: 
If there is not a vis:ble segment at either end of the span and the 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
59 
same Z segment order exists at each end of the span, 
Output background. 
Else if the same segment is visible at both ends of the span and 
the same nO!1.visible segments are in front of the visible segment 
at both ends, 
Else 
Display segment. 
Find intersection point and process the two new spans 
created by this intersection. 
{End if} 
Creating in-out lists 
Imagine a ray fired in the Z direction at the end of each span. The Z 
sort list contains a list of the n locations where the ray would intersect the 
solid primitives. A binary array called the in-out list is created for each 
primitive at each end or the span to specify whether the imaginary ray is 
inside or outside the primitive in the n -1 ray segments defined by the n 
intersections. The in-out lists indicates whether one is inside or outside a. 
given primitive between two locations in the Z sort list. 
An in-out list is created for all the primitives while processing each 
span. The primitives that are not a part or a given span are designated as 
being completely empty. This is necessary because, even though a primith-e is 
not involved in a span, it may influence one that is as a result of the boolean 
operations of the eSG tree. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Combining in-out lists 
Alter each primitive has an in-out list, the lists are combined as 
directed by the CSG tree. This is done for each end of the span. The 
procedure involves making an in-out list for each one of the boolean nodes of 
the tree. Starting with the primitives, the in-out lists for two left and right 
children are combined to rorm a. new in-out list ror the parent node. Instead of 
recursively traversing the tree ror each span, a key is created specifying the 
sequential order for combining all the lists. This key is cr~ated before the 
hidden surface procedure is invoked. 
z 
I 
I 
I 
J 
D I-
I 
B f---
~ 
I ><-! 
cV~ : 
I 
I 
A t= 
J 
I 
! 
Left 
.. - - - - - •• ---t.r..---'. 
Right •• __ ....... ~---4 
•• -- - --. 
U •• --===O.----'l.r..------e. 
n .-----•• --~.~-----. 
.. - _. --e - - - -- • 
• 
Figure 32 - Example of In-out List Combinations 
(Left Primitive: C,D; Right Primitive A,B) 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Figure 32 illustrates an example. Four segments from two primitives 
that are children of the same parent node, A and B from the right primitive 
and C and D from the leet primitive, cross the sample span shown at the left. 
The right side of figure 32 illustrates the in-out lists for the two primitives for 
the left end of the span and the in-out lists for all possible boolean 
combinations. The dots represent a segment in the Z sort list or, if you use 
the ray analogy, ray intersections in the Z direction. Solid lines indicate being 
inside the primitive between two segments in the Z list while dotted lines 
specify being outside the primitive. 
The solution to the CSG visibility problem is found in the in-out list of 
the head node. The visible segment is the one in the Z list that starts the first 
solid region in the in-out list of the head node. If, for example! the CSG tree 
of figure 32 was made up of only one boolean node, the visible segment for the 
left end of the span with thp. union operator would be segment A. If the 
operator was intersection, segment C would be vi.sible, and if it was a 
difference operator, segment B would be visible. 
Combining the lists is simply boolean algebra, but instead of the' usual 
complement operator, difference is used. These rules are specified in table 5. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
62 
_., 
~-
Operator 
Left 
Rie:ht 
Result 
U 
in 
In 
in 
in 
out 
in 
out 
in 
in 
out 
out 
out 
n 
in 
in 
in 
in 
out 
out 
out 
in 
out 
out 
out 
out 
-
in 
in 
out 
in 
out 
in 
out 
in 
out 
out 
out 
out 
Table 5 - Boolean Combin&.tion Rules 
The most efficient way to implement the ~ombination of each element in the 
in-out list is to look into a table for the correct result as specified by the left 
and right classification and the operator. 
It is also worthwhile when combining lists to take advantage of the 
condition when either the left or right in-out list is empty. This eliminates the 
need of evaluating each individual entry in the two lists to be combined. 
Table 6 lists all the possible conditions and the result if one of the lists are 
empty. Of course, if both are empty, the result, is also an empty list. 
Onerator 
EmDtv side 
R(,~lJ It 
U 
left 
all right 
right 
all left 
n 
either 
empty 
-
left 
empty 
right 
alllert 
Table 6 - Simplifications for In-out List Combinations 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Determining visibility across a span 
If the same segment is visible at both ends of the span, one is still not 
guaranteed that this segment is visible across the entire span. Nor is one 
assured that the entire span is ba.ckground if no visible segments are detected 
at the ends of the span. Figure 33 and 34 illustrate an example of each of 
t.hese situations. In both figures segments A and B are from primitive 1 and 
C and D are from primitive 2. In figure 33, the boolean operation is (1-2) 
and segment A is found to be visible at both ends of the span. .As shown, 
primitive 2 penetrates primitive 1 requiring the span to be subdivided and 
reevaluated. Tite span of figure 34 has no visible segments at the ends due to 
the intersection oi the two primitives. 
After subdividing the span at 
intersection points, one can clearly see that there are visible segments within 
the span. (The dotted lines indicate new span boundaries and hatching 
highlights the resulting visible segment::!.) 
Visibility is assured if one segment is visibie at both ends of the span 
and none of the other segments in the span cross thai visibie segment. If there 
is a crossing, the point of intersection is calculated. and two new spans are 
defined by the original span boundaries and the intersection point. If no 
segments are 7isible at the ends, one is assured there are no visible segments 
across the span if there are no segment crossings within the span. The span 
must be subdivided if there are crossings. Even though this may appear to 
require a substantial number of intersection calculations, segment intersections 
are relatively rare occurrences. 
When a visible segment is found in a span, it is only wise to output that 
segment when one is assured that it is not visible in the next span. A visibie 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
z 
B ""I -------,.; B 
I 
I 
c 
B ~~---~-~ 
I 
I 
I 
C
l 
A 
-
Figure 33 - Primitive 1 (A; B) -
Primitive 2 (0, D) 
/:B 
, 
I 
I 
A-
Figure 34 - Primitive 1 (A, B) n Primitive 2 (C, D) 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
segment that traverses a number of spans can be saved and sent on to be 
displayed as a continuous segment saving unnecessp..'i'Y output iterations. 
Finding intersecting segments 
It is vital to determine correctly which segments cross within a span. 
The segments that intersect are the ones that do not have the same ordering 
in the Z sort list at the ends of the span. If at least one segment is visible at 
the end of a span, one can simply check the segments that are in front of it on 
each side of the span. If one segment is in front of the visible segment at one 
~nd of the span and not the other, that segment and the visible segment 
intersect. For example, segments C and D are in front 01 A. at only one end of 
the span in figure 33. Therefore, A and C along with A and D intersect 
within the span boundaries. 
When a span is subdivided by an intersection, all the end information 
such as the Z sort list and in-out list does not need to be recalculated. If the 
left subspan is evaluated first, the right end information can be saved on a 
stack and brought back when the right subspan is examined. For the new left 
subspan, the left ~nd information is already active and only the new right end 
span is processed. Coming back to the right subspan and unloading the stored 
information, only the new left end needs evaluation. 
Other implementation considerations 
A number of tolerances are considered during implementation. A 
tolerance is required to decide when the ends of segments are close enough to 
be part of the same span boundary. Another one is necessary to make the 
decision that a span is too small to be evaluated. Once the smallest span has 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
been specified, one must be aware that the Z sort locations have to be made 
slightly inside the ends of the span. These sort locations are called the left 
and right clip points. The clip points must not meet or cross or the visibility 
problem cannot be solved. If a segment is deemed too small and discarded, the 
next visible or nonvisible segment must come back and cover the discarded 
region to prevent any holes. 
It is common for polygons to be coincident in a CSG model. Since the 
Z sort procedure cannot decide which coincidental edge is in front of the other, 
sometimes their Z order is switched at the span boundaries. This may result 
in the algorithm attempting to find the intersection of two segments that are 
para!!e!. After deciding that two segments have the same Z component, the 
solution is to sort the two segments by polygon number or primitive number. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
Chapter 8 
SUMMARY AND FU'1rURE DEVELOPMENTS 
A technique for free-form solid modeling was described representing a 
significant departure from the traditional technology. This FFD, or free-form 
deformation, capability uses trivariate Bernstein polynomials to deform solid 
models in a truly free-form manner. This technique operates in an intuitively 
meaningful manner and is a method for sculpting solid mod(>ls. The sculpture 
metaphor is a ~~rcpriate because a designer becomes like a sculptor in creating 
a solid model. One can apply the deformations locally, globally or in a 
hierarchical manner ::led still maintain desired continuity com;traints. The 
deiormation can be applied to any modeling scheme and t.he direct application 
to qua.drics was accentuated. 
A syst.em was presented incorporating FFD in a eSG, or constructive 
solid geometry modeling environlnent. An adapt.ive subdivision a.lgorit.hm; 
subdividing in R3 space: generates surfaces of deformed primitives. The 
visibility of the pr:mitives as specified by the Loolean combinations of the eSG 
tree is 
resolved 
in 
a scan line hidden surface removal algorithm. 
Implementation techniques for the system were emphasized. 
Figure 35 illustrates an example of the soitware. The eSG tree Cor this 
figure contains fifteen primit.ives, although seven are muitiple instances. Two 
primitive types are used: a cylinder, (or the letters, aiH~ a block. The b<iSe 
block is differenced with the letters and the "waved" block. The letters are 
also intersected with the "waved" blo('k ~nd unioned with 1he base b!o~k. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
88 
- '  
-' 
'-
¥ 
-
• 
-
-___ 
I. 
. . #  
__ 
t 
-
. 
" 
--- - --- --
~ 
. 
-
-
- -
~~-~- - --- ~ -
.. 
. 
~I.-
-
-
___ ~ 
___ -
_' .. _ ~ 
__ '_--- =_ 
Figure 35 - CSG Model with FFD 
Five different deformations are used, one for each of the following: base block, 
"wa"'ed" blo~k, letter S, arch of the letter R (also used for the P) and the foot 
of the R. 
A significant number of polygons are required for images such as tbelSe 
and most of the polygons generated are not displayed. For exampie, the 
"waved" block of figure 35 is defined twice and maybe one fourth of the 
polygons are display. This is a by-product of using the scan line algorithm not 
only for bidden surface removal, but also ior solving the CSG visibility 
problem. Since the majority of computation time is spent in the scan line 
algorithm, a minimum number of polygons should be generated. Aiso, the scan 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
line algorithm requires a high degree of efficiency and optimization. 
Future Developments 
The number of polygons can be reduced by combining triangles that 
share the same long side. Two triangles in this position are e':'planar and do 
not need to be a.nalyzed separately by the scan line aigorithm. 
In some situations, the number of polygons generated for a cylinder can 
be reduced. Due to the triangle and adaptive subdivision techniques, triangles 
are generated longitudinally on the cylindrical shell. If there is no bendlng or 
twisting of the cylinder, thes~ triangles can be replaced by a smaller number of 
lung poly!?:oTl.s. 
Implementing this reduction technique requires that the 
subdivision algorithm have a knowledge of the types of deformations applied to 
the primitive. The decision of which deformations do not. require the complete 
set of triangles is not a trivial one. 
The application oi other coherence techniques may decrease execution 
for hidden surface removal only, applies the fact that the sorted ordering of 
segments alolIg the Z axis tends to be similar Cor neighbor!ng scan lines. 
Ano~"her coherence property is thai segment intersections have nearly the same 
X and Z components for neighboring scan lines. These coherence properties 
are not so easily applied to a esc scan line algorithm since the Z processing 
also soives the eSG visibility probiem. There is a potentiai ior suriace 
intersection at any screen location where primitives overlap. The test for 
polygon intersection must be made at the ends oi the span regardless of the 
results from previous scan lines unless there is only one primitive in the span. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
70 
The volume of a CSG model can be approximated by considering t.he 
area created by the visible and back facing segments in a. scan line sample 
span. Since a scan line has a specific thickness in relation to the model, the 
areas can be converted into volumes and summed to find the totl\l volume of 
the CSG model. The center of mass can be found by calculating the centroids 
of each sample span. 
Calculating the area for a span requires some added complexity in the 
span pro~essing. Normally only the first visible segment as specified in the in-
out list is evaluated for intersections while the area calculation would require 
processing the front and back segment of each solid region of the in-out list. 
Once this is accomplished, the calculation of volume is basicaiiy broken down 
into finding the area of a polygon in the X - Z scan plane. 
An orthogonal projection would be required so that screen space could 
be converted easily back into primitive space. The accuracy of the process 
would be a function of the polygonal approximation of the surface and the 
computational resolution. 
For improved precision, the scan segments may provide good initial 
estimates ior a ray tracing solution to the mass properties problem. 
possible 
approaches 
for 
computing mass 
properties are surveyed in 
[Mortenson85;pp.486-498] 
Finally, algorithms need to be developed for computing intersection 
curves of deformed surfaces, an important special case being plane section 
curves. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
[Alfeld84] 
[Atherton83] 
[Barnhill84] 
[Barr81] 
[Barr84] 
[Baumgart72] 
[Bezier74] 
[Bezier84] 
[Blinn82] 
[BOhm84J 
[Bouknight70] 
[Braid80j 
REFERENCES 
Alfeld, 
P., 
"A Trivariate 
Clough-Tocher 
scheme 
for 
Tetrahedral Data, H MRC Technical Summary Report #2702, 
Mathematics Research Center, University of Wisconsin-
Madison (1984). 
Atherton, P.R., "A Scan Line Hidden Surface Removal 
Procedure for Constructive Solid Geometry," Computer 
Graphics, 17 (July 1983),73-82. 
Barnhill, R.E. 2nd F.F. Little, :'Thre~ and Four- Dimensional 
Surfaces," Rocky Mountain, Journal of Mathematics, 14 
(1984), 77-102. 
Barr, 
A., 
"Superquadrics 
and 
Angle-Preserving 
Transformations," IEEE Computer Graphics, 1 (January 
1981), 11-23. 
Barr, A., "Global and Local Deformations of Solid Primitives," 
Computer Graphics, 18 (July 1984), 21-30. 
Baumgart, B.G., "Winged Edge Polyhedron Representation," 
STAN-CS-320, Dept. of Computer Science, 
Stanford 
University, Palo Alto, CA (1972). 
Bezier, P., "Mathematical and Practical Possibilities of 
UNISURF," 
Computer-Aided 
Geometric 
Design, 
R.E. 
Barnhill, and R.F. Riesenfeld, editors, Academic Press, New 
York: NY {1974}. 
Bezier, P., 
"CAD/CAM: Past, Requirements, 
Trends," 
CAD84, 
Computers in Design Engineering Conference 
Proceedings, J. Wexler, editor (1984), 1-6. 
Blinn, J., "A Generalization of Algebraic Surface Drawing," 
A.CAf Tr!!n~adion8 on Graphics, 1 (July 1982), 235-256. 
BOhm, \"1., G. Farin and J. Kahmann, "A Survey of Curve and 
Surface Methods in CAGD," Computer Aided Geometric 
Dec'gn, 1 (July 1984), 1-60. 
Boukuight, W.J., "A Procedure for Generatiou oi Three-
Din~ensio1.!3.! 
H?Ir-Tone 
Computer 
Graphics 
Representations," Communications of ACM, 13 (September 
1970), 527. 
Braid, I.C., R.C. Hillyard and LA. Stroud, "Stcpv;ise 
Construction of Polyhedra in . Geometric 
Modelling," 
7! 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
[Burden81] 
[Casale85] 
[Catmu1l74] 
\Chiyokura83] 
[Clark79] 
[Coons64] 
[Farouki85] 
\Ferguson64j 
\Foley82J 
IForrest72j 
IGordon74] 
IHawlin 77J 
72 
Mathematical Methods in Computer Graphics and Design, 
K.W. Brodlie editor, Academic Press, London, England 
(1980), 123-141. 
Burden, R.L., J.D. Faires and A.C. Reynolds, Numerical 
Analysis, Second Edition, Prindle, 'Weber and Schmidt, 
Boston, MA (1981) 439-461. 
Casale, M.S. and E.L. Stanton, "An Overview of Analytic 
Solid Modeling," IEEE Computer Graphics, 5 (February 
1985), 45-56. 
Catmull, E.E., "A Subdivision Algorithm for Computer 
Display of Curved Surfaces," Tech. Rep. UTEC-CSc-74-133, 
Dept. of Computer Science, University of Utah, Salt Lake 
City, UT (December 1974). 
Chiyokura., H. and F. Kimura, "Design of Solids with Free-
Form Sl!rfaces," Computer Graphics, 17 (July 1983), 289-
298. 
Clark, J.H., "A Fast Algorithm for Rendering Parametric 
Surfaces," Computer Graphics, 13 (Special Issue, Aug. 1979), 
7-12. 
Coons, S.A., "Surfaces lror Computer Aided Design of Space 
Figuies,H 
tvla.ssachtisetts 
Institute 
or 
Technology, 
Cambridge, MA ESL 9442-M-139 (January 1964). 
Farouki, R.T. and J.K. Hinds, "A Hierarchy of Geometric 
Forms," IEEE Computer Graphics, 5 (May 1985), 51-78. 
Ferguson, J.C., "Muitivariable Curve Interpolation," Journal 
0/ ACM, 11 (1964), 221-228. 
Foley, J.D. and A. Van Dam, Fundamentals of Interactive 
Computer Graphics, First Edition, Addison-Wesley, Reading, 
MA (1982). 
Forrest, A.R., "On Coons and Other Methods for the 
Representation of Curved Surfaces," Computer Graphics and 
Image Processing, 1 (1972), 341-359. 
Gordon, W. and R.E. Riesenfeld, "B-Spline Curves and 
Surfaces." Computer Aided Geometric Design, R.E. Barnhill, 
and R.F. Rip~pnrp.ld, editors, Academic Press, New York, 
NY (1974). 
Hamlin, G. and C.W. Gear, "Raster-Scan Hidden Surface 
Algorithm Techniques," Computer Graphics, 11 (1977), 206~ 
213. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
[Hoffmann85] 
[Jared84] 
IKalay82] 
[Kimura84] 
[L:1DC79] 
ILane80] 
73 
Hoffmann, C. and J. Hopcroft, "Automatic Surface Generation 
in Computer Aided Design," TR 85-661, Dept. of Computer 
Science, Cornell University, Ithaca, NY (January 1985). 
Jared, 
G.E.M., 
"Synthesi!: 
of Volume 
Modelling 
and 
Sculptured Surfaces in BUILD," CAD84, Computers in 
,!)e.~!·gn Engineering Conference Proceedings, J. Wexler, 
editor (1984), 481-495. 
Kalay, Y.E., "Modeling Polyhedral Solids Bounded by Multi-
Curved Parametric Surfaces," ACM IEEE Nineteenth 
Design Automation Conference Proceedings (June 1982), 
501-507. 
Kimura, F., "Geomap-III: Designing Soiids with Free-Form 
Surfaces", IEEE Computer Graphics, 4 (June 1984), 58-72. 
Lane, J.M. and L. Carpenter, "A Generalized Scan Line 
Algorithm for the Computer Display of Parametrically 
Defined 
Surfaces," 
Computer 
Graphics 
and 
Image 
Processing, 11 (1979), 290-297. 
Lane, J.M. and R.F. Riesenfeld, "A Theoretical Development 
for the Computer Generation and Display of Piecewise 
Polynomial 
Surfaces," 
IEEE 
Transactions 
of Pattern 
Analysis and Machine Intelligence, PA.M:i-2 (January 1980), 
35--16. 
!Middieditch85] Middleditch, A.E. and K.H. Sears, "Blend Surfaces for Set 
. 
Theoretic Volume Modelling Systems," Compute; Graphics 
19 (July 1985) 161-170. 
[Moftenson85] 
[Nay8l] 
[Newman79] 
[Nyddeger72j 
[Owen86j 
rJortenson, 
~J.E., Geometric ~~lode!ing, First Edition,. John 
Wiley and Sons, New York, NY (1985). 
Nay, B.J., "A General Purpose Computer Graphics System 
with 
N-Sided 
Element 
Display 
Capability," 
Ph.D. 
Dissertation, Brigham Young University, Provo, UT (H)81). 
Newman, \V.M. and R.F. Sproull, Principles of Interactive 
Computer:Jraphics, Second Edition, McGraw-Hill, New 
York, N i (1979). 
Nyddeger, R., "A Data Minimization Algorithm of Analytical 
Models for Computer Graphics," Masters Thesis, Dept. of 
Computer Science, University of Utah, Salt Lake City, UT 
(1972). 
Owen, J. and A.P. Rockwood, "General Implicit Surfaces in 
Geometric Modeling," in Geometric Modeling, G. Farin, 
editor, SIAM, to appear (H)86). 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
[Requicha80] 
[Requicha82] 
[Requicha83] 
[Ricci73] 
[Riesenfeld83] 
[Rockwood86] 
[Romney70] 
[Roth82] 
[Sabin68] 
[Sarraga84j 
[Sederberg83J 
[Sederberg85] 
74 
RequicLii., AAG., "Representations for Rigid Solids: Theory, 
Methods, and Systems," Computing Surveys 12 (Dec. 1980), 
437-464. 
Requicha, AAG. and H.B. Voelcker, "Solid Modeling: A 
Historical Summary and Contemporary A'3sessment," IEEE 
Computer Graphics 2 (March 1982j, 9-24. 
Requicha, AAG. and H.B. Voelcker, "Solid Modeling: 
Current Status and Research Directions," IEEE Computer 
Graphics 3 (October 1983), 25-37. 
Ricci, A., "A Constructive Geometry for Computer Graphics," 
Computer Jotirnal16 (1973), 157-160. 
Riesenfeld, RF., "A View of Spline-Based Selid ModelHng," 
Proceedings, Autofact V, Detroit, MI (Novembe~ 1983), 2-'75 
- 2-83. 
Rockwood, AP. and J. Owen, "Blending Surraces in Solid 
Modelling," in Geometric Modeling, G. F~ri", editor, SIAM, 
to appear (1986). 
Romney, G.W., "Computer Assisted Assembly and Rendering 
of Solids," TR-4-20, Dept. of Computer Science, University 
of Utah, Salt Lake City, UT (1970). 
Roth, S.D., "Ray Casting for Modeling Solids," Computer 
Graphics and Image Processing, 18 (1982), 109-144. 
Sabin, M.A, "The Use of Potential Surfaces for Numerical 
Geometry," 
British 
Aircraft 
Corporation, 
Weybridge 
VTOjMSj153 (1968). 
Sarraga, R.F. and W.C. Waters, "Free-Form Surfaces in 
GMSolid: Goals and Issues," in Solid Modeling by Computers 
from Theory to Applications, M.S. Pickett and J.W. Boyse, 
editors, Plenum Press {1984} 187-204. 
Sederberg, T.W., "Implicit and Parametric Curves and 
Surfaces for Computer Aided Geometric Design," Ph.D. 
Thesis, Purdue University, West Lafayette, IN (1983). 
Sederberg, T.'vV. "Piecewi.se Algebraic Surface Patches," 
Computer Aided Geometric Deeign, 2 (1985), 53-59. 
[Sederberg86aj Sederbcrg, T.W. and S.R Parry, "Free-form Deformation of 
Polygonal 
Data," 
SIGGRAPH/FRA.NCE 
Conference 
[Sedeberg86bl 
Proceedings (April 1986). 
Sederberg, T.W. and S.R Parry, "Free-Form Deformation of 
Solid Geometric Modeis," to appear in Computer Graphics 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
[Stanton77] 
ISteinberg84] 
ISuthland74] 
IThomas84] 
[Varady84] 
\Voelcker77] 
[Watkins70j 
75 
(August 1986). 
Stanton, E.L., L.M. Crain and T.F. Neu, "A Parametric Cubic 
Modeling System ror General Solids or Composite Material," 
International Journal of Numerical Methods in Engineering, 
11 (1977), 653-670. 
Steinberg, H.A., "A Smooth Surface Based on Biquadratic 
Patches," IEEE Computer Graphics, 4 (September 1984), 
20-23. 
Suthe.land, I.E., R.F. Sproull and R.A. Schumacher, "A 
Characterization or Ten Hidden-Surface Algorithms," ACM 
Computer Surveys 6 (March 1974) 1-55. 
Thomas, S.W., "Modeling Volumes Bounded by B-Spline 
Surfaces," Ph.D. Thesi:J, Dept. or Computer Science, 
University or Utah, Salt Lake City, UT (1984). 
Varady, T. and M.J. Pratt, "Design Techniques ror the 
Definition or Solid Objects with Free-Form Geometry," 
Computer Aided Geomdric Design, 1 (December 1984), 207-
225. 
Voelcker, lLB. and A.A.G. Requicha, "Geometric Modding oi 
Mechanical Parts and Processes," Computer, 10 (December 
1977). 
Watkins, G.S., "A Real-Time Visible Surface Algorithm," 
Tech. Rep. UTEC-CSc-70-101, Dept. of Computer Science, 
University or Utah, Salt Lake City, UT (June 1970). 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
76 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
77 
Initial Primitive De6.nltion 
The dimensions of t,he base cube are the same for all ,;hree prirniHYes: 
sphere, cylinder and block. The initial defin!tion ior each primitive is the 
minimum amount or information necessary for the subdivision process to 
execute. This consists of twelve triangles for a~l three primitives and eight, 
sixteen and twenty-rour vertices for the sphere, eylinder and block 
respectively. 
There are actually only eight unique vertices for all three 
primitives, but the cylinder and block have mUltiple vertices to allow 
discontinuities along some of the edges. 
~6 
~ 
\0 (if/ 
0\ 
/® 
'5 
~/6 
I " 
~I 
\.§) // I 
@j 
-__ 
I 
,/' \ 
~ 
I 
@\ ® ~5 
Figure 36 - Triangle and Vertex Numberling 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
78 
The triangle numbering is identical for all three primitives, but because 
of the multiple vertices, the connectivity and shared vertex information is 
different.. Figure 36 illustrates the triangle and vertex numbering for the 
sphere. The left drawing shows the outer faces while the right drawII;g has 
the front faces removed and is a view from inside the cube. Triangle numbers 
a.re circled to differentiate them from the vertex numbers. The cylinder and 
block also use the same vertex order as illustrated. 
The edge flag indicates which side of the triangle has a discontinuity. 
The first side of a triangle is the edge specified by the first two connectivity 
entries, the second side by the second and third entries and the third side by 
the third and first entries. Flag values one through three refe," to the side that 
has a discontinuity. A flag value of four indicates a discontinuity for both the 
first and third sides. When a triangle is subdivided, the primitive routine must 
correctly update the edge flag for the two new triangles. 
\Vhen a primitive is visited during traversal of the esc tree, the initial 
values of that primitive type are loaded into the triangle and vertex arrays. 
The sphere and cylinder primitive generation routines must calculate the X,Y 
and Z primitive coordinates for each base coordinat.e. 
(The primitive 
coordinates ior the block are initially the same as those of the hase.) 
The following tables indicate the initial values for each of the three 
primitives. This inrormat·ion should also be helpful for defining new primitives. 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
79 
ITRIAR 
_. 
Triande # 
Connectivity 
Neig;hbors 
~~dg;e Flag; 
1 
2,3,1 
3,7,2 
0 
2 
2,1,6 
1,8,3 
0 
3 
2,6,3 
2,9,1 
0 
I 
4 
4,3,8 
7,10,11 
0 
5 
5,1,8 
8,11,12 
0 
6 
7,6,8 
9,12,10 
0 
I 
7 
4,1,3 
11,1,4 
0 
8 
5,6,1 
12,2,5 
0 
I 
9 
7,3,6 
10,3,6 
0 
10 
7,8,3 
6,4,9 
0 
11 
4,8,1 
4,5,7 
0 
12 
586 
5 6,8 
0 
RNODES 
Vertex # 
X,Y,Z Coordinates 
1 
1,-1,1 
2 
1,1,1 
3 
-1,1,1 
4 
-1,-1,1 
5 
1,-1,-1 
6 
1),-1 
7 
-1,1,-1 
8 
-1 -1 -1 
-
I 
NODE -
Vertex # I # Shared 
Triangle # 's 
I 
1 
I 
6 
1,2,5,7,8,11 
2 I 
3 
I 
1,2,3 
3 
6 
1,3,4,7,9,10 
4 
3 
4,7,11 
5 
3 
5,8,12 
6 
6 
2,3,6,8,9,12 
7 
3 
6,9,10 
8 
6 
{.5 6 lO~l1,IZ 
Table 7 - Initial Values for Sphere Primitive 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
80 
ITRIAR 
Triangle * Connectivity 
Neighbors 
Edge Flag 
1 
2,3,1 
3,7,2 
1 
2 
2,1,6 
1,8,3 
3 
3 
10,14 
11,2,9,1 
4 
4 
4,3,8 
7,10,11 
3 
5 
13,9,16 
8,11,12 
4 
6 
7,6,8 
9,12,10 
1 
7 
4,1,3 
11,1,4 
1 
I 
8 
5,6,1 
12,2,5 
3 
9 
I 
15,11,14 
10,3,6 
4 
i 
10 
7,8,3 
6,4,9 
3 
I 
11 
12,16,9 
4,5,7 
4 
12 
5 8,6 
568 
1 
I 
RNODES 
Vertex * X,Y,Z Coordinates 
1,9 
1,-1,1 
2,10 
1,1,1 
3,11 
-1,1,1 
4,12 
-1,-1,1 
5,13 
1,-1,-1 
6,H 
1,1,-1 
7,15 
-1,1,-1 
8.16 
I 
-1.-1,-1 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
81 
NODE 
Vertex # 
# Shared 
Triangle #'s 
1 
4 
1,2,7,8 
2 
2 
1,2 
3 
4 
1,4,7,10 
4 
2 
4,7 
5 
2 
8,12 
6 
4 
2,6,8,12 
7 
2 
6,10 
I 
8 
4 
4,6,10,12 
9 
2 
I 
5,11 
I 
Ie 
1 
3 
I 
11 
2 
3,9 
12 
1 
11 
13 
1 
5 
14 
2 
3,9 
15 
1 
9 
16 
2 
511 
Table 8 - Initial Values for Cylinder Primitive 
ITRIAR 
Trian~le # 
Connectivity 
Neighbors 
Edge Flag 
1 
I 
2,3,1 
3,7,2 I 
4 
Z 
.1'\ 1'\ h 
, 
0 
., 
A 
I 
IV,11,U 
1,0,0 
'i-
I 
3 
18,14,11 
2,9,1 
4 
4 
I 
''''~1R 
7~10,1l 
4 
_4!,' .... V'l.'l 
5 
21,17,24 
8,11,12 
4 
6 
15,22,8 
9,12,10 
J 
7 
4,1,3 
11,1,4 
4 
8 
5,6,9 
12,2,5 
4 
Q 
7,11,14 
10,3,6 
4 
10 
23,16,19 
6,4,9 
4 
11 
20,24,17 
4,5,7 
4 
12 
13,"-822 
5 6,8 
4 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
82 
RNODES 
VE;!tex # 
X,Y Z Coordinates 
1,9,17 
1,-1,1 
2,10,18 
1,1,1 
3,11,19 
-1,1,1 
4,12,20 
-1,-1,1 
5,13,21 
1,-1,-1 
6,14,22 
1,1,-1 
7,15,23 
-1,1,-1 
816.24 
-1 -1,-1 
NOD_E 
Vertex # 
# Shared 
Triangle # 's 
1 
2 
1,7 
2 
1 
1 
3 
2 
1,7 
4 
1 
7 
5 
1 
8 
6 
2 
2,8 
7 
1 
9 
8 
2 
6,12 
9 
2 
2,8 
10 
1 
2 
11 
2 
3,9 
12 
1 
4 
13 
1 
12 
14 
2 
3,9 
15 
1 
6 
16 
2 
4,10 
17 
2 
5,11 
18 
1 
3 
19 
2 
4,10 
20 
1 
11 
21 
1 
5 
22 
2 
6,12 
23 
. 
10 
24 
2 
511 
Table 9 - Initial Values for Block Primitive 

Reproduced with permission of the copyright owner.  Further reproduction prohibited without permission.
FREB-FORM DEFORMATIONS IN A 
CONSTRUCTIVE SOLID GEOMETRY MODELING SYSTEM 
Scott R. Parry 
Department of Civil Engineering 
Ph.D. Degree, April 1986 
ABSTRACT 
Research in computer aided geometric design of free-form surfaces 
has provided elegant modeling techniques. However, there has been limited 
development of free-form design methods for solid geometric modeling. 
Most approaches have attempted to impose (,Il!'r;;nt free-form surface 
technology on solid modeling. This dissertation examines a new approach. 
This new technique proceeds by deforming solid geometric models in a free-
form manner. This approach can be used with any existing solid modeling 
scheme such as constructive solid geometry or boundary representation. it 
can deform surface primitives of any type or degree such as planes, 
quadrics, parametric surface patches or implicitly defined surfaces. The 
deformation can be applied either globally or locally and can impose any 
desired degree of derivative continuity. The scheme is based on t!'ivariate 
Bernstein polynomials. 
The deformation technique functions well in a constructive solid 
geometry modeling system. Implementation of such a system with specific 
design approaches are presented: primarily the polygonalization of deformed 
surfaces using adaptive subdivision and display by the use of a scan line 
hidden surface removal algorithm. 
COMMITTEE APPROVAL: 
Steven E. Ben dey ,Co ml 
! 
\ 
• 
r1,i."_ 
C: .1... 1-\. I' \'IT.., .............. _~.J..... 
-"'--r--r-
Heri~~. Christiansen, Depann.",nt Chairman 

