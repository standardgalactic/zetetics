Concepts of Proof in Mathematics, Philosophy, and Computer Science

Ontos Mathematical Logic
Edited by 
Wolfram Pohlers, Thomas Scanlon,  
Ernest Schimmerling, Ralf Schindler,  
Helmut Schwichtenberg
Volume 6

Concepts of Proof 
in Mathematics, 
Philosophy, and 
Computer Science
Edited by 
Dieter Probst and Peter Schuster

ISBN 978-1-5015-1080-9
e-ISBN (PDF) 978-1-5015-0262-0
e-ISBN (EPUB) 978-1-5015-0264-4
ISSN 2198-2341
Library of Congress Cataloging-in-Publication Data
A CIP catalog record for this book has been applied for at the Library of Congress.
Bibliographic information published by the Deutsche Nationalbibliothek
The Deutsche Nationalbibliothek lists this publication in the Deutsche Nationalbibliografie; 
detailed bibliographic data are available on the Internet at http://dnb.dnb.de.
© 2016 Walter de Gruyter GmbH, Berlin/Boston
Printing: CPI books GmbH, Leck 
♾ Printed on acid-free paper
Printed in Germany
www.degruyter.com

Preface
The Humboldt-Kolleg “Proof” held in Bern, Switzerland, from 9th to 13th Septem-
ber 2013 was a try to give due consideration to the depth and breadth of the
time-honoured concept of proof, by gathering leading scholars from mathemat-
ics, informatics and philosophy whose studies are centered at the concept of
proof. The present volume is an attempt to represent many of their approaches in
print, which can brieﬂy be summarized as follows.
In “Herbrand Conﬂuence for First-Order Proofs with Π2-Cuts” Bahareh Af-
shari, Stefan Hetzl and Graham E. Leigh assign to each ﬁrst-order proof with cuts
of complexity at most Π2 a well-behaved formal grammar of limited size; all nor-
mal forms obtained by non-erasing cut reductions result in the same Herbrand
expansion.
“Proof-Oriented Categorical Semantics” is Marco Benini’s alternative inter-
pretation of the entity of which the ﬁrst-order proposition-as-types correspon-
dence and the associated type systems are equivalent but diﬀerent presentations
in distinct categories; his framework embraces standard ﬁrst-order categorical se-
mantics.
In “Logic for Gray-Code Computation” Ulrich Berger, Kenji Miyamoto, Helmut
Schwichtenberg and Hideki Tsuiki study real number computation with Gray code
from a constructive angle, to extract algorithms from proofs with inductive and
coinductive deﬁnitions; their case studies are formalized in the proof assistant
Minlog.
Douglas S. Bridges in “The Continuum Hypothesis Implies Excluded Middle”
shows within the framework of Bishop-style constructive mathematics that the
Continuum Hypothesis resembles the Axiom of Choice also inasmuch as it implies
the Law of Excluded Middle, and discusses a more explicit Brouwerian counterex-
ample.
“Theories of Proof-Theoretic Strength ψ(ΓΩ+1)” by Ulrik Buchholtz, Gerhard
Jäger and Thomas Strahm is about a range of theories with proof-theoretic ordinal
ψ(ΓΩ+1); it is not only that this ordinal parallels the one of predicative analysis,
Γ0, but also that some of those theories are parallel to classical theories of strength
Γ0.
The highlight of Thierry Coquand and Henri Lombardi’s “Some Remarks
about Normal Rings” is a constructive proof that if a commutative ring R is nor-
mal, then so is the polynomial ring R[X]; this is based on a special technique to
replace the use of minimal primes by explicit localizations in a suitable tree.
In “On Sets of Premises” Kosta Došen sheds light from categorial proof theory
on the phenomenon that when collecting premises into (multi)sets rather than

VI
|
Preface
sequences one might have to face the unwanted consequence that any two de-
ductions with the same premises and the same conclusions would be identiﬁed.
Hajime Ishihara and Takako Nemoto in “Non-Deterministic Inductive Deﬁ-
nitions and Fullness” prove that a special form of non-deterministic inductive
deﬁnition is tantamount to the principle of fullness characteristic of constructive
Zermelo–Fraenkel set theory as a constructive version of the power set axiom.
In “Cyclic Proofs for Linear Temporal Logic” Ioannis Kokkinis and Thomas
Studer establish weakening for annotated sequents by purely syntactical meth-
ods, and thus solve an open problem that Brünnler and Lange have brought up in
the proof theory of temporal logic.
The main achievement of Roman Kuznets’s paper “Craig Interpolation via Hy-
persequents” is a novel constructive method of proving the Craig interpolation
property based on cut-free hypersequent calculi; he tests the method by verifying
that property for the modal logic S5.
With “A General View on Normal Form Theorems for Łukasiewicz logic with
product” Seraﬁna Lapenta and Ioana Leuştean explore the connection between
the Pierce–Birkhoﬀconjecture and Łukasiewicz logic with product, the models of
which reﬂect an algebraic hierarchy of lattice-ordered structures, from groups to
algebras.
In Maria Emilia Maietti and Giuseppe Rosolini’s “Relating Quotient Comple-
tions via Categorical Logic” the authors show that the elementary quotient com-
pletion of an elementary existential doctrine coincides with an exact completion
when a choice rule holds in the starting existential elementary doctrine.
Roman Murawski’s “Some Historical, Philosophical and Methodological Re-
marks on Proof in Mathematics” is about task and meaning of proof in mathemat-
ics, including discussions of the role of informal proofs in mathematical research
practice, of the concept of formal proof, and of the distinction between provability
and truth.
In “Cut Elimination in Sequent Calculi with Implicit Contraction, with a con-
jecture on the origin of Gentzen’s altitude line construction” Sara Negri and Jan
von Plato settle the issue that standard cut elimination fails if the principal for-
mula of a rule occurs in a premiss, and adapt this to sequent calculi with multisets
and contraction.
While one objective of Hilbert’s Programme, ﬁnitistic consistency proofs,
has been dashed by Gödel’s second incompleteness theorem, in “Hilbert’s Pro-
gramme and Ordinal Analysis” Wolfram Pohlers argues that ordinal analysis
not only helps to the other objective—the elimination of ideal elements—but is
actually based on it.
In “Aristotle’s Deductive Logic: a Proof-Theoretical Study” Jan von Plato
shows that derivations based on Aristotle’s rules of proof can so be transformed

Preface
|
VII
that the method of indirect proof is invoked at most once as a last step, which is
the only way in which—as the author claims—Aristotle used indirect proof.
Michael Rathjen’s “Remarks on Barr’s Theorem: Proofs in Geometric Theo-
ries” gives a constructive proof of Gentzen’s Hauptsatz for L∞ω–logic which en-
tails in a simple way the so-called Barr theorem that in geometric L∞ω–logic clas-
sical and intuitionistic provability coincide; also the Axiom of Choice is put into
context.
Acknowledgment: First and foremost the editors of this volume would like to ex-
press their gratitude to the Alexander-von-Humboldt Foundation for oﬀering the
patronage of the Humboldt-Kolleg “Proof” and for generously giving ﬁnancial
support. Open-handed ﬁnancial assistance further came from the following in-
stitutions: Burgergemeinde Bern, Deutsche Vereinigung für Mathematische Logik
und für Grundlagenforschung der Exakten Wissenschaften, the Logic and Theory
Group at the Institute of Computer Science of the University of Bern, Swiss Na-
tional Science Foundation, Swiss Academy of Science, and Swiss Society for Logic
and Philosophy of Science.
When co-editing this volume the second editor received individual funding by
the Alexander-von-Humboldt Foundation, in the form of a Further Research Fel-
lowship which he spent at the Munich Center for Mathematical Philosophy upon
kind invitation by Hannes Leitgeb; and by the John Templeton Foundation within
the project “Abstract Mathematics for Actual Computation: Hilbert’s Program in
the 21st Century”.
Maik Bierwirth, Project Editor at De Gruyter, provided considerate guidance
throughout the present book project. Special thanks are own to Olena Gainulina,
Production Editor at De Gruyter, for her advice and patience during the phase of
typesetting the ﬁnal version of this volume; and to Peppo Brambilla, system ad-
ministrator of the Institut für Informatik, Universität Bern, for his technical sup-
port. Laura Crosilla and Daniel Wessel have given helpful advice about certain
aspects of the introduction.
Last but not least, the editors are indebted to the authors and to the anony-
mous peer reviewers, without whose respective contributions this volume would
hardly have emerged.
Bern
D.P.
Verona
P.S.
June 2016


Contents
Dieter Probst and Peter Schuster
Introduction | 1
Bahareh Afshari, Stefan Hetzl, and Graham E. Leigh
Herbrand Confluence for First-Order Proofs with Π2-Cuts | 5
Marco Benini
Proof-Oriented Categorical Semantics | 41
Ulrich Berger, Kenji Miyamoto, Helmut Schwichtenberg, and Hideki Tsuiki
Logic for Gray-code Computation | 69
Douglas S. Bridges
The Continuum Hypothesis Implies Excluded Middle | 111
Ulrik Buchholtz, Gerhard Jäger, and Thomas Strahm
Theories of Proof-Theoretic Strength ψ(ΓΩ+1) | 115
Thierry Coquand and Henri Lombardi
Some Remarks about Normal Rings | 141
Kosta Došen
On Sets of Premises | 151
Hajime Ishihara and Takako Nemoto
Non-Deterministic Inductive Deﬁnitions and Fullness | 163
Ioannis Kokkinis and Thomas Studer
Cyclic Proofs for Linear Temporal Logic | 171
Roman Kuznets
Craig Interpolation via Hypersequents | 193
Seraﬁna Lapenta and Ioana Leuştean
A General View on Normal Form Theorems for Łukasiewicz Logic
with Product | 215

X
|
Contents
Maria Emilia Maietti and Giuseppe Rosolini
Relating Quotient Completions via Categorical Logic | 229
Roman Murawski
Some Historical, Philosophical and Methodological Remarks on Proof
in Mathematics | 251
Sara Negri and Jan von Plato
Cut Elimination in Sequent Calculi with Implicit Contraction, with a Conjecture
on the Origin of Gentzen’s Altitude Line Construction | 269
Wolfram Pohlers
Hilbert’s Programme and Ordinal Analysis | 291
Jan von Plato
Aristotle’s Deductive Logic: a Proof-Theoretical Study | 323
Michael Rathjen
Remarks on Barr’s Theorem: Proofs in Geometric Theories | 347

Dieter Probst and Peter Schuster
Introduction
In a ﬁrst attempt to explain the concept of proof in mathematics, one could simply
say that a proof is a way to convince someone of the truth of a claim. Here “some-
one” may mean oneself, a colleague, the audience of a seminar or conference talk,
the students present at a lecture, or even the entire community of mathematicians.
In parallel to the diﬀerent context of law one could also say that the truth of
a claim consists in that the claim corresponds to the actual facts—which, how-
ever, is anything but uncontroversial from certain epistemic perspectives. But to
tell what is true is not unproblematic even in law, where the objects of discourse
largely belong to the real world and are fairly concrete: just think of the only wit-
ness in a case being lying throughout, or of scientiﬁc experts called by the court
who fail to come to a common assessment.
Mathematics, on the other hand, is to a large extent about an ideal world pop-
ulated by more-or-less abstract entities such as numbers, points, lines, and more
recently by even more puzzling objects such as sets, functions, categories etc. The
task of deﬁnining truth in mathematics thus is of an entirely diﬀerent character.
In fact, numerous serious foundational and philosophical issues are about
and around. These include the time-honoured problem whether universals exist,
or just particulars; the question whether mathematical knowledge is possible at
all, e.g. as Kant’s synthetic judgements a priori; and the various issues that have
arisen from and since what became known as Grundlagenkrise der Mathematik
(foundational crisis of mathematics).
A way to avoid many of these problems, and still have a reasonable concept of
proof, is to move from absolute truth to relative certainty. This also is the working
attitude of most mathematicians no matter whether on Sundays they believe that
absolute truth is possible.
In a nutshell, relative certainty means that a proof is a successful demonstra-
tion that a mathematical theorem necessarily follows by logical reasoning from
axioms which are considered evident for the given context and/or agreed upon by
the community. It is this very concept of proof that sets mathematics apart from
other ﬁelds, distinguishing it as the prototype of a deductive discipline especially
vis-à-vis the inductive sciences.
Dieter Probst: Institut für Informatik, Universität Bern, Neubrückstrasse 10, 3012 Bern, Switzer-
land, e-mail: probst@inf.unibe.ch
Peter Schuster: Dipartimento di Informatica , Università di Verona, Strada Le Grazie 15, 37134
Verona, Italy, e-mail: peter.schuster@univr.it

2
|
D. Probst and P. Schuster
Euclid allegedly was the ﬁrst to employ the method of proof rigorously, to link
deﬁnitions and theorems the way that is now standard mathematical practice.
However, the idea of a proof was arguably known to the Babylonians, and cer-
tainly to the Pythagoreans as they are remembered for establishing the necessity
of proofs in mathematics. Yet Euclid’s geometry is generally considered to be the
paradigm of mathematical certainty by rigorous proof, which has been aspired
ever since even for the whole of mathematics.
The quest for certainty became more urgent with the introduction of abstract
terms into mathematics, especially from the second half of the 19th century. Real
pressure emerged with the paradoxes resulting from this development, the prime
example being Russell’s discovery that naive set theory is inconsistent. This was
particularly relevant to Hilbert, by many considered the last mathematician to
be conversant with the entire subject, who indeed held the formalist view that
especially with the use of abstract terms mathematics is no more, no less, than a
symbolic language in the spirit of Leibniz’s characteristica universalis intended to
serve as an alphabet of human thought.
Slightly later Brouwer advocated—to some extent paralleled by Weyl and pre-
ceded by Kronecker—the so-called intuitionist view of mathematics as a construc-
tive mental activity. For proof praxis this means that logical reasoning and set for-
mation cannot be used as easily with inﬁnite or abstractentities asitcan withmost
ﬁnite or concrete objects. It took about half a century until Bishop with his con-
structive analysis proved that doing mathematics with intuitionistic logic need
not face the limitations which Hilbert saw in Brouwer’s proposal.
Encouraged by the earlier successful axiomatization of geometry, already in
1900 Hilbert asked—with the second item of his famous list of 23 open problems—
for a proof that the axioms of arithmetic would never lead to a contradiction:
the axioms by which, following Dedekind, he had characterized the real num-
bers. He made explicit that, apart from entailing the consistency (i.e., non-
contradictoriness) of geometry, any consistency proof for arithmetic would con-
stitute a proof of mathematical existence of the real numbers or the continuum.
By a consistency proof for all mathematics one could also do away, at once
and in principle, with the constraints perceivedly imposed by Kronecker and
Brouwer in particular. Hilbert in fact aimed at a consistent axiomatization of the
customary unlimited way of doing mathematics, an axiomatization capable of
deriving all mathematical truth including of course its own consistency. Hilbert
requested, moreover, that the proof of consistency be done by ﬁnite methods only,
to justify once and for all the use of ideal objects and transﬁnite methods.
By Gödel’s celebrated incompleteness theorems all hope was dashed to com-
plete Hilbert’s programme as a whole. Its initiation, however, was the dawn of a
novel direction of mathematics, soon under the identiﬁers Metamathematik and

Introduction
|
3
Beweistheorie (proof theory), which features mathematical reasoning and the
concept of proof as main objects of study.
Early but essential achievements were made by Gentzen. With natural de-
duction and sequent calculus he made precise formal notions of proof ﬂexible
enough to accommodate and relate classical and intuitionistic reasoning as pro-
pagandized by Hilbert and Brouwer, respectively. Gentzen showed that consis-
tency of arithmetic can be proved at least from outside the system, and his Haupt-
satz (main theorem) is without doubt the most versatile tool of proof theory not
only to establish consistency for wider areas of mathematics.
Gentzen’s main tool is what is known as cut elimination: a way of getting rid
of unnecessary detours in order to convert formal proofs into normal form as is
needed for in-depth proof-theoretical studies. As a late impact hardly to be ex-
pected in Gentzen’s time, his achievements have proved useful in theoretical com-
puter science: for the development of provably correct software, e.g. by extracting
programs directly from formal proofs.
So concerns that initially were mainly foundational—ifnotpartlyideological—
ignited a thorough exploration of the concept of formal proof, and prompted ad-
jacent disciplines to discuss and apply this concept from their own perspectives.
Despite all this, the prima facie rather philosophical question of what should
be considered as a proof has become more pressing with the rapid progress of
mathematics in combination with the racily increasing potential of computing
technology—and perhaps also just with the quest for formal proofs.
The concept of proof shared by the community is wider than the notion of
formal proof. For instance, the famous Four-Colour Theorem is widely accepted
although it was proved using a computer to carry out an exhaustive case check-
ing unfeasible for a human agent. The working mathematician anyway takes a
pragmatic stance, rarely provides a formalized proof and usually does not even
care much which formal system would allow to formalize it.
It needs to be said that the task of formalization is anything but easy, for which
Wiles’s distinguished but highly complex proof of Fermat’s Last Theorem is a good
example. These days only relatively few mathematicians are able to comprehend
this proof as a whole, and there is demand for a more down-to-earth proof, e.g. in
Peano Arithmetic, which would be eligible for formalisation or even for computer-
based mechanical veriﬁcation.
The idea of proof which the formal mathematical counterpart tries to model
has evolved with time; it has transgressed the boundaries of logic and permeated
most parts of mathematics and even computer science. Proof has become a truly
interdisciplinary topic.


Bahareh Afshari, Stefan Hetzl, and Graham E. Leigh
Herbrand Confluence for First-Order Proofs
with Π2-Cuts
Abstract: To each ﬁrst-order proof π with cuts of at most complexity Π2, we assign
a formal grammar in which the number of production rules is bounded by the size
of π and the set of generated terms is ﬁnite and forms a Herbrand expansion for
the end-sequent of π. Using these grammars we prove that all (possibly inﬁnitely
many) normal forms of π obtained by non-erasing cut reductions have the same
Herbrand expansion.
Keywords: Cut elimination, First-order logic, Herbrand’s theorem, Formal lan-
guage theory
Mathematics Subject Classiﬁcation 2010: 03F05, 68Q42
1 Introduction
In classical ﬁrst-order logic a proof can be considered as being composed of two
layers: on the one hand the terms by which quantiﬁers are instantiated, and on
the other hand, the propositional structure. This separation is most clearly illus-
trated by Herbrand’s theorem [Herbrand, 1930, Buss, 1995]: a formula is valid if
and only if there is a ﬁnite expansion (of existential quantiﬁers to disjunctions
and universal quantiﬁers to conjunctions of instances) which is a propositional
tautology. Such Herbrand expansions can be transformed to and obtained from
cut-free sequent calculus proofs in a quite straightforward way.
Standard cut reduction is, however, not conﬂuent, i.e. it permits the computa-
tion of many essentially diﬀerent cut-free proofs. It was shown in [Baaz and Hetzl,
2011] (for pure ﬁrst-order logic) and in [Hetzl, 2012b] (for arithmetical theories)
that the number of diﬀerent Herbrand expansions obtainable from a single proof
with cut grows at least as fast as the size of the cut-free proofs. Still, it is not clear
whether these results can be strengthened to obtain even more normal forms. In
particular, it is an open question whether in general cut-elimination can produce
inﬁnitely many diﬀerent Herbrand expansions.
In [Hetzl and Straßburger, 2012, 2013] an upper bound for the obtainable nor-
mal forms has been provided for proofs with Π1-cuts in the following strong sense:
Bahareh Afshari, Stefan Hetzl, and Graham E. Leigh: Institute of Discrete Mathematics and
Geometry, Vienna University of Technology, Vienna, Austria,
email: bahareh.afshari@tuwien.ac.at, stefan.hetzl@tuwien.ac.at, graham.leigh@tuwien.ac.at

6
|
B. Afshari, S. Hetzl, and G. Leigh
a proof π with Π1-cuts induces a ﬁnite set [[π]] such that every cut-free proof π耠
obtained from π via standard cut elimination has a Herbrand expansion, H(π耠),
which is contained in [[π]] . Moreover, if π耠is obtained from π by non-erasing re-
ductions (reductions that do not eliminate sub-proofs) then we even have H(π耠) =
[[π]]. Consequently all normal forms of the non-erasing reduction (of which there
inﬁnitely many) have the same Herbrand expansion. This property of classical
logic has been called Herbrand-conﬂuence in [Hetzl and Straßburger, 2012, 2013]
and provides a general way of deﬁning the computational content of a classical
proof.
The present paper extends Herbrand-conﬂuence to proofs with Π2-cuts. To a
simple Π2-proof¹ π we associate a recursively deﬁned tree grammar Gπ whose set
of production rules is bounded by the size of π and generates a ﬁnite language
L(Gπ) satisfying the following conﬂuence result.
Theorem 1.1. Let π0, π1, . . . , πk be a sequence of simple Π2-proofs such that πi+1
is obtained from πi by a standard reduction rule (see Figures 1 and 2) other than
weakening reduction. Then L(Gπ0) = Ł(Gπk). In particular, if the proof πk contains
only quantiﬁer-free cuts L(Gπ0) = H(πk).
Theorem 1.1 can be seen as a reﬁnement of [Afshari et al., 2015, Theorem 2].
Therein each simple Π2-proof π is associated an acyclic context-free tree grammar
Fπ such that for π0, π1, . . . , πk being a reduction sequence (possibly allowing re-
duction of weakening), L(Fπ0) ⊇Ł(Fπk). For simple proofs, the grammars deﬁned
here and in [Afshari et al., 2015] can be shown to have the same language. There
are, however, a number of technical diﬀerences between the two grammars moti-
vated by the combinatorial nature of proving Herbrand conﬂuence. Most notably,
Gπ may be cyclic (but permit only ‘well-founded’ derivations).
The grammar Gπ can be considered as a directed graph whose nodes are
quantiﬁer occurrences and whose edges describe the information ﬂow between
them. In this sense it is also similar to the graphical formalisms of [Heijltjes, 2010,
McKinley, 2013]. Other related structures are proof nets, which capture informa-
tion ﬂow on the propositional level and have been extensively studied starting
with [Girard, 1987], as well as the logical ﬂow graphs used by Buss [Buss, 1991]
in the solution of the k-provability problem and further investigated by Carbone
(see e.g. [Carbone and Semmes, 2000]).
1 See Deﬁnition 2.1.

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
7
2 First-order logic
We work with a Tait-style sequent calculus for ﬁrst-order logic with explicit weak-
ening and contraction rules. Terms and formulæ of ﬁrst-order logic are deﬁned
as usual using the connectives ∧, ∨and quantiﬁers ∀, ∃, as well as a selection
of predicate and function symbols. We assume two sets of variable symbols, free
variables, denoted α, β, etc., and bound variables, x, y, z, with a formula only able
to contain the latter sort in bound contexts.
Upper-case Roman letters, A, B, etc. denote formulæ and upper-case Greek
letters Γ, ∆, etc. will range over sequents, ﬁnite unordered collections of formulæ
with possible repetition. We abbreviate by Γ, ∆the disjoint union of Γ and ∆; and
Γ, A is shorthand for Γ, {A}. We write
̄A to denote the dual of the formula A ob-
tained by de Morgan laws, and A[x/t] for the formula obtained from A by replac-
ing x with the term t if this will not induce any variable capture, and A otherwise.
Table 1. Axioms and rules of sequent-calculus
A, ̄A (for A an atomic formula)
Γ, A, B
−−−−−−−−−−−−−−−−−−−−−∨
Γ, A ∨B
Γ, A
∆, B
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∧
Γ, ∆, A ∧B
Γ, A[x/α]
−−−−−−−−−−−−−−−−−−−−−−−−−∀
Γ, ∀xA
Γ, A[y/s]
−−−−−−−−−−−−−−−−−−−−−−−−−∃
Γ, ∃yA
Γ
−−−−−−−−−w
Γ, ∆
Γ, ∆, ∆∗
−−−−−−−−−−−−−−−−−−−−−c
Γ, ∆
Γ, A
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆
A proof is a ﬁnite binary tree of sequents obtained from the axioms and rules laid
out in Table 1. In the (∀) rule, α is called the eigenvariable and must not appear
in Γ, ∀xA. In the (∃) rule the term s is assumed to be free for y. In the contraction
rule (c), ∆∗denotes a distinct copy of ∆. In each inference rule, those formulæ
which are explicitly mentioned in the premise are said to be principal in the rules
applied, for example A and B are principal in (∧) rule, every formula from ∆∗is
principal in (c), and there are no principal formulæ in the weakening rule (w).
We assume all proofs are regular, namely all quantiﬁers’ eigenvariables are
distinct and diﬀerent from any free variables. EV(π) denotes the set of eigenvari-
ables in π and π[α/t] is the result of replacing throughout the proof π each occur-
rence of the variable symbol α by the term t. We write π ⊢Γ to express that π is a
proof with Γ being the sequent appearing at the root of π. A position in a proof π is
a ﬁnite binary sequence pointing to a node in the proof-tree π. Pos(π) denotes the
set of all positions in π. For p ∈Pos(π), π|p denotes the subproof of π at position

8
|
B. Afshari, S. Hetzl, and G. Leigh
p with the convention that π|⟨⟩= π and π|ip = π耠|p, where π耠is the immediate
left (or only) subproof of π if i = 0 and the immediate right subproof otherwise.
The size of π, denoted |π|, is the total number of inference rules and axioms in π.
In this paper we primarily consider the following class of ﬁrst-order proofs.
Deﬁnition 2.1 (Simple formulæ and simple Π2-proofs). We call a formula simple
if it is a prenex Π2 or prenex Σ2 formula with at most one universal and one existen-
tial quantiﬁer. A simple Π2-proof is a proof in which each sequent is a ﬁnite multiset
of simple formulæ and every universally quantiﬁed formula appearing above a cut
is principal in the inference directly after its introduction (which is either a cut or
existential introduction).
Lemma 2.2. If π ⊢Γ in which all cut formulæ in π and all formulæ in Γ are simple
then there is a simple Π2-proof π耠⊢Γ such that |π耠| ≤|π|.
Proof: Apply inversion to all principal occurrences of universally quantiﬁed for-
mulæ in π that appear above some cut to ‘shift’ the quantiﬁer introduction rule
(∀) downwards in the proof resulting in a simple Π2-proof π耠⊢Γ. This operation
will not introduce any new inference rules to π so |π耠| ≤|π|.
2.1 Cut reduction
The standard cut reduction rules are given in Figures 1 and 2.
Axiom:
π
Γ, A
A, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, A
䁄䀼
π
Γ, A
Boolean:
π0
Γ, A
π1
∆, B
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∧
Γ, ∆, A ∧B
π2
Π, ̄A, ̄B
−−−−−−−−−−−−−−−−−−−−−−−−∨
Π, ̄A ∨̄B
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆, Π
䁄䀼
π0
Γ, A
π1
∆, B
π2
Π, ̄A, ̄B
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
∆, Π, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆, Π
Fig. 1. One-step cut reduction and permutation rules I.

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
9
Quantiﬁer:
π0
Γ, A[x/α]
−−−−−−−−−−−−−−−−−−−−−−−−−−∀
Γ, ∀x A
π1
∆, ̄A[x/t]
−−−−−−−−−−−−−−−−−−−−−−−−−∃
∆, ∃x ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆
䁄䀼
π0[α/t]
Γ, A[x/t]
π1
∆, ̄A[x/t]
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆
Weakening:
π0
Γ耠
−−−−−−−−−w
Γ, A
π1
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆
䁄䀼
π0
Γ耠
−−−−−−−−−w
Γ, ∆
Contraction:
π0
Γ耠, Γ, A, Γ∗, A∗
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−c
Γ耠, Γ, A
π1
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ耠, Γ, ∆
䁄䀼
π0
Γ耠, Γ, A, Γ∗, A∗
π1
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ耠, Γ, Γ∗, A∗, ∆
π∗
1
∆∗, ̄A∗
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ耠, Γ, Γ∗, ∆, ∆∗
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−c
Γ耠, Γ, ∆
Unary inf.:
π0
Γ耠, A
−−−−−−−−−−−−−r
Γ, A
π1
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆
䁄䀼
π0
Γ耠, A
π1
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ耠, ∆
−−−−−−−−−−−−r
Γ, ∆
Binary inf.:
π0
Γ耠
π1
Γ耠耠, A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−r
Γ, A
π2
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆
䁄䀼
π0
Γ耠
π1
Γ耠耠, A
π2
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ耠耠, ∆
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−r
Γ, ∆
Fig. 2. One-step cut reduction and permutation rules II.

10
|
B. Afshari, S. Hetzl, and G. Leigh
There is one reduction step that may not preserve simple Π2-proofs, namely the
particular instance of binary rule permutation in which (r) is (cut):
π0
Γ, A
π1
∆, ∀xB, ̄A
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
∆, Λ, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π ⊢Γ, ∆, Λ
䁄䀼
π0
Γ, A
π1
∆, ∀xB, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆, ∀xB
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π耠⊢Γ, ∆, Λ
In the right-hand proof, ∀xB is principal in the cut but is not immediately preceded
by the rule (∀) introducing it, so is not a simple proof. If the left-hand proof is a
simple Π2-proof then it follows that π1 has the form
π耠
1
∆, B[x/β], ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
∆, ∀xB, ̄A
whence we see that applying unary rule permutation to the upper cut in π耠we
may obtain the derivation
π0
Γ, A
π耠
1
∆, B[x/β], ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆, B[x/β]
−−−−−−−−−−−−−−−−−−−−−−−−−−∀
Γ, ∆, ∀xB
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π耠耠⊢Γ, ∆, Λ
We have π 䁄䀼π耠䁄䀼π耠耠and π耠耠is a simple Π2-proof.
In order to permit reduction strategies of this form it is convenient to consider
the reduction from π to π耠耠as a single reduction step, so we add the following

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
11
additional rule to the deﬁnition of 䁄䀼:
π0
Γ, A
π1
∆, B[x/β], ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
∆, ∀xB, ̄A
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
∆, Λ, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π ⊢Γ, ∆, Λ
䁄䀼
π0
Γ, A
π1
∆, B[x/β], ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆, B[x/β]
−−−−−−−−−−−−−−−−−−−−−−−−−−∀
Γ, ∆, ∀xB
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π耠耠⊢Γ, ∆, Λ
(1)
Deﬁnition 2.3. For proofs π, π耠we write π 䁄䀼π耠if π耠is the result of applying one
of the rules of Figures 1 or 2, or (1) above to (a sub-proof of) π. Notice that in con-
traction reduction the left sub-proof is duplicated and care is taken to rename the
eigenvariables (expressed by annotating the proof/sequent/formula in question by
an asterisk) to maintain regularity.
2.2 Herbrand’s theorem
Suppose Γ is a set of simple formulæ and π ⊢Γ is a proof in which all cuts are
on non-quantiﬁed formulæ. For each F ∈Γ let the Herbrand set for F, denoted
H(π, F), be the set of terms that occur in π as witnesses to the existential quantiﬁer
in F (if there is one). The Herbrand set for π is the set H(π) = {(F, t) | F ∈Γ ∧t ∈
H(π, F)}.
Given a set X of terms and simple formula F, let FX denote the prenex Π1
formula given by
(∀xF)X = ∀xFX
(∃xF)X = ⋁
t∈X
F[x/t]
and FX = F if F is quantiﬁer-free.
Theorem 2.4 (Herbrand’s theorem for simple formulæ). Let Γ be a ﬁnite set of
simple Σ1 formulæ. ⋁Γ is valid iﬀthere exist ﬁnite sets {XF ⊆Terms | F ∈Γ} such
that the formula ⋁F∈Γ FXF is valid.

12
|
B. Afshari, S. Hetzl, and G. Leigh
Proof: The right-to-left direction is immediate. For the left-to-right direction, sup-
pose ⋁Γ is valid formula of ﬁrst-order logic. Fix a cut-free proof π ⊢Γ and for each
F ∈Γ, set XF = H(π, F). By Gentzen’s mid-sequent theorem π induces a proof of
⋁F∈Γ FXF and we are done.
3 Proof grammars
It this section we deﬁne a class of grammars suitable for the analysis of Π2-proofs.
Our deﬁnition of a grammar somehow deviates from a standard one as it allows
certain (controlled) bounded non-terminals to be re-written in the derivations. It
is, nevertheless, possible to provide an equivalent deﬁnition of these grammars in
terms of (standard) context-free tree grammars [Afshari et al., 2015]. The presen-
tation given in this paper has the advantage that the types of non-terminals are
ﬁxed from the outset allowing the veriﬁcation of (proof-speciﬁc) language prop-
erties such as reductions proved in Section 5 to be clearer.
3.1 Terms, positions and substitution
Fix a ranked alphabet Σ and let V be a ﬁxed set of variable symbols distinct from
Σ. Let Term(Σ) denote the set of terms in the simply-typed λ-calculus built from
Σ ∪V. The set of positions of a term T ∈Term(Σ), denoted Pos(T), are the nodes of
the underlying tree, i.e.
Pos(T) = {⟨⟩} ∪
{
{
{
{
{
{
{
0,
if T ∈Σ ∪V,
{ip | i ∈{0, 1} ∧p ∈Pos(Ti)},
if T = T0 ⋅T1,
{0p | p ∈Pos(T0)},
if T = (λα.T0).
For a term T and p ∈Pos(T), we write T|p for the subterm of T at position p.
Given T ∈Term(Σ) and α ∈V, let Free(T, α) ⊆Pos(T) be the collection of
positions at which α appears free in T:
Free(α, α) = {⟨⟩}
Free(훾, α) = 0
if α
̸= 훾∈V
Free(a, α) = 0
if a ∈Σ
Free(T1 ⋅T2, α) = {ip | i ∈{0, 1} and p ∈Free(Ti, α)}
Free(λ훾.T, α) =
{
{
{
0,
if 훾= α
{0p | p ∈Free(T, α)},
if 훾̸= α

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
13
We introduce two forms of term substitution. Let S, T ∈Term(Σ).
–
T[a/S], where a ∈Σ ∪V, denotes the safe substitution of S for a in T. So
in particular, (λ훾.T)[훾/S] = λ훾.T and for a distinct from 훾, (λ훾.T)[a/S] =
λδ.(T[훾/δ][a/S]) where δ is a variable symbol not occurring free in S.
–
T[p/S], where p ∈Pos(T), is deﬁned by recursion on p:
T[⟨⟩/S] = S
a[p/S] = S,
a ∈Σ ∪V
(T0 ⋅T1)[0p/S] = T0[p/S] ⋅T1
(λα.T)[0p/S] = λα.T[p/S]
(T0 ⋅T1)[1p/S] = T0 ⋅(T1[p/S])
Note that this may involve an unsafe substitution.
3.2 Syntax and semantics of proof grammars
A proof grammar is a tuple G = ⟨N, Σ, S, Pr⟩where N is a set of typed non-terminals
of order at most 1, S ⊆N is a set of starting symbols (of base type), Σ is a ranked
alphabet, called terminals, disjoint from N, and Pr consists of pairs (a, T) ∈N ×
Term(Σ ∪N) (called production rules and written a →T) such that a and T have
the same type. Given a proof grammar G we assume G = ⟨NG, ΣG, SG, PrG⟩.
Let d be a sequence ⟨ρi, pi⟩i<k of pairs of production rules of a proof grammar
G and positions, and S and T terms. We call d a derivation from S to T, written
d: S →T, if there exist terms (Ni)i≤k such that N0 = S, Nk = T, and for each
0 ≤i < k,
1.
ρi is a production rule of G and pi ∈Pos(Ni),
2.
For ρi = (a →S), we have Ni|pi = a and Ni+1 = Ni[pi/S].
The sequence of terms (Ni)i≤k is uniquely determined by d and S, whence we may
write d(i) for Ni. The length of d, lh(d), is k. We write Der(G) for the set of deriva-
tions in G, and say T is derivable from S if there exists a derivation d: S →T. A
derivation d writes a non-terminal a if there is a production rule of the form a →S
for some S occurring in d.
The language of a proof grammar G, L(G), is the set of terms not containing
free occurrences of non-terminal symbols that are derivable from the starting sym-
bols of the grammar:
Ł(G) = {T | ∃d: σ →T s.t. σ ∈SG and T contains no
free occurrence of a non-terminal}.
When comparing languages of proof grammars it is convenient to work modulo β-
convertibility. For λ-terms S and T, we write S →β T to abbreviate T is obtainable

14
|
B. Afshari, S. Hetzl, and G. Leigh
from S by one step β-reduction, and →∗
β for the reﬂexive transitive closure of this
relation. Thus for grammars G1, G2, we write L(G1) ⊆Ł(G2) to express that for
every S ∈Ł(G1) there exists a T ∈Ł(G2) such that T →∗
β S.
3.3 Rigidity
Rigid grammars were studied in [Hetzl, 2010, 2012a] for the construction of terms
appearing in cut-elimination for ﬁrst-order logic with Π1-cuts. In this section we
extend the notion of rigidity for the analysis of proofs with Π2-cuts.
Let G be a proof grammar and suppose ⊲is a transitive binary relation on
NG and R ⊆NG is a designated set of non-terminals. A derivation d = ⟨(ai →
Si), qi⟩i<lh(d) : S →T induces an equivalence relation on {i | i < lh(d)} corre-
sponding to connectedness in parse trees: for j0, j1 < lh(d), set j0 ≈d j1 iﬀthere
exist i0 ≤j0, j1 such that
1.
qi0 ≤qj0, qj1,
2.
for every k ∈{0, 1} and i0 < i < jk < lh(d), if qi ≤qjk and ai ∈R then ajk
̸⊲ai.
In other words, two non-terminals occurring in (the natural tree representation
of) the derivation d are considered connected if there is no non-terminal of higher
priority between them and their closest common ancestor. We write j0 ∼d j1 if
j0 ≈d j1 and in addition aj0 = aj1 ∈R. Notice that ∼d may not be an equivalence
relation on {i | i < lh(d)}. For instance, if aj
̸∈R then j
̸∼d j.
We consider derivations that respect the relation ∼d and we permit unsafe
substitutions that are controlled by priority ordering ⊲:
Deﬁnition 3.1 (Rigid derivations). Let G be a proof grammar and suppose ⊲is a
transitive binary relation onNG and R ⊆NG. A derivation d = ⟨ai →Ti, qi⟩i<k : S →
T in G is rigid with respect to (⊲, R) if
1.
for every i, j < k, i ∼d j implies T|qi = T|qj, and
2.
for every i < k with ai ∈R, if d(i)|q = λai.S0 for some position q < qi and
term S0, then there exist position q < q耠< qi, term S1 and variable b such that
d(i)|q耠= λb.S1 and ai ⊲b.
A rigid proof grammar is a tuple G = ⟨N, R, ⊲, Σ, S, Pr⟩such that ⟨N, Σ, S, Pr⟩is
a proof grammar, R ⊆N and ⊲is a transitive relation on N. R = RG is the set of
rigid non-terminals of G and ⊲=⊲G is the priority ordering of G. G is acyclic if the
ordering ⊲G is acyclic, that is for all a ∈NG it is not the case that a ⊲G a, and is
totally rigid if RG = NG.

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
15
In a rigid proof grammar G, a derivation is simply a derivation in the underly-
ing proof grammar and a rigid derivation is a derivation which is rigid with respect
to (⊲G, RG).
A rigid derivation d: S →T (in G) is full if there is no extension of d that
is a rigid derivation in G. The language of a rigid proof grammar G, L(G), is the
collection of terms derivable from full rigid derivations starting from SG:
Ł(G) = {T | ∃d: σ →T s.t. σ ∈SG and d is full and (⊲G, RG)-rigid}.
Note Deﬁnition 3.1 allows certain variables that are bounded (by an abstraction)
to be re-written. Therefore in rigid derivations, arbitrary β-reductions are not per-
missible until the derivation is fully written in the sense given above.
Observation 3.2. The language of a rigid proof grammar is a set of closed (well-
typed) ground-type λ-terms.
Observation 3.3 (Permutation). Let d and d耠be derivations in a rigid grammar G
and suppose d耠is a permutation of d. d耠is rigid iﬀd is rigid.
Example 3.4. Let G be the rigid proof grammar with start symbol σ, the non-
terminals σ, α and 훾, rigid non-terminals R, ordering ⊲, all other symbols terminals
of appropriate arity, and production rules
σ →f(α, 훾, 훾)
훾→g(훾) | a
α →훾
If 훾
̸∈R we have, unsurprisingly, L(G) = {f(gm(a), gn(a), go(a)) | m, n, o ≥0}. For
훾∈R,
1.
If 훾⊲훾⊲α and α ∈R, L(G) = {f(gm(a), gn(a), gn(a)) | m, n ≥0};
2.
If 훾⊲훾̸⊲α, L(G) = {f(gm(a), gm(a), gm(a)) | m ≥0};
3.
If 훾̸⊲훾̸⊲α, L(G) = {f(a, a, a)}.
Example 3.5. Let G be a proof grammar and suppose R ⊆NG. Further, let d =
⟨ρi, qi⟩i<k : M →N be a derivation in G. Two simple choices of ⊲are
1.
Global rigidity. Set ⊲G= 0. Then d is (⊲G, R)-rigid iﬀfor all i, j < k, d(i)|qi =
d(j)|qj ∈R implies N|qi = N|qj.
2.
Local rigidity. ⊲L= NG × NG. In this form rigidity is treated only at the level
of production rules: d is (⊲L, R)-rigid iﬀfor every i < k, if ρi = (a →S) and
S|p = S|q ∈R, then N|qip = N|qiq.
Notation 3.6. Given a derivation d = ⟨ρi, qi⟩i<k and a position p we deﬁne dp to be
the derivation ⟨ρi, pqi⟩i<k.
Deﬁnition 3.7 (Subderivation). Let d = ⟨ρi, qi⟩i<lh(d) be a derivation and suppose
k < lh(d). The subderivation of d from k is the longest derivation e = ⟨̂ρi, ̂qi⟩i<lh(e)
such that ̂q0 = ⟨⟩and eqk is a subsequence of d.

16
|
B. Afshari, S. Hetzl, and G. Leigh
Deﬁnition 3.8 (Strong rigidity). A derivation d = ⟨ρi, qi⟩i<lh(d) is strongly rigid iﬀ
for all i0, i1 < lh(d) if i0 ∼d i1 then the subderivations of d from i0 and i1 are
identical or a permutation of one another.
Restricting to strongly-rigid derivations does not reduce the language of a rigid
grammar:
Lemma 3.9. Let G be a rigid grammar. For all M and N, if there is a rigid derivation
from M to N in G then there exists a strongly rigid derivation from M to N in G.
Proof: By recursion through d: for each p and q such that d(i)|p = d(j)|q ∈NG
and N|p = N|q replace the sub-derivation of d at q by a copy of the sub-derivation
of d at p. The result will be strongly rigid iﬀd is rigid.
3.4 Bounds on rigid proof grammars
Lemma 3.10 (Bounding). Suppose G is a rigid proof grammar satisfying the follow-
ing condition:
for every rigid derivation d = ⟨ρi, pi⟩i≤k in G and every i < j ≤k,
if pi ≤pj and d(i)|pi = d(j)|pj then there exists l ∈(i, j) such that
(2)
pi ≤pl ≤pj and d(j)|pj ⊲G d(l)|pl.
If G is acyclic then L(G) is ﬁnite; if G is acyclic and totally rigid, |Ł(G)| ≤|PrG|2|NG|−1.
Proof: Assume G is a rigid proof grammar satisfying (2) and ⊲G is acyclic. Fix a
rigid derivation d = ⟨ρi, pi⟩i≤k in G from an starting symbol. Call a derivation
̂d = ⟨̂ρi, ̂pi⟩i≤̂k a path through d if ̂d is a subsequence of d, ( ̂ρ0, ̂p0) = (ρ0, p0), and
for every i < j < ̂k, ̂pi ≤̂pj.
Let ̂d be a path through d and let Nd denote the set of non-terminals written by
̂d, i.e. Nd = {a ∈NG | ∃i < ̂k∃S ̂ρi = (a →S)}. Suppose Nd = {a0, a1, . . . , a|Nd|−1}
and for all i < j < |Nd|, ai
̸⊲aj which is possible as ⊲G is acyclic. By the stated
requirement there can be at most one i ≤̂k such that ̂ρi writes a0, whence there are
at most two production rules in ̂d that write a1, four production rules in ̂d writing
a2, and in general no more than 2i production rules writing ai. So ̂k < 2|Nd|. The
set of paths through d forms a tree which has branching degree bounded by some
constant K independent of d and depth bounded by 2|NG|, and it follows that k ≤
K2|NG|. As d is arbitrary there are only ﬁnitely many rigid derivations and the ﬁrst
result follows.
Suppose G is acyclic, totally rigid and satisﬁes (2). Let m = |PrG| and n = |NG|.
We argue, by induction on the number of non-terminals in G, that the set of terms

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
17
T ∈Terms(ΣG) rigidly derivable from a starting symbol in G has size bounded by
m2n−1.
The base case is n = 1. By the main assumption of the lemma every derivation
d: σ →T with σ ∈SG and ∈Terms(ΣG) has length 1, of which there are no more
than m. For the induction step, suppose n = n0 + 1. Let N = NG \ {a} where a
̸= σ
is chosen such that a
̸⊲b for all b ∈NG \ {σ}. Suppose d: σ →T ∈Terms(ΣG)
is a rigid derivation in G. By the main assumption d can be re-ordered to have the
form d0d1 where d0 : σ →S and d1 : S →T = S[a/S耠] for appropriate terms S
and S耠, such that the non-terminal a is not written in d0 and not introduced by
a production rule in d1. The induction hypothesis implies there is no more than
m2n0−1 possibilities for each of S and S耠, whence there are ≤m2n−1 possibilities for
T.
3.5 Grammars for Π2-proofs
In this section we associate to each simple Π2-proof π a proof grammar Gπ which
will be used in the subsequent sections to prove the conﬂuence result. We begin
with a motivating example:
Example 3.11. Let π ⊢∃xF be the proof given below in which there is a Π2-cut
on ∀x∃yA, a Π1-cut on ∀xB and we assume these are the only cuts on quantiﬁed
formulæ in π; α and 훾the respectively eigenvariables of these cuts; ti and ui wit-
ness terms of the existential quantiﬁer in, respectively, ∃x∀y ̄A and ∃x ̄B; and βi the
eigenvariable of the universal quantiﬁer in ∀y ̄A(ti, y). For a formula C, we use C∗to
distinguish between the two copies of C that may appear in the same sequent in the
proof.
B(훾), A(α, s(α, 훾)), F(g(훾, α))
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
B(훾), A(α, s(α, 훾)), ∃xF
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
∀xB, ∃yA(α, y), ∃xF
̄B(u1), ̄B∗(u2(α))
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
̄B(u1), ∃x ̄B∗
−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
∃x ̄B, ∃x ̄B∗
−−−−−−−−−−−−−−−−−−−−−−−−c
∃x ̄B
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
∃yA(α, y), ∃xF
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
∀x∃yA(x, y), ∃xF
π耠⊢∃x∀y ̄A(x, y)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π ⊢∃xF

18
|
B. Afshari, S. Hetzl, and G. Leigh
where π耠is given by
̄A(t1, β1), ̄A∗(t2(β1), β2)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
̄A(t1, β1), ∀y ̄A∗(t2(β1), y)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
̄A(t1, β1), ∃x∀y ̄A∗(x, y)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
∀y ̄A(t1, y), ∃x∀y ̄A∗(x, y)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
∃x∀y ̄A(x, y), ∃x∀y ̄A∗(x, y)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−c
π耠⊢∃x∀y ̄A(x, y)
Having the cut reduction process in mind, it is natural to consider the following
grammar. First we introduce a starting symbol σ∃xF which will write to the (literal)
witness of ∃xF in π, i.e. the term g(훾, α). This production rule initiates the search for
the witnesses to ∃xF. Next we add production rules that write the eigenvariables
α and 훾of the two cuts to the associated terms ti and ui respectively, mirroring
the substitutions performed in Gentzen-style cut elimination. To capture the cor-
rect rules for eigenvaribles of the universal quantiﬁer in ∃x∀y ̄A, i.e. β0 and β1, we
introduce a functional non-terminal σ which represents the existential quantiﬁer in
∀x∃yA(x, y) and allows βi to write (modulo β-reduction) to the term s(ti, 훾).² More
precisely, G = ⟨N, R, ⊲, Σ, S, Pr⟩with S = {σ∃xF}, R = {α, 훾, β1, β2}, N = S ∪R ∪{σ}
and Pr consisting of rules:
σ∃xF →g(훾, α)
훾→u1 | u2
α →t1 | t2
βi →σ ⋅ti
for i = 1, 2
σ →λα.s
The priority ordering is given by the order in which the eigenvariables are eliminated
in the proof, increasing in priority from top down, and left to right through a Π2-cut
(which has the universal formula on the left subproof):
훾⊲α ⊲β2 ⊲β1
We now calculate L(G). There are two possible starting derivations for σ∃xF:
σ∃xF →g(훾, α) →g(u1, α)
(3)
σ∃xF →g(훾, α) →g(u2(α), α)
(4)
Extending (3) we obtain the closed term g(u1, t1) ∈Ł(G) as well as
σ∃xF →∗g(u1, α) →g(u1, t2(β1)) →g(u1, t2(σ ⋅t1)) →g(u1, t2(λα.s(α, 훾) ⋅t1)).
2 Further motivation for the use of non-terminals of function type can be found in [Afshari et al.,
2015].

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
19
Since 훾⊲β1, the 훾appearing in the last term above is not connected to its
earlier occurrence in (3) and may freely write to either u1 or u2, yielding terms
g(u1, t2(s(t1, u1)) and g(u1, t2(s(t1, u2(t1))) in L(G).
To extend (4), ﬁrst note that the (possible) two occurrences of α in g(u2(α), α)
must be written to the same result, of which the following are allowed.
g(u2(t1), t1)
g(u2(t2(s(t1, u1))), t2(s(t1, u1)))
g(u2(t2(s(t1, u2(t1)))), t2(s(t1, u2(t1))))
Indeed, it is not hard to check that any cut-free proof π耠obtainable from π via the
reduction steps in Figures 1 and 2, H(π耠, ∃xF) consists of exactly the six closed terms
derived above.
We now proceed with the deﬁnition of the grammar. Let π ⊢Γ be a simple Π2-proof
of a set of prenex Π2 and Σ2 formulæ. The proof grammar for π is the grammar
Gπ = ⟨Nπ, Rπ, ⊲π, Σπ, Sπ, Prπ⟩where the components are deﬁned as follows.
Symbols and their types
We will use symbols of the form τp
F or σp
F where p is a position and F is a formula
occurring in π.³ Each such symbol is assigned a type, either 0 (ground type) or
0 →0 (function type):
–
type(τp
F) = type(σp
̄F) = 0 if F ∈Π2.
–
type(τp
F) = type(σp
̄F) = (0 →0) otherwise (i.e. F ∈Σ2 \ Π2).
–
All eigenvariables in π and ﬁrst-order terms are ground-type terms.
Alphabet and non-terminals
Σπ consists of the function symbols, constants and variables occurring in π, and
symbols τ⟨⟩
F for every F ∈Γ. The set of non-terminals, Nπ, consists of
–
rigid non-terminals Rπ = EV(π);
–
starting symbols Sπ = {σ⟨⟩
F | F ∈Γ};
–
symbols τp
A where p ∈Pos(π) \ {⟨⟩} and A is a formula occurring in the end-
sequent of π|p;
3 For brevity we write τF for τ⟨⟩
F .

20
|
B. Afshari, S. Hetzl, and G. Leigh
–
symbols σp
A where p ∈Pos(π) and A is a formula occurring in the end-sequent
of π|p.
Table 2. Production rules in Gπ
π|p ⊢Γ
Production rules in Gπ for position p, Prπ,p
π|p ⊢A, ̄A
{σp
A →τp
̄A, σp
̄A →τp
A}
∆, A0, A1
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∨
π|p ⊢∆, A0 ∨A1
prod(p, ∆, 0)
Π, A0
∆, A1
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∧
π|p ⊢Π, ∆, A0 ∧A1
prod(p, Π, ∆)
∆, A[x/α]
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
π|p ⊢∆, ∀xA
prod(p, ∆, 0) ∪{α →τp
∀xA, σp
∀xA →λα.σp0
A[x/α]}
∆, A[y/s]
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−∃
π|p ⊢∆, ∃yA
prod(p, ∆, 0) ∪{σp
∃yA →s, τp0
A[y/s] →τp
∃yA ⋅s}
∆, A
Π, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π|p ⊢∆, Π
prod(p, ∆, Π) ∪{τp0
A
→σp1
̄A , τp1
̄A
→σp0
A }
∆
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−w
π|p ⊢∆, Π
prod(p, ∆, 0)
∆, Π, Π∗
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−c
π|p ⊢∆, Π
prod(p, Π ∪∆, 0) ∪{τp0
F∗→τp
F , σp
F →σp0
F∗| F ∈Π}
prod(p, Γ, ∆) = prodτ(p, Γ, ∆) ∪prodσ(p, Γ, ∆)
prodτ(p, Γ0, Γ1) = {τpj
F →τp
F | j ∈{0, 1} ∧F ∈Γj}
prodσ(p, Γ0, Γ1) = {σp
F →σpj
F | j ∈{0, 1} ∧F ∈Γj}
Production rules and priority ordering
As the set of production rules in Gπ we choose Prπ := ⋃p∈Pos(π) Prπ,p, where the
sets Prπ,p (deﬁned in Table 2) are determined by the rule of inference occurring at
position p in π. Informally, non-terminals of the form σp
F represent the existential
quantiﬁer in F (if there is one) with their production rules ‘searching’ for witnesses

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
21
within the sub-proof π|p. Dually, τp
F represents the universal quantiﬁer in F (at p)
and link eigenvariables on one side of a cut to the existential witnesses on the
other side.
Like the production rules, the rigidity ordering, ⊲π, is determined by the local
structure of π and is the smallest transitive relation satisfying the following ﬁve
conditions.
–
Concerning production rules for axioms and side formulæ to all inference
rules:
1.
For each production rule of the form a →τq
B or a →τq
B ⋅s where a ∈
Nπ \ EV(π) we have a ⊲π τq
B;
2.
For each rule of the form σp
A →σpj
B or σp
A →λα.σpj
B (j ∈{0, 1}) we have
σp
A ⊲π σpj
B ;
–
For production rules introducing or eliminating eigenvariables:
3.
For each production rule α →τq
∀xA where α ∈EV(π) we have α ⊲π τq
∀xA,
and ξ ⊲π α for every ξ ∈EV(π|q0);
4.
For each rule of the form σp
A →s and each variable α appearing in s we
set σp
A ⊲π α;
–
And for production rules of cut formulæ:
5.
For a rule τpi
A →σpj
̄A with i = 1 −j ∈{0, 1}, if A = ∀xA0 for some Σ1
formula A0 then τpi
A ⊲π σpj
̄A .
The ﬁrst four conditions increase the priority of non-terminals as one follows ei-
ther ‘τ’ production rules ‘down’ the proof towards the conclusion or principal cuts,
or ‘σ’ productions ‘upwards’ towards witnesses of existential quantiﬁers. The ﬁ-
nal condition mediates the passage between the two paths over (one direction of)
a Π2-cut. The additional cases added by 3. capture, through the rigidity ordering,
the duplication of eigenvariables that may occur when reducing a quantiﬁed cut.
Example 3.12. Consider the proof π in Example 3.11. The grammar Gπ is the tuple
⟨Nπ, Rπ, ⊲π, Σπ, Sπ, Prπ⟩where Sπ = {σ⟨⟩
∃xF}, Rπ = {α, 훾, β1, β2}, we have in partic-
ular 훾⊲π α ⊲π τ0
∀x∃yA ⊲π σ1
∃x∀y ̄A ⊲π β2 ⊲π β1 and the production rules are:
1.
For the starting symbol we have:
σ⟨⟩
∃xF →σ0
∃xF →σ00
∃xF →σ000
∃xF →σ0000
∃xF →g(훾, α)
2.
For the eigenvariable 훾:
훾→τ000
∀xB →σ001
∃x ̄B →σ0010
∃x ̄B | σ0010
∃x ̄B∗
σ0010
∃x ̄B →u1
σ0010
∃x ̄B∗→σ00100
∃x ̄B∗→u2

22
|
B. Afshari, S. Hetzl, and G. Leigh
3.
For eigenvariable α:
α →τ0
∀x∃yA →σ1
∃x∀y ̄A →σ10
∃x∀y ̄A | σ10
∃x∀y ̄A∗
σ10
∃x∀y ̄A →t1
σ10
∃x∀y ̄A∗→σ100
∃x∀y ̄A∗→σ1000
∃x∀y ̄A∗→t2
4.
For eigenvariables β1 and β2:
β1 →τ100
∀y ̄A(t1) →τ10
∃x∀y ̄A ⋅t1
τ10
∃x∀y ̄A →τ1
∃x∀y ̄A
β2 →τ10000
∀y ̄A∗(t2) →τ1000
∃x∀y ̄A∗⋅t2
τ1000
∃x∀y ̄A∗→τ100
∃x∀y ̄A∗→τ10
∃x∀y ̄A∗→τ1
∃x∀y ̄A
τ1
∃x∀y ̄A →σ0
∀x∃yA →λα.σ00
∃yA
σ00
∃yA →σ000
∃yA →s
Notice that the function type non-terminal σ0
∀x∃yA plays the same role as σ in gram-
mar G of Example 3.11. Indeed, L(G) = Ł(Gπ).
Shifting symbols, terms and rules
Following the deﬁnition above, it is clear that if π is a sub-proof of π耠, say π = π耠|p,
then Gπ can be viewed as a sub-grammar of Gπ耠by ‘shifting’ the annotation of non-
terminals in Gπ by the position p. This action of ‘shifting’ a grammar relative to a
position turns out to be a useful operation on grammars. We let Gp denote the
result of shifting G relative to p, that is, Gp = ⟨Np
G, RG, ⊲p
π, ΣG, Sp
G, Prp
G⟩, where
Np
G = {ap | a ∈NG}
Sp
G = {ap | a ∈SG}
Prp
G = {ap →Tp | (a →T) ∈PrG}
⊲p
π = {(ap, bp) | a ⊲π b}
given by
(τq
F)p = τpq
F
(σq
F)p = σpq
F
훾p = 훾
for 훾∈RG
(T1 ⋅T2)p = Tp
1 ⋅Tp
2
(λα.T)p = λα.(Tp)
So in particular Gp
π|p is a sub-grammar of Gπ whenever p ∈Pos(π).
Lemma 3.13. If π is a simple Π2-proof then ⊲π is acyclic.
Proof: By induction on the proof π ⊢Γ noticing that no production rule in Gπ
writes τ⟨⟩
F or introduces σ⟨⟩
F (for F ∈Γ), and that if π ends in a cut on a simple

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
23
Π2 formula A = ∀x∃yB (say π|0 ⊢Γ, A and π|1 ⊢Γ, ̄A) then for all a ∈N0
π|0 and
b ∈N1
π|1 we have a
̸⊲π b.
Theorem 3.14. Let π be a simple Π2-proof. Then |Ł(Gπ)| < 222|π|.
Proof: First, note that requirement (2) of Lemma 3.10 is satisﬁed by all proof gram-
mars arising from simple Π2-proofs. We deﬁne a new grammar G耠by making the
following changes to Gπ: for every non-terminal νp
F
̸∈Rπ with ν ∈{τ, σ} and pro-
duction rule νp
F →S, if there is a production rule a →νp
F in Gπ then remove
νp
F →S and instead add a →S. Observe this process is well-deﬁned as the term S
cannot contain any occurrences of νp
F. Once all production rules writing νp
F are re-
placed, remove νp
F from the set of non-terminals. Let G0 be the resulting grammar,
and G耠the subsequent grammar obtained by indicating any remaining non-rigid
non-terminals in G0 to be rigid.
G耠is a totally rigid grammar and |NG耠| + |PrG耠| ≤2|π|. Moreover, L(Gπ) =
Ł(G耠): it is easy to see that the ‘compression’ preserves rigid derivations and so
L(G0) = Ł(Gπ). In G0 the only non-rigid non-terminals remaining are of the form
τp
∃yA or σp
∀y ̄A for some p and A. Observe that i) there is only one choice for writing
such non-terminals, and ii) τp
∃yA, σp
∀y ̄A ⊲π α where α is the eigenvariable of ∀y ̄A.
Thus any two non-terminals that become disconnected through τp
∃yA or σp
∀y ̄A in
G耠were already disconnected in Gπ through α. Indeed G耠and Gπ have the same
language, and the comparability between their rigid derivations means G耠also
satisﬁes requirement (2).
Now Lemma 3.10 implies |Ł(G耠)| ≤|PrG耠|2
|NG耠|−1
. We therefore have
|Ł(Gπ)| = |Ł(G耠)| ≤22
|NG耠|+|PrG耠|−1
< 222|π|.
This concludes the proof.
4 Technical lemmas
In Section 5 we will prove that for regular simple Π2-proofs π and π耠if π 䁄䀼π耠
then L(Gπ耠) ⊆Ł(Gπ). Before considering the theorem, however, we require addi-
tional results concerning the ﬁne structure of proof grammars. In Section 4.1 we
introduce the notion of homomorphism between proof grammars as a means to
test language containment. Section 4.2 highlights a number of properties relating
to derivations in proof grammars and Section 4.3 prepares the ground-work for
replacing sub-proofs by ones with comparable grammars.

24
|
B. Afshari, S. Hetzl, and G. Leigh
4.1 Comparing grammars
An easy way to compare the languages induced by grammars is by providing a
function mapping non-terminals of one grammar into another preserving rigid
derivability. In the simplest form (which is all that is required here) this is given
by a homomorphism as described below. First we need the following deﬁnitions.
Controlled β-reduction
We generalise the relation of β-reduction to obtain a ﬁner relation between terms.
Given two λ-terms S and T and a (possibly empty) set of variables X ⊆V, we write
S 䀚䀠X T if one of the following conditions hold.
–
S = T;
–
S = S0 ⋅S1, T = T0 ⋅T1 and Si 䀚䀠X Ti;
–
S = λα.S0, T = λα.T0 and S0 䀚䀠X T0;
–
S = (λα.S0) ⋅S1, α ∈X and T = S0[α/S1].
Notice that S 䀚䀠V T is the usual 1-step parallel β-reduction. We write S 䀚䀠T iﬀ
S 䀚䀠V T. This is not to be confused with S 䀚䀠0 T which holds iﬀS = T. Also let
S 䀚䀠∗
X T denote the (reﬂexive) transitive closure of S 䀚䀠X T.
Following the deﬁnition of S 䀚䀠T we deﬁne acanonical function rT,S mapping
positions in T to their corresponding position in S:
rT,S(⟨⟩) = ⟨⟩
r(T0⋅T1),(S0⋅S1)(ip) = i rTi,Si(p),
for i ∈{0, 1}
r(λα.T0),(λα.S0)(0p) = 0 rT0,S0(p)
rS0[α/S1],(λα.S0)⋅S1(p) =
{
{
{
1p耠,
if p = qp耠, q ∈Free(α, S0) and p耠∈Pos(S1)
00p,
otherwise
where Free(α, S0) denotes the positions in S0 marking free occurrences of α.
Homomorphism function
Let F and G be rigid proof grammars and f : NF →NG. If ΣF ⊆ΣG then f naturally
extends to a function (.)f : Terms(ΣF ∪NF) →Terms(ΣG ∪NG) given by
αf = f(α)
if α ∈NF,
(λα.S)f = λαf .Sf
af = a
if a ∈ΣF,
(S ⋅T)f = Sf ⋅Tf

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
25
Deﬁnition 4.1 (Homomorphism). Let F, G be rigid grammars and suppose ΣF ⊆ΣG
and SF ⊆SG. A homomorphism from F into G is a function f : NF →NG such that
1.
f(σ) = σ for every σ ∈SF;
2.
f(a) has the same type as a for every a ∈NF;
3.
f(α) ∈RG iﬀα ∈RF;
4.
a ⊲F b implies f(a) ⊲G f(b);
5.
for each ρ = (a →S) ∈F, there is a derivation ρf = ⟨ρi, pi⟩i<k : f(a) →Sf in G
such that ρf(i)|pi ∈RG only if i = 0;
6.
For every rigid derivation d = ⟨(ai →Si), pi⟩i<l : σ →S in F with σ ∈SF and
every j0, j1 < l, if f(aj0) = f(aj1) and j0 ≈d j1 then aj0 = aj1.
We write f : F →G to stipulate that ΣF ⊆ΣG, SF ⊆SG and f is a homomorphism
from F to G.
Notice that condition 6 is trivially satisﬁed if f is injective, thus its only role is for
in the case of Contraction Reduction.
A homomorphism f : F →G extends to a function (.)f : Der(F) →Der(G) in
the obvious way: given a derivation d = ⟨ρ, p⟩e: S →T in F, suppose ef : d(1)f →
Tf is already deﬁned and set df := ⟨ρf , p⟩ef : Sf →Tf in G.
Lemma 4.2. Suppose f : F →G is a homomorphism. If d: S →T is a rigid deriva-
tion in F then df : Sf →Tf is a rigid derivation in G.
Proof: Let F and G be as above, d = ⟨(ai →Si), pi⟩i<k : S →T a rigid derivation
in F and df = ⟨(bj →Mj), qj⟩j<lh(df ) : Sf →Tf the derivation in G induced by f.
First suppose j0, j1 < lh(df) are such that j0 ≈df j1 and bj0 = bj1 ∈RG.
Condition 4 (combined with the deﬁnition of d 㨃→df) implies that there are i0, i1 <
lh(d) such that bjl = f(ail) and qjl = pil for l = 0, 1. Let j∗< j0, j1 be the index
witnessing j0 ≈df j1. Set j ≤j∗be the greatest index such that bj = f(ai∗) for some
i∗< lh(d). We now verify that i∗witnesses i0 ≈d i1: To obtain a contradiction,
suppose for l = 0 or l = 1 there is a non-terminal ai with i∗< i < il such that
pi ≤pl and ail ⊲F ai. By condition 4 we have bjl = f(ail) ⊲G f(ai). Let f(ai) = bj耠.
By the deﬁnition of j we know for every j∗≥j耠> j, bj耠∉f({ai | i ≤lh(d)}).
Therefore, j耠> j∗, and since bjl ⊲G bj耠we see that bj耠violates j0 ≈df j1, hence we
are done. Since i0 ≈d i1, from condition 6 we deduce ai0 = ai1 so, since d is rigid,
T|pi0 = T|pi1. But then Tf|qj0 = Tf|qj1 as required.
To check the second condition of rigidity for df, suppose df(j)|x = λα.Sf
0 for
x < qj and bj = α ∈RG. Note that for any term T and position y, Tf|y = (T|y)f. In
particular, since α is also rigid there is i < lh(d) such that df(j) = (d(i))f, f(ai) = bj
with ai ∈RF, and pi = qj. Then we have d(i)|x = λai.S0 and so by rigidity of d
there exists x < y < pi such that d(i)|y = λb.S1 and ai ⊲F b. Let β = f(b). Then
df(j)|y = λβ.Sf
1 and by condition 4 α ⊲G β.

26
|
B. Afshari, S. Hetzl, and G. Leigh
Since homomorphisms ﬁx terms from ΣF we conclude
Corollary 4.3. Suppose F and G are rigid proof grammars and there is a homomor-
phism f : F →G. Then L(F) ⊆Ł(G).
4.2 Partitioning
Let π be a proof ending in a cut. The grammar Gπ can be viewed as the union of
the two disjoint subgrammars G0
π|0 and G1
π|1 and ‘connecting’ production rules (i.e.
rules introduced by the cut). A full derivation d in Gπ can therefore be permuted
to the form d1d2 ⋅⋅⋅dk where each di is a full derivation in either G0
π|0 or G1
π|1, plus
one direction of the connecting rules. The next lemma demonstrates that in the
case of cuts on (simple) Π2-formulæ, there can be at most three such ‘alternations’
between the two subgrammars. This observation will be particularly relevant in
the analysis of the Quantiﬁer Reduction rule (Lemma 5.6).
Lemma 4.4 (Cut Partition). Suppose π is the simple Π2-proof given below where A
is assumed to be a Π2 formula.
π0 ⊢Γ, A
π1 ⊢∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π ⊢Γ, ∆
For F ∈Γ and N ∈Term(Σπ), if d: σ0
F →N is a rigid derivation in Gπ then there is a
permutation d耠= d1d2d3d4 : σ0
F →N of d such that
–
d1 : σ0
F →M1 is a full derivation in G0
π0 ∪{τ0
A →σ1
̄A};
–
d2 : M1 →M2 is a rigid derivation G1
π1 ∪{τ1
̄A →σ0
A};
–
d3 : M2 →M3 is a derivation in G0
π0;
–
d4 : M3 →N is a derivation using only the rules {τ0
F →τ⟨⟩
F | F ∈Γ} ∪{τ1
F →
τ⟨⟩
F | F ∈∆}.
Proof: The derivation d耠is obtained through permuting the production rules
so that we fully re-write the non-terminals of a subgrammar Gi
πi before passing
(through the cut on A) to those of G1−i
π1−i. In this way it is clear how to obtain
full derivations d1 and d2 satisfying the requirements such that d1d2 is a sub-
sequence of d. Note, as d1 and d2 are full, M1 and M2 are, respectively, terms in
Σπ ∪{σ1
̄A} ∪{τ0
F | F ∈Γ} and Σπ ∪{σ0
A} ∪{τ0
F | F ∈Γ} ∪{τ1
F | F ∈∆}. Finally, to
obtain d3 we rewrite (according to d) all occurrences of σ0
A in M2. Observe that
in doing so the non-terminal τ0
A will not be created: d3 writes each occurrence
of σ0
A in M2 to a term of the form λα.S where α is the unique eigenvariable for
the external universal quantiﬁer in A; the deﬁnition of ⊲π and the restriction on
rigid derivations implies d3 may not utilise a production rule of the form α →τq
A,

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
27
so τ0
A cannot appear in M3. Therefore, the only non-terminals from Gπ in M3 are
{τ0
F | F ∈Γ} ∪{τ1
F | F ∈∆} which will be written with the remaining of production
rules from prodτ(⟨⟩, Γ, ∆).
Theorem 4.5 (Partition). Let π be a simple Π2-proof and p ∈Pos(π). Denote by Gp
the sub-grammar of G comprising only those production rules writing non-terminals
in {σq
F, τq
F | p ≤q} ∪EV(π|p) with start symbols {σp
F | F in the end sequent of π|p}.
If N ∈Ł(Gπ), then there exists a rigid derivation d: σ →N in Gπ of the form d =
d0d1 ⋅⋅⋅dL where for all i ≤L,
–
di : Mi →Mi+1 is a full derivation in Gπ \ Gp if i is even;
–
di : Mi →Mi+1 is a full derivation in Gp if i is odd.
Proof: The proof is by induction on p. The base case p = ⟨⟩holds trivially, choos-
ing d0 = d. Suppose p = qj where j ∈{0, 1}. Let L耠and ⟨d耠
i⟩i≤L耠be given by the
induction hypothesis for q ∈Pos(π). For each i ≤L耠therefore d耠
i : Mi →Mi+1 is a
full derivation in Gπ \ Gq, if i is even, and in Gq otherwise.
First suppose the ﬁnal rule of π|q is a cut. By Lemma 4.4 for each odd i, d耠
i can
be replaced by a derivation of the form ei,0ei,1ei,2 : Mi →Mi+1 where ei,0 and ei,2
are full derivations in Gq0 = Gp and ei,1 is a full derivation in Gq1.
Suppose j = 1. Then we pick L = L耠and set
di =
{
{
{
ei−1,2d耠
iei+1,0
i ≤L even,
ei,1,
i ≤L odd,
where, if necessary, eL+1,0 = e−1,2 = ⟨⟩. If instead j = 0 we set L = 2L耠and for
each 2i ≤L耠we deﬁne
d4i = d耠
2i
d4i+2 = e2i+1,1
d4i+1 = e2i+1,0
d4i+3 = e2i+1,2.
Now suppose the rule at position q in π is not a cut. Notice that if e: a →S is
a derivation in Gq with a ∈NGq then e is either a derivation wholly in Gq0 or
a derivation wholly in Gq1. Thus for each odd i ≤L耠, d耠
i can be re-ordered as a
derivation ei,0ei,1 : Mi →Mi+1 where ei,0 is full in Gq0 and ei,1 is full in Gq1.
Moreover, observe that the two derivations are independent of one another, so
ei,1ei,0 : Mi →Mi+1. Using this fact it is straightforward to alter the arrangement
of derivations to obtain a satisfying sequence ⟨di⟩i≤L with L ≤L耠.
4.3 Lifting
Another ingredient required in the analysis of the Quantiﬁer Reduction rule
is commuting derivations with β-reduction. More precisely, given a derivation

28
|
B. Afshari, S. Hetzl, and G. Leigh
d: T →U and β-reduction R 䀚䀠X T, whether it is possible to ‘lift’ d to a derivation
e: R →S such that S 䀚䀠X U as in the ﬁgure below. This is not in general possible
as demonstrated by the example in Figure 3. Lemma 4.8 pins down suﬃcient
conditions for completing the square. Before this we deﬁne the reverse process
which can be visualised as ‘pushing’ a derivation through β-reduction.
R
S
T
U
e
d
X
X
(λx.f(x, x)) ⋅α
(λx.f(x, x))⋅?
f(α, α)
f(a, b)
e
d
X
X
Fig. 3. Lifting
Deﬁnition 4.6. Let e = ⟨ρi, pi⟩i<lh(e) : R →S be a derivation in grammar G and
suppose R 䀚䀠X T. The derivation eT is deﬁned by recursion on lh(e).
–
For lh(e) = 0, eT := ⟨⟩;
–
For lh(e) = n + 1, eT := eT
0⟨ρn, qi⟩i≤k where e0 = ⟨ρi, pi⟩i<n and {qi | i ≤k} is
an enumeration of {q | rT,R(q) = pn}.
It is easily seen that
Lemma 4.7. If e: R →S, R 䀚䀠X T and eT : T →U then S 䀚䀠X U, and if d is strongly
rigid, so is eT.
Lemma 4.8 (Lifting). Let d = ⟨ai →Si, pi⟩i<k : T →U be a strongly rigid deriva-
tion in grammar G and R 䀚䀠X T. Suppose
1.
for all positions q0, q1, if rT,R(q0) = rT,R(q1) then the subderivations of d from
q0 and q1 are permutations of one another;
2.
if ai ∈X then there exists p < pi and non-terminal α
̸∈X such that ai ⊲α and
U|p = λα.(U|p0).
Then there exists a strongly rigid derivation e: R →S such that eT is a permutation
of d and S 䀚䀠X U.
Proof: Let rT,R be the canonical function mapping positions in T to their corre-
sponding position in R. To each p ∈Pos(S) we can associate a particular position
in T corresponding to p. Thus let r−1
T,S be a function such that
r−1
T,S(p) ∈{q | rT,S(q) = p}
for every position p. We now deﬁne e = f(d) recursively:

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
29
–
For k = 0, f(d) = ⟨⟩;
–
For k = l + 1, if pl = r−1
T,R(p)q for some maximal p ∈Pos(R) and some q,
set f(d) = f(d0)⟨al →Sl, pq⟩where d0 = ⟨ai →Si, pi⟩i<l, otherwise set
f(d) = f(d0).
f(d) is well-deﬁned since condition 1. ensures that f(d) is invariant under the
choice of the inverse r−1, and condition 2. guarantees that every applicable pro-
duction rule in d will be also freely applicable in f(d).
5 Reductions
We begin with showing that the simplest reductions yield homomorphisms.
Lemma 5.1. Suppose π 䁄䀼π耠is an instance of a reduction rule in Figure 1 or 2 except
Contraction or Quantiﬁer Reduction. Then L(Gπ耠) ⊆Ł(Gπ). If the reduction is not a
case of Weakening Reduction then in fact L(Gπ耠) = Ł(Gπ).
Proof: Suppose π 䁄䀼π耠is and instance of Axiom Reduction and
π0
Γ, A
A, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π|p ⊢Γ, A
π0
π耠|p ⊢Γ, A
A homomorphism f : Gπ耠→Gπ can be easily given by a function which maps a
non-terminal νpq
F for ν ∈{σ, τ} and pq ∈Pos(π耠) with q
̸= ⟨⟩to the corresponding
ones in π at position p0q and is identity on all other non-terminals. Consider a
rule σp
F →S in π耠then σ0p →f(S) is a production rule in π. If F ∈Γ, σp
F →σp0
F is
also a production rules in Gπ; otherwise, F = A and the sequence
σp
A →σp1
A →τp1
̄A →σp0
A
is a derivation in π. In either case, we have a derivation f(σp
F) →f(S) in π as re-
quired. Conversely, one can deﬁne a homomorphism f : Gπ →Gπ耠by the function
below, hence L(Gπ) = Ł(Gπ耠).
f(νp
F) = νp
F
f(νp0q
F
) = νpq
F
f(σp1
A ) = f(τp1
̄A ) = σp
A
f(τp1
A ) = f(σp1
̄A ) = τp
A

30
|
B. Afshari, S. Hetzl, and G. Leigh
Now consider an instance of Weakening Reduction. Suppose
π0
Γ耠
−−−−−−−−w
Γ, A
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π|p ⊢Γ, ∆
π0
Γ耠
−−−−−−−−−−−−−−−−−−−−−−−w
π耠|p ⊢Γ, ∆
where Γ耠⊆Γ. A homomorphism from Gπ耠to Gπ is deﬁned as follows. The function
f : Nπ耠→Nπ is determined by
f(νpq
F ) = νp0q
F
for ν ∈{σ, τ} and every q
̸= ⟨⟩with pq ∈Pos(π耠|p);
f(훾) = 훾
for all other non-terminals.
Production rules from π耠are readily mapped to derivation in π and the remaining
conditions of d are trivially met.
Suppose instead that π 䁄䀼π耠is a case of rule permutation. Of particular in-
terest is if the reduction is the permutation of two cuts, for example π|p and π耠|p
are of the form
π0
Γ, A
π1
∆, B[x/β], ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−∀
∆, ∀xB, ̄A
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
∆, Λ, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π|p ⊢Γ, ∆, Λ
π0
Γ, A
π1
∆, B[x/β], ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, ∆, B[x/β]
−−−−−−−−−−−−−−−−−−−−−−−−−−∀
Γ, ∆, ∀xB
π2
Λ, ∀xB
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π耠|p ⊢Γ, ∆, Λ
where A is a Π2 formula and B is Σ1.
We begin showing L(Gπ耠) ⊆Ł(Gπ). This is achieved by considering the ho-
momorphism that maps, for i = 0, 1, 2, the copy of Gπi in Gπ耠to the copy in Gπ.
Explicitly, we deﬁne f : Nπ耠→Nπ as follows. For each position q, formula F and
ν ∈{σ, τ} set
f(νp000q
F
) = νp0q
F
f(νp001q
F
) = νp100q
F
f(νp1q
F
) = νp11q
F
.

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
31
The non-terminals arising from positions p0 and p00 in π耠are then appropriately
mapped to those in π so connections between the sub-grammars are preserved:
f(νp0
F ) =
{
{
{
νp0
F
if F ∈Γ
νp10
F
if F ∈∆∪{∀xB}
f(νp00
F
) =
{
{
{
νp0
F
if F ∈Γ
νp100
F
if F ∈∆∪{B[x/β]}
In all other cases (i.e. a is a non-terminal of Gπ耠but not of Gp
π耠|p) we set f(a) = a.
We now argue that if A is not quantiﬁer free and the last rule in π0 is not
weakening then f is a homomorphism. Since π is a simple proof, A has the form
∀xA0 for some Σ1 formula A0 and there is an eigenvariable α ∈EV(π0) such that
the last inference rule of π0 is
Γ, A0[x/α]
−−−−−−−−−−−−−−−−−−−−−−−∀
Γ, A
By the deﬁnition of ⊲π notice that ξ ⊲π α ⊲π τp0
A for every ξ ∈EV(π0) \ {α}. It is
clear that f respects the ordering ⊲耠
π when restricted to non-terminals from either
π0, π1 or π2. The only other cases we need show are
f(τp000
A
) ⊲π f(σp001
̄A
)
ξ ⊲π β ⊲π f(τp0
∀xB) ⊲π f(σp1
∀xB)
for every ξ ∈EV(π0). The ﬁrst inequation is given by the deﬁnition of ⊲π. The
second is determined by observing
ξ ⊲π τp0
A ⊲π σp1
̄A ⊲π σp100
̄A
⊲π β ⊲π τp10
∀xB ⊲π σp11
∀xB.
As f is injective on eigenvariables in π耠condition 6 is also satisﬁed and by Corol-
lary 4.3 we are done.
In the other cases, namely that A is quantiﬁer free or A has no eigenvariable
associated to it in π0, f need not be a homomorphism because for an eigenvari-
able ξ ∈EV(π0) we will have ξ
̸⊲π β but ξ ⊲耠
π β. Nevertheless, by the Cut Partition
Lemma 4.4 it is simple to show that f maps rigid derivations in Gπ耠to rigid deriva-
tions in Gπ.
The converse direction, L(Gπ) ⊆Ł(Gπ耠), is witnessed by the function f : Nπ →
Nπ耠given by
f(νp0q
F
) = νp000q
F
f(νp100q
F
) = νp001q
F
f(νp11q
F
) = νp1q
F
f(νp10
F
) =
{
{
{
νp001
F
if F = A
νp0
F
otherwise
f(νp1
F ) =
{
{
{
{
{
{
{
νp0
F
if F ∈∆
νp001
F
if F = A
νp1
F
otherwise
for each q, F and ν ∈{σ, τ}, and setting f(a) = a in all other cases which in all
cases is a homomorphism.

32
|
B. Afshari, S. Hetzl, and G. Leigh
We now proceed with Contraction Reduction. In this case the obvious renaming
of non-terminals is not injective and additional properties are required in order to
verify the preservation of rigidity i.e. condition 6 of homomorphism.
For the remainder of the section we use symbols x and y (possibly with in-
dices) as meta-variables for positions in terms to contrast with positions in proofs
which will be denoted by p, q, etc.
Lemma 5.2 (Contraction Reduction). If π, π耠are simple Π2-proofs and π 䁄䀼π耠is
an instance of Contraction Reduction, L(Gπ耠) = Ł(Gπ).
Proof: Suppose that the reduction π 䁄䀼π耠is an instance of Contraction Reduction
to position p as follows:
π0
Γ, A
π1
∆, ̄A, ̄A∗
−−−−−−−−−−−−−−−−−−c
∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π|p ⊢Γ, ∆
π0
Γ, A
π∗
0
Γ∗, A∗
π1
∆, ̄A, ̄A∗
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ∗, ∆, ̄A
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
Γ, Γ∗, ∆
−−−−−−−−−−−−−−−−−−−−−−−c
π耠|p ⊢Γ, ∆
Note that we have assumed the contraction is on a single formula
̄A; the case for
contraction of multiple formulæ is analogous. Consider the function f : Nπ耠→Nπ
deﬁned by
f(훾) = f(훾∗) = 훾
for 훾∈EV(π0)
f(νp00q
F
) = f(νp010q
F∗
) = νp0q
F
f(δ) = δ
for δ ∈EV(π1)
f(νp011q
F
) = νp10q
F
f(νp01
F
) = νp10
F
for F ∈∆∪{ ̄A}
f(νp01
F∗) = νp0
F
for F ∈Γ
f(νp0
F ) = νp10
F
for F ∈∆
f(νp0
F/F∗) = νp0
F
for F ∈Γ
f(a) = a
It is easy to verify that f transforms production rules in Gπ耠to derivations in Gπ.
For instance, the production rules τp00
A
→σp01
̄A
and τp010
A∗
→σp011
̄A∗
, from the cuts
in π耠on A and A∗, are transformed under f to τp0
A
→σp1
̄A
→σp10
̄A
and τp0
A
→
σp1
̄A →σp10
̄A∗respectively.
Condition 6 is the only non-trivial case to verify. Suppose, in search of a con-
tradiction, d = ⟨(ai →Si), yi⟩i<lh(d) : a0 →S is a strongly rigid derivation in Gπ耠
and i0, i1 < lh(d) are such that i) i0 ≈d i1, ii) f(ai0) = f(ai1) ∈Rπ and iii) ai0
̸= ai1.
We may assume d is the shortest rigid derivation satisfying these conditions, so
in particular for every i < lh(d), yi ≤yi0 or yi ≤yi1, both hold only if i = 0, and
lh(d) = max{i0 + 1, i1 + 1}. By the deﬁnition of f, (ii) and (iii) we may assume
ai0 = 훾∈EV(π0) and ai1 = 훾∗∈EV(π∗
0). The argument breaks into three cases:

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
33
1.
d writes one of the two non-terminals σp010
A∗
or σp00
A
;
2.
a0 ∈EV(π0)∪EV(π∗
0) or a0 ∈{σp00q
F
, σp010q
F
} for some q ∈Pos(π0) and simple
formula F;
3.
there exist distinct j0, j1 < lh(d) and formulæ F0, F1 ∈Γ such that for each
k ∈{0, 1}, 0 < jk < ik, yjk ≤yik, aj0 = σp0
F0 and aj1 = σp0
F∗
1 .
Notice that the failure of 1 implies either 3 or that a0 is a non-terminal from one of
π0 or π∗
0, a condition that, by the minimality of d, is equivalent to 2.
First suppose 1 holds. Due to the minimality of d the derivation must pass
through (from right to left) at least one of the two marked cuts, so there is i ≥j
such that either ai = τp01
̄A
and Si = σp00
A
, or ai = τp011
̄A∗
and Si = σp010
A∗
. This is only
possible if ̄A contains a universal quantiﬁer and so, by simplicity of π, ̄A cannot be
in the class Π2, that is, A = ∀x∃yA0 for some quantiﬁer-free A0. But then we may
ﬁnd an eigenvariable of EV(π1) that is written by d and contradicts assumption
(i).
Suppose 2 holds; in particular that a0 ∈EV(π0) or a0 = σp00q
F
for some q ∈
Pos(π0) and simple formula F. Since ai1 ∈EV(π∗
0) and y0 < yi1 there exists j0 < i1
such that y0 < yj0 ≤yi1 and either aj0 = τp00
A
or aj0 ∈{τq
F | q ≤p and F is simple}
(if the production rule in d giving rise to aj0 writes an eigenvariable from EV(π耠) \
EV(π0) then in fact aj0 = τq
F for some q < p and some F). Assuming 1 does not hold
the latter case will hold for some choice of j0 whence there also exists j0 ≤j1 < i1
such that aj1 ∈{σp
F | F ∈Γ}. But then there will be j0 < i < j1 such that yi ≤yj1 ≤
yi1, ai ∈EV(π耠) \ EV(π耠|p) and ξ ⊲耠
π ai for every ξ ∈EV(π耠|p), contradicting (i).
If 3 holds then similar to the above argument there must exist i < lh(d) such
that ai ∈EV(π耠) \ EV(π耠|p) and ξ ⊲耠
π ai for every ξ ∈EV(π耠).
By Lemma 4.2 we conclude L(Gπ耠) ⊆Ł(Gπ). The converse inclusion holds be-
cause f is, in a suitable sense, surjective. In particular, for every rigid derivation
d in Gπ there exists a derivation d耠in Gπ耠such that d is a permutation of f(d耠).
d耠is chosen by replacing each sub-derivation that resides wholly within π0 by its
counterpart in π∗
0 if this sub-derivation is immediately preceded or succeeded by
the production rules τp10
̄A∗
→τp1
̄A or σp1
̄A →σp10
̄A∗. This operation is guaranteed to
yield a derivation in Gπ耠by the Partition Lemma for Cut which implies that there is
no derivation in Gπ that write σp0
A to a term containing τp0
A and involves only rules
taken from π0.
Before we proceed with Quantiﬁer Reduction we need the following lemmas.
Lemma 5.3. If π is a simple Π2-proof, d: τp
A →S is a derivation in Gπ and S|x =
α ∈EV(π|q) for some x ∈Pos(S) and p < q ∈Pos(π) then there exist y < x and
β ∈EV(π) such that S|y = λβ.(S|y0) and α ⊲β.

34
|
B. Afshari, S. Hetzl, and G. Leigh
Proof: By examination of the deﬁnition of Gπ.
Lemma 5.4 (Substitution). Let π be a regular proof, s a term whose free variables
do not appear in EV(π) and α
̸∈EV(π). Then for every d: M →N in Gπ[α/s] there
exists a derivation d耠: M耠→N耠in Gπ such that M = M耠[α/s] and N = N耠[α/s] and
d耠is strongly rigid iﬀd is strongly rigid.
Proof: Let f be the natural homomorphism from Gπ to Gπ[α/s]. Notice f is surjective
on derivations up to permutation.
Let d = ⟨(ai →Si), yi⟩i<lh(d) : S →T be a derivation. Recall the relation ∼d deﬁned
in Section 3.3. We could instead deﬁne ∼d on the set Pos(T). For x0, x1 ∈Pos(T),
x0 ∼d x1 if and only if there exists j0, j1 < lh(d) such that
1.
x0 = yj0 and x1 = yj1,
2.
aj0 = aj1 ∈R,
3.
for every i0 < i < lh(d) and k ∈{0, 1}, if ai ∈R and yi ≤yjk then aji
̸⊲ai.
The relation ∼d on positions (as opposed to indices) is not in general transitive but
it suﬃces to deﬁne rigidity and is a useful alternative. For example,
Lemma 5.5. Let d: S →T be a derivation and suppose d耠is a permutation of d.
If d耠is a derivation and ∼is deﬁned on positions then ∼d=∼d耠. In addition, ∼d is
independent of the choice of S.
Lemma 5.6 (Quantiﬁer Reduction). If π and π耠are the simple Π2-proofs and π 䁄䀼
π耠is an instance of Quantiﬁer Reduction L(Gπ耠) = Ł(Gπ).
Proof: Suppose that the reduction π 䁄䀼π耠is an instance of Quantiﬁer Reduction
to position p as follows:
π0
Γ0, Aα
−−−−−−−−−−−−−−−−−−−−∀
Γ0, ∀x Ax
π1
Γ1, ̄As
−−−−−−−−−−−−−−−−−−−−∃
Γ1, ∃x ̄Ax
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π|p ⊢Γ0, Γ1
π0[α/s]
Γ0, As
π1
Γ1, ̄As
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−cut
π耠|p ⊢Γ0, Γ1
where At abbreviates A[α/t]. Let G = Gπ and G耠= Gπ耠. We begin showing L(Gπ耠) ⊆
Ł(Gπ).
Suppose a ∈NG耠and let d: a →T be a full strongly rigid derivation in G耠.
We may assume d is partitioned according to the Partition Theorem 4.5, whence
d = d0d1 ⋅⋅⋅d2L and for each i ≤L, di : Si →Si+1 is a full derivation in G耠\ G耠
p, if
i is even, and in G耠
p otherwise. We determine a term T耠䀚䀠∗T and rigid derivation
d耠: a →T耠in G by recursion on L.

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
35
If L = 0, d = d0 is a derivation solely in G耠\ G耠
p and hence also a derivation
in G. So suppose L > 0. The Cut Partition Lemma 4.4 determines a strongly rigid
permutation of d1 of the form e0e1e2e3e4 where
–
e0 : S1 →S1
1 is derivation using only rules in {σp
F →σpi
F | i < 2 ∧F ∈Γi};
–
e1 : S1
1 →S2
1 is a full derivation in the grammar G耠
p0;
–
e2 : S2
1 →S3
1 is a full derivation in (G耠
p1 \ {τp1
̄As });
–
e3 = ⟨(τp1
̄As →σp0
As ), xi⟩1≤i≤k : S3
1 →S4
1 = S3
1[τp1
̄As /σp0
As ];
–
e4 = ex1
4,1 ⋅⋅⋅exk
4,k : S4
1 →S2 where for each 1 ≤i ≤k, e4,i is a derivation of
S2|xi from σp0
As using only rules in G耠
p0, and exi
4,i is the induced derivation of
S4
1[xi/S2|xi] from S4
1 obtained by adjusting e4,i to S4
1.
The Substitution Lemma 5.4 provides translations of e1 and e4 to derivations
̂e1 : S1
1 →̂S2
1 and ̂e4 = ̂ex1
4,1 ⋅⋅⋅̂exk
4,k :
̂S4
1 →̂S2 in Gp0 such that
S2
1 = ̂S2
1[τp00
Aα /τp0
As ][α/s]
S4
1 = ̂S4
1[σp0
As /σp00
Aα ]
S2 = ̂S2[α/s].
Within Gπ|p there is a simple derivation of s from α (i.e., α →τp0
∀xAx →σp1
∃x ̄Ax →s)
which, when combined with ̂e1 and the natural translation of e2 into Gp10, yields
a derivation e = e0 ̂e1 ̂e2 : S1 →̂S3
1 = S3
1[τp1
̄As /τp10
̄As ].
The derivation e3, when translated to Gπ|p,⁴ becomes
̂e3 :
̂S3
1 →S3
1[τp1
̄As /(λα. σp00
Aα ) ⋅s]
and may be connected with e and ̂ex100
4,1 ⋅⋅⋅̂exk00
4,k to yield the derivation ̂e given by
e0 ̂e1 ̂e2 ̂e3 ̂ex100
4,1 ⋅⋅⋅̂exk00
4,k : S1 →S耠
2 = S2[x1/(λα. ̂S2|x1) ⋅s] ⋅⋅⋅[xk/(λα. ̂S2|xk) ⋅s].
Clearly S耠
2 䀚䀠α S2. All that remains is to show that the derivation d2 ⋅⋅⋅d2L : S2 →
T ‘lifts’ to a derivation ̂d2 : S耠
2 →
̂T such that d0 ̂e ̂d2 : a →
̂T is rigid and
̂T 䀚䀠T
as then applying the induction hypothesis to ̂d2 will determine a rigid derivation
d耠: a →T耠in G such that T耠䀚䀠T.
First we note the following. Suppose y0 and y1 are distinct positions in S2 such
that S2|y0 = S2|y1 ∈RG耠and rS2,S耠
2(y0) ∼d0 ̂e rS2,S耠
2(y1). If neither y0 nor y1 has the
form xi1y for any i ≤k and position y then by the choice of ̂e and strong rigidity
of d in fact y0 ∼d0d1 y1. If y0 ≥xi1 however, then since S2|y0 is an eigenvariable
outside π|p, also y0 ∼d0d1 y1.
We can now verify that the lifting lemma can indeed be applied to d2 ⋅⋅⋅d2L
to obtain a term ̂T 䀚䀠T and derivation ̂d2 : S耠
2 →
̂T: The ﬁrst condition for lifting
4 Each (τp1
̄As →σp0
As) is readily translated to τp10
̄As
→τp1
∃x ̄Ax ⋅s →σp0
∀xAx ⋅s →(λα.σp00
Aα ) ⋅s.

36
|
B. Afshari, S. Hetzl, and G. Leigh
is provided by the argument in the previous paragraph in the case rS2,S耠
2(y0) =
rS2,S耠
2(y1); the second condition follows from Lemma 5.3. The previous argument
also suﬃces to deduce that d0 ̂e ̂d2 is rigid. As applying the induction hypothesis
to ̂d2 does not aﬀect rigidity, we are done.
The converse direction, namely L(Gπ) ⊆Ł(Gπ耠), is more straightforward. Ev-
ery derivation e starting from α with lh(e) ≥3 will have e(1) = τp0
∀xAx, e(2) = σp1
∀xAx
and e(3) = s. Similarly, for any derivation e耠in Gπ, if i < lh(e耠) and e耠(i)|x has
the form (λα.S0) ⋅S1 then S1 = s. These observations allow a simple translation
of derivations in Gπ to derivations in Gπ耠preserving rigidity. Let d: a →S be a
derivation in Gπ where a and S contain neither τp1
∀xA nor σp0
∀xA, and let S 䀚䀠∗
α S耠
be the term in which all abstractions on α have been reduced. Then there exists a
derivation d耠: f(a) →f(S耠) where f : Nπ →Terms(Σπ ∪Nπ耠) is deﬁned by
f(α) = f(τp0
∀xAx) = f(σp1
∃x ̄Ax) = s
f(νp00q0
F
) = νp0q0
F[α/s]
f(νp10q1
F
) = νp1q1
F
for ν ∈{σ, τ}, q0 ∈Pos(π0) and q1 ∈Pos(π1), and f(a) = a in all other cases.
Finally we may deduce that d耠is rigid whenever d is strongly rigid by an induction
on lh(d) using Lemma 4.7. As f is the identity function on terms in Terms(Σπ), we
conclude L(Gπ) ⊆Ł(Gπ耠).
6 Conclusion
We have established the following theorems.
Theorem 6.1. Let π0, π1, . . . , πk be a sequence of simple Π2-proofs such that πi+1
is obtained from πi by the reduction steps outlined in Section 2.1. Then L(Gπk) ⊆
Ł(Gπ0). If, moreover, no step in the reduction is an instance of weakening reduction
then L(Gπ0) = Ł(Gπk).
Theorem 6.2. Let π ⊢Γ be a simple Π2-proof where Γ is a set of Σ1 formulæ. There
exists a grammar G such that
1.
|PrG| ≤|π| + |Γ|,
2.
|Ł(G)| ≤222|π|,
3.
The formula ⋁F∈Γ F{t|(F,t)∈Ł(G)} is valid,
4.
If π耠is obtained from π by a sequence of simple Π2-proofs using the reduction
steps of Section 2.1 and all cuts in π耠are on quantiﬁer-free formulæ then the
Herbrand set for π耠, H(π耠), is contained in L(G); if no application of weakening
reduction is used then H(π耠) = Ł(G).
Proof: Let G be the modiﬁcation of Gπ which contains a single (fresh) start symbol
σ and production rules σ →(F, σF) for each F ∈Γ ∩Σ1. 1. is immediate from the

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
37
deﬁnition of Gπ, 2. is a consequence of Lemma 3.14 and 4. is a corollary of the pre-
vious theorem and the observation that if π contains only cuts on quantiﬁer-free
formulæ then, up to β-equivalence of terms, H(π) = Ł(G). Finally, 3. is deducible
from the ﬁrst part of 4. by observing that standard cut elimination strategies, such
as in [Troelstra and Schwichtenberg, 1996], preserve simplicity of proofs.
These results may be extended to proofs involving prenex Π2 and Σ2 formulæ.
This can be achieved by endowing the simply typed λ-calculus with product types
and pairing functions in the usual way. In addition to the typing deﬁnition for
simple Π1 and Σ1 formulæ deﬁned in the paper, for each position q and prenex Π2
formula A = ∀xB the two non-terminals τq
A and σq
̄A are assigned type type(τq
A) =
o × type(τq
B), and σq
A and τq
̄A have the dual type o →type(σq
B) where o denotes
the type of ﬁrst-order terms. In other words, if A = ∀x1 ⋅⋅⋅∀xm∃y1 ⋅⋅⋅∃ynB and B
is quantiﬁer free then
type(τq
A) = type(σq
̄A) = om+1 = o × (o × ⋅⋅⋅× o
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
m+1
)
type(σq
A) = type(τq
̄A) = o →o →⋅⋅⋅→o
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
m
→on+1.
The production rules for existential and universal introduction in Table 2 then
become respectively
prod(p, Π, 0) ∪{σp
∃yA →(s, σp0
A[y/s]), τp0
A[y/s] →τp
∃yA ⋅s},
prod(p, Π, 0) ∪{α →(τp
∀xA)0, τp0
A[x/α] →(τp
∀xA)1, σp
∀xA →λα.σp0
A[x/α]}
where (., .) is a (polymorphic) binary pairing function withﬁrst andsecondprojec-
tions (.)0 and (.)1. Aside from a few technical considerations all the lemmas and
proofs presented here generalise to proofs with cuts and end-sequents of prenex
Π2 and Σ2 formulæ.
6.1 Future work
We have shown the language of grammars deﬁned for simple Π2-proofs is invari-
ant under most cut reduction rules. It would be interesting to investigate under
which further transformations language invariance is maintained. For example,
as part of Lemma 5.1 we have shown that permuting two cuts does not change the
language of the proof grammar. In other words, composition by cut is an asso-
ciative operation which, as another interesting line of future work, would allow
the consideration of a category of proofs in the spirit of [Hyland, 2002]. Note, the

38
|
B. Afshari, S. Hetzl, and G. Leigh
results and techniques presented in this paper are independent of the exact syn-
tactic variant of the sequent calculus used and apply to two-sided, additive, etc.
calculi as well.
Further generalisation of this work would involve larger classes of cut-
formulæ of which there are two natural directions to proceed. The ﬁrst is to
generalise to cuts on a wider class of Π2 and Σ2-formulæ. The simplest extension,
which can already be realised, is to simple proofs with cuts on arbitrary prenex Π2
formulæ (this generalisation is described in detail above); more complex will be
considering boolean combinations of prenex Π2 and Σ2 formulæ and non-prenex
formulæ. A second generalisation would see proof grammars extended to prenex
Πn-formulæ. The relationship between proofs and grammars established thus far
suggests how to proceed: with Π1-cuts inducing non-terminals of type level 0 and
Π2-cuts inducing, in addition, non-terminals if type level 1, the conjecture is that
Πn+1-cuts will be amenable to analysis using non-terminals of level ≤n and order
n recursion schemes (a natural extension of context-free tree grammars to higher-
order). This is reminiscent to the relationship between the number of quantiﬁer
alternations in an induction and the type level of the functional obtained from
Gödel’s Dialectica interpretation [Gödel, 1958], see e.g. [Avigad and Feferman,
1999].
Acknowledgment: The authors’ research was supported by the Wiener Wissen-
schafts-, Forschungs- und Technologiefonds (WWTF) project VRG12-04.
References
Bahareh Afshari, Stefan Hetzl, and Graham E. Leigh. Herbrand Disjunctions, Cut Elimination
and Context-Free Tree Grammars. In Thorsten Altenkirch, editor, 13th International Confer-
ence on Typed Lambda Calculi and Applications (TLCA 2015), volume 38 of Leibniz Interna-
tional Proceedings in Informatics (LIPIcs), pages 1–16, Dagstuhl, Germany, 2015. Schloss
Dagstuhl–Leibniz-Zentrum fuer Informatik.
Jeremy Avigad and Solomon Feferman. Gödel’s functional (“dialectica”) interpretation. In Sam
Buss, editor, The Handbook of Proof Theory, pages 337–405. North-Holland, 1999.
Matthias Baaz and Stefan Hetzl. On the non-confluence of cut-elimination. Journal of Symbolic
Logic, 76(1):313–340, 2011.
Samuel R. Buss. The undecidability of k-provability. Annals of Pure and Applied Logic, 53:
75–102, 1991.
Samuel R. Buss. On Herbrand’s Theorem. In Logic and Computational Complexity, volume 960
of Lecture Notes in Computer Science, pages 195–209. Springer, 1995.
Alessandra Carbone and Stephen Semmes. A Graphic Apology for Symmetry and Implicitness.
Oxford Mathematical Monographs. Oxford University Press, 2000.

Herbrand Confluence for First-Order Proofs with Π2-Cuts
|
39
Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50(1):1–101, 1987.
Kurt Gödel. Über eine noch nicht benützte Erweiterung des ﬁniten Standpunktes. Dialectica,
12:280–287, 1958.
Willem Heijltjes. Classical proof forestry. Annals of Pure and Applied Logic, 161(11):1346–1366,
2010.
Jacques Herbrand. Recherches sur la théorie de la démonstration. PhD thesis, Université de
Paris, 1930.
Stefan Hetzl. On the form of witness terms. Archive for Mathematical Logic, 49(5):529–554,
2010.
Stefan Hetzl. Applying Tree Languages in Proof Theory. In Adrian-Horia Dediu and Carlos
Martín-Vide, editors, Language and Automata Theory and Applications (LATA) 2012, vol-
ume 7183 of Lecture Notes in Computer Science, pages 301–312. Springer, 2012a.
Stefan Hetzl. The Computational Content of Arithmetical Proofs. Notre Dame Journal of Formal
Logic, 53(3):289–296, 2012b.
Stefan Hetzl and Lutz Straßburger. Herbrand-Confluence for Cut-Elimination in Classical First-
Order Logic. In Patrick Cégielski and Arnaud Durand, editors, Computer Science Logic
(CSL) 2012, volume 16 of Leibniz International Proceedings in Informatics (LIPIcs), pages
320–334. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2012.
Stefan Hetzl and Lutz Straßburger. Herbrand-confluence. Logical Methods in Computer Sci-
ence, 9(4), 2013.
J. Martin E. Hyland. Proof theory in the abstract. Annals of Pure and Applied Logic, 114:43–78,
2002.
Richard McKinley. Proof nets for Herbrand’s Theorem. ACM Transactions on Computational
Logic, 14(1):5:1–5:31, 2013.
Anne S. Troelstra and Helmut Schwichtenberg. Basic Proof Theory. Cambridge: Cambridge
University Press, 1996.


Marco Benini
Proof-Oriented Categorical Semantics
Abstract: The proposition-as-types correspondence applied to ﬁrst-order logical
theories and the associated type systems says that they are diﬀerent although
equivalent presentations of the same entity. But the nature of this entity is not
clear, as these systems are interpreted in distinct categories and in diﬀerent ways.
In this contribution, an alternative framework is introduced so that the interpre-
tations of the logical system and of the type theory identify the same entity, which
acquires both, a logical and a computational meaning at the semantic level. It is
shown that this semantics is sound and complete, both in the logical and in the
type-theoretic sense. Also, it is shown that the standard models for interpreting
ﬁrst-order systems in category theory can be transformed in equivalent models in
the presented framework.
Keywords: Categorical semantics, Propositions-as-types
Mathematics Subject Classiﬁcation 2010: 03B20, 03C07, 03G30
1 Introduction
The proposition-as-types correspondence in its classic formulation [Howard,
1980] tells that the propositional intuitionistic logic and the simple theory of
types are diﬀerent but equivalent presentations of the same entity. Speciﬁcally,
considering the logical fragment limited to conjunction and implication, and the
type theory based on product and arrow types, the correspondence says that each
logical formula can be seen as a type, and each proof as a typed term, and vice
versa. The computational behaviour, that is, the reduction of typed terms, ac-
quires a logical meaning, namely, normalisation of proofs; conversely, each proof
acquires a computational meaning, being, thanks to the correspondence, a term
apt to be reduced.
In [Johnstone, 2002b, Section D.4.2], the propositional fragment is naturally
interpreted in a topos: each formula becomes a monomorphism, and the connec-
tives are interpreted as the operations in the lattice of subobjects. Also, the simple
theory of types is naturally interpreted in weak Cartesian closed categories: each
type becomes an object, so that a product type becomes a product in the category,
and an arrow type becomes an exponential object. Actually, the full power of a
Marco Benini: Dipartimento di Scienza e Alta Tecnologia, Università degli Studi dell’Insubria,
via Valleggio 11, I-22100 Como, Italy, e-mail: marco.benini@uninsubria.it

42
|
M. Benini
topos is not needed to interpret the propositional fragment, or conversely, we can
safely limit the interpretation of the simple theory of types to toposes, so that the
world where the logical and type-theoretic models live is the same. Nevertheless,
the diﬀerence between the models for logic and type theory is striking: in one case,
formulae are arrows, in the other, objects¹. So, in particular, these theories do not
seem to speak about the same entities.
Moving to the richer ﬁrst-order language, it is possible to construct a type the-
ory that allows to establish the propositions-as-types correspondence as in the
propositional case. But in the ﬁrst-order case, the class of categories used to pro-
vide models for the logical side of the correspondence is very diﬀerent from the
one used to assign a meaning to type theory. In fact, quantiﬁers are modelled by
suitable adjoint functors, according to Lavwere’s seminal paper [Lavwere, 1969],
while the nowadays prominent semantics of types interpret quantiﬁers as prod-
uct or function spaces, see [The Univalent Foundations Program, 2013, Chapter 1].
Although both interpretations of quantiﬁers arise as adjoints to some elementary
functor, they diﬀer: the pullback functor in Lavwere’s case, where the left and
right adjoint provide the interpretations for the existential and universal quanti-
ﬁers, respectively; functions spaces are right adjoint to the product functor _×X, as
they are just the exponential objects in the category of types; product spaces arise
as right adjoints to diagonal functors X 㨃→(X, X). At least in principle, it is possi-
ble to use toposes as a unifying class of categories, but it is hard to imagine that
a topos is the natural entity which is described by the ﬁrst-order language. Also,
as in the propositional case, the way to interpret formulae and types is radically
distinct, giving rise to diﬀerent models, even within the same class of categories.
In the present contribution, a novel class of categories is introduced, to give
a semantics both to ﬁrst-order intuitionistic theories and to their corresponding
type theories. But, diﬀerently from the standard way to interpret logic and type
theory, the models are the same to the point that formulae and types denote the
same objects, and similarly proofs and typed terms denote the same arrows. In
this way, the semantics poses the propositions-as-types correspondence as the
1 In a way, this is too simple: in fact, what is important is the structure of the entity interpreting
a formula. For example, a conjunction A ∧B interpreted as a type becomes a product, which is
deﬁned together with its projections and universal arrows, coming from its construction as a limit.
Conversely, A∧B interpreted as a logical formula becomes a meet in the lattice of subobjects of the
context of interpretation, thus an equivalence class of arrows with a common codomain, related
to the other subobjects via a suitable notion of order. The important part is not the product or the
equivalence class, but how the interpretation relates to other objects or other equivalence classes,
respectively. It is this structure which should emerge in the semantics, and it is the objective of
this contribution to make it explicit.

Proof-Oriented Categorical Semantics
|
43
central notion, which justiﬁes the “proof-oriented” attribute of the title. It will be
shown that the semantics is sound and complete both in the logical and in the
type-theoretical sense. Also, we will draw a brief sketch of the relations of the
proposed semantics with other ways to assign a meaning to ﬁrst-order logic.
The main feature of the proposed semantics, the one allowing to say that ﬁrst-
order logic and the corresponding type theory, are presentations of the same en-
tity, is that the models are point-free. This means that logical terms do not denote
elements in some universe, but rather they are used to construct the glue that
keeps together the interpretation of formulae and proofs, so that both logic and
computation will arise from the same structure. For example, considering arith-
metic, logical terms denote natural numbers in standard set-theoretic semantics,
like Kripke or Tarski models; in a standard categorical semantics, like Heyting
categories, logical terms denote special arrows, which correspond to the natural
numbers. On the contrary, in the framework that will be introduced in the follow-
ing, logical terms are used as ‘placeholders’ to describe the action of the substitu-
tion operation on a suitable category, whose objects denote logical formulae and
whose arrows denote logical proofs. It is really the algebraic action induced on the
category by the substitution operation that forms the ‘glue’ which allows to deﬁne
an interpretation for formulae and proofs. And, since any ﬁrst-order theory in this
framework has a classifying model, we will conclude that this model is exactly the
entity presented by the logical theory and the corresponding type theory.
2 Preliminaries
Before introducing the semantics, it is useful to precisely ﬁx the syntax of the logi-
cal systems we are going to use. This allows to introduce the type theories, so that
the propositions-as-types correspondence will hold by construction.
2.1 Logic
The logical systems we are interested in are usually described as being theo-
ries in the multi-sorted, ﬁrst-order, intuitionistic logic. Referring to [Troelstra and
Schwichtenberg, 2000] for an extensive presentation, these theories are described
by the following deﬁnitions.
Deﬁnition 1 (Logical signature). A logical signature ⟨S, F, R⟩is composed by a set
S of sort symbols, a set F of function symbols each one of the form f :s1×⋅⋅⋅×sn →
s0 where, for every 0 ≤i ≤n, si ∈S, and a set R of relation symbols each one of the

44
|
M. Benini
form r:s1×⋅⋅⋅×sn where, for every 1 ≤i ≤n, si ∈S. When n = 0, a function symbol is
usually called a constant, while a relation symbol is usually called a propositional
constant.
Deﬁnition 2 (Logical term). Given a signature ⟨S, F, R⟩, assume that there is a de-
numerable set Vs of logical variables for each s ∈S. Then, a logical term is induc-
tively deﬁned as follows, along with the set of its free variables:
1.
if v ∈Vs then v : s is a term and FV(v : s) = {v : s};
2.
if f :s1×⋅⋅⋅×sn →s0 ∈F and t1:s1, . . . , tn:sn are terms, then so is f(t1, . . . , tn):
s0, and FV(f(t1, . . . , tn) : s0) = ⋃n
i=1 FV(ti : si).
Deﬁnition 3 (Logical formula). Fixed a signature ⟨S, F, R⟩, a logical formula is in-
ductively deﬁned, along with its free variables, as:
1.
⊤and ⊥are formulae, and FV(⊤) = FV(⊥) = 0;
2.
if p : s1 × ⋅⋅⋅× sn ∈R and t1 : s1, . . . , tn : sn are terms, then p(t1, . . . , tn) is a
formula and FV(p(t1, . . . , tn)) = ⋃n
i=1 FV(ti : si);
3.
if A and B are formulae, so are A ∧B, A ∨B, and A ⊃B, and FV(A ∧B) =
FV(A ∨B) = FV(A ⊃B) = FV(A) ∪FV(B);
4.
if x ∈Vs and A is a formula, so are ∀x : s A and ∃x : s A, and FV(∀x : s A) =
FV(∃x : s A) = FV(A) \ {x : s}.
A notion of substitution is deﬁned in the standard way, see e.g. [Troelstra and
Schwichtenberg, 2000, Section 1.1.2].
Deﬁnition 4 (Substitution). Fixed a signature ⟨S, F, R⟩, the act of substituting x ∈
Vs with r : s in the term t : u, notation t[r/x] : u, is inductively deﬁned as:
1.
if v ∈Vu, then v[r/x] : u = r : s when x is identical to v and u is identical to s,
while v[r/x] : u = v : u otherwise;
2.
f(t1, . . . , tn)[r/x] : u = f(t1[r/x], . . . , tn[r/x]) : u.
The act of substituting x ∈Vs with the term r : s in the formula A, notation A[r/x],
is inductively deﬁned as:
1.
⊤[r/x] = ⊤, ⊥[r/x] = ⊥;
2.
p(t1, . . . , tn)[r/x] = p(t1[r/x], . . . , tn[r/x]);
3.
(A∧B)[r/x] = A[r/x]∧B[r/x], (A∨B)[r/x] = A[r/x]∨B[r/x], and (A ⊃B)[r/x] =
A[r/x] ⊃B[r/x];
4.
(∀y:u A)[r/x] = ∀y:u A[r[z/y]/x], with z:u
̸∈FV(A), when x:s is diﬀerent from
y:u, and (∀y:u A)[r/x] = ∀y:u A otherwise; (∃y:u A)[r/x] = ∃y:u A[r[z/y]/x],
with z : u
̸∈FV(A), when x : s is diﬀerent from y : u, and (∃y : u A)[r/x] = ∃y : u A
otherwise, that is, when x is identical to y and s is identical to u.

Proof-Oriented Categorical Semantics
|
45
Assum
Γ ⊢A
where A ∈Γ
Ax
Γ ⊢A
where A ∈T
Γ ⊢A Γ ⊢B
∧I
Γ ⊢A ∧B
Γ ⊢A ∧B
∧E1
Γ ⊢A
Γ ⊢A ∧B
∧E2
Γ ⊢B
Γ ⊢A
∨I1
Γ ⊢A ∨B
Γ ⊢A
∨I2
Γ ⊢B ∨A
Γ ⊢A ∨B Γ, A ⊢C Γ, B ⊢C
∨E
Γ ⊢C
Γ, A ⊢B
⊃I
Γ ⊢A ⊃B
Γ ⊢A ⊃B Γ ⊢A
⊃E
Γ ⊢B
⊤I
Γ ⊢⊤
Γ ⊢⊥
⊥E
Γ ⊢B
Γ ⊢A
∀I
Γ ⊢∀x : s A
(∗)
Γ ⊢∀x : s A
∀E
Γ ⊢A[r/x]
Γ ⊢A[r/x]
∃I
Γ ⊢∃x : s A
Γ ⊢∃x : s A Γ, A ⊢B
∃E
Γ ⊢B
(∗∗)
Fig. 1. The logical calculus: in (∗), the variable x : s must be fresh in the corresponding proof,
i.e., x : s
̸∈⋃C∈Γ FV(C), with Γ the set of assumptions; also, in (∗∗), the variable x : s must be
fresh, too, i.e., x : s
̸∈FV(B) ∪⋃C∈Γ FV(C).
It is worth remarking that substitution operates at the meta-level. Hence, if x is a
variable and k a constant of the same sort, we do not distinguish the term x[k/x]
from k within the syntax.
Deﬁnition 5 (Logical theory). A (logical) theory is a collection of formulae. A for-
mula in a theory T is said to be an axiom of T.
Deﬁnition 6 (Logical calculus). Fixed a signature and a theory T, a derivation or
proof Γ ⊢T A of a formula A from the ﬁnite set of formulae Γ, the assumptions, is
inductively deﬁned by the rules in Figure 1. These are the usual rules of natural de-
duction [Troelstra and Schwichtenberg, 2000, p. 36] for multi-sorted intuitionistic
ﬁrst-order logic, presented in the sequent notation.

46
|
M. Benini
2.2 Type theory
The type theories are constructed to validate the propositions-as-types interpreta-
tion. To avoid clashes with the categorical notation, used to describe the seman-
tics, and to emphasise the correspondence with the logical systems, we adopt the
logical notation whenever appropriate.
Thus, a type is just a logical formula. According to the propositions-as-types
correspondence, a typed term should be a logical derivation, but the deﬁnition of
proofs should be made more precise than we did in the previous section. In the
ﬁrst place, assumptions and their use have to be made explicit and traceable: this
is obtained using contexts.
Deﬁnition 7 (Context). Fixed a signature ⟨S, F, R⟩, assume that, for each type t,
there is a denumerable set Wt of typed variables; as usual, they are denoted as
x : t. Then, a context is any ﬁnite list of typed variables such that each typed vari-
able appears only once.
Out of the formal deﬁnition, the meaning is simply that each context denotes a
set of assumptions: so, x : t in a context means that the type t, a formula in the
propositions-as-types interpretation, is an assumption whose name is x. We re-
quired assumptions to form ﬁnite sets, and thus we require contexts to be ﬁnite
lists. It is evident that, forgetting the sequence, each ﬁnite list generates a ﬁnite
set. Conversely, having a sequence is handy to precisely deﬁne the semantics of
proofs, but, as we are going to show, essentially irrelevant, since a change in the
order of elements induces an isomorphic choice of objects and arrows for the in-
terpretation of formulae and derivations, respectively.
Deﬁnition 8 (Typed theory). A typed theory is a collection T of elements of the form
a : A, with a a constant and A a type. We require that each constant appears only
once, that is, a constant uniquely identify an axiom.
Every logical theory can be seen as a typed theory by decorating each axiom with a
distinct constant, and, vice versa, every typed theory generates a logical theory, by
forgetting the constants. So the correspondence between the two notions allows
to ignore their diﬀerence most of the times.
Deﬁnition 9 (Typed term). Given a signature ⟨S, F, R⟩, a typed theory T, and a con-
text Γ, a typed term is inductively deﬁned as:
1.
if x : t ∈Γ then Γ.x : t is a typed term, and FV(Γ.x : t) = {x : t};
2.
if a : A ∈T then Γ.a : A is typed term, and FV(Γ.a : A) = 0;
3.
if Γ.s : A and Γ.t : B are typed terms, then so is Γ.∧I(s, t) : A ∧B; moreover,
FV(Γ.∧I(s, t) : A ∧B) = FV(Γ.s : A) ∪FV(Γ.t : B);

Proof-Oriented Categorical Semantics
|
47
4.
if Γ.t : A ∧B is a typed term, then so are Γ.∧E1(t) : A and Γ.∧E2(t) : B; also,
FV(Γ.∧E1(t) : A) = FV(Γ.∧E2(t) : B) = FV(Γ.t : A ∧B);
5.
if Γ.t:A is a typed term, so are Γ.∨I1(t):A∨B and Γ.∨I2(t):B∨A, and, moreover,
FV(Γ.∨I1(t) : A ∨B) = FV(Γ.∨I2(t) : B ∨A) = FV(Γ.t : A);
6.
if Γ.s : A ∨B, Γ, u : A.t : C, and Γ, v : B.r : C are typed terms (and u : A and v : B
cannot occur in Γ), then so is Γ.∨E(s, t, r, u : A, v : B) : C, and
FV(Γ.∨E(s, t, r, u : A, v : B) : C) =
FV(Γ.s : A ∨B) ∪
∪(FV(Γ, u : A.t : C) \ {u : A}) ∪
∪(FV(Γ, v : B.r : C) \ {v : B}) ;
7.
if x ∈WA and Γ, x : A.t : B is a typed term, then Γ.⊃I(t, x : A) : A ⊃B is, too, and
FV(Γ.⊃I(t, x : A) : A ⊃B) = FV(Γ.t : B) \ {x : A};
8.
if Γ.s : A ⊃B and Γ.t : A are typed terms, then Γ.⊃E(s, t) : B is a typed term, too;
moreover, FV(Γ.⊃E(s, t) : B) = FV(Γ.s : A ⊃B) ∪FV(Γ.t : A);
9.
Γ.⊤I : ⊤is a typed term, and FV(Γ.⊤I : ⊤) = 0;
10. if Γ.t : ⊥is a typed term, so is Γ.⊥E(t) : B, and FV(Γ.⊥E(t) : B) = FV(Γ.t : ⊥);
11. if x ∈Vs and Γ.t : A is a typed term such that x : s
̸∈FV∗(Γ.t : A), then also
Γ.∀I(t) : ∀x : s A is a typed term, and FV(Γ.∀I(t) : ∀x : s A) = FV(Γ.t : A);
12. if Γ.t : ∀x : s A is a typed term and r : s is a logical term, then Γ.∀E(t, r) : A[r/x]
is a typed term, and FV(Γ.∀E(t, r) : A[r/x]) = FV(Γ.t : ∀x : s A);
13. if x ∈Vs, r : s is a logical term, and Γ.t : A[r/x] is a typed term, then also
Γ.∃I(t) : ∃x : s A is a typed term, and FV(Γ.∃I(t) : ∃x : s A) = FV(Γ.t : A[r/x]);
14. if Γ.t:∃x:s A and Γ, u:A.r:B are typed terms such that x:s
̸∈FV∗(Γ.r:B)∪FV(B),
then Γ.∃E(t, r, u : A)) : B is a typed term, and
FV(Γ.∃E(t, r, u : A)) : B) = FV(Γ.t : ∃x : s A) ∪
∪(FV(Γ, u : A.r : B) \ {u : A}) .
In the previous deﬁnition, FV∗(Γ.t : A) is the set consisting of those logical variables
x : s such that there are a type r and a typed variable y ∈Wr such that x : s ∈FV(r)
and y : r ∈FV(Γ.t : A). That is, FV∗(Γ.t : A) is the set of the free logical variables in
the set of used² assumptions in Γ.
2 Actually, this is an apparently more relaxed condition of freshness of a variable than the one
in Figure 1. In essence, the present condition says that the variable used to introduce a universal
quantiﬁcation, or to eliminate an existential one, must not occur among the assumptions which
are used via the assumption rule in the relevant subproofs. The other assumptions do not matter,
as they are not relevant to establish the validity of the conclusion, which is exactly the statement
that has to be proven in the meta-theory, and it should be evident.

48
|
M. Benini
A few remarks are due: the deﬁnition does not depend on the order of elements
within Γ, but only on its underlying collection of elements; the term constructors
have the same names as the logical inference rules and the same structure, thus
establishing the proposition-as-types correspondence; discharged assumptions
are rendered as typed variables occurring in a term, but not among its free typed
variables; the conditions on variables to be fresh in the corresponding proof, see
Figure 1, are reduced to require that a logical variable does not occur among the
free variables in the undischarged assumptions. The mapping between the stan-
dard constructors in type theory, e.g., abstraction, application, pairing, etc., is
immediate. Also, an evident notion of substitution is available for typed terms:
each free typed variable can be replaced by any typed term in the same context
provided the variable and the term share the same type.
As a computational system, the type theory operates by reducing typed terms.
It is beyond the scope of this contribution to analyse the reduction process—the
interested reader may look at normalisation in [Troelstra and Schwichtenberg,
2000, Chapter 6]. Instead, we present the reduction rules in the form of equali-
ties.
Deﬁnition 10 (Typed equality). Fixed a signature, equality of typed terms is induc-
tively deﬁned by the following rules: we will use the abbreviations
⃗x :
⃗A for x1 :
A1, . . . , xn :An, [ ⃗s/ ⃗y] for [s1/y1, . . . , sm/ym], and similar where appropriate; also,
r, s, t, are meta-variables for typed terms, while u, v, x, y, and z are proper variables,
and e stands for a logical term.
1.
if ⃗x : ⃗A.s : C = ⃗x : ⃗A.t : C then Γ.s[ ⃗r/ ⃗x]: C = Γ.t[ ⃗r/ ⃗x]: C where, for each 1 ≤i ≤n,
Γ.ri : Ai is a typed term;
2.
if Γ.s1 :B1 = Γ.t1 :B1, . . . , Γ.sm :Bm = Γ.tm :Bm, then Γ.r[ ⃗s/ ⃗y]:C = Γ.r[ ⃗t/ ⃗y]:C;
3.
Γ.t : A = Γ.t : A;
4.
if Γ.t : A = Γ.s : A then Γ.s : A = Γ.t : A;
5.
if Γ.t : A = Γ.s : A and Γ.s : A = Γ.r : A, then Γ.t : A = Γ.r : A;
6.
if Γ, u : A.s1 : C = Γ, u : A.t1[u/x] : C and Γ, v : B.s2 : C = Γ, v : B.t2[v/y] : C,
then Γ.∨E(r, s1, s2, u : A, v : B) : C = Γ.∨E(r, t1, t2, x : A, y : B) : C;
7.
if Γ, x:B.s:C = Γ, x:B.t[x/y]:C, then also Γ.⊃I(s, x:B):B ⊃C = Γ.⊃I(t, y:B):B ⊃
C;
8.
similarly, if Γ, u:A.s:B = Γ, u:A.t[u/v]:B, then Γ.∃E(r, s, u:A):B = Γ.∃E(r, t, v:
A) : B;
9.
Γ.t : ⊤= Γ.⊤I : ⊤;
10. Γ.∧E1(∧I(t, s)) : A = Γ.t : A;
11. Γ.∧E2(∧I(t, s)) : A = Γ.s : A;
12. Γ.∧I(∧E1(t), ∧E2(t)) : A ∧B = Γ.t : A ∧B;
13. Γ.∨E(∨I1(r), t, s, u : A, v : B) : C = Γ.t[r/u] : C;

Proof-Oriented Categorical Semantics
|
49
14. Γ.∨E(∨I2(r), t, s, u : A, v : B) : C = Γ.s[r/v] : C;
15. Γ.∨E(∨E(t0, t1, t2, u1 : A, u2 : B), t3, t4, u3 : C, u4 : D) : E =
= Γ.∨E(t0,∨E(t1, t3, t4, u3 : C, u4 : D),
∨E(t2, t3, t4, u3 : C, u4 : D), u1 : A, u2 : B) : E;
16. Γ, x : A.⊥E(t) : A = Γ.x : A;
17.
Γ.⊃E(⊃I(t, u : A), s) : B = Γ.t[s/u] : B;
18. if u : A
̸∈FV(Γ.t : A ⊃B), Γ.⊃I(⊃E(t, s), u : A) : A ⊃B = Γ.t : A ⊃B ;
19. Γ.∀E(∀I(t), e) : B[e/z] = Γ.t[e/z] : B[e/z];
20. if Γ.∀E(t, e) : B[e/x] = Γ.∀E(s, e) : B[e/x] for every logical term e of , then Γ.t :
∀x : s B = Γ.s : ∀x : s B;
21. Γ.∃E(∃I(t : A[e/x]) : ∃x : s A, r, u : A) : B = Γ.r[e/x][t/u] : B;
22. if Γ.∃E(r, t, x : A)) : B = Γ.∃E(r, s, x : A)) : B, Γ, x : A.t : B = Γ, x : A.s : B;
23. Γ.r : B = ∃E(t, r, x : A) : B with x : A
̸∈FV(r : B);
24. Γ.∃E(∃E(t, s, u : A), r, v : B) : C = Γ.∃E(t, ∃E(s, r, v : B), u : A) : C.
Rules (1)–(5) say that equality is an equivalence relation which is preserved by
substituting equals for equals, and rules (6)–(8) say that bounded typed variables
can be freely renamed. Rules (9)–(14), (16)–(19), and (21) are the standard reduc-
tions of product types, of sum types, β and η, and of universal and existential
types, see [Girard et al., 1989]. Rules (15), (23) and (24) are standard permutation
and simpliﬁcation rules, see [Troelstra and Schwichtenberg, 2000, Chapter 6].
Rule (20) and (22) establish when the parametric subproofs of two equal proofs,
are equal.
3 Semantics
The semantics of the logical systems and of the corresponding type theories is
based on category theory: informally, a type is interpreted as an object and a logi-
cal proof as an arrow. The structure of the category allows to interpret all the con-
nectives, while the logical terms generate, via substitution, the objects deputed to
interpret quantiﬁers. The categorical structure is, essentially, the one of distribu-
tive categories, used by Taylor [1999] to interpret propositional intuitionistic logic
plus a notion of substitution on the interpreted types.
Admitting the logical terms to form a groupoid [Mac Lane, 1998, p. 20], which
is a natural extension of being a set—which is a discrete category, that is, a cate-
gory whose only arrows are identities, while groupoids are categories whose ar-
rows are all isomorphisms—it becomes possible to use the very same structure to
generate a reasonable notion of equality at the semantic level, alongside quan-
tiﬁers. Informally, an arrow in a groupoid indicates that two speciﬁc terms are

50
|
M. Benini
equal by deﬁnition—which is evident when the arrow is the identity, but becomes
meaningful when the arrow is an isomorphism. This equality is naturally mapped
into an axiom of the logical theory or, equivalently, into a primitive arrow in the
model of the theory inside the category of interpretation. Moreover, the structure
of groupoid ensures that the generated equality is an equivalence relation, and
the mapping into the category via the substitution functor forces equality to be a
congruence. Actually, as it will be discussed in Section 5, using groupoids in the
very beginning allows to abstract over the structure of terms, retaining only what
is really needed to convey meaning to logic inside the semantics we are going to
illustrate.
3.1 Categories
In short, the semantics is deﬁned by the action the syntactical substitution pro-
cess, see Deﬁnition 4, performs on a category ℂwith enough structure. The ac-
tion is represented as a family Σ of functors, each one modelling the substitution
of a variable in an interpreted formula/type. Equivalently, the substitution func-
tors are the way to interpret the syntactical substitution operation in the semantic
level.
Deﬁnition 11 (Logical category). Fixed a signature, a logical category is a triple
⟨ℂ, 픾, Σ⟩such that
1.
ℂis a category with ﬁnite products, ﬁnite coproducts and exponentiation;
2.
픾is a groupoid of logical terms, that is, a category whose objects are all the
logical terms on the signature, and such that every arrow is an isomorphism;
3.
Σ = {ΣA(x : s): 픾→ℂ}A,x:s is a family of functors, called the substitution func-
tors, indexed by all the types and all the logical variables;
4.
each substitution functor ΣA(x : s) has a limit and a colimit;
5.
substitution functors preserve the syntactical substitution, that is, for any A,
x : s, and t : s, ΣA(x : s)(t : s) = ΣA[t/x](x : s)(x : s);
6.
substitution functors are stable with respect to variables, that is, for any x : s
and y : t, ΣA(x : s)(x : s) = ΣA(y : t)(y : t);
7.
moreover, for any variable x : s, and any term t : s,
(a) Σ⊥(x : s)(t : s) = 0, the initial object of ℂ;
(b) Σ⊤(x : s)(t : s) = 1, the terminal object of ℂ;
(c) for any A and B, ΣA∧B(x : s)(t : s) = ΣA(x : s)(t : s) × ΣB(x : s)(t : s), the
binary product in ℂ;
(d) for any A and B, ΣA∨B(x : s)(t : s) = ΣA(x : s)(t : s) + ΣB(x : s)(t : s), the
binary coproduct in ℂ;

Proof-Oriented Categorical Semantics
|
51
(e) for any A and B, ΣA⊃B(x : s)(t : s) = ΣB(x : s)(t : s)ΣA(x:s)(t:s), the exponential
object in ℂ;
(f) for any A and x : s, Σ∀x:s A(x : s)(x : s) = lim ΣA(x : s);
(g) for any A and x : s, Σ∃x:s A(x : s)(x : s) = colimΣA(x : s).
When we refer to the product of the category ℂ, we assume that a choice has been
made among the possible isomorphic objects which may be considered products.
And the same holds for the other categorical constructions we use, that is, coprod-
uct, exponentiation and the limit and colimit in (4).
It is worth remarking that, up to isomorphisms, the above mentioned choice does
not matter: it is a basic fact of category theory that all the limits on the same func-
tor are isomorphic, see, e.g., [Awodey, 2006].
There is an evident and natural way to assign an interpretation to any type:
Deﬁnition 12 (Interpretation of types). Given a logical category ⟨ℂ, 픾, Σ⟩over a
signature S, the interpretation of the type A is deﬁned to be MA = ΣA(x : s)(x : s),
for any variable x : s.
Because of (6) in Deﬁnition 11, this deﬁnition is well-founded.
It is worth noticing that, ﬁxed M, the requirement (5) in Deﬁnition 11 allows to
uniquely deﬁne the family Σ. Nevertheless, we prefer to derive the interpretation
of terms from the action of the substitution process over the category ℂ, since it is
really this action which induces a meaning, as it is evident in (7) of the deﬁnition
of logical category. Thus, it is the family Σ, which is the ‘glue’ referred to in the
Introduction, the structure that keeps together the interpretation of formulae so
that it can acquire a meaning allowing to use it as a model for logic.
Deﬁnition 13 (T-model). Given a typed theory T, a T-model ⟨ℂ, 픾, Σ, α⟩is such
that ⟨ℂ, 픾, Σ⟩is a logical category on the language of T, and α is map from the
theory T to Objℂsuch that there exists an arrow α(a : A): 1 →MA in ℂfor each
axiom a : A ∈T. This arrow will force all the axioms to be valid, see Deﬁnition 14,
hence the use of the name ‘model’.
3.2 Interpretations
To deﬁne the semantics of typed terms, it has to be remarked that a logical cate-
gory is distributive, i.e., A × (B + C) ≃(A × B) + (A × C) for any A, B, C ∈Objℂ. In a
logical category, it also holds that MA×M∃x:s B ≃M∃x:s A∧B, sometimes called
the Frobenius isomorphism. These isomorphisms will be denoted by ∆and ∆F, re-
spectively, and they come for free from Cartesian closure. Then, the interpretation

52
|
M. Benini
MB
MA
JΓ.t:B∧CK
/
JΓ.∧E1(t):BK
0
JΓ.∧E2(t):CK
.
MB × MC
π1
9
π2
%
MC
MA
JΓ.s:BK
y
JΓ.t:CK
%
JΓ.∧I(s,t):B∧CK

MB
MC
MB × MC
π1
e
π2
9
Fig. 2. The semantics of ∧E1, ∧E2 (left), and ∧I (right).
of a typed term x1 : A1, . . . , xn : An.t : B will be an arrow from MA1 × ⋅⋅⋅× MAn
to MB. Since changing the order of elements in the context x1 : A1, . . . , xn : An
induces an isomorphic product in the category, as it is immediate to check, inter-
pretation will be automatically deﬁned up-to-isomorphisms, in this very precise
sense.
Deﬁnition 14 (Typed terms semantics). Fixed a T-model ⟨ℂ, 픾, Σ, α⟩, the interpre-
tation of a typed term Γ.t : B, notation JΓ.t : BK, is inductively deﬁned as follows: to
simplify the notation, we pose Γ to be x1 : A1, . . . , xn : An, and A = A1 ∧⋅⋅⋅∧An,
1.
if x : Ai is a typed variable, JΓ.x : AiK = πi : MA →MAi, the i-th projector of the
product MA; this is the only point where we use the sequence of elements within
the context, and the reader is invited to check that reordering the elements re-
duces to choose an isomorphic projector in the isomorphic product arising from
the reordering;
2.
if a : B ∈T is an axiom, JΓ.a : BK = ! ∘α(a : B), with !: MA →1 the universal
arrow of the terminal object, and α(a : B) as in Deﬁnition 13;
3.
JΓ.∧I(s, t) : B ∧CK = (JΓ.s : BK, JΓ.t : CK), with (_, _) the universal arrow of the
product MB × MC, see Figure 2;
4.
JΓ.∧E1(t) : BK = π1 ∘JΓ.t : B ∧CK where π1 is the ﬁrst projector of the product
MB×MC; also, JΓ.∧E2(t):CK = π2 ∘JΓ.t:B∧CK where π2 is the second projector
of the product MB × MC, see Figure 2;
5.
JΓ.∨I1(t) : B + CK = ı1 ∘JΓ.t : BK, with ı1 the ﬁrst injection of MB + MC; similarly,
JΓ.∨I2(t) : B + CK = ı2 ∘JΓ.t : CK, with ı2 the second injection of the coproduct
MB + MC, , see Figure 3;
6.
JΓ.∨E(s, t, r, u : B, v : C) : DK = [JΓ, u : B.t : DK, JΓ, v : C.r : DK] ∘∆∘(1MA, JΓ.s :
B ∨CK), where [_, _] is the couniversal arrow of the coproduct (MA × MB) +
(MA × MC), (_, _) is the universal arrow of the product MA × (MB + MC), and
the arrow ∆is the distributive isomorphism, see Figure 3;

Proof-Oriented Categorical Semantics
|
53
MB
ı1
%
MA
JΓ.t:BK
<
JΓ.t:CK
"
JΓ.∨I1(t):B+CK
/
JΓ.∨I2(t):B+CK
/ MB + MC
MC
ı2
9
MA
JΓ.s:B∨CK
v
1MA
(
(1MA,JΓ.s:B∨CK)

JΓ.∨E(s,t,r,u:B,v:C):DK
z
MB + MC
MA
MA × (MB + MC)
∆

π2
g
π1
7
(MA × MB) + (MA × MC)
[JΓ,u:B.t:DK,JΓ,v:C.r:DK]

MA × MB
ı1
7
JΓ,u:B.t:DK
(
MA × MC
ı2
g
JΓ,v:C.r:DK
v
MB
Fig. 3. The semantics of ∨I1, ∨I2 (left), and ∨E (right).
MA × MB
JΓ.⊃I(t,x:B):B⊃CK×1MC

JΓ,x:B.t:CK
&
MC
MCMB × MB
ev
9
MA
JΓ.s:B⊃CK
x
JΓ.t:BK
%
(JΓ.s:B⊃CK,JΓ.t:BK)

JΓ.⊃E(s,t):CK
z
MCMB
MB
MCMB × MB
π1
f
π2
9
ev

MC
Fig. 4. The semantics of ⊃I (left) and ⊃E (right).

54
|
M. Benini
MA
JΓ[u/x].t[u/x]:B[u/x]K
&
JΓ.∀I(t):∀x:s B)K
/ M∀x : s B
πu
w
{MB[u/x]}u:s
M∀x : s B
#
{
πu

MA
JΓ.t:∀x:s BK
o
JΓ.∀E(t,u):B[u/x]K
{
⋅⋅⋅
MB[u/x]
⋅⋅⋅
Fig. 5. Semantics of ∀I (left) and ∀E (right).
7.
JΓ.⊃I(t, x : B) : B ⊃CK = tr(JΓ, x : B.t : CK), with tr the exponential transpose,
see Figure 4;
8.
JΓ.⊃E(s, t) : CK = ev ∘(JΓ.s : B ⊃CK, JΓ.t : BK) where ev is the exponential eval-
uation, see Figure 4;
9.
JΓ.⊤I : ⊤K =!: MA →1, the universal arrow of the terminal object;
10. JΓ.⊥E(t) : BK =! ∘JΓ.t : ⊥K, with !: 0 →MB the couniversal arrow of the initial
object;
11. JΓ.∀I(t) : ∀x : s B)K is the universal arrow MA →M∀x : s B of the limit on
ΣB(x : s). In fact, JΓ.t : BK: MA →MB and, by deﬁnition of M, JΓ[u/x].t[u/x] :
B[u/x]K: MA[u/x] →MB[u/x] for any logical term u : s. But, by construc-
tion of ∀I, x : s
̸∈FV∗(Γ.t : B), hence Γ[u/x] = Γ and A[u/x] = A. Therefore,
(MA, {J Γ.t[u/x] : B[u/x]K}u:s) is a cone on ΣB(x : s) and thus there is a unique
universal arrow to lim ΣB(x : s) = M∀x : s B, see Figure 5.
12. JΓ.∀E(t, u) : B[u/x]K = πu ∘JΓ.t : ∀x : s BK, with πu the projection corresponding
to the logical term u : s in the limit cone on ΣB(x : s) having M∀x : s B as vertex,
see Figure 5;
13. JΓ.∃I(t) : ∃x : s BK = ıu ∘JΓ.t : B[u/x]K, where ıu is the injection corresponding to
the term u : s in the colimit cocone on ΣB(x : s) having M∃x : s B as vertex, see
Figure 6;
14. JΓ.∃E(t, r, v:B):CK = !∘∆F∘(1MA, JΓ.t : ∃x : s BK), where ∆F is the Frobenius iso-
morphism, and !: M∃x:s A∧B →MC is the couniversal arrow of the colimit on
ΣA∧B(x:s). In fact, since JΓ, v:B.r:CK: MA∧B →MC, it follows that JΓ[u/x], v:
B[u/x].r[u/x] : C[u/x]K: M(A ∧B)[u/x] →MC[u/x], but, by construction of
∃E, A[u/x] = A and C[u/x] = C. Thus, (MC, {JΓ, v : B[u/x].r[u/x] : CK}u:s) is
a cocone on ΣA∧B(x : s) and so there is unique couniversal arrow to it from
colimΣA∧B(x : s) = M∃x : s A ∧B, see Figure 6.
Then, ﬁxed a theory T and a T-model, two typed terms Γ.t : A and Γ.s : B are
semantically equal whenever their interpretations are isomorphic in the evident
co-slice category, JΓ.t : AK ≅JΓ.s : BK. Also, a formula A is valid in a T-model when

Proof-Oriented Categorical Semantics
|
55
M∃x : s B
⋅⋅⋅
:
MB[u/x]
ıu
O
⋅⋅⋅
d
MA
JΓ.t:B[u/x]K
O
JΓ.∃I(t):∃x:s BK
;
MA
1MA
u
JΓ.t:∃x:s BK
(
(1MA,JΓ.t:∃x:s BK)

JΓ.∃E(t,r,v:B):CK

MA
M∃x : s B
MA × M∃x : s B
π1
i
π2
6
∆F

M∃x : s A ∧B
!
(
{MA × MB[u/x]}u:s
{ıu}u:s
5
JΓ,v:B[u/x].r[u/x]:CK
/ MC
Fig. 6. The semantics of ∃I (left) and ∃E (right).
there is an arrow p: 1 →MA. It is worth remarking that the axioms in T are valid
in any T-model via the α map. Also, it is important to remark again that reordering
the elements in a context, yields to isomorphic interpretations of types and typed
terms.
4 Soundness and Completeness
Fixed a theory T, a soundness result for the logical system states that, whenever
Γ.p : A is a typed term, i.e., a logical proof in the proposition-as-types correspon-
dence, any T-model in which all the assumptions are valid, makes A valid, too. A
completeness result is the converse. Because of the proof-oriented nature of the
semantics, this soundness result is almost immediate.
Theorem 1 (Logical soundness). If the formula A is derivable from Γ in the theory
T via the proof p, then A is valid in any T-model making all the assumptions valid.
Proof: Let Γ be x1 : B1, . . . , xn : Bn, the sequence being arbitrary. Since each as-
sumption is valid, there is 1 →MBi in the T-model for each 1 ≤i ≤n, thus
훾: 1 →MB1 ×⋅⋅⋅×MBn is the universal arrow of the product. But JΓ.p:AK: MB1 ×
⋅⋅⋅×MBn →MA, so JΓ.p:AK∘훾makes A valid. A diﬀerent ordering of assumptions
yields, evidently, to an isomorphic evidence of validity for A.

56
|
M. Benini
The soundness result for the type theory on T states that, if two typed terms are
equal, they have the same interpretation, up to isomorphisms. Showing this result
is long and tedious, so we just sketch its proof, which can be found in full details
in [Benini, 2013]. The key to the proof is to show that composing proofs by substi-
tuting assumptions with derivations, reduces in the semantics to the composition
of interpretations.
Lemma 2. Let ⃗x : ⃗A be the context x1 : A1, . . . , xn : An, and let Γ.ri : Ai be a typed
term for each 1 ≤i ≤n. Then, for any typed term ⃗x : ⃗A.t : B,
JΓ.t[r1/x1, . . . , rn/xn] : BK = J ⃗x : ⃗A.t : BK ∘(JΓ.r1 : A1K, . . . , JΓ.rn : AnK) .
Proof: By induction on the structure of the typed term ⃗x : ⃗A.t : B.
Theorem 3 (Soundness). If a typed equality Γ.s : A = Γ.t : A is derivable in the type
theory based on T, then, in any T-model, JΓ.s : AK ≅JΓ.t : AK.
Proof: By induction on the deﬁnition of typed equality.
The logical interpretation of the soundness theorem for type theory is a weak form
of normalisation: as far as we regard typed equality as a way to reduce proofs,
equality preserves the semantics.
To show the completeness results for the type theories and for the logical sys-
tems, we proceed by constructing a syntactical model M of a theory T. Then, we
will prove that M classiﬁes all the T-models, which means the M model is, in a
sense, the minimal one verifying the theory. The completeness results follow im-
mediately.
Deﬁnition 15 (Syntactical equivalence). Fixed a theory T, its equivalence classes
of typed terms [Γ.t : A] are deﬁned as the minimal sets such that
1.
Γ.t : A ∈[Γ.t : A];
2.
if Γ耠.s : B = Γ耠.r : B is derivable from T, and Γ耠.s : B ∈[Γ.t : A], then also
Γ耠.r : B ∈[Γ.t : A];
3.
if Γ耠, z : D1 ∧D2.s[∧E1(z)/y1, ∧E2(z)/y2] : B ∈[Γ.t : A] with z : D1 ∧D2
̸∈
FV(Γ耠, y1 : D1, y2 : D2.s : B), then Γ耠, y1 : D1, y2 : D2.s : B ∈[Γ.t : A];
4.
if Γ耠, z : D.s : B ∈[Γ.t : A] and y : D
̸∈FV(Γ耠, z : D.s : B), then it holds that
Γ耠, y : D.s[y/z] : B ∈[Γ.t : A].
Fact 1. Each typed term Γ.t : A appears in some equivalence class [y : C.s : A] with
the context consisting of a single typed variable.
Proof: Let Γ be x1 : A1, . . . , xn : An. Pose C as A1 ∧⋅⋅⋅∧An, with C be ⊤when
n = 0, and take y : C to be new: then,
s = t[∧E1(y)/x1, ∧E1(∧E2(y))/x2, . . . , ∧E2(⋅⋅⋅(∧E2(y)) ⋅⋅⋅)/xn] .

Proof-Oriented Categorical Semantics
|
57
The idea is that the ﬁrst element of Γ can be obtained from y as ∧E1(y), and the
rest of Γ is represented by ∧E2(y). Recursively dismounting the rest, we can access
every element of Γ, which provides the formula s above.
Fact 2. If Γ.t : B and Γ.s : B are in the same equivalence class [y : C.r : D] then B is
identical to D and Γ.t : B = Γ.s : B.
Proof: An immediate induction on the deﬁnition of syntactical equivalence
proves B is the same as D, Γ, y:C.t:B = Γ, y:C.r:B and Γ, y:C.s:B = Γ, y:C.r:B.
So, syntactical equivalence induces a partition on the collection of typed terms,
thus it is an equivalence relation.
Deﬁnition 16 (Syntactical category). Given a theory T, its syntactical category
⟨ℂT, 픾T, ΣT⟩is deﬁned as
1.
the category ℂT whose objects are all the types, the equivalence classes [x:A.t:
B] deﬁne the arrows A →B, with [x : A.x : A] as identities, and composition is
given by substitution:
[y : B.s : C] ∘[x : A.t : B] = [x : A.s[t/y] : C] ;
2.
the groupoid 픾T is the discrete category of logical terms³.
3.
the substitution functor ΣT is generated, remember (5) in Deﬁnition 11, by the
type interpretation MT deﬁned by MTA = A.
Proposition 4. Fixed a theory T, its syntactical category ⟨ℂT, 픾T, ΣT⟩is logical.
Proof: Products are formed by conjunction and ⊤; coproducts by disjunction and
⊥; exponentiation is implication; the limit and the colimit of any substitution
functor are the corresponding universally and existentially quantiﬁed formulae.
Mere calculation allows to verify that these objects behave as expected.
Proposition 5. Given a theory T, and thus its syntactical category ⟨ℂT, 픾T, ΣT⟩,
the T-model ⟨ℂT, 픾T, ΣT, αT⟩, where αT maps the axiom (a : A) 㨃→[x : ⊤.a : A], is
called the canonical model and it satisﬁes exactly those typed equalities which are
provable from T.
Proof: Observing that the equivalence class [x:⊤.a:A] contains .a:A, the deriva-
tion of A via the axiom rule from the empty context, it follows that the map αT
3 In the light of Section 5, when using abstract terms on the (abstract) signature ⟨픾, Σ, R⟩, 픾T
will become 픾, thus constraining the canonical model to preserve the equalities which are part
of the structure of abstract terms. It is worth remarking that this change has no impact on the
results in this section, except for a technical assumption which will be discussed in Section 5.

58
|
M. Benini
induces the arrow [.a : A]: 1 →A, thus the deﬁnition of T-model is correct. By
induction on the structure of x : C.t : B, we prove that Jx : C.t : BK = [x : C.t : B].
Then, the conclusion follows immediately.
Proposition 6. Fixed a theory T, for every logical category ⟨ℂ, 픾, Σ⟩, there is a
bijection between equivalence classes, modulo natural equivalences, of structure-
preserving functors ℂT →ℂand equivalence classes, modulo isomorphisms, of
T-models in ℂ, induced by the map F 㨃→F(MT).
Proof: Essentially, this is Proposition 4.2.5 in Part D of [Johnstone, 2002b], see
also [Benini, 2013].
Theorem 7 (Completeness). If Γ.t : A is semantically equal to Γ.s : A in every T-
model, then Γ.t : A = Γ.s : A is derivable from T.
Proof: It is safe to assume that Γ is x : B, thanks to syntactical equivalence. So,
if Jx : B.t : AK = Jx : B.s : AK is valid in every T-model, it holds in the canonical
model as well. But, from the proof of Proposition 5, Jx : B.t : AK = [x : B.t : A] and
Jx : B.s : AK = [x : B.s : A], so [x : B.t : A] = [x : B.s : A] and the conclusion follows
from Fact 2.
Corollary 8. If a formula A is valid in every T-model, then A is provable in the theory
T.
Proof: If A is valid in every T-model, 1 →A is an arrow in the canonical model,
thus [.t : A] is inhabited.
Hence, given a theory T, both the logical system and the type theory on T are
sound and complete, and the canonical model captures exactly the valid formu-
lae and the valid typed equalities: in the words of the Introduction, the canoni-
cal model is the entity the theory T really speaks of. And any other T-model may
be obtained from the canonical one by transforming it via a suitable structure-
preserving functor, which happens to be a logical functor [Mac Lane and Moerdijk,
1992, Section IV.2].
An inconsistent theory T allows to derive ⊥: in the present semantics, T has a
canonical model as well, but it is logically trivial, since M⊤→M⊥is an arrow, that
is, the initial and the terminal object are isomorphic. Of course, being the canon-
ical model a classiﬁer for other models via structure-preserving functors, all the
model will have zero objects too. Oppositely, if a theory has at least a model with
no zero object, it is consistent. It should be remarked that an inconsistent theory
has a canonical model which still contains non-trivial computational information
about how its proofs reduce: this can be useful for non-logical applications.

Proof-Oriented Categorical Semantics
|
59
The reader may wonder why we have not explicitly considered equality in the
completeness proof: in other semantics, the presence of equality modiﬁes the way
a canonical model is synthesised from the language. The answer is that there is
no need to treat equality as special: since the semantics is point-free, i.e., logical
terms are not part of it, and they do not get interpreted in some entity in the logical
category, but rather they are only visible through the action of the substitution
functor, equality is just another atomic relation.
4.1 Equalities
As we said, logical categories contain enough structure to model equality in the
semantics. Although it is always possible to treat equality between logical terms
by an axiomatic theory, which gets interpreted in the previously explained way,
and thus give rise to a sound and complete theory, there are cases when a purely
semantic approach is preferable.
The general idea is to consider the groupoid 픾of logical terms as the deﬁni-
tion of the equality relation, and to use the machinery developed so far to project
the groupoid structure onto the logical category, and to synthesise a theory for
equality from this projection. To do so, assume the signature to contain a relation
symbol =s :s × s for some sort s. Then, we require the logical category ⟨ℂ, 픾, Σ⟩
to satisfy
1.
if f ∈Hom픾(t : s, r : s) then there is π(f) ∈Homℂ(1, Mt =s r);
2.
if Hom픾(t : s, r : s) = 0 then there is εt,r ∈Homℂ(Mt =s r, 0).
We want to show that these two requirements are enough to make =s a congru-
ence, i.e., an equivalence relation such that, if t =s r then MA[t/x] = MA[r/x] for
each type A and variable x:s. In the following, we assume to work within a logical
category ⟨ℂ, 픾, Σ⟩satisfying the requirements above.
Fact 3. If g ∈Homℂ(MA, MB) then A ⊃B is valid.
Proof: Consider the following exponentiation diagram:
MBMA × MA
ev
/ MB
1 × MA
tr(g∘π2)×1MA
O
π2
/ MA
g
O
Then, tr(g ∘π2): 1 →MA ⊃B.

60
|
M. Benini
Fact 4. If, for all terms t : s, ft ∈Homℂ(1, MB[t/x]MA[t/x]), then ∀x : s A ⊃B is
valid.
Proof: Since (1, {ft}t:s) is a cone on ΣA⊃B(x : s), there exists the universal arrow
1 →M∀x : s A ⊃B = lim ΣA⊃B(x : s).
Proposition 9. The formula ∀x : s x =s x is valid.
Proof: Since, for each term t:s, 1t:s ∈Hom픾(t:s, t:s), 1 →Mt =s t is an arrow in
ℂ. Thus, 1 = M⊤is the vertex of a cone on Σx=sx(x : s). Then, the universal arrow
of lim Σx=sx(x : s) from 1 establishes the conclusion.
Proposition 10. The formula ∀x : s ∀y : s x =s y ⊃y =s x is valid.
Proof: Let t : s and r : s be terms of sort s. Either there is f ∈Hom픾(t : s, r : s), or
Hom픾(t : s, r : s) = 0. In the former case, being 픾a groupoid, f has an inverse, and
π(f −1): 1 →Mr =s t is in ℂ. Hence π(f −1)∘(!: Mt =s r →1) : Mt =s r →Mr =s t.
In the latter case, (!: 0 →Mr =s t) ∘εt,r : Mt =s r →Mr =s t. In both case, there
is some g: Mt =s r →Mr =s t. So, by Fact 3, Mt =s r ⊃Mr =s t is valid. Thus, by
Fact 4 twice, the conclusion follows.
Proposition 11. The formula ∀x : s ∀y : s ∀z : s x =s y ∧y =s z ⊃x =s z is valid.
Proof: Let t : s, u : s and v : s be terms. Either there are f1 ∈Hom픾(t : s, u : s) and
f2 ∈Hom픾(u : s, v : s), or one of Hom픾(t : s, u : s) and Hom픾(u : s, v : s) is empty.
In the former case, f2 ∘f1 ∈Hom픾(t:, v : s), so π(f2 ∘f1): 1 →Mt =s v is in ℂ.
Thus, π(f2∘f1)∘(!: Mt =s u × Mu =s v →1) : Mt =s v×Mu =s v →Mt =s v. In the
latter case, either Mt =s u →0 or Mu =s v →0 is in ℂ, that is f : Mt =s u × Mu =s
v →0 can be constructed by composing with the appropriate projection. Thus,
(!: 0 →Mt =s v) ∘f : Mt =s u × Mu =s v →Mt =s v. Summing up, in any case
there is an arrow g: Mt =s u × Mu =s v →Mt =s v. So, by Fact 3 and Fact 4, the
conclusion follows.
Proposition 12. For any formula A, if t =s r is valid, so is A[t/x] ⊃A[r/x].
Proof: Being t =s r valid, either there is f ∈Hom픾(t : s, r : s) or the category ℂis
trivial, i.e., 0 is isomorphic to 1. In the latter case, the conclusion follows imme-
diately, as 0 is initial. In the former case, since ΣA(x : s)(f): MA[t/x] →MA[r/x],
Fact 3 yields the result.
Thus, the natural typed theory for equality arising from the groupoid 픾is T=, the
typed theory consisting all the axioms aπ(f) :t =s r corresponding to the case (1) in
the requirements on the logical category, and all the axioms aεt,r : ¬t =s r, corre-
sponding to case (2). Then, soundness follows immediately from Propositions 9,
10, 11, and 12. And completeness comes for free.

Proof-Oriented Categorical Semantics
|
61
5 Abstracting logical terms
A peculiar aspect of working within a point-free framework is that logical terms
do not denote elements of some universe; rather, they link together formulae and
proofs through the substitution functor. Precisely, terms and variables have very
speciﬁc roles: terms are used as replacements for variables in the substitution pro-
cess. In turn, the semantic substitution process is modelled by the action of the
substitution functors, and by the substitution rules in Deﬁnition 4 in the syntax.
And, by clause (5) of Deﬁnition 11, these two instances of the process are coherent.
On the contrary, variables are used in a variety of ways: they act as terms; they
can be replaced by terms in the substitution process; they are used to form quanti-
ﬁed formulae; they constrain how inference rules may be applied—see clauses (11)
and (14) in Deﬁnition 9; they index the substitution functors whose limits and
colimits are used to interpret quantiﬁed formulae. All the uses of variables, as de-
scribed so far, are deeply interrelated.
Since terms and variables do not get interpreted, although their roles are es-
sential to build both the syntax and the semantics, it is natural to ask whether
they are really needed. Or, oppositely, if they may be replaced by a simpler, more
abstract structure. The answer is positive, although not yet completely satisfac-
tory. In fact, as we will show in the following, we can use any groupoid as the
structured collection of terms, obtaining essentially the same results, and, at the
same time, allowing for an apparently more expressive syntax.
Substituting logical terms with the objects of a groupoid requires to modify
the syntax. Speciﬁcally, the notion of signature, i.e., Deﬁnition 1 changes as fol-
lows: an abstract signature is a triple ⟨픾, Σ, R⟩composed by a groupoid 픾, a func-
tor Σ: 픾× 픾× 픾→픾, and a set R of relation symbols, each one of the form r : n,
where n ∈ℕindicates its arity, that is, the number of arguments. The Σ functor
models substitution of terms in 픾: Σt(x)(r) is the result of substituting x with r in
t. We require Σ to be stable: Σt(x)(x) = t for any x, t ∈Obj픾, compare with (6) in
Deﬁnition 11.
Fact 5. Fixed an abstract signature ⟨픾, Σ, R⟩, let x1, x2, r1, r2, t1, t2 ∈Obj픾such
that x1 ≅x2, r1 ≅r2, and t1 ≅t2. Then Σt1(x1)(r1) ≅Σt2(x2)(r2).
In an abstract signature, variables can be identiﬁed with those objects in 픾that
signiﬁcantly aﬀect the substitution process: formally, x ∈Obj픾is a variable when
there are t, r ∈Obj픾such that Σt(x)(r)
̸≅t. To conform to the standard notation,
we call V the collection of all variables in an abstract signature, and we write t[r/x]
instead of Σt(x)(r) when x is a variable.

62
|
M. Benini
Then, formulae, typed terms and the rest of the framework can be immedi-
ately redeﬁned with no signiﬁcant impact. The results, soundness and complete-
ness in particular, can be derived in same way, except that an additional technical
assumption is needed: in fact, it is easy to consider groupoids having a non-empty
but still ﬁnite collection of variables. Since we require to freely form quantiﬁed for-
mulae, and substitution requires to rename bounded variables at need, the stor-
age of new variables may exhaust in those groupoids, preventing to reproduce the
proofs of our results in them. Still, when a groupoid has an inﬁnite number of
non-isomorphic variables, or even when V = 0, the proofs in this contribution
are valid. The special case V = 0 means to consider propositional systems, since
quantiﬁed formulae cannot be formed.
Of course, introducing sorts is easy: it suﬃces to consider 픾= ⨆s∈S 픾s, the co-
product of the groupoids 픾s, each one having inﬁnite non-isomorphic variables.
For a simple signature as in Deﬁnition 1, the groupoid 픾is the coproduct ⨆s∈S 픾s,
that is, the disjoint union of the groupoids 픾s, with 픾s the discrete category, i.e.,
the set of terms in the sort s.
An essential notion to model the constraints that variables introduce in the
framework, as already illustrated, is that of free variables in a term: the free vari-
ables in t ∈Obj픾is the collection FV(t) of variables x such that there is r ∈Obj픾
for which t[r/x]
̸≅t. It is immediate to check that such a deﬁnition works as ex-
pected, because of Fact 5.
As an example, let us consider the category ℙof quasi orders and monotone
maps. The category 픾ℙhas as objects all the quasi orders but its arrows are just
the isomorphisms of ℙ. Clearly, 픾ℙis a groupoid, and thus we can use it as the
‘collection’ of abstract terms in a logical language. Assuming to have equality as
the only relation symbol, and interpreting it in the standard way, see Section 4.1,
the theory will model quasi orders up to isomorphisms, forcing isomorphic order-
ings to be equal in the theory.
Let Σ: 픾ℙ× 픾ℙ× 픾ℙ→픾ℙbe any functor such that
–
ΣQ(S)(R) = Q when the ﬁnite quasi order S does not occur in Q or R does not
occur in S,
–
ΣQ(S)(R) = ⟨(Q \ S) ⊔R; ≤⟩when the ﬁnite quasi order S occurs in Q and R
occurs in S (notice how a choice has to be made, since S may occur in Q more
than once, and R may occur in S in more than one way)
–
the ≤ordering relation above is deﬁned as x ≤y when
–
x, y ∈Q \ S and x ≤Q y;
–
x, y ∈R and x ≤R y;
–
x ∈Q \ S, y ∈R and there is z ∈S such that x ≤Q z and z ≤S y;
–
x ∈R, y ∈Q \ S and there is z ∈S such that x ≤S z and z ≤Q y.

Proof-Oriented Categorical Semantics
|
63
Clearly, because it acts on a groupoid, Σ is a functor, and it is stable, since
ΣQ(S)(S) = Q, as it is immediate to verify.
Clearly, in this abstract signature, the ‘terms’ are the quasi orders, which are
considered up-to-isomorphisms. The variables are the ﬁnite quasi orders, and the
‘substitution’ on terms replaces a ﬁnite quasi order S with a suborder R, in the
obvious way. This is useful, for example, to show that chains can be compressed
by identifying equivalent elements, thus reducing well quasi orders to well orders.
This property is proved in a completely formal environment, by considering all the
possible Σ functors above. Evidently, the advantage of this technique is to move
the semantic way of reasoning, which is typical of algebraic arguments, like the
ones used in the theory of quasi orders, to the syntactic level, naturally.
6 Comparison with other semantics
First-order intuitionistic systems have been intensively studied and many diﬀer-
ent ways to formally interpret these logical systems have been proposed and com-
pared to each other. In this spirit, we will compare logical categories with similar
frameworks, based on category theory, so to make the comparison precise. From
our results, the reader may easily relate the semantics in this contribution with
other systems based on diﬀerent backgrounds.
The two major categorical frameworks to assign a meaning to ﬁrst-order
logic are Heyting categories and, as an especially important instance, elementary
toposes. Both semantics are described in [Johnstone, 2002b], and we assume
them to be well-known; in this respect, we adopt the notation of [Johnstone,
2002b] and its terminology. In fact, these semantics are variations over the same
idea: to associate a subobject to each formula in a context. So, the context pro-
vides the object of reference and, speciﬁcally, the pseudo-complemented lattice
of its subobjects. Formulae get a meaning by interpreting connectives as lattice
operations, while, following Lavwere [1969]’s idea of interpreting quantiﬁcations
as adjoints, quantiﬁers are rendered by relating the lattices of diﬀerent objects
through their connecting arrows. In fact, Heyting categories are, in a way, the
minimal categories allowing for such an interpretation, while elementary toposes
can be regarded as their natural algebraic and categorical completions.
So, we will show that each model M for a logical theory T in a Heyting cate-
gory can be directly and uniformly transformed in a T-model L in a logical cate-
gory, in such a way that the valid statements in M are exactly those in L. Of course,
since every elementary topos is also a Heyting category, the same transformation
can be done on models in a topos. Thus, we will deduce that the expressive power

64
|
M. Benini
of the semantics based on logical categories is at least the same as the one based
on Heyting algebras, or elementary toposes, as far as we are only interested in
what can be expressed in the ﬁrst-order language and within the notion of valid-
ity.
Fixed⁴ a signature Σ, we want to map each Σ-structure M in a Heyting category
ℂto an essentially equivalent logical category LH(M).
Deﬁnition 17. The category LH(M) = ⟨픻, 픾, Ξ⟩, is deﬁned as
1.
The objects of 픻are JFV(A).AKℂ, the interpretation of the formula A in its min-
imal context⁵ inside ℂ, for all the formulae A. It is worth noticing that the order
of variables in the context denoted by FV(A) is not relevant since the ﬁnite prod-
ucts over the same objects are isomorphic;
2.
Hom픻(JFV(A).AKℂ, JFV(B).BKℂ) contains at most one arrow, and this happens
exactly when JFV(A) ∪FV(B).AKℂ≤JFV(A) ∪FV(B).BKℂin the lattice of subob-
jects of M(FV(A) ∪FV(B));
3.
identities are the obvious arrows generated by reﬂexivity of ≤;
4.
composition in 픻reduces to transitivity of ≤;
5.
the groupoid 픾is the set, seen as a discrete category, of all terms in the language
over Σ;
6.
Ξ is the substitution functor generated by the interpretation map N : A 㨃→
JFV(A).AKℂ, sending A to its interpretation in the minimal context.
Proposition 13. For any Σ-structure M in a Heyting category ℂ, LH(M) is a logical
category.
Proof: See [Benini, 2013]. It reduces to show that the lattice operations are
mapped by N into the right categorical constructions, and that the adjoints
seen through the N map construct the limit and the colimit of substitution func-
tors⁶.
4 Unfortunately, Johnstone [2002b] uses the Greek letter Σ for signatures, while we used it for
the substitution functor: since there will be no double usage in this section, we conform to [John-
stone, 2002b] from now on.
5 Again, the notion of context here is diﬀerent from the previously deﬁned one, since the vari-
ables are logical, i.e., they are decorated with sorts instead of types. It is worth remarking that our
contexts are the ones used in [Johnstone, 2002b] to deﬁne the interpretation of the simple theory
of types.
6 In [Benini, 2013], an auxiliary device, the notion of star and costar subcategory, has been used.
Subsequently, these auxiliary notions have turned out to be superﬂuous, and so they have been
dropped from the current presentation. Nevertheless, proofs are, essentially, unchanged

Proof-Oriented Categorical Semantics
|
65
Proposition 14. Let M be a Σ-structure in a Heyting category ℂ. A sequent ⃗x: ⃗C: A ⊢
B is valid in M if and only if it is valid in LH(M).
Proof: The ‘only if’ part is immediate by deﬁnition of LH. So, since the sequent is
valid in the Heyting semantics, J ⃗x: ⃗C.AKℂ≤J ⃗x: ⃗C.BKℂin the lattice of subobjects of
M( ⃗x: ⃗C). Then, it is easy to show [Benini, 2013] that JFV(A)∪FV(B).AKℂ≤JFV(A)∪
FV(B).BKℂin the lattice of subobjects of M(FV(A) ∪FV(B)), thus, by deﬁnition of
LH, there is an arrow NA →NB in 픻, as required.
Thus, given a model in a Heyting category, it is possible to transform it in a model
in a logical category so that the valid formulae are exactly the same in both mod-
els. A natural question is whether it is possible to build a model in a Heyting cat-
egory out of a T-model in a logical category. Up to present, the answer is negative
and the intuitive reason is that the T-model is point-free: since logical terms and
sorts are external to the core semantics, it seems unlikely that their interpretation
can be reconstructed and/or generated.
But, supposing to have a T-model LH(M) in a logical category, which is known
to come from a model M in a Heyting category, is it possible to recover M? Again,
as far as we know, the answer is negative, and for the same reason as above. Nev-
ertheless, assuming that M is a model in a topos, we can, in some sense, invert
the construction process leading to LH(M) by synthesising a very abstract model
N in another topos which preserves validity of formulae as in Proposition 14. This
result can be achieved by extending the map LH to a proper functor.
Deﬁnition 18 (Logical functor). A functor F : E →F between the toposes E and
F is said to be logical, see [Johnstone, 2002a, Section A.2.1] and [Mac Lane and
Moerdijk, 1992, Section IV.2], when
1.
F preserves ﬁnite limits;
2.
for all A ∈ObjE, F(℘A) with the relation F(εA) is a powerset object for FA,
see [Goldblatt, 2006, p. 104].
Deﬁnition 19. Fixed a topos E and a signature ⟨S, F, R⟩, Str E is the category whose
objects are the models of the language in E, and whose arrows are the corresponding
logical endo-functors preserving interpretations: G: U →V ∈Str E when G is a
logical functor E →E such that MVs = G(MUs) for any s ∈S, MVf = G(MUf) for
any f ∈F, and MVr = G(MUr) for any r ∈R.
Fact 6. If F : U →V ∈Str E, then MVt : s = F(MUt : s) for any logical term t : s,
and JΓ.AKV = F(JΓ.AKU) for any formula A in the context Γ.
So, Str E is the right domain for extending LH to a functor: it contains the models
in the topos E and its arrows are exactly the functors between models preserving
the logical structure, validity in particular.

66
|
M. Benini
Deﬁnition 20. Fixed a signature S, Str is the category
1.
whose objects are the logical categories ⟨ℂ, 픾, Σ⟩having as objects the formu-
lae on S, 픾is a groupoid of terms over S, and Σ is generated by a surjective
interpretation M;
2.
whose arrows are the functors preserving interpretations, or, equivalently, the
functors preserving limits and colimits.
Because all the categories ℂin the above deﬁnition are small, the latter require-
ment can be rephrased by saying that the arrows are the functors having both a
left and a right adjoint.
Fact 7. For each model U in some topos E, LH(U) ∈Str.
Fact 8. If T is a theory over the signature S, and ⟨ℂT, 픾T, ΣT⟩is the syntactical
category, see Deﬁnition 16, then ⟨ℂT, 픾T, ΣT⟩∈ObjStr.
Thus, Str is the right codomain for extending LH to a functor: it contains all the
images of models in Str E and the characterising model for a theory.
Deﬁnition 21 (LH functor). Given a topos E and a signature S, then the functor
LH: Str E →Str extends the map LH: for any F : U →V in Str E, LH(F) is an arrow
between LH(U) = ⟨픻U, 픾, ΣU⟩and LH(V) = ⟨픻V, 픾, ΣV⟩deﬁned by
1.
LH(F)(JFV(A).AKU) = F(JFV(A).AKU) for any formula A on S;
2.
for any f : JFV(A).A)KU →JFV(B).B)KU, LH(F)(f) is the unique arrow such that
⇒V ∘(FJΓ.AKU, FJΓ.BKU) = F⊤MVΓ with Γ = FV(A) ∪FV(B).
The deﬁnition is quite technical but its essence is that each logical functor pre-
serving validity of models in a topos can be transformed in a canonical way into
a homomorphism between logical categories. This happens exactly because, ob-
viously, validity preserving arrows preserve validity, a fact that can be expressed
in topos-theoretic terms, as in point (2) above.
We remind the following result, see [Awodey, 2006, Corollary 9.17]:
Proposition 15. Let F : ℂ→픻be a functor between small categories. Then, the
functor F∗: [픻op, Set] →[ℂop, Set] given by F∗(G) = G∘F, has both left and a right
adjoints F! ⊣F∗⊣F∗. Moreover, there is a natural isomorphism F! ∘Yℂ≅Y픻∘F,
where Y is the Yoneda embedding:
[ℂop, Set]
F∗
/
F!
/ [픻op, Set]
F∗
o
ℂ
Yℂ
O
F
/ 픻
Y픻
O

Proof-Oriented Categorical Semantics
|
67
Hence, taking F to be LH, from a small topos E, it is possible to reconstruct topos-
theoretic models from T-models, but they live in the bigger world of the presheaf
topos [(Str E)op, Set]. The fact that all the reconstructed models are equivalent in
terms of validity is a consequence of the existence of adjoints.
7 Conclusions
This contribution illustrates a categorical semantics for the ﬁrst-order, multi-
sorted logical theories, together with the associated type theories. The semantics
has been shown to be sound and complete, both in the logical and in the type-
theoretical sense, and every theory has a classifying model.
Moreover, the models are point-free, since logical terms are not interpreted in
some universe inside the models, but rather they are used to deﬁne the notion of
semantic substitution, i.e., the action syntactical substitution performs over the
category which is the ‘universe’ of the model, whose objects stand for formulae,
and whose arrows stands for logical proofs. Hence, logical terms do not need a
supporting universe to be studied via the logical language of the describing the-
ory.
Although this semantics is equivalent to Heyting categories, as both makes
valid the same collection of formulae,the correspondence between models is
not direct: given a model in a Heyting category, it has been shown how a cor-
responding logical category is constructed. But, the point-free nature of logical
categories prevents the construction of a suitable universe to interpret terms,
which is needed to derive an associated Heyting category.
Acknowledgment: This work has been supported by the project Correctness by
Construction (CORCON), EU 7th framework programme, grant n. PIRSES-GA-2013-
612638, and by the project Abstract Mathematics for Actual Computation: Hilbert’s
Program in the 21st Century, John Templeton Foundation.
References
Steve Awodey. Category Theory, volume 49 of Oxford Logic Guides. Oxford University Press,
2006.
Marco Benini. Intuitionistic ﬁrst-order logic: Categorical semantics via the Curry-Howard iso-
morphism. Technical report, ArXiv.org, 2013. http://arxiv.org/abs/1307.0108.

68
|
M. Benini
Jean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and Types, volume 7 of Cambridge Tracts
in Theoretical Computer Science. Cambridge University Press, 1989.
Robert Goldblatt. Topoi: The Categorical Analysis of Logic. Dover Publications, 2006.
William Howard. The formulae-as-types notion of construction. In J. Roger Seldin and
Jonathan P. Hindley, editors, To H.B. Curry: Essays on Combinatory Logic, Lambda Cal-
culus and Formalism, pages 479–490. Academic Press, 1980. Original paper manuscript
from 1969.
Peter T. Johnstone. Sketches of an Elephant: A Topos Theory Compendium, volume 1. Oxford
University Press, 2002a.
Peter T. Johnstone. Sketches of an Elephant: A Topos Theory Compendium, volume 2. Oxford
University Press, 2002b.
William F. Lavwere. Adjointness in foundations. Dialectica, 23:281–296, 1969. Reprinted in
Theory and Applications of Categories, 16:1–16 (2006).
Saunders Mac Lane. Categories for the Working Mathematician. Springer, second edition,
1998.
Saunders Mac Lane and Ieke Moerdijk. Sheaves in Geometry and Logic: A First Introduction to
Topos Theory. Springer, 1992.
Paul Taylor. Practical Foundations of Mathematics, volume 59 of Cambridge studies in ad-
vanced mathematics. Cambridge University Press, 1999.
The Univalent Foundations Program. Homotopy Type Theory: Univalent Foundations of Mathe-
matics. Lulu press, 2013.
Anne S. Troelstra and Helmut Schwichtenberg. Basic Proof Theory, volume 43 of Cambridge
Tracts in Theoretical Computer Science. Cambridge University Press, second edition,
2000.

Ulrich Berger, Kenji Miyamoto, Helmut Schwichtenberg,
Hideki Tsuiki
Logic for Gray-code Computation
Abstract: Gray-code is a well-known binary number system where neighboring
values diﬀer in one digit only. Tsuiki (2002) has introduced Gray code to the ﬁeld
of real number computation. He assigns to each number a unique 1⊥-sequence,
i.e., an inﬁnite sequence of {−1, 1, ⊥} containing at most one copy of ⊥(mean-
ing undeﬁnedness). In this paper we take a logical and constructive approach to
study real number computation based on Gray-code. Instead of Tsuiki’s indeter-
ministic multihead Type-2 machine, we use pre-Gray code, which is a represen-
tation of Gray-code as a sequence of constructors, to avoid the diﬃculty due to ⊥
which prevents sequential access to a stream. We extract real number algorithms
from proofs in an appropriate formal theory involving inductive and coinductive
deﬁnitions. Examples are algorithms transforming pre-Gray code into signed digit
code of real numbers, and conversely, the average for pre-Gray code and a trans-
lation of ﬁnite segments of pre-Gray code into its normal form. These examples
are formalized in the proof assistant Minlog.
Keywords: Gray-code, Real number computation, Inductive and coinductive def-
initions, Program extraction
Mathematics Subject Classiﬁcation 2010: 03D78, 03F60, 03B70, 03B35
1 Introduction
Gray-code (also called reﬂected binary code) is widely known in digital com-
munication, due to its property that the Hamming distance between adjacent
Gray-codes is always 1. Based on Gray-code, Di Gianantonio and Tsuiki studied
independently an expansion of real numbers as inﬁnite sequences of {0, 1, ⊥}
each of which contains at most one ⊥standing for undeﬁnedness [Gianantonio,
1999, Tsuiki, 2002]. Tsuiki called it modiﬁed Gray expansion. He also studied com-
putability of real numbers, and presented several algorithms to do real number
computation via Gray-code. The motivation of this paper is to shed light on the
Ulrich Berger: Swansea University, Swansea, SA2 8PP, Wales, UK,
e-mail: u.berger@swansea.ac.uk
Kenji Miyamoto, Helmut Schwichtenberg: Ludwig-Maximilian Universität München, Munich,
Germany, e-mail: kenji.miyamoto@math.lmu.de, schwicht@math.lmu.de
Hideki Tsuiki: Division of Mathematics, Faculty of Integrated Human Studies, Kyoto University,
Kyoto 606, Japan, e-mail: tsuiki@i.h.kyoto-u.ac.jp
and

70
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
logical aspect of Gray-code computation from the constructive standpoint. We
formalize Gray-code in the Theory of Computable Functionals, TCF in short, and
also in the proof assistant Minlog¹, which is an implementation of TCF, by means
of inductive and coinductive deﬁnitions [Schwichtenberg and Wainer, 2012]. In
order to make use of Tsuiki’s idea in TCF, we introduce pre-Gray code which is
Gray-code represented as ordinary streams. Through the realizability interpreta-
tion we extract from proofs programs as terms in an extension T+ of Gödel’s T
involving higher type recursion and corecursion operators. As case studies we
extract real number algorithms in our setting of pre-Gray code. The correctness of
the extracted programs is automatically ensured by the soundness theorem.
The rest of this paper is organized as follows. In Section 2 we investigate Gray-
code and introduce pre-Gray code representation of real numbers. In Section 3 we
describe realizability in our framework TCF, w.r.t. inductive and coinductive def-
initions. This provides a suitable setting to study logical aspects of signed digit
streams and pre-Gray code. Section 4 presents proofs about coinductive repre-
sentations that correspond to algorithms; the latter are described informally. 4.1
studies the average of two real numbers in signed digit code, and 4.4 directly for
pre-Gray code. In 4.2 and 4.3 we give translators from pre-Gray into signed digit
code, and vice versa. 4.5 studies a translation of ﬁnite segments of pre-Gray code
into its normal form. Section 5 deals with the conversion of Gray-code to modiﬁed
Gray expansion. In Section 6 we present and discuss the terms extracted from for-
malizations (in the proof assistant Minlog) of the proofs in Sections 4 and 5.
Related work
There are programming languages which can process modiﬁed Gray expan-
sion directly. Tsuiki and Sugihara studied an extension of Haskell with the
non-deterministic choice operator gamb which works as McCarthy’s amb oper-
ator [Tsuiki and Sugihara, 2005]. Tsuiki studied a logic programming language
with guarded clauses and committed choice [Tsuiki, 2005]. Terayama and Tsuiki
studied an extension of PCF with parallelism [Terayama and Tsuiki, 2013]. In this
paper we avoid using the above features by adopting pre-Gray code. Concerning
stream based real arithmetic. Wiedmer [Wiedmer, 1977, 1980] used signed digit
streams for real number computation. Its corecursive treatment was studied by
Ciaﬀaglione and Di Gianantonio in Coq [Ciaﬀaglione and Gianantonio, 1999].
Berger and Seisenberger studied program extraction to obtain programs dealing
1 See http://www.minlog-system.de/

Logic for Gray-code Computation
|
71
with signed digit streams [Berger and Seisenberger, 2010]. Some of their results
are formalized by Miyamoto and Schwichtenberg in TCF and Minlog [Miyamoto,
2013, Miyamoto and Schwichtenberg, 2015]. Chuang studied the average and the
multiplication of real numbers using coinduction in Agda via the Curry-Howard
isomorphism [Chuang, 2011].
2 Gray-code and its variations
2.1 Expansions of real numbers
We deﬁne binary expansion of the unit interval as the expansion of the unit² in-
terval 핀= [−1, 1] as inﬁnite sequences of PSD = {−1, 1} (proper signed digits) so
that v = a1a2 . . . represents
∞
∑
i=1
ai
2i .
(1)
With binary expansion, a ﬁnite sequence a1, a2, . . . , an denotes the interval
fa1(fa2 . . . (fan(핀) . . . ) for fa the function
fa(x) = x + a
2
,
and a1a2 . . . denotes the real number that belongs to the intersection of the in-
tervals denoted by its ﬁnite truncations. Though binary expansion is simple and
has little redundancy, it cannot be used for stream-based computation of the re-
als because, for example, the ﬁrst digit of the number 0 cannot be determined by
any arbitrary approximation information of the number. To remedy this, signed
digit code is commonly used in real number computation. Signed digit code is a
representation of the same interval with the same formula (1), but with three dig-
its SD = {−1, 0, 1}. In this paper, we view ﬁnite sequences of SD as a free algebra
I with a nullary constructor nilI and three unary constructors C−1, C0, C1 of type
I →I. That is,
I = nilI + C−1 I + C0 I + C1 I.
Signed digit code has a lot of redundancy, as ̄11 and 0 ̄1 represent the same inter-
val [−1/2, 0] and 1 ̄1 and 01 represent the same interval [0, 1/2]. Here, ̄1 is the
notation of −1 in a sequence. Modiﬁed Gray expansion is a unique representation
2 For simplicity we base our study on [−1, 1] rather than [0, 1].

72
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
1 (=[-1,0])
1 (=[0,1])
11 (=[0,1/2])
11 (=[-1,-1/2])
11 (=[-1/2,0])
11 (=[1/2,1])
.........................................................................................................
[-1,1]
111(=[-1,-3/4])
11
ω
ω
1
ω
1
ω
ω
111
111
ω
ω
1111 1111
111
111
111
111
111
111
111
=
-1
=
0
=
0
=
=
1/3
=
1/2
=
1/2
=
1
Fig. 1. Gray expansion.
of 핀that can be used for real number computation. It is based on Gray expansion
which is another way of expanding 핀with PSD. In Gray expansion, the sequence is
ﬂipped after an appearance of 1. That is, let LRa for a ∈PSD be functions deﬁned
as
LRa(x) = −a x −1
2
(2)
so that LR−1
= f−1 but LR1(x) = f1(−x) (Figure 1). Then, the number rep-
resented by a sequence v = a1a2 . . . is the limit of the shrinking intervals
LRa1(LRa2 . . . (LRan(핀) . . . ) which is equal to
∞
∑
i=1
−∏j≤i(−aj)
2i
.
(3)
With Gray expansion, each dyadic rational number (i.e., k/2i for integers −2i ≤
k ≤2i) other than −1 and 1 is represented in two ways as is the case for the bi-
nary expansion. For example, 0 is expanded as ̄11 ̄1ω and 11 ̄1ω. However, the two
expansions diﬀer only at one digit and the sequence after the digit they diﬀer is
always 1 ̄1ω. Modiﬁed Gray expansion assigns the 1⊥-sequence s⊥1 ̄1ω to a dyadic
rational number which has two Gray expansions s11 ̄1ω and s ̄11 ̄1ω for s ∈{1, ̄1}∗
[Tsuiki, 2002]. In this way, each real number in the unit interval is represented as a

Logic for Gray-code Computation
|
73
unique inﬁnite 1⊥-sequence, which is an inﬁnite sequence of {−1, 1, ⊥} such that
at most one copy of ⊥is contained in the sequence. In this paper, we consider its
variant that assigns all three sequences s11 ̄1ω, s ̄11 ̄1ω, and s⊥1 ̄1ω to this dyadic
rational number and simply call it the (inﬁnite) Gray-code. Gray-codes of real num-
bers in [−1, 1] range over the subset {1, ̄1}ω ∪{1, ̄1}∗⊥1 ̄1ω of {−1, 1, ⊥}ω. We will
also call each 1⊥-sequence in this set an (inﬁnite) Gray-code. The following ta-
ble shows the diﬀerence of the three representations according to the character a
allowed when a dyadic rational number is represented as sa1 ̄1ω.
Table 1. Variations of Gray-code
Gray expansion
a ∈{−1, 1},
Modiﬁed Gray expansion
a = ⊥,
Gray-code
a ∈{−1, 1, ⊥}.
As we will study in Section 5, Gray-code and modiﬁed Gray expansion are equiv-
alent in that a Gray-code can be coinductively converted to modiﬁed Gray expan-
sion.
In order to deﬁne the meaning of Gray-codes more precisely, we introduce
ﬁnite Gray-codes. A ﬁnite 1⊥-sequence of length n is an inﬁnite sequence t =
t0t1 . . . of {−1, 1, ⊥} such that tn−1
̸= ⊥, tk = ⊥for k ≥n, and tk = ⊥for at
most one k < n. We sometime omit the suﬃx ⊥ω of a ﬁnite 1⊥-sequence and write
it as a sequence of {−1, 1, ⊥} of length n. We call a ﬁnite 1⊥-sequence in {1, ̄1}∗∪
{1, ̄1}∗⊥1 ̄1∗a ﬁnite Gray-code. We deﬁne the order generated by ⊥⊑−1 and
⊥⊑1 on {−1, 1, ⊥}, and its product order on {−1, 1, ⊥}ω. The set of ﬁnite/inﬁnite
1⊥-sequences form a Scott-Ershov domain BD with compact elements ﬁnite 1⊥-
sequences. Similarly, ﬁnite/inﬁnite Gray-codes form a Scott-Ershov domain RD
with compact elements ﬁnite Gray-codes. We say that a ﬁnite 1⊥-sequence t ap-
proximates a 1⊥-sequence s if t ⊑s.
We can deﬁne the meaning of Gray-code based on this domain structure. The
meaning [[s]] of a ﬁnite Gray-code s is the same interval as the meaning of s with
Gray expansion if s ∈{ ̄1, 1}∗, and is the union of [[s耠̄11 ̄1n]] and [[s耠11 ̄1n]] if s has
the form s耠⊥1 ̄1n for s耠∈{ ̄1, 1}∗. The meaning [[t]] of an inﬁnite Gray-code t is the
unique real number that belongs to the intersection of [[s]] for s ﬁnite Gray-codes
that approximate t. The following proposition is immediate from the deﬁnition.
Proposition 2.1.
1.
For t ∈{−1, 1}ω, [[t]] is the same as the value obtained by (3).
2.
For s⊥1 ̄1ω with s ∈{−1, 1}∗, [[s⊥1 ̄1ω]] = [[s ̄11 ̄1ω]] = [[s11 ̄1ω]].

74
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
2.2 An algebra of ⊥-sequences
Note that ⊥is not an ordinary character and a machine cannot read or write a
⊥on a tape. In [Tsuiki, 2002] an IM2-machine (indeterministic multihead Type-2
machine) was introduced to input and output 1⊥-sequences. An IM2-machine has
two heads on each input/output tape so that it can skip a ⊥and access the rest the
sequence. In this paper, instead of such a direct manipulation of 1⊥-sequences,
we deﬁne pre-Gray code, which is a “representation” of Gray-code as sequences
of constructors representing how an 1⊥-sequence is obtained, and consider com-
putation through usual stream programs instead of IM2-machines.
We introduce the algebra OB = (|OB|, C ∪{nil}) of ﬁnite 1⊥-sequences, before
introducing pre-Gray code. The carrier set |OB| is the set of ﬁnite 1⊥-sequences.
It is generated by four unary constructors in C := {cons1, cons−1, ins1, ins−1} as
well as a nullary constructor nil. Recall that an ordinary binary sequence is a term
of a free algebra with two unary constructors consa for a ∈{−1, 1} which prepend
a to a sequence as well as nil. On the other hand, a 1⊥-sequence is generated
by two additional constructors insa for a ∈{−1, 1} which insert a as the second
character to a sequence.
Example 2.2. The term ins1(ins−1(cons−1(ins1 nil))) denotes ̄11 ̄1⊥1:
nil
denotes
⊥ω,
(ins1 nil)
denotes
⊥1⊥ω,
(cons−1(ins1 nil))
denotes
̄1⊥1⊥ω,
(ins−1(cons−1(ins1 nil)))
denotes
̄1 ̄1⊥1⊥ω,
(ins1(ins−1(cons−1(ins1 nil))))
denotes
̄11 ̄1⊥1⊥ω.
When writing a term of OB, we omit nil and write it as a sequence of C. Thus, we
write [ins1, ins−1, cons−1, ins1] for this term.
It is not hard to caluculate, that [cons−1, cons1, cons−1, ins1] also denotes the
same 1⊥-sequence. We write φ(p) for the 1⊥-sequence denoted by p ∈C∗. More
precisely, φ([c1, . . . , cn]) = (c1 ∘⋅⋅⋅∘cn)(⊥ω).
For coalgebraic computation, one needs to read sequences of constructors
from left to right. If a sequence of C is read from left to right, then it can be con-
sidered as a procedure to construct a 1⊥-sequence as follows. We start with an
inﬁnite tape with the state ⊥ω. We view consa as the operation to ﬁll the leftmost
⊥with a and insa as the operation to ﬁll the second ⊥from the left with a. We

Logic for Gray-code Computation
|
75
write ψ(p) for the 1⊥-sequence obtained by this procedure. More precisely, if we
deﬁne c耠: {−1, 1, ⊥}ω →{−1, 1, ⊥}ω (c ∈C) by
cons耠
a(s) = ﬁlling in s the ﬁrst bottom from the left by a
ins耠
a(s) = ﬁlling in s the second bottom from the left by a
then ψ([c1, . . . , cn]) = (c耠
n ∘⋅⋅⋅∘c耠
1)(⊥ω).
Example 2.3. We construct
̄11 ̄1⊥1 according to [cons−1, cons1, cons−1, ins1] as
⊥ω →
̄1⊥ω →
̄11⊥ω →
̄11 ̄1⊥ω →
̄11 ̄1⊥1⊥ω and according to [ins1, ins−1,
cons−1, ins1] as ⊥ω →⊥1⊥ω →⊥1 ̄1⊥ω →̄11 ̄1⊥ω →̄11 ̄1⊥1⊥ω.
Proposition 2.4. φ(p) = ψ(p) for p ∈C∗.
Proof: We show that
(c1 ∘⋅⋅⋅∘cn)(⊥ω) = (c耠
n ∘⋅⋅⋅∘c耠
1)(⊥ω).
(4)
Note that c耠satisﬁes the equations
c耠(b : s) = b : c耠(s) (b
̸= ⊥),
cons耠
a(⊥: s) = a : s,
ins耠
a(⊥: s) = ⊥: cons耠
a(s).
Using the equations for c and c耠one easily veriﬁes that
c(⊥ω) = c耠(⊥ω),
(5)
c ∘d耠= d耠∘c.
(6)
From (6) one obtains
(c1 ∘⋅⋅⋅∘cn) ∘c耠= c耠∘(c1 ∘⋅⋅⋅∘cn)
(7)
by induction on n. Now (7) and (5) yield (4), again by induction on n.
Note that c耠is increasing. That is, s ⊑c耠(s) for c ∈C. Therefore, we can
consider an inﬁnite sequence q ∈Cω of the four constructors cons1, cons ̄1,
ins1, ins ̄1 as representing an inﬁnite 1⊥-sequence which is obtained as the
least upper bound of { φ(p)(= ψ(p)) | p is a ﬁnite preﬁx of q }. For example,
[ins1, ins−1, ins−1, ins−1, . . . ] represents ⊥1 ̄1ω, and we write φ(q) for the 1⊥-
sequence represented by q ∈Cω.
As we have noted, the algebra OB is not a free algebra and we have equations
insa ∘consb = consb ∘consa
(8)
for a, b ∈PSD. Actually, OB is the universal algebra in that the set of ﬁnite 1⊥-
sequences is equal to the quotient of C∗by these equations.

76
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
2.3 An algebra of Gray-code and an auxiliary algebra
Recall that ﬁnite Gray-codes form a subset { ̄1, 1}∗∪{ ̄1, 1}∗⊥1 ̄1∗of the set of ﬁnite
1⊥-sequences. In order to represent only this set of ﬁnite Gray-codes, we deﬁne a
subalgebra G of OB simultaneously with another subalgebra H. The carrier set of
G is the set of ﬁnite Gray-codes. A naive attempt is to deﬁne them as follows.
G = ({ ̄1, 1}∗∪{ ̄1, 1}∗⊥1 ̄1∗,
{ consa : G →G | a ∈PSD } ∪{ins1 : H →G, nilG : G})
H = (⊥̄1∗, {ins−1 : H →H, nilH : H})
However, this deﬁnition does not allow ﬁlling a bottom with a digit by the consa
constructor in the coinductive treatment of an 1⊥-sequence. For this purpose, we
need to add the constructors consa : G →H for a ∈PSD to the above deﬁnition.
In order to distinguish the two constructors consa of types G →G and G →H,
we give them diﬀerent names LRa and Fina. We also rename ins1 and ins−1 to U
and D, respectively, and deﬁne the two algebras G and H with carrier sets |G| =
{ ̄1, 1}∗∪{ ̄1, 1}∗⊥1 ̄1∗and |H| = { ̄1, 1}+ ∪{ ̄1, 1}+⊥1 ̄1∗∪⊥̄1∗mutually recursively
as follows.
G = (|G|, { LRa : G →G | a ∈PSD } ∪{U: H →G, nilG : G})
H = (|H|, { Fina : G →H | a ∈PSD } ∪{D: H →H, nilH : H})
Note that the carrier sets of both algebras are generated (but not freely) by their
constructors. We call a term of type G a ﬁnite pre-Gray code.
In the coinductive treatment of an 1⊥-sequence, U: H →G means to leave
the current cell Undeﬁned and ﬁll the next cell with 1, D: H →H means to
Delay the determination of the value of the unﬁlled cell and add ̄1 to the end of
the sequence, and Fina means to Finally ﬁll the unﬁlled cell with a. Thus, both
U(D(Fin−1(U(nilH)))) and LR−1(LR1(LR−1(U(nilH)))) are terms of type G represen-
ting the sequence ̄11 ̄1⊥1.
We call an inﬁnite sequence of these constructors all of whose ﬁnite trunca-
tions are term of type G an inﬁnite term of type G, and similary, deﬁne an inﬁnite
term of H. An inﬁnite term p of type G is representing an inﬁnite Gray-code φ(p)
and thus representing a real number [[p]] ∈핀deﬁned as [[φ(p)]]. For example, for
p = [U, D, D, . . . ], φ(p) = ⊥1 ̄1ω and [[p]] = 0. We call an inﬁnite term of type G
an (inﬁnite) pre-Gray code.
Since consa, and insa satisfy (8), the constructors of G and H satisfy the fol-
lowing equations for a ∈PSD.
U ∘Fina = LRa ∘LR1,
(9)
D ∘Fina = Fina ∘LR−1.
(10)

Logic for Gray-code Computation
|
77
We show that the set of ﬁnite Gray-codes is the quotient of the term algebra of G
with these equations.
Proposition 2.5. Let p be a term of type G and ai ∈PSD (1 ≤i ≤m).
1.
If φ(p) = a1 . . . am⊥1 ̄1l, the equation p = [LRa1, . . . , LRam, U, Dl] can be de-
rived from (9) and (10).
2.
If φ(p) = a1 . . . am, the equation p = [LRa1, . . . , LRam] can be derived from (9)
and (10).
Proof: Let p = [c1, . . . , cn]. We have n = l + m because each constructor adds
one digit to a sequence. Suppose that the argument type of ci is H for i ≥k and
the return type of ck is G. Then, from the deﬁnition of G and H, we have k = m + 1
and ck, . . . , cn are uniquely determined as ck = U and ci = D for i > k. Therefore,
(1) is immediately derived from (2). We prove (2) by induction on m. If m = 0, then
p = nilG and this statement holds. Suppose that cm = LRb. Since φ(p) = ψ(p)
by Proposition 2.4, am = b and φ([c1, . . . , cm−1]) = a1 . . . am−1. Therefore, it
holds by the induction hypothesis. Suppose that cm = Finb. Since the argument
type of cm−1 is H, p has the form [c1, . . . , cm−k−2, U, Dk, Finb]. By induction hy-
pothesis, [c1, . . . , cm−k−2] = [LRa1, . . . , LRam−k−2] is derived. On the other hand,
[U, Dk, Finb] = [LRb, LR1, LRk
−1] is derived by applying (10) k times and then ap-
plying (9). Thus, (2) is proved.
2.4 Pre-Gray code
As we deﬁned, Gray-codes are representations of 핀as {−1, 1, ⊥}-sequences and
pre-Gray codes are terms of the algebra G of Gray-codes. For our study of real num-
ber computation based on pre-Gray code, we redeﬁne G and H as free algebras
and assign aﬃne functions fc to unary constructors c of G and H so that one can
directly deﬁne meanings of pre-Gray codes.
First, since nilG and nilH express the empty 1⊥-sequence, they denote the unit
interval 핀. It is natural to deﬁne fLRa and fU as
fLRa = −a x −1
2
(= LRa in (2)),
(11)
fU(x) = x
2 .
(12)
Since (9) and (10) hold, fFina and fD should satisfy
fU ∘fFina = fLRa ∘fLR1,
(13)
fD ∘fFina = fFina ∘fLR−1.
(14)

78
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
From (13), we have
fFina(x) = a x + 1
2
= fLRa(−x),
(15)
and therefore from (14), we have
fD(x) = x
2 .
(16)
Equations (11), (12), (15), and (16) deﬁne the meanings of constructors as aﬃne
functions, and they deﬁne the meaning FG(p) of a term p = [c1, . . . , cn] of type G
as
FG(p) = fc1(fc2(. . . fcn(핀) . . . )).
(17)
They also deﬁne the meaning FH(q) of a term q of type H similarly. Therefore, they
deﬁne meanings FG(p) and FH(q) of inﬁnite terms p of type G and q of type H, re-
spectively, as the unique elements which belong to intersections of the meanings
of their ﬁnite preﬁxes (Figure 2).
1⊥1
1
1
⊥1
1⊥1
11
11
11
⊥11
11
11⊥1
11⊥1
111
111
111 1⊥11
111
11⊥1
11⊥1
111
111
111 1⊥11
111
⊥1１1
11
ω
ω
1ω
1
ω
ω
ω
⊥11
111 111
ω
ω
ω
1⊥11
1111 1111
........................................................................................................
1
1
1
1
1
1
1
1
1
1
1
1
1
1
U
U
U
U
U
U
U
F1
F1
D
F1
F1
D
F1
F1
D
F1
F1 D
Fig. 2. The domain RD and constructors of pre-Gray code. Here, LR−1, LR1, U, Fin−1, Fin1, and
D are written as ̄1, 1, U, F ̄1, F1, and D, respectively.
Proposition 2.6. For a (possibly inﬁnite) term p of type G, we have [[p]] = FG(p).

Logic for Gray-code Computation
|
79
Proof: We ﬁrst prove the statement for the case that p is ﬁnite. Since equations
(13) and (14) hold, we only need to consider the cases p = [LRa1, . . . , LRam, U, Dn]
and p = [LRa1, . . . , LRam] by Proposition 2.5. The latter case is immediate from
the deﬁnition. In the former case, we have φ(p) = a1 . . . am⊥1 ̄1n. Let g = fLRa1 ∘
⋅⋅⋅∘fLRam . We have
[[p]] = [[a1 . . . am ̄11 ̄1n]] ∪[[a1 . . . am11 ̄1n]]
= g(fLR−1 ∘fLR1 ∘f n
LR−1(핀)) ∪g(fLR1 ∘fLR1 ∘f n
LR−1(핀))
= g([−1/2n+1, 0]) ∪g([0, 1/2n+1])
= g([−1/2n+1, 1/2n+1])
= (g ∘fU ∘f n
D)(핀)
= FG([LRa1, . . . , LRam, U, Dn]).
The case p is inﬁnite is immediately derived from the ﬁnite case.
Note that the meaning FH(p) of a term p of type H is also deﬁned. If p is a term
of type H, then φ(p) may not be a ﬁnite Gray-code and even if it is, FH(p) is dif-
ferent from [[φ(p)]] in general. For example, φ([D]) = ⊥̄1 and [[ ̄1 ̄1]] ∪[[1 ̄1]] =
[−1, −1/2] ∪[1/2, 1] is not an interval, and [[φ([Fin1, LR1])]] = [[11]] = [0, 1/2]
whereas FH([Fin1, LR1]) = [1/2, 1].
The meaning FH of H deﬁnes another representation of 핀which is obtained by
ﬂipping the second digit of Gray code (Figure 3). We extract conversion programs
between these two representations from the proof of Lemma 4.10 in Section 4.4.
0
1
-1
-1/2
1/2
0
1
-1
-1/2
1/2
Fig. 3. Expansion by G (i.e., Gray expansion) and expansion by H.
We deﬁned an inﬁnite term of type G as an inﬁnite sequence of constructors of
G and H such that any truncation of the sequence forms a ﬁnite term of type G.
In TCF, inﬁnite structures like this can be treated as cototal ideals. Each algebra
deﬁnition of TCF generates a basic domain of the Scott-Ershov model of partial
continuous functionals. Among the ideals of such a domain we single out the to-

80
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
tal and cototal ones, which are our well-founded and non-well-founded objects,
respectively. For the details, please consult [Schwichtenberg and Wainer, 2012].
For our algebras I, G, and H, every total ideal is a ﬁnite term and every cototal
ideal is an inﬁnite term of the algebra.
The notion of a cototal ideal also makes sense when the underlying algebra
does not have nullary constructors. Since we will only be concerned with cototal
ideals we take advantage of this fact and from now on omit the nullary construc-
tor from our algebras. This will simplify the arguments below considerably (for
instance in comparison with [Miyamoto and Schwichtenberg, 2015]). We also re-
deﬁne our free algebras I, G and H so that I has a binary constructor C of type
SD →I →I and so on; the intention is LRa(p) = LR(a, p). To sum up, our alge-
bras have the following deﬁnitions.
I = C SD I,
G = LR PSD G + U H,
H = Fin PSD G + D H.
3 Coinductive representation of Gray-code via
realizability
A constructive proof of a formula A can be viewed as a solution to the problem
posed by A [Kolmogorov, 1932]. Such a solution is a (computable) function of a
certain type τ(A) determined by the formula A. For example, ∀n∃m(Prime(m) ∧
m > n) has type N →N. Sometimes the solution is only a veriﬁcation, like for
∀n1,n2,n3>0,m>2(nm
1 +nm
2
̸= nm
3 ). In such cases a solution has no computational con-
tent and the formula A is called non-computational (n.c., or Harrop); the other
ones are called computationally relevant (c.r.). The only way c.r. formulas can
arise is via inductively deﬁned predicates, like I or coI below (we consider ∃xA
and A ∨B as inductively deﬁned). The clauses of the inductive deﬁnition deter-
mine the data type (free algebra) of a solution or “realizer”. It is essential that we
allow non-computational universal quantiﬁers ∀nc [Berger, 1993] to obtain the de-
sired data type. For instance, in the clause ∀nc
x ∀d(I(x) →I( x+d
2 )) (d ∈{−1, 0, 1})
for I one is not interested in the real number x as input, but only in how the digit d
gives rise to a new element of I. Here we work in such a constructive arithmetical
theory with realizability (called TCF in [Schwichtenberg and Wainer, 2012]).
We want to extract algorithms for real number computation from proofs in an
appropriate formal theory involving coinductive deﬁnitions. The idea is to leave
inﬁnite streams implicit, as realizers of atomic propositions on reals. For exam-

Logic for Gray-code Computation
|
81
ple, consider the problem to compute the average of two real numbers coded by
inﬁnite streams. We will coinductively deﬁne a unary predicate coI and prove
∀nc
x,x耠(coI(x) →coI(x耠) →coI( x + x耠
2
))
(18)
(recall that ∀nc indicates that the reals x, x耠have no computational signiﬁcance,
only the assumptions coI(x), coI(x耠) have). Associated with coI is its “realizability
extension” (coI)r, a relation between streams v of signed digits and real numbers
x. We can understand (coI)r(v, x) as saying that v is a stream representation of x
witnessing coI(x). The soundness theorem gives
(coI)r(v, x) →(coI)r(v耠, x耠) →(coI)r(f(v, v耠), x + x耠
2
)
for some function f extracted from the proof. The function is the stream trans-
former for the average, and it is obtained (together with a proof of its correctness)
from the proof of (18), which never mentions streams.
Now what is the predicate coI? Consider the operator
Φ(X) := { x | ∃r
x耠∈X∃d(x = x耠+ d
2
) },
where d ranges over SD := {−1, 0, 1}. The r in ∃r (not to be confused with the r in
(coI)r) indicates that the quantiﬁed variable x耠has no computational signiﬁcance,
only the kernel of the existential formula has. Since Φ(X) is stricly positive in X,
our underlying theory provides us with unary predicates (or sets; they are not dis-
tinguished) I and coI for the least and greatest ﬁxed point of Φ:
I := µXΦ(X)
least ﬁxed point
coI := νXΦ(X)
greatest ﬁxed point
satisfying the (strengthened) axioms
Φ(I ∩X) ⊆X →I ⊆X
induction
X ⊆Φ(coI ∪X) →X ⊆coI
coinduction
(they are called “strengthened” because their hypotheses are weaker than the
ﬁxed point property Φ(X) = X).
The realizability extensions Ir and (coI)r are binary predicates on streams v
of signed digits (coming from ∃d in the deﬁnition of Φ(X)) and real numbers x.
Consider the operator
Φr(Y) := { (v, x) | ∃nc
(v耠,x耠)∈Y∃d(x = x耠+ d
2
∧v = Cd(v耠))) }

82
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
(the u in ∃nc indicates that neither the quantiﬁed variable nor the kernel has com-
putational signiﬁcance). Since Φr(Y) is strictly positive in Y, again our underlying
theory provides us with binary predicates (or relations) Ir and (coI)r for the least
and greatest ﬁxed point of Φr:
Ir := µYΦr(Y)
least ﬁxed point
(coI)r := νYΦr(Y)
greatest ﬁxed point
satisfying the (strengthened) axioms
Φr(Ir ∩Y) ⊆Y →Ir ⊆Y
induction
Y ⊆Φr((coI)r ∪Y) →Y ⊆(coI)r
coinduction.
The following proposition states that the deﬁnition of coI is correct in the sense
that the realizers of coI(x) are exactly the signed digit representations of x.
Proposition 3.1. For v = a1a2 . . . ∈SDω and x ∈핀
(coI)r(v, x) ↔x ∈
∞
⋂
n=1
fa1(fa2(. . . fan(핀) . . . ))
Proof: For the direction from left to right we show
∀v,x((coI)r(v, x) →v = a1a2 . . . ∧x ∈fa1(fa2(. . . fan(핀) . . . )))
by induction on n. For n = 0 this holds since x ∈핀. For n+1 suppose that (coI)r(v, x)
holds. Then, since (coI)r is a ﬁxed point of Φr,
∃v耠,x耠,a1((coI)r(v耠, x耠) ∧x = fa1(x耠) ∧v = Ca1(v耠)).
Let v耠= a2a3 . . .. By induction hypothesis, x耠∈fa2(fa3(. . . fan+1(핀) . . . )). We have
v = Ca1(v耠) = a1a2 . . . and x ∈fa1(fa2 . . . (fan+1(핀)) . . . ).
The direction from right to left is shown by coinduction. Setting
{ (v, x) | v = a1a2 . . . , x ∈fa1(fa2(. . . fan(핀) . . . )) for every n }
it suﬃces to show P ⊆Φr(P). Assume (v, x) ∈P. Set x耠:= 2x −a1 and v耠:=
a2a3 . . .. Then clearly P(v耠, x耠), x = x耠+a1
2
and v = a1v耠= Ca1(v耠). Hence (v, x) ∈
Φr(P).
For Gray-code we proceed similarly; for brevity only for the inﬁnite case. We now
need two predicates coG and coH instead of coI. The corresponding operators Γ, ∆
are deﬁned by
Γ(X, Y) := { y | ∃r
x∈X∃a(y = −a x −1
2
) ∨∃r
x∈Y(y = x
2) },
∆(X, Y) := { y | ∃r
x∈X∃a(y = a x + 1
2
) ∨∃r
x∈Y(y = x
2) }

Logic for Gray-code Computation
|
83
and we deﬁne (coG, coH) := ν(X,Y)(Γ(X, Y), ∆(X, Y)). This is understood as the great-
est ﬁxed point of (Γ, ∆), expressed by the (strengthened) simultaneous coinduc-
tion axiom
(X, Y) ⊆(Γ(coG ∪X, coH ∪Y), ∆(coG ∪X, coH ∪Y)) →(X, Y) ⊆(coG, coH),
where inclusion ⊆is meant component-wise.
For later use we note immediate consequences of the fact that (coG, coH) is a
(simultaneous) ﬁxed point of (Γ, ∆), CoGClause and CoGClauseInv:
∀nc
x (coG(x) →∃r
x耠∈coG∃a(x = −a x耠−1
2
) ∨∃r
x耠∈coH(x = x耠
2 )),
(19)
∀nc
x (∃r
x耠∈coG∃a(x = −a x耠−1
2
) ∨∃r
x耠∈coH(x = x耠
2 ) →coG(x)).
(20)
The realizability extensions (coG)r and (coH)r are binary predicates on cototal ide-
als p in G or q in H (respectively) and real numbers x. Consider the operators
Γr(Z, W) := { (p, x) | ∃(p耠,x耠)∈Z∃a(x = −a x耠−1
2
∧p = LRa(p耠)) ∨nc
∃(q耠,x耠)∈W(x = x耠
2 ∧p = U(q耠)) },
∆r(Z, W) := { (q, x) | ∃(p耠,x耠)∈Z∃a(x = a x耠+ 1
2
∧q = Fina(p耠)) ∨nc
∃(q耠,x耠)∈W(x = x耠
2 ∧q = D(q耠)) }
(the nc in ∨nc indicates that the disjunction has no computational signiﬁcance).
Since both Γr(Z, W) and ∆r(Z, W) are strictly positive in Z, W, our underlying the-
ory provides us with a pair of binary predicates (coG)r, (coH)r for the greatest ﬁxed
point of (Γr, ∆r):
((coG)r, (coH)r) := ν(Z,W)(Γr(Z, W), ∆r(Z, W))
satisfying the (strengthened) simultaneous coinduction axiom
(Z, W) ⊆(Γr((coG)r ∪Z, (coH)r ∪W), ∆r((coG)r ∪Z, (coH)r ∪W)) →
(Z, W) ⊆((coG)r, (coH)r)
where again inclusion ⊆is meant component-wise.
Similar to Proposition 3.1, we show that coG is correct in the sense that the
realizers of coG(x) are exactly the pre-Gray codes of x.
Proposition 3.2. For x ∈핀and cototal ideals p in G and q in H
(coG)r(p, x) ↔x = FG(p),
(coH)r(q, x) ↔x = FH(q).

84
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
Proof: Recall that if p = [c1, c2, . . .] is a cototal ideal in G, then
FG(p) =
∞
⋂
n=1
fc1(fc2(. . . fcn(핀) . . . ))
and similary for FH(q). The proof is similar to the case of signed digits, but slightly
more involved because of the simultaneous deﬁnition of (coG)r and (coH)r.
Remark 3.3 (Nested deﬁnition). As an alternative to the above simultaneous deﬁ-
nition of coG and coH, we can take the nested deﬁnition coG耠= νXΓ(X, coH耠(X)) where
coH耠
X = νY∆(X, Y). The witnessing algebras would also be changed. In this paper we
adopt the simultaneous one, since the extracted programs are simpler.
4 Proofs about coinductive representations that
correspond to algorithms
In each of the examples below, after the proof we state the rules (equations) ex-
pressing the algorithm implicit in this proof. Such an “informal program extrac-
tion” can be diﬃcult and error-prone. In Section 6 this will be done precisely, us-
ing Minlog to extract a program (i.e., a term in an extension of Gödel’s T) from a
formalization of this proof.
4.1 Average for signed digit code
As a warm-up we prove the average property (18), following [Berger and Seisen-
berger, 2010]. Consider two sets of averages, the second one with a “carry” i ∈
SD2 := {−2, −1, 0, 1, 2}:
P := { x + y
2
| x, y ∈coI },
Q := { x + y + i
4
| x, y ∈coI, i ∈SD2 },
where SD2 are the “extended signed digits” {−2, −1, 0, 1, 2}; let i, j range over
SD2. Recall that coI is a ﬁxed point of Φ. Hence coI ⊆Φ(coI), i.e.
∀nc
x∈coI∃r
x耠∈coI∃d(x = x耠+ d
2
)
coI-clause.
(21)
It suﬃces to show that Q satisﬁes (21), for then by the greatest-ﬁxed-point axiom
for coI we have Q ⊆coI. Since we also have P ⊆Q we then obtain P ⊆coI, which is
our claim.

Logic for Gray-code Computation
|
85
Lemma 4.1 (CoIAvToAvc).
∀nc
x,y∈coI∃r
x耠,y耠∈coI∃i( x + y
2
= x耠+ y耠+ i
4
).
Proof: Immediate from (21).
Lemma 4.2 (CoIAvcSatCoICl).
∀i∀nc
x,y∈coI∃r
x耠,y耠∈coI∃j,d( x + y + i
4
=
x耠+y耠+j
4
+ d
2
).
Proof: We need functions J : SD →SD →SD2 →SD2 and K : SD →SD →
SD2 →SD such that d + e + 2i = J(d, e, i) + 4K(d, e, i). They can be deﬁned easily
by cases on d, e and i. Using these we can relate the functions x+d
2 and x+y+i
4
by
x+d
2 + y+e
2 + i
4
=
x+y+J(d,e,i)
4
+ K(d, e, i)
2
.
(22)
Now (21) gives the claim.
By coinduction from Lemma 4.2 we obtain
Lemma 4.3 (CoIAvcToCoI).
∀nc
z (∃r
x,y∈coI∃i(z = x + y + i
4
) →coI(z)).
Proposition 4.4 (CoIAverage).
∀nc
x,y(coI(x) →coI(y) →coI( x + y
2
)).
Proof: Immediate from Lemmata 4.1 and 4.3.
Implicit algorithm. Lemma 4.1 computes the ﬁrst “carry” i ∈SD2 and the tails of
the inputs. Then f : SD2 × I × I →I deﬁned corecursively by
f(i, Cd(v), Ce(w)) = CK(d,e,i)(f(J(d, e, i), v, w))
is called repeatedly in order to compute the average step by step.
4.2 From pre-Gray to signed digit code
We prove coG ⊆coI. However, to be able to do this by coinduction we need to gen-
eralize our goal to
Lemma 4.5 (CoGToCoIAux). ∀nc
x (∃a(coG(ax) ∨coH(ax)) →coIx).

86
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
Proof: For P := { x | ∃a(coG(ax) ∨coH(ax)) } we must show P ⊆coI. By coinduction
it suﬃces to prove P ⊆Φ(coI ∪P). Let x1 ∈P. We show x1 ∈Φ(coI ∪P):
∃r
x∈coI∪P∃d(x1 = x + d
2
).
(23)
Since x1 ∈P we have a such that coG(ax1) ∨coH(ax1).
Case coG(ax1). The coG-clause coG ⊆Γ(coG, coH) applied to ax1 ∈coG gives us
∃r
x∈coG∃b(ax1 = −b x −1
2
) ∨∃r
x∈coH(ax1 = x
2).
If the left hand side holds, we have x2 ∈coG and b such that ax1 = −b x2−1
2 . Then
(23) holds for x := −abx2 and d := ab, since −abx2 ∈P (by x2 ∈coG and the
deﬁnition of P), and
x1 = a2x1 = −ab x2 −1
2
= −abx2 + ab
2
= x + d
2
.
If the right hand side holds, we have x2 ∈coH such that ax1 = x2
2 . Then (23) holds
for x := ax2 and d := 0, since ax2 ∈P (by x2 ∈coH and the deﬁnition of P), and
x1 = a2x1 = a x2
2 = ax2 + 0
2
= x + d
2
.
Case coH(ax1). The coH-clause coH ⊆∆(coG, coH) applied to ax1 ∈coH gives
∃r
x∈coG∃b(ax1 = b x + 1
2
) ∨∃r
x∈coH(ax1 = x
2).
If the left hand side holds, we have x2 ∈coG and b such that ax1 = b x2+1
2 . Then (23)
holds for x := abx2 and d := ab, since abx2 ∈P (by x2 ∈coG and the deﬁnition of
P), and
x1 = a2x1 = ab x2 + 1
2
= abx2 + ab
2
= x + d
2
.
If the right hand side holds, we have x2 ∈coH such that ax1 = x2
2 . Then (23) holds
for x := ax2 and d := 0, since ax2 ∈P (by x2 ∈coH and the deﬁnition of P), and
x1 = a2x1 = a x2
2 = ax2 + 0
2
= x + d
2
.
Implicit algorithm. [f, g]: PSD × G + PSD × H →I deﬁned by
f(a, LRb(p)) = Cab(f(−ab, p)),
g(a, Finb(p)) = Cab(f(ab, p)),
f(a, U(q))
= C0(g(a, q)),
g(a, D(q))
= C0(g(a, q)).
An immediate consequence is
Proposition 4.6 (CoGToCoI). ∀nc
x (coG(x) →coI(x)).

Logic for Gray-code Computation
|
87
4.3 From signed digit to pre-Gray code
Conversely we also have coI ⊆coG. Again, to be able to prove this by coinduction
we need to generalize our goal to
Lemma 4.7 (CoIToCoGAux).
∀nc
x (∃acoI(ax) →coGx),
∀nc
x (∃acoI(ax) →coHx).
Proof: For P := { x | ∃a(ax ∈coI) } we show P ⊆coG simultaneously with P ⊆coH.
By coinduction it suﬃces to prove (i) P ⊆Γ(coG ∪P, coH ∪P) and (ii) P ⊆∆(coG ∪
P, coH ∪P). For (i), let x1 ∈P. We show x1 ∈Γ(coG ∪P, coH ∪P):
∃r
x∈coG∪P∃a(x1 = −a x −1
2
) ∨∃r
x∈coH∪P(x1 = x
2).
(24)
Since x1 ∈P we have a1 such that coI(a1x1). The coI-clause coI ⊆Φ(coI) applied to
a1x1 ∈coI gives us
∃r
x∈coI∃d(a1x1 = x + d
2
).
Hence we have x2 ∈coI and d such that a1x1 = x2+d
2 .
Case d = −1. Then the left hand of (24) holds for x := x2 and a := −a1, since
x2 ∈P (by x2 ∈coI and the deﬁnition of P), and
x1 = a1a1x1 = a1
x2 + d
2
= a1
x2 −1
2
.
Case d = 1. Then the left hand of (24) holds for x := −x2 and a := a1, since −x2 ∈P
(by x2 ∈coI and the deﬁnition of P), and
x1 = a1a1x1 = a1
x2 + d
2
= a1
x2 + 1
2
= −a1
−x2 −1
2
.
Case d = 0. Then the right hand of (24) holds for x := a1x2, since a1x2 ∈P (by
x2 ∈coI and the deﬁnition of P), and
x1 = a1a1x1 = a1
x2 + d
2
= a1x2
2
.
This ﬁnishes the proof of (i). The proof of (ii) is similar, and we omit it.
Implicit algorithm. g: τ →G and h: τ →H with τ := PSD × I, deﬁned by
g(b, C−1(v)) = LR−b(g(1, v)),
h(b, C−1(v)) = Fin−b(g(−1, v)),
g(b, C1(v)) = LRb(g(−1, v)),
h(b, C1(v)) = Finb(g(1, v)),
g(b, C0(v)) = U(h(b, v)),
h(b, C0(v)) = D(h(b, v)).
An immediate consequence is
Proposition 4.8 (CoIToCoG). ∀nc
x (coI(x) →coG(x)).

88
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
4.4 Average for pre-Gray code
We consider the problem to compute the average of two real numbers given in
pre-Gray code directly, without going via signed digit code.
As a preparation we treat the unary minus function. Here we make use of the
fact that our coinduction axioms are in strengthened form (that is X ⊆Φ(coI∪X) →
X ⊆coI instead of X ⊆Φ(X) →X ⊆coI, for example).
Lemma 4.9 (CoGMinus).
∀nc
x (coG(−x) →coGx),
∀nc
x (coH(−x) →coHx).
Proof: For P := { x | −x ∈coG) } and Q := { x | −x ∈coH) } we show P ⊆coG
simultaneously with Q ⊆coH. By coinduction it suﬃces to prove (i) P ⊆Γ(coG ∪
P, coH ∪Q) and (ii) Q ⊆∆(coG ∪P, coH ∪Q). For (i), let x1 ∈P. We show x1 ∈
Γ(coG ∪P, coH ∪Q):
∃r
x∈coG∪P∃a(x1 = −a x −1
2
) ∨∃r
x∈coH∪Q(x1 = x
2).
(25)
The coG-clause applied to −x1 ∈coG gives us
∃r
x∈coG∃a(−x1 = −a x −1
2
) ∨∃r
x∈coH(−x1 = x
2).
In the ﬁrst case we have x2 ∈coG and a with −x1 = −a x2−1
2 . Then the left hand
side of (25) holds for x2 and −a (here we use that our coinduction axiom is in
strengthened form). In the second case we have x2 ∈coH with −x1 = x2
2 . Then the
right hand side of (25) holds for −x2. This ﬁnishes the proof of (i). The proof of (ii)
is similar, and we omit it.
Implicit algorithm. f : G →G and f 耠: H →H deﬁned by
f(LRa(p)) = LR−a(p),
f 耠(Fina(p)) = Fin−a(p),
f(U(q)) = U(f 耠(q)),
f 耠(D(q)) = D(f 耠(q)).
Using Lemma 4.9 we prove that coG and coH are in fact equivalent.
Lemma 4.10 (CoHToCoG).
∀nc
x (coHx →coGx),
∀nc
x (coGx →coHx).

Logic for Gray-code Computation
|
89
Proof: We show coH ⊆coG simultaneously with coG ⊆coH. By coinduction it suf-
ﬁces to prove (i) coH ⊆Γ(coG ∪coH, coH ∪coG) and (ii) coG ⊆∆(coG ∪coH, coH ∪coG).
For (i), let x1 ∈coH. We show x1 ∈Γ(coG ∪coH, coH ∪coG):
∃r
x∈coG∪coH∃a(x1 = −a x −1
2
) ∨∃r
x∈coH∪coG(x1 = x
2).
(26)
The coH-clause applied to x1 ∈coH gives us
∃r
x∈coG∃a(x1 = a x + 1
2
) ∨∃r
x∈coH(x1 = x
2).
In the ﬁrst case we have x2 ∈coG and a with x1 = a x2+1
2 . Then the left hand side of
(26) holds for −x2 and a, using Lemma 4.9 and (again) that our coinduction axiom
is in strengthened form. In the second case we have x2 ∈coH with x1 = x2
2 . Then
the right hand side of (25) holds for x2. This ﬁnishes the proof of (i). The proof of
(ii) is similar, and we omit it.
Implicit algorithm. g: H →G and h: G →H:
g(Fina(p)) = LRa(f −(p)),
h(LRa(p)) = Fina(f −(p)),
g(D(q)) = U(q),
h(U(q)) = D(q)
where f −:= cCoGMinus (cL denotes the function extracted from the proof of a
lemma L). Notice that no corecursive call is involved.
The direct proof of the existence of the average w.r.t. Gray-coded reals is similar
to the proof in Section 4.1 of the existence of the average w.r.t. signed digit stream
coded reals. It proceeds as follows. To prove
∀nc
x,y(coG(x) →coG(y) →coG( x + y
2
))
consider again two sets of averages, the second one with a “carry”:
P := { x + y
2
| x, y ∈coG },
Q := { x + y + i
4
| x, y ∈coG, i ∈SD2 }.
It suﬃces to show that Q satisﬁes the clause coinductively deﬁning coG, for then by
the greatest-ﬁxed-point axiom for coG we have Q ⊆coG. Since we also have P ⊆Q
we then obtain P ⊆coG, which is our claim.
Lemma 4.11 (CoGAvToAvc).
∀nc
x,y∈coG∃r
x耠,y耠∈coG∃i( x + y
2
= x耠+ y耠+ i
4
).
Proof: Immediate from CoGClause (19).

90
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
Implicit algorithm. We use f ∗for cCoGPsdTimes and s for cCoHToCoG.
f(LRa(p), LRa耠(p耠)) = (a + a耠, f ∗(−a, p), f ∗(−a耠, p耠)),
f(LRa(p), U(q)) = (a, f ∗(−a, p), s(q)),
f(U(q), LRa(p)) = (a, s(q), f ∗(−a, p)),
f(U(q), U(q耠)) = (0, s(q), s(q耠)).
Lemma 4.12 (CoGAvcSatCoICl).
∀i∀nc
x,y∈coG∃r
x耠,y耠∈coG∃j,d( x + y + i
4
=
x耠+y耠+j
4
+ d
2
).
Proof: As in Lemma 4.2 we need the functions J, K with their property (22). Then
(19) gives the claim.
Implicit algorithm.
f(i, LRa(p), LRa耠(p耠)) = (J(a, a耠, i), K(a, a耠, i), f ∗(−a, p), f ∗(−a耠, p耠)),
f(i, LRa(p), U(q)) = (J(a, 0, i), K(a, 0, i), f ∗(−a, p), s(q)),
f(i, U(q), LRa(p)) = (J(0, a, i), K(0, a, i), s(q), f ∗(−a, p)),
f(i, U(q), U(q耠)) = (J(0, 0, i), K(0, 0, i), s(q), s(q耠)).
Lemma 4.13 (CoGAvcToCoG).
∀nc
z (∃r
x,y∈coG∃i(z = x + y + i
4
) →coG(z)),
∀nc
z (∃r
x,y∈coG∃i(z = x + y + i
4
) →coH(z)).
Proof: We show Q ⊆coG simultaneously with Q ⊆coH. By coinduction it suﬃces
to prove (i) Q ⊆Γ(coG ∪Q, coH ∪Q) and (ii) Q ⊆∆(coG ∪Q, coH ∪Q). For (i), let
z1 ∈Q. We show z1 ∈Γ(coG ∪Q, coH ∪Q):
∃r
z∈coG∪Q∃a(z1 = −a z −1
2
) ∨∃r
z∈coH∪Q(z1 = z
2).
(27)
Lemma 4.12 applied to z1 ∈Q gives us x1, y1 ∈coG and i1, d1 such that
z1 =
x1+y1+i1
4
+ d1
2
.
Case d1 = 0. Go for the right hand side of (27) with z := (x1 + y1 + i1)/4 ∈Q. Case
d1 = ±1. Go for the left hand side of (27) with a := d1 and z := (−ax1 −ay1 −
ai1)/4 ∈Q. Then
−a z −1
2
= −a 4z −4
8
= x1 + y1 + i1 + 4a
8
= z1.
This ﬁnishes the proof of (i). The proof of (ii) is similar, and we omit it.

Logic for Gray-code Computation
|
91
Implicit algorithm. In the proof we used SdDisj: ∀d(d = 0 ∨∃a(d = a)).
g(i, p, p耠) = let (i1, d, p1, p耠
1) = cCoGAvcSatCoICl(i, p, p耠) in
case cSdDisj(d) of
0 →U(h(i, p1, p耠
1))
a →LRa(g(−ai, f ∗(−a, p1), f ∗(−a, p耠
1))),
h(i, p, p耠) = let (i1, d, p1, p耠
1) = cCoGAvcSatCoICl(i, p, p耠) in
case cSdDisj(d) of
0 →D(h(i, p1, p耠
1))
a →Fina(g(−ai, f ∗(−a, p1), f ∗(−a, p耠
1))).
Proposition 4.14 (CoGAverage).
∀nc
x,y(coG(x) →coG(y) →coG( x + y
2
)).
Proof: Compose Lemmata 4.11 and 4.13.
4.5 A bounded translation from pre-Gray code to its normal
form
For pre-Gray code there are many ways of expressing the same real number as we
noted in Section 2. In particular, the terms U(Dk(Fina p))) and LRa(LR1(LRk
−1 p))))
denote the same number as Proposition 2.5 says (Dk and LRk
−1 denote k-times rep-
etition of the same constructor). Here we extract a program which transfers the
former pattern in the ﬁrst n elements of a pre-Gray code into the latter pattern.
Similar to G we inductively deﬁne a binary relation zG between real and na-
tural numbers (used as bounds), this time with an initial clause. The deﬁnition
is no longer simultaneous with H, but the latter can be deﬁned independently in
advance:
z∆(Z) := { (y, m) | m = 0 ∨∃r
(x,n)∈Z(y = x
2 ∧m = n + 1) }.
With zH = µZz∆(Z) we can now deﬁne
zΓ(X) := { (y, m) | m = 0 ∨∃r
(x,n)∈X∃a(y = −a x −1
2
∧m = n + 1) ∨
∃r
(x,n)∈zH(y = x
2 ∧m = n + 1) }
and zG = µXzΓ(X). From a proof of { (x, n) | coG(x) } ⊆zG, we extract the desired
program to compute a preﬁx of a pre-Gray code of x of length n which does not

92
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
contain a subsequence of the form UDkFina from a pre-Gray code of x. The as-
sociated algebra for zH it is just the natural numbers N, and for zG it is zG with
constructors
Nz: zG,
LRz: PSD →zG →zG,
Uz: N →zG.
Lemma 4.15 (GenCoGLR). ∀nc
x ∀a(coG(x) →coG(−a x−1
2 )).
Proof: Easy by coinduction.
Lemma 4.16 (CoGToBGAux).
∀n∀nc
x (coG(x) →zG(x, n)),
∀n∀nc
x (coH(x) →zH(x, n) ∨∃r
y∈coG∃a(zG(y, n −1) ∧x = a y + 1
2
)).
Proof: We prove both statements simultaneously by induction on n. The case n =
0 is trivial. For the step case, we ﬁrst assume coG(x1) and prove (x1, n + 1) ∈zG.
We have
∃r
x2∈coG∃a(x1 = −a x2 −1
2
) ∨∃r
x2∈coH(x1 = x2
2 ).
(Case A) Suppose that the left hand side holds. Then, by induction hypothesis
applied to x2, we have zG(x2, n). Therefore (x1, n + 1) ∈zΓ(zG) = zG because
∃r
(x2,n)∈zG∃a(x1 = −a x2 −1
2
).
(Case B) Suppose that the right hand side holds. Then, x1 = x2
2 for x2 ∈coH. There-
fore, by induction hypothesis,
zH(x2, n) ∨∃r
x3∈coG∃a(zG(x3, n −1) ∧x2 = a x3 + 1
2
).
(Case B1) Suppose that the left hand side holds. Then, since zH(x2, n) and x1 = x2
2 ,
zG(x1, n + 1) holds.
(Case B2) Suppose that the right hand side holds. Then,
x1 = x2
2 = a3
x3 + 1
4
= −a3
−x3−1
2
−1
2
= −a3
x4 −1
2
for some a3, x3 ∈coG and x4 := −x3−1
2 . Since x1 = −a3
x4−1
2 , for our goal zG(x1, n+1)
it suﬃces to prove zG(x4, n). In case n = 0 this follows from the initial clause for
zG, and in case n = m +1 it follows from zG(x3, n −1) by the ﬁrst generating clause
for zG, since x4 = −x3−1
2 .
Next, we suppose that coH(x1) and prove
zH(x1, n + 1) ∨∃r
y∈coG∃a(zG(y, n) ∧x1 = a y + 1
2
).

Logic for Gray-code Computation
|
93
The argument is almost the same as above. Since coH(x1), we have
∃r
x2∈coG∃a(x1 = a x2 + 1
2
) ∨∃r
x2∈coH(x1 = x2
2 ).
(Case A) Suppose that the left hand side holds. We have x1 = a2 x2+1
2
for a2 and
x2 ∈coG. By induction hypothesis, zG(x2, n). Therefore
∃r
y∈coG∃a(zG(y, n) ∧x1 = a y + 1
2
).
(Case B) Suppose that the right hand side holds. We have x1 = x2
2 for x2 ∈coH. By
induction hypothesis,
zH(x2, n) ∨∃r
x3∈coG∃a(zG(x3, n −1) ∧x2 = a x3 + 1
2
).
(Case B1) Suppose that the left hand side holds. Then, since zH(x2, n) and x1 = x2
2 ,
we have zH(x1, n + 1).
(Case B2) Suppose that the right hand side holds. Then,
x1 = x2
2 = a x3 + 1
4
= a
x3−1
2
+ 1
2
= a x4 + 1
2
for x4 := x3−1
2 . We prove the right hand side of our goal for x4 and a. Since x1 =
a x4+1
2
it suﬃces to prove x4 ∈coG and zG(x4, n). From x3 ∈coG we obtain x4 ∈coG
by Lemma 4.15. To prove zG(x4, n) we argue by cases on n. In case n = 0 this follows
from the initial clause for zG, and in case n = m + 1 it follows from zG(x3, n −1) by
the ﬁrst generating clause for zG, since x4 = x3−1
2 .
Implicit algorithm. f : N →G →zG and g: N →H →N+PSD×G× zG are deﬁned
by simultaneous recursion
f(0, p) = 0
g(0, q) = 0
f(n + 1, LRa(p)) = LRza(f(n, p))
f(n + 1, U(q)) = case g(n, q) of
m →m
(a, p, r) →LRza(case n of
0 →0
m + 1 →LRz1(r))
g(n + 1, Fina(p)) = (a, p, f(n, p))
g(n + 1, D(q)) = case g(n, q) of
m →m + 1
(a, p, r) →(a, LR−1(p), f(n, LR−1(p)))

94
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
An immediate consequence is
Proposition 4.17 (CoGToBG). ∀n∀nc
x (coG(x) →zG(x, n)).
5 Conversion from Gray-code to modiﬁed Gray
expansion
As we studied in Section 2.1, each dyadic rational number has three representa-
tions of the forms s11 ̄1ω, s ̄11 ̄1ω and s⊥1 ̄1ω in Gray-code, and only the last one
in modiﬁed Gray expansion. We show that Gray-code can be converted to modi-
ﬁed Gray expansion. We denote by K(RD) and L(RD) the sets of compact and non-
compact elements of RD, which coincide with the sets of ﬁnite Gray-codes and
inﬁnite Gray-codes, respectively. We also denote by M(L(RD)) the set of minimal
elements of L(RD), which coincides with the set of modiﬁed Gray expansions.
We say that s is a predecessor of t if s ⊑t and no u ∈K(RD) satisﬁes s ⊑u ⊑t.
⊥ω have no predecessor, s耠⊥1 ̄1k, ̄1k and 1 ̄1k have one predecessor, and the other
elements of K(RD) have two predecessors (see Figure 2). We deﬁne a function ρ on
K(RD) so that ρ(s) is the meet of the predecessors of s for s
̸= ⊥. In the following
deﬁnition, a ∈{ ̄1, 1}, k ≥0, s耠∈{ ̄1, 1}∗, and a ̄1k−1 means ⊥ω if k = 0.
ρ(s) =
{
{
{
{
{
{
{
{
{
{
{
{
{
⊥ω
(s = ⊥ω)
s耠⊥1 ̄1k−1
(s = s耠⊥1 ̄1k)
a ̄1k−1
(s = a ̄1k)
s耠⊥1 ̄1k−1
(s = s耠a1 ̄1k)
Since ρ(s) ⊑s, we have [[ρ(s)]] ⊇[[s]]. Moreover, [[ρ(s)]] is the smallest standard
interval whose interior contains [[s]].
One can verify that ρ is monotonic. Therefore, ρ can be extended to a continu-
ous function from RD to RD because RD is a Scott-Ershov domain. It is obvious that
ρ(L(RD)) ⊆L(RD). The following proposition says that ρ is a conversion function
from Gray-code to modiﬁed Gray expansion.
Proposition 5.1. ρ is a retract function from L(RD) to M(L(RD)). That is, ρ(t) ∈
M(L(RD)) and ρ(t) ⊑t for t ∈L(RD). In particular, ρ(t) = t for t ∈M(L(RD)).
Proof: Since ρ(s) ⊑s for s ∈K(RD), ρ(t) ⊑t for t ∈L(RD), and therefore ρ(t) =
t for t ∈M(L(RD)). We show ρ(L(RD)) ⊆M(L(RD)). Suppose that t ∈L(RD) \
M(L(RD)) and let t = sa1 ̄1ω for some s ∈{ ̄1, 1}∗and a ∈{ ̄1, 1}. Since ρ(sa1 ̄1k) =
s⊥1 ̄1k−1 for every k ≥0, ρ(t) = s⊥1 ̄1ω ∈M(L(RD)).

Logic for Gray-code Computation
|
95
We develop an algorithm to compute the function ρ at the level of pre-Gray code,
i.e. we transform a pre-Gray code p to a pre-Gray code p耠such that φ(p耠) =
ρ(φ(p)), in particular p耠will be the modiﬁed Gray-expansion of the real number
denoted by p.
In the following, we sometimes write a for LRa for simplicity. Since ρ(a1 ̄1) =
⊥1 for a ∈PSD, if the sequence begins with [LRa, LR1, LR−1], then we apply Equa-
tion (9) from right to left and replace it with [U, Fina, LR−1] and ﬁx U. We write this
rule simply as
a 1 ̄1 㨃→U | Fina ̄1.
On the other hand, since ρ(a11)=a, if the sequence begins with [U, Fina, LR1],
we apply Equation (9) from left to right and replace it with [LRa, LR1, LR1] and ﬁx
LRa. Therefore, we have
U Fina 1 㨃→a 1 1.
Similarly, we have the following rules
Fina ̄1 ̄1 㨃→D | Fina ̄1,
D Fina 1 㨃→Fina | ̄1 1.
If the sequence does not match to these four patterns, then we ﬁx the ﬁrst charac-
ter. We repeat this procedure to the rest of the sequence. One can verify that the
implicit algorithm extracted from the proof of Proposition 5.5 behaves in this way.
We extract a program that converts Gray-code to modiﬁed Gray expansion.
To this end we deﬁne variants coM of coG and coN of coH. Recall that the predi-
cate (coG)r(p, y) expresses that p is a pre-Gray code of y by Proposition 3.2, and
it is deﬁned (as greatest ﬁxed point) to mean that p = LRa(p耠), y = −a x−1
2
and
(coG)r(p耠, x) or else p = U(q), y = x
2 and (coH)r(q, x). In this deﬁnition, p = LR−1(p耠)
happens only if y ≤0, p = LR1(p耠) happens only if y ≥0 and p = U(q) happens
only if −1
2 ≤y ≤1
2. Modiﬁed Gray expansion is obtained by restricting these three
cases to y < 0, y > 0, and −1
2 < y < 1
2. Therefore, coM is deﬁned so that the left
clause of coG is restricted to y
̸= 0 and the right clause of coG is restricted to y
̸= ± 1
2.
A similar restriction must be imposed on coH. Accordingly we deﬁne variants Γ耠,
∆耠of the operators Γ, ∆by
Γ耠(X, Y) := { y | ∃r
x∈X∃a(y = −a x −1
2
∧y
̸= 0) ∨∃r
x∈Y(y = x
2 ∧y
̸= ±1
2) },
∆耠(X, Y) := { y | ∃r
x∈X∃a(y = a x + 1
2
∧y
̸= 0) ∨∃r
x∈Y(y = x
2 ∧y
̸= ±1
2) }
and we deﬁne (coM, coN) := ν(X,Y)(Γ耠(X, Y), ∆耠(X, Y)).

96
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
The corresponding realizability predicates are deﬁned by the operators
(Γ耠)r(Z, W) := { (p, x) | ∃(p耠,x耠)∈Z∃a(x = −a x耠−1
2
∧p = LRa(p耠) ∧x
̸= 0) ∨nc
∃(q耠,x耠)∈W(x = x耠
2 ∧p = U(q耠)) ∧x
̸= ±1
2 },
(∆耠)r(Z, W) := { (q, x) | ∃(p耠,x耠)∈Z∃a(x = a x耠+ 1
2
∧q = Fina(p耠) ∧x
̸= 0) ∨nc
∃(q耠,x耠)∈W(x = x耠
2 ∧q = D(q耠)) ∧x
̸= ±1
2 }
as ((coM)r, (coN)r) := ν(Z,W)((Γ耠)r(Z, W), (∆耠)r(Z, W)).
The following proposition shows that coM is correct in the sense that the re-
alizers of coM(x) are exactly the pre-Gray codes of x that are mapped by φ to a
modiﬁed Gray-expansion of x.
Proposition 5.2. For cototal ideals p in G and x ∈핀
(coM)r(p, x) ↔φ(p) is a modiﬁed Gray-expansion of x.
Proof: This is a direct consequence of the following lemma, because the modiﬁed
Gray expansion of −1 and 1 are ̄1ω and 1 ̄1ω, respectively, and they are the only
cases modiﬁed Gray expansion has the form s ̄1ω for s ∈{ ̄1, 1}∗.
Lemma 5.3. For x ∈핀and cototal ideals p in G and q in H
(coM)r(p, x) ↔x = FG(p) ∧(x ∈{−1, 1} ∨φ(p)
̸= s ̄1ω for s ∈{ ̄1, 1}∗),
(coN)r(q, x) ↔x = FH(q) ∧(x ∈{−1, 1} ∨φ(q)
̸= s ̄1ω for s ∈{ ̄1, 1}∗).
Proof: (From left to right). First, obviously, (coM)r(p, x)
→
(coG)r(p, x) and
(coN)r(q, x) →(coH)r(q, x). Therefore, (coM)r(p, x) →x = FG(p) and (coN)r(q, x) →
x = FH(q) holds by Proposition 3.2. We show
∀s,p,x((coM)r(p, x) →x ∈{−1, 1} ∨φ(p)
̸= s ̄1ω)
(28)
∀s,q,x((coN)r(q, x) →x ∈{−1, 1} ∨φ(q)
̸= s ̄1ω)
(29)
by induction on the length |s| of s ∈{ ̄1, 1}∗. As the base case, (28) holds for |s| = 0
because φ(p) = ̄1ω ∧x = FG(p) implies x = −1. We study (29) for |s| = 0. We show
that there is no pair (q, x) such that φ(q) = ̄1ω and (coN)r(q, x). Suppose that such
a pair exists. We have x = FH(q) and FH(q) = 0 (cf. Figure 3 on page 79). Since
(coN)r is a ﬁxed point of (∆耠)r,
∃p耠,x耠,a((coM)r(p耠, x耠) ∧x = a x耠+ 1
2
∧p = Fina(p耠) ∧x
̸= 0)

Logic for Gray-code Computation
|
97
or
∃q耠,x耠((coN)r(q耠, x耠) ∧x = x耠
2 ∧p = D(q耠) ∧x
̸= ±1
2).
Since x = 0, we have the latter case and p = D(q耠) and (coN)r(q耠, 0). Again for q耠,
we have q耠= D(q耠耠) and (coN)r(q耠耠, 0). In this way, we have q = Dω and φ(q) = ⊥̄1ω,
and we have contradiction. Thus, (29) holds for |s| = 0.
Suppose that (28) and (29) hold for |s| = n and prove (28) for |s| = n + 1.
Suppose that (coM)r(p, x). Since (coM)r is a ﬁxed point of (Γ耠)r,
∃p耠,x耠,a((coM)r(p耠, x耠) ∧x = −a x耠−1
2
∧p = LRa(p耠) ∧x
̸= 0)
or
∃q耠,x耠((coN)r(q耠, x耠) ∧x = x耠
2 ∧p = U(q耠) ∧x
̸= ±1
2 .
In the former case, by induction hypothesis, x耠∈{−1, 1} or else φ(p耠)
̸= s ̄1ω for
any s ∈{ ̄1, 1}n. The case x耠= 1 does not happen because x
̸= 0. If x耠= −1, then
x ∈{−1, 1}. If φ(p耠)
̸= s ̄1ω for any s ∈{ ̄1, 1}n, then φ(p) = φ(LRa(p耠)) = a :
φ(p耠)
̸= s耠̄1ω for any s耠∈{ ̄1, 1}n+1.
In the latter case, by induction hypothesis, x耠∈{−1, 1} or else φ(q耠)
̸= s ̄1ω for
any s ∈{ ̄1, 1}n. The case x耠∈{−1, 1} does not happen because x
̸= ± 1
2. Suppose
that φ(q耠)
̸= s ̄1ω for any s ∈{ ̄1, 1}n. We have, for a : t = φ(q耠), φ(p) = φ(U(q耠)) =
a : 1 : t and a : 1 : t
̸= s耠̄1ω for any s耠∈{ ̄1, 1}n+1.
The step case of (29) is similar and we omit it.
(From right to left). Easily proved by coinduction.
Remark 5.4. From coG = Γ(coG, coH) and coH = ∆(coG, coH) we know that 훾a(x) :=
−a x−1
2
∈coG (x ∈coH) and δa(x) := a x+1
2
∈coH (x ∈coG).
Proposition 5.5 (CoGToCoM).
∀nc
x (coG(x) →coM(x)),
∀nc
x (coH(x) →coN(x)).
Proof: For P := coG and Q := coH we show P ⊆coM simultaneously with Q ⊆coN.
By coinduction it suﬃces to prove (i) P ⊆Γ耠(coM ∪P, coN ∪Q) and (ii) Q ⊆∆耠(coM ∪
P, coN ∪Q). For (i), let x0 ∈P. We show x0 ∈Γ耠(coM ∪P, coN ∪Q):
∃r
x∈coM∪P∃a(x0 = −a x −1
2
∧x0
̸= 0) ∨∃r
x∈coN∪Q(x0 = x
2 ∧x0
̸= ±1
2).
(30)
The coG-clause applied to x0 ∈coG gives us
∃r
x∈coG∃a(x0 = −a x −1
2
) ∨∃r
x∈coH(x0 = x
2).
(31)

98
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
Case ga. The lhs of (31) holds. We have x1 ∈coG and a1 with x0 = −a1 x1−1
2 . The
coG-clause applied to x1 ∈coG gives us
∃r
x∈coG∃a(x1 = −a x −1
2
) ∨∃r
x∈coH(x1 = x
2).
(32)
Case gaa. The lhs of (32) holds. We have x2∈coG and a2 with x1 = −a2 x2−1
2 .
Case ga ̄1. Assume a2 = −1. Go for the lhs of (30) with x1 ∈P and a1. The goal
x0 = −a1 x1−1
2
holds by the choice of x1, a1. Since x2 ∈[−1, 1], x1 = x2−1
2
̸= 1.
Thus, x0 = −a1 x1−1
2
̸= 0.
Case ga1. Assume a2 = 1. The coG-clause applied to x2 ∈coG gives us
∃r
x∈coG∃a(x2 = −a x −1
2
) ∨∃r
x∈coH(x2 = x
2).
(33)
Case ga1a. The lhs of (33) holds. We have x3∈coG and a3 with x2= −a3
x3−1
2 .
Case ga1 ̄1. Assume a3 = −1. Go for the rhs of (30) with x = δa1(x2) :=
a1 x2+1
2
∈Q (since x2 ∈coG implies δa(x2) ∈coH). The goal x0 = x
2 holds since
x0 = −a1
x1 −1
2
= −a1
−a2 x2−1
2
−1
2
= a1
x2 −1 + 2
4
= x
2 .
On the other hand, since x3 ∈[−1, 1], x2 = x3−1
2
∈[−1, 0] and therefore, x0 =
a1 x2+1
4
∈[−1
4 , 1
4]. Thus, x0
̸= ± 1
2.
Case ga11. Assume a3 = 1. Go for the lhs of (30) with x1 ∈P and a1. The goal
x0 = −a1 x1−1
2
holds by the choice of x1, a1. Since x3 ∈[−1, 1], x2 = −x3−1
2
∈[0, 1]
and hence x1 = −x2−1
2
̸= 1. Thus, x0 = −a1 x1−1
2
̸= 0.
Case ga1U. The rhs of (33) holds. We have x3 ∈coH with x2 = x3
2 . Go for the
lhs of (30) with x = x1 ∈Q and a1. The goal x0 = −a1 x1−1
2
holds by the choice
of x1, a1. Since x3 ∈[−1, 1], x2 ∈[−1
2 , 1
2] and therefore x1 = −x2−1
2
̸= 1. Thus,
x0 = −a1 x1−1
2
̸= 0.
Case gaU. The rhs of (32) holds. We have x2 ∈coH with x1 = x2
2 . Go for the
lhs of (30) with x = x1 ∈Q and a1. The goal x0 = −a1 x1−1
2
holds by the choice of
x1, a1. Since x2 ∈[−1, 1], x1 = x2
2
̸= 1. Thus, x0 = −a1 x1−1
2
̸= 0.
Case gU. The rhs of (31) holds. We have x1 ∈coH with x0 = x1
2 . We now proceed
as above, applying the coH-clause to x1 ∈coH, and complete the proof of (i). The
proof for (ii) is similar, and we omit it.
Modiﬁed Gray expansion is a more desirable representation of real numbers than
Gray-code in that it gives the unique code to each real number. However, a pro-
gram which inputs and outputs modiﬁed Gray expansion is usually not easy to
write, as the following conversion program indicates.

Logic for Gray-code Computation
|
99
Implicit algorithm. g: G →G and h: H →H, deﬁned by (with a for LRa)
g(a( ̄1(p)))
= a(g( ̄1(p)))
h(Fina( ̄1( ̄1(p)))) = D(h(Fina( ̄1(p))))
g(a(1( ̄1(p))))
= U(h(Fina( ̄1(p))))
h(Fina( ̄1(1(p)))) = Fina(g( ̄1(1(p))))
g(a(1(1(p))))
= a(g(1(1(p))))
h(Fina( ̄1(U(q)))) = Fina(g( ̄1(U(q))))
g(a(1(U(q))))
= a(g(1(U(q))))
h(Fina(1(p)))
= Fina(g(1(p)))
g(a(U(q)))
= a(g(U(q)))
h(Fina(U(q)))
= Fina(g(U(q)))
g(U(Fina( ̄1(p)))) = U(h(Fina( ̄1(p))))
h(D(Fina( ̄1(p)))) = D(h(Fina( ̄1(p))))
g(U(Fina(1(p)))) = a(g(1(1(p))))
h(D(Fina(1(p)))) = Fina(g( ̄1(1(p))))
g(U(Fina(U(q)))) = U(h(Fina(U(q))))
h(D(Fina(U(q)))) = D(h(Fina(U(q))))
g(U(D(q)))
= U(h(D(q)))
h(D(D(q)))
= D(h(D(q)))
When the above program cCoGToModCoG is composed with a program which in-
puts and outputs Gray-code, one obtains a program that inputs and outputs mo-
diﬁed Gray expansion since a modiﬁed Gray expansion is itself a Gray-code. For
example, cCoGAverage ∘cCoGToModCoG is an average program on modiﬁed Gray
expansion. Therefore, by constructing a program which inputs and outputs Gray-
code, one automatically obtains a program which inputs and outputs modiﬁed
Gray expansion.
6 Minlog and program extraction
Minlog is a proof assistant designed to study constructive proofs and their real-
izers, or more precisely the theory TCF [Schwichtenberg and Wainer, 2012]. All
proofs in Sections 4 and 5 have been formalized in Minlog³ and their realizers
extracted, as terms in an extension of Gödel’s T. In this section we present the ex-
tracted terms and discuss how they operate. They involve recursion and corecur-
sion operators where the original proofs used induction or coinduction axioms,
and the conversion rules for these operators determine how the extracted terms
can be used as programs. The results of such an analysis have been shown in Sec-
tions 4 and 5 under the label “implicit algorithm”.
3 See http://www.minlog-system.de/, which gives instructions on how to download (or clone)
the system and the necessary software (Scheme in this case). The formalizations can be found in
the directory minlog/examples/analysis/gray.scm.

100
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
6.1 Corecursion
Recall the type of the corecursion operator for I:
coRτ
I : τ →(τ →SD × (I + τ)) →I.
(34)
The type SD×(I+τ) appears since I has the single constructor C of type SD →I →I.
The meaning of coRτ
I NM is deﬁned by the conversion rule
coRτ
I NM 㨃→Cπ1(MN)([idI→I, λy(coRτ
I yM)]π2(MN)).
We have used π1, π2 for the two projections of type ρ × σ, and the notation
[f, g]: ρ + σ →τ (for f : ρ →τ and g: σ →τ) deﬁned by
[f, g](z) :=
{
{
{
f(x)
if z = inl(x),
g(y)
if z = inr(y).
We will also need the simultaneous corecursion operators coR(G,H),(σ,τ)
G
and
coR(G,H),(σ,τ)
H
for G, H, of type
coR(G,H),(σ,τ)
G
: σ →δG →δH →G
coR(G,H),(σ,τ)
H
: τ →δG →δH →H
(35)
with step types
δG := σ →PSD × (G + σ) + (H + τ),
δH := τ →PSD × (G + σ) + (H + τ).
The type PSD×(G+σ)+(H+τ) appears since G has the two constructors LR: PSD →
G →G and U: H →G, and H has the two constructors Fin: PSD →G →H
and D: H →H. Omitting the upper indices of coR, the terms coRGNMM耠and
coRHN耠MM耠are deﬁned by the conversion rules
coRGNMM耠㨃→
{
{
{
LRπ1(u)([id, λy(coRGyMM耠)]π2(u))
if MN = inl(u)
U([id, λz(coRHzMM耠)]v)
if MN = inr(v)
coRHN耠MM耠㨃→
{
{
{
Finπ1(u)([id, λy(coRGyMM耠)]π2(u))
if M耠N耠= inl(u)
D([id, λz(coRHzMM耠)]v)
if M耠N耠= inr(v)

Logic for Gray-code Computation
|
101
6.2 Notational conventions of Minlog
Table 2. Notational conventions of Minlog
Heading 1
Heading 2
Types
iv, ag, ah, bg
base types for the algebra I, G, H, zG
rho=>sigma
function typ
rho@@sigma
product type
rho ysum sigma
sum type
Variables
v, p, q
of type I, G and H
(with ﬁxed types)
d, a, i
of type SD, PSD, SD2
ivw
of type SD2 × I × I
jdvw
of type SD2 × SD × I × I
ap
of type PSD × G
bv
of type PSD × I
ipp
of type SD2 × G × G
idpp
of type SD2 × SD × G × G
psf
of type (G →zG) × (H →N + PSD × G × zG)
apbg
of type PSD × G × zG
Constants
Rec, CoRec
recursion, corecursion
Des
destructor
PsdToSd
embedding of PSD into SD
plus, times, inv
arithmetic in SD
cL
realizer for lemma L
Terms
[x]r
lambda abstraction λxr
r@s
product term
left r,right r
components (preﬁx, binding strongest)
InL, InR
injections into a sum type
6.3 CoIAverage
We analyze the term in Figure 4 extracted from CoIAverage. The ﬁrst argument N
of the corecursion operator destructs v, v0 into their components (d, v), (e, w) and
forms (d + e, v, w). The step function M, when applied to an argument ivw of type
τ = SD2 ×I×I, M gives a result of type SD×(I+τ), as follows. Destruct ivw into the
form (i, (d, v), (e, w)), and let jdvw be the quadruple (J(d, e, i), K(d, e, i), v, w).
Return (K(d, e, i), inr(J(d, e, i), v, w)).

102
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
[v,v0](CoRec sdtwo@@iv@@iv=>iv)
(left Des v plus left Des v0@right Des v@right Des v0)
([ivw][let jdvw
(J left Des left right ivw
left Des right right ivw
left ivw@
K left Des left right ivw
left Des right right ivw
left ivw@
right Des left right ivw@
right Des right right ivw)
(left right jdvw@InR(left jdvw@right right jdvw))])
Fig. 4. Extracted term for CoIAverage.
Hence we can write λycoRτ
I yM as a function f : τ →I deﬁned by
f(i, Cd(v), Ce(w)) = CK(d,e,i)(f(J(d, e, i), v, w)).
6.4 CoGToCoI
Consider the term in Figure 5 extracted from Lemma 4.5 (CoGToCoIAux).
[apq](CoRec psd@@(ag ysum ah)=>iv)apq
([apq0][case (right apq0)
(InL p -> [case (Des p)
(InL ap ->
PsdToSd(left apq0 times left ap)@
InR(inv(left apq0 times left ap)@InL right ap))
(InR q -> Mid@InR(left apq0@InR q))])
(InR q -> [case (Des q)
(InL ap ->
PsdToSd(left apq0 times left ap)@
InR(left apq0 times left ap@InL right ap))
(InR q0 -> Mid@InR(left apq0@InR q0))])])
Fig. 5. Extracted term for CoGToCoIAux.

Logic for Gray-code Computation
|
103
We analyze the second argument M of the corecursion operator (the “step term”).
When applied to an argument N of type τ = PSD × (G + H), M returns a result of
type SD × (I + τ); it will be in the right part of I + τ (i.e., here we do not use the fact
that our coinductive deﬁnitions are in “strengthened” form). Consider the right
hand side N2 of N, of type G + H.
Case 1. If N2 is of the form inl(p) with p of type G, destruct p. Recall that
G has two constructors, LR and U. If p is of the form LRb(p耠), the result is
(ab, inr(−ab, inl(p耠))). If p is of the form U(q), the result is (0, inr(a, inr(q))).
Case 2. If N2 is of the form inr(q) with q of type H, destruct q. Recall that
H has two constructors, Fin and D. If q is of the form Finb(p), the result is
(ab, inr(ab, inl(p))). If q is of the form D(q耠), the result is (0, inr(a, inr(q耠))).
Hence λycoRτ
I yM is a function [f, g]: PSD × G + PSD × H →I deﬁned by
f(a, LRb(p)) = Cab(f(−ab, p)),
g(a, Finb(p)) = Cab(f(ab, p)),
f(a, U(q))
= C0(g(a, q)),
g(a, D(q))
= C0(g(a, q)).
6.5 CoIToCoG
For Lemma 4.7 (CoIToCoGAux) we obtain the extracted term in Figure 6.
[bv](CoRec psd@@iv=>ag psd@@iv=>ah)bv
([bv0][case (left Des right bv0)
(Lft -> InL(inv left bv0@InR(PRht@right Des right bv0)))
(Rht -> InL(left bv0@InR(PLft@right Des right bv0)))
(Mid -> InR(InR(left bv0@right Des right bv0)))])
([bv0][case (left Des right bv0)
(Lft -> InL(inv left bv0@InR(PLft@right Des right bv0)))
(Rht -> InL(left bv0@InR(PRht@right Des right bv0)))
(Mid -> InR(InR(left bv0@right Des right bv0)))])
Fig. 6. Extracted term for CoIToCoGAux.
To understand this term recall the type (35) of the simultaneous corecursion op-
erators coR(G,H),(τ,τ)
G
and coR(G,H),(τ,τ)
H
, or shortly coRG and coRH, with τ := PSD × I
and step types δ := τ →PSD × (G + τ) + (H + τ). We again analyze the particular
step functions M, M耠extracted from our proof. When applied to an argument N
of type τ = PSD × I, M returns a result of type PSD × (G + τ) + (H + τ), in the right
part of G + τ or H + τ. Let N = (b, v) with v of type I, of the form Cd(v耠). The result

104
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
is
inl(−b, inr(1, v耠))
if d = −1,
inl(b, inr(−1, v耠))
if d = 1,
inr(inr(b, v耠))
if d = 0.
Similarly, when applied to an argument N of type τ = PSD × I, M耠returns a result
of type PSD × (G + τ) + (H + τ). Let N = (b, v) with v of type I, of the form Cd(v耠).
The result is
inl(−b, inr(−1, v耠))
if d = −1,
inl(b, inr(1, v耠))
if d = 1,
inr(inr(b, v耠))
if d = 0.
Hence we can write the two functions λycoRGyMM耠and λycoRHyMM耠as g: τ →G
and h: τ →H deﬁned by
g(b, C−1(v)) = LR−b(g(1, v)),
h(b, C−1(v)) = Fin−b(g(−1, v)),
g(b, C1(v)) = LRb(g(−1, v)),
h(b, C1(v)) = Finb(g(1, v)),
g(b, C0(v)) = U(h(b, v)),
h(b, C0(v)) = D(h(b, v)).
6.6 CoGAverage
For Lemma 4.9 (CoGMinus) the extracted term is shown in Figure 7.
[p](CoRec ag=>ag ah=>ah)p
([p0][case (Des p0)
(InL ap -> InL(inv left ap@InL right ap))
(InR q -> InR(InR q))])
([q][case (Des q)
(InL ap -> InL(inv left ap@InL right ap))
(InR q0 -> InR(InR q0))])
Fig. 7. Extracted term for CoGMinus.
We need simultaneous corecursion operators
coR(G,H),(σ,τ)
G
,
and
coR(G,H),(σ,τ)
H

Logic for Gray-code Computation
|
105
of type (35). By analyzing the particular step functions M, M耠extracted from our
proof we see that we can write
λycoRGyMM耠
and
λzcoRHzMM耠
as functions f : σ →G and f 耠: τ →H deﬁned by
f(LRa(p)) = LR−a(p),
f 耠(Fina(p)) = Fin−a(p),
f(U(q)) = U(f 耠(q)),
f 耠(D(q)) = D(f 耠(q)).
Lemma 4.9 (CoGMinus) gave us Lemma 4.10 (CoHToCoG).
[q](CoRec ah=>ag ag=>ah)q
([q0][case (Des q0)
(InL ap -> InL(left ap@InL(cCoGMinus right ap)))
(InR q1 -> InR(InL q1))])
([p][case (Des p)
(InL ap -> InL(left ap@InL(cCoGMinus right ap)))
(InR q0 -> InR(InL q0))])
Fig. 8. Extracted term for CoHToCoG.
The extracted term in Figure 8 clearly represents the functions shown as implicit
algorithm in Section 4.4.
We now come to the average for Gray-code. As a preparation we need an easy
consequence of CoGMinus, a lemma CoGPsdTimes with extracted term
[a,p][case a (PLft -> cCoGMinus p) (PRht -> p)].
For Lemma 4.11 (CoGAvToAvc) the extracted term in Figure 9 again clearly repre-
sents the function shown as implicit algorithm in Section 4.4.
For Lemma 4.12 (CoGAvcSatCoICl) the extracted term is shown in Figure 10. It is
rather easy to parse into how it is written in Section 4.4.
For Lemma 4.13 (CoGAvcToCoG) we need as a preparation an easy lemma SdDisj:
∀d(d = 0 ∨∃a(d = a)), with extracted term
[d][case d (Lft -> Inr PLft) (Rht -> Inr PRht) (Mid -> DummyL)]
It is easy to see that the extracted term for Lemma 4.13 (in Figure 11) gives the
algorithm in Section 4.4.

106
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
[p,p0][case (Des p)
(InL ap ->
[case (Des p0)
(InL ap0 -> left ap plus left ap0@
cCoGPsdTimes inv left ap right ap@
cCoGPsdTimes inv left ap0 right ap0)
(InR q -> left ap plus Mid@
cCoGPsdTimes inv left ap right ap@
cCoHToCoG q)])
(InR q ->
[case (Des p0)
(InL ap -> Mid plus left ap@
cCoHToCoG q@
cCoGPsdTimes inv left ap right ap)
(InR q0 -> MT@cCoHToCoG q@cCoHToCoG q0)])]
Fig. 9. Extracted term for CoGAvToAvc.
[i,p,p0][case (Des p)
(InL ap ->
[case (Des p0)
(InL ap0 -> J(PsdToSd left ap)(PsdToSd left ap0)i@
K(PsdToSd left ap)(PsdToSd left ap0)i@
cCoGPsdTimes inv left ap right ap@
cCoGPsdTimes inv left ap0 right ap0)
(InR q ->
J(PsdToSd left ap)Mid i@
K(PsdToSd left ap)Mid i@
cCoGPsdTimes inv left ap right ap@
cCoHToCoG q)])
(InR q ->
[case (Des p0)
(InL ap -> J Mid(PsdToSd left ap)i@
K Mid(PsdToSd left ap)i@
cCoHToCoG q@
cCoGPsdTimes inv left ap right ap)
(InR q0 -> J Mid Mid i@K Mid Mid i@
cCoHToCoG q@cCoHToCoG q0)])]
Fig. 10. Extracted term for CoGAvcSatCoICl.

Logic for Gray-code Computation
|
107
[ipp](CoRec sdtwo@@ag@@ag=>ag sdtwo@@ag@@ag=>ah)ipp
([ipp0]
[let idpp (cCoGAvcSatCoICl
left ipp0 left right ipp0 right right ipp0)
[case (cSdDisj left right idpp)
(DummyL -> InR(InR(left idpp@right right idpp)))
(Inr a ->
InL(a@InR
(a times inv left idpp@
cCoGPsdTimes inv a left right right idpp@
cCoGPsdTimes inv a right right right idpp)))]])
([ipp0][let idpp (cCoGAvcSatCoICl
left ipp0 left right ipp0 right right ipp0)
[case (cSdDisj left right idpp)
(DummyL -> InR(InR(left idpp@right right idpp)))
(Inr a ->
InL(a@InR
(a times left idpp@
cCoGPsdTimes a left right right idpp@
cCoGPsdTimes a right right right idpp)))]])
Fig. 11. Extracted term for CoGAvcToCoG.
[n](Rec nat=>(ag=>bg)@@(ah=>nat ysum psd@@ag@@bg))n
(([p]Nz)@([q]InL Zero))
([n0,psf]
([p][case (Des p)
(InL ap -> LRz left ap(left psf right ap))
(InR q -> [case (right psf q)
(InL n -> Uz n)
(InR apbg ->
LRz left apbg
[case n0
(Zero -> Nz)
(Succ n1 -> LRz PRht right right apbg)])])])@
Fig. 12. Extracted term for CoGToBGAux, part I

108
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
For Proposition 4.14 (CoGAverage) the extracted term is obtained by composition
of those for Lemmata 4.11 and 4.13: [p,p0]cCoGAvcToCoG(cCoGAvToAvc p p0).
6.7 CoGToBG
For Lemma 4.16 again the extracted term (see Figure 12 above and Figure 13 below)
represents the algorithms given in Section 4.5
([q][case (Des q)
(InL ap -> InR(left ap@right ap@left psf right ap))
(InR q0 -> [case (right psf q0)
(InL n1 -> InL(Succ n1))
(InR apbg ->
InR
(left apbg@
LR PLft left right apbg@
left psf(LR PLft left right apbg)))])]))
Fig. 13. Extracted term for CoGToBGAux, part II
6.8 CoGToCoM
Finally Figure 15 gives the term extracted from our proof of Proposition 5.5.
[p](CoRec ag=>ag ah=>ah)p
([p0][case (Des p0)
(InL ap -> [case (Des right ap)
(InL ap0 -> [case (left ap0)
(PLft -> InL(left ap@InR right ap))
(PRht -> [case (Des right ap0)
(InL ap1 -> [case (left ap1)
(PLft -> InR(InR(cCoHClauseInv
(InL(left ap@right ap0)))))
Fig. 14. Extracted term for CoGToCoM, to be continued on the next page

Logic for Gray-code Computation
|
109
(PRht -> InL(left ap@InR right ap))])
(InR q -> InL(left ap@InR right ap))])])
(InR q -> InL(left ap@InR right ap))])
(InR q -> [case (Des q)
(InL ap -> [case (Des right ap)
(InL ap0 -> [case (left ap0)
(PLft -> InR(InR(cCoHClauseInv(InL ap))))
(PRht -> InL(left ap@InR(cCoGClauseInv
(InR(cCoHClauseInv(InL(PRht@right ap0)))))))])
(InR q0 -> InR(InR(cCoHClauseInv(InL ap))))])
(InR q0 -> InR(InR q))])])
([q][case (Des q)
(InL ap -> [case (Des right ap)
(InL ap0 -> [case (left ap0)
(PLft -> [case (Des right ap0)
(InL ap1 -> [case (left ap1)
(PLft -> InR(InR(cCoHClauseInv
(InL(left ap@right ap0)))))
(PRht -> InL(left ap@InR right ap))])
(InR q0 -> InL(left ap@InR right ap))])
(PRht -> InL(left ap@InR right ap))])
(InR q0 -> InL(left ap@InR right ap))])
(InR q0 -> [case (Des q0)
(InL ap -> [case (Des right ap)
(InL ap0 -> [case (left ap0)
(PLft -> InR(InR(cCoHClauseInv(InL ap))))
(PRht -> InL(left ap@InR(cCoGClauseInv
(InR(cCoHClauseInv(InL(PLft@right ap0)))))))])
(InR q1 -> InR(InR(cCoHClauseInv(InL ap))))])
(InR q1 -> InR(InR q0))])])
Acknowledgment: This work was supported by the International Research Staﬀ-
Exchange Scheme (IRSES) Nr. 612638 CORCON and Nr. 294962 COMPUTAL of the
European Commission, the JSPS Core-to-Core Program, A. Advanced research Net-
works and JSPS KAKENHI Grant Number 15K00015.
Fig. 15. Extracted term for CoGToCoM, part II

110
|
U. Berger, K. Miyamoto, H. Schwichtenberg, and H. Tsuiki
References
Ulrich Berger. Program extraction from normalization proofs. In M. Bezem and J.F. Groote,
editors, Typed Lambda Calculi and Applications, volume 664 of LNCS, pages 91–106.
Springer, Berlin, Heidelberg, New York, 1993.
Ulrich Berger and Monika Seisenberger. Proofs, programs, processes. In F. Ferreira et al.,
editors, Proceedings CiE 2010, volume 6158 of LNCS, pages 39–48. Springer, Berlin, Hei-
delberg, New York, 2010.
Chi Ming Chuang. Extraction of Programs for Exact Real Number Computation Using Agda. PhD
thesis, Swansea University, Wales, UK, 2011.
Alberto Ciaﬀaglione and Pietro Di Gianantonio. A co-inductive approach to real numbers.
In Proc. of the workshop “Types 1999”, volume 1956 of LNCS, pages 114–130. Springer,
Berlin, Heidelberg, New York, 1999.
Pietro Di Gianantonio. An abstract data type for real numbers. Theoretical Computer Science,
221(1-2):295–326, 1999.
Andrey N. Kolmogorov. Zur Deutung der intuitionistischen Logik. Math. Zeitschr., 35:58–65,
1932.
Kenji Miyamoto. Program extraction from coinductive proofs and its application to exact real
arithmetic. PhD thesis, Mathematisches Institut der Universität München, 2013.
Kenji Miyamoto and Helmut Schwichtenberg. Program extraction in exact real arithmetic.
Mathematical Structures in Computer Science, 25:1692–1704, 2015.
Shmuel Sagiv, editor. Programming Languages and Systems, 14th European Symposium on
Programming,ESOP 2005, Held as Part of the Joint European Conferences on Theory and
Practice of Software, ETAPS 2005, Edinburgh, UK, April 4-8, 2005, Proceedings, volume
3444 of Lecture Notes in Computer Science, 2005. Springer.
Helmut Schwichtenberg and Stanley S. Wainer. Proofs and Computations. Perspectives in
Logic. Association for Symbolic Logic and Cambridge University Press, 2012.
Kei Terayama and Hideki Tsuiki.
A stream calculus of bottomed sequences for real
number computation.
Electr. Notes Theor. Comput. Sci., 298:383–402, 2013.
10.1016/j.entcs.2013.09.023. URL http://dx.doi.org/10.1016/j.entcs.2013.09.023.
Hideki Tsuiki. Real number computation through Gray code embedding. Theoretical Computer
Science, 284:467–485, 2002.
Hideki Tsuiki. Real number computation with committed choice logic programming languages.
J. Log. Algebr. Program., 64(1):61–84, 2005. 10.1016/j.jlap.2004.07.005. URL http://dx.
doi.org/10.1016/j.jlap.2004.07.005.
Hideki Tsuiki and Keiji Sugihara. Streams with a bottom in functional languages. In Sagiv
[2005], pages 201–216. 10.1007/978-3-540-31987-0_15. URL http://dx.doi.org/10.1007/
978-3-540-31987-0_15.
Edwin Wiedmer. Exaktes Rechnen mit reellen Zahlen und anderen unendlichen Objekten. PhD
thesis, ETH Zürich, 1977.
Edwin Wiedmer. Computing with inﬁnite objects. Theoretical Computer Science, 10:133–155,
1980.

Douglas S. Bridges
The Continuum Hypothesis Implies Excluded
Middle
Abstract: Within the framework of Bishop-style constructive mathematics, it is
ﬁrst proved that the Continuum Hypothesis (CH) implies the law of excluded mid-
dle. A more explicit Brouwerian counterexample to CH is then discussed.
Keywords: Continuum hypothesis, Constructive, Excluded middle
Mathematics Subject Classiﬁcation 2010: 03F60, 03E50
It is a well-known result of Goodman & Myhill [Goodman and Myhill, 1978]¹ that
in Bishop-style constructive mathematics (BISH)²—essentially, in their and our
case, mathematics with intuitionistic logic and a constructive set theory such as
CZF [Aczel and Rathjen] ³—the full axiom of choice AC implies the law of excluded
middle.⁴ Given the classical independence of AC relative to ZF, and the similar
status of Cantor’s Continuum Hypothesis (which, save for the intuitionistic pa-
per [Gielen et al., 1981], has largely been ignored by the constructive mathematics
community), it is reasonable to ask whether the following holds in BISH:
Theorem 1. The Continuum Hypothesis implies the law of excluded middle.
We prove this theorem shortly. But ﬁrst we need to clarify what we mean by ‘the
Continuum Hypothesis’. This can be handled without dealing directly with cardi-
nals: for, classically, it is equivalent to the statement that if the cardinality of a set
S lies between that of ω (the set of natural numbers) and that of Pω (the power
set of ω) then either S is cardinally similar to ω or else it is cardinally similar to
Pω; in turn, this is equivalent classically to the what we take as the constructive
version of the Continuum Hypothesis: namely,
1 based on work of Diaconescu [Diaconescu, 1975].
2 For more on BISH see [Bishop, 1967, Bishop and Bridges, 1985, Troelstra and van Dalen, 1988].
3 CZF is not the only set-theoretic foundation for BISH. Examples of others are constructive Morse
set theory [Bridges and Alps], intuitionistic ZF [Friedman, 1977], and Myhill’s CST [Myhill, 1975].
A popular foundation of a diﬀerent sort is Martin-Löf’s type theory [Martin-Löf, 1975].
4 Note that although the axiom of dependent choice, and the consequent one of countable
choice, are acceptable to most constructive mathematicians, some—notably Richman [Richman,
2001]—have been developing mathematics constructively without even countable choice.
Douglas S. Bridges: School of Mathematics & Statistics, University of Canterbury, Private Bag
4800, Christchurch, New Zealand, e-mail: d.bridges@math.canterbury.ac.nz

112
|
D. Bridges
CH: If ω ≼S ≼Pω and ¬ (S ≼ω), then S ≈Pω.
Here, ‘≼’ is the usual ‘is cardinally smaller than’ predicate and ‘≈’ the ‘cardinally
similar’ or ‘equinumerous with’ one; thus: ‘S ≼T’ means that there exists an in-
jection (that is, one-one mapping) of S into T, and ‘S ≈T’ that we have both S ≼T
and T ≼S. Both of these predicates are reﬂexive and transitive predicates, and ‘≈’
is also symmetric. If
S ≼T ∧¬ (S ≈T) ,
then we say that S is cardinally strictly smaller than T, and that T is cardinally
strictly greater than S.
Our proof of Theorem 1 requires two preliminaries.
Lemma 2. Let A be a set, and f a mapping of A into PA. Then there exists C ⊂A
that is not in the range of f.
Proof: The argument is a positive re-phrasing of a familiar one in classical ZF.
Deﬁne
C ≡{x ∈A : x ∉f(x)} .
Then C ∈PA. Suppose there exists x ∈A with f(x) = C. Then
x ∈C ↔x ∉f(x) = C,
which is absurd. Hence C is not in the range of f.
Corollary 3. An inhabited set is cardinally strictly smaller than its power set.
We now give the proof of Theorem 1.
Proof: Let p be an arbitrary statement,⁵ and deﬁne
S ≡{{n} : n ∈ω} ∪{E ⊂ω : p ∨¬p} .
Using the canonical injections f of ω into S, and g of S into Pω, we see that ω ≼S ≼
Pω. Moreover, if S ≈ω, then, by Corollary 3, ¬ (S ≈Pω) and therefore ¬ (p ∨¬p),
which is absurd; whence ¬ (S ≈ω). Assuming CH, we obtain S ≈Pω. It follows
from this and Lemma 2 that there exists C ⊂ω that is not in the range of f; whence
C ∈{E ⊂ω : p ∨¬p}
and therefore p ∨¬p.
5 What we present here is an informal proof that can be formalised in Constructive Morse Set The-
ory [Bridges and Alps]. To formalise the proof in Constructive ZF [Aczel and Rathjen], we would
need to add the restriction that p be a bounded statement, in which case the conclusion is that
CH implies the restricted law of excluded middle.

The Continuum Hypothesis Implies Excluded Middle
|
113
Theorem 3 embodies a Brouwerian counterexample to the Continuum Hy-
pothesis. If we allow ourselves to invoke the classical results of Gödel [Gödel,
1940] and Cohen [Cohen, 1963], then we can use the ideas in the proof of Theorem
1 to beef up that example as follows.
First, consider the set
T ≡{E ⊂ω : CH ∨¬CH} .
If T = ⌀, then we have the contradiction ¬ (CH ∨¬CH); hence T is nonempty.
On the other hand, if T is inhabited—that is, we can construct an element of T—
then CH ∨¬CH holds. But the constructive interpretation of ‘CH ∨¬CH’ is that ei-
ther we have a proof of CH or we have a proof of ¬CH, which runs counter to the
classical Gödel-Cohen proof that CH is independent of ZF set theory. Since BISH
is consistent with classical mathematics, we see that T is an explicit example of a
nonempty set which cannot possibly be proved inhabited.
This, in itself, is not uninteresting; but it also gives a new insight into the
constructive status of CH. Consider the set
S ≡{{n} : n ∈ω} ∪T,
which (see the proof of Theorem 1) satisﬁes
ω ≼S ≼Pω ∧¬ (S ≈ω) .
If ¬ (S ≈Pω), then T = ⌀, which we have seen is absurd; hence ¬¬ (S ≈Pω). On
the other hand, if S ≈Pω, then—again see the proof of Theorem 1—T is inhabited,
which, as we have just shown, cannot be proved. Thus S is an explicit example of
a set that has the properties
ω ≼S ≼Pω ∧¬ (S ≈ω) ∧¬¬ (S ≈Pω)
and that, within BISH, cannot possibly be proved cardinally similar to Pω.
Incidentally, the proof in [Goodman and Myhill, 1978] can be adapted simi-
larly, to provide an explicit example of a set A and a subset S of A × {0, 1} such
that
∀x∈A∃y∈B ((x, y) ∈S)
but it is impossible to prove, constructively, that there exists a function f : A →B
such that (x, f(x)) ∈S for each x ∈A.
Acknowledgment: I am grateful to Fred Richman and Maarten McKubre-Jordens
for their comments on the ﬁrst draft of this paper.

114
|
D. Bridges
References
P. Aczel and M. Rathjen. Constructive set theory. forthcoming.
E. Bishop. Foundations of Constructive Analysis. McGraw-Hill, New York, 1967.
E. Bishop and D. S. Bridges. Constructive Analysis. Grundlehren der Math. Wiss. 279, Springer,
Heidelberg, 1985.
D. S. Bridges and R. A. Alps. Morse set theory as a foundation for constructive mathematics.
preprint, University of Canterbury, New Zealand.
P. J. Cohen. The independence of the continuum hypothesis. Proc. Nat. Acad. Sciences of the
U.S.A., 51:1143–1148, 1963.
R. Diaconescu. Axiom of choice and complementation. Proc. Amer. Math. Soc., 51:176–178,
1975.
H. Friedman. Set-theoretic foundations for constructive analysis. Ann. Math., 105:1–28, 1977.
W. Gielen, H. de Swart, and W. Veldman. The continuum hypothesis in intuitionism. J. Symb.
Logic, 46:121–136, 1981.
K. Gödel. The Consistency of the Continuum Hypothesis. Princeton. Univ. Press, Princeton, NJ,
1940.
N. Goodman and J. Myhill. Choice implies excluded middle. Zeit. Math. Logik Grundlagen
Math., 23:461, 1978.
P. Martin-Löf. An intuitionistic theory of types, predicative part. In H. E. Rose and J. C. Shep-
herdson, editors, Logic colloquium ’73, Proceedings of the logic colloquium, Bristol, July
1973, Studies in logic and the foundations of mathematics, pages 73–118. North-Holland,
1975.
J. Myhill. Constructive set theory. J. Symbolic Logic, 40:347–382, 1975.
Fred Richman. Constructive mathematics without choice. In Peter Schuster, Ulrich Berger, and
Horst Osswald, editors, Reuniting the Antipodes: Constructive and Nonstandard Views of
the Continuum, volume 306 of Synthese Library, pages 207–210. Kluwer A. P., 2001.
A. S. Troelstra and D. van Dalen. Constructivism in mathematics I, volume 121 of Studies in
Logic and the Foundations of Mathematics. North-Holland, 1988.

Ulrik Buchholtz, Gerhard Jäger, and Thomas Strahm
Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
Abstract: The purpose of this article is to present a range of theories with proof-
theoretic ordinal ψ(ΓΩ+1). This ordinal parallels the ordinal of predicative anal-
ysis, Γ0, and our theories are parallel to classical theories of strength Γ0 such as
̂
ID<ω, FP0, ATR0, Σ1
1-DC0 + (SUB), and Σ1
1-AC0 + (SUB). We also relate these theo-
ries to the unfolding of ID1 which was already presented in the PhD thesis of the
ﬁrst author as a system of strength ψ(ΓΩ+1)
Keywords: Subsystems of second order arithmetic and inductive deﬁnitions,
Proof-theoretic ordinals, Unfolding
Mathematics Subject Classiﬁcation 2010: 03F03, 03F05, 03F015, 03F35
1 Introduction
The ordinal ψ(ΓΩ+1) appeared ﬁrst in [Bachmann, 1950], there it is denoted by
φFω2+1(1)+1(1).¹ This was the paper where Bachmann introduced the idea of us-
ing assigned fundamental sequences to ordinals of the third number class in or-
der to deﬁne large countable ordinals, and this is what Howard [Howard, 1972]
uses in his original ordinal analysis of ID1. ID1 is the theory of one generalized
positive inductive deﬁnition, and its proof-theoretic ordinal is now known as the
Bachmann-Howard ordinal.
Miller [Miller, 1976] proposed that ψ(ΓΩ+1) should be the proof-theoretic ordi-
nal of a theory that relates to ID1 as predicative analysis relates to ﬁrst order arith-
metic. Feferman’s unfolding program [Feferman, 1996] provides a way to identity
such a system because the unfolding of ﬁrst order arithmetic is proof-theoretically
equivalent to predicative analysis with proof-theoretic ordinal Γ0 (cf. [Feferman
and Strahm, 2000]).
For a history of the Bachmann method of describing constructive ordinals,
and how it gave way to the more modern approach, we refer to [Crossley and
Bridge Kister, 1986/87] and the preface of [Buchholz et al., 1981].
1 See section 2 for details on the notation system.
Ulrik Buchholtz: Department of Philosophy, Carnegie Mellon University, Pittsburgh, PA 15213-
3890, USA, e-mail: ulrikb@andrew.cmu.edu
Gerhard Jäger and Thomas Strahm: Institut für Informatik, Universität Bern, Neubrückstrasse
10, 3012 Bern, Switzerland, e-mail: {jaeger,strahm}@iam.unibe.ch

116
|
U. Buchholtz, G. Jäger, and T. Strahm
Buchholtz [Buchholtz, 2014] recently proved that the unfolding of ID1 has
proof-theoretic ordinal ψ(ΓΩ+1), which indeed relates to ψ(εΩ+1) (the ordinal of
ID1) as Γ0 relates to ε0 (the ordinal of ﬁrst order Peano arithmetic).
In this paper we survey a range of further systems which also have proof-
theoretic strength ψ(ΓΩ+1), for example Σ1
1-DC∙
0 + (SUB∙), ATR∙
0 + (SUB∙), FP∙
0 and
̂
ID∙
<ω.
Hancock [Hancock, 2000] separately conjectured that ψ(ΓΩ+1) is the ordinal
of a certain kind of Martin-Löf type theory. This is made precise and veriﬁed in
a companion article, which also identiﬁes a system of explicit mathematics of
strength ψ(ΓΩ+1).
The remainder of this paper is organized as follows: In the next section we
set up some ordinal-theoretic preliminaries, including the deﬁnition of ψ(ΓΩ+1)
and a review of derivation operators in the sense of Buchholz. Section 3 is cen-
tered around subsystems of second order arithmetic. Namely, we introduce sys-
tems Σ1
1-DC∙
0 + (SUB∙), ATR∙
0, and FP∙
0 resulting from their well-known relatives
Σ1
1-DC0 + (SUB), ATR0, and FP0 by admitting least ﬁxed points of arithmetical op-
erators in the base language of second order arithmetic. In Section 4 we review the
unfolding of ID1; it is employed in Section 5 to establish the lower bound ψ(ΓΩ+1)
of the above-mentioned systems via a formalized inductive model construction.
Section 6 is devoted to the deﬁnition of ﬁnitely iterated ﬁxed point theories ̂
ID∙
n
for n < ω and a reduction of FP∙
0 to the union of these theories, ̂
ID∙
<ω. In Section
7 we sketch the main lines of the ordinal analysis of ̂
ID∙
<ω, determining its proof-
theoretic upper bound ψ(ΓΩ+1). The paper concludes with a ﬁnal discussion on
related systems of strength ψ(ΓΩ+1) in the setting of Martin-Löf type theory as well
as Feferman’s explicit mathematics.
2 Ordinal notations
In this section we try to give an account of the ordinal-theoretic environment and
the ordinal-theoretic tools needed for putting the results of this article into per-
spective. We assume that the reader is familiar with the basic ordinal theory, the
Veblen hierarchy of normal functions and collapsing functions à la Buchholz.
A full exposition can be found in [Buchholz and Schütte, 1988], [Pohlers, 1989,
2009], and [Schütte, 1977].
Let On be the collection of all ordinals, Ωthe least uncountable ordinal,
and AP the collection of all additive principal numbers, meaning that α ∈AP iff
(∀η, ξ < α)(η + ξ < α). By α =NF α1 + ⋅⋅⋅+ αn we express that
α = α1 + ⋅⋅⋅+ αn
and
α1, . . . , αn ∈AP
and
αn ≤⋅⋅⋅≤α1 < α.

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
117
Then the following result about the existence of the Cantor normal form is stan-
dard.
Lemma 2.1. For every ordinal α with 0 < α and α ∉AP there exist uniquely deter-
mined ordinals α1, . . . , αn such that α =NF α1 + ⋅⋅⋅+ αn.
The binary Veblen function φ is inductively deﬁned by φ0ξ := ωξ for all ordinals ξ
and by choosing φα to be the enumeration function of the closed and unbounded
collection {ξ ∈On : ∀β < α(φβξ = ξ)} if α > 0. An ordinal α is called strongly
critical iff α = φα0, and we let SC be the collection of all strongly critical ordinals.
Now we set
α =NF φβ훾
:⇐⇒
α = φβ훾
and
β, 훾< α
and obtain the following normal form property. For a proof see, for example,
[Pohlers, 1989] or [Schütte, 1977].
Lemma 2.2. For every ordinal α ∈AP \ SC there exist uniquely determined ordinals
β and 훾such that α =NF φβ훾.
It is common to write Γα for the α-th strongly critical ordinal, hence Γ is the normal
function enumerating SC. Since ΓΩ= Ω, it follows that ΓΩ+1 is the least strongly
critical ordinal greater than Ω.
We now introduce for all ordinals α and β sets of ordinals C(α, β) and ordinals
ψα following [Buchholz, 1992].
Deﬁnition 2.3. The sets of ordinals C(α, β) and the ordinals ψα are deﬁned for all
ordinals α and β by induction on α.
1.
{0, Ω} ∪β ⊆C(α, β).
2.
If η, ξ ∈C(α, β), then η + ξ ∈C(α, β) and φηξ ∈C(α, β).
3.
If ξ < α and ξ ∈C(α, β), then ψξ ∈C(α, β).
4.
ψα := min{β ∈On : C(α, β) ∩Ω⊆β}.
The sets C(α, β) and the ordinals ψα have a series of important properties whose
proofs are not diﬃcult and can be found in the references mentioned above.
Lemma 2.4. For all ordinals α, α1, α2, β, 훾1, . . . , 훾n, we have:
1.
If β is a limit ordinal, then C(α, β) = ⋃{C(α, ξ) : ξ < β}.
2.
C(α, ψα) ∩Ω= ψα.
3.
ψα ∈SC.
4.
If 훾=NF 훾1 + ⋅⋅⋅+ 훾n and 훾∈C(α, β), then 훾1, . . . , 훾n ∈C(α, β).
5.
If 훾=NF φ훾1훾2 and 훾∈C(α, β), then 훾1, 훾2 ∈C(α, β).
6.
If α1 < α2 and α1 ∈C(α2, ψα2), then ψα1 < ψα2.
7.
If α1 ≤α2, then ψα1 ≤ψα2 and C(α1, ψα1) ⊆C(α2, ψα2).
8.
C(α, 0) = C(α, ψα).

118
|
U. Buchholtz, G. Jäger, and T. Strahm
So ψ is a weakly monotone function from On to the strongly critical ordinals less
than or equal to ψ(ΓΩ+1). It also follows that ψ(ΓΩ+1) is the largest segment of ordi-
nals in C(ΓΩ+1, ψΓΩ+1), i.e., the least ordinal that cannot be generated by closing
{0, Ω} under addition, ω-exponentiation, the binary Veblen function φ, and the
function ψ.
The function ψ is weakly monotone but not strictly monotone: for example,
if α = min{ξ ∈On : Γξ = ξ}, then ψβ = Γβ for all β ≤α and ψ훾= α for all 훾
such that α ≤훾≤Ω. In order to obtain unique representations of the ordinals in
C(ΓΩ+1, ψΓΩ+1) we introduce a further normal form. Given ordinals α and β we
deﬁne
α =NF ψβ
:⇐⇒
α = ψβ
and
β ∈C(β, ψβ).
A detailed proof of the following normal form theorem for the function ψ can be
found in [Pohlers, 1989].
Lemma 2.5. For every strongly critical ordinal α ∈C(ΓΩ+1, ψΓΩ+1) there exists a
uniquely determined ordinal β such that α =NF ψβ.
We end this section with some remarks about ordinal operators that will used to
deﬁne operator controlled derivations in the sense of Buchholz Buchholz [1992].
Deﬁnition 2.6. Let Pow(On) denote the collection of all sets of ordinals.
1.
A class function
H : Pow(On) →Pow(On)
is called a derivation operator iff it is monotone, inclusive plus idempotent
and satisﬁes the following properties for all X ∈Pow(On) and all ordinals
α, α1, . . . , αn:
(a) {0, Ω} ⊆H(X).
(b) If α =NF α1 + . . . αn, then
α ∈H(X) ↔{α1, . . . , αn} ⊆H(X).
(c) If α =NF φα1α2, then
α ∈H(X) ↔{α1, α2} ⊆H(X).
2.
If H is a derivation operator, we deﬁne for all ﬁnite sets of ordinals m and all
ordinals σ operators
H[m], H[σ], Hσ : Pow(On) →Pow(On)

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
119
by setting for all X ∈Pow(On):
H[m](X)
:=
H(X ∪m),
H[σ](X)
:=
H(X ∪{σ}),
Hσ(X)
:=
⋂{C(α, β) : X ⊆C(α, β) and σ < α}.
Buchholz [Buchholz, 1992] provides a detailed analysis of derivation operators
from which, in particular, we get all the properties summarized in the next lemma.
Lemma 2.7. If H is a derivation operator, then we have for all ﬁnite sets of ordinals
m, all ordinals σ, and all X ∈Pow(On):
1.
H[m], H[σ], and Hσ are derivation operators.
2.
m ⊆H(0)
㨐⇒
H[m] = H.
3.
σ ∈H(0)
㨐⇒
H[σ] = H.
3 Subsystems of second order arithmetic
Our language L2 of second order arithmetic contains number variables a, b, c,
u, v, w, x, y, z, . . . and set variables U, V, W, X, Y, Z, . . . (both possibly with sub-
scripts), function symbols for all primitive recursive functions, relation symbols
for all primitive recursive relations, the relation symbol ∈for the element relation
between natural numbers and sets of natural numbers as well as the standard
logical connectives and auxiliary symbols. In addition, we have a distinguished
anonymous unary relation symbol R that we use to deﬁne proof-theoretic ordi-
nals and also plays a special role in the unfolding systems (see below). The num-
ber terms and formulas of L2 are deﬁned as usual, and the arithmetic formulas
of L2 are those without bounded set quantiﬁers; number and set parameters are
permitted in arithmetic formulas.
Moreover, we frequently make use of the vector notation ⃗e as shorthand for a
ﬁnite string e1, . . . , en of expressions whose length is not important or is evident
from the context. Suppose now that ⃗a is the string of variables a1, . . . , an and ⃗r
the string of number terms r1, . . . , rn. Then A[ ⃗r/ ⃗a] is the formula that is obtained
from A by simultaneously replacing all free occurrences of the variables ⃗a by the
number terms ⃗r; in order to avoid collision of variables, a renaming of bounded
variables may be necessary. If the formula A is written as B[ ⃗a], then we often sim-
ply write B[ ⃗r] instead of A[ ⃗r/ ⃗a]; further variants of this notation below will be
obvious.
The binary (inﬁx) relation symbol = stands for the primitive recursive equality
relation, the binary (inﬁx) relation symbol < for the primitive recursive less-than

120
|
U. Buchholtz, G. Jäger, and T. Strahm
relation, and t耠for the successor of t. Very often we also write the same expres-
sion for a primitive recursive function (relation) as for the associated function (re-
lation) symbol. Equality is only taken as basic symbol between numbers; equality
between sets of numbers and functions is deﬁned as
(U = V)
:=
∀a(a ∈U ↔a ∈V).
In the following we make use of the standard primitive recursive coding machin-
ery in L2: ⟨r1, . . . , rn⟩stands for the primitive recursively formed n-tuple of the
number terms r1, . . . , rn; Seq is the primitive recursive set of sequence numbers;
lh(r) denotes the length of (the sequence number coded by) r; if i < lh(r), then (r)i
is the i-th component of (the sequence coded by) r, i.e., r = ⟨(r)0, . . . , (r)lh(r) .−1⟩
provided that r is a sequence number.
The ﬁrst order language L1 is the sub-language of L2 in which only formu-
las of L2 without set variables are permitted. Now we pick a fresh unary relation
symbol P and write L1(P) for the extension of L1 by P, i.e., expressions of the
form P(t) are permitted as atomic formulas of L1(P). An L1(P) formula is called
P-positive if each occurrence of P in this formula is positive. We call P-positive
formulas that contain at most u free inductive operator forms and let A[P, u] range
over such forms. If A[P, u] does not contain the anonymous relation symbol R, it
is called a pure inductive operator form.
Next we extend the language L2 to a new second order language L∙
2 by adding
a fresh unary relation symbol PA for every pure inductive operator form A[P, u];
the number terms of L∙
2 are, of course, the number terms of L2. An L∙
2 formula is
called elementary in case it does not contain bounded set variables. As syntactic
variables we use r, s, t, r0, s0, t0, . . . for number terms and A, B, C, A0, B0, C0, . . .
for formulas of L∙
2.
In the following we introduce a series of theories of second order arithmetic.
The weakest of those, the theory ACA0 is formulated in L2 and has the usual ax-
ioms and rules of inference of two-sorted logic with equality for the ﬁrst sort, the
axioms of primitive recursive arithmetic PRA for the primitive recursive functions
and relations plus the axiom schema of arithmetic comprehension, i.e.,
∃X∀a(a ∈X ↔A[a])
for all arithmetic formulas A[u] of L2, and the induction axiom
∀X(0 ∈X ∧∀a(a ∈X →a耠∈X) →∀a(a ∈Y)).

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
121
Well-known extensions of ACA0 are obtained by adding axioms about comprehen-
sion and choice, for example
∀a(∃XA[X, a] ↔∀XB[X, a]) →∃Y∀a(a ∈Y ↔∃XA[X, a]),
(∆1
1-CA)
∀a∃XC[a, X] →∃Y∀aC[a, (Y)a],
(Σ1
1-AC)
∀a∀X∃YD[a, X, Y] →∃Z∀aD[a, (Z)a, (Z)a],
(Σ1
1-DC)
where A[U, v], B[U, v], C[u, V], and D[u, V, W] are arithmetic formulas of L2. In
these formulations we are using the abbreviations
r ∈(U)s
:=
⟨r, s⟩∈U,
r ∈(U)s
:=
r ∈U ∧r = ⟨(r)0, (r)1⟩∧(r)1 < s.
We write ∆1
1-CA0, Σ1
1-AC0, and Σ1
1-DC0 for the theories ACA0 + (∆1
1-CA), ACA0 +
(Σ1
1-AC), and ACA0 + (Σ1
1-DC), respectively, and recall that ∆1
1-CA0 and Σ1
1-AC0
are conservative extensions of Peano arithmetic PA, whereas Σ1
1-DC0 has proof-
theoretic ordinal φω0. For details see [Barwise and Schlipf, 1975], [Buchholz
et al., 1981], and [Cantini, 1986].
Before turning to the next principle, we introduce some notation: If A and
B[v] are L2 formulas, then AU[{a : B[a]}] indicates the result of substituting B[r]
for each occurrence of (r ∈U) in A. The substitution rule is the rule of inference
∀XA
AX[{a : B[a]}]
(SUB)
for arithmetic L2 formulas A[U] and arbitrary L2 formulas B[v]. Obviously, the
bar rule
∀XTI[⊲, X]
TI[⊲, {a : B[a]}]
for binary primitive recursive relations ⊲is a special case of (SUB). Here TI[⊲, U]
stands for the formula
∀x(∀y(y ⊲x →y ∈U) →x ∈U) →∀x(x ∈U).
From [Feferman and Jäger, 1983] we know that ∆1
1-CA0+(SUB), Σ1
1-AC0+(SUB), and
Σ1
1-DC0 + (SUB) are proof-theoretically equivalent and of proof-theoretic strength
Γ0.
In the later considerations two further theories in L2 will play an important
role: The ﬁrst is the theory ATR0 – the fourth system of Friedman’s program of
reverse mathematics – that extends ACA0 by the schema of arithmetic transﬁnite
recursion; a standard reference is [Simpson, 2009]. The second is the ﬁxed point
theory FP0, resulting from ACA0 by adding the ﬁxed point axioms
∃X∀a(a ∈X ↔A[X, a])
(FP)

122
|
U. Buchholtz, G. Jäger, and T. Strahm
for all U-positive arithmetic formulas A[U, v]. As shown in [Avigad, 1996], ATR0
and FP0 are equivalent.
Theorem 3.1. An L2 formula is provable in ATR0 if and only if it is provable in FP0.
After these preliminary remarks we now turn to the theories that interest us most
in this article. They are all formulated in the language L∙
2 and comprise the fol-
lowing least ﬁxed point axioms
∀a(A[PA, a] →PA(a)),
(ID.1)
∀X(∀a(A[X, a] →a ∈X) →∀a(PA(a) →a ∈X)).
(ID.2)
for all inductive operator forms A[P, u]. Please observe that (ID.2) only claims
minimality with respect to sets, not with respect to L∙
2 deﬁnable classes.
The theory ACA∙
0 is the L∙
2 system that contains the axioms of ACA0 (formu-
lated for L∙
2), all least ﬁxed point axioms (ID.1) and (ID.2) plus the comprehension
schema
∃X∀a(a ∈X ↔A[a]),
(E-CA)
for elementary L∙
2 formulas A[u]. As a consequence, any PA deﬁnes a set in ACA∙
0.
It is an easy exercise to show that ACA∙
0 is a conservative extension of the fa-
mous theory ID1 of non-iterated positive inductive deﬁnitions; for details about
ID1 cf., for example, [Buchholz et al., 1981] or [Pohlers, 2009].
The schemas (∆1
1-CA∙), (Σ1
1-AC∙), and (Σ1
1-DC∙) are the analogues of (∆1
1-CA),
(Σ1
1-AC), and (Σ1
1-DC) with the arithmetic L2 formulas replaced by elementary L∙
2
formulas. Accordingly, the theories ∆1
1-CA∙
0, Σ1
1-AC∙
0, and Σ1
1-DC∙
0 are deﬁned to be
the theories ACA∙
0 + (∆1
1-CA∙), ACA∙
0 + (Σ1
1-AC∙), and ACA∙
0 + (Σ1
1-DC∙).
Of course, there is also an analogue of the substitution rule for the language
L∙
2. Simply consider
∀XA
AX[{a : B[a]}]
(SUB∙)
for all elementary L∙
2 formulas A[U] and arbitrary L∙
2 formulas B[v]. Thus the bar
rule for L∙
2 reads as
∀XTI[⊲, X]
TI[⊲, {a : B[a]}]
for binary relations ⊲that are primitive recursive in the least ﬁxed points PA and
arbitrary L∙
2 formulas B[v], and is a special case of (SUB∙).²
2 It is because of (SUB∙) that we restrict ourselves to pure operator forms in L∙
2.

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
123
In the following we shall prove that ∆1
1-CA∙
0 + (SUB∙), Σ1
1-AC∙
0 + (SUB∙), and
Σ1
1-DC∙
0 + (SUB∙) are theories with proof-theoretic ordinal ψ(ΓΩ+1). Two other in-
teresting systems of the same strength are ATR∙
0 and FP∙
0, obtained from ATR0 and
FP0, respectively, by relativizing them to the language L∙
2.
More precisely, let the schema of elementary transﬁnite recursion be as the
schema of arithmetic transﬁnite recursion but with elementary L∙
2 formulas in-
stead of arithmetic L2 formulas. Then ATR∙
0 is the extension of ACA∙
0 by elementary
transﬁnite recursion. Similarly, the ﬁxed point axioms of L2 are lifted to
∃X∀a(a ∈X ↔A[X, a])
(FP∙)
for arbitrary U-positive elementary formulas A[U, v] of L∙
2, and FP∙
0 is the L∙
2 the-
ory ACA∙
0 + (FP∙).
There exists a close relationship between our theories formulated in L2 and
their counterparts in L∙
2. Consider an inductive operator form A[U, v] together
with the axiom schema
∃X(∀a(A[X, a] →a ∈X) ∧∀Y(∀a(A[Y, a] →a ∈Y) →X ⊆Y))
(LFP)
for all inductive operator forms A[U, v]. Added to ACA0 it implies that every induc-
tive operator form has a least ﬁxed point, where “least” means least with respect
to all sets that are ﬁxed points.
Theorem 3.2. Let T be one of the theories ACA0, ∆1
1-CA0, Σ1
1-AC0, Σ1
1-DC0, ATR0, or
FP0, which are all formulated in L2. Then we have:
1.
T∙, which is formulated in L∙
2, is a conservative extension of T + (LFP) with re-
spect to all L2 sentences.
2.
ATR∙
0 and FP∙
0 prove the same L∙
2 formulas.
Proof: Since every relation constant PA for an inductive operator form A[U, v]
deﬁnes a set, all instances of (LFP) are provable in the theories T∙. Therefore,
T +(LFP) ⊆T∙. To establish conservativity, we simply ﬁx for each inductive opera-
tor form A[U, v] the uniquely determined least ﬁxed point U, which exists accord-
ing to (LFP), and interpret PA(t) as (t ∈U). These considerations together with
Theorem 3.1 also yield the second assertion.
We write M[U] to express that U is ( the range of the sets of) a countable coded
ω-model of Σ1
1-DC0 in the sense of [Simpson, 2009]. Elementhood in such an U is
then abbreviated by
V
̇∈U
:=
∃a(V = (U)a),
and
⃗V
̇∈U means that all components of
⃗V belong to U. Moreover, given an
arbitrary L2 formula A, its relativization AU to U is obtained from A by re-

124
|
U. Buchholtz, G. Jäger, and T. Strahm
placing all quantiﬁers ∃X(. . . X . . .) and ∀X(. . . X . . .) by ∃x(. . . (U)x . . .) and
∀x(. . . (U)x . . .), respectively. Note that AU is always arithmetic.
The theory ATR0 has the following important property; cf. [Simpson, 2009]
for a detailed proof and a discussion of the general context.
Theorem 3.3. The theory ATR0 proves that
∀X∃Y(X
̇∈Y ∧M[Y]).
For the subsequent considerations we let A0[U, v], A1[U, v], A2[U, v], . . . be an
arbitrary (but ﬁxed) enumeration of all inductive operator forms and write
Fi[X] := ∀a(Ai[U, a] →a ∈U) ∧∀Y(∀a(Ai[Y, a] →a ∈Y) →X ⊆Y),
expressing that set X is the least ﬁxed point of Ai[U, v]. For any natural number
n we write For(n) for the collection of all L∙
2 formulas that do not contain relation
symbols PAi with n < i.
Lemma 3.4. Let n be an arbitrary natural number. Under the assumptions
1.
A[ ⃗U] is an L2 formula whose free set variables are from the list
⃗U,
2.
Σ1
1-DC∙
0 + (SUB∙) proves A[ ⃗U] by a proof P such that all formulas occurring in P
belong to For(n),
3.
the set variables W0, . . . , Wn do not occur in P, and B[ ⃗U] is the formula ob-
tained from A[ ⃗U] by substituting (t ∈Wi) for each subformula PAi(t), i =
0, . . . , n,
the theory ATR0 proves
∀Z((
n
⋀
i=0
(Fi[Wi] ∧Wi
̇∈Z) ∧
⃗U
̇∈Z ∧M[Z]) →BZ[ ⃗U]).
Proof: We proceed by induction on P. If A[ ⃗U] is an axiom of Σ1
1-DC∙
0, then our as-
sertion is obvious since we relativize with respect to countable coded ω-models of
Σ1
1-DC0; if A[ ⃗U] is the conclusion of a rule of inference diﬀerent from (SUB∙), then
our assertion follows directly from the induction hypothesis. So it only remains to
discuss the case that A[ ⃗U] is the conclusion of (SUB∙). Then this inference has the
form
∀XC[ ⃗U, X]
C[ ⃗U, {x : D[ ⃗U, x]}]
,
where A[ ⃗U] is the formula C[ ⃗U, {x : D[ ⃗U, x]}], C[ ⃗U, V] is an elementary L∙
2 for-
mula, and D[ ⃗U, v] an arbitrary L∙
2 formula. Let E[ ⃗U, V]and F[ ⃗U, v] be the L2 for-
mulas obtained from C[ ⃗U, V] and D[ ⃗U, v], respectively, by substituting (t ∈Wi)
for each subformula PAi(t), i = 0, . . . , n. In view of the induction hypothesis ATR0

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
125
proves
∀Z((
n
⋀
i=0
(Fi[Wi] ∧Wi
̇∈Z) ∧
⃗U
̇∈Z ∧M[Z]) →(∀X
̇∈Z)E[ ⃗U, X]),
(*)
and we have to show in ATR0 that
∀Z((
n
⋀
i=0
(Fi[Wi] ∧Wi
̇∈Z) ∧
⃗U
̇∈Z ∧M[Z]) →E[ ⃗U, {x : DZ[ ⃗U, x]}]).
Working within ATR0, pick a Z such that
n
⋀
i=0
(Fi[Wi] ∧Wi
̇∈Z) ∧
⃗U
̇∈Z ∧M[Z].
By Theorem 3.3 there exists an Y0 for which
n
⋀
i=0
(Fi[Wi] ∧Wi
̇∈Y0) ∧
⃗U
̇∈Y0 ∧Z
̇∈Y0 ∧M[Y0].
Hence {x : DZ[ ⃗U, x]} is a set in Y0, i.e., there exists an X0 with
X0
̇∈Y0 ∧∀a(a ∈X0 ↔DZ[ ⃗U, a]).
Now we go back to (*), and obtain (by inserting Y0 for Z and X0 for X) that
E[ ⃗U, X0], hence E[ ⃗U, {x : DZ[ ⃗U, x]}]. This is what we had to show.
Theorem 3.5. Let A[U] be an arithmetic formula of L2 with no set variables besides
U. Then we have that
Σ1
1-DC∙
0 + (SUB∙) ⊢∀XA[X]
㨐⇒
ATR0 + (LFP) ⊢∀XA[X].
Proof: From our assumption we obtain that there exists a natural number n and
a proof of A[ ⃗U] in Σ1
1-DC∙
0 + (SUB∙) such that all formulas in this proof belong to
For(n). We choose fresh set variables W0, . . . , Wn not occurring in this proof and
see by the previous lemma that ATR0 proves
∀Z((
n
⋀
i=0
(Fi[Wi] ∧Wi
̇∈Z) ∧U
̇∈Z ∧M[Z]) →A[U]),
hence also
∃X0 . . . ∃Xn∃Z(
n
⋀
i=0
(Fi[Xi] ∧Xi
̇∈Z) ∧U
̇∈Z ∧M[Z]) →A[U].
In view of the schema (LFP) and Theorem 3.3, this means that A[U] is provable in
ATR0 + (LFP). Consequently, ATR0 + (LFP) proves ∀XA[X].

126
|
U. Buchholtz, G. Jäger, and T. Strahm
Corollary 3.6. Let A[U] be an arithmetic formula of L2 with no set variables besides
U. Then we have that
Σ1
1-DC∙
0 + (SUB∙) ⊢∀XA[X]
㨐⇒
ATR∙
0 ⊢∀XA[X].
Let us conclude this section with some remarks on the anonymous relation symbol
R. Clearly, in the context of L2 and L∙
2 it plays the same role as any unspeciﬁed
free set variable and would have been superﬂuous. More speciﬁcally: if T is one
of the L2 or L∙
2 theories considered so far, then T proves A if and only if it proves
∀XAR[X], where AR[U] is obtained from A by replacing all occurrences of R(t) by
(t ∈U).
In the next sections we shall turn to several ﬁrst order theories, and then it
is convenient to work within a syntax that provides for a place holder for arbi-
trary non-speciﬁed properties. A typical example is the ﬁrst order deﬁnition of
the proof-theoretic ordinal of a theory. For any primitive recursive relation ⊲we
set
TI[⊲, R]
:=
∀x(∀y(y ⊲x →R(y)) →R(x)) →∀xR(x).
Then if T is a theory formulated in a language containing the ﬁrst order part of L2,
the ordinal α is called provable in T if and only if there exists a primitive recursive
well ordering ⊲of order type α such that T proves TI[⊲, R]. The proof-theoretic
ordinal |T| of T is deﬁned to be the least ordinal not provable in T.
Furthermore, it is more or less obvious that in the presence of (SUB∙) the fol-
lowing variant of the substitution rule is available. It will be needed for interpret-
ing the substitution rule of the unfolding of ID1, described in the next section.
Lemma 3.7. Let A be an elementary L∙
2 formula and B[u] an arbitrary L∙
2 formula.
If Σ1
1-DC∙
0 +(SUB∙) proves A, then Σ1
1-DC∙
0 +(SUB∙) also proves AR[{a : B[a]}], where
AR[{a : B[a]}] here indicates the result of substituting B[t] for each occurrence of
R(t) in A.
4 Unfolding of ID1
In this section we deﬁne the unfolding of ID1 as in [Buchholtz, 2014]. This is an
instance of Feferman’s unfolding program [Feferman, 1996], for a general exposi-
tion, see also [Buchholtz, 2014]. This is deﬁned in two steps; ﬁrst the operational
unfolding U0(ID1) is introduced, and then the full unfolding U(ID1) is deﬁned as
an extension.
Let L∙
1 denote the fragment of L∙
2 without free or bound set variables (and thus
also without the ∈relation). We use here a version of the unfolding in which the

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
127
operational structure is given by a partial combinatory algebra. The language of
U0(ID1) is the language L∙
1 extended with new constants k and s (combinators), p,
p0 and p1 (pairing and projection), d (deﬁnition by cases), tt (true) and ﬀ(false),
e (equality), and the binary function symbol ⋅(application). Terms are built in
the usual way using variables and constants and closing under application and
the function symbols of L∙
2. Further, we add a unary relation symbol N (natural
numbers), and to account for partiality of application we also add a unary relation
symbol ↓(deﬁned; expressing that a term has a value). When writing terms we
drop the symbol for application and use the convention that application is left-
associative to leave out parentheses. We often write f(a1, . . . , an) for f a1 . . . an
and ⟨⟨a, b⟩⟩for p a b.
For U0(ID1) we use Beeson’s Logic of Partial Terms with strictness and equal-
ity, see [Beeson, 1985]. The non-logical axioms of U0(ID1) are:
1.
The usual axioms of arithmetic, relativized to N, with the schematic form of
complete induction on the natural numbers,
R(0) ∧∀x(N(x) ∧R(x) →R(x耠)) →∀x(N(x) →R(x)).
2.
The least ﬁxed point axioms for each PA in schematic form relativized to N,³
∀a(N(a) ∧AN[PA, a] →PA(a)),
(∀a(N(a) ∧AN[R, a] →R(a)) →∀a(N(a) ∧PA(a) →R(a))).
3.
Partial combinatory algebra (PCA) axioms with pairing and deﬁnition by
cases:
(a) k a b = a.
(b) s a b↓∧s a b c ≃a c (b c).
(c) p0⟨⟨a, b⟩⟩= a ∧p1⟨⟨a, b⟩⟩= b.
(d) d a b tt = a ∧d a b ﬀ= b.
4.
Decidable equality on natural numbers:
(a) ∀x, y(N(x) ∧N(y) →e x y = tt ∨e x y = ﬀ).
(b) ∀x, y(N(x) ∧N(y) →(e x y = tt ↔x = y)).
In addition, U0(ID1) includes the unrestricted substitution rule,
A
AR[{a : B[a]}] ,
(SUB)
where, because of partiality, AR[{a : B[a]}] indicates the result of substituting
(r↓∧B[r]) for each occurrence of R(r) in A.
3 As usual, AN denotes the formula A with all quantiﬁers relativized to N.

128
|
U. Buchholtz, G. Jäger, and T. Strahm
Abstraction terms λx.t can be deﬁned as usual, and from the PCA axioms we
can show in U0(ID1):
1.
(λx.t)↓∧(λx.t) x ≃t
2.
s↓→(λx.t) s ≃t[s/x]
Here, t ≃s is an abbreviation for t↓∨s↓→t = s. Note that we use the notation
of the λ-calculus even though the conversion relation is not exactly the same (in
particular, it does not validate the (ξ)-rule of the λ-calculus).
The PCA axioms allow us to introduce a ﬁxed point operator, but we cannot
prove that it produces least ﬁxed points.
Theorem 4.1 (Fixed point). There is a closed term ﬁx of U0(ID1) such that
U0(ID1) ⊢ﬁx f↓∧ﬁx f x ≃f (ﬁx f) x.
The language of the full unfolding U(ID1) extends the language by additional con-
stants to reﬂect the predicates of U0(ID1): nat (natural number), iA (inductive set),
eq (equality), prR (anonymous relation symbol R), inv (inverse image), conj (con-
junction), neg (negation), un (universal quantiﬁcation over the natural numbers),
join (join, that is, disjoint union). In addition, we add the unary relation symbol Π
(predicates) and the binary relation symbol ∈(predication). The axioms of U(ID1)
extend the ones of U0(ID1) by
5.
Basic axioms about predicates:
(a) Π(nat) ∧∀x(x ∈nat ↔N(x)).
(b) Π(iA) ∧∀x(x ∈iA ↔PA(x)).
(c) Π(eq) ∧∀x(x ∈eq ↔∃y(x = ⟨⟨y, y⟩⟩)).
(d) Π(prR) ∧∀x(x ∈prR ↔R(x)).
(e) Π(a) →Π(inv(a, f)) ∧∀x(x ∈inv(a, f) ↔f x ∈a).
(f) Π(a) ∧Π(b) →Π(conj(a, b)) ∧∀x(x ∈conj(a, b) ↔x ∈a ∧x ∈b).
(g) Π(a) →Π(neg a) ∧∀x(x ∈neg(a) ↔¬(x ∈a)).
(h) Π(a) →Π(un a) ∧∀x(x ∈un(a) ↔∀y(N(y) →⟨⟨x, y⟩⟩∈a)).
6.
The dependent join axiom:
Π(a) ∧(∀y ∈a)Π(f y) →Π(join(f, a))
∧∀x(x ∈join(f, a) ↔∃y, z(x = ⟨⟨y, z⟩⟩∧y ∈a ∧z ∈f(y))).
Finally, U(ID1) contains the restricted substitution rule
A
AR[{a : B[a]}] ,
(SUB)
where A is any formula in the language of U0(ID1) and B is any formula in the lan-
guage of U(ID1) (with the same convention as for the substitution rule for U0(ID1)).

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
129
5 Lower proof-theoretic bound
We deﬁne an interpretation of U(ID1) into Σ1
1-AC∙
0 + (SUB∙) in which we interpret
the operational constants using indices of partial recursive functions. The pred-
icates are then interpreted via a ﬁxed point of an elementary positive operator
form A[Q+, x, y, z] where Q is a new ternary relation symbol. For the interpreta-
tion we need only consider a particular proof in U(ID1), and since such a proof
refers only to ﬁnitely many of the least ﬁxed points PA we can for simplicity (and
because there is a universal such case), assume that A refers to a single inductive
predicate PA (which we ﬁx throughout this section).
The ﬁxed point QA[x, y, z] of A[Q+, x, y, z] is obtained in Σ1
1-AC∙
0 using, as
usual, Aczel’s trick (cf. Feferman Feferman [1982]). In particular, we can consider
the class C of formulas ∃XA[X, ⃗x], where A is an elementary formula with the same
restrictions as for the operator A. There is a quinary C formula E[z, x1, x2, x3, x4]
that enumerates the quaternary C formulas. Using diagonalization we can then
obtain a ternary C formula PA that is our desired ﬁxed point of the operator A. We
record this as a lemma.
Lemma 5.1. There is a C formula QA[x, y, z] such that Σ1
1-AC∙
0 proves
∀x, y, z(AQ[QA, x, y, z] ↔QA[x, y, z])
where AQ[QA, x, y, z] denotes the formula obtained from A[Q+, x, y, z] by replac-
ing each occurrence of Q(s, t, u) with QA[s, t, u].
The operational unfolding U0(ID1) is interpreted in the usual way using its model
in the partial recursive functions. See for example [Feferman and Strahm, 2000].
In particular, a b is interpreted as {a}(b) in the sense of ordinary recursion theory.
In order to interpret predicates we need codes of the following forms:
Table 1. Predicates and their codes
Predicate
Code
nat
⟨0, 0⟩
eq
⟨1, 0⟩
iA
⟨2, 0⟩
prR
⟨3, 0⟩
neg(a)
⟨4, a⟩
un(a)
⟨5, a⟩
conj(a, b)
⟨6, a, b⟩
inv(a, f)
⟨7, a, f⟩
join(f, a)
⟨8, f, a⟩

130
|
U. Buchholtz, G. Jäger, and T. Strahm
Thus, for example, the constant neg is interpreted as the index ̂
neg for a partial
recursive function such that {̂
neg}(a) = ⟨4, a⟩. We use the ternary ﬁxed point
QA[x, y, z] with following informal interpretation:
QA[x, 0, 0]
x is a predicate
QA[x, y, 1]
y ∈x
QA[x, y, 2]
y ∉x
The operator form A[Q, a, b, c] is now deﬁned to be the disjunction of the follow-
ing 26 clauses:
1.
a = ⟨0, 0⟩∧b = 0 ∧c = 0,
2.
a = ⟨0, 0⟩∧c = 1,
3.
a = ⟨1, 0⟩∧b = 0 ∧c = 0,
4.
a = ⟨1, 0⟩∧∃x(b = ⟨x, x⟩) ∧c = 1,
5.
a = ⟨1, 0⟩∧∀x(b
̸= ⟨x, x⟩) ∧c = 2,
6.
a = ⟨2, 0⟩∧b = 0 ∧c = 0,
7.
a = ⟨2, 0⟩∧PA(b) ∧c = 1,
8.
a = ⟨2, 0⟩∧¬PA(b) ∧c = 2,
9.
a = ⟨3, 0⟩∧b = 0 ∧c = 0,
10. a = ⟨3, 0⟩∧R(b) ∧c = 1,
11. a = ⟨3, 0⟩∧¬R(b) ∧c = 2,
12. ∃x(a = ⟨4, x⟩∧Q(x, 0, 0)) ∧b = 0 ∧c = 0,
13. ∃x(a = ⟨4, x⟩∧Q(x, 0, 0) ∧Q(x, b, 2)) ∧c = 1,
14. ∃x(a = ⟨4, x⟩∧Q(x, 0, 0) ∧Q(x, b, 1)) ∧c = 2,
15. ∃x(a = ⟨5, x⟩∧Q(x, 0, 0)) ∧b = 0 ∧c = 0,
16. ∃x(a = ⟨5, x⟩∧Q(x, 0, 0) ∧∀yQ(x, ⟨b, y⟩, 1) ∧c = 1,
17.
∃x(a = ⟨5, x⟩∧Q(x, 0, 0) ∧∃yQ(x, ⟨b, y⟩, 2) ∧c = 2,
18. ∃x, y(a = ⟨6, x, y⟩∧Q(x, 0, 0) ∧Q(y, 0, 0)) ∧b = 0 ∧c = 0,
19. ∃x, y(a = ⟨6, x, y⟩∧Q(x, 0, 0) ∧Q(y, 0, 0) ∧Q(x, b, 1) ∧Q(y, b, 1)) ∧c = 1.
20. ∃x, y(a = ⟨6, x, y⟩∧Q(x, 0, 0) ∧Q(y, 0, 0) ∧(Q(x, b, 2) ∨Q(y, b, 2))) ∧c = 2.
21. ∃x, f(a = ⟨7, x, f⟩∧Q(x, 0, 0)) ∧b = 0 ∧c = 0,
22. ∃x, f(a = ⟨7, x, f⟩∧Q(x, 0, 0) ∧Q(x, {f}(b), 1)) ∧c = 1,
23. ∃x, f(a = ⟨7, x, f⟩∧Q(x, 0, 0) ∧({f}(b)↑∨Q(x, {f}(b), 2)) ∧c = 2,
24. ∃f, x(a = ⟨8, f, x⟩∧Q(x, 0, 0) ∧∀y(Q(x, y, 2) ∨Q({f}(y), 0, 0)))
∧b = 0 ∧c = 0,
25. ∃f, x(a = ⟨8, f, x⟩∧Q(x, 0, 0) ∧∀y(Q(x, y, 2) ∨Q({f}(y), 0, 0))
∧∃u, v(b = ⟨u, v⟩∧Q(x, u, 1) ∧Q({f}(u), v, 1)) ∧c = 1,
26. ∃f, x(a = ⟨8, f, x⟩∧Q(x, 0, 0) ∧∀y(Q(x, y, 2) ∨Q({f}(y), 0, 0))
∧∀u, v(b
̸= ⟨u, v⟩∨Q(x, u, 2) ∨Q({f}(u), v, 2)) ∧c = 2.

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
131
We can now deﬁne
Π(x) := QA[x, 0, 0] ∧∀y(QA[x, y, 2] ↔¬QA[x, y, 1]),
y ∈x := Π(x) ∧QA[x, y, 1].
A similar trick was used by Feferman in [Feferman, 1982] in order to model uni-
verses in type theory and explicit mathematics. It is now a matter of routine to
verify that this deﬁnes an interpretation ∗of U(ID1) into Σ1
1-AC∙
0 + (SUB∙). Note
that according to this interpretation, the premise of the substitution rule trans-
lates into an elementary formula of L∙
2.
Theorem 5.2. The system U(ID1) is contained in the system Σ1
1-AC∙
0 +(SUB∙) via the
translation ∗.
Hence, using [Buchholtz, 2014], we get following:
Corollary 5.3. ψ(ΓΩ+1) ≤|U(ID1)| ≤|Σ1
1-AC∙
0 + (SUB∙)|.
In fact, the lower bound proof in [Buchholtz, 2014] can also be carried through in
∆1
1-CA∙
0 + (SUB∙). As usual, jump hierarchies of elementary operators can be built
using ∆1
1 comprehension, see for example [Schütte, 1977].
Theorem 5.4. ψ(ΓΩ+1) ≤|∆1
1-CA∙
0 + (SUB∙)|.
6 Finitely iterated ﬁxed point theories
The aim of this section is to introduce ﬁrst order theories ̂
ID∙
n, for all natural num-
bers n ≥1, and to reduce FP∙
0 to the union of those. In the next section we shall
then carry through the ordinal analysis of the theories ̂
ID∙
n and thus determine the
upper proof-theoretic bound of FP∙
0 and the systems equivalent to FP∙
0.
The theories ̂
ID∙
n are the analogues of the well-known ﬁxed point theories ̂
IDn,
see [Feferman, 1982] or [Jäger et al., 1999], but with ID1 rather than PA as the base
theory. The languages L∙(n) are deﬁned by induction on n as follows:
1.
L∙(0) is the ﬁrst order part L∙
1 of the language L∙
2.
2.
Given L∙(n−1), we ﬁrst determine the collection C(n−1) of all (not necessarily
pure) inductive operator forms A[P, u] formulated in L∙(n −1), then select a
fresh unary relation symbol P(n)
A for each A[P, u] from C(n −1), and let L∙(n)
be the extension of L∙(n −1) by these new relation symbols, i.e.,
L∙(n) := L∙(n −1) ∪{P(n)
A : A[P, u] ∈C(n −1)}.

132
|
U. Buchholtz, G. Jäger, and T. Strahm
For any natural number n ≥1, the the theory ̂
ID∙
n is formulated in the language
L∙(n), its logic is the usual ﬁrst order predicate logic with equality. The non-logical
axioms of ̂
ID∙
n are:
(A1) All axioms of primitive recursive arithmetic PRA plus the schema of complete
induction on the natural numbers for all formulas of L∙(n).
(A2) The least ﬁxed point axioms
∀a(A[PA, a] →PA(a)),
(1)
∀a(A[{x : B[x]}, a] →B[a]) →∀a(PA(a) →B[a])
(2)
for all inductive operator forms A[P, u] of L1 and all formulas B[u] of L∙(n).
(A3) The ﬁxed point axioms
∀a(A[P(m)
A , a] ↔P(m)
A (a))
for all natural numbers m with 1 ≤m ≤n and all inductive operator forms
A[P, u] from C(m −1).
L∙(< ω) is the union of the languages L∙(n) and ̂
ID∙
<ω is the union of the theories
̂
ID∙
n,
̂
ID∙
<ω := ⋃{̂
ID∙
n : 1 ≤n < ω}.
The following theorem is the analogue of Avigad’s reduction of FP0 to the theory
̂
ID<ω of ﬁnitely iterated ﬁxed points above PA; for details see Avigad [1996].
Theorem 6.1. FP∙
0 is a conservative extension of ̂
ID∙
<ω with respect to all formulas of
L∙(0). In other words, if FP∙
0 proves the L∙(0) formula A, then ̂
ID∙
<ω proves A as well.
Proof: Taking up the strategy of Avigad [1996], we can establish this theorem by
a model-theoretic argument. All we have to show is that any (ﬁrst order) model
of ̂
ID∙
<ω can be extended to a (second order) model of FP∙
0 that validates the same
formulas of L∙(0).
So let 필be a model of ̂
ID∙
<ω, write |필| for the universe of 필, and denote the
필-interpretations of the relation symbols PA for least ﬁxed points and P(n)
A for
arbitrary ﬁxed points by 필(PA) and 필(P(n)
A ), respectively. Then we deﬁne 핊필to be
the collection of all these sets 필(PA) and 필(P(n)
A ) plus their projections. Finally,
(필, 핊필) is the second order extension of 필where 핊필takes care of the second
order part. Clearly, we have
필　㨐A ↔(필, 핊필) 　㨐A
for all formulas A of L∙(0). It remains to show that (필, 핊필) is a model of FP∙
0. For
dealing with the ﬁxed point axioms, consider an U-positive elementary formula

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
133
A[U, V1, . . . , Vm, x, y1, . . . , yn] with at most the indicated free set and number
variables. To simplify notation we assume m = n = 1. We have to show that
(필, 핊필) 　㨐∀X∀a∃Y∀b(b ∈Y ↔A[Y, X, b, a]).
(*)
To do so, choose an element p ∈|필| and a set M ∈핊필, given, for example, as
M = {i ∈|필| : ⟨i, q⟩∈필(P(k)
B )}
for some ﬁxed point relation symbol P(k)
B and some q ∈|필|. Now we deﬁne the
formula C[P, u] to be
u = ⟨(u)0, (u)1, (u)2⟩⟩∧
A[{x : P(⟨x, (u)1, (u)2⟩)}, {x : P(k)
B (⟨x, (u)2⟩)}, (u)0, (u)1].
and observe that C[P, u] is an inductive operator form with respect to the language
L∙(k). For the set
N := {i ∈|필| : ⟨i, p, q⟩∈필(P(k+1)
C
)}
and all i ∈|필| we thus have
i ∈N ↔⟨i, p, q⟩∈필(P(k+1)
C
),
↔(필, 핊필) 　㨐C[P(k+1)
C
, ⟨i, p, q⟩],
↔(필, 핊필) 　㨐A[N, M, i, p].
Hence N is the required ﬁxed point, and (*) has been validated. All other cases are
straightforward or treated similarly.
By methods similar to those in [Avigad, 1996], the previous theorem can also be
proved in a purely syntactic and proof-theoretic manner. We also conjecture that
the speed-up result of [Avigad, 1996] carries over to FP∙
0 and ̂
ID∙
<ω.
7 Upper proof-theoretic bound
To establish the upper proof-theoretic bounds on the theories ̂
ID∙
n we shall com-
bine methods of predicative and impredicative cut-elimination. To this end we
ﬁrst extend the languages L∙(n) to languages L∙∞(n) by adding for inductive op-
erator form A[P, u] and each ordinal α < Ωa new unary relation symbol P<α
A .
These relation symbols are used to represent the stages of the least ﬁxed points PA.
Then we restrict ourselves to the fragment of closed L∙∞(n) formulas A in negation-
normal form and deﬁne ¬A by de Morgan’s rules and the law of double negation.

134
|
U. Buchholtz, G. Jäger, and T. Strahm
We now turn to inﬁnite calculi, and in order to measure and control the com-
plexities of inﬁnite derivations we need control over the ranks and ordinal param-
eters of formulas occurring in inﬁnite derivations.
Deﬁnition 7.1 (Rank and parameter set).
1.
The rank, rk(A), of a closed L∙∞(n) formula A in negation-normal form is de-
ﬁned inductively as follows:
(a) rk(A) := rk(¬A) := 0 for closed atomic L1 formulas A,
(b) rk(P<α
A (t)) := rk(¬P<α
A (t)) := ωα for α < Ω,
(c) rk(PA(t)) := rk(¬PA(t)) := Ω,
(d) rk(P(m)
A (t)) := rk(¬P(m)
A (t)) := Ω,
(e) rk(A ∧B) := rk(A ∨B) := max{rk(A), rk(B)} + 1,
(f) rk(∃xA[x]) := rk(∀xA[x]) := rk(A[0]) + 1,
2.
The parameter set, |A|, of a closed L∙∞(n) formula A in negation-normal form
is deﬁned to be the set of the ordinals α occurring in subformulas P<α
A (t) in A.
Note that the deﬁnition of rank ensures that rk(A[P<β, s]) < rk(P<α
A (s)) for β < α.
Given any natural number n, we now introduce an inﬁnitary system ̂
ID∙∞
n in
Tait-style, and use the capital Greek letters Γ, Θ, Λ, possibly with subscripts, for
ﬁnite sets of closed L∙∞(n) formulas in negation-normal form. Also, we write (for
example) Γ, Θ, A, B for Γ ∪Θ ∪{A, B}. If Γ is the set {A1, . . . , An} of closed L∙∞(n)
formulas in negation-normal form, then |Γ| := |A1|∪⋅⋅⋅∪|An| is the parameter set
of Γ.
Axioms of ̂
ID∙∞
n :
1.
Γ, A whenever A is a true atomic L1 formula.
2.
Γ, ¬B whenever B is a false atomic L1 formula.
3.
Γ, ¬R(s), R(t) for numerically equivalent closed terms s and t.
4.
Γ, ¬P(m)
A (s), P(m)
A (t) for numerically equivalent closed terms s and t.
Basic rules of inference of ̂
ID∙∞
n :
(∨)
Γ, A, B
Γ, A ∨B
(∧)
Γ, A
Γ, B
Γ, A ∧B
(∃)
Γ, A[s]
Γ, ∃xA[x]
(∀)
Γ, A[s] for all closed s
Γ, ∀xA[x]
(P(m)
A )
Γ, A[P(m)
A , s]
Γ, P(m)
A (s)
if m ≤n
(¬P(m)
A )
Γ, ¬A[P(m)
A , s]
Γ, ¬P(m)
A (s)
if m ≤n

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
135
Cuts of ̂
ID∙∞
n :
(cut)
Γ, A
Γ, ¬A
Γ
Closure rules of ̂
ID∙∞
n :
(Cl-PA)
Γ, A[PA, s]
Γ, PA(s)
Ordinal rules of inference of ̂
ID∙∞
n :
(P<α
A )
Γ, A[P<β
A , s]
Γ, P<α
A (s)
if β < α
(¬P<α
A )
Γ, ¬A[P<ξ
A , s] for all ξ < α
Γ, ¬P<α
A (s)
(PA)
Γ, A[P<β
A , s]
Γ, PA(s)
if β < Ω
(¬PA)
Γ, ¬A[P<ξ
A , s] for all ξ < Ω
Γ, ¬PA(s)
The formulas A and ¬A in the premises of (cut) are called the cut formulas of this
cut. The rank of a cut is the rank of its cut formulas.
For the ordinal assignment to proofs and the subsequent cut elimination and col-
lapsing we follow [Buchholz, 1992] and make use of his approach to operator con-
trolled derivations.
Deﬁnition 7.2. Let H be a derivation operator and let Γ be a ﬁnite set of closed
L∙∞(n) formulas in negation-normal form. Then ̂
ID∙∞
n , H
ρ
α Γ is deﬁned for all ordi-
nals α and ρ by induction on α.
1.
If Γ is an axiom of ̂
ID∙∞
n and |Γ| ∪{α} ⊆H(0), then ̂
ID∙∞
n , H
ρ
α Γ for all ordinals
ρ.
2.
If ̂
ID∙∞
n , H
ρ
α0 Γi and α0 < α for every premise of a basic inference of ̂
ID∙∞
n or a
cut of rank less than ρ and if |Γ| ∪{α} ⊆H(0) for the conclusion Γ of this rule,
then ̂
ID∙∞
n , H ρ
α Γ.
3.
If ̂
ID∙∞
n , H
ρ
α0 Γ, A[P<σ
A , s] for some σ < τ and σ, α0 < α and if |Γ, P<τ
A (s)|∪{α} ⊆
H(0), then ̂
ID∙∞
n , H ρ
α Γ, P<τ
A (s).
4.
If ̂
ID∙∞
n , H[σ]
ρ
ασ Γ, ¬A[P<σ
A , s] and ασ < α for all σ < τ and if |Γ, ¬P<τ
A (s)|∪{α} ⊆
H(0), then ̂
ID∙∞
n , H ρ
α Γ, ¬P<τ
A (s).
5.
If ̂
ID∙∞
n , H
ρ
α0 Γ, A[P<σ
A , s] for some σ < Ωand σ, α0 < α and if |Γ, PA(s)|∪{α} ⊆
H(0), then ̂
ID∙∞
n , H ρ
α Γ, PA(s).
6.
If ̂
ID∙∞
n , H[σ]
ρ
ασ Γ, ¬A[P<σ
A , s] and ασ < α for all σ < Ωand if |Γ, ¬PA(s)|∪{α} ⊆
H(0), then ̂
ID∙∞
n , H ρ
α Γ, ¬PA(s).
7.
If ̂
ID∙∞
n , H[σ]
ρ
α0 Γ, A[PA, s] and α0 + 1 < α and if |Γ, PA(s)| ∪{α} ⊆H(0), then
̂
ID∙∞
n , H ρ
α Γ, PA(s).

136
|
U. Buchholtz, G. Jäger, and T. Strahm
We write ̂
ID∙∞
n , H
ρ
<α Γ to mean there exists an α0 < α with ̂
ID∙∞
n , H
ρ
α0 Γ.
In the remaining part of this article we describe (or sketch) how to employ the
inﬁnitary systems for establishing the upper proof-theoretic bound of the theories
̂
IDn. Our main reference is again [Buchholz, 1992] where an analogous analysis
has been carried out in full details for a theory that is similar to (or even more
complicated than) our systems as far as impredicative methods of proof theory
are concerned. We state the main results and believe that it should not be too
complicated for the reader to ﬁll in the missing details.
First observe that the inﬁnitary systems ̂
ID∙∞
n have the property that all in-
stances of complete induction on the natural numbers and all instances of least
ﬁxed point induction are provable, in particular by making use of the inﬁnitary
rules (∀) and (¬PA). However, the price is that we have to deal with complex
derivations of inﬁnitary depths. As a consequence we obtain a canonical embed-
ding theorem.
Theorem 7.3 (Embedding). Let A be a closed L∙(n) formula A in negation-normal
form. If ̂
ID∙
n ⊢A, then there exists a natural number k such that for all derivation
operators H,
̂
ID∙∞
n , H
Ω+k
<εΩ+1 A.
Now we move on to cut elimination. It is easy to convince oneself that the ax-
ioms and rules of inference of the inﬁnitary systems ̂
ID∙∞
n and the deﬁnitions of the
ranks of closed L∙∞(n) formulas in negation-normal form are so that cuts of ranks
greater than Ωcan be eliminated without any problems. As usual, ω0(α) := α and
ωk+1(α) := ωωk(α) for all ordinals α and natural numbers k.
Lemma 7.4 (Partial cut elimination). If Γ is a ﬁnite set of closed L∙∞(n) formulas in
negation-normal form, then we have for all derivation operators H, all ordinals α,
and all natural numbers k:
̂
ID∙∞
n , H Ω+1+k
α
Γ
㨐⇒
̂
ID∙∞
n , H
Ω+1
ωk(α) Γ.
The next step is to eliminate the ﬁxed points P(m)
A . To achieve this, we can make use
of standard elimination procedures for ﬁnitely many ﬁxed points by asymmetric
interpretations as, for example, in [Cantini, 1985], [Jäger and Strahm, 1996], or
[Marzetta and Strahm, 1997].
Lemma 7.5 (Elimination of ﬁxed points). If Γ is a ﬁnite set of closed L∙∞(n) formu-
las in negation-normal form, then we have for all derivation operators H and all
ordinals α:
̂
ID∙∞
n+1, H Ω+1
<α
Γ
㨐⇒
̂
ID∙∞
n , H
Ω+1
<φα0 Γ.

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
137
Cut formulas of rank less than Ωare eliminated by methods of predicative cut
elimination as presented in [Schütte, 1977]; for all details concerning predicative
cut elimination in the presence of derivation functions see [Buchholz, 1992].
Lemma 7.6 (Predicative cut elimination). If Γ is a ﬁnite set of closed L∙∞(0) formu-
las in negation-normal form, then we have for all derivation operators H, allordinals
α, and all ordinals β and ρ with β, ρ < Ωand ρ ∈H(0):
̂
ID∙∞
n , H β+ωρ
α
Γ
㨐⇒
̂
ID∙∞
n , H
β
φρα Γ.
So it only remains to deal with cut formulas of the form PA(t) and ¬PA(t), and
here the boundedness and collapsing techniques enter the picture. Let POS be
the collection of all closed L∙∞(0) formulas in negation-normal form that do not
contain subformulas of the form ¬PA(t); i.e., POS is the collection of all closed
L∙∞(0) formulas in negation-normal form that are positive in the least ﬁxed point
relations PA. In addition, if A belongs to POS and α is an ordinal less than Ω,
then A(<α) is the formula obtained from A if all occurrences of PA(t) are replaced
by P<α
A (t). For the proof of this boundedness and collapsing lemma consult again
[Buchholz, 1992].
Lemma 7.7 (Boundedness and Collapsing).
1.
For all ﬁnite sets Γ of closed L∙∞(n) formulas in negation-normal form, all and
elements A of POS, all derivation operators H, and all ordinals α, β, ρ such that
α ≤β < Ωand β ∈H(0) we have:
̂
ID∙∞
0 , H ρ
α Γ, A
㨐⇒
̂
ID∙∞
0 , H ρ
α Γ, A(<β).
2.
Suppose that Γ is a ﬁnite subset of POS and σ an ordinal such that |Γ| ⊆C(σ +
1, ψ(σ + 1)) and σ ∈Hσ[|Γ|](0). Then we have for all ordinals α and β := σ +
ωΩ+α:
̂
ID∙∞
0 , Hσ[|Γ|] Ω+1
α
Γ
㨐⇒
̂
ID∙∞
0 , Hβ[|Γ|] ψβ
ψβ Γ.
Combining Theorem 7.3 with the series of Lemmas 7.4 to 7.7 and carrying through
some ordinal calculations, we obtain complete cut elimination for the closed L1
formulas provable in one of the theories ̂
IDn.
Theorem 7.8 (Complete cut elimination). Let A be a closed formula of the lan-
guage L1 and suppose that A is provable in ̂
IDn for some natural number n ≥1.
Then there exist a derivation operator H and an ordinal α < ψ(ΓΩ+1) such that
̂
ID∙∞
0 , H 0
α A.
By standard proof theory this result immediately gives us the upper bound result
for the theory ̂
ID∙
<ω: If ̂
ID∙
<ω proves TI[⊲, R] for some primitive recursive well or-
dering ⊲, then there exists a natural number n large enough such that ̂
IDn proves

138
|
U. Buchholtz, G. Jäger, and T. Strahm
TI[⊲, R]. In view of the previous theorem this implies
̂
ID∙∞
0 , H 0
α TI[⊲, R]
for some derivation operator H and some ordinal α < ψ(ΓΩ+1). Finally, as shown
in [Schütte, 1977], we can conclude that the depth of a cut free derivation of
TI[⊲, R] essentially bounds the order type of this well ordering.
Corollary 7.9. |̂
ID∙
<ω| ≤ψ(ΓΩ+1).
It only remains to see this upper bound result in the context of Theorem 3.2, Corol-
lary 3.6, Theorem 5.2, Corollary 5.3, and Theorem 6.1 in order to conclude the or-
dinal analysis of the main theories of this article.
Corollary 7.10 (Proof-theoretic ordinal).
ψ(ΓΩ+1) = |̂
ID∙
<ω| = |FP∙
0| = |ATR∙
0|
= |Σ1
1-DC∙
0 + (SUB∙)| = |Σ1
1-AC∙
0 + (SUB∙)| = |U(ID1)|.
8 Discussion
We have identiﬁed several systems in classical logic of strength ψ(ΓΩ+1) (cf. Corol-
lary 7.10). Our results are a parallel to those characterizing classical systems of
strength Γ0,
Γ0 = |̂
ID<ω| = |FP0| = |ATR0|
= |Σ1
1-DC0 + (SUB)| = |Σ1
1-AC0 + (SUB)| = |U(NFA)|.
(See [Feferman, 1982] for ̂
ID<ω, [Avigad, 1996] for FP0, [Simpson, 2009] for the sub-
systems of second order arithmetic, and Feferman and [Feferman and Strahm,
2000] for U(NFA).)
A companion article in preparation shall establish similar results for con-
structive systems. In particular, we shall verify the conjecture of Hancock [Han-
cock, 2000] by studying a predicative type theory in the style of [Martin-Löf, 1975]
(i.e., a dependent type theory with an externally indexed hierarchy of predica-
tive universes (Un)n<ω) extended with a single well-ordering type (belonging to
all universes) corresponding to the constructive tree ordinals (a type Ord with
constructors zero of type Ord, successor of type Ord →Ord and limit of type
(Nat →Ord) →Ord). This will parallel the result of Feferman [Feferman, 1982]
that the strength of the predicative type theory itself is Γ0. Also of interest is an
analogous system of explicit mathematics, similarly containing a hierarchy of uni-
verses (as in [Feferman, 1982]) and a type of constructive tree ordinals.

Theories of Proof-Theoretic Strength ψ(ΓΩ+1)
|
139
References
J. Avigad. On the relationship between ATR0 and ̂
ID<ω. J. Symb. Logic, 61(3):768–779, 1996.
H. Bachmann. Die Normalfunktionen und das Problem der ausgezeichneten Folgen von Ord-
nungszahlen. Vierteljahresschr. Naturforsch. Ges. Zürich, 95:115–147, 1950.
K. J. Barwise and J. Schlipf. On recursively saturated models of arithmetic. In D. H. Saracino
and V. B. Weispfenning, editors, Model Theory and Algebra, volume 498 of Lecture Notes
in Mathematics, pages 42–55. Springer, 1975.
M. J. Beeson. Foundations of Constructive Mathematics: Metamathematical Studies, volume 6
of Ergebnisse der Mathematik und ihrer Grenzgebiete (3). Springer, 1985.
U. Buchholtz. Unfolding of Systems of Inductive Deﬁnitions. PhD thesis, Department of Mathe-
matics, Stanford University, 2014.
W. Buchholz. A simpliﬁed version of local predicativity. In P. Aczel, H. Simmons, and S. S.
Wainer, editors, Proof theory: A Selection of Papers from the Leeds Proof Theory Pro-
gramme 1990, pages 115–147. Cambridge Univ. Press, 1992.
W. Buchholz and K. Schütte. Proof Theory and Impredicative Subsystems of Aanlysis, volume 2
of Studies in Proof Theory, Monographs. Bibliopolis, 1988.
W. Buchholz, S. Feferman, W. Pohlers, and W. Sieg. Iterated Inductive Deﬁnitions and Sub-
systems of Analysis: Recent Proof-Theoretical Studies, volume 897 of Lecture Notes in
Mathematics. Springer, 1981.
A. Cantini. A note on a predicatively reducible theory of iterated elementary induction. Boll.
Unione Mat. Ital. (B), 6:413–430, 1985.
A. Cantini. On the relation between choice and comprehension principles in second order
arithmetic. J. Symb. Logic, 51(2):360–373, 1986.
J. N. Crossley and J. Bridge Kister. Natural well-orderings. Arch. Math. Logik Grundlagenforsch.,
26(1–2):57–76, 1986/87.
S. Feferman. Iterated inductive ﬁxed-point theories: application to Hancock’s conjecture. In
G. Metakides, editor, The Patras Symposion, pages 171–196. North-Holland, 1982.
S. Feferman. Gödel’s program for new axioms: Why, where, how and what? In P. Hájek, editor,
Gödel ’96, volume 6 of Lecture Notes in Logic, pages 3–22. Springer, 1996.
S. Feferman and G. Jäger. Choice principles, the bar rule and autonomously iterated compre-
hension schemes in analysis. J. Symb. Logic, 48(1):63–70, 1983.
S. Feferman and T. Strahm. The unfolding of non-ﬁnitist arithmetic. Ann. Pure Appl. Logic, 104
(1-3):75–96, 2000.
P. G. Hancock. Ordinals and Interactive Programs. PhD thesis, Laboratory for Foundations of
Computer Science, University of Edinburgh, 2000.
W. A. Howard. A system of abstract constructive ordinals. J. Symb. Logic, 37:355–374, 1972.
G. Jäger and T. Strahm. Some theories with positive induction of ordinal strength φω0. J. Symb.
Logic, 61(3):818–842, 1996.
G. Jäger, R. Kahle, A. Setzer, and T. Strahm. The proof-theoretic analysis of transﬁnitely iterated
ﬁxed point theories. J. Symb. Logic, 64(1):53–67, 1999.
P. Martin-Löf. An intuitionistic theory of types: predicative part. In Logic Colloquium ’73 (Bristol,
1973), volume 80 of Studies in Logic and the Foundations of Mathematics, pages 73–118.
North-Holland, 1975.

140
|
U. Buchholtz, G. Jäger, and T. Strahm
M. Marzetta and T. Strahm. The µ quantiﬁcation operator in explicit mathematics with uni-
verses and iterated ﬁxed point theories with ordinals. Arch. Math. Logic, 37(5+6):391–413,
1997.
L. W. Miller. Normal functions and constructive ordinal notations. J. Symb. Logic, 41(2):439–
459, 1976.
W. Pohlers. Proof Theory. An Introduction, volume 1407 of Lecture Notes in Mathematics.
Springer, 1989.
W. Pohlers. Proof Theory. The First Step into Impredicativity. Universitext. Springer, 2009.
K. Schütte. Proof Theory, volume 225 of Grundlehren der mathematischen Wissenschaften.
Springer, 1977.
S. G. Simpson. Subsystems of Second Order Arithmetic. Perspectives in Logic. Cambridge Univ.
Press, 2nd edition, 2009.

Thierry Coquand and Henri Lombardi
Some Remarks about Normal Rings
Abstract: We give a constructive proof that R[X] is normal when R is normal. We
apply this result to an operation needed for studying the henselization of a local
ring. Our proof is based on the case where R is without zero divisors, which is more
involved than the case where R is an integral domain. We have to use a construc-
tive deciphering technique that replaces the use of minimal primes (in classical
mathematics) by suitable explicit localizations in a suitable tree.
Keywords: Normal ring, Pf-ring, Constructive mathematics, Gcd tree.
Mathematics Subject Classiﬁcation 2010: 13B22, 13B30, 13B40, 03F65
1 Introduction
An integrally closed domain R is an integral domain whose integral closure in its
ﬁeld of fraction is R itself. An element b is integral over an ideal I iﬀb satisﬁes an
integral relation
bn + u1bn−1 + ⋅⋅⋅+ un = 0
with ul in Il. We can reformulate the deﬁnition of being integrally closed by stating
that whenever b is integral over ⟨a⟩then b belongs to ⟨a⟩. In this form, this deﬁni-
tion makes sense even if R is an arbitrary ring (not necessarily a domain) and this
characterizes the notion of normal ring. It can be checked that this is equivalent to
the following: any localization of R at a prime ideal is an integrally closed integral
domain ([Ducos et al., 2004, Proposition 6.4]).
This paper is mainly concerned with the analysis of the following classical
result: if R is an integrally closed domain then so is R[X]. We ﬁrst recall a proof
which reduces this result to Kronecker’s Theorem ([Lombardi and Quitté, 2015,
Theorem 3.3]). Interestingly, the argument depends in a crucial how we interpret
constructively the notion of “integral domain”. Logically, to be an integral domain
can be stated as
∀x.∀y. xy = 0 →[x = 0 ∨y = 0]
(1)
which is classically, but not constructively, equivalent to
∀x. x = 0 ∨[∀y.xy = 0 →y = 0].
(2)
Thierry Coquand: Department of Computer Science, Chalmers, University of Göteborg, 41296
Göteborg, Sweden, e-mail: thierry.coquand@cse.gu.se
Henri Lombardi: Laboratoire de Mathématiques. Université de Franche-Comté.
F-25030 Besançon Cedex, e-mail: henri.lombardi@univ-fcomte.fr

142
|
T. Coquand and H. Lombardi
On this form, this means that any element is 0 or is regular. This Deﬁnition (2)
is actually the usual deﬁnition of integral domain in constructive mathematics
(Lombardi and Quitté [2015], Mines et al. [1988]). With this deﬁnition the argument
using Kronecker’s Theorem makes sense constructively.
The deﬁnition (1) also has been considered in constructive algebra: a ring sat-
isfying this condition is called a ring without zero divisors (Lombardi and Quitté
[2015]). The main part of this paper presents a proof that if R is a normal ring with-
out zero divisors than so is R[X]. What is surprising is that this proof seems to re-
quire a technique which is used for analyzing argument involving minimal prime
ideal ([Lombardi and Quitté, 2015, Section XV-7]). Furthermore, the proof involves
the introduction of the notion of gcd tree of two polynomials, which is important
in other context (Alonso et al. [2014]). Going from Deﬁnition (2) to Deﬁnition (1),
classically equivalent, requires a much more complex argument.
The advantage of Deﬁnition (1) is that it is now relatively easy to conclude from
this that, more generally, if R is normal (without any integrality condition) then
so is R[X]. The last section analyzes a connected operation useful for studying the
henselization of a local ring.
2 Constructible and Gcd trees
Given a reduced ring R we deﬁne the notion of constructible tree for R. This is a
binary tree. To each node of this tree is associated a reduced ring, and R is asso-
ciated to the root of the tree. Such a tree can only grow in the following way: we
choose a leaf, and an element a of the ring S associated to this leaf. We add then
two sons to this node: to the left branch we associate the ring S[1/a] and to the
right branch the ring S/√⟨a⟩. Any such tree deﬁnes a partition of the constructible
spectrum of R (Johnstone [1986]).
If we look at the leftmost branch of this tree, we see that the leaf is of the form
R[1/(a1 ⋅⋅⋅an)] and so is a localization of the ring R.
The main proofs in this note will be by induction on the size of a given con-
structible tree.
If we have two polynomials P and Q in R[X] we can associate a constructible tree
which corresponds to the formal computation of the gcd of P and Q. To each leaf
S are also associated polynomials A, B, G, P1, Q1 in S[X], with G monic, which
witness the computation of the gcd of P and Q
AP1 + BQ1 = 1
P = GP1
Q = GQ1.

Some Remarks bout Normal Rings
|
143
Notice that for building this tree, R does not need to be discrete (i.e. to have a
decidable equality). Here is a simple example: P = X2 and Q = aX + b. We start
by the two branches S0 = R[1/a] and S1 = R/√⟨a⟩. Over S0 we have the two
branches S00 = S0[1/b] and S01 = S0/√⟨b⟩. Over S1 we have the two branches
S10 = S1[1/b] and S11 = S1/√⟨b⟩. The gcd is 1 over S00 and S10, and is X over S01
and is X2 over S11.
This tree is called the gcd tree of P and Q.
If one of the polynomial is monic, one can reduce the size of this tree by using
subresultants (Apéry and Jouanoulou [2006]).
3 Kronecker’s Theorem
We shall only need a simple case of Kronecker’s Theorem ([Lombardi and Quitté,
2015, Theorem 3.3]).
Theorem 3.1. Let R be a ring, if Xm + a1Xm−1 + ⋅⋅⋅+ am divides a polynomial of the
form Xn + b1Xn−1 + ⋅⋅⋅+ bn in R[X] then a1, . . . , am are integral over the subring
of R generated by b1, . . . , bn.
Proof: We introduce the splitting algebra¹ T of Xn + b1Xn−1 + ⋅⋅⋅+ bn (Lombardi
and Quitté [2015]) so that Xn + b1Xn−1 + ⋅⋅⋅+ bn = (X −t1) ⋅⋅⋅(X −tn) in T[X]. The
ring R embeds in T and ai is a polynomial in t1, . . . , tn.
Corollary 3.2. Let R be a ring, if Y + a0Xm + ⋅⋅⋅+ am divides a polynominal of the
form Yn + b1Yn−1 + ⋅⋅⋅+ bn in R[X, Y] then all coeﬃcients a0, . . . , am are roots of
polynomials of the form Zl + p1Zl−1 +⋅⋅⋅+ pl where pi is a homogeneous polynomial
of degree i in b1, . . . , bn where bj has weight j.
Proof: It is enough to look at the case where a0, . . . , am are indeterminates, and R
is a polynomial ring on a0, . . . , am and some other indeterminates. By replacing Y
by XN for N big enough, we get that each a0, . . . , am is integral over ℤ[b1, . . . , bn]
and hence each ak is root of a polynomial of the form Zl + p1Zl−1 + ⋅⋅⋅+ pl where
pi is a polynomial in b1, . . . , bn. By replacing Y by Y/c where c is another inde-
terminate, we get that pi is homogeneous of degree i in b1, . . . , bn where bj has
weight j.
1 T = R[X1, . . . , Xn]/J(f) = R[x1, . . . , xn] where J(f) is the ideal of symmetric relators necessary
to identify ∏n
j=1(X −xj) with f(X) in T[X]. We let x = x1 and the quotient ring R[x] = R[X]/⟨f⟩
is identiﬁed with a subring of T. If g(X, Y) = f(X)−f(Y)
X−Y
then g(x1, X) = ∏n
i=2(X −xi) in T[X] and
g(x1, xj) = 0 for j ≥2.

144
|
T. Coquand and H. Lombardi
Corollary 3.3. Let R be a normal integral domain, then R[X] is a normal integral
domain.
Proof: We assume given P and Q in R[X] such that P is integral over ⟨Q⟩and
we want to show that P is in ⟨Q⟩in R[X]. Let K be the total fraction ﬁeld of R.
Since R is an integral domain, we can consider R to be a subring of K. Since K[X]
is euclidean, we know that P is in ⟨Q⟩in K[X] and we have cP = HQ for some
regular element c. Since P is integral over ⟨Q⟩we have a relation
Pn + A1QPn−1 + ⋅⋅⋅+ AnQn = 0
with A1, . . . , An in R[X] and so we can write
Yn + A1cYn−1 + ⋅⋅⋅+ Ancn = (Y −H)S(X, Y)
where S(X, Y) is a monic polynomial in R[X][Y]. Using Corollary 3.2, it follows that
all coeﬃcients of H are integral over ⟨c⟩and hence are in ⟨c⟩since R is normal.
We can then write H = cH1 and so c(P −QH1) = 0 in R[X]. It follows that we have
P = QH1 and hence P is in ⟨Q⟩in R[X].
This is the argument we are going to adapt in the case where R is normal and
without zero divisors.
4 Polynomial ring
We assume that R is normal without zero divisors and we show that R[X] is nor-
mal. We assume given P and Q in R[X] such that P is integral over ⟨Q⟩and we
want to show that P is in ⟨Q⟩in R[X].
Lemma 4.1. If R is normal then R is reduced.
Proof: If b2 = 0 then b is integral over ⟨0⟩and so is in ⟨0⟩.
Lemma 4.2. If R is normal then so is R[1/a].
Proof: For c and b in R, if c is integral over ⟨b⟩in R[1/a] we have a relation
(aNc)n + u1b(aNc)n−1 + ⋅⋅⋅+ unbn = 0 with u1, . . . , un in R. Since R is normal
we have aNc in ⟨b⟩.
Lemma 4.3. If R is without zero divisors then so is R[1/a].
Proof: We take two elements v = b/an and w = c/am of R[1/a] with b and c in R.
If we have vw = 0 in R[1/a] we have apbc = 0 in R for some p ⩾0. We have then
apb = 0 in R or apc = 0 in R, which implies that v = 0 or w = 0 in R[1/a].

Some Remarks bout Normal Rings
|
145
From now on in this section, we assume R to be a normal ring without zero divi-
sors.
Lemma 4.4. If P is integral over ⟨Q⟩and is in ⟨Q⟩in R[1/a][X] then a = 0 or P is in
⟨Q⟩in R[X].
Proof: We have H in R[X] such that aNP = QH for some N. We write c = aN. Since
P is integral over ⟨Q⟩we have a relation
Pn + A1QPn−1 + ⋅⋅⋅+ AnQn = 0
with A1, . . . , An in R[X] and so
Qn(Hn + A1cHn−1 + ⋅⋅⋅+ Ancn) = 0
in R[X]. Hence either Q = 0 in which case P = 0 is in ⟨Q⟩or we can write
Yn + A1cYn−1 + ⋅⋅⋅+ Ancn = (Y −H)S(X, Y)
where S(X, Y) is a monic polynomial in R[X][Y]. Using the corollary of Kronecker’s
Theorem 3.2, it follows that all coeﬃcients of H are integral over ⟨c⟩and hence are
in ⟨c⟩since R is normal. We can then write H = cH1 and so c(P−QH1) = 0 in R[X].
It follows that we have c = 0, that is equivalent to a = 0, or P = QH1 and hence P
is in ⟨Q⟩in R[X].
Lemma 4.5. If we have P and Q in R[X] and a constructible tree for R such as, at
all leaves S of this tree, we have P in ⟨Q⟩in S[X]. Then P is in ⟨Q⟩in R[X].
Proof: Look at the leftmost branch of this tree, indexed by elements a1, . . . , al, so
that S = S耠[1/al] where S耠= R[1/(a1 ⋅⋅⋅al−1)] is without zero divisors by Lemma
4.3 and is normal by Lemma 4.2. Using Lemma 4.4 we get that al = 0 in S耠or P is in
⟨Q⟩in S耠[X]. In the second case, we can shorten the leftmost branch to a1, . . . , al
and get a smaller tree. In the ﬁrst case where al = 0 in S耠, this means that the right
son S耠/⟨a⟩of S耠is equal to S耠and we also can shorten the tree. We conclude by
tree induction.
Theorem 4.6. If R is normal and without zero divisors then so is R[X].
Proof: We take P and Q in R[X] and we assume that we have a relation
Pn + A1QPn−1 + ⋅⋅⋅+ AnQn = 0
with n ⩾1 and A1, ⋅⋅⋅, An in R[X]. We have to show that P is in ⟨Q⟩in R[X].
We look now at the gcd tree of P and Q as deﬁned in the ﬁrst section. At all
leaves S of this tree, we have P1, Q1, G, A, B in S[X] satisfying
P = GP1, Q = GQ1, AP1 + BQ1 = 1

146
|
T. Coquand and H. Lombardi
in S[X] and G is monic. Since G is monic and
Pn + A1QPn−1 + ⋅⋅⋅+ AnQn = Gn(Pn
1 + A1Q1Pn−1
1
+ ⋅⋅⋅+ AnQn
1) = 0
we have
Pn
1 + A1Q1Pn−1
1
+ ⋅⋅⋅+ AnQn
1 = 0
and Q1 divides Pn
1. With AP1 + BQ1 = 1 this implies that Q1 is a unit and so P is
in ⟨Q⟩in S[X]. We can now apply Lemma 4.5.
5 Normal ring
We say that the ring is locally without zero divisors ([Lombardi and Quitté, 2015,
Lemma VIII-3.2]) if, and only if, whenever ab = 0 then there exists u such that
ua = 0 and (1 −u)b = 0. These rings are often called pf-rings. In this note, only
the notion of rings without zero divisors and locally without zero divisors will play
a role.
Lemma 5.1. If R is normal then R is locally without zero divisors.
Proof: If ab = 0 then b2 −(a + b)b = 0 so b is integral over ⟨a + b⟩and so is
in ⟨a + b⟩. We can write b = (a + b)u and so ua = (1 −u)b. This implies ua2 =
(1 −u)ba = 0 and so ua = (1 −u)b = 0 since R is reduced.
Theorem 5.2. If R is normal then so is R[X].
Proof: By Lemma 5.1, R is locally without zero divisors. Assume then that a poly-
nomial P ∈R[X] is integral over ⟨Q⟩in R[X]. Following the proof of Theorem
4.6, each time we use ab = 0 →a = 0 or b = 0, we split the “current ring
R[1/v]” in two rings R[1/vu] and R[1/v(1−u)] by using an u such that ua = 0 and
(1 −u)b = 0. We ﬁnd ﬁnally u1, . . . , um in R such that ⟨u1, . . . , um⟩= 1 and P
belongs to ⟨Q⟩in each R[1/uj][X]. It follows that P is in ⟨Q⟩as required.
6 The ring R{f}
Let f be a monic polynomial in R[X]. We can consider the extension S = R[X]/⟨f⟩
where f has a root x. We let fX be the formal derivative of f w.r.t. X, and we deﬁne
R{f} to be the localization S[1/fX(x)]. This construction is important to study the
properties of henselization of a local ring (Raynaud [1970]).
The goal of this section is to show that R{f} is normal whenever R is normal.
As in the previous section, we can ﬁrst assume that R is without zero divisors, and

Some Remarks bout Normal Rings
|
147
then use that a normal ring is locally without zero divisors to conclude. So in the
rest of the section, we assume that R is a normal ring without zero divisors.
If f = gh is the product of two monic polynomials g and h we have R{f} isomor-
phic to R{g}[1/h(x)]×R{h}[1/g(x)]. This remark is important since by using Lemma
4.2 we can reason by induction on the degree of f to show that R{f} is normal if R
is normal.
Lemma 6.1. If R is normal without zero divisors, and a in R and T = R[1/a] and
f = gf1 with g and f1 monic in T[X] then we have g and f1 in R[X] or a = 0.
Proof: Using Kronecker’s Theorem 3.1, each coeﬃcient of g and f1 is integral over
R. Since R is normal and without zero divisors, this implies that a = 0 or g and f1
are in R[X].
We have the trace map tr : S →R. If we introduce the splitting algebra ([Lombardi
and Quitté, 2015, Deﬁnition III-4.1]) of f and write f = (X −x1) ⋅⋅⋅(X −xn) with
x = x1 then the trace of h(x) ∈S is h(x1) + ⋅⋅⋅+ h(xn). If v = h(x) in S is integral
over ⟨a⟩S with a in R then all elements h(x1), . . . , h(xn) are integral over ⟨a⟩R
and so tr(v) is also integral over ⟨a⟩X and so is in ⟨a⟩X since R is normal. Also if
we write f(X) −f(Y) = (X −Y)g(X, Y) = ∑i gi(Y)Xi, we have fX(T) = g(T, T) and
g(x1, xj) = 0 for j
̸= 1. So we get for all v = h(x) = h(x1) in S
fX(x)h(x) = g(x1, x1)h(x1) = ∑i gi(x1)h(x1) xi
1
and for j
̸= 1
0 = g(x1, xj)h(xj) = ∑i gi(xj)h(xj) xi
1
so that, by summation, we get Tate’s formula ([Raynaud, 1970, Chapter VII, 1])
fX(x)v = ∑i tr(gi(x)v) xi.
Since each gi(x) is integral over R, we can state the following lemma.
Lemma 6.2. If R is normal, if a in R and if v in S is integral over ⟨a⟩S then fX(x)v is
in ⟨a⟩S.
Theorem 6.3. If R is normal then R{f} is normal.
Proof: We assume given p, q in R[X] such that p(x) is integral over ⟨q(x)⟩in S so
that we have a relation p(x)n + u1(x)q(x)p(x)n−1 + ⋅⋅⋅+ un(x)q(x)n = 0. The goal
is to show that p(x) is in q(x)S[fX(x)−1].
We look at the gcd tree of q and f, and the leftmost branch of this tree. At
the leaf of this branch we have a list of elements that we force to be invertible
a1, . . . , an and q1, f1, g, A, B in R[a−1] with a = a1 . . . an such that
f = gf1
q = gq1
1 = Af1 + Bq1.

148
|
T. Coquand and H. Lombardi
Furthermore g and hence f1 are monic since f is monic.
If f = f1 we have g = 1 and q = q1. In this case we have c = Af + Bq where
c = (a1 . . . an)m for some m and so we have c = B(x)q(x) in S = R[X]/⟨f⟩. We then
have a relation
(p(x)B(x))n + u1(x)c(p(x)B(x))n−1 + ⋅⋅⋅+ un(x)cn = 0
and hence, by Lemma 6.2, we get that p(x)B(x) is in ⟨c⟩in S[fX(x)−1]. Hence we
have l(x) in S and N such that
fX(x)Np(x)B(x) = cl(x) = q(x)B(x)l(x)
and so
c(p(x)fX(x)N −l(x)q(x)) = 0.
We have then c = 0 or p(x) is in ⟨q(x)⟩in R[fX(x)−1]. So either we have the desired
conclusion that p(x) is in ⟨q(x)⟩or we have an = 0 in R[1/(a1 ⋅⋅⋅an−1)] and we
can shorten the computation tree of the gcd of f and q.
If f and f1 have not the same degree, we have found a proper decomposition f =
gf1 of f in R[1/a] with a = a1 ⋅⋅⋅an. In this case, since R is normal, by Lemma 6.1,
we have two subcases
–
either g and f1 are in R[X] and we can conclude by induction on the degree of
f, using that R{f} isomorphic to R{g}[1/f1] × R{f1}[1/g],
–
or a = 0 and as in the previous case, we can shorten the computation tree of
the gcd of f and q.
As in ([Lombardi and Quitté, 2015, VIII-4.4]), we say that a ring is a Prüfer ring if
it is arithmetic and reduced. A coherent Prüfer ring is an arithmetic pp-ring.
Corollary 6.4. If R is a Prüfer ring of Krull dimension ⩽1 then so is R{f}.
Proof: We use the fact that a ring is normal coherent ring of Krull dimension ⩽1
if, and only if, it is Prüfer and of Krull dimension ⩽1 (Ducos et al. [2004]). We
have shown that R{f} is normal. Since S = R[X]/⟨f⟩is an integral extension of R
it is also of Krull dimension ⩽1 (Coquand et al. [2009]) and so is its localization
R{f}. Finally, S is a ﬁnite free R-module, and so it is coherent if R is coherent and
so is its localization R{f}.
This gives an alternative proof to the main result of (Coquand et al. [2010]), that
R{f} is Prüfer when R = k[X], in the case where f is monic in Y. It is possible
however to reduce the general case to this case, by a change of variables.

Some Remarks bout Normal Rings
|
149
References
M. E. Alonso, T. Coquand, and H. Lombardi. Revisiting Zariski main theorem from a constructive
point of view. Journal of Algebra, 406:46–68, 2014. 10.1016/j.jalgebra.2014.02.003. URL
http://dx.doi/10.1016/j.jalgebra.2014.02.003.
François Apéry and Jean-Pierre Jouanoulou. Élimination: le cas d’une variable. Hermann, Paris,
2006.
Thierry Coquand, Lionel Ducos, Henri Lombardi, and Claude Quitté. Constructive Krull dimen-
sion. I. Integral extensions. Journal of Algebra and its Applications, 8(1):129–138, 2009.
10.1142/S0219498809003199. URL http://dx.doi/10.1142/S0219498809003199.
Thierry Coquand, Henri Lombardi, and Claude Quitté. Curves and coherent Prüfer rings. Journal
of Symbolic Computation, 45(12):1378–1390, 2010. 10.1016/j.jsc.2010.06.016. URL
http://dx.doi/10.1016/j.jsc.2010.06.016.
L. Ducos, H. Lombardi, C. Quitté, and M. Salou. Théorie algorithmique des anneaux arithmé-
tiques, des anneaux de Prüfer et des anneaux de Dedekind. Journal of Algebra, 281(2):
604–650, 2004. 10.1016/j.jalgebra.2004.06.030. URL http://dx.doi/10.1016/j.jalgebra.
2004.06.030.
Peter T. Johnstone. Stone spaces, volume 3 of Cambridge Studies in Advanced Mathematics.
Cambridge University Press, Cambridge, 1986. Reprint of the 1982 edition.
Henri Lombardi and Claude Quitté. Commutative algebra: constructive methods, volume 20 of
Algebra and Applications. Springer, Dordrecht, revised edition, 2015. 10.1007/978-94-
017-9944-7. URL http://dx.doi/10.1007/978-94-017-9944-7. Finite projective modules,
Translated from the French by Tania K. Roblot.
Ray Mines, Fred Richman, and Wim Ruitenburg. A course in constructive algebra. Universitext.
Springer, New York, 1988. 10.1007/978-1-4419-8640-5. URL http://dx.doi/10.1007/978-1-
4419-8640-5.
Michel Raynaud. Anneaux locaux henséliens. Lecture Notes in Mathematics, Vol. 169. Springer,
Berlin-New York, 1970.


Kosta Došen
On Sets of Premises
Abstract: Conceiving of premises as collected into sets or multisets, instead of se-
quences, may lead to triviality for classical and intuitionistic logic in general proof
theory, where we investigate identity of deductions. Any two deductions with the
same premises and the same conclusions become equal. In terms of categorial
proof theory, this is a consequence of a simple fact concerning adjunction with a
full and faithful functor applied to the adjunction between the diagonal functor
and the product biendofunctor, which corresponds to the conjunction connective.
Keywords: Sequent, Deduction, Identity of deductions, Contraction, Isomor-
phism of formulae, Categories, Adjunction, Diagonal functor, Product, Conjunc-
tion
Mathematics Subject Classiﬁcation 2010: 03F03, 03F07
1 Introduction
General proof theory addresses the question “What is a proof?”, or rather “What
is a deduction?” — a deduction being a hypothetical proof, i.e. a proof with hy-
potheses — by dealing with questions related to normal forms for deductions,
and in particular with the question of identity criteria for deductions. It deals with
the structure of deductions, as exhibited, for example, with the help of the typed
lambda calculus in the Curry-Howard correspondence, and not with their strength
measured by ordinals, which is what one ﬁnds in proof theory that arose out of
Hilbert’s programme.
Much of general proof theory is the ﬁeld of categorial proof theory. Funda-
mental notions of category theory like the notion of adjoint functor, and very im-
portant structures like cartesian closed categories, came to be of central concern
for logic in that ﬁeld. Through results of categorial proof theory called coherence
results, which provide a model theory for equality of deductions, logic ﬁnds new
ties with geometry, topology and algebra (see the books [Došen, 1999], [Došen and
Petrić, 2004] and [Došen and Petrić, 2007a], the more recent introductory survey
[Došen, 2014], and references therein).
Kosta Došen: Faculty of Philosophy, University of Belgrade, and Mathematical Institute, Ser-
bian Academy of Sciences and Arts, Knez Mihailova 36, p.f. 367, 11001 Belgrade,
e-mail: kosta@mi.sanu.ac.rs

152
|
K. Došen
In general proof theory, and in particular in categorial proof theory, one looks
for an algebra of deductions, and for that, one concentrates on the operations of
this algebra, which come with the inference rules. As an equational theory, the
algebra of deductions involves the question of identity criteria for deductions, the
central question of general proof theory. (This question may be found, at least
implicitly, in Hilbert’s 24th problem; see [Došen, 2015].)
In categorial proof theory one usually studies a freely generated category of a
certain kind equationally presented. This freely generated category is constructed
out of syntactical material, as in universal algebra one constructs a freely gen-
erated algebra of a certain kind equationally presented by factoring through an
equivalence relation on terms. In categories we have partial algebras—the arrow
terms out of which the equivalence classes are built have types, their sources
and targets—but there is no signiﬁcant mathematical diﬀerence in the construc-
tion when compared with what one has in universal algebra (see [Došen and
Petrić, 2004], Chapter 2, in particular in Section 2.3). The objects of this freely
constructed categories are propositions, i.e. formulae, and the arrows, i.e. the
equivalence classes of arrow terms, are deductions, i.e. equivalence classes of
particular derivations, whose sources are premises and whose targets are conclu-
sions. For deductions we have the partial operation of composition and identity
deductions (this is essential for them; see [Došen, 2016]). The categories in ques-
tion are interesting if they are not preorders, i.e., not all arrows with the same
source and the same target are equal. Otherwise, the proof theory is trivial: any
deductions with the same premises and the same conclusions become equal.
In terms of categorial proof theory, assuming that premises are collected into
sets leads to assuming that for every proposition A we have that A and A ∧A are
isomorphic, where ∧is the conjunction connective. Isomorphism is understood
here as in category theory: there are arrows, i.e. deductions, from A to A ∧A and
back, which composed give identity arrows, i.e. identity deductions (see [Došen
and Petrić, 2012] and references therein). We are led to assume moreover that the
associativity and commutativity of conjunction give isomorphisms.
It is not diﬃcult to establish that a category K with binary product × is a pre-
order (i.e., any two arrows with the same source and the same target are equal) iﬀ
for every object B of K the diagonal arrow from B to B × B is an isomorphism. It is
also not diﬃcult to establish the related fact that K is a preorder iﬀfor every object
B of K the ﬁrst-projection arrow from B × B to B is equal to the second-projection
arrow with the same source and the same target. We will put these facts within
a more general categorial context involving adjunction, which should shed light
upon them. This is the main goal of this paper, and achieving this goal, together
with some related matters (like those in the last section), is the novelty it should
bring.

On Sets of Premises
|
153
In categorial proof theory the binary connective of conjunction, both classi-
cal and intuitionistic, is identiﬁed with binary product. So what we mentioned
above indicates that assuming that premises are collected into sets leads to pre-
ordered categories where objects are propositions, i.e., formulae, and arrows are
deductions. This makes the proof theory trivial.
Assuming that premises are collected into multisets leads to assuming that
for every proposition A the permutation deduction from A∧A to A∧A, which per-
mutes the two occurrences of A in A ∧A, is equal to the identity deduction from
A ∧A to A ∧A. Although that assumption leads to the same absolute trivialization
of the proof theory of classical and intuitionistic logic, the trivialization obtained
with it for linear logic is less absolute. The same less absolute trivialization is ob-
tained for the proof theory of relevant logic by assuming moreover that A and A∧A
are isomorphic. (What is this less absolute trivialization will be explained in the
last section, at the end of the paper.)
2 Sequents
Gentzen’s sequents are expressions of the form A1, . . . , An ⊢B1, . . . , Bm where
A1, . . . , An, B1, . . . , Bm are formulae of an object language, like a language of
propositional logic or a ﬁrst-order language. Instead of the turnstile ⊢Gentzen
writes →(which is more commonly used nowadays for the binary connective of
implication; we use it below, as usual, for separating the sources and targets of
arrows in categories), for A and B he uses Gothic letters, and for n and m Greek
letters (see [Gentzen, 1935], Section I.2.3). The natural numbers n and m may also
be zero; when n is zero A1, . . . , An is the empty word, and analogously for m and
B1, . . . , Bm. For what we have to say in this paper we could restrict ourselves to
sequents where m is one.
The comma in sequents is an auxiliary symbol that serves to separate for-
mulae in sequences, which however is not essential. A sequent could as well be
A1 . . . An ⊢B1 . . . Bm, but it could be diﬃcult, though not impossible, to see
where Ai ends and Ai+1 begins in the sequence AiAi+1. Instead of p, p, p ∧q ⊢r, r
we would have the less perspicuous ppp ∧q ⊢rr, which however is not ambigu-
ous. (It becomes more perspicuous when we do not omit the outermost parenthe-
ses of formulae, as in pp(p ∧q) ⊢rr.)
So Gentzen’s sequents may be conceived as expressions of the form Γ ⊢∆
where Γ and ∆are ﬁnite, possibly empty, sequences of formulae. (Capital Greek
letters as schemata in sequents originate from Gentzen; see op. cit.) To econo-
mize upon considerations involving structural rules, a number of authors seem to

154
|
K. Došen
think they are improving upon Gentzen if they take in Γ ⊢∆that Γ and ∆are not
sequences of formulae, but other sorts of ﬁnite collections of formulae, multisets
(i.e. sets of occurrences) of formulae or sets of formulae. One should note imme-
diately that with that Γ ⊢∆seizes to be a word of a formal language, as usually
conceived. If Γ and ∆are multisets or sets, then Γ ⊢∆is not a sequence of sym-
bols. It could be conceived as a triple (Γ, ⊢, ∆), in which case ⊢is not essential. A
sequent could be identiﬁed with the ordered pair (Γ, ∆).
Such a move is not without its dangers. We are not usually interested in par-
ticular sequents, but in sequent schemata. In other words, we want our sequents
to be closed under substitution. If we continue using the notation A1, . . . , An ⊢
B1, . . . , Bm as it is usually done, and if A1, . . . , An and B1, . . . , Bm are conceived
as sets of formulae, then by substituting p for q from the sequent p, q ⊢p we ob-
tain as a substitution instance p ⊢p, and the application of the structural rule of
thinning on the left is transformed into the ﬁgure on the right:
p ⊢p
p, q ⊢p
p ⊢p
p ⊢p
which does not look like an application of thinning.
This may be embarrassing, but need not be calamitous. It becomes really dan-
gerous when we are interested not only in provability, but in proofs, i.e. not only
in deducibility, but in deductions, and try to characterize identity of deductions.
If we do that in category theory, i.e. in categorial proof theory, making the move
that corresponds to switching from sequences to multisets or sets is dangerous,
and may result in collapse. It may trivialize matters: any two deductions with the
same premises and the same conclusions will be equal. The corresponding cate-
gories will be preorders.
3 Sequents in categorial proof theory
In categorial proof theory sequents of the simple kind A ⊢B, where A and B are
single formulae, give the types of arrows f : A →B, with A being the source and
B the target. In the presence of conjunction ∧, which serves to replace the comma
on the left-hand side of Gentzen’s sequents, and the constant ⊤which replaces
the empty sequence, together with disjunction ∨and the constant ⊥for the right-
hand side, we can mimic Gentzen’s sequents, as Gentzen himself envisaged in
[Gentzen, 1935] (Section I.2.4).
Conjunction, classical or intuitionistic (they are the same), corresponds in
this perspective to binary product, and ⊤corresponds to a terminal object (which

On Sets of Premises
|
155
may be conceived as nullary product). The associativity natural isomorphism for
binary product justiﬁes Gentzen’s switch to sequences. The matter with the com-
mutativity, i.e. symmetry, natural isomorphism for binary product is more tricky.
(We deal with it in the last section.) We may identify A ∧B and B ∧A, but we
should nevertheless distinguish the identity deduction for A ∧A to A ∧A from the
deduction that permutes the two occurrences of A.
To the principle of contraction there does not however correspond an isomor-
phism: A and A∧A are not isomorphic, as the sets A and A×A are not isomorphic
if A is ﬁnite with more than one member. To assume that contraction is tied to an
isomorphism leads to triviality. Matters are analogous with binary coproduct and
an initial object, which correspond respectively ∨and ⊥, but we will concentrate
on conjunction and product in this paper.
By conjunction we understand here a binary connective to which a meet op-
eration of a semilattice corresponds algebraically. In the terminology of substruc-
tural logics, this is an additive conjunction, for which we have the two natural-
deduction rules of conjunction elimination, the ﬁrst-projection and second-
projection rules that correspond to Gentzen’s structural rule of thinning. (We
will consider on another occasion what happens if we assume that contraction is
an isomorphism for a multiplicative conjunction that does not involve thinning,
like a conjunction we ﬁnd in relevant logic.)
4 Adjunction with a full and faithful functor
We will appeal to a result concerning adjoint functors dual to Theorem 1 of Section
IV.3 of [Mac Lane, 1971]. (The proof of this result below will be more direct and
simpler than the proof in loc. cit.; it will not appeal to the Yoneda lemma.)
Let F be a functor from a category K to a category A, and G a functor from A to
K, such that G is right-adjoint to F, with members of the counit of the adjunction
being φA : FGA →A, for A an object of the category A, and members of the
unit of the adjunction being 훾B : B →GFB, for B an object of the category K (we
follow the notational conventions of [Došen, 1999], Chapter 4, save that we write
K instead of B, to distinguish this category clearly from its object B). Then we have
the following.
Proposition 4.1. The functor F is faithful iﬀfor every object B of K the arrow 훾B is
monic.
Proof: From left to right we have:

156
|
K. Došen
훾B ∘g1 = 훾B ∘g2 ⇒F훾B ∘Fg1 = F훾B ∘Fg2, since F is a functor
⇒φFB ∘F훾B ∘Fg1 = φFB ∘F훾B ∘Fg2
⇒Fg1 = Fg2, by a triangular equation of adjunction
⇒g1 = g2, since F is faithful.
From right to left we have:
Fg1 = Fg2 ⇒GFg1 ∘훾C = GFg2 ∘훾C
⇒훾B ∘g1 = 훾B ∘g2, by the naturality of 훾
⇒g1 = g2, since 훾B is monic.
For 1B : B →B being an identity arrow we have the following.
Proposition 4.2. The functor F is full iﬀfor every object B of K there is an arrow
hB : GFB →B of K such that 훾B ∘hB = 1GFB.
Proof: From left to right, the fullness of F implies that for every object B of K there
is an arrow hB : GFB →B such that FhB = φFB. We have:
훾B ∘hB = GFhB ∘훾GFB, by the naturality of 훾
= GφFB ∘훾GFB, since FhB = φFB
= 1GFB, by a triangular equation of adjunction.
From right to left, take f : FB1 →FB2 and j = hB2 ∘Gf ∘훾B1 : B1 →B2. We have:
Fj = FhB2 ∘FGf ∘F훾B1, since F is a functor
= φFB2 ∘F훾B2 ∘FhB2 ∘FGf ∘F훾B1, by a triangular equation of adjunction
= φFB2 ∘FGf ∘F훾B1, since 훾B2 ∘hB2 = 1GFB2 and F is a functor
= f ∘φFB1 ∘F훾B1, by the naturality of φ
= f, by a triangular equation of adjunction.
Corollary 4.3. The functor F is full and faithful iﬀfor every object B of K the arrow
훾B is an isomorphism.
Proof: From left to right, we have hB by the fullness of F and Proposition 4.2. Then
we have:
F(hB ∘훾B) = FhB ∘F훾B, since F is a functor
= φFB ∘F훾B, since FhB = φFB
= F1B,

On Sets of Premises
|
157
by a triangular equation of adjunction and the functoriality of F. By the faithful-
ness of F we obtain that hB ∘훾B = 1B.
From right to left, we use Propositions 4.1 and 4.2 from right to left.
As another corollary we have that if F is full and faithful, then the adjunction is
trivial, in the sense that every two canonical arrows ofadjunctionofthesametype,
i.e. with the same source and the same target, are equal (for trivial adjunctions see
[Došen, 1999], Sections 4.6.2 and 4.11).
5 Adjunction with the diagonal functor
Consider now the diagonal functor D from a category K to the product category
K × K. This functor is always faithful. We have on the other hand the following.
Proposition 5.1. The functor D is full iﬀK is a preorder.
Proof: From left to right, take the arrows g, g耠: B1 →B2 of K. By the fullness of
D, for the arrow (g, g耠) : (B1, B1) →(B2, B2) of K × K we have an arrow h of K
such that (g, g耠) = Dh = (h, h). Hence g = g耠.
From right to left, we have for every arrow (g, g耠) : (B1, B1) →(B2, B2) of
K × K that g = g耠. Hence (g, g耠) = (g, g) = Dg.
The category K has a product biendofunctor × iﬀthis functor is right adjoint to
the diagonal functor D. The members 훾B : B →B × B of the unit of this adjunc-
tion, which can be called diagonal arrows, correspond to the contraction arrows
of conjunction wB : B ⊢B∧B. If these arrows are isomorphisms, then, by Proposi-
tion 4.2 (and Corollary 4.3 from right to left), the diagonal functor D is full, and, by
Proposition 5.1 from left to right, K is a preorder. In proof-theoretical terms, any
two deductions with the same premises and the same conclusions are equal. So if
we want our proof theory to be nontrivial, we should not permit the contraction
arrows wB to be isomorphisms.
Conversely, if K is a preorder, by Proposition 5.1 from right to left, the diagonal
functor is full, and, by Corollary 4.3 from left to right, the arrows 훾B : B →B×B are
isomorphisms. So we have established the following for categories K with binary
product ×.
Proposition 5.2. The category K is a preorder iﬀfor every object B of K the diago-
nal arrow 훾B : B →B × B is an isomorphism.

158
|
K. Došen
Note that it is possible in a category K with binary product × to have for every
object B that B and B × B are isomorphic without the diagonal map being an iso-
morphism. We will consider that matter in the next section.
We have established Proposition 5.2 without mentioning explicitly the projec-
tion arrows, but they are in the background. It is easy to see that K is a preorder
iﬀfor every object B of K we have that the ﬁrst-projection arrow k1
B,B : B × B →B
is equal to the second-projection arrow k2
B,B : B × B →B. From left to right this is
trivial, while for the other direction we have that if k1
B,B = k2
B,B, then for any two
arrows g, g耠: C →B of K we have for ⟨g, g耠⟩: C →B × B that k1
B,B
∘⟨g, g耠⟩=
k2
B,B
∘⟨g, g耠⟩, and hence g = g耠.
If the diagonal functor D is full, then for the members
(k1
B,B, k2
B,B): (B × B, B × B) →(B, B)
of the counit of the adjunction of D with the biendofunctor × we have that k1
B,B =
k2
B,B. So if the projection arrows k1
B,B and k2
B,B are not equal, then D is not full, and,
by Proposition 5.1, the category K is not a preorder.That K is nota preorderfollows
of course immediately from the inequality of k1
B,B and k2
B,B, but it is worth seeing
how Proposition 5.1 and with it the wider perspective of the preceding section are
involved.
This shows how the non-triviality of K hinges on distinguishing the two pro-
jection arrows from B×B to B, i.e. the two deductions from B∧B to B based on the
two natural-deduction rules of conjunction elimination (see the end of Section 3).
In a category with binary product we derive k1
B,B = k2
B,B from the assumption
that the diagonal arrow wB : B →B × B, called 훾B above, is an isomorphism in the
following manner. We have in any such category that k1
B,B
∘wB = k2
B,B
∘wB = 1B,
and then, by the isomorphism of wB, we obtain k1
B,B = k2
B,B.
When k1
B,B = k2
B,B, then k1
B,B, i.e. k2
B,B, is the arrow inverse to wB : B →B × B,
which makes of the diagonal arrow wB an isomorphism. We have k1
B,B
∘wB = 1B
anyway. We also have:
wB ∘k1
B,B
=
⟨k1
B,B, k1
B,B⟩, by the naturality of wB
=
⟨k1
B,B, k2
B,B⟩, since k1
B,B = k2
B,B
=
1B×B.
The reduction to triviality brought by assuming that the diagonal arrows wB are
isomorphisms could have been shown by appealing only to these comments about
k1
B,B = k2
B,B. We preferred however to put the matter in a wider perspective given
by the preceding section. This shows that the matters we deal with are not peculiar
to the adjunction with the diagonal functor.
The triviality of the adjunctions involving the quantiﬁers that are considered
in [Došen and Petrić, 2009] (Section 1.4) has the same roots involving sets. The

On Sets of Premises
|
159
universally quantiﬁed formula ∀xA interpreted over a domain with two objects
a and b stands either for the conjunction Ax
a ∧Ax
b or the conjunction Ax
b ∧Ax
a.
Moreover, Ax
a∧Ax
a and Ax
a are not distinguished. Quantiﬁers involve sets of objects,
and neither multisets nor sequences. So from the point of view of general proof
theory the assertion that quantiﬁers are like conjunctions and disjunctions should
be taken with a grain of salt.
6 Collapse with sets and multisets of premises
We have noted after Proposition 5.2 that it is possible in a category with binary
product × to have for every object B that B and B × B are isomorphic without the
diagonal arrow wB : B →B × B being an isomorphism. The isomorphism may be
produced by something else. To see that, take the category C with binary product
freely generated out of a nonempty set P of generating objects, which are usu-
ally taken to be syntactical objects, letters, like propositional variables. (The con-
struction of such equationally presented syntactical freely generated categories is
described in detail in [Došen and Petrić, 2004], Chapter 2, in particular in Section
2.3.) Out of C we can build another category with binary product, which we call C耠,
by replacing the objects of C, which are like propositional conjunctive formulae,
by sets of letters, free generators, occurring in these formulae. If P is the singleton
{p}, then we have in C耠a single object {p} (i.e. P itself). The category C耠is not a pre-
order if we keep in it the structure of arrows of C. (That this is possible is shown
by the one-object category that is a skeleton of the category of denumerably in-
ﬁnite sets with functions as arrows.¹) So the diagonal arrow w{p} : {p} →{p},
though its source and target are both {p}, need not be equal to the identity ar-
row 1{p} : {p} →{p}. Analogously, the projection arrows k1
{p},{p} : {p} →{p} and
k2
{p},{p} : {p} →{p} need not be equal to 1{p}, and they need not be mutually equal.
Once we have passed to C耠and understand this category proof-theoretically,
the temptation is however big to take the diagonal arrow w{p}, which corresponds
to contraction, to be the identity arrow 1{p}. In proof theory the switch to sets of
premises is usually made in order not to be obliged to keep an account of structural
rules. If we have to continue keeping this account, what is the advantage of the
switch? We are moreover required to keep an account of contraction when it is
invisible, when it consists in passing from {p} to {p}.
When w{p} is identiﬁed with 1{p} we have collapse, as we have seen in this
paper (and in particular in Proposition 5.2). Collapse also ensues when k1
{p},{p} =
1 I am grateful to Zoran Petrić for suggesting this example.

160
|
K. Došen
k2
{p},{p} = 1{p} : {p} →{p}, which seems tempting and natural to assume when the
structural rule of thinning is invisible, when it adds a premise we already have,
and premises are collected into sets (see the trivial thinning ﬁgure mentioned in
Section 2).
Suppose now C is a freely generated category with a symmetric monoidal mul-
tiplication biendofunctor ⊗(see [Mac Lane, 1971], Section VII.7; these categories
are called symmetric associative in [Došen and Petrić, 2004], Chapter 5), which
corresponds to the multiplicative conjunction of linear logic, and is tied to col-
lecting premises into multisets. In C we have a symmetry natural isomorphism
cB1,B2 : B1 ⊗B2 →B2 ⊗B1. Now C耠is obtained from C by replacing the objects of
C, i.e. propositional formulae, by sets of occurrences of letters in these formulae,
i.e. multisets of letters occurring in these formulae. As before, C耠is not a preorder if
we keep in it the structure of arrows of C, and in particular continue distinguish-
ing the symmetry isomorphisms cp,p : p ⊗p →p ⊗p from the identity arrows
1p⊗p : p ⊗p →p ⊗p. The corresponding arrows in C耠go from the multiset {p, p}
to the multiset {p, p}.
The assumption cB,B = 1B⊗B is however dangerous. If ⊗happens to be bi-
nary product ×, this assumption leads to collapse, as did the isomorphism of the
diagonal arrows and the equality of the projection arrows. This is because we
have k1
B,B
∘cB,B = k2
B,B in categories with binary product, where cB,B is deﬁned
as ⟨k2
B,B, k1
B,B⟩. So collecting premises into multisets in classical and intuitionis-
tic logic is as dangerous as collecting them into sets.
The situation is somewhat diﬀerent in linear logic. We have the assumption
cB,B = 1B⊗B in a category called S耠in [Došen and Petrić, 2004] (Section 6.5; this
category is obtained out of the symmetric associative category freely generated
by a nonempty set of generating objects), which is a preorder, and this shows that
the assumption cB,B = 1B⊗B makes that all the canonical arrows tied to multiplica-
tive conjunction in linear logic that have the same source and the same target are
equal. This does not mean however that the assumption will lead in general to
preorder.
If among the free generators we do not have only objects, but also diﬀerent
arrows with the same source and the same target, they will not become equal be-
cause of cB,B = 1B⊗B. This is shown by an inductive argument establishing that
for every equation derivable for such a freely generated category, for every gen-
erating arrow f, we cannot have f on one side of the equation without having it
on the other.² The same holds for relevant logic and categories related to it (see
[Petrić, 2002] and [Došen and Petrić, 2007b]).
2 I am grateful to Zoran Petrić for suggesting this simple argument.

On Sets of Premises
|
161
In these categories we have, as members of a natural transformation corre-
sponding to contraction, diagonal arrows from B to B ⊗B, with ⊗corresponding
to multiplicative conjunction as above. In addition to cB,B = 1B⊗B, we are led to
assume that these diagonal arrows are isomorphisms if we assume that premises
are collected into sets, and we will show in another place how this makes equal all
the canonical arrows tied to multiplicative conjunction that have the same source
and the same target. This assumption of isomorphism will however not lead in
general to preorder, for reasons analogous to those in the preceding paragraph.
So, in linear and relevant logic, with premises collected into multisets or sets the
danger is still there, but not as big as in classical and intuitionistic logic.
Acknowledgment: Work on this paper was supported by the Ministry of Educa-
tion, Science and Technological Development of Serbia, while the Alexander von
Humboldt Foundation has, within the frame of Humboldt-Kollegs, supported the
presentation of a talk partly related to the paper at the conference Proof in Bern
in September 2013. I am grateful to the organizers of that conference for their hos-
pitality, and to Miloš Adžić and Zoran Petrić for discussing the ideas of the paper,
reading a draft of it and making useful comments.
References
K. Došen. Cut Elimination in Categories. Kluwer, Dordrecht, 1999.
K. Došen. Algebras of deductions in category theory. In D. Jokanović et al., editor, Third
Mathematical Conference of the Republic of Srpska, Proceedings, Trebinje 2013, Zbornik
radova, volume I, pages 11–18, Trebinje, 2014. Univerzitet u Istočnom Sarajevu, Fakultet
za proizvodnju i menadžment. (available at: http://www.mi.sanu.ac.rs/~kosta/Dosen%
20Algebras%20of%20Deductions.pdf).
K. Došen. General proof theory. In P. Schroeder-Heister et al., editor, Logic, Methodology
and Philosophy of Science – Proceedings of the 14th International Congress (Nancy 2011):
Logic and Science Facing the New Technologies, pages 149–151, London, 2015. College
Publications. (preprint available at: http://www.mi.sanu.ac.rs/~kosta/Dosen_General%
20Proof%20Theory%20nov2011.pdf).
K. Došen.
On the paths of categories: An introduction to deduction.
In T. Piecha and
P. Schroeder-Heister et al., editors, Advances in Proof-Theoretic Semantics, pages 65–77,
Cham, 2016. Springer. (preprint available at: http://www.mi.sanu.ac.rs/~kosta/Dosen%
20On%20the%20Paths.pdf).
K. Došen and Z. Petrić. Proof-Theoretical Coherence. KCL Publications (College Publications),
London, 2004. (revised version of 2007 available at: http://www.mi.sanu.ac.rs/~kosta/
publications.htm).

162
|
K. Došen
K. Došen and Z. Petrić. Proof-Net Categories. Polimetrica, Monza, 2007a. (preprint of 2005,
inessentially diﬀerent from the printed text, available at: http://www.mi.sanu.ac.rs/
~kosta/publications.htm).
K. Došen and Z. Petrić. Relevant categories and partial functions. Publications de l’Institut
Mathématique, N.S., 82 (96):17–23, 2007b. (available at: http://arXiv.org).
K. Došen and Z. Petrić. Coherence in linear predicate logic. Annals of Pure and Applied Logic,
158:125–153, 2009. (available at: http://arXiv.org).
K. Došen and Z. Petrić. Isomorphic formulae in classical propositional logic. Mathematical
Logic Quarterly, 58:5–17, 2012. (available at: http://arXiv.org).
G. Gentzen. Untersuchungen über das logische Schließen. Mathematische Zeitschrift, 39:
176–210, 405–431, 1935. (English translation: Investigations into logical deduction, in The
Collected Papers of Gerhard Gentzen, M.E. Szabo, editor, pages 68-131, 312-317, Amster-
dam, 1969. North-Holland).
S. Mac Lane. Categories for the Working Mathematician. Springer, Berlin, 1971. Second
edition, 1998.
Z. Petrić. Coherence in substructural categories. Studia Logica, 70:271–296, 2002. Available
at: http://arXiv.org.

Hajime Ishihara and Takako Nemoto
Non-Deterministic Inductive Deﬁnitions
and Fullness
Abstract: In this paper, we deal with the non-deterministic inductive deﬁnition
principle NID with the weak notion of a set-generated class introduced by van den
Berg and with the strong notion of a set-generated class adopted by Aczel et al. We
introduce a principle, called nullary NID, and prove that nullary NID is equivalent
to Fullness in a subsystem of the constructive Zermelo-Fraenkel set theory.
Keywords: Constructive set theory, Non-deterministic inductive deﬁnition, Full-
ness
Mathematics Subject Classiﬁcation 2010: 03E70, 03F65
1 Introduction
The notion of a set-generated class was introduced in [Aczel, 2006] for dcpos using
some terminology from domain theory. A partially ordered class is a directed com-
plete partial order (dcpo) if each directed subset has a least upper bound, where
a subset is directed if any pair of elements of the subset has an upper bound in
the subset. A dcpo X is set-generated if there is a subset G of X such that, for each
a ∈X, {x ∈G | x ≤a} is a directed subset whose least upper bound is a. If we
restrict our attention to a class X of subsets of a set with the inclusion ⊆as a partial
order, then we may say that X is set-generated if there exists a subset G of X such
that
∀α ∈X∀τ ∈Fin(α)∃β ∈G[τ ⊆β ⊆α],
where Fin(α) is the set of ﬁnitely enumerable subsets of α.
This deﬁnition was adopted in [Aczel et al., 2015], and it was shown that the
notion of a set-generated class plays crucial roles in predicative constructive math-
ematics. However, in an early draft of [Aczel et al., 2015] and in [van den Berg,
2013], a weaker notion of a set-generated class was employed: a class X of subsets
of a set is set-generated if there exists a subset G of X such that
∀α ∈X∀x ∈α∃β ∈G[x ∈β ⊆α].
Hajime Ishihara and Takako Nemoto: School of Information Science, Japan Advanced Institute
of Science and Technology, Nomi, Ishikawa 923-1292, Japan, e-mail: ishihara@jaist.ac.jp,
t-nemoto@jaist.ac.jp

164
|
H. Ishihara and T. Nemoto
Note that the strong notion of a set-generated class is crucial in some applications,
for example, [Ishihara and Kawai, 2015].
In [van den Berg, 2013], the principle NID on non-deterministic inductive def-
initions and set-generated classes were introduced, using the weaker notion of
a set-generated class in the constructive set theory CZF. A rule on a set S is a pair
(a, b) of subsets a and b of S, and a rule is called elementary if a is a singleton and
ﬁnitary if a is ﬁnitely enumerable. A subset α of S is closed under the rule (a, b) if
a ⊆α ⇒b ≬α,
where b ≬α ⇔∃x ∈b(x ∈α), that is, the intersection of b and α is inhabited.
For a set R of rules on S, we call a subset α of S R-closed if it is closed under each
rule in R. The NID principle is that for each set S and set R of rules on S, the class
of R-closed subsets of S is set-generated. If we restrict rules in NID to elementary
and ﬁnitary rules, we call them elementary NID and ﬁnitary NID, respectively.
On the other hand, [Aczel et al., 2015] characterized set-generated classes with
the strong notion using generalized geometric theories and the set generation ax-
iom (SGA) in CZF. In [van den Berg, 2013], it was discussed on a relation between
ﬁnitary NID and SGA, and revealed some aspect between the weak notion and the
strong notion of a set-generated class. He also showed that elementary NID im-
plies Fullness, a theorem in CZF, which is an important axiom in a subsystem of
CZF that implies Exponentiation (the class of functions between sets is a set).
In this paper, we introduce another NID principle, called nullary NID, which
is weaker than ﬁnitary NID, and prove that nullary NID is equivalent to Fullness
in a subsystem of CZF, that is, the elementary constructive set theory ECST. We
also show that elementary NID implies nullary NID, and that nullary, elementary
and ﬁnitary NID with the weak notion of a set-generated class are equivalent to
respectively nullary, elementary and ﬁnitary NID with the strong notion.
2 The elementary constructive set theory
The constructive Zermelo-Fraenkel set theory CZF, founded by [Aczel, 1978, 1982,
1986], grew out of Myhill’s constructive set theory [Myhill, 1975] as a formal system
for Bishop’s constructive mathematics, and permits a quite natural interpretation
in Martin-Löf type theory [Martin-Löf, 1984]. Aczel and Rathjen introduced the
elementary constructive set theory ECST which is a subsystem of CZF in their book
draft [Aczel and Rathjen, 2010] written by extending their research report [Aczel
and Rathjen, 2001].

Non-Deterministic Inductive Deﬁnitions and Fullness
|
165
Deﬁnition 1. The language of a constructive set theory contains variables for sets
and the binary predicates = and ∈. The axioms and rules are those of intuitionis-
tic predicate logic with equality. In addition, ECST has the following set theoretic
axioms:
–
Extensionality:
∀a∀b(∀x(x ∈a ↔x ∈b) →a = b).
–
Pairing:
∀a∀b∃c∀x(x ∈c ↔x = a ∨x = b).
–
Union:
∀a∃b∀x(x ∈b ↔∃y ∈a(x ∈y)).
–
Restricted Separation:
∀a∃b∀x(x ∈b ↔x ∈a ∧φ(x))
for every restricted formula φ(x). Here a formula φ(x) is restricted, or ∆0, if all
the quantiﬁers occurring in it are bounded, i.e. of the form ∀x ∈c or ∃x ∈c.
–
Replacement:
∀a(∀x ∈a∃!yφ(x, y) →∃b∀y(y ∈b ↔∃x ∈aφ(x, y)))
for every formula φ(x, y).
–
Strong Inﬁnity:
∃a[0 ∈a ∧∀x(x ∈a →x + 1 ∈a)
∧∀y(0 ∈y ∧∀x(x ∈y →x + 1 ∈y) →a ⊆y)],
where x + 1 is x ∪{x}, and 0 is the empty set 0.
Let a and b be sets. Using Replacement and Union, the cartesian product a × b
of a and b consisting of the ordered pairs (x, y) = {{x}, {x, y}} with x ∈a and
y ∈b can be introduced in ECST. Similarly, we can introduce the disjoint union
a + b = {(0, x) | x ∈a} ∪{(1, y) | y ∈b}, where 1 = {0}. A relation r between a and
b is a subset of a × b. A relation r ⊆a × b is total (or is a multivalued function) if
for every x ∈a there exists y ∈b such that (x, y) ∈r. The class of total relations
between a and b is denoted by mv(a, b), or more formally
r ∈mv(a, b) ⇔r ⊆a × b ∧∀x ∈a∃y ∈b((x, y) ∈r).
A function from a to b is a total relation f ⊆a × b such that for every x ∈a there is
exactly one y ∈b with (x, y) ∈f. The class of functions from a to b is denoted by
ba, or more formally
f ∈ba ⇔f ∈mv(a, b) ∧∀x ∈a∀y, z ∈b((x, y) ∈f ∧(x, z) ∈f →y = z).
We use ω for the unique set a such that 0 ∈a ∧∀x(x ∈a →x + 1 ∈a), ensured
by Strong Inﬁnity. For a set S, let Fin(S) denote the class {ran(f) | f ∈Sn, n ∈ω}

166
|
H. Ishihara and T. Nemoto
of ﬁnitely enumerable subsets of S, and let Fin+(S) denote the class {σ ∈Fin(S) |
∃x ∈S(x ∈σ)} of ﬁnitely enumerable inhabited subsets of S.
The constructive set theory CZF is obtained from ECST by replacing Replace-
ment by
Strong Collection:
∀a(∀x ∈a∃yφ(x, y) →∃b(∀x ∈a∃y ∈bφ(x, y) ∧∀y ∈b∃x ∈aφ(x, y)))
for every formula φ(x, y),
and adding
–
Subset Collection:
∀a∀b∃c∀u(∀x ∈a∃y ∈bφ(x, y, u) →
∃d ∈c(∀x ∈a∃y ∈dφ(x, y, u) ∧∀y ∈d∃x ∈aφ(x, y, u)))
for every formula φ(x, y, u), and
–
∈-Induction: ∀a(∀x ∈aφ(x) →φ(a)) →∀aφ(a), for every formula φ(a).
In ECST, Subset Collection implies
Fullness:
∀a∀b∃c(c ⊆mv(a, b) ∧∀r ∈mv(a, b)∃s ∈c(s ⊆r)),
and Fullness and Strong Collection imply Subset Collection. The notable conse-
quence of Fullness is that ba forms a set, that is
Exponentiation:
∀a∀b∃c∀f(f ∈c ↔f ∈ba).
Note that, in the presence of Exponentiation (and hence Fullness), the classes
Fin(S) and Fin+(S) are sets for each set S, by Replacement, Union and Restricted
Separation.
For a set S, we write Pow(S) for the power class of S which is not a set in ECST
nor in CZF:
a ∈Pow(S) ⇔a ⊆S.
3 Non-deterministic inductive deﬁnitions and
Fullness
In this section, we work within the subsystem ECST of CZF.
Deﬁnition 2. Let S be a set. Then a rule on S is a pair (a, b) of subsets a and b of
S. A rule is called nullary if a is empty, elementary if a is a singleton and ﬁnitary if

Non-Deterministic Inductive Deﬁnitions and Fullness
|
167
a is ﬁnitely enumerable. A subset α of S is closed under the rule (a, b) if
a ⊆α ⇒b ≬α.
For a set R of rules on S, we call a subset α of S R-closed if it is closed under each
rule in R.
Remark 3. Note that if a rule is nullary or elementary, then it is ﬁnitary.
Deﬁnition 4. Let S be a set and let X be a subclass of Pow(S). Then X is set-
generated if there exists a subset G of X such that
∀α ∈X∀x ∈α∃β ∈G(x ∈β ⊆α),
and strongly set-generated if there exists a subset G of X such that
∀α ∈X∀σ ∈Fin(α)∃β ∈G(σ ⊆β ⊆α).
Deﬁnition 5. Let NID and NID∗denote the principles that for each set S and set R
of rules on S, the class of R-closed subsets of S is set-generated and strongly set-
generated, respectively. The principles obtained by restricting R in NID(∗) to a set of
nullary, elementary and ﬁnitary rules are called nullary NID(∗), elementary NID(∗)
and ﬁnitary NID(∗), respectively.
Remark 6. Trivially, NID∗implies NID, and note that ﬁnitary NID(∗) implies nullary
NID(∗) and elementary NID(∗).
For a set S, let ∗S denote the set {x ∈S | x
̸∈x} which is not in S.
Theorem 7. Nullary NID is equivalent to Fullness.
Proof: Suppose nullary NID. Let A and B be sets, and deﬁne a set R of nullary
rules on (A × B) ∪{∗A×B} by
R = {(0, {x} × B) | x ∈A} ∪{(0, {∗A×B})}.
Then, by nullary NID, there exists a subset G of the class X of R-closed subsets of
(A × B) ∪{∗A×B} such that
∀α ∈X∀z ∈α∃β ∈G(z ∈β ⊆α).
Let C = {β ∩(A × B) | β ∈G}. Then for each β ∈G and x ∈A, since β ≬{x} × B,
there exists y ∈B such that (x, y) ∈β, and hence (x, y) ∈β ∩(A × B). Therefore
C ⊆mv(A, B). For each r ∈mv(A, B), since {x} × B ≬r ∪{∗A×B} for each x ∈A and
∗A×B ∈r ∪{∗A×B}, we have r ∪{∗A×B} ∈X, and hence there exists β ∈G such that
∗A×B ∈β ⊆r ∪{∗A×B}. Thus β ∩(A × B) ⊆(r ∪{∗A×B}) ∩(A × B) = r.

168
|
H. Ishihara and T. Nemoto
Conversely, suppose Fullness. Let R be a set of nullary rules on a set S. Then,
by Fullness, there exists a set C ⊆mv(R, S) such that
∀r ∈mv(R, S)∃s ∈C(s ⊆r).
Let
G = {{x} ∪ran(r) | x ∈S, r ∈C, ∀((0, b), y) ∈r(y ∈b)}.
If r ∈C and ∀((0, b), y) ∈r(y ∈b), then for each (0, b) ∈R, we have b ≬ran(r),
and hence b ≬{x} ∪ran(r) for each x ∈S. Therefore G is a subset of the class
of R-closed subsets of S. For each R-closed subset α of S, since r = {((0, b), y) |
(0, b) ∈R, y ∈b ∩α} ∈mv(R, S), there exists s ∈C such that s ⊆r. Note that,
since ∀((0, b), y) ∈r(y ∈b) and ran(r) ⊆α, we have ∀((0, b), y) ∈s(y ∈b) and
ran(s) ⊆α. Therefore if x ∈α, then {x}∪ran(s) ∈G and x ∈{x}∪ran(s) ⊆{x}∪α =
α.
Proposition 8. Elementary NID implies nullary NID.
Proof: Let R be a set of nullary rules on a set S, and deﬁne a set R耠of elementary
rules on S ∪{∗S} by
R耠= {({∗S}, b) | (0, b) ∈R} ∪{({x}, {∗S})}) | x ∈S}.
Then, by elementary NID, there exists a subset G耠of the class X耠of R耠-closed sub-
sets of S ∪{∗S} such that
∀α耠∈X耠∀z ∈α耠∃β耠∈G耠(z ∈β耠⊆α耠).
Let G = {β耠∩S | β耠∈G耠, ∗S ∈β耠}. Then for each β耠∩S ∈G and (0, b) ∈R,
since ∗S ∈β耠, we have b ≬β耠, and hence b ≬β耠∩S. Therefore G is a set of R-closed
subsets of S. Let α be an R-closed subset of S. Then for each (0, b) ∈R, since b ≬α,
we have b ≬α ∪{∗S}, and ∗S ∈α ∪{∗S}. Hence α ∪{∗S} ∈X耠. Therefore for each
x ∈α, since x ∈α ∪{∗S}, there exists β耠∈G耠such that x ∈β耠⊆α ∪{∗S}, and so
∗S ∈β耠. Thus β耠∩S ∈G and x ∈β耠∩S ⊆(α ∪{∗S}) ∩S = α.
Remark 9. Note that, assuming nullary, elementary or ﬁnitary NID, we have Full-
ness, and hence the classes Fin(S) and Fin+(S) are sets for each set S.
For a subset α of the disjoint union A + B, let (α)0 and (α)1 denote the sets {x ∈A |
(0, x) ∈α} and {y ∈B | (1, y) ∈α}, respectively.
Proposition 10. Nullary, elementary and ﬁnitary NID imply nullary, elementary and
ﬁnitary NID∗, respectively.
Proof: Let R be a set of nullary rules on a set S, and deﬁne a set R耠of nullary rules
on Fin(S) by
R耠= {(0, Fin+(b)) | (0, b) ∈R}.

Non-Deterministic Inductive Deﬁnitions and Fullness
|
169
Then, by nullary NID, there exists a subset G耠of the class X耠of R耠-closed subsets
of Fin(S) such that
∀α耠∈X耠∀σ ∈α耠∃β耠∈G耠(σ ∈β耠⊆α耠).
Let G = {⋃β耠| β耠∈G耠}. Then for each β耠∈G耠and (0, b) ∈R, since Fin+(b) ≬β耠,
there exists σ ∈Fin+(b) ∩β耠, hence there exists x ∈b such that x ∈σ ∈β耠, and
therefore b ≬⋃β耠. Thus G is a set of R-closed subsets of S. Let α be an R-closed
subset of S. Then for each (0, Fin+(b)) ∈R耠, since (0, b) ∈R, we have b ≬α, and
hence Fin+(b) ≬Fin(α). Therefore Fin(α) ∈X耠. Thus for each σ ∈Fin(α) there
exists β耠∈G耠such that σ ∈β耠⊆Fin(α), and so σ ⊆⋃β耠⊆⋃Fin(α) = α.
Let R be a set of elementary or ﬁnitary rules on a set S, and deﬁne a set R耠of
elementary and ﬁnitary rules on S + Fin(S) by
R耠= {(1 × a, 1 × b) | (a, b) ∈R}
∪{(1 × a, {(1, σ) | σ ∈Fin(b)}) | (a, b) ∈R}
∪{({(1, σ)}, {(0, x)}) | σ ∈Fin(S), x ∈σ}.
Note that R耠is elementary and ﬁnitary if R is elementary and ﬁnitary, respectively.
Then, by elementary or ﬁnitary NID, there exists a subset G耠of the class X耠of R耠-
closed subsets of S + Fin(S) such that
∀α耠∈X耠∀z ∈α耠∃β耠∈G耠(z ∈β耠⊆α耠).
Let G = {(β耠)0 | β耠∈G耠}. Then for each β耠∈G耠and (a, b) ∈R with a ⊆(β耠)0,
since 1 × a ⊆β耠, we have 1 × b ≬β耠, and hence b ≬(β耠)0. Therefore G is a set of
R-closed subsets of S. Let α be an R-closed subset of S. Then α + Fin(α) is an R耠-
closed subset of S + Fin(S). In fact, for each (a, b) ∈R, if 1 × a ⊆α + Fin(α), then,
since a ⊆α, we have b ≬α, and hence 1 × b ≬α + Fin(α) and (1, σ) ∈α + Fin(α)
for some σ ∈Fin(b). For ({(1, σ)}, {(0, x)}) ∈R耠where σ ∈Fin(S) and x ∈σ,
if {(1, σ)} ⊆α + Fin(α), then, since σ ∈Fin(α), we have x ∈σ ⊆α, and hence
(0, x) ∈α +Fin(α). Therefore α +Fin(α) ∈X耠. Thus for each σ ∈Fin(α) there exists
β耠∈G耠such that (1, σ) ∈β耠⊆α + Fin(α), and since β耠is R耠-closed and (0, x) ∈β耠
for each x ∈σ, we have σ ⊆(β耠)0 ⊆(α + Fin(α))0 = α.
Corollary 11. Nullary, elementary and ﬁnitary NID are equivalent to respectively
nullary, elementary and ﬁnitary NID∗.
Acknowledgment: The authors thank the anonymous referee for helpful com-
ments and suggestions, and the Japan Society for the Promotion of Science (JSPS),
Core-to-Core Program (A. Advanced Research Networks) for supporting the re-
search.

170
|
H. Ishihara and T. Nemoto
References
Peter Aczel. The type theoretic interpretation of constructive set theory. In Logic Colloquium ’77
(Proc. Conf., Wrocław, 1977), volume 96 of Stud. Logic Foundations Math., pages 55–66.
North-Holland, Amsterdam-New York, 1978.
Peter Aczel. The type theoretic interpretation of constructive set theory: choice principles. In
The L. E. J. Brouwer Centenary Symposium (Noordwijkerhout, 1981), volume 110 of Stud.
Logic Found. Math., pages 1–40. North-Holland, Amsterdam, 1982.
Peter Aczel. The type theoretic interpretation of constructive set theory: inductive deﬁnitions.
In Logic, methodology and philosophy of science, VII (Salzburg, 1983), volume 114 of Stud.
Logic Found. Math., pages 17–49. North-Holland, Amsterdam, 1986.
Peter Aczel. Aspects of general topology in constructive set theory. Ann. Pure Appl. Logic, 137
(1-3):3–29, 2006.
Peter Aczel and Michael Rathjen. Notes on constructive set theory. Technical Report No. 40,
Institut Mittag-Leﬀler, The Royal Swedish Academy of Sciences, 2001.
Peter Aczel and Michael Rathjen. CST. Book draft, 2010. URL https://www1.maths.leeds.ac.uk/
~rathjen/book.pdf.
Peter Aczel, Hajime Ishihara, Takako Nemoto, and Yasushi Sangu. Generalized geometric
theories and set-generated classes. Math. Structures Comput. Sci., 25(7):1466–1483,
2015.
Hajime Ishihara and Tatsuji Kawai. Completeness and cocompleteness of the categories of
basic pairs and concrete spaces. Math. Structures Comput. Sci., 25(8):1626–1648, 2015.
Per Martin-Löf. Intuitionistic type theory, volume 1 of Studies in Proof Theory. Lecture Notes.
Bibliopolis, Naples, 1984. Notes by Giovanni Sambin.
John Myhill. Constructive set theory. J. Symbolic Logic, 40(3):347–382, 1975.
Benno van den Berg. Non-deterministic inductive deﬁnitions. Arch. Math. Logic, 52(1-2):113–
135, 2013.

Ioannis Kokkinis and Thomas Studer
Cyclic Proofs for Linear Temporal Logic
Abstract: Annotated sequents provide an elegant approach for the design of de-
ductive systems for temporal logics. Their proof theory, however, is notoriously
diﬃcult. It is not even clear how to syntactically show the admissibility of weak-
ening. In this paper, we establish weakening by purely proof-theoretic methods,
thus solving an open problem by Brünnler and Lange. We also investigate the role
of cut in annotated sequent systems.
Keywords: Proof theory, Temporal logic
Mathematics Subject Classiﬁcation 2010: 03B44, 03F03
1 Introduction
The proof theory of temporal logics, and of modal ﬁxed point logics in general,
is notoriously diﬃcult. It is not even clear how to design a ﬁnitary deductive sys-
tem for linear time temporal logic LTL with nice proof-theoretic properties. In this
context, deductive systems featuring inﬁnite long proof branches (together with
a global soundness condition) and their cyclic variants have recently obtained
much attention, see, for instance, [Brotherston and Simpson, 2011, Brünnler and
Lange, 2008, Bucheli et al., 2010, Niwinski and Walukiewicz, 1996, Shamkanov,
2014, Studer, 2008].
Brünnler and Lange [Brünnler and Lange, 2008] proposed an elegant formal-
ism with cyclic proofs for LTL using focus games from Lange and Stirling [Lange
and Stirling, 2001] as an inspiration. The main technical feature of their system
are annotated sequents, which are employed to derive greatest ﬁxed points. How-
ever, some very basic proof-theoretic problems turn out to be surprisingly hard in
this setting. For instance, despite the admissibility of several structural rules, in-
cluding cut, being proved semantically in [Brünnler and Lange, 2008], it remains
to prove the same facts by proper proof-theoretic methods. Even the admissibility
of weakening, which is quite trivial for most types of sequent calculi, is far from
being simple for annotated sequents due to the presence of sequent contexts in
the annotations.
Ioannis Kokkinis, Thomas Studer: Institut für Informatik, Universität Bern, Neubrückstrasse 10,
3012 Bern, Switzerland, e-mail: kokkinis@inf.unibe.ch, tstuder@inf.unibe.ch

172
|
I. Kokkinis and T. Studer
As Brünnler and Lange point out [Brünnler and Lange, 2008], the problem
with weakening is to be expected since the fact that a certain statement is provable
by induction does not imply that a weaker statement is also provable by induction.
In this paper we provide a solution to this open problem and establish the
admissibility of weakening by proof-theoretic means.
Moreover, we present a series of examples that explain the design of Brünnler
and Lange’s system. Their system is based on annotations that are sets of sets of
formulas and it uses several rules to unfold greatest ﬁxed points. Our examples
show that these features are necessary in order to have completeness, that means
their system is as simple as a cut-free system can be.
However, we also show that if we add a cut-rule, then the system can be made
much simpler. That is, we can have fewer rules and annotations of a simpler form.
This provides a very nice and instructive example on the role of cut in proofs of
induction statements.
2 Sequent Systems for LTL
In this section we see an approach for deﬁning a sound and complete sequent
calculus for LTL. Note that we only study the unary fragment of LTL. This is enough
to discuss the proof-theoretic problems but simpliﬁes the presentation.
We start with deﬁning the syntax and semantics for LTL-sequents. Then we
recall a naive way of giving an LTL-sequent calculus and explain its shortcomings.
We ﬁnish this section with introducing the sequent calculus LT1, which is based
on so-called annotations.
2.1 Syntax and Semantics
We start with a countable set of atomic propositions, which we call Prop. The lan-
guage of the sequent calculus, LS, is then described by the following grammar:
(gesetzt mit in Latex wie oben angegeben)
A ::= P | P | A ∧A | A ∨A | ◻A | ⋄A |
⃝A
where P ∈Prop and P denotes the negation of P. In this paper, we assume right
associativity for all binary connectives.
We deﬁne the set of sequents, Seq, by:
Seq := {Γ 儨儨儨儨Γ is a ﬁnite subset of LS}

Cyclic Proofs for Linear Temporal Logic
|
173
We will use capital greek letters like Γ, ∆, Σ, . . . for sequents, capital latin letters
like A, B, C, D, . . . for LS-formulas and the letters P, Q for elements of Prop, all of
them possibly primed or with subscripts. As usual union is represented by comma,
i.e.:
Γ, ∆stands for Γ ∪∆
Γ, A stands for Γ ∪{A}
We deﬁne the negation of an LS-formula as usual by:
P := P
⃝A :=
⃝A
A ∨B := A ∧B
◻A := ⋄A
A ∧B := A ∨B
⋄A := ◻A
Let Γ ∈Seq. We deﬁne the following sequent:
⃝Γ := {
⃝A | A ∈Γ}
Now we can deﬁne the notion of LTL-model and validity.
Deﬁnition 1 (LTL-model). An LTL-model or simply a model is a function µ that maps
natural numbers to sets of atomic propositions, i.e.:¹
µ : ℕ→P(Prop)
Let µ be a model. Every natural number i represents a point in time and the set µ(i)
represents the facts that hold at the time-point i. The expression µ, i 　㨐A stands
for model µ satisﬁes formula A at time-point i. The relation 　㨐is deﬁned as follows:
Deﬁnition 2 (Satisﬁability of LS-formulas). Let µ be a model and let i ∈ℕ. We
have:
µ, i 　㨐P
⇐⇒
P ∈µ(i)
µ, i 　㨐P
⇐⇒
P ∉µ(i)
µ, i 　㨐A ∧B
⇐⇒
µ, i 　㨐A and µ, i 　㨐B
µ, i 　㨐A ∨B
⇐⇒
µ, i 　㨐A or µ, i 　㨐B
µ, i 　㨐◻A
⇐⇒
∀j ≥i(µ, j 　㨐A)
µ, i 　㨐⋄A
⇐⇒
∃j ≥i(µ, j 　㨐A)
µ, i 　㨐
⃝A
⇐⇒
µ, i + 1 　㨐A
1 P stands for powerset

174
|
I. Kokkinis and T. Studer
A formula A is valid, denoted by 　㨐A, iﬀ(∀µ)(∀i)[µ, i 　㨐A], i.e. iﬀA holds in all
models at all time-points.
Let Γ ∈Seq. We assume that Γ is semantically equivalent to the disjunction
of its elements, i.e. we set
µ, i 　㨐Γ
⇐⇒
µ, i 　㨐⋁
A∈Γ
A
2.2 A Naive Approach
We begin with a “naive” sequent calculus for LTL, called LTnaive, which is given
in Fig. 1. This system contains the usual propositional axioms and rules (aid, ∨,
∧), the rule for
⃝and the rules for unfolding ◻and ⋄.
As usual L ⊢A means that the logic L proves the formula A. When L is clear
from the context we may simply write ⊢A. By L
n
A we mean that there is a
derivation of A in L with depth at most n.
aid
Γ, P, P
Γ, A, B
∨
Γ, A ∨B
Γ, A
Γ, B
∧
Γ, A ∧B
Γ, A
Γ,
⃝◻A
◻
Γ, ◻A
Γ, A,
⃝⋄A
⋄
Γ, ⋄A
Γ
⃝
Σ,
⃝Γ
Fig. 1. System LTnaive
It is easy to see that system LTnaive is sound with respect to LTL-models. But what
about completeness? The ﬁrst observation, see [Brünnler and Lange, 2008], is that
system LTnaive almost works: the only thing that goes wrong is that we cannot de-
rive induction principles as is shown in the following example.
Example 3. The valid sequent
Γ = ⋄(P ∧
⃝P), P, ◻P
cannot be proved in LTnaive. This sequent is semantically equivalent to the temporal
induction axiom
P ∧◻(P →
⃝P) →◻P

Cyclic Proofs for Linear Temporal Logic
|
175
where the connective →is interpreted in the standard way.
An attempt to prove Γ in LTnaive will lead to a derivation like the following:
aid
⋄(P ∧
⃝P), P, P
aid
⃝⋄(P ∧
⃝P), P, P,
⃝◻P
⋄(P ∧
⃝P), P, ◻P
⃝
⃝⋄(P ∧
⃝P),
⃝P, P,
⃝◻P
∧
⃝⋄(P ∧
⃝P), P ∧
⃝P, P,
⃝◻P
⋄
⋄(P ∧
⃝P), P,
⃝◻P
◻
⋄(P ∧
⃝P), P, ◻P
Observe that the endsequent reappears in the top right of the derivation. Hence there
is no proof of Γ in LTnaive.
When we try to prove a formula that contains the operator ◻, the proof-search
will fail like it did in the above example for sequent Γ. However, the obvious idea
of just closing a cyclic branch as axiomatic will lead to an unsound system as is
illustrated in the next example, see [Brünnler and Lange, 2008].
Example 4. Consider the non-valid sequent ∆= ◻P,
⃝⋄◻P. If we could close all the
cyclic branches then we would have the following proof for ∆in LTnaive:
◻P,
⃝⋄◻P
⋄
⋄◻P
⃝
P,
⃝⋄◻P
◻P,
⃝⋄◻P
⋄
◻P, ⋄◻P
⃝
⃝◻P,
⃝⋄◻P
◻
◻P,
⃝⋄◻P
Hence, a better idea, than simply closing every cyclic branch, is required. Brünnler
and Lange’s idea ([Brünnler and Lange, 2008]) is to close a cyclic branch if there
is a formula such that whenever the ◻-rule is applied to it between the two oc-
currences of the cyclic sequent, the branch is along the right premise. Thus, in
Example 3, the rightmost branch of the LTnaive-derivation for Γ would be closed,
thus yielding a correct proof. In Example 4, however, the left branch in the deriva-
tion for ∆would not be closed and hence this would not be a proof for the non-
valid sequent ∆. In order to implement this idea, we have to enrich our syntax with
the so-called annotations.
2.3 Annotations – System LT1
We deﬁne the set of annotated formulas, Lann:
Lann := {◻ΓA,
⃝◻ΓA 儨儨儨儨A ∈LS, Γ ∈Seq}

176
|
I. Kokkinis and T. Studer
In ◻ΓA, the sequent Γ is called an annotation. We deﬁne the set of annotated se-
quents:
Seqann := { Γ 儨儨儨儨Γ is a ﬁnite subset of LS ∪Lann
that contains at most one annotated formula }
The semantics of ◻ΓA is deﬁned as follows. Let µ be an LTL-model and let i ∈ℕ.
We have:
µ, i 　㨐◻ΓA
⇐⇒
∀j ≥i((∀i ≤k ≤j(µ, k 　㨐Γ)) 㨐⇒µ, j 　㨐A)
System LT1 is given by the axioms and rules in Fig. 2. For the
⃝-rule, we assume
Σ ∈Seq, i.e. Σ does not contain annotated formulas. For rep and foc, we also
assume Γ ∈Seq. System LT1 contains all the rules of the system LTnaive plus the
aid
Γ, P, P
Γ, A, B
∨
Γ, A ∨B
Γ, A
Γ, B
∧
Γ, A ∧B
rep
Γ, ◻ΓA
Γ, A
Γ,
⃝◻ΓA
foc
Γ, ◻A
Γ, A
Γ,
⃝◻A
◻
Γ, ◻A
Γ, A,
⃝⋄A
⋄
Γ, ⋄A
Γ
⃝
Σ,
⃝Γ
Fig. 2. System LT1
rule foc and the axiom rep. The name of the rule foc stands for focus and implies
that we focus on a speciﬁc ◻-formula, i.e. the formula ◻A in the conclusion of the
foc-rule. We focus on this formula by annotating it with its context, i.e. Γ. When
the annotated formula appears in exactly the same context (i.e. Γ), then we can
close the branch as axiomatic using the axiom rep (the name of this axiom stands
for repetition).
The sequent
⋄(P ∧
⃝P), P, ◻P
(which could not be proved in system LTnaive) can now be derived in LT1 as shown
below:

Cyclic Proofs for Linear Temporal Logic
|
177
aid
⋄(P ∧
⃝P), P, P
aid
⃝⋄(P ∧
⃝P), P, P,
⃝◻ΓP
rep
⋄(P ∧
⃝P), P, ◻ΓP
⃝
⃝⋄(P ∧
⃝P),
⃝P, P,
⃝◻ΓP
∧
⃝⋄(P ∧
⃝P), P ∧
⃝P, P,
⃝◻ΓP
⋄
⋄(P ∧
⃝P), P,
⃝◻ΓP
foc
⋄(P ∧
⃝P), P
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
Γ
, ◻P
Brünnler and Lange [Brünnler and Lange, 2008] present a soundness proof for a
system very similar to LT1. However, as we will see later, system LT1 only is com-
plete if we add a cut rule. We deﬁne system LT1cut to be LT1 enriched with the rule
cut:
Γ, A
A, ∆
cut
Γ, ∆
In this rule, A is an LS-formula.
Before showing the completeness and incompleteness results we need to
show that weakening is syntactically admissible in system LT1cut.
Deﬁnition 5. A derivation satisﬁes the next-property iﬀany branch from the end-
sequent to any instance of foc goes through at least one
⃝-rule.
Lemma 6. Let Γ ∈Seq. If LT1cut
n Γ, then there is an LT1cut-proof of Γ satisfying
the next-property.
Proof: By induction on n and a case distinction on the last rule.
1.
Γ is the conclusion of aid. Then the claim holds trivially.
2.
Γ is the conclusion of rep. This case is not possible because of our assumption
Γ ∈Seq.
3.
Γ is the conclusion of foc. Then Γ = ∆, ◻A and the given proof E of Γ has the
following form:
A
∆, A
rep −−−−−−−−−−−−−−−
∆, ◻∆A
. . .
B
Λ
D
∆,
⃝◻∆A
foc −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
∆, ◻A
In the above derivation the sequent Λ contains no annotations, i.e. Λ ∈Seq.
All the other sequents in derivation D contain annotations. Obviously Λ is
obtained by an application of the rule cut.

178
|
I. Kokkinis and T. Studer
First we observe that by the induction hypothesis, there are proofs A耠and B耠
of ∆, A and Λ respectively that satisfy the next-property.
Further we have that in the derivation D
any branch from ∆,
⃝◻∆A to some ∆, ◻∆A
goes through a
⃝-rule
(1)
and
there are no instances of foc.
(2)
Let D耠be the derivation that is obtained from D by dropping all annotations
occurring in threads starting from
⃝◻∆A, i.e. by replacing sequents of the
form Σ, ◻∆A and Σ,
⃝◻∆A by Σ, ◻A and Σ,
⃝◻A, rescpectively.
Hence we have the following proof of ∆, ◻A:
A耠
∆, A
E
∆, ◻A
. . .
B耠
Λ
D耠
∆,
⃝◻A
◻−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
∆, ◻A
This proof satisﬁes the next-property. Indeed:
(a) The proofs A耠and B耠satisfy the next-property.
(b) In the derivation D耠every branch from ∆,
⃝◻A to some ∆, ◻A goes
through at least one
⃝-rule (because of (1)).
(c) The derivation D耠contains no foc-rules (because of (2)).
Hence any branch from the conclusion ∆, ◻A to an instance of foc goes
through a
⃝-rule.
4.
In all other cases, the claim follows easily by the induction hypothesis.
By Lemma 6 we immediately get the following weakening result.
Corollary 7 (Weakening for non-annotated sequents). For any Γ, ∆
∈
Seq we
have:
LT1cut ⊢Γ 㨐⇒LT1cut ⊢Γ, ∆
Proof: Let LT1cut ⊢Γ. By Lemma 6 we have a proof D for Γ that satisﬁes the next-
property. We prove the claim by induction on the length of D. Let α be the lower-
most rule in D. Since D satisﬁes the next-property and Γ ∈Seq, the rule α can be
aid, ∨, ∧, ◻, ⋄, cut or
⃝. If α is aid or
⃝, then claim follows by built-in weaking.
Otherwise it follows by the induction hypothesis.

Cyclic Proofs for Linear Temporal Logic
|
179
By a similar proof, we can show invertibiltiy of ∨.
Corollary 8 (Invertibility of the ∨-rule). For any Γ ∈Seq and A, B ∈LS we have:
LT1cut ⊢Γ, A ∨B 㨐⇒LT1cut ⊢Γ, A, B
3 Completeness
In this section, we show that system LT1cut is complete by embedding a complete
Hilbert system for LTL in LT1cut. We will also show that the cut-free system LT1 is
not complete and that we need more complex annotations to obtain a complete
cut-free system.
3.1 A Hilbert System for LTL
The language LH is described by the following grammar:
ϕ := P | ¬ϕ | ϕ ∧ϕ | ◻ϕ |
⃝ϕ
where P ∈Prop. Additionally we will use the following abbreviations:
ϕ ∨ψ := ¬(¬ϕ ∧¬ψ)
⋄ϕ := ¬◻¬ϕ
ϕ →ψ := ¬(ϕ ∧¬ψ)
ϕ ↔ψ := (ϕ →ψ) ∧(ψ →ϕ)
We will use the Greek letters ϕ, ψ, ρ, . . . for LH-formulas possibly primed or with
subscripts.
Table 1 shows the Hilbert system ΣLTL for LTL.
Table 1. Axioms and Rules of the system ΣLTL
Axioms
Rules
(P)
⊢ϕ, ϕ is a propositional tautology
(MP)
ϕ, ϕ →ψ ⊢ψ
(Fun)
⊢
⃝¬ϕ ↔¬
⃝ϕ
(N
⃝)
ϕ ⊢
⃝ϕ
(K
⃝)
⊢
⃝(ϕ →ψ) →(
⃝ϕ →
⃝ψ)
(Ind)
ϕ →ψ, ϕ →
⃝ϕ ⊢ϕ →◻ψ
(Alw)
⊢◻ϕ →ϕ ∧
⃝◻ϕ
Satisﬁability of LH-formulas in an LTL-model is deﬁned as follows:

180
|
I. Kokkinis and T. Studer
Deﬁnition 9 (Satisﬁability of LH-formulas). Let µ be a model and i ∈ℕ. We have:
µ, i 　㨐P
⇐⇒
P ∈µ(i)
µ, i 　㨐¬ϕ
⇐⇒
µ, i
̸　㨐ϕ
µ, i 　㨐ϕ ∧ψ
⇐⇒
µ, i 　㨐ϕ and µ, i 　㨐ψ
µ, i 　㨐◻ϕ
⇐⇒
∀j ≥i(µ, j 　㨐ϕ)
µ, i 　㨐
⃝ϕ
⇐⇒
µ, i + 1 　㨐ϕ
Validity for LH-formulas is deﬁned in the same way as for LS-formulas. The fol-
lowing theorem is proved in Chapter 2 of [Kröger and Merz, 2008].
Theorem 10 (Soundness and Completeness). The system ΣLTL is sound and com-
plete with respect to LTL-models, i.e. we have for all LH-formulas ϕ:
　㨐ϕ
⇐⇒
ΣLTL ⊢ϕ
3.2 System LT1 + cut is Complete
In this subsection we will show that the system LT1cut is complete by embedding
system ΣLTL to system LT1cut. Before proving the embedding we need some auxil-
iary deﬁnitions and lemmata.
As a ﬁrst step we extend axiom aid to all LS-formulas.
Lemma 11. [Extension of axiom aid to LS-formulas] Let Γ ∈Seq and let A ∈LS.
Then we have the following in system LT1cut:
⊢Γ, A, A
Proof: The proof is by induction on the structure of A. The only interesting cases
are A = ◻B and A = ⋄B. So assume A = ◻B. It holds A = ⋄B. Then we have the
following derivation in LT1cut:
i.h.
B,
⃝⋄B, B
⋄
B, ⋄B
rep
◻⋄BB, ⋄B
⃝
⃝◻⋄BB,
⃝⋄B, B
⋄
⃝◻⋄BB, ⋄B
foc
◻B, ⋄B
Corollary 7
Γ, ◻B, ⋄B
The case A = ⋄B simply is dual to the shown case.

Cyclic Proofs for Linear Temporal Logic
|
181
An easy induction on the structure of the formula A also yields the following
lemma.
Lemma 12. Let A ∈LS. It holds that:
A = A
Now we deﬁne two translation functions between the languages LH and LS.
We deﬁne the function σ : LS →LH inductively:
σ(P) = P
σ(P) = ¬P
σ(A ∧B) = σ(A) ∧σ(B)
σ(A ∨B) = σ(A) ∨σ(B)
σ(◻A) = ◻σ(A)
σ(⋄A) = ⋄σ(A)
σ(
⃝A) =
⃝σ(A)
We deﬁne the function τ : LH →LS inductively:
τ(P) = P
τ(◻ϕ) = ◻τ(ϕ)
τ(¬ϕ) = τ(ϕ)
τ(
⃝ϕ) =
⃝τ(ϕ)
τ(ϕ ∧ψ) = τ(ϕ) ∧τ(ψ)
Some simple calculations show that the function τ behaves as expected with re-
spect to the propositional connectives.
Lemma 13. Let ϕ, ψ ∈LH. It holds:
1.
τ(ϕ →ψ) = τ(ϕ) ∨τ(ψ)
2.
τ(ϕ ∨ψ) = τ(ϕ) ∨τ(ψ)
3.
τ(ϕ ↔ψ) = (τ(ϕ) ∨τ(ψ)) ∧(τ(ψ) ∨τ(ϕ))
4.
τ(⋄ϕ) = ⋄τ(ϕ)
It is straightforward to show that τ is the inverse of σ.
Lemma 14. Let A ∈LS. It holds:
τ(σ(A)) = A
Now we can prove the embedding Lemma:
Lemma 15 (Embedding of ΣLTL into LT1cut).
(∀ϕ ∈LH)[ΣLTL ⊢ϕ 㨐⇒LT1cut ⊢τ(ϕ)]
Proof: By induction on the length of the derivation ΣLTL ⊢ϕ. We distinguish the
following cases:

182
|
I. Kokkinis and T. Studer
1.
ϕ is a propositional tautology. Then τ(ϕ) is also a propositional tautology.
Hence, clearly LT1cut ⊢τ(ϕ).
2.
ϕ is an instance of the axiom (Fun). That means there is a ψ ∈LH such that
ϕ = ¬
⃝ψ ↔
⃝¬ψ. From Lemma 12 and Lemma 13 we get:
τ(ϕ) = (
⃝τ(ψ) ∨
⃝τ(ψ)) ∧(
⃝τ(ψ) ∨
⃝τ(ψ))
So, we have the following derivation in LT1cut:
Lemma 11
⃝τ(ψ),
⃝τ(ψ)
∨
⃝τ(ψ) ∨
⃝τ(ψ)
Lemma 11
⃝τ(ψ),
⃝τ(ψ)
∨
⃝τ(ψ) ∨
⃝τ(ψ)
∧
(
⃝τ(ψ) ∨
⃝τ(ψ)) ∧(
⃝τ(ψ) ∨
⃝τ(ψ))
3.
ϕ is an instance of axiom (K
⃝). That means there are ψ, ρ ∈LH such that
ϕ =
⃝(ψ →ρ) →
⃝ψ →
⃝ρ. By Lemma 12 and Lemma 13 we get:
τ(ϕ) =
⃝(τ(ψ) ∧τ(ρ)) ∨
⃝τ(ψ) ∨
⃝τ(ρ)
So, we have the following derivation:
Lemma 11
τ(ψ), τ(ψ), τ(ρ)
Lemma 11
τ(ρ), τ(ψ), τ(ρ)
∧
τ(ψ) ∧τ(ρ), τ(ψ), τ(ρ)
⃝
⃝(τ(ψ) ∧τ(ρ)) ,
⃝τ(ψ),
⃝τ(ρ)
∨
⃝(τ(ψ) ∧τ(ρ)) ∨
⃝τ(ψ),
⃝τ(ρ)
∨
⃝(τ(ψ) ∧τ(ρ)) ∨
⃝τ(ψ) ∨
⃝τ(ρ)
4.
ϕ is an instance of the axiom (Alw). That means there is a ψ ∈LH such that
ϕ = ◻ψ →ψ ∧
⃝◻ψ. From Lemma 12 and Lemma 13 we get:
τ(ϕ) = ⋄τ(ψ) ∨(τ(ψ) ∧
⃝◻τ(ψ))
So, we have the following derivation in LT1cut:
Lemma 11
τ(ψ),
⃝⋄τ(ψ), τ(ψ)
Lemma 11
τ(ψ),
⃝⋄τ(ψ),
⃝◻τ(ψ)
∧
τ(ψ),
⃝⋄τ(ψ), τ(ψ) ∧
⃝◻τ(ψ)
⋄
⋄τ(ψ), τ(ψ) ∧
⃝◻τ(ψ)
∨
⋄τ(ψ) ∨(τ(ψ) ∧
⃝◻τ(ψ))

Cyclic Proofs for Linear Temporal Logic
|
183
5.
ϕ is the conclusion of an application of (MP). That means there is a ψ ∈LH
such that ΣLTL ⊢ψ and ΣLTL ⊢ψ →ϕ. Then we ﬁnd the following derivation
in LT1cut:
i.h.
τ(ψ)
i.h.
τ(ψ →ϕ)
Lemma 13 1
τ(ψ) ∨τ(ϕ)
Corollary 8
τ(ψ), τ(ϕ)
cut
τ(ϕ)
6.
ϕ is the conclusion of an application of (N
⃝). That means that there is a ψ ∈
LH such that ϕ =
⃝ψ and that ΣLTL ⊢ψ. In LT1cut we have the following
derivation:
i.h.
τ(ψ)
⃝
⃝τ(ψ)
And since
⃝τ(ψ) = τ(
⃝ψ) = τ(ϕ) we have that LT1cut ⊢τ(ϕ).
7.
ϕ is the conclusion of an application of (Ind). That means there are ψ, ρ ∈LH
such that ϕ = ψ →◻ρ, and that ΣLTL ⊢ψ →ρ and ΣLTL ⊢ψ →
⃝ψ. By
Lemma 13 1 we have:
τ(ϕ) = τ(ψ →◻ρ) = τ(ψ) ∨◻τ(ρ)
τ(ψ →ρ) = τ(ψ) ∨τ(ρ)
τ(ψ →
⃝ψ) = τ(ψ) ∨
⃝τ(ψ)
We ﬁnd the following derivation in LT1cut:
i.h.
τ(ψ) ∨τ(ρ)
Corollary 8
τ(ψ), τ(ρ)
i.h.
τ(ψ) ∨
⃝τ(ψ)
Corollary 8
τ(ψ),
⃝τ(ψ)
rep
τ(ψ), ◻τ(ψ)τ(ρ)
⃝τ(ψ),
⃝◻τ(ψ)τ(ρ)
cut
τ(ψ),
⃝◻τ(ψ)τ(ρ)
foc
τ(ψ), ◻τ(ρ)
∨
τ(ψ) ∨◻τ(ρ)
To establish completeness of LT1cut, we need the following lemma, which can eas-
ily be shown by induction on A.
Lemma 16. Let A ∈LS, let µ be a model and let i ∈ℕ. It holds:
µ, i 　㨐A
㨐⇒
µ, i 　㨐σ(A)

184
|
I. Kokkinis and T. Studer
Finally we can prove completeness of system LT1cut.
Theorem 17. System LT1cut is complete for LS-formulas, i.e. for all LS-formulas A
　㨐A
㨐⇒
LT1cut ⊢A
Proof: Let A ∈LS. We have:
　㨐A 㨐⇒(∀µ)(∀i ∈ℕ)[µ, i 　㨐A]
Lemma 16
㨐⇒
(∀µ)(∀i ∈ℕ)[µ, i 　㨐σ(A)] 㨐⇒　㨐σ(A)
Theorem 10
㨐⇒
ΣLTL ⊢σ(A)
Lemma 15
㨐⇒
LT1cut ⊢τ(σ(A))
Lemma 14
㨐⇒
LT1cut ⊢A
3.3 System LT1 is not Complete
Now we show that if we remove the rule cut from system LT1cut, the resulting sys-
tem (i.e. LT1) is not complete. Let Γ be the following valid sequent:
P, ⋄(P ∧
⃝
⃝P), ◻(P ∨
⃝P)
Γ is semantically equivalent to the following LH-formula:
P ∧◻(P →
⃝
⃝P) →◻(P ∨
⃝P)
which expresses a valid induction statement in LTL.
The following derivation is an attempt to prove Γ in LT1.
aid
P, ⋄(P ∧
⃝
⃝P), P,
⃝P
∨
P, ⋄(P ∧
⃝
⃝P), P ∨
⃝P
aid
P, P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆P
D
∧
P, P ∧
⃝
⃝P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
⋄
P, ⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
foc
P, ⋄(P ∧
⃝
⃝P)
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
∆
, ◻(P ∨
⃝P)
D {
⃝P, ⋄(P ∧
⃝
⃝P), ◻∆(P ∨
⃝P)
⃝
P,
⃝
⃝P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
The reason we cannot prove sequent Γ in system LT1 is that in system LT1 it is im-
possible to “get rid of an annotation”. So, in the above proof-attempt for Γ there
is no way we can drop ∆from sequent
⃝P, ⋄(P ∧
⃝
⃝P), ◻∆(P ∨
⃝P), which is
the sequent on the top of the derivation D. So, the only way to prove an annotated
sequent is to reach either axiom rep or axiom aid from it. In our case it is impos-
sible to reach rep from
⃝P, ⋄(P ∧
⃝
⃝P), ◻∆(P ∨
⃝P), since it would require the

Cyclic Proofs for Linear Temporal Logic
|
185
application of a
⃝-rule, which is not possible (the conclusion of a
⃝-rule can-
not contain a formula of the form ◻∆A). It is also impossible to reach aid from
⃝P, ⋄(P∧
⃝
⃝P), ◻∆(P∨
⃝P) since the sequent
⃝P, ⋄(P∧
⃝
⃝P) is not valid and
our system is sound. Thus, proof-search for Γ in LT1 fails and, therefore, system
LT1 is not complete.
We can tackle the problem of “being unable to get rid of annotations” by in-
troducing a new rule. For any ∆∈Seq we deﬁne the following rule:
Γ, A
Γ,
⃝◻∆A
◻∆
Γ, ◻∆A
Rule ◻∆is sound with respect to LTL-models for any ∆. As we can see, rule ◻∆allows
us to drop the annotation from an annotated sequent (the left premise of the rule
◻∆is an unannotated sequent). We deﬁne LT1+ to be system LT1 plus the rule ◻∆
for any ∆∈Seq.
In system LT1+ we can prove the sequent P, ⋄(P∧
⃝
⃝P), ◻(P∨
⃝P) as follows:
aid
P, ⋄(P ∧
⃝
⃝P), P,
⃝P
∨
P, ⋄(P ∧
⃝
⃝P), P ∨
⃝P
aid
P, P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
D1
∧
P, P ∧
⃝
⃝P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
⋄
P, ⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
foc
P, ⋄(P ∧
⃝
⃝P)
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
∆
, ◻(P ∨
⃝P)
D1
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
aid
P, P
⃝
⃝P, ⋄(P ∧
⃝
⃝P), P,
⃝P
∨
⃝P, ⋄(P ∧
⃝
⃝P), P ∨
⃝P
D2
⋄
⃝P, ⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
◻∆
⃝P, ⋄(P ∧
⃝
⃝P), ◻∆(P ∨
⃝P)
⃝
P,
⃝
⃝P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
D2
{
{
{
{
{
{
{
{
{
rep
P, ⋄(P ∧
⃝
⃝P), ◻∆(P ∨
⃝P)
⃝
⃝P, P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
D3
∧
⃝P, P ∧
⃝
⃝P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
D3
{
{
{
rep
P, ⋄(P ∧
⃝
⃝P), ◻∆(P ∨
⃝P)
⃝
⃝P,
⃝
⃝P,
⃝⋄(P ∧
⃝
⃝P),
⃝◻∆(P ∨
⃝P)
However, LT1+ is still too simple: it fails to prove all valid sequents. Take for ex-
ample the following valid sequent, which we call Σ:
⃝◻(P ∨Q), ⋄(
⃝P ∧
⃝Q)

186
|
I. Kokkinis and T. Studer
where P, Q are diﬀerent elements of Prop. We show that Σ cannot be derived in
LT1+.
We set C = P∨Q and D =
⃝P∧
⃝Q. A proof-attempt for Σ in LT1+ is as follows:
D1(P, Q)
⃝
⃝◻C,
⃝⋄D,
⃝P
D1(Q, P)
⃝
⃝◻C,
⃝⋄D,
⃝Q
∧
⃝◻C,
⃝⋄D, D
⋄
⃝◻C, ⋄D
where D1(P, Q) is
aid
P, Q, ⋄D, P
∨
C, ⋄D, P
rep
⋄D, P, ◻⋄D,PC
⃝
⃝⋄D,
⃝P, P,
⃝◻⋄D,PC
D2(P, Q)
⃝
⃝⋄D,
⃝Q, P,
⃝◻⋄D,PC
∧
⃝⋄D, D, P,
⃝◻⋄D,PC
⋄
⋄D, P,
⃝◻⋄D,PC
foc
◻C, ⋄D, P
and D2(P, Q) is
aid
⋄D, Q, P, Q
∨
⋄D, Q, C
rep
⋄D, P, ◻⋄D,PC
⃝
⃝⋄D,
⃝P, Q,
⃝◻⋄D,PC
⋄D, Q, ◻⋄D,PC
⃝
⃝⋄D,
⃝Q, Q,
⃝◻⋄D,PC
∧
⃝⋄D, D, Q,
⃝◻⋄D,PC
⋄
⋄D, Q,
⃝◻⋄D,PC
◻⋄D,P
⋄D, Q, ◻⋄D,PC
The reason we cannot prove Σ in LT1+ is that it is impossible to prove the sequent
⋄D, Q, ◻⋄D,PC in LT1+. Since ⋄D, Q, ◻⋄D,PC is no instance of axiom rep, it is natural
to try to prove it by applying the ◻⋄,P rule ﬁrst. However, as we can see in deriva-
tion D2(P, Q) this leads again to sequent ⋄D, Q, ◻⋄D,PC. Hence proof-search for Σ
fails, i.e. LT1+ cannot be complete. However, the fact that an annotated sequent,
i.e. ⋄D, Q, ◻⋄D,PC, is cyclic in D2(P, Q) gives us a hint for how we should improve
the principle for closing cyclic branches. What if we keep a set of sequents rather
than a single sequent in the annotation? This is the approach of Brünnler and
Lange [Brünnler and Lange, 2008], which we study in the next section.
4 Histories
So far, all our systems could only store one sequent in the annotation. In the pre-
vious section we have seen that this not enough to deﬁne a complete cut-free se-
quent system for LTL. Brünnler and Lange [Brünnler and Lange, 2008] present a

Cyclic Proofs for Linear Temporal Logic
|
187
system that is very similar to LT1. The only diﬀerence is that their annotations
contain sets of sequents rather than single sequents. Based on their approach, we
present a system LT2, for which we syntactically establish weakening. This solves
an open problem of Brünnler and Lange.
4.1 System LT2
We start with deﬁning the set of histories (ﬁnite sets of sequents), which we call
His:
His = {H 儨儨儨儨H is a ﬁnite subset of Seq}
We will use the letters H and G for histories, possibly primed or with subscripts.
We also deﬁne the set Lhis:
Lhis := {◻HA,
⃝◻HA 儨儨儨儨A ∈LS, H ∈His}
We will refer to Lhis-formulas as formulas with histories, or when there is no dan-
ger of confusion as annotated formulas. We also deﬁne the set of sequents with
histories:
Seqhis := { Γ 儨儨儨儨Γ is a ﬁnite subset of LS ∪Lhis
that contains at most one Lhis-formula }
We assume that a history is semantically equivalent to the conjunction of its ele-
ments, i.e. for a model µ and i ∈ℕ:
µ, i 　㨐H
⇐⇒
µ, i 　㨐⋀
Γ∈H
Γ
⇐⇒
µ, i 　㨐⋀
Γ∈H
⋁
A∈Γ
A
The semantics of ◻HA is deﬁned like that of ◻ΓA. We have:
µ, i 　㨐◻HA
⇐⇒
∀j ≥i((∀i ≤k ≤j(µ, k 　㨐H)) 㨐⇒µ, j 　㨐A)
In Figure 3 we present system LT2. Again we assume Σ ∈Seq in the
⃝-rule. For
rep, ◻H and foc, we also assume Γ ∈Seq.
Whenever rule ◻∆is applied in an LT1+-proof, the sequent in the annotation does
not change. In system LT2, an application of rule ◻H leads to a new sequent being
added to the annotation (history). Thus, rule ◻H is a generalization of rule ◻∆,
which implies that system LT1+ is a subsystem of LT2.
System LT2 proves the sequent:
Σ =
⃝◻(P ∨Q), ⋄(
⃝P ∧
⃝Q)

188
|
I. Kokkinis and T. Studer
aid
Γ, P, P
Γ, A, B
∨
Γ, A ∨B
Γ, A
Γ, B
∧
Γ, A ∧B
rep
Γ, ◻H,ΓA
Γ, A
Γ,
⃝◻{Γ}A
foc
Γ, ◻A
Γ, A
Γ,
⃝◻H,ΓA
◻H
Γ, ◻HA
Γ, A
Γ,
⃝◻A
◻
Γ, ◻A
Γ, A,
⃝⋄A
⋄
Γ, ⋄A
Γ
⃝
Σ,
⃝Γ
Fig. 3. System LT2
which as we saw in section 3 cannot be proved in LT1+. Hence, system LT1+ is
proper subsystem of system LT2. We now present the proof of Σ in LT2. As before
we set D =
⃝P ∧
⃝Q and C = P ∨Q. Moreover, we sometimes write, e.g., ◻∆,Γ for
◻{∆,Γ}.
D1(P, Q)
⃝
⃝◻C,
⃝⋄D,
⃝P
D1(Q, P)
⃝
⃝◻C,
⃝⋄D,
⃝Q
∧
⃝◻C,
⃝⋄D, D
⋄
⃝◻C, ⋄D
where D1(P, Q) is
aid
P, Q, ⋄D, P
∨
C, ⋄D, P
rep
⋄D, P, ◻{⋄D,P}C
⃝
⃝⋄D,
⃝P, P,
⃝◻{⋄D,P}C
D2(P, Q)
⃝
⃝⋄D,
⃝Q, P,
⃝◻{⋄D,P}C
∧
⃝⋄D, D, P,
⃝◻{⋄D,P}C
⋄
⋄D, P,
⃝◻{⋄D,P}C
foc
◻C, ⋄D, P
D2(P, Q) is
aid
⋄D, Q, P, Q
∨
⋄D, Q, C
D3(P, Q)
⋄
⋄D, Q,
⃝◻{⋄D,P},{⋄D,Q}C
◻{⋄D,P}
⋄D, Q, ◻{⋄D,P}C
and D3(P, Q) is
rep
⋄D, P, ◻{⋄D,P},{⋄D,Q}C
⃝
⃝⋄D,
⃝P, Q,
⃝◻{⋄D,P},{⋄D,Q}C
rep
⋄D, Q, ◻{⋄D,P},{⋄D,Q}C
⃝
⃝⋄D,
⃝Q, Q,
⃝◻{⋄D,P},{⋄D,Q}C
∧
⃝⋄D, D, Q,
⃝◻{⋄D,P},{⋄D,Q}C

Cyclic Proofs for Linear Temporal Logic
|
189
As we mentioned before, Brünnler and Lange’s system with histories is very sim-
ilar to our LT2, so using the same techniques as in [Brünnler and Lange, 2008] we
can show soundness and completeness. Actually, we can prove completeness for
a system LT2耠, in which the
⃝-rule allows only weakinging with atomic formulas.
This system can then be embedded in LT2, thus showing the completeness of LT2.
Theorem 18. System LT2 is sound and complete with respect to LTL-models, i.e. for
all LS-formulas A we have
　㨐A
⇐⇒
LT2 ⊢A
4.2 Weakening
Brünnler and Lange [Brünnler and Lange, 2008] formulated the problem of syn-
tactically showing the admissibility of weakening in annotated systems. Here we
provide a solution to this problem for LT2.
We use the same approach as for LT1. That is we show weakening as a corol-
lary of the next-property. However, the presence of histories in LT2 requires some
care. We will need the following two auxiliary statements, which can be shown
simultaneously by induction on n.
Lemma 19. Let H and G ∈His. It holds:
1.
If LT2
n Γ, ◻HA, then LT2
n Γ, ◻H,GA.
2.
If LT2
n Γ,
⃝◻HA, then LT2
n Γ,
⃝◻H,GA.
The analogue of Lemma 6 for system LT2 is the following lemma:
Lemma 20. Let Γ ∈Seq. If LT2
n Γ, then there is an LT2-proof of Γ satisfying the
next-property.
Proof: Again the proof is by induction on n and a case distinction on the last rule.
We only show the case for foc. Then Γ = ∆, ◻A and the given proof E of Γ has the
following form (where the derivation H is shown in the next page):
A
∆, A
. . .
H
rep −−−−−−−−−−−−−−−−−−
∆, ◻{∆}A
D
∆,
⃝◻{∆}A
foc −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
∆, ◻A

190
|
I. Kokkinis and T. Studer
H
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
{
Ai
Γi, A
rep −−−−−−−−−−−−−−−−−−
∆, ◻Hi1 A
. . .
rep −−−−−−−−−−−−−−−−−−−−
Γil, ◻Hil A
Di
Γi,
⃝◻{∆,Γi}A
◻{∆} −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
Γi, ◻{∆}A
We have that in the derivation D:
any branch from ∆,
⃝◻A to some Γi, ◻A or some
(3)
∆, ◻A goes through a
⃝-rule
and
there are no instances of foc
(4)
Furthermore, we observe that if ∆∈Hik (that is when ∆, ◻Hik A is an instance of
rep), then from LT2 ⊢∆,
⃝◻{∆}A and Lemma 19 we get a proof Bik for ∆,
⃝◻Hik A.
We let D耠
i be the the derivation that results from Di by deleting ∆from all
histories occurring in threads starting from
⃝◻{∆,Γi}A.
Hence we obtain the following proofs of Γi, ◻A, which we denote by Ci.
Ai
Γi, A
A
∆, A
Bi1
∆,
⃝◻Hi1 A
◻Hi1\{∆} −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
∆, ◻Hi1\{∆}A
. . .
Γil, ◻Hil \{∆}A
D耠
i
Γi,
⃝◻{Γi}A
foc −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
Γi, ◻A
Now we proceed as follows:
1.
We apply the induction hypothesis to A, which yields a proof A耠of ∆, A that
satisﬁes the next-property.
2.
We let D耠be the derivation that results from D by dropping the annotation ∆
in the threads starting from
⃝◻{∆}A.

Cyclic Proofs for Linear Temporal Logic
|
191
We ﬁnd that in the derivation D耠,
any branch from ∆,
⃝◻A to some Γi, ◻A or some
∆, ◻A goes through a
⃝-rule
because of (3) and
there are no instances of foc
because of (4).
Finally we obtain the following proof of ∆, ◻A.
A耠
∆, A
Ci
Γi, ◻A
. . .
E
∆, ◻A
D耠
∆,
⃝◻A
◻−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
∆, ◻A
This proof satisﬁes the next-property. Indeed, we have:
1.
the proof A耠satisﬁes the next-property;
2.
any branch from ∆,
⃝◻A to some Γi, ◻A or to some ∆, ◻A goes through a
⃝-
rule;
3.
the derivation D耠does not contain instances of foc.
Hence any branch from the conclusion ∆, ◻A to an instance of foc goes through a
⃝-rule.
We get weakening for LT2 as a corollary of Lemma 20. The proof is the same as for
Corollary 7.
Corollary 21 (Weakening for non-annotated sequents). For any Γ, ∆∈Seq we
have:
LT2 ⊢Γ
㨐⇒
LT2 ⊢Γ, ∆
Acknowledgment: We would like to thank the anonymous referee for valuable
comments that helped us improve the paper substantially.

192
|
I. Kokkinis and T. Studer
References
James Brotherston and Alex Simpson. Sequent calculi for induction and inﬁnite descent. Jour-
nal of Logic and Computation, 21(6):1177–1216, December 2011.
Kai Brünnler and Martin Lange. Cut-free sequent systems for temporal logic. The Journal of
Logic and Algebraic Programming, 76(2):216–225, 2008.
Samuel Bucheli, Roman Kuznets, and Thomas Studer. Two ways to common knowledge.
In Thomas Bolander and Torben Braüner, editors, Proceedings of the 6th Workshop
on Methods for Modalities (M4M–6 2009), Copenhagen, Denmark, 12–14 November
2009, Electronic Notes in Theoretical Computer Science, pages 83–98. Elsevier, 2010.
10.1016/j.entcs.2010.04.007. URL http://www.iam.unibe.ch/ltgpub/2010/bks10a.pdf.
Fred Kröger and Stephan Merz. Temporal Logic and State Systems. Springer, Berlin, 2008.
Martin Lange and Colin Stirling. Focus games for satisﬁability and completeness of temporal
logic. In LICS, 2001.
Damian Niwinski and Igor Walukiewicz. Games for the mu-calculus. Theoretical Computer
Science, 163(1&2):99–116, 1996.
Daniyar S. Shamkanov. Circular proofs for Gödel-Löb logic. CoRR, abs/1401.4002, 2014. URL
http://arxiv.org/abs/1401.4002.
Thomas Studer. On the proof theory of the modal mu-calculus. Studia Logica, 89:343–363,
2008. 10.1007/s11225-008-9133-6.

Roman Kuznets
Craig Interpolation via Hypersequents
Abstract: In this paper, we describe a novel constructive method of proving the
Craig interpolation property (CIP) based on cut-free hypersequent calculi and ap-
ply the method to prove the CIP for the modal logic S5.
Keywords: Craig interpolation, Hypersequent, Structural proof theory, Modal
logic
Mathematics Subject Classiﬁcation 2010: 03B45, 03C40, 03F07, 03B70
1 Introduction
Interpolation is one of the standard properties of a logical system, studied along-
side decidability, complexity, and semantic completeness. Interpolation is closely
related to algebraic properties such as amalgamation (see [Gabbay and Maksi-
mova, 2005] for an overview and the history of the subject). The logic L is said
to have the Craig interpolation property (CIP) if, whenever L ⊢A →B, there ex-
ists a formula C “in the common language” of A and B such that L ⊢A →C and
L ⊢C →B. The formula C is then called the interpolant of A and B. In this paper,
we consider modal logics, hence, the “common language” simply means having
the same propositional variables.
One of the methods for proving the CIP constructively and eﬃciently¹, is by
employing a cut-free (or, more generally, an analytic) proof system and by con-
structing an interpolant by induction on the derivation of A →B (properly rep-
resented in this proof system). Such a method based on sequent calculi is well
known and had been used for many a system, e.g., for classical and intuitionistic
propositional logics and for many modal logics. However, sequent calculi do not
seem to be expressive enough to capture many interesting modal logics. In fact,
one of the ﬁrst modal logics to be considered in modern times, S5, has so far re-
sisted all attempts at being captured by a cut-free sequent calculus. Moreover, it
was shown by Lellmann and Pattinson [2013] that such a calculus does not exist
under reasonable restrictions on the type of rules used.
1 Rather than by the exhaustive search of all potential interpolants.
Roman Kuznets: Institut für Computersprachen, Technische Universität Wien,
e-mail: roman@logic.at

194
|
R. Kuznets
The simplest extension of the sequent formalism that is known to be capa-
ble of capturing S5 is the formalism of hypersequents, which was ﬁrst introduced
by Minc [1971]. (Mints² used the term “cortege” rather than “hypersequent” and
employed a slightly more cumbersome notation than we are used to now.³) Hyper-
sequents under their proper name were later independently rediscovered by Pot-
tinger [1983] and Avron [1987].
It is, thus, natural to generalize the constructive method of showing the CIP
from sequents to hypersequents. In his seminal survey, Avron [1996] writes:
The only rule [...] which brings moments of synchronization into proofs is external contrac-
tion. [I]ts presence is the explanation why in hypersequential calculi cut-elimination usually
does not imply the Craig interpolation theorem.
According to Avron, the rule of external contraction
G | Γ ⇒∆| Γ ⇒∆
EC −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ ⇒∆
is the main obstacle to such a generalization. However, the modal logic S5, cap-
tured by a hypersequent calculus with the external contraction rule EC, is known
to enjoy the CIP. Thus, EC does not, in general, prevent the CIP from holding.
In a joint work [Fitting and Kuznets, 2015], we developed a method of gen-
eralizing the syntactic proof of the CIP from sequents to nested sequents. While
hypersequents are not exactly subsystems of nested sequents because several of
hypersequent rules are not present in nested calculi, it is reasonable to view hy-
persequents as substructures of nested sequents. Indeed, a hypersequent is a set
(multiset, sequence) of ordinary sequents, whereas a nested sequent is a tree of
sequents. Both hypersequents and nested sequents are internal calculi, meaning
that each hypersequent and each nested sequent can be translated into a formula.
Based on the commonly used translations, components of a hypersequent corre-
spond to children of the root of a nested sequent. Thus, it seems reasonable to
expect that the method for proving the CIP via nested sequents from [Fitting and
Kuznets, 2015] can be adapted to hypersequents. In this paper, we show that this
is indeed the case and that the external contraction does not present any diﬃcul-
ties for our method. We develop the method using a hypersequent calculus for S5
from [Avron, 1996] as an example.
2 Spelled “Minc” in the translation.
3 The full text of the original Russian version of 1968 is available at
http://mi.mathnet.ru/eng/tm/v98/p88.

Craig Interpolation via Hypersequents
|
195
2 The Modal Logic S5
Being the ﬁfth of Lewis’s systems, the modal logic S5 is one of the oldest mod-
ern modal logics in existence and is often used, for instance, as a logic of knowl-
edge [Fagin et al., 1995]. Its language, which we will call the modal language, is
deﬁned by the grammar
A ::= P | ⊥| (A →A) | ◻A,
where P is taken from a countably inﬁnite set Prop of propositional variables. The
Boolean constant ⊤, the Boolean connectives ¬, ∧, and ∨, and the modality ⋄are
deﬁned in the standard way. We use the standard conventions regarding the omis-
sion of redundant parentheses.
The modal logic S5 is axiomatized by all instances of propositional tautolo-
gies in the modal language above and the following modal axioms:
–
t: ◻A →A;
–
4: ◻A →◻◻A;
–
5: ¬◻A →◻¬ ◻A.
The epistemic reading of these axioms, when ◻A is understood as “A is known,”
states the factivity of knowledge and the positive and negative introspection of the
knowledge agent. The inference rules are modus ponens and modal necessitation:
A →B
A
MP −−−−−−−−−−−−−−−−−−−−−−
B
and
A
Nec −−−−−−
◻A
.
The logic S5 has a particularly simple Kripke semantics:
Deﬁnition 2.1 (Kripke frames and models). A Kripke frame (for S5) is (W, ∼), a
pair of a non-empty set W and of an equivalence relation ∼on W. Elements of W
are called worlds. If u ∼v, we say that the world u is indistinguishable from
the world v. A Kripke model (for S5) is a triple (W, ∼, V) where (W, ∼) is a Kripke
frame (for S5) and V : W →2Prop is a valuation that assigns to each world from W
the set of propositional variables true at this world.
Deﬁnition 2.2 (Truth and validity in Kripke models). Given a Kripke model M =
(W, ∼, V), the relation of truth between modal formulas and worlds w in this model
is deﬁned as follows:
for each propositional variable P ∈Prop:
M, w ⊩P
iff
P ∈V(w);
M, w ⊮⊥;
M, w ⊩A →B
iff
M, w ⊮A or M, w ⊩B;
M, w ⊩◻A
iff
M, v ⊩A for all v ∈W such that v ∼w.

196
|
R. Kuznets
We say that A is valid in M, written M ⊩A, if M, w ⊩A for all w ∈W.
Theorem 2.3 (Completeness of Kripke semantics for S5, [Fagin et al., 1995]). For
any modal formula A,
S5 ⊢A
iff
A is valid in all Kripke models for S5.
3 Hypersequents for S5
Deﬁnition 3.1 (Sequents and hypersequents). A sequent is a ﬁgure Γ ⇒∆where
Γ and ∆are ﬁnite (possibly empty) multisets of modal formulas. A hypersequent G
is a ﬁnite (possibly empty) sequence
Γ1 ⇒∆1 | . . . | Γn ⇒∆n
of sequents Γi ⇒∆i, called (sequent) components of G. We deﬁne the length ‖G‖ of
a hypersequent G to be the number of sequent components it contains.
We denote ﬁnite multisets of formulas by Γ, ∆, Π, Σ, etc.and denote hypersequents
by G, H, etc. For a multiset of formulas Γ, we deﬁne ◻Γ := {◻C | C ∈Γ}.
Deﬁnition 3.2 (Hypersequent system for S5). The hypersequent system HS5 for
the logic S5 is presented in Figure 1. It is essentially the one presented in [Avron,
1996]. The modiﬁcations are slight and clearly do not aﬀect the cut-free complete-
ness of the system. We list the diﬀerences between our presentation compared to
that by Avron [1996]:
–
sequent components consist of pairs of multisets of formulas rather than pairs
of sequences of formulas (a hypersequent, however, remains a sequence of com-
ponents);
–
Boolean connectives are restricted to ⊥and →;
–
in [Avron, 1996] rules can be applied to any component of a hypersequent,
whereas we restrict the applications to the last component of the hypersequent,
except for the external exchange rule;
–
it is not speciﬁed what type of propositional rules, additive or multiplicative, is
used in [Avron, 1996].
To state the completeness of the hypersequent calculus HS5 with respect to the
logic S5, we use a translation from hypersequents to formulas:

Craig Interpolation via Hypersequents
|
197
id −−−−−−−−−−−−−−−−−−−
A ⇒A
id⊥−−−−−−−−−−−−−−
⊥⇒
G | Γ ⇒∆, A
G | Γ, B ⇒∆
→⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ, A →B ⇒∆
G | Γ, A ⇒∆, B
⇒→−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ ⇒∆, A →B
G | Γ ⇒∆
W ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ, A ⇒∆
G | Γ ⇒∆
⇒W −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ ⇒∆, A
G
EW −−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ ⇒∆
G | Γ, A, A ⇒∆
C ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ, A ⇒∆
G | Γ ⇒∆, A, A
⇒C −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ ⇒∆, A
G | Γ ⇒∆| Γ ⇒∆
EC −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ ⇒∆
G | Γ ⇒∆| Λ ⇒Θ | H
Ex −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Λ ⇒Θ | Γ ⇒∆| H
G | Γ, A ⇒∆
◻⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | Γ, ◻A ⇒∆
G | ◻Γ ⇒A
⇒◻−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | ◻Γ ⇒◻A
G | ◻Λ, Γ ⇒◻Φ, ∆
MS −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
G | ◻Λ ⇒◻Φ | Γ ⇒∆
Fig. 1. Cut-free hypersequent system HS5 for the modal logic S5 (following [Avron, 1996]).
Deﬁnition 3.3 (Formula translation). The formula translation of a hypersequent is
deﬁned as
Γ1 ⇒∆1 | . . . | Γn ⇒∆n :=
n
⋁
i=1
◻(⋀Γi →⋁∆i) .
As usual, the empty disjunction is understood to be ⊥and the empty conjunction
is ⊤. (Strictly speaking, the order of formulas in ⋀Γi and ⋁∆i has to be speciﬁed
even though all possible end results are pairwise provably equivalent in S5. To be
formally correct, we assume an arbitrary but ﬁxed order on modal formulas and use
it in the conjunctions/disjunctions of multisets Γi and ∆i.)

198
|
R. Kuznets
Theorem 3.4 (Completeness of HS5, [Avron, 1996]). For any hypersequent G,
HS5 ⊢G
⇐⇒
S5 ⊢G.
Corollary 3.5. For arbitrary modal formulas A and B,
HS5 ⊢A ⇒B
⇐⇒
S5 ⊢A →B.
4 Preparing for Interpolation
Interpolation is always performed between two entities, e.g., between formu-
las A and B. The last corollary of the preceding section shows that we can equiva-
lently interpolate between the antecedent and consequent of a single-component
hypersequent. However, as in the case of two-sided sequents, such a division does
not remain stable along a hypersequent derivation because the →-introducing
rules move formulas from one side of ⇒to the other one, which aﬀects the set
of variables common between the antecedent(s) and the consequent(s) in un-
predictable ways. Instead, we must supply a hypersequent with an extra layer of
structure, splitting all formulas, antecedent and consequent alike, into left formu-
las, i.e., eventually contributing to A, and right formulas, eventually contributing
to B in the endsequent A ⇒B:
Deﬁnition 4.1 (Split hypersequents). A split hypersequent ̃G is a hypersequent
where each antecedent and each consequent is partitioned into two multisets by a
semicolon:
Γ1; Π1 ⇒∆1; Σ1 | . . . | Γn; Πn ⇒∆n; Σn
(the semicolon can be omitted if an antecedent or a consequent is empty, i.e., we
write Γ; Π ⇒instead of Γ; Π ⇒; ). For the split hypersequent ̃G above, its left
(right) sides are obtained by dropping all right (left) formulas:
L̃G := Γ1 ⇒∆1 | . . . | Γn ⇒∆n,
R̃G := Π1 ⇒Σ1 | . . . | Πn ⇒Σn.
As before, the length of a split hypersequent is the number of its components, i.e.,
for the split hypersequent above ‖̃G‖ := n. It is obvious that ‖̃G‖ = ‖L̃G‖ = ‖R̃G‖.
Given that we plan to ﬁnd interpolants between the left and right formulas of a
given split hypersequent, we need to split all the rules of the calculus HS5.
Deﬁnition 4.2 (Split hypersequent calculus SHS5). The calculus SHS5 is pre-
sented in Figures 2 and 3.

Craig Interpolation via Hypersequents
|
199
̃G
EW −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ | Γ; Π ⇒∆; Σ
EC −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ | Λ; Φ ⇒Θ; Ψ | ̃H
Ex −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Λ; Φ ⇒Θ; Ψ | Γ; Π ⇒∆; Σ | ̃H
̃G | Γ, A; Π ⇒∆; Σ
◻l ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ, ◻A; Π ⇒∆; Σ
̃G | ◻Γ; ◻Π ⇒A;
⇒◻l −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Γ; ◻Π ⇒◻A;
̃G | Γ; Π, A ⇒∆; Σ
◻r ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π, ◻A ⇒∆; Σ
̃G | ◻Γ; ◻Π ⇒; A
⇒◻r −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Γ; ◻Π ⇒; ◻A
̃G | ◻Λ, Γ; ◻Θ, Π ⇒◻Φ, ∆; ◻Ψ, Σ
MS −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Λ; ◻Θ ⇒◻Φ; ◻Ψ | Γ; Π ⇒∆; Σ
Fig. 2. Cut-free split hypersequent system SHS5 for the modal logic S5:
modal and external structural rules.
It is easy to see that the split system is nothing but the split of the original system:
Theorem 4.3 (Equivalence of HS5 and SHS5). For arbitrary ﬁnite multisets Γ, Π,
∆, and Σ of modal formulas,
SHS5 ⊢Γ; Π ⇒∆; Σ
⇐⇒
HS5 ⊢Γ ∪Π ⇒∆∪Σ.
Proof: Both directions are proved by induction on the depth of the derivation. The
crucial observation is that each split rule of SHS5 becomes an ordinary rule of HS5
if one takes the union of left and right formulas separately in each antecedent and
each consequent. Vice versa, for each split of the conclusion of any rule of HS5,
there is a split of the premise(s) that turns this rule into a rule of SHS5.
Corollary 4.4. For arbitrary modal formulas A and B,
SHS5 ⊢A; ⇒; B
⇐⇒
S5 ⊢A →B.

200
|
R. Kuznets
idll −−−−−−−−−−−−−−−−−−−−−−−−−−
A; ⇒A;
idrl −−−−−−−−−−−−−−−−−−−−−−−−−−−−
; A ⇒A;
idlr −−−−−−−−−−−−−−−−−−−−−−−−−−
A; ⇒; A
idrr −−−−−−−−−−−−−−−−−−−−−−−−−−−−
; A ⇒; A
idl
⊥−−−−−−−−−−−−−−−−−
⊥; ⇒
idr
⊥−−−−−−−−−−−−−−−−−−−
; ⊥⇒
̃G | Γ, A; Π ⇒∆, B; Σ
⇒→l −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆, A →B; Σ
̃G | Γ; Π, A ⇒∆; Σ, B
⇒→r −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ, A →B
̃G | Γ; Π ⇒∆, A; Σ
̃G | Γ, B; Π ⇒∆; Σ
→l ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ, A →B; Π ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ, A
̃G | Γ; Π, B ⇒∆; Σ
→r ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π, A →B ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ
Wl ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ, A; Π ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ
⇒Wl −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆, A; Σ
̃G | Γ; Π ⇒∆; Σ
Wr ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π, A ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ
⇒Wr −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ, A
̃G | Γ, A, A; Π ⇒∆; Σ
Cl ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ, A; Π ⇒∆; Σ
̃G | Γ; Π ⇒∆, A, A; Σ
⇒Cl −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆, A; Σ
̃G | Γ; Π, A, A ⇒∆; Σ
Cr ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π, A ⇒∆; Σ
̃G | Γ; Π ⇒∆; Σ, A, A
⇒Cr −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ, A
Fig. 3. Cut-free split hypersequent system SHS5 for the modal logic S5:
propositional and internal structural rules

Craig Interpolation via Hypersequents
|
201
Proof: The statement follows from Corollary 3.5 and Theorem 4.3.
Remark 4.5. The same reasons that compelled us to split each component of a hy-
persequent explain why the cut rule cannot be processed by a constructive proof
of the CIP based on the induction on a sequent-like derivation. The cut rule vio-
lates the subformula property by removing a formula completely from each of the
two premises. This removal can shrink the set of common variables in unpredictable
ways, thus, rendering the interpolants from the induction hypothesis suddenly un-
usable.
Splitting a hypersequent is no diﬀerent from splitting a sequent and is standard
for constructive proofs of the CIP. Thus, by itself, it does not yet help to extend the
method to hypersequents. The crucial idea behind our method of proving the CIP
is that interpolation should be done on the component level, i.e., instead of having
a formula interpolant for the whole hypersequent, responsible, in particular, for
encoding the hypersequent structure and its transformations, we allow each se-
quent component to have its own formula interpolant and combine these compo-
nentwise interpolants by explicit operations creating structures that parallel the
structure of the hypersequent being interpolated. This view of interpolation sig-
niﬁes a departure from the very deﬁnition of interpolation. Thus, we must both
present the intuition behind our view and demonstrate that the two deﬁnitions
coincide for the ﬁnal result of our interpolation procedure (but not during the
intermediate stages, where our interpolation statements cannot be translated to
the standard ones). To this end, we present an alternative semantics for hyperse-
quents that provides the intuition for the structure of our interpolants.
Deﬁnition 4.6 (Connected worlds). Let M = (W, ∼, V) be a Kripke model. A se-
quence of worlds
⃗w = w1, . . . , wn from W is called M-connected if w1 ∼wi for
each 2 ≤i ≤n. It immediately follows that wi ∼wj for all 1 ≤i ≤j ≤n.
Deﬁnition 4.7 (Componentwise semantics). Let M = (W, ∼, V) be a Kripke model.
A sequent Γ ⇒∆holding at a world w ∈W of M is deﬁned as follows:
M, w ⊨Γ ⇒∆
⇐⇒
M, w ⊮A for some A ∈Γ
or
M, w ⊩B for some B ∈∆.
Let G be a hypersequent Γ1 ⇒∆1 | . . . | Γn ⇒∆n and
⃗w = w1, . . . , wn be a
sequence of length ‖G‖ of worlds from W. The hypersequent G holding on the se-
quence
⃗w in M is deﬁned as follows:
M, ⃗w ⊨Γ1 ⇒∆1 | . . . | Γn ⇒∆n
⇐⇒
M, wi ⊨Γi ⇒∆i for some 1 ≤i ≤n.
(In particular, we deﬁne M, ε ⊭ε, i.e., the empty hypersequent does not hold on the
empty sequence of worlds.)

202
|
R. Kuznets
Deﬁnition 4.8 (Componentwise validity). A hypersequent G is componentwise
valid if M, ⃗w ⊨G for any Kripke model M and any M-connected sequence
⃗w of
length ‖G‖.
Lemma 4.9 (Equivalence of two semantics). A hypersequent G is componentwise
valid iff its formula interpretation is valid in all Kripke models.
Proof: Let G be a hypersequent Γ1 ⇒∆1 | . . . | Γn ⇒∆n. We prove that it is com-
ponentwise invalid iff its formula interpretation is invalid. Our ﬁrst observation is
that for any component Γ ⇒∆, any Kripke model M = (W, ∼, V), and any world
w ∈W, we have
M, w ⊭Γ ⇒∆
⇐⇒
M, w ⊮⋀Γ →⋁∆.
(1)
In the following sequence of statements, each statement is equivalent to the pre-
vious one.
1.
G is invalid;
2.
there is a Kripke model M = (W, ∼, V) and there is a world v ∈W such that
M, v ⊮
n
⋁
i=1
◻(⋀Γi →⋁∆i);
(by deﬁnitions of G and of validity for formulas)
3.
there exists a Kripke model M = (W, ∼, V), a world v ∈W, and worlds
w1, . . . , wn ∈W such that v ∼wi and M, wi ⊮⋀Γi →⋁∆i for each
i = 1, . . . , n;
(by deﬁnition of ⊩)
4.
there exists a Kripke model M = (W, ∼, V) and an M-connected sequence
⃗w = w1, . . . , wn such that M, wi ⊮⋀Γi →⋁∆i for each i = 1, . . . , n;
(v can be set to w1 because ∼is an equivalence relation)
5.
there exists a Kripke model M = (W, ∼, V) and an M-connected sequence
⃗w = w1, . . . , wn such that M, wi ⊭Γi ⇒∆i for each i = 1, . . . , n;
(by (1))
6.
there exists a Kripke model M = (W, ∼, V) and an M-connected sequence
⃗w
of length n such that M, ⃗w ⊭G;
(by deﬁnition of ⊨)
7.
G is componentwise invalid.
(by deﬁnition of componentwise validity)
Having transferred validity to the level of sequent components, we now deﬁne the
objects that will serve as interpolants.
Deﬁnition 4.10 (Hyperformulas and g-hyperformulas). An hyperformula is a se-
quence of modal formulas, written in the hypersequent notation: C1 | . . . | Cn.
By analogy with sequence of worlds, we use vector notation
⃗C for hyperformulas
and deﬁne the length of a hyperformula to be the number of formulas in it, i.e.,
儩儩儩儩C1 | . . . | Cn儩儩儩儩:= n.

Craig Interpolation via Hypersequents
|
203
Each hyperformula is a generalized hyperformula of the same length. If
℧1 and ℧2 are generalized hyperformulas of length n each, then (℧1 6 ℧2) and
(℧1 7 ℧2) are also generalized hyperformulas of length n. For brevity’s sake, we
sometimes call generalized hyperformulas simply g-hyperformulas.
Deﬁnition 4.11 (Componentwise semantics for (g-)hyperformulas). Let
a
triple
M = (W, ∼, V) be a Kripke model. Let
⃗C = C1 | . . . | Cn be a hyperformula and
⃗w = w1, . . . , wn be a sequence of length ‖ ⃗C‖ of worlds from W. We deﬁne
M, ⃗w ⊨C1 | . . . | Cn
iff
M, wi ⊨Ci for some 1 ≤i ≤n.
For arbitrary g-hyperformulas ℧1 and ℧2 and arbitrary sequence
⃗w of worlds
from W such that ‖℧1‖ = ‖℧2‖ = ‖ ⃗w‖, we deﬁne
M, ⃗w ⊨℧1 7 ℧2
iff
M, ⃗w ⊨℧1 and M, ⃗w ⊨℧2;
M, ⃗w ⊨℧1 6 ℧2
iff
M, ⃗w ⊨℧1 or M, ⃗w ⊨℧2.
Thus, with respect to the componentwise semantics, 7 and 6 on hyperformulas cor-
respond to ∧and ∨on formulas respectively.
Two g-hyperformulas ℧1 and ℧2 are called componentwise equivalent, written
℧1 ⫤⊨℧2, iff ‖℧1‖ = ‖℧2‖ and, for any Kripke model M and any M-connected
sequence
⃗w of length ‖℧1‖, we have
M, ⃗w ⊨℧1
⇐⇒
M, ⃗w ⊨℧2.
Deﬁnition 4.12 (Componentwise interpolant). A componentwise interpolant of a
split hypersequent ̃G is a g-hyperformula ℧such that ‖℧‖ = ‖̃G‖ and for each Kripke
model M and each M-connected sequence
⃗w with ‖ ⃗w‖ = ‖℧‖,
–
if M, ⃗w ⊭℧, then M, ⃗w ⊨L̃G;
–
if M, ⃗w ⊨℧, then M, ⃗w ⊨R̃G;
–
℧contains only propositional variables common to L̃G and R̃G.
If ℧is a componentwise interpolant of ̃G, we write ̃G ←㨀℧.
Lemma 4.13 (Translation from componentwise to formula interpolants). If a g-
hyperformula C1 7 ⋅⋅⋅7 Cm of length 1 is a componentwise interpolant of a split
hypersequent A; ⇒; B, then the formula C1 ∧⋅⋅⋅∧Cm is an interpolant of the
formulas A and B.
Proof: Indeed, L(A; ⇒; B) is A ⇒and R(A; ⇒; B) is ⇒B. Thus, the formu-
las Cj contain only propositional variables common to A and B.

204
|
R. Kuznets
Let M = (W, ∼, V) be a Kripke model and w ∈W be a world in it. We have
M, w ⊮
m
⋀
i=1
Ci
㨐⇒
M, w ⊭
m7
i=1
Ci
㨐⇒
M, w ⊨A ⇒
㨐⇒
M, w ⊮A,
M, w ⊩
m
⋀
i=1
Ci
㨐⇒
M, w ⊨
m7
i=1
Ci
㨐⇒
M, w ⊨⇒B
㨐⇒
M, w ⊩B.
Hence, by the completeness of S5, we have
S5 ⊢A →C1 ∧⋅⋅⋅∧Cm
and
S5 ⊢C1 ∧⋅⋅⋅∧Cm →B.
Lemma 4.14 (External disjunction elimination).
1.
For arbitrary modal formulas A1, . . . , An, B1, . . . , Bn,
(A1 | . . . | An) 6 (B1 | . . . | Bn) ⫤⊨A1 ∨B1 | . . . | An ∨Bn.
2.
Any g-hyperformula can be transformed to a componentwise equivalent exter-
nal conjunction of hyperformulas without changing the set of propositional vari-
ables occurring in it.
In principle, any g-hyperformula of length 1 can be translated into a formula in
this way, but translating 7 is suﬃcient because with respect to the componen-
twise semantics the external conjunction and disjunction 7 and 6 behave like
∧and ∨with respect to Boolean semantics. In particular, any g-hyperformula can
be transformed to a componentwise equivalent DNF or CNF using the standard
algorithm. The simple proof of the following lemma is left to the reader.
Lemma 4.15 (External disjunction elimination).
1.
For arbitrary modal formulas A1, . . . , An, B1, . . . , Bn,
(A1 | . . . | An) 6 (B1 | . . . | Bn) ⫤⊨A1 ∨B1 | . . . | An ∨Bn.
2.
Any g-hyperformula can be transformed to a componentwise equivalent exter-
nal conjunction of hyperformulas without changing the set of propositional vari-
ables occurring in it.
5 The Interpolation Algorithm
We divide our description of the algorithm for constructing interpolants into three
parts. First, we present the propositional and structural rules in Figures 4 and 5
respectively and prove correctness for the most interesting cases. The modal rules
(presented later in Figure 6) require additional auxiliary lemmas.

Craig Interpolation via Hypersequents
|
205
idll −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
A; ⇒A; ←㨀⊥
idrl −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
; A ⇒A; ←㨀¬A
idlr −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
A; ⇒; A ←㨀A
idrr −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
; A ⇒; A ←㨀⊤
idl
⊥−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
⊥; ⇒←㨀⊥
idr
⊥−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
; ⊥⇒←㨀⊤
̃G | Γ; Π ⇒∆, A; Σ ←㨀℧1
̃G | Γ, B; Π ⇒∆; Σ ←㨀℧2
→l ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ, A →B; Π ⇒∆; Σ ←㨀℧1 6 ℧2
̃G | Γ; Π ⇒∆; Σ, A ←㨀℧1
̃G | Γ; Π, B ⇒∆; Σ ←㨀℧2
→r ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π, A →B ⇒∆; Σ ←㨀℧1 7 ℧2
For rules →l ⇒and →r ⇒, it is required that ‖℧1‖ = ‖℧2‖ = ‖̃G‖ + 1.
Fig. 4. Interpolation algorithm: Propositional rules. For the propositional rules not depicted
above, the given interpolant for the premise is to be used as an interpolant for the conclusion.
Remark 5.1. Note that the empty (split) hypersequent can never occur in a deriva-
tion in HS5 (or in SHS5), thus, we need not care how to properly deﬁne transforma-
tions to CNF and DNF for g-hyperformulas of length 0.
Lemma 5.2 (Algorithm correctness I: propositional and structural rules). All the
rules depicted in Figure 4 produce a componentwise interpolant for the conclu-
sion of the rule whenever componentwise interpolants (transformed to a proper
form) are given for all the premises. Further, any componentwise interpolant of
the premise of a propositional or structural rule not depicted in Figure 4 is also a
componentwise interpolant for the conclusion of the same rule.
Proof: We consider several representative cases, leaving the rest to the reader.
Throughout the proof we assume M = (W, ∼, V) to be an arbitrary Kripke model,
w ∈W to be an arbitrary world from it, and
⃗w to be an arbitrary M-connected se-
quence of worlds of appropriate length. We also omit the model from the ⊩state-

206
|
R. Kuznets
ments about formulas and from ⊨statements about hyperformulas and hyperse-
quents.
Rule idrl −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
; A ⇒A; ←㨀¬A
. It is clear that all propositional variables in ¬A are
common between
⇒A and A ⇒. We need to consider arbitrary M-
connected sequences of length 1, i.e., arbitrary worlds. We have
w ⊭¬A
㨐⇒
w ⊮¬A
㨐⇒
w ⊨⇒A
㨐⇒
w ⊨L( ; A ⇒A; ),
w ⊨¬A
㨐⇒
w ⊩¬A
㨐⇒
w ⊨A ⇒
㨐⇒
w ⊨R( ; A ⇒A; ).
Rules not depicted in Figure 4. They all work in the same way. It is suﬃcient to
note that, for all of them, if one side, left or right, of the premise hyperse-
quent holds on
⃗w then the same side of the conclusion hypersequent also
holds on
⃗w (and, of course, to verify the common-variable condition).
Rule
̃G | Γ; Π ⇒∆, A; Σ ←㨀℧1
̃G | Γ, B; Π ⇒∆; Σ ←㨀℧2
→l ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ, A →B; Π ⇒∆; Σ ←㨀℧1 6 ℧2
.
Assume that ℧1 and ℧2 are interpolants of the premises, in particular, ‖℧1‖ =
‖℧2‖ = ‖̃G‖ + 1, making ℧1 6 ℧2 well deﬁned. It is easy to see that the com-
mon-variable condition for the conclusion is fulﬁlled. Let
⃗w =
⃗v, u. For the
left side,
⃗w ⊭℧1 6 ℧2
㨐⇒
⃗w ⊭℧1
and
⃗w ⊭℧2
㨐⇒
⃗w ⊨L̃G | Γ ⇒∆, A
and
⃗w ⊨L̃G | Γ, B ⇒∆
㨐⇒
( ⃗v ⊨L̃G
or
u ⊨Γ ⇒∆
or
u ⊩A) and
( ⃗v ⊨L̃G
or
u ⊨Γ ⇒∆
or
u ⊮B)
㨐⇒
( ⃗v ⊨L̃G
or
u ⊨Γ ⇒∆
or
u ⊮A →B)
㨐⇒
⃗w ⊨L̃G | Γ, A →B ⇒∆.
The argument for the right side is even simpler. If
⃗w ⊨℧1 6 ℧2, then at
least one of ℧1 and ℧2 holds on ⃗w making the right side of the corresponding
premise hypersequent true on
⃗w. But the right side of the conclusion hyper-
sequent is the same as that of both premise hypersequents.
Rule
̃G | Γ; Π ⇒∆; Σ | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | Aj | Bj)
EC −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | Aj ∨Bj)
.
Recall that it was this rule that was identiﬁed as the main obstacle to using
hypersequents for proving the CIP in [Avron, 1996]. Once again, the common-

Craig Interpolation via Hypersequents
|
207
variable condition presents no diﬃculties. Let
⃗w =
⃗v, u be a sequence of
length ‖̃G‖ + 1. The crucial observations for this case are that
⃗v, u ⊨
⃗Cj | Aj ∨Bj
⇐⇒
⃗v, u, u ⊨
⃗Cj | Aj | Bj
for each j = 1, . . . , m and that
⃗v, u, u ⊨S(̃G | Γ; Π ⇒∆; Σ | Γ; Π ⇒∆; Σ)
㨐⇒
⃗v, u ⊨S(̃G | Γ; Π ⇒∆; Σ)
for S being either L or R.
̃G ←㨀
m7
j=1
⃗Cj
EW −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | ⊥)
̃G | Γ; Π ⇒∆; Σ | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | Aj | Bj)
EC −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | Aj ∨Bj)
̃G | Γ; Π ⇒∆; Σ | Λ; Φ ⇒Θ; Ψ | ̃H ←㨀
m7
j=1
( ⃗Cj | Aj | Bj |
⃗Dj)
Ex −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | Λ; Φ ⇒Θ; Ψ | Γ; Π ⇒∆; Σ | ̃H ←㨀
m7
j=1
( ⃗Cj | Bj | Aj |
⃗Dj)
In order to apply the rules EW, EC, and Ex, the interpolant of the premise must be ﬁrst transformed
to an external conjunction of hyperformulas by Lemma 4.15. In addition, it is required that
‖̃G‖ = ‖ ⃗Cj‖ and ‖̃H‖ = ‖ ⃗Dj‖ for each j = 1, . . . , m.
Fig. 5. Interpolation algorithm: Structural rules. For the structural rules not depicted above, the
given interpolant for the only premise is to be used as an interpolant for the conclusion.
Restricting some interpolants to be external conjunctions of hyperformulas in Fi-
gure 4 is for convenience more than out of necessity. The same structural trans-
formations applied to arbitrary g-hyperformulas would have worked equally well,

208
|
R. Kuznets
but would have been more cumbersome to describe. The modal rules, in contrast,
require logical transformations that aﬀect the structure of the interpolant, making
it necessary to impose an even more restrictive interpolant format to process the
⇒◻l rule. Our immediate goal is to show that this special format can always be
achieved. We formulate this as a lemma but leave its simple proof to the reader.
Lemma 5.3 (Separation of a g-hyperformula component). Let ⊥n be an abbrevia-
tion for ⊥| . . . | ⊥
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
n
.
1.
For any hyperformula ⃗C of length n and any formula A,
⃗C | A
⫤⊨
(⊥n | A) 6 ( ⃗C | ⊥).
2.
For arbitrary formulas A1, . . . , Am with m ≥2 and any n ≥0,
m7
j=1
(⊥n | Aj)
⫤⊨
⊥n |
m
⋀
j=1
Aj.
3.
For any hyperformula ⃗C of length n,
⃗C | ⊥
⫤⊨
(⊥n | ⊤) 7 ( ⃗C | ⊥).
4.
For any g-hyperformula ℧of length n + 1, there is a componentwise equivalent
g-hyperformula of the form
m6
j=1
((⊥n | Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥))
with the same set of propositional variables.
Finally, before getting our hands dirty with the modal rules, we formulate auxil-
iary statements that will make the main arguments more transparent by separat-
ing tedious technical details to stand-alone lemmas.
Lemma 5.4 (Boxed formulas invariant within a connected component). Let M =
(W, ∼, V) be an arbitrary Kripke model and u and z be worlds from W.
u ∼z
㨐⇒
(u ⊩◻G
⇐⇒
z ⊩◻G).
(2)
Proof: By a standard semantic argument.
Lemma 5.5 (Hypersequent necessitation in one component). Let M = (W, ∼, V)
be an arbitrary Kripke model. For any hypersequent H, any ﬁnite multiset Ξ of
modal formulas, any modal formula F, any sequence ⃗v of worlds from W, and any
world u ∈W such that ‖H‖ = ‖ ⃗v‖, we have

Craig Interpolation via Hypersequents
|
209
1.
M, ⃗v, u耠⊨H | ◻Ξ ⇒
for some u耠∼u
㨐⇒
M, ⃗v, u ⊨H | ◻Ξ ⇒;
2.
M, ⃗v, u耠⊨H | ◻Ξ ⇒F
for all u耠∼u
㨐⇒
M, ⃗v, u ⊨H | ◻Ξ ⇒◻F.
Proof: We distinguish three possibilities:
1.
M, ⃗v ⊨H. It follows that M, ⃗v, u ⊨H | ◻Ξ ⇒and M, ⃗v, u ⊨H | ◻Ξ ⇒◻F.
2.
M, u耠⊮◻G for some G ∈Ξ and some u耠∼u. By Lemma 5.4, M, u ⊮◻G. It
follows immediately that M, ⃗v, u ⊨H | ◻Ξ ⇒and M, ⃗v, u ⊨H | ◻Ξ ⇒◻F.
3.
If M, ⃗v ⊭H and M, u耠⊩◻G for all G ∈Ξ and all u耠∼u, then assumption
of part 1 of the lemma is not satisﬁed. However, whenever the assumption of
part 2 is satisﬁed, we have M, u耠⊩F for all u耠∼u. Thus, M, u ⊩◻F and
M, ⃗v, u ⊨H | ◻Ξ ⇒◻F.
Lemma 5.6 (Algorithm correctness II: modal rules). All the rules depicted in Fi-
gure 6 produce a componentwise interpolant for the conclusion of the rule whenever
componentwise interpolants (in a proper form) are given for the premise. Further,
any componentwise interpolant of the premise of a modal rule not depicted in
Figure 6 is also a componentwise interpolant for the conclusion of the same rule.
Proof: We omit the rule ◻r ⇒because it is very similar to the case of ◻l ⇒we
demonstrate. Throughout the proof we assume M = (W, ∼, V) to be an arbitrary
Kripke model, w to be an arbitrary world from W, and
⃗w to be an arbitrary con-
nected sequence of worlds from W of appropriate length. We also omit the model
from the ⊩statements about formulas and from ⊨statements about hyperformulas
and hypersequents. Finally, we omit the trivial proofs that the common-variables
condition is satisﬁed for all the rules.
Rule ◻l ⇒.
We need to show that any interpolant of the premise hypersequent is also
an interpolant of the conclusion hypersequent. The only change from the
premise to the conclusion is that A is replaced with ◻A in the antecedent.
Thus, it is suﬃcient to observe that, due to the reﬂexivity of ∼,
w ⊮A
㨐⇒
w ⊮◻A.
Rule
̃G | ◻Λ, Γ; ◻Θ, Π ⇒◻Φ, ∆; ◻Ψ, Σ ←㨀
m7
j=1
( ⃗Cj | Aj)
MS −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Λ; ◻Θ ⇒◻Φ; ◻Ψ | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | ⊥| Aj)
.
The key observations are (2) and that, for any sequence
⃗v of worlds of
length ‖̃G‖, for arbitrary worlds u and z, and for each j = 1, . . . , m,
⃗v, u ⊨
⃗Cj | Aj
⇐⇒
⃗v, z, u ⊨
⃗Cj | ⊥| Aj

210
|
R. Kuznets
The requirement for the sequence of worlds to be connected is used here for
the ﬁrst time to allow for the application of (2).
Rule
̃G | ◻Γ; ◻Π ⇒; A ←㨀
m7
j=1
( ⃗Cj | Bj)
⇒◻r −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Γ; ◻Π ⇒; ◻A ←㨀
m7
j=1
( ⃗Cj | ◻Bj)
.
Let
⃗w =
⃗v, u. For the left side, let us assume that
⃗w ⊭
m7
j=1
( ⃗Cj | ◻Bj). Then
there is 1 ≤J ≤m such that ⃗v ⊭
⃗CJ and u ⊮◻BJ. It follows that there exists
a world u耠∈W such that u ∼u耠and u耠⊮BJ. Thus, on the M-connected
sequence ⃗v, u耠, the given interpolant
m7
j=1
( ⃗Cj | Bj) of the premise hypersequent
does not hold, making the left side of the premise hypersequent true on the
same sequence: ⃗v, u耠⊨L̃G | ◻Γ ⇒. By Lemma 5.5.1, we have
⃗w ⊨L̃G | ◻Γ ⇒
for the left side of the conclusion hypersequent.
For the right side, assume that
⃗w ⊨
m7
j=1
( ⃗Cj | ◻Bj). Then for each 1 ≤j ≤m
either ⃗v ⊨
⃗Cj or u ⊩◻Bj. Since u ⊩◻Bj implies u耠⊩Bj for all u耠∼u, it
follows that ⃗v, u耠⊨
m7
j=1
( ⃗Cj | Bj) for all u耠∼u, making the right side of the
premise hypersequent true on all these sequences, which are M-connected:
⃗v, u耠⊨R̃G | ◻Π ⇒A for all u耠∼u. By Lemma 5.5.2,
⃗w ⊨R̃G | ◻Π ⇒◻A for
the right side of the conclusion hypersequent.
Rule
̃G | ◻Γ; ◻Π ⇒A; ←㨀
m6
j=1
((⊥n | Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥))
⇒◻l −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Γ; ◻Π ⇒◻A; ←㨀
m6
j=1
((⊥n | ⋄Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥))
.
Let us consider
⃗w = ⃗v, u. For the left side, assume that
⃗w ⊭
m6
j=1
((⊥n | ⋄Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥)) .
In other words, for each j = 1, . . . , m there exists 1 ≤Kj ≤lj such that
u ⊮⋄Bj
or
⃗v ⊮
⃗Cj,Kj.

Craig Interpolation via Hypersequents
|
211
It follows that for each u耠∼u and for each j = 1, . . . , m,
u耠⊮Bj
or
⃗v ⊮
⃗Cj,Kj.
In other words, for each u耠∼u,
⃗v, u耠⊭
m6
j=1
((⊥n | Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥)) ,
making the left side of the premise hypersequent true on all such sequences,
which are M-connected: for all u耠∼u, we have ⃗v, u耠⊨L̃G | ◻Γ ⇒A. By
Lemma 5.5.2, we have
⃗w ⊨L̃G | ◻Γ ⇒◻A, i.e., the left side of the conclusion
hypersequent holds on
⃗w.
For the right side, assume that
⃗w ⊨
m6
j=1
((⊥n | ⋄Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥)) .
In other words, for some 1 ≤J ≤m,
u ⊩⋄BJ
and
for all 1 ≤kJ ≤lJ
⃗v ⊩
⃗CJ,kJ .
It follows that, for some u耠∼u,
u耠⊩BJ
and
for all 1 ≤kJ ≤lJ
⃗v ⊩
⃗CJ,kJ .
In other words, for some u耠∼u,
⃗v, u耠⊨
m6
j=1
((⊥n | Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥)) ,
making the right side of the premise hypersequent true on the sequence ⃗v, u耠,
which is M-connected: we have
⃗v, u耠⊨R̃G | ◻Π ⇒
for this u耠. By Lemma 5.5.1, we have
⃗w ⊨L̃G | ◻Π ⇒
i.e., the right side of the conclusion hypersequent holds on
⃗w.
Putting all together, we conclude that
Theorem 5.7. S5 enjoys the CIP.

212
|
R. Kuznets
Proof: Let S5 ⊢A →B. By Corollary 4.4, we have SHS5 ⊢A; ⇒; B. By Lem-
mas 5.2 and 5.6, we can construct a componentwise interpolant ℧of A; ⇒; B.
By Lemma 4.15, this ℧can be eﬃciently transformed to another componentwise
interpolant ℧耠, which is an external conjunction of hyperformulas of length 1.
By Lemma 4.13, this ℧耠can be eﬃciently transformed to a formula interpolant C
of A and B.
̃G | ◻Γ; ◻Π ⇒A; ←㨀
m6
j=1
((⊥n | Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥))
⇒◻l −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Γ; ◻Π ⇒◻A; ←㨀
m6
j=1
((⊥n | ⋄Bj) 7
lj7
kj=1
( ⃗Cj,kj | ⊥))
̃G | ◻Γ; ◻Π ⇒; A ←㨀
m7
j=1
( ⃗Cj | Bj)
⇒◻r −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Γ; ◻Π ⇒; ◻A ←㨀
m7
j=1
( ⃗Cj | ◻Bj)
̃G | ◻Λ, Γ; ◻Θ, Π ⇒◻Φ, ∆; ◻Ψ, Σ ←㨀
m7
j=1
( ⃗Cj | Aj)
MS −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
̃G | ◻Λ; ◻Θ ⇒◻Φ; ◻Ψ | Γ; Π ⇒∆; Σ ←㨀
m7
j=1
( ⃗Cj | ⊥| Aj)
For ⇒◻r and MS, the interpolant of the premise must be transformed to an external conjunction
of hyperformulas. The rule ⇒◻l requires a more elaborate form guaranteed by Lemma 5.3. It is
required that
‖̃G‖ = ‖ ⃗Cj‖ for each j = 1, . . . , m,
(MS)
and that
‖̃G‖ = ‖ ⃗Cj,kj‖ = n for each j = 1, . . . , m and kj = 1, . . . , lj,
(⇒◻l)
where ⊥n = ⊥| . . . | ⊥
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
n
.
Fig. 6. Interpolation algorithm: Modal rules. For the modal rules ◻l ⇒and ◻r ⇒not depicted
above, the given interpolant for the premise is to be used as an interpolant for the conclusion.

Craig Interpolation via Hypersequents
|
213
Example 5.8. To illustrate our method, we apply it to a properly adapted sample
derivation from [Avron, 1996] in Figure 7. The rules for handling ¬ are easily deriv-
able from those we presented for →. Note that the interpolant P∨◻⊥of P and ◻¬◻¬P
constructed by the algorithm contains redundancies: the formula P alone could
serve as an interpolant.
idlr −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒; P ←㨀P
¬r ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ¬P ⇒←㨀P
◻r ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ◻¬ P ⇒←㨀P
MS −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
; ◻¬ P ⇒| P; ⇒←㨀⊥| P
Ex −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒| ; ◻¬ P ⇒←㨀P | ⊥
⇒¬r −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒| ⇒; ¬◻¬ P ←㨀P | ⊥
⇒◻r −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒| ⇒; ◻¬ ◻¬ P ←㨀P | ◻⊥
Ex −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
⇒; ◻¬ ◻¬ P | P; ⇒←㨀◻⊥| P
⇒Wr −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
⇒; ◻¬ ◻¬ P | P; ⇒; ◻¬ ◻¬ P ←㨀◻⊥| P
Ex −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒; ◻¬ ◻¬ P | ⇒; ◻¬ ◻¬ P ←㨀P | ◻⊥
Wl ⇒−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒; ◻¬ ◻¬ P | P; ⇒; ◻¬ ◻¬ P ←㨀P | ◻⊥
EC −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
P; ⇒; ◻¬ ◻¬ P ←㨀P ∨◻⊥
Fig. 7. Application of our algorithm to the derivation of P ⇒◻¬ ◻¬ P from [Avron, 1996].
6 Conclusion and Future Work
To the best of our knowledge, we have presented the ﬁrst method of proving inter-
polation constructively by induction on a hypersequent derivation. The method
was developed for the classical modal logic S5. We plan to extend this method to
–
various other classical hypersequent systems,
–
grafted sequent calculi, recently developed in [Kuznets and Lellmann, 2016],
which combine hypersequent and nested sequent calculi,
–
non-classical hypersequent systems, especially ones for intermediate logics.
Acknowledgment: This work is funded by the Austrian Science Fund (FWF) grant
M 1770-N25.

214
|
R. Kuznets
References
Arnon Avron. A constructive analysis of RM. Journal of Symbolic Logic, 52(4):939–951, Decem-
ber 1987. 10.2307/2273828.
Arnon Avron. The method of hypersequents in the proof theory of propositional non-classical
logics. In Wilfrid Hodges, Martin Hyland, Charles Steinhorn, and John Truss, editors,
Logic: From Foundations to Applications: European Logic Colloquium, pages 1–32. Claren-
don Press, 1996.
Ronald Fagin, Joseph Y. Halpern, Yoram Moses, and Moshe Y. Vardi. Reasoning about Knowl-
edge. MIT Press, 1995.
Melvin Fitting and Roman Kuznets. Modal interpolation via nested sequents. Annals of Pure
and Applied Logic, 166(3):274–305, March 2015. 10.1016/j.apal.2014.11.002.
Dov M. Gabbay and Larisa Maksimova. Interpolation and Deﬁnability: Modal and Intuitionistic
Logic, volume 46 of Oxford Logic Guides. Clarendon Press, 2005.
Roman Kuznets and Björn Lellmann. Grafting hypersequents onto nested sequents. Logic
Journal of the IGPL, In Press, 2016. 10.1093/jigpal/jzw005.
Björn Lellmann and Dirk Pattinson. Correspondence between modal Hilbert axioms and
sequent rules with an application to S5. In Didier Galmiche and Dominique Larchey-
Wendling, editors, Automated Reasoning with Analytic Tableaux and Related Meth-
ods, 22nd International Conference, TABLEAUX 2013, Nancy, France, September 16–19,
2013, Proceedings, volume 8123 of Lecture Notes in Computer Science, pages 219–233.
Springer, 2013. 10.1007/978-3-642-40537-2_19.
G. E. Minc. On some calculi of modal logic. In V. P. Orevkov, editor, The Calculi of Symbolic
Logic. I, volume 98 of Proceedings of the Steklov Institute of Mathematics, pages 97–124.
AMS, 1971. Originally published in Russian in 1968.
Garrel Pottinger. Uniform, cut-free formulations of T, S4, and S5. Journal of Symbolic Logic, 48
(3):900, September 1983. 10.2307/2273495. Abstract.

Seraﬁna Lapenta and Ioana Leuştean
A General View on Normal Form Theorems
for Łukasiewicz Logic with Product
Abstract: In this survey paper we explore the connection between the Pierce-
Birkhoﬀconjecture and Łukasiewicz logic with product. Conservative extensions
of Łukasiewicz logic can be deﬁned by adding an internal product or a mul-
tiplication with scalars from [0, 1]. The corresponding models reﬂect an alge-
braic hierarchy of lattice-ordered structures, from groups to algebras. We prove
a general version of the normal form theorem and we state a local version of the
Pierce-Birkhoﬀconjecture.
Keywords: Łukasiewicz logic, MV-algebras, Normal form theorem, Pierce-Birkhoﬀ
conjecture.
Mathematics Subject Classiﬁcation 2010: 06D35, 06F25, 03B50
1 Introduction
The modern evolution of Łukasiewicz logic, deﬁned in [Łukasiewicz and Tarski,
1930], is strongly connected with its algebraic counterpart: the theory of MV-
algebras. Introduced in [Chang, 1958], MV-algebras stand to Łukasiewicz proposi-
tional logic as boolean algebras stand to classical logic. We refer to [Cignoli et al.,
2000] for a comprehensive study of their general theory and to [Mundici, 2011]
for advanced topics. Łukasiewicz logic and MV-algebras are also studied in the
general context of t-norm based logics [Hájek, 1998].
MV-algebras are structures (A, ⊕,∗, 0) of type (2, 1, 0), satisfying some spe-
ciﬁc identities. The theory of MV-algebras was highlighted by Mundici’s categor-
ical equivalence between MV-algebras and Abelian lattice-ordered groups with
strong unit (ℓu-groups) [Mundici, 1986]. As a consequence, for any MV-algebra A
there exists a unique, up to isomorphism, ℓu-group (G, u) such that A is isomor-
phic with the unit interval [0, u] of G, endowed with an MV-algebra structure by
x∗= u −x and x ⊕y = (x + y) ∧u for any x, y ∈[0, u]. Note that the MV-algebraic
sum ⊕, which can be seen as a non-idempotent disjunction, is the group addition
Seraﬁna Lapenta: Department of Mathematics, University of Salerno, Via Giovanni Paolo II, 132
Fisciano (SA), Italy, e-mail: slapenta@unisa.it
Ioana Leuştean: Department of Computer Science, Faculty of Mathematics and Computer Sci-
ence, University of Bucharest, Academiei nr.14, sector 1, C.P. 010014, Bucharest, Romania,
e-mail: ioana@fmi.unibuc.ro

216
|
S. Lapenta and I. Leuştean
+ truncated to the unit interval. Further operations are deﬁned as follows: 1 is 0∗,
the Łukasiewicz implication is x →y = x∗⊕y = (u−x+y)∧u and the Łukasiewicz
conjunction is x ⊙y = (x∗⊕y∗)∗= (x + y −u) ∨0 for any x, y ∈[0, u]. The stan-
dard MV-algebra is the real unit interval [0, 1] equipped with the above deﬁned
operations. Chang’s completeness theorem states that an equation is satisﬁed in
all MV-algebras if and only if it is satisﬁed in the MV-algebra [0, 1].
Since the real interval [0, 1] is closed to the product operation, a natu-
ral problem was to ﬁnd a complete axiomatization for the variety generated
by ([0, 1], ⊕, ⋅,∗, 0), where ([0, 1], ⊕,∗, 0) is the standard MV-algebra and ⋅:
[0, 1] × [0, 1] →[0, 1] is the product of real numbers. Enriching the structure of
MV-algebras, the product was deﬁned as an internal operation for PMV-algebras
[Di Nola and Dvurečenskij, 2001] and as a scalar multiplication with scalars
from [0, 1] for Riesz MV-algebras [Di Nola and Leuştean, 2014]. In [Lapenta and
Leuştean, 2015] the authors deﬁned and studied MV-algebras with both internal
product and scalar multiplication under the name of fMV-algebras. The equiva-
lence between MV-algebras and ℓu-groups is generalized for each case, leading to
equivalences with particular classes of f-rings, Riesz spaces and f-algebras. More-
over, connections between these structures are proved in [Lapenta and Leuştean,
2016] using the MV-algebraic tensor product deﬁned in [Mundici, 1999].
The logical systems developed for PMV-algebras [Horčík and Cintula, 2004]
and Riesz MV-algebras [Di Nola and Leuştean, 2014] are conservative extensions
of Łukasiewicz logic. One of the main theorems of Łukasiewicz logic states that,
for n ≥1, the term functions with n variables are exactly the continuous [0, 1]-
valued piecewise linear functions with integer coeﬃcients deﬁned on [0, 1]n [Mc-
Naughton, 1951]. This can be seen as a normal form theorem for Łukasiewicz logic.
A similar result was proved in [Di Nola and Leuştean, 2014] for the logical sys-
tem that has Riesz MV-algebras as models; in this case the piecewise linear func-
tions have real coeﬃcients. In [Montagna and Panti, 2001, Introduction] it is stated
that a similar result for PMV-algebras is related to the Pierce-Birkhoﬀconjecture
[Birkhoﬀand Pierce, 1956] and our aim was to make a deeper investigation of this
connection. Consequently, we characterized a subclass of fMV-algebras such that
the normal form theorem of the corresponding logical system is a local version of
the Pierce-Birkhoﬀconjecture [Lapenta and Leuştean, 2015].
We overview four equational theories, whose underlying models are MV-
algebras, Riesz MV-algebras, PMV-algebras and fMV-algebras. At the core of our
presentation lies Theorem 4.9, a general normal form result. The already known
normal form theorems for MV-algebras, Riesz MV-algebras and fMV-algebras are
straightforward consequences, as well as the normal form theorem for PMV-
algebras, which is a new result. In the last section of our paper we emphasize the
relation with the Pierce-Birkhoﬀconjecture.

A General View on Normal Form Theorems for Łukasiewicz Logic with Product
|
217
2 The algebras of Łukasiewicz logic with product
In this section we present the structures of Łukasiewicz logic extended with a
product operation that can be either an internal binary one, or a scalar multipli-
cation with scalars from [0, 1].
An MV-algebra is a structure (A, ⊕,∗, 0) of type (2,1,0) which satisﬁes the fol-
lowing properties for any x, y ∈A:
(A, ⊕, 0) is an Abelian monoid,
(x∗)∗= x
(x∗⊕y)∗⊕y = (y∗⊕x)∗⊕x,
0∗⊕x = 0∗
We refer to [Cignoli et al., 2000] for all the unexplained notions related to MV-
algebras. In any MV-algebra A we can deﬁne the following: 1
def= 0∗, x ⊙y
def=
(x∗⊕y∗)∗, x ∨y
def=
(x ⊙y∗) ⊕y and x ∧y
def=
(x ⊕y∗) ⊙y for any x, y ∈A.
Hence (A, ∨, ∧, 0, 1) is a bounded distributive lattice such that x ≤y if and only if
x ⊙y∗= 0.
A Riesz MV-algebra [Di Nola and Leuştean, 2014] is a structure
(R, ⊕,∗, 0, {r | r ∈[0, 1]})
such that (R, ⊕,∗, 0) is an MV-algebra and {r | r ∈[0, 1]} is a family of unary
operation such that the following properties hold for any x, y ∈A and r, q ∈[0, 1]:
r(x ⊙y∗) = (rx) ⊙(ry)∗,
(r ⊙q∗) ⋅x = (rx) ⊙(qx)∗,
r(qx) = (rq)x,
1x = x.
A PMV-algebra¹ [Di Nola and Dvurečenskij, 2001, Montagna, 2000] is a structure
(P, ⊕, ∗, ⋅, 0) such that (P, ⊕, ∗, 0) is an MV-algebra, the operation ⋅: P × P →P is
associative and commutative, and the following identities hold for any x, y, z ∈P:
z ⋅(x ⊙y∗) = (z ⋅x) ⊙(z ⋅y)∗,
x ⋅1 = x.
An fMV-algebra² [Lapenta and Leuştean, 2015] is a structure
(A, ⊕, ⋅,∗, {r | r ∈[0, 1]}, 0)
1 We assume that PMV-algebras are commutative and unital, while the deﬁnition from [Di Nola
and Dvurečenskij, 2001] is more general.
2 As for PMV-algebras, we assume that fMV-algebras are commutative and unital, while the def-
inition from [Lapenta and Leuştean, 2015] is more general.

218
|
S. Lapenta and I. Leuştean
which satisﬁes the following properties:
(A, ⊕, ⋅,∗, 0) is a PMV-algebra,
(A, ⊕,∗, {r | r ∈[0, 1]}, 0) is a Riesz MV-algebra,
r(x ⋅y) = (rx) ⋅y = x ⋅(ry) for any x, y, z ∈A and α ∈[0, 1].
For x, y, r ∈[0, 1] we deﬁne x ⊕y = min{x + y, 1}, x∗= 1 −x, while x ⋅y = xy
and rx coincide with the product of real numbers. In consequence the real interval
[0, 1] naturally becomes an MV-algebra, a PMV-algebra, a Riesz MV-algebra and
an fMV-algebra. While [0, 1], endowed with the appropriate structure, generates
the variety of MV-algebras and Riesz MV-algebras, this is no longer true for PMV-
algebras and fMV-algebras. This issue will be further discussed in Section 5.
We mention in the sequel one of the most relevant results in the theory of
MV-algebras: its connection with the theory of Abelian lattice-ordered groups.
An ℓu-group is a pair (G, u), where G is an Abelian lattice-ordered group [Bi-
gard et al., 1977] and u is a strong unit. If (G, u) is an ℓu-group, then [0, u]G =
([0, u], ⊕,∗, 0) is an MV-algebra, where [0, u] = {x ∈G | 0 ≤x ≤u} and
x ⊕y = u ∧(x + y), x∗= u −x for any x ∈[0, u].
If MV is the category of MV-algebras with MV-algebra homomorphisms and
uAG is the category of ℓu-groups equipped with lattice-ordered group homomor-
phisms that preserve the strong unit, then one deﬁnes a functor Γ : uAG →MV
by Γ(G, u) = [0, u]G and Γ(h) = h|[0,u1]G1 , where (G, u) is an ℓu-group and h :
G1 →G2 is a morphism in uAG between (G1, u1) and (G2, u2). In [Mundici, 1986],
Mundici proved that the functor Γ establishes a categorical equivalence between
uAG and MV.
It is clear that all mentioned algebraic structures are deeply related to each
other. In particular, all of them have an MV-algebra reduct. Therefore we can de-
ﬁne forgetful functors from the categories PMV of PMV-algebras, RMV of Riesz MV-
algebras and fMV of fMV-algebras to MV. The categorical equivalence between
MV-algebras and ℓu-groups can be generalized for each of this structures to an
equivalence with an appropriate class of unital lattice-ordered structures having
a lattice-ordered group reduct with a strong unit [Di Nola and Dvurečenskij, 2001,
Di Nola and Leuştean, 2014, Lapenta and Leuştean, 2015]. Denoted by uR the cat-
egory of unital f-rings with strong unit, by uRS the category of Riesz spaces with
strong unit and by ufAlg the category of unital f-algebras with strong unit (fu-
algebras), we have the following commutative diagram,

A General View on Normal Form Theorems for Łukasiewicz Logic with Product
|
219
uAG
Γ
#
uRS
U
o
Γℝ
{
MV
RMV
U
o
PMV
U
O
fMV
U
o
U
O
uR
U
O
Γ(⋅)
<
ufAlg
Γ(⋅),ℝ
c
U
o
U
O
3 On the Pierce-Birkhoﬀconjecture
At the end of the paper [Birkhoﬀand Pierce, 1956], the authors asked for a char-
acterization of the “free, commutative, real ℓ-algebra (ℓ-group) with n generators”
and they conjectured that “it is isomorphic with the l-group of real functions which
are continuous and piecewise polynomial of degree at most n over a ﬁnite number of
pieces”. They asked “the same problem for the free (commutative) ℓ-rings, for free
f-rings”, saying that: “The former is probably very diﬃcult”.
Deﬁnition 3.1. Let n ≥1 be a natural number.
–
A function f : ℝn →ℝis a piecewise polynomial (PWP) function if it is contin-
uous and there is a ﬁnite set of polynomials {p1, . . . , pk} ⊆ℝ[x1, ⋅⋅⋅, xn] such
that for any (a1, . . . , an) ∈ℝn there exists i ∈{1, . . . , k} with f(a1, . . . , an) =
pi(a1, . . . , an).
–
A continuous function f : ℝn →ℝis a inf-sup-polynomial-deﬁnable (ISD)
function if there is a ﬁnite set of polynomials {qij|1 ≤i ≤m, 1 ≤j ≤k} ⊆
ℝ[x1, ⋅⋅⋅, xn] such that f = ⋁m
i=1 ⋀k
j=1 qij.
We denote by PWP(n) the set of all PWP-functions and by ISD(n) the set of all
ISD-functions deﬁned as above. Our notations are inspired by [Delzell, 1989].
The Pierce-Birkhoﬀconjecture states that
PWP(n) = ISD(n) for any n ≥2.
In this form, it was formulated by Henriksen and Isbell. The proof for n ≤2 is
made in [Mahé, 1984, 2007], where an unpublished proof of Gus Efroymson is
also quoted. In [Mahé, 2007] the author proves that any PWP-function has a rep-
resentation by inf and sup of polynomials in the whole ℝ3, except for the union of

220
|
S. Lapenta and I. Leuştean
arbitrary small balls, depending on the PWP-function. We refer to [Madden, 2011]
for a comprehensive survey on the subject.
Nowadays the conjecture is still inspiring. In [Lucas et al., 2015] the au-
thors say: “This paper represents a step in our program towards the proof of the
Pierce–Birkhoﬀconjecture.”
Remark 3.2. In Deﬁnition 3.1 one may consider piecewise linear functions instead of
piecewise polynomial functions. Such functions are called piecewise homogeneous
linear in [Beynon, 1974], where the following result is proved:
the vector lattice of all piecewise homogeneous linear functions f : ℝn →ℝ
coincides with the vector lattice of all functions f : ℝn →ℝwhich can be expressed
in the form ⋁m
i=1 ⋀k
j=1 qij, where qij : ℝn →ℝare linear functionals for any i, j.
4 Term functions and piecewise polynomial
functions
Let S be a subring of ℝ. Let L0 = {⊕,∗, 0} be the language of MV-algebras, i.e. ⊕is a
binary operation, ∗is unary and 0 is a constant. Let L1 = L0 ∪{⋅}, L0,S = L0 ∪{δr |
r ∈[0, 1]∩S}, L1,S = L0∪{⋅}∪{δr | r ∈[0, 1]∩S}, where ⋅is a binary operation and
δr is unary operation for any r ∈S∩[0, 1]. We assume that L ∈{L0, L1, L0,S, L1,S}
and that [0, 1] is an L-algebra as follows: x⊕y = min{x+y, 1}, x∗= 1−x, x⋅y = xy
is the product of real numbers and δrx = rx for any r ∈S, x, y ∈[0, 1].
For n ≥1 we deﬁne in the usual way the set Term(n, L) of L-terms in n vari-
ables (denoted by X1, ⋅⋅⋅, Xn). If t ∈Term(n, L) then ̃t : [0, 1]n →[0, 1] is the
term function determined by t, when [0, 1] is assumed to have the corresponding
L-structure. We further set
TF(n, L) = {̃t : [0, 1]n →[0, 1] | t ∈Term(n, L)}.
Our aim is to characterize the elements of TF(n, L), by means of piecewise poly-
nomial functions.
Remark 4.1. In order to express better our general results we introduce the notion
of L-polynomial function as follows:
–
an L0-polynomial function is an aﬃne linear function p : ℝn →ℝwith integer
coeﬃcients;
–
an L1-polynomial function is a polynomial function p : ℝn →ℝwith integer
coeﬃcients;
–
an L0,S-polynomial function is an aﬃne linear function p : ℝn →ℝwith
coeﬃcients from S;

A General View on Normal Form Theorems for Łukasiewicz Logic with Product
|
221
–
an L1,S-polynomial function is a polynomial function p : ℝn →ℝwith coeﬃ-
cients from S.
Notation 4.2. In the sequel, the map ϱ : ℝ→[0, 1] is deﬁned by ϱ(x) = x ∧1 ∨0,
for any x ∈ℝ.
Deﬁnition 4.3. Let n ≥1 be a natural number and let S be a subring of ℝ.
–
A continuous function f : [0, 1]n →[0, 1] is a unital piecewise polynomial
function with coeﬃcients from S if there exists a ﬁnite set of polynomials,
called components, {pi : ℝn →ℝ| 1 ≤i ≤k} ⊆S[x1, . . . , xn] such that
for any (a1, . . . , an) ∈ℝn there exists i ∈{1, . . . , k} with f(a1, . . . , an) =
pi(a1, . . . , an). We denote by PWP(n, L) the set of all such functions whose
components are L-polynomial functions.
–
A continuous function f : [0, 1]n →[0, 1] is a unital inf-sup-deﬁnable func-
tion with coeﬃcients from S if there exists a ﬁnite set of polynomials, called
components, {qij : ℝn →ℝ|1 ≤i ≤m, 1 ≤j ≤k} ⊆S[x1, . . . , xn] such
that f = ⋁m
i=1 ⋀k
j=1(ϱ ∘qij). We denote by ISD(n, L) the set of all such functions
whose components are L-polynomial functions.
The following result generalizes [McNaughton, 1951, Theorem 2], [Cignoli et al.,
2000, Proposition 3.1.8], [Di Nola and Leuştean, 2014, Theorem 10], [Lapenta and
Leuştean, 2015, Proposition 3.5]. We give the proof for the sake of completeness.
Proposition 4.4. TF(n, L) ⊆PWP(n, L).
Proof: Let t be a term in Term(n, L). The result will be proved by structural in-
duction on t.
–
If t = Xi for some i ≤n, then ̃t = πn
i and it trivially belongs to PWP(n, L).
–
If t = t∗
1, then ̃t = (̃t1)∗. By induction hypothesis there exists an integer h
and some polynomials q1, . . . , qh ∈S[x1, . . . , xn] such that for any point in
the n-cube, ̃t1 coincide with one of them. Then 1 −q1, . . . , 1 −qh are the
components of ̃t.
–
If t = t1 ⊕t2, let q1,. . ., qm be the components of ̃t1 and p1,. . .,pk be the
components of ̃t2. Then ̃t is deﬁned by the polynomials {1} ∪{sij}i,j, where
sij = 1 −qi + pj for any i ∈{1, . . . , s} and j ∈{1, . . . , r}.
–
If t is δr(t1) for some r ∈[0, 1] ∩S and q1,. . .,qs are the components of ̃t1,
then rq1,. . .,rqs are the components of ̃t.
–
If t = t1 ⋅t2, let q1,. . ., qm be the components of ̃t1 and p1,. . .,pk be the
components of ̃t2. Then ̃t is deﬁned by the polynomials qi ⋅pj, for any i ∈
{1, . . . , s} and j ∈{1, . . . , r}.

222
|
S. Lapenta and I. Leuştean
Lemma 4.5. [Di Nola and Leuştean, 2014, Lemma 9] For any x, y ∈ℝthe following
properties hold:
(a) (x ∨0) + (y ∨0) ≥(x + y) ∨0,
(b) x ≥0 iﬀϱ(−x) = 0,
(c) ϱ(x) = ϱ(x ∨0).
Lemma 4.6. [Di Nola and Leuştean, 2014, Lemma 10] If g : [0, 1]n →ℝand h :
[0, 1]n →[0, 1] then the following properties hold.
(a) ϱ ∘(g + h) = ((ϱ ∘g) ⊕h) ⊙(ϱ ∘(g + 1)).
(b) ϱ ∘(1 −g) = 1 −(ϱ ∘g).
The following result is a generalization of [McNaughton, 1951, Theorem 1], [Cignoli
et al., 2000, Lemma 3.1.9], [Di Nola and Leuştean, 2014, Proposition 6], [Lapenta
and Leuştean, 2015, Proposition 4.3]. In spite of the fact that the proof is very sim-
ilar to the one in [Lapenta and Leuştean, 2015], it covers at least one additional
relevant case: for L = L1, this result and Theorem 4.9 lead to a better understand-
ing of the free PMV-algebra with n free generators.
We note that, following the proof, one can extract an algorithm that generates
the term associated to a given L-polynomial function (see Figure 1).
Proposition 4.7. Let S be a subring of ℝ.
(a) For any L-polynomial function p : [0, 1]n →ℝthere exists t ∈Term(n, L)
such that ϱ ∘p = ̃t.
(b) For any g ∈ISD(n, L) there exists t ∈Term(n, L) such that g = ̃t.
Proof: We give the proof for L = L1,S, which is the most general one.
(a) Let p : [0, 1]n →ℝbe an polynomial function. Let k be the degree of p.
Then
p(x1, . . . , xn) =
∑
i1+...+in≤k
ci1,...,inxi1
1 ⋅⋅⋅xinn ,
where ci1,...,in ∈S for any choice of the indexes. Since any ci1,...,in can be written
as a sum of a ﬁnite number of elements in [−1, 1] ∩S, we assume that
p(x1, . . . , xn) = rmym + ⋅⋅⋅+ rp+1yp+1 + rp + ⋅⋅⋅+ r1
where m ≥1 and p ≥0 are natural numbers, p ≤m, rj ∈([−1, 1] ∩S) \ {0} for any
j ∈{1, ⋅⋅⋅, m} and yj ∈{xi1
1 ⋅⋅⋅xinn | i1 + ⋅⋅⋅+ in ≤k} for any j ∈{p + 1, ⋅⋅⋅, m}.
We prove the theorem by induction on m ≥1. In the sequel we denote by x an
element (x1, . . . , xn) from [0, 1]n.
Initial step m = 1. We have p(x) = r for any x ∈[0, 1]n or p(x) = rxi1
1 ⋅⋅⋅xinn for any
x ∈[0, 1]n where r ∈([−1, 1] ∩S) \ {0} and {i1, . . . , in} is a suitable set of indexes.

A General View on Normal Form Theorems for Łukasiewicz Logic with Product
|
223
If r ∈[−1, 0) ∩S then ϱ ∘p = 0 so ϱ ∘p = ̃t for t = 0.
If r ∈(0, 1] ∩S then p = ϱ ∘p. It follows that p = ̃t where t = δr(0∗) if p(x) = r
for any x ∈[0, 1]n and t = δr(Xi1
1 ⋅⋅⋅Xinn ) if p(x) = rxi1
1 ⋅⋅⋅xinn for any x ∈[0, 1]n.
Induction step. We take p = g + h where ϱ ∘g = ̃t1 for some term t1 and there
is r ∈([−1, 1] ∩S) \ {0} and a suitable choice of indexes for i1, . . . , in such that
h(x) = r for any x ∈[0, 1]n, or h(x) = rxi1
1 ⋅⋅⋅xinn for any x ∈[0, 1]n. We consider
two cases.
Case 1. If r ∈(0, 1] then h : [0, 1]n →[0, 1] so ϱ ∘p = ((ϱ ∘g) ⊕h) ⊙(ϱ ∘(1 + g)) by
Lemma 4.6 (a). Following the initial step, there is a term t2 such that h = ̃t2. We
notice that 1+g = 1−(−g) and the induction hypothesis holds for (−g), then there
is a term t3 such that ϱ ∘(−g) = ̃t3. It follows by Lemma 4.6 (b) that ϱ ∘(1 + g) =
1 −̃t3 = ̃t3
∗, and ϱ ∘p = ̃t where t = (t1 ⊕t2) ⊙t∗
3.
Case 2. If r ∈[−1, 0), then g + h = (g −1) + (1 + h) and 1 + h : [0, 1]n →[0, 1]. By
Lemma 4.6 (a) we get
ϱ ∘p = ((ϱ ∘(g −1)) ⊕(1 + h)) ⊙(ϱ ∘g).
Following the initial step, there is a term t2 such that −h = ̃t2, so 1+h = 1−(−h) =
̃t2
∗. In the sequel we have to ﬁnd a term t3 that corresponds to ϱ ∘(g −1), where
g(x) = rmym + ⋅⋅⋅+ rp+1yp+1 + rp + ⋅⋅⋅+ r1
with rj ∈([−1, 1]∩S)\{0} for any j ∈{1, ⋅⋅⋅, m} and yj in {xi1
1 ⋅⋅⋅xinn | i1+⋅⋅⋅+in ≤k}
for any j ∈{p + 1, ⋅⋅⋅, m}.
Case 2.1. If rj ≤0 for any j ∈{1, ⋅⋅⋅, m} then g −1 ≤0, so ϱ ∘(g −1) = 0 = ̃t3 with
t3 = 0.
Case 2.2. If there is j0 ∈{1, ⋅⋅⋅, p} such that rj0 > 0, then
(g −1)(x) = rmym + ⋅⋅⋅+ rp+1yp+1 + rp + ⋅⋅⋅+ (rj0 −1) + ⋅⋅⋅+ r1
and rj0 −1 ∈[−1, 0), so the induction hypothesis applies to g−1. Then there exists
a term t3 such that ϱ ∘(g −1) = ̃t3.
Case 2.3. If there is j0 ∈{p + 1, ⋅⋅⋅, m} such that rj0 > 0, then we set h0(x) = rj0yj0
and
g0(x) = g(x) −rj0yj0 −1.
It follows that g −1 = g0 + h0 such that g0 satisﬁes the induction hypothesis and
h0 : [0, 1]n →[0, 1]. We are in the hypothesis of Case 1, so there exists a term t3
such that ϱ ∘(g −1) = ̃t3.
Summing up, we get ϱ ∘(g + h) = ̃t with t = ((t2 ⊕t∗
3) ⊙t1).
(b) This is straightforward by (a): for any gij there exist a term tij ∈Termn(S) such
that ϱ ∘gij = ̃
tij.

224
|
S. Lapenta and I. Leuştean
Then
g = ϱ ∘g = ⋁
i∈I
⋀
j∈J
ϱ ∘gij = ⋁
i∈I
⋀
j∈J
̃
tij.
If t = ⋁i∈I ⋀j∈J tij, we get g = ̃t.
Remark 4.8. If f : [0, 1]n →ℝis a polynomial function with real coeﬃcients then
we represent f : [0, 1]n →ℝas
f(x1, . . . , xn) = rmym + ⋅⋅⋅+ rp+1yp+1 + rp + ⋅⋅⋅+ r1
where p ≤m , rj ∈[−1, 1] \ {0}, and yj = x
i1
j
1 ⋅⋅⋅x
in
j
n is a monomial for any j >
p. Using this representation one can easily extract an algorithm from the proof of
Theorem 4.9, which returns an L-term corresponding to f. In Figure 1 we describe
the algorithm for L = L1,S.
We note that the polynomial f is represented by
(p, r1, . . . , rp, (rp+1, ip+1), . . . , (rm, im)),
where ij = (i1
j , . . . , in
j ) for any j ∈{p + 1, . . . , m}. In particular cases the represen-
tation can be simpliﬁed as follows:
–
for L ∈{L0, L0,S} the monomials yj satisfy the condition i1
j + ⋅⋅⋅+ in
j = 1, so yj
are of the form xk;
–
for L ∈{L0, L1} and for any j we have rj ∈{−1, 1}.
The algorithm for L = L0,ℝis described in [Gerla et al., 2013].
The following theorem summarizes our results.
Theorem 4.9. ISD(n, L) ⊆TF(n, L) ⊆PWP(n, L) for L ∈{L0, L1, L0,S, L1,S}.
5 Normal form theorems and the Pierce-Birkhoﬀ
conjecture
Let S be a subring of ℝand L as above. In the light of Theorem 4.9, one may ask if
the following equalities hold:
(∗)
ISD(n, L) = TF(n, L) = PWP(n, L).
This problem has the same ﬂavor as the Pierce-Birkhoﬀconjecture. Moreover, for
L = L0 this is the McNaughton theorem [McNaughton, 1951, Mundici, 1994]. In
the following we discuss the property (∗) from logical perspective.

A General View on Normal Form Theorems for Łukasiewicz Logic with Product
|
225
// we use the notation ik = (i1
k, . . . , in
k)
function Term(p, r1, . . . , rp, (rp+1, ip+1), . . . (rm, im))
{
(F1) if rk ≤0 for any k ∈{1, . . . , m} then return(0);
(F2) find k ∈{1, . . . , m} such that rk > 0;
if k ≤p then ψ := δrk(0∗) else ψ := δrk(X
i1
k
1 ⋅⋅⋅X
in
kn );
(F3) if m = 1 then return(ψ);
(F4) if k ≤p then
{φ = Term(p −1, r1, . . . , rk−1, rk+1, . . . rp, (rp+1, ip+1), . . . , (rm, im));
χ =Term(p −1,−r1, . . . ,−rk−1, −rk+1, . . .−rp, (−rp+1, ip+1), . . . , (−rm, im))
} else
{φ = Term(p, r1, . . . , rp, . . . , (rk−1, ik−1)(rk+1, ik+1), . . . , (rm, im));
χ = Term(p, −r1, . . . , −rp, . . . , (−rk−1, ik−1), (−rk+1, ik+1), . . . , (−rm, im))
}; return((φ ⊕ψ) ⊙¬χ)
}
Fig. 1. The term corresponding to a polynomial function
If L ∈{L1, L0,S, L1,S} and [0, 1]L is an L-algebra deﬁned in the previous sec-
tion, then TF(n, L) is an L-algebra with pointwise operations. By general results
in universal algebra TF(n, L) is the free L-structure in the variety generated by
[0, 1]L.
We already mentioned that L0 is the language of Łukasiewicz logic. One can
easily see that L1, L0,ℝ, L1,ℝare, respectively, the language of PMV-algebras,
Riesz MV-algebras and fMV-algebras.
We further note that [0, 1]L0 generates the variety of MV-algebras [Chang,
1959, Cignoli et al., 2000] and [0, 1]L0,ℝgenerates the variety of Riesz MV-algebras
[Di Nola and Leuştean, 2014]. Let Lℝbe the propositional calculus which has
Riesz MV-algebras as models. In this context (∗) holds [Di Nola and Leuştean,
2014] and it can be seen as a local version of the result from Remark 3.2.
The situation is diﬀerent for PMV-algebras, since the standard model [0, 1]L1
generates only a proper subvariety [Horčík and Cintula, 2004]. Moreover, due to
a result of Isbell [Isbell, 1972] this variety is not ﬁnitely axiomatizable. Montagna
proved that the proper quasi-variety of PMV+-algebras deﬁned by the quasi-
identity:
x ⋅x = 0 ⇒x = 0 for any x
is generated, as a quasi-variety, by [0, 1]L1 [Montagna, 2005]. Consequently, the
equality (∗) for L1 is a normal form theorem for the system PL耠, described in
[Horčík and Cintula, 2004], that has PMV+-algebras as models. A similar analysis

226
|
S. Lapenta and I. Leuştean
is made in [Lapenta and Leuştean, 2015] for fMV-algebras; in this case the quasi-
variety generated by the standard model [0, 1]L1,ℝis the class of FR+-algebras and
the corresponding propositional calculus is denoted FMVL+.
Finally we note that all these logical systems are conservative extensions of
Łukasiewicz ∞-valued logic and the L-structure TF(n, L) is, up to isomorphism,
the Lindenbaum-Tarski algebra of the corresponding propositional calculus. The
property (∗) is a normal form theorem and we summarize below the results known
so far.
Table 1. Normal form theorem : summary of known results
L
Logic
Algebra
ISD(n, L)= PWP(n, L)
L0
Łuk
MV-algebras
true [McNaughton, 1951]
L0,ℝ
Lℝ
Riesz MV-algebras
true [Di Nola and Leuştean, 2014]
L1
PL耠
PMV+-algebras
open problem
L1,ℝ
FMVL+
FR+-algebras
true if n ≤2
open problem if n > 2
[Lapenta and Leuştean, 2015]
In the following we emphasize the results for the system FMVL+. Note that in
this case the unital piecewise polynomial functions from Deﬁnition 4.3 have the
components as the continuous piecewise polynomial functions from the Pierce-
Birkhoﬀconjecture.
If f : ℝn →[0, 1] is a continuous piecewise polynomial function then f|[0,1]n
is a continuous piecewise polynomial function deﬁned on the unit cube. In gen-
eral it is not known if any piecewise polynomial function deﬁned on [0, 1]n is the
restriction of a continuous piecewise polynomial function deﬁned on ℝn, but for
n = 2 a positive answer is given in [Fischer and Marshall, 2013]. As a direct con-
sequence and using Mahé’s proof for the Pierce-Birkhoﬀconjecture [Mahé, 1984],
for n ≤2 we get
ISD(n, L1,ℝ) = TF(n, L1,ℝ) = PWP(n, L1,ℝ).
The above result is a normal form theorem for the propositional calculus FMVL+
and describes the functions corresponding to the formulas in two variables. The
following result can be interpreted as a local version of the Pierce-Birkhoﬀtheo-
rem.
Conjecture 5.1. [Lapenta and Leuştean, 2015] For n > 2,
ISD(n, L1,ℝ) = TF(n, L1,ℝ) = PWP(n, L1,ℝ).

A General View on Normal Form Theorems for Łukasiewicz Logic with Product
|
227
We note that the above result does not immediately imply and it is not immedi-
ately implied by the original Pierce-Birkhoﬀconjecture and it might be equally
hard to prove.
Acknowledgment: Ioana Leuştean was partially supported by a grant of the
Romanian National Authority for Scientiﬁc Research and Innovation, CNCS-
UEFISCDI, project number PN-II-RU-TE-2014-4-0730.
References
W. M. Beynon. Combinatorial aspects of piecewise polynomial functions. Journal . Math. Soc.,
2:719–727, 1974.
A. Bigard, K. Keimel, and S. Wolfstein. Groupes et anneuax reticules. Springer-Verlag, Lecture
Notes in Mathematics 608, 1977.
G. Birkhoﬀand R.S. Pierce. Lattice-ordered rings. An. Acad. Brasil. Cienc., 28:41–69, 1956.
C.C. Chang. Algebraic analysis of many-valued logics. Trans. Amer. Math. Soc., 88:467–490,
1958.
C.C. Chang. A new proof of the completeness of the Łukasiewicz axioms. Transactions of the
American Mathematical Society, 93:74–80, 1959.
R. Cignoli, I. M. L. D’Ottaviano, and D. Mundici. Algebraic foundation of many-valued Reason-
ing. Kluver Academic Publ. Dordrecht, Trends in Logic 7, 2000.
C.N. Delzell. On the Pierce-Birkhoﬀconjecture over ordered ﬁelds. Rocky Mountains Journal of
Mathematics, 19(3):651–668, 1989.
A. Di Nola and A. Dvurečenskij. Product MV-algebras. Multiple-Valued Logics, 6:193–215, 2001.
A. Di Nola and I. Leuştean. Łukasiewicz logic and riesz spaces. Soft Computing, 18(12):2349–
2363, 2014.
A. Fischer and M. Marshall. Extending piecewise polynomial functions in two variables. An-
nales de la faculté des Sciences de Toulouse Mathématiques, 22:253–268, 2013.
B. Gerla, A. Di Nola, and I. Leuştean. Adding Real Coeﬃcients to Łukasiewicz logic: An Appli-
cation to Neural Networks. In Masulli F., Pasi G., and Yager R., editors, Lecture notes in
Computer Science 8256, WILF 2013, Proceedings, pages 77–85. 2013.
P. Hájek. Metamathematics of Fuzzy Logic. Kluver Dordrecht, Trends in Logic 4, 1998.
R. Horčík and P. Cintula. Product Łukasiewicz logic. Archive for Mathematical Logic, 43(4):
477–503, 2004.
J R. Isbell. Notes on Ordered Rings. Algebra Univ., 1:393–399, 1972.
S. Lapenta and I. Leuştean. Towards understanding the Pierce-Birkhoﬀconjecture via MV-
algebras. Fuzzy sets and systems, 276:114–130, 2015.
S. Lapenta and I. Leuştean. Scalar extensions for the algebraic structures of Łukasiewicz logic.
Journal of Pure and Applied Algebra, 220:1538–1553, 2016.
F. Lucas, D. Schaub, and M. Spivakovsky. On the pierce–birkhoﬀconjecture. Journal of Algebra,
435:124 – 158, 2015.

228
|
S. Lapenta and I. Leuştean
J. Łukasiewicz and A. Tarski. Untersuchungen über den aussagenkalkül. Comptes Rendus de la
Société des Sciences et des Lettres de Varsovie, 23:30–50, 1930.
J. Madden. Henriksen and Isbell on f-rings. Topology and Its Applications, 158:1768–1773,
2011.
L. Mahé. On the Birkhoﬀ-Pierce conjecture. Rocky Mountains Journal, 14(4):983–985, 1984.
L. Mahé. On the Birkhoﬀ-Pierce conjecture in three variables. J. Pure Appl. Algebra, 211:459–
470, 2007.
R. McNaughton. A theorem about inﬁnite-valued sentential logic. Journal of Symbolic Logic, 16:
1–13, 1951.
F. Montagna. An algebraic approach to Propositional Fuzzy Logic. Journal of Logic, Language
and Information, 9:91–124, 2000.
F. Montagna. Subreducts of MV-algebras with product and product residuation. Algebra Uni-
versalis, 53:109–137, 2005.
F. Montagna and G. Panti. Adding structure to MV-algebras. J. Pure and Applied Algebra, 164:
365–387, 2001.
D. Mundici. Interpretation of ACF*-algebras in Łukasiewicz sentential calculus. J. Funct. Anal.,
65:15–63, 1986.
D. Mundici. A constructive proof of McNaughton Theorem in inﬁnite-valued logic. J. Symb. Log.,
59:596–602, 1994.
D. Mundici. Tensor Products and the Loomis–Sikorski Theorem for MV-Algebras. Advances in
Applied Mathematics, 22(2):227 – 248, 1999.
D. Mundici. Advanced Łukasiewicz calculus and MV-algebras. Springer, Trends in Logic 35,
2011.

Maria Emilia Maietti and Giuseppe Rosolini
Relating Quotient Completions
via Categorical Logic
Abstract: In previous work we introduced the notion of elementary quotient com-
pletion with respect to an elementary doctrine. We also generalized the notion
of exact completion of a regular category as an exact completion of an existential
elementary doctrine. Here we characterize when the elementary quotient comple-
tion of an elementary existential doctrine coincides with an exact completion. We
do this by employing the categorical logic of the various notions of doctrines in-
volved in our analysis. The outcome is that the two completions coincide when a
choice rule holds in the starting existential elementary doctrine.
Keywords: Quotient completion, Split ﬁbration, Universal construction
Mathematics Subject Classiﬁcation 2010: 03G30, 03B15, 18C50, 03B20, 03F55
1 Introduction
The need of completing a structure with quotients arises in various ﬁelds in math-
ematics and in computer science, including foundation of mathematics, type the-
ory and category theory, in order to get models closed under quotients though
based on much weaker structures.
In previous work [Maietti and Rosolini, 2013b,a] we used the language of cate-
gory theory to introduce a notion of quotient completion for Lawvere’s elementary
doctrines, see [Lawvere, 1969a, 1970]. The notion includes well-known instances
of quotient completion in category theory and in type theory: for examples, the
exact completion of a lex category as in [Carboni and Celia Magno, 1982], Joyal’s
arithmetic universes (see [Maietti, 2010]) and setoid models of type theory are all
instances of elementary quotient completions.
In another work [Maietti and Rosolini, 2015] we reviewed and generalized the
notion of exact completion of a regular category as a free construction from an ex-
istential elementary doctrine. Examples of this construction are toposes obtained
from triposes, see [Hyland et al., 1980], in particular the eﬀective topos of [Hyland,
1982].
Maria Emilia Maietti: Dipartimento di Matematica Pura ed Applicata, Università di Padova, via
Trieste 63, 35121 Padova, Italy, e-mail: maietti@math.unipd.it
Giuseppe Rosolini: DIMA, Università di Genova, via Dodecaneso 35, 16146 Genova, Italy,
e-mail: rosolini@unige.it

230
|
M. E. Maietti and G. Rosolini
The aim of this paper is to present a logical characterization of when the el-
ementary quotient completion of an existential elementary doctrine happens to
coincide with its exact completion.
To this purpose in the ﬁrst part of the paper we review the mentioned no-
tions of quotient completion related to an elementary doctrine. Diﬀerently from
the previous work, here we employ the internal logic for elementary doctrine as
presented in [Jacobs, 1999]. Finally we show that the two completions coincide
when the starting elementary existential doctrine satisﬁes a rule of choice.
2 Notions of elementary doctrine
In previous work [Maietti and Rosolini, 2013b,a] we employed the notion of el-
ementary doctrine to generalize the completion of a categorical structure with
quotients. The main idea was to relativize the concept of quotient completion to a
many sorted logic, represented categorically by a doctrine, validating the logical
structure needed to speak of equivalence relations. In loc.cit. we found appropri-
ate to use Lawvere’s concept of elementary doctrine, which represents a many
sorted logic with conjunctions and propositional equality, and related to it we de-
ﬁned the notion of elementary quotient completion.
F.W. Lawvere introduced the notion of elementary doctrine in a series of semi-
nal papers, see [Lawvere, 1969a,b, 1970], to synthetize the structural properties of
logical systems, see also [Lawvere and Rosebrugh, 2003] for a uniﬁed survey. Law-
vere’s crucial intuition was to consider logical languages and theories as hyper-
doctrines to study their 2-categorical properties, e.g. connectives and quantiﬁers
are determined by structural adjunctions. That approach proved extremely fruit-
ful, see [Makkai and Reyes, 1977, Carboni, 1982, Lambek and Scott, 1986, Jacobs,
1999, Taylor, 1999, van Oosten, 2008] and references therein.
Taking advantage of the category-theoretical presentation of logic by doc-
trines, we now ﬁrst introduce a general notion of elementary doctrine which we
found appropriate to study the notion of quotient of an equivalence relation, see
[Maietti and Rosolini, 2013b, 2015].
Since doctrines can be presented equivalently in the form of ﬁbrations, see
e.g. [Jacobs, 1999], we may use the names interchangeably.
Denote by InfSL the 2-category of inf-semilattice: objects are posets with ﬁnite
meets, 1-morphisms are functions between them which preserves ﬁnite meets, and
2-morphisms are given by the pointwise order on the homsets.

Relating Quotient Completions via Categorical Logic
|
231
Deﬁnition 2.1. Let C be a category with ﬁnite products. An elementary doctrine on
C is a functor P: Cop 㨀→InfSL¹—the value P(A) is the ﬁbre on A—such that, for
every object A in C, there is an object δA, which we shall call ﬁbered equality, in
P(A × A) such that
1.
for every object X and morphism e := ⟨pr1, pr2, pr2⟩: X × A →X × A × A in C,
the assignment that sends α in P(X × A) to the meet
E
e(α) := PidX×pr1(α) ∧P⟨pr2,pr3⟩(δA),
computed in P(X×A×A), determines a left adjoint to Pe: P(X×A×A) →P(X×A)
where pri, i = 1, 2, are the projections from X × A to each of the two factors.
Remark 2.2.
1.
Since T is terminal in C, condition (1.) for X = T yields that the assignment that
sends α in P(A) to the meet
E
⟨idA,idA⟩(α) := Ppr1(α) ∧δA,
computed in P(A × A), determines a left adjoint to P⟨idA,idA⟩: P(A × A) →P(A).
2.
The previous remark yields that δA is unique for each object A in C.
3.
Since ⟨pr2, pr1⟩∘⟨idA, idA⟩= ⟨idA, idA⟩, one has that
E
⟨idA,idA⟩(α) = Ppr2(α) ∧δA
for every α in P(A).
4.
In P(A × A) it is ⊤≤P⟨idA,idA⟩(δA) and, in P(A × A), it is δA ≤Pf×f(δB) when
f: A →B.
5.
For α1 in P(X1 × Y1) and α2 in P(X2 × Y2), write α1 ⊠α2 for the object
P⟨pr1,pr3⟩(α1) ∧P⟨pr2,pr4⟩(α2)
in P(X1 × X2 × Y1 × Y2) where pri, i = 1, 2, 3, 4, are the projections from X1 ×
X2 × Y1 × Y2 to each of the four factors.
Condition 2.1.1. is to request that δA×B = δA ⊠δB for every pair of objects A and
B in C.
Examples 2.3.
1.
The ﬁrst example of elementary doctrine is that of powersets. The domain cat-
egory is the category Set of sets and functions. The terminal object can be ﬁxed
1 We may refer to such a functor as an indexed inf-semilattice; we always write Pf for the value
of the indexing functor P on a morphism f.

232
|
M. E. Maietti and G. Rosolini
as {0}, and the product of two sets is given by the set of ordered pairs encoded
as usual (x, y) := {{x}, {x, y}} with obvious projections.
The elementary doctrine P: Setop 㨀→InfSL on Set is given as the pow-
erset P(A). The action on functions f: A →B is by inverse image, i.e. Pf :=
f −1: P(B) →P(A).
The elementary structure is given by the diagonal subset of A × A.
2.
The standard categorical example of an indexed poset is the ﬁbration of sub-
objects, a generalization of the previous example to an arbitrary category.
Consider a category C with binary products, a terminal object and pullbacks
of monomorphisms—for convenience, we shall assume that C is also well-
powered, here as well as any other time when size issues become relevant. The
functor S: Cop 㨀→InfSL assigns to any object A in C the poset S(A) of subob-
jects of A in C and it is easy to check that the poset is an inf-semilattice. For
a morphism f: B →A, the assignment that maps a subobject in S(A) to that
represented by the left-hand morphism in any pullback of it along f produces a
functor Sf: S(A) →S(B) that preserves products.
The elementary structure is provided by the diagonal morphisms.
3.
Another categorical example is given by a category S with binary products and
weak pullbacks, by deﬁning the doctrine functor of weak subobjects Ψ: Sop 㨀→
InfSL which evaluates as the poset reﬂection of each comma category S/A at
each object A of S, introduced in [Grandis, 2000].
4.
An example of elementary doctrine from ﬁrst order logic is the Lindenbaum-
Tarski algebras of well-formed formulas of a theory T with equality in the ﬁrst
order language L. The domain category is the category V of lists of variables
and term substitutions:
–
object of V are lists of distinct variables (xj1, . . . , xjn);
–
morphisms (t1/xk1, . . . , tm/xkm): (xj1, . . . , xjn) →(xk1, . . . , xkm) are lists
of substitutions for variables where each term tj, i = 1, . . . , m, is built in
L on the variables xj1, . . . , xjn;
–
composition (xj1, . . . , xjn)
(ti/xki )m
i=1/(xk1, . . . , xkm)
(si/xhi )ℓ
i=1 /(xh1, . . . , xhℓ)
is given by simultaneous substitutions
(xj1, . . . , xjn)
(si(t1/xk1 ,...,tm/xkm )/xhi )ℓ
i=1)
/ (xh1, . . . , xhℓ).
The terminal object is the empty list (); the product of two objects (xj1, . . . , xjn)
and (xk1, . . . , xkm) is given by the list (xj1, . . . , xjn, xJ+k1, . . . , xJ+km), where
J = max{j1, . . . , jn}. Projections are given by substitution of the variables
in (xj1, . . . , xjn) by the ﬁrst n variables in (xj1, . . . , xjn, xJ+k1, . . . , xJ+km),
and of the variables in (xk1, . . . , xkm) with the last m variables occurring in
(xj1, . . . , xjn, xJ+k1, . . . , xJ+km).

Relating Quotient Completions via Categorical Logic
|
233
The elementary doctrine LT: Vop 㨀→InfSL on V is given as follows: for a list of
distinct variables ⃗x, the inf-semilattice LT( ⃗x) has
–
objects are equivalence classes of well-formed formulas of L with no more
free variables than xj1,...,xjn with respect to provable reciprocal conse-
quence W ⊣⊢T W耠in T;
morphisms[W ] →[V ] are the provable consequences W ⊢T V in T for some
pair of representatives (hence for any pair);
–
composition is given by the cut rule in the logical calculus;
–
identities [W ] →[W ] are given by the logical rules W ⊢T W.
For a list of distinct variables
⃗x := (xj1, . . . , xjn), the poset LT( ⃗x) has ﬁnite
meets: the top element is any true formula, for example x = x with x variable in
⃗x and the meet of a pair of formulas is obtained by conjunction.
Elementary doctrines are the cloven Eq-ﬁbrations of [Jacobs, 1999] and, as ex-
plained in loc.cit., there is a deductive calculus associated to those which is that
of the ∧=-fragment over type theory with just a unit type and a binary product
type constructor. From now on, we shall employ the logical language introduced
in loc.cit. and write
a1: A1, . . . , ak: Ak | ϕ1(a1, . . . , ak), . . . , ϕn(a1, . . . , ak) ⊢ψ(a1, . . . , ak)
in place of
ϕ1 ∧. . . ∧ϕn ≤ψ
in P(A1 × . . . × Ak). Note that, in line with loc.cit., δA(a, a耠) will be written as
a: A, a耠: A | a =A a耠. Also we write a: A | α ⊣⊢β to abbreviate a: A | α ⊢β and
a: A | β ⊢α.
It is possible to express precisely relationships between the examples once
one considers the 2-category ED of elementary doctrines:
–
the 1-morphisms are pairs (F, b) where F: C →D is a functor and b: P
.→R∘Fop
is a natural transformation as in the diagram
Cop
P
)
F
op

InfSL
Dop
R
5
b ⋅

where the functor F preserves products and, for every object A in C, the func-
tor bA: P(A) →R(F(A)) preserves ﬁnite meets and
bA×A(δA) = R⟨F(pr1),F(pr2)⟩(δF(A));

234
|
M. E. Maietti and G. Rosolini
–
the 2-morphisms are natural transformations θ: F
.→G such that
Cop
P
+
F
op

G
op
	
InfSL
Dop
R
3
b ⋅

⋅c

.
θ
op
o
≤
so that, for every A in C and every α in P(A), one has bA(α) ≤F(A) RθA(cA(α)).
Remark 2.4. Expressing in the internal logic the action of a 1-morphism (F, b) we
have the following translation table—simply writing (–)F and (–)b for the action of
F and b respectively.
P
(F,b)
/ R
A × B 
/ AF × BF
a: A 
/ a: AF
(s, t) 
/ (sF, tF)
f(s) 
/ f F(sF)
⊤
/ ⊤
ϕ ∧ψ 
/ ϕb ∧ψb
s =A t 
/ sF =AF tF
In the same vein, a 2-morphism θ: (F, b) →(G, c) determines a family of terms
(x: XF | θX(x): XG), as X varies in C, such that, for every term (a: A | t: B) in C,
the terms (a: AF | θB(tF): BG) and (a: AF | tG(θA(a)): BG) are equal and
a: AF | αb(a) ⊢αc(θ(a))
for every A in C and α in P(A).
Examples 2.5.
1.
Given a theory T with equality in a ﬁrst order language L (say with a single sort),
a 1-morphism (F, b): LT →S from the elementary doctrine LT: Vop 㨀→InfSL as
in 2.3.4. into S: Setop 㨀→InfSL, the elementary doctrine in 2.3.1. with C = Set,
determines a model M of T where the set underlying the interpretation is F(x1).
In fact, there is an equivalence between the category ED(LT, S) and the category
of models of T and L-homomorphisms.
2.
Given a category C with products and pullbacks, one can consider the two
indexed inf-semilattices: that of subobjects S: Cop 㨀→InfSL, and the other
Ψ: Cop 㨀→InfSL, obtained by the poset reﬂection of each comma category
C/A, for A in C. The inclusion of the poset S(A) of subobjects over A into the

Relating Quotient Completions via Categorical Logic
|
235
poset reﬂection of C/A extend to a 1-morphism from S to Ψ which is an equiva-
lence exactly when every morphism in C can be factored as a retraction followed
by a monic.
The notion of comprehension is related to the characterization of doctrines of sub-
objects. Though very general, we shall present that notion in the particular case
of an elementary doctrine.
Deﬁnition 2.6. Given any elementary doctrine P: Cop 㨀→InfSL, and an object α in
some P(A), a comprehension of α is a morphism {|a: A | α(a)|}: X →A in C such that
x: X | ⊤⊢α({|a: A | α(a)|}(x))
and, for every f: Z →A such that
z: Z | ⊤⊢α(f(z))
there is a unique morphism f 耠: Z →X such that f = {|a: A | α(a)|} ∘f 耠.²
Intuitively, the comprehension morphism represents the subsets of elements in
the object A obtained by comprehension with the predicate α.
In previous works [Maietti and Rosolini, 2013b,a] we said that an elementary
doctrine P has comprehensions if every α has a comprehension, and that P has full
comprehensions if, moreover, α ≤β in P(A) whenever {|α|} factors through {|β|}.
However to view comprehensions as logical constructors following Jacobs
[1999], we need to assume that a choice of comprehensions is available in the
doctrine as follows.
An elementary doctrine P has a choice of comprehensions if there is a func-
tion {|–|} that assigns a comprehension to every object α in the ﬁbre P(A)³, and that
P: Cop 㨀→InfSL has a choice of full comprehensions if it has a choice compre-
hensions and, for any C-object A, one has a: A | α ⊢β holds in case there is a
factorization
X
{|a:A|α(a)|}

/ Y
{|a:A|β(a)|}

A
Remark 2.7. The notion of comprehension connects an abstract indexed poset with
one of subobjects of the base when this has pullbacks of monomorphisms. We now
recall a standard result in the case of interest for us, see e.g. [Jacobs, 1999] where
2 Hence a comprehension is necessarily monic.
3 It is a function {|–|} ∈∏A∈C0 CP(A)0
1
.

236
|
M. E. Maietti and G. Rosolini
also a very elegant, more abstract view of comprehensions as right adjoint is con-
sidered.
Let P: Cop 㨀→InfSL be an elementary doctrine, and suppose that P has a choice
of comprehensions. Consider the indexed inf-semilattice S: Cop 㨀→InfSL of subob-
jects of the base category C. The function computing comprehensions can be ex-
tended to a natural transformation
Cop
P
+
S
3 InfSL
{|–|} ⋅
in a unique way. All functors {|–|}: P(A) →S(A) are faithful, and are fully faithful
exactly when P has full comprehensions.
From now on when we simply say that an elementary doctrine P has comprehen-
sions, or full comprehensions, we assume that it has a choice of comprehensions, or
full comprehensions just to be able to use the internal categorical logic.
A special case of comprehensions are the diagonal morphisms and the fol-
lowing deﬁnition considers just that possibility.
Deﬁnition 2.8. An elementary doctrine P: Cop 㨀→InfSL has comprehensive diag-
onals if every diagonal morphism ⟨idA, idA⟩: A →A × A is a comprehension.
Lemma 2.9. Let P: Cop 㨀→InfSL be an elementary doctrine. The following are
equivalent:
1.
P has comprehensive diagonals.
2.
For every object A in C, the diagonal ⟨idA, idA⟩: A →A × A is a comprehension
of the corresponding ﬁbered equality δA.
3.
For any two morphisms f, g: A →B in C, it is
f = g in C iﬀa: A | ⊤⊢f(a) =B g(a).
It is easy to determine a 2-reﬂection of elementary doctrines into the full 2-
subcategory of elementary doctrines with comprehensive diagonals once one
notices that the condition
a: A | ⊤⊢f(a) =B g(a)
ensures that Pf = Pg, i.e. that, for every β in P(B), one has that
a: A | β(f(a)) ⊢β(g(a))
and
a: A | β(g(a)) ⊢β(f(a)).
So the reﬂection takes an elementary doctrine P: Cop 㨀→InfSL to the elementary
doctrine Px: Cop
P
㨀→InfSL, induced by P on the quotient category CP of C with

Relating Quotient Completions via Categorical Logic
|
237
respect to the equivalence relation where f ∼g when
a: A | ⊤⊢f(a) =B g(a).
We may refer to the doctrine Px as the extensional reflection of P.
Remark 2.10. When an elementary doctrine P: Cop 㨀→InfSL has full comprehen-
sions and comprehensive diagonals, the base category C has equalizers. The equal-
izer of A
f
/
g
/ B is computed as {|a: A | f(a) =B g(a)|}: E →A.
Remark 2.11. In the situation considered in 2.7, the pair (idC, {|–|}) is a 1-morphism
in ED
Cop
P
)
idC
op

InfSL
Cop
S
5
{|–|} ⋅

exactly when
X
{|δA|}

∼
/ A
⟨idA,idA⟩

A × A
for any objects A in C, i.e. when P has comprehensive diagonals.
Indeed, if P is an elementary doctrine with comprehensions and comprehensive
diagonals, then the base category has pullbacks. So P embeds into the indexed
poset S of subobjects of C. One can think that comprehensions and comprehsive
diagonals force P to “look like” a poset of subobjects of C. Actually, this will be
the main situation we shall be interested in the following sections.
With that perspective, we also introduce the notion of existential elementary
doctrine from [Lawvere, 1969a], which presents existential quantiﬁcation as a left
adjoint to the substitution functor, see also [Jacobs, 1999].
Deﬁnition 2.12. An elementary doctrine P: Cop 㨀→InfSL is existential if, for A1
and A2 in C, for a(ny) projection pri: A1×A2 →Ai, i = 1, 2, the functor Ppri: P(Ai) →
P(A1 × A2) has a left adjoint
E
pri, to which we shall unimaginatively refer as exis-
tential, and these left adjoints satisfy the
–
Frobenius reciprocity: for pr: X →A a projection, α in P(A), β in P(X), the
canonical morphism
E
pr(Ppr(α) ∧X β) ≤α ∧A
E
pr(β) in P(A) is iso;

238
|
M. E. Maietti and G. Rosolini
–
Beck-Chevalley condition: for any pullback diagram
X耠
pr耠/
f 耠

A耠
f

X
pr
/ A
with pr a projection (hence also pr耠a projection), for any β in P(X), the canon-
ical morphism
E
pr耠Pf 耠(β) ≤Pf
E
pr(β) in P(A耠) is iso.
Deﬁnition 2.13. Let CEED be the 2-full 2-subcategory of ED
consisting of exis-
tential elementary doctrines with comprehensions whose ﬁrst components F of
1-morphisms (F, b) preserve comprehensions and existential adjoints.
Similarly to the case of elementary doctrines, [Jacobs, 1999] shows that the de-
ductive calculus associated to existential elementary doctrines is that of the ∧=∃-
fragment over type theory with a unit type and a binary product type constructor.
Remark 2.14. We recall a result of G.M. Kelly in [Kelly, 1992] which is related to the
situation considered in 2.7 when the elementary doctrine P: Cop 㨀→InfSL is also
existential with full comprehensions; in that case the base category C has a stable
proper factorization system. Recall from [Freyd and Kelly, 1972] that a pair (E, M)
of families of morphisms in C is a factorization system if they satisfy
–
factorization: every map in C factors as A
f
/
e
&
B
I
m
9
where e is in E and m
is in M;
–
orthogonality: for every commutative diagram
J
m$
X
f
:
e
%
Y
K
g
9
such that the
morphism e in in E and the morphism m is in M, then there is a unique morphism
J
m$
X
f
:
e
%
Y
K
g
9
h
O
making the two triangles commute.
The factorization system is stable if the family E is closed under pullbacks—M is
automatically closed under pullbacks, thanks to orthogonality—, and it is proper if
M consists of monos and E consists of epis.
In the factorization system determined on C by the doctrine P, the family M
consists of all maps isomorphic to a comprehension and the family E consists of
surjective epis. Given a morphism f: A →B in C, a suitable factorization is obtained
as follows:

Relating Quotient Completions via Categorical Logic
|
239
–
The mono is {|b: B | ∃x: A.f(x) =B b|}: I →B, the comprehension of the “image
in B of the graph of f”.
–
Then the ﬁrst factor is obtained by the universal property of a comprehension
since
a: A | ⊤⊢∃x: A.f(x) =B f(a)
A more general connection between ﬁbrations and not necessarily proper factoriza-
tion systems than that sketched here is in [Hughes and Jacobs, 2002].
3 Doctrines with eﬀective quotients
We saw how in an indexed poset, a comprehension allows to determine a “subset”
of deﬁnition in the base category for any predicate represented by an object in the
ﬁbre. Similarly an equivalence relation in a ﬁbre can determine a quotient in the
base category. For that reason, we recall from [Maietti and Rosolini, 2013b,a] the
notion of equivalence relation related to a doctrine and the associated notion of
eﬀective quotient.
Deﬁnition 3.1. Given an elementary doctrine P: Cop 㨀→InfSL, an object A in C and
an object ρ in P(A × A), we say that ρ is a P-equivalence relation on A if it satisﬁes
–
reflexivity: a: A, a耠: A | a =A a耠⊢ρ(a, a耠);
–
symmetry: a: A, a耠: A | ρ(a, a耠) ⊢ρ(a耠, a);
–
transitivity: a: A, a耠: A, a耠耠: A | ρ(a, a耠), ρ(a耠, a耠耠) ⊢ρ(a, a耠耠).
In elementary doctrines as those presented in 2.3, P-equivalence relations concide
with the usual notion for those of the form 2.3.1. or 2.3.2.; more interestingly, in
cases like 2.3.3. a Ψ-equivalence relation is a pseudo-equivalence relation in S in
the sense of [Carboni and Celia Magno, 1982].
For P: Cop 㨀→InfSL an elementary doctrine, the object (a: A, a耠: A | a =A a耠)
is a P-equivalence relation on A. And for a morphism f: A →B in C, the func-
tor Pf×f: P(B × B) →P(A × A) takes a P-equivalence relation σ on B to a P-
equivalence relation on A. Hence, the P-kernel equivalence of f: A →B, the object
(a: A, a耠: A | f(a) =B f(a耠)) of PA×A is a P-equivalence relation on A. In such a case,
one speaks of (a: A, a耠: A | f(a) =B f(a耠)) as an eﬀective P-equivalence relation.
Deﬁnition 3.2. Let P: Cop 㨀→InfSL be an elementary doctrine. Let ρ be a P-
equivalence relation on A. A P-quotient of ρ, or simply a quotient when the doctrine
is clear from the context, is a morphism q: A →A/ρ in C such that
a; A, a耠: A | ρ(a, a耠) ⊢q(a) =A/ρ q(a耠)

240
|
M. E. Maietti and G. Rosolini
and, for every morphism g: A →Z such that
a; A, a耠: A | ρ(a, a耠) ⊢g(a) =Z g(a耠),
there is a unique morphism g: A/ρ →Z such that g = g ∘q.
We say that such a P-quotient is stable if, for every pullback diagram
B
f 耠

q耠
/ C
f

A
q / A/ρ
in C, the morphism q耠is a P-quotient.
Deﬁnition 3.3. Given an elementary doctrine P: Cop 㨀→InfSL and a P-equivalence
relation ρ on an object A in C, the poset of descent data Desρ is the sub-poset of
P(A) on those α such that
a: A, b: A | α(a), ρ(a, b) ⊢α(b).
Remark 3.4. Given an elementary doctrine P: Cop 㨀→InfSL, for f: A →B in C, let
χ be the P-kernel Pf×f(δB). The functor Pf: P(B) →P(A) applies P(B) into Desχ.
Deﬁnition 3.5. Given an elementary doctrine P: Cop 㨀→InfSL and a morphism
f: A →B in C, let χ be the P-kernel Pf×f(δB). The morphism f is descent if the
functor Pf: P(B) →Desχ is full (it is trivially faithful). The morphism f is eﬀective
descent if the functor Pf: P(B) →Desχ is an equivalence (hence an isomorphisms
of orders).
Consider the 2-full 2-subcategory QED of ED whose objects are elementary doc-
trines P: Cop 㨀→InfSL with descent quotients of P-equivalence relations.
The 1-morphisms are those pairs (F, b) in ED
Cop
P
)
F
op

InfSL
Dop
R
5
b ⋅

such that F preserves quotients in the sense that, if the morphism q: A →C in C
is a quotient of a P-equivalence relation ρ on A, then the morphism Fq: FA →FC
in D is a quotient of the R-equivalence relation R⟨F(pr1),F(pr2)⟩(bA×A(ρ)) on FA.
In [Maietti and Rosolini, 2013a] we proved that it is possible to add freely quo-
tients of equivalence relations to an elementary doctrine. For an elementary doc-
trine P: Cop 㨀→InfSL, the quotient completion of P consists of a category QP of
“quotients in P”, deﬁned as follows:

Relating Quotient Completions via Categorical Logic
|
241
–
an object of QP is a pair (A, ρ) such that ρ is a P-equivalence relation on A;
–
a morphism f: (A, ρ) →(B, σ) is a morphism f: A →B in C such that
a: A, b: A | ρ(a, b) ⊢σ(f(a), f(b)).
Composition is given by that of C, identities are represented by identities of C and
morphism equality is that of C.
The indexed inf-semilattice ̂P: Qop
P 㨀→InfSL on QP is the categories of descent
data: on an object (A, ρ) it is deﬁned as
̂P(A, ρ) := Desρ
where the order of descent data Desρ is the sub-order of P(A) on those α such that
a: A, b: A | α(a), ρ(a, b) ⊢α(b).
There is a 1-morphism (J, j): P →̂P in ED where J: Cop 㨀→RP sends an object A
in C to (A, δA) and a morphism f: A →B to f: (A, δA) →(B, δB) since δA ≤A×A
Pf×f(δB), and jA: P(A) →̂P(A, δA) is the identity since
̂P(A, δA) = DesδA = P(A).
It is immediate to see that J is full and faithful and that (J, j) is a change of base.
Theorem 3.6. The indexed inf-semilattice ̂P: Qop
P
㨀→InfSL is an elementary doc-
trine with eﬀective quotients, and it is the free such on P in the sense that, for every
elementary doctrine P: Cop 㨀→InfSL, pre-composition with the 1-morphism
Cop
P
)
J
op

InfSL
Qop
P
̂P
5
j ⋅

in ED induces an essential equivalence of categories
−∘(J, j): QED(̂P, Z) ≡ED(P, Z)
for every Z in QED.
As noticed in [Maietti and Rosolini, 2013a] the completion with quotients com-
mute with other ﬁbrational structure.
Proposition 3.7. Let P: Cop 㨀→InfSL be an elementary doctrine and consider its
quotient completion ̂P: Qop
P 㨀→InfSL. Then the following properties hold.

242
|
M. E. Maietti and G. Rosolini
1.
If P has comprehensions, then ̂P has comprehensions.
2.
If P has full comprehensions, then ̂P has full comprehensions and eﬀective quo-
tients are stable.
3.
If P is existential, then ̂P is existential.
Note that comprehension is not preserved by the embedding morphism (J, j): P →
̂P so swiftly (see [Maietti and Rosolini, 2013b,a]).
Proposition 3.8. Let P: Cop 㨀→InfSL be an elementary doctrine with comprehen-
sive diagonals. If P has full comprehensions, then (J, j) preserves them.
Moreover, the property of comprehensive diagonals is not necessarily inherited
by the free completion ̂P.
Therefore, if one wants to construct from an elementary doctrine P: Cop 㨀→
InfSL, in a free way, an indexed poset with eﬀective quotients which looks as much
as possible like the indexed poset of subobjects of the base category—i.e. the in-
dexed poset has full comprehension and comprehensive diagonals—, one must
go through a few steps:
1.
make sure that P has full comprehensions and comprehensive diagonals;
2.
add eﬀective quotients;
3.
force comprehensive diagonals.
As for step 1., in case P fails to have comprehensions or comprehensive diagonals,
these can be added freely, see e.g. [Maietti and Rosolini, 2013a].
Step 2. is just an application of 3.6.
Step 3. is accomplished by the construction after 2.9 once one checks that ̂Px
has eﬀective quotients. Moreover, full comprehensions are inherited by ̂Px, as well
as existential quantiﬁers, if P has them.
In the following sections, we shall analyze a situation which arises when
̂Px: ((QP)̂P)op 㨀→InfSL
is the ﬁbration of subobjects of its base category. We refer to such a doctrine ̂Px as
the elementary quotient completion of P.
4 The rule of unique choice
In this section we are going to show when an elementary quotient completion of
an elementary doctrine happens to be an exact category by making use of a choice
principle.

Relating Quotient Completions via Categorical Logic
|
243
As a ﬁrst step, it is useful to recall the deﬁnition of the exact completion of
an existential elementary doctrine introduced in [Maietti and Rosolini, 2015]; we
refer the reader to loc.cit. for the details, pointing out that there are many sources
in the literature which discuss various diﬀerent presentations of the completion,
e.g. [Kelly, 1992, Carboni, 1982, Carboni and Walters, 1987, Freyd and Scedrov,
1991, Jacobs, 1999, Hughes and Jacobs, 2002].
For the purpose of the following presentation, it is convenient to introduce a
preliminary concept which requires precisely the notion of existential elementary
doctrine.
Deﬁnition 4.1. Let P: Cop 㨀→InfSL be an elementary existential doctrine. Let ϕ
be an object in P(A × B). One says that ϕ is functional from A to B if the following
conditions hold:
–
ϕ is single-valued:
a: A, b: B, b耠: B | ϕ(a, b), ϕ(a, b耠) ⊢b =B b耠;
–
ϕ is total:
a: A | ⊤⊢∃b: B. ϕ(a, b).
Deﬁnition 4.2. An elementary existential doctrine P: Cop 㨀→InfSL satisﬁes the
rule of unique choice if, for pair of objects A and B, and every functional object ϕ
from A to B there is a morphism f: A →B in C such that
a: A | ⊤⊢ϕ(a, f(a)).
Example 4.3. The existential elementary doctrine S: Setop 㨀→InfSL of subsets sat-
isﬁes the rule of unique choice.
The reader may appreciate a very close relationship between the concept intro-
duced in 4.2 and that of a relation which is a function. Indeed, like for that one,
one can introduce a notion of functional composition as follows: for ϕ functional
from A to B and ψ functional from B to C, it is
∃b: B.[ϕ(a, b) ∧ψ(b, c)]
with a: A and c: C.
It should now appear clear that, for a given existential elementary doctrine
P: Cop 㨀→InfSL, there is a category FP of functional morphisms on it whose ob-
jects are the objects of C and where a morphism ϕ: A →B is a functional object
from A to B. Composition is functional composition; the identity morphism on A
is (a: A, a耠: A | a =A a耠) which is clearly functional from A to A, see [Freyd and
Scedrov, 1991].
There is a natural functor K: C 㨀→FP which is the identity on the objects and
maps f: A →B in C to the functional object (a: A, b: B | f(a) =B b) in P(A × B).
The functor K is faithful exactly when P has comprehensive diagonals.

244
|
M. E. Maietti and G. Rosolini
As K suggests, the data for FP appear as superimposed on C. So, in order to
avoid confusion, from now on we shall mark morphisms in FP with an asterisk as
follows ϕ: A →∗B.
Since the initial datum is an existential elementary doctrine, one expects to
determine a similar structure on FP. Indeed, the similarity with the set-theoretic
situation continues as one deﬁnes the indexed poset P+ as P+(A) := P(A) and, for
a morphism ϕ: A →∗B in FP, a homomorphism of inf-semilattices
P+(ϕ) := [( y: B | α(y) ) 㨃→( x: A | ∃y: B. (ϕ(x, y) ∧α(y)) )] .
The following result follows directly from the deﬁnition of the rule of unique
choice.
Proposition 4.4. Let P: Cop 㨀→InfSL be an existential elementary doctrine. P sat-
isﬁes the rule of unique choice if and only if its extensional reﬂection Px: Cop
P
㨀→
InfSL does.
Proof: It is obvious since the ﬁbres of Px are the same as those of P and there is
simply an existence condition on the morphism f in the rule of unique choice.
Proposition 4.5. The indexed inf-semilattice P+: Fop
P 㨀→InfSL is an existential el-
ementary doctrine with comprehensive diagonals which satisﬁes the rule of unique
choice. Moreover
Cop
P
)
K
op

InfSL
Fop
P
P+
6
id ⋅

is a 1-morphism in EED .
Proof: It is a direct computation after one notices that binary products are in-
duced by K, so the product of A and B is
A
A × B
K(pr1)
o
K(pr2)
/B.
Remark 4.6. In fact, (K, id) is a 2-reﬂection of EED into its full 2-subcategory on the
existential elementary doctrines with comprehensive diagonals which satisﬁes the
rule of unique choice. So (K, id) is an equivalence exactly when P: Cop 㨀→InfSL has
comprehensive diagonals and satisﬁes the rule of unique choice.
In fact, K is full if and only if P satisﬁes the rule of unique choice, and K is faithful
if and only if P has comprehensive diagonals.
Note that one obtains the exact completion EP of an elementary existential doc-
trine P in [Maietti and Rosolini, 2015] as the doctrine F̂P.

Relating Quotient Completions via Categorical Logic
|
245
Remark 4.7. It is easy to recognize that examples of exact completion for the deﬁ-
nition given here is the exact completion Xex/reg of a regular category X, see [Freyd
and Scedrov, 1991, Carboni, 1995, Carboni and Vitale, 1998], by taking the subobject
ﬁbration of X as P.
Other examples come from theories apt to formalize constructive mathemat-
ics: the category of total setoids à la Bishop and functional relations based on the
intensional type theory of the Minimalist Foundation in [Maietti, 2009], or the cat-
egory of total setoids à la Bishop and functional relations based on the Calculus of
Constructions [Coquand, 1990], which forms a topos as mentioned in [Barthe et al.,
2003].
Remark 4.8. Note that an existential elementary doctrine P: Cop 㨀→InfSL with
comprehensions has unique choice in the sense of [Jacobs, 1999] if and only if it
satisﬁes the rule of unique choice. So, it follows from 4.4.4 and 4.9.4 of loc.cit. that
the following are equivalent.
1.
C is a regular category and P is the doctrine of its subobject.
2.
P has full comprehensions, comprehensive diagonals and satisﬁes the rule of
unique choice.
Theorem 4.9. Let P: Cop 㨀→InfSL be an existential elementary doctrine with sta-
ble eﬀective quotients. The following are equivalent.
1.
C is an exact category and P is the doctrine of its subobjects.
2.
P has full comprehensions, comprehensive diagonals and satisﬁes the rule of
unique choice.
Proof: It follows from 4.8 because, for a subobject ﬁbration S: Cop 㨀→InfSL, an
S-equivalence relation is precisely an equivalence relation in C and an exact cate-
gory is a regular category with eﬀective coequalizers of equivalence relations.
Recall from [Maietti and Rosolini, 2015] the following rule of choice.
Deﬁnition 4.10. Given an existential elementary doctrine P: Cop 㨀→InfSL we say
that P satisﬁes the rule of choice if, for every ϕ ∈P(A × B) such that
a: A | ⊤⊢∃b: B.ϕ(a, b),
there is a morphism f: A →B in C such that
a: A | ⊤⊢ϕ(a, f(a)).
Clearly the rule of choice is stronger than the rule of unique choice since the re-
lations employed in the rule of unique choice are particular instances of those
which appear in the rule of choice.

246
|
M. E. Maietti and G. Rosolini
Proposition 4.11. Let P: Cop 㨀→InfSL be an existential elementary doctrine with
comprehensions. Then P satisﬁes the rule of choice if and only if its quotient com-
pletion ̂P: Qop
P 㨀→InfSL satisﬁes the rule of unique choice.
Proof: (⇒) Immediate.
(⇐) Suppose ϕ ∈P(A × B) is such that
a: A | ⊤⊢∃b: B.ϕ(a, b).
Consider the comprehension ℓ:= {|a: A, b: B | ϕ(a, b)|}: X →A × B and consider
the object
(X, (x: X, x耠: X | pr1(ℓ(x)) =A pr1(ℓ(x耠))))
in QP. It is immediate to check that (a: A, x: X | a =A pr1(ℓ(x))) is in
̂P((A, (a: A, a耠: A | a =A a耠)) × (X, (x: X, x耠: X | pr1(ℓ(x)) =A pr1(ℓ(x耠)))))
since it is just
a: A, a耠: A, x: X, x耠: X | a =A a耠, pr1(ℓ(x)) =A pr1(ℓ(x耠)), a =A pr1(ℓ(x)) ⊢
a耠=A pr1(ℓ(x耠)).
It is also easy to prove that (a: A, x: X | a =A pr1(ℓ(x))) is functional from
(A, (a: A, a耠: A | a =A a耠)) to (X, (x: X, x耠: X | pr1(ℓ(x)) =A pr1(ℓ(x耠)))) since
the existential quantiﬁers of ̂P are those of P as shown in [Maietti and Rosolini,
2013b].
Thanks to the assumption that ̂P satisﬁes the rule of unique choice, there is
f: A →X such that
a: A | ⊤⊢a =A pr1(ℓ(f(a))).
Hence the morphism pr2∘ℓ∘f: A →B is such that a: A | ⊤⊢ϕ(a, pr2(ℓ(f(a)))).
5 The rule of choice and exact completions
Lemma 5.1. Let P: Cop 㨀→InfSL be an existential elementary doctrine, and con-
sider the 1-morphism
((QP)̂P)op
̂Px
*
K耠
op

InfSL
(F̂P)op
̂P+
4
i ⋅

induced by the 1-morphism (K, id): ̂P →F̂P. The functor K耠is full (hence iso) if and
only if P satisﬁes the rule of choice.

Relating Quotient Completions via Categorical Logic
|
247
Proof: It follows from 4.4 and 4.11.
Theorem 5.2. Let P: Cop 㨀→InfSL be an existential elementary doctrine with com-
prehensive diagonals, full comprehensions and let ̂Px: ((QP)̂P)op 㨀→InfSL be its
elementary quotient completion. The following are equivalent.
1.
the base category (QP)̂P of the elementary quotient completion of P is an exact
category and ̂Px is its subobject doctrine.
2.
P satisﬁes the rule of choice.
3.
the base category (QP)̂P of the elementary quotient completionof P isequivalent
to the exact completion EP ≡F̂P of P and ̂Px is a subobject doctrine.
Proof: It follows from 5.1 and 4.9.
Remark 5.1. Note that proposition 4.11 and theorem 5.2 hold also if P has just weak
full comprehensions.
Examples 5.3. The setoid model over Martin-Löf’s type theory in [Maietti and
Rosolini, 2013b] and the elementary quotient completion of the doctrine of a lex
category (with a choice of its structure) provide examples of elementary quotient
completions which are exact since the rule of unique choice holds in the logic of the
quotient model.
6 The axiom of unique choice in an elementary
quotient completion
Proposition 4.11 continues to hold if we replace the rule of choice with the axiom
of choice and the rule of unique choice with the axiom of unique choice respec-
tively, provided that the doctrine P has implications and universal quantiﬁcations
and its base category is closed under (weak) function spaces. We recall the basic
notions to state that result.
Deﬁnition 6.1. An elementary doctrine P: Cop 㨀→InfSL is implicational if, for every
object A in C, every α in P(A), the functor α ∧–: P(A) →P(A) has a right adjoint
α ⇒–: P(A) →P(A).
Deﬁnition 6.2. An elementary doctrine P: Cop 㨀→InfSL is universal if, for A1 and
A2 in C and a(ny) projection pri: A1 × A2 →Ai, i = 1, 2, the functor Ppri: P(Ai) →
P(A1 × A2) has a right adjoint
A
pri, and these satisfy the Beck-Chevalley condition:

248
|
M. E. Maietti and G. Rosolini
for any pullback diagram
X耠
pr耠/
f 耠

A耠
f

X
pr
/ A
with pr a projection (hence also pr耠a projection), for any β in P(X), the canonical
arrow Pf
A
pr(β) ≤
A
pr耠Pf 耠(β) in P(A耠) is iso.
Deﬁnition 6.3. An elementary, existential, implicational and universal doctrine
P: Cop 㨀→InfSL with a cartesian closed base satisﬁes the axiom of unique choice,
(AUC) for short, if
(∀x: A.∃!y: B.ϕ(x, y)) →(∃f: BA.∀x: A.ϕ(x, f(x)))
holds in P.
As already noticed in [Maietti and Rosolini, 2013b] the completion with quotients
commute also with the ﬁbrational structure described above.
Proposition 6.4. Let P: Cop 㨀→InfSL be an elementary doctrine with full compre-
hensions and let ̂P: Qop
P
㨀→InfSL be its quotient completion. Then the following
properties hold.
1.
If C is cartesian closed then QP is cartesian closed.
2.
If P is implicational, then ̂P is implicational.
3.
If P is universal, then ̂P is universal.
Moreover, the 1-arrow (J, j): P →̂P preserves the implicational and universal struc-
ture of P.
Finally, we have:
Proposition 6.5. Let P: Cop 㨀→InfSL be an elementary existential implicational
and universal doctrine with a cartesian closed base and full comprehensions. Then
P satisﬁes the axiom of choice if and only if its quotient completion ̂P: Qop
P 㨀→InfSL
satisﬁes the axiom of unique choice.
Proof: The proof is similar to that of proposition 4.11.
(⇒) Immediate by the deﬁnition of right adjoints and implications in ̂P.
(⇐) Suppose ϕ ∈P(A × B) is P-relation. Consider the comprehension ℓ:=
{|a: A, b: B | ϕ(a, b)|}: X →A × B and the relation
(a: A, x: X | a =A pr1(ℓ(x)))
which is in
̂P((A, (a: A, a耠: A | a =A a耠)) × (X, (x: X, x耠: X | pr1(ℓ(x)) =A pr1(ℓ(x耠)))))

Relating Quotient Completions via Categorical Logic
|
249
Then, (AUC) holds in ̂P for that ̂P-relation and that yields that (AC) holds for ϕ in
P since the existential quantiﬁers, the universal quantiﬁers and implications of ̂P
are deﬁned in terms of those of P as shown in [Maietti and Rosolini, 2013b].
Remark 6.6. Observe that, as noticed in [Maietti, 2005], the subobject doctrine of
a locally cartesian closed regular category is implicational, universal and validates
the axiom of unique choice.
Remark 6.7. Note that proposition 6.4 and theorem 6.5 hold also if P has just weak
full comprehensions and its base is only weakly cartesian closed.
An example of this structure is the setoid model over Martin-Löf’s type theory of
example 5.3. A discussion on the validity of choice principles in such a structure can
be found in [Martin-Löf, 2006]. Proposition 6.5 gives an abstract account of what
happens in this example.
References
G. Barthe, V. Capretta, and O. Pons. Setoids in type theory. J. Funct. Programming, 13(2):261–
293, 2003.
A. Carboni. Analysis non-standard e topos. Rend. Istit. Mat. Univ. Trieste, 14(1-2):1–16, 1982.
ISSN 0049-4704.
A. Carboni. Some free constructions in realizability and proof theory. J. Pure Appl. Algebra,
103:117–148, 1995.
A. Carboni and R. Celia Magno. The free exact category on a left exact one. J. Aust. Math. Soc.,
33(A):295–301, 1982.
A. Carboni and E.M. Vitale. Regular and exact completions. J. Pure Appl. Algebra, 125:79–117,
1998.
A. Carboni and R.F.C. Walters. Cartesian bicategories, I. J. Pure Appl. Algebra, 49:11–32, 1987.
T. Coquand. Metamathematical investigation of a calculus of constructions. In P. Odifreddi,
editor, Logic in Computer Science, pages 91–122. Academic Press, 1990.
P.J. Freyd and G.M. Kelly. Categories of continuous functors I. J. Pure Appl. Algebra, 2:169–191,
1972.
P.J. Freyd and A. Scedrov. Categories Allegories. North Holland Publishing Company, 1991.
M. Grandis. Weak subobjects and the epi-monic completion of a category. J. Pure Appl. Alge-
bra, 154(1-3):193–212, 2000.
J. Hughes and B. Jacobs. Factorization systems and ﬁbrations: Toward a ﬁbred Birkhoﬀvariety
theorem. Electron. Notes Theor. Comput. Sci., 11:#, 2002. URL http://www.elsevier.nl/
locate/entcs/volume6.html.
J.M.E. Hyland. The eﬀective topos. In A.S. Troelstra and D. van Dalen, editors, The L.E.J.
Brouwer Centenary Symposium, pages 165–216. North Holland Publishing Company,
1982.
J.M.E. Hyland, P.T. Johnstone, and A.M. Pitts. Tripos Theory. Math. Proc. Camb. Phil. Soc., 88:
205–232, 1980.

250
|
M. E. Maietti and G. Rosolini
B. Jacobs. Categorical Logic and Type Theory. North Holland Publishing Company, 1999.
G.M. Kelly. A note on relations relative to a factorization system. In A. Carboni, M.C. Pedicchio,
and G. Rosolini, editors, Category Theory ’90, volume 1488 of Lecture Notes in Math.,
pages 249–261. Springer-Verlag, Como, 1992.
J. Lambek and P.J. Scott. Introduction to Higher Order Categorical Logic. Cambridge University
Press, 1986.
F. W. Lawvere. Adjointness in foundations. Dialectica, 23:281–296, 1969a.
F.W. Lawvere. Diagonal arguments and cartesian closed categories. In Category Theory, Homol-
ogy Theory and their Applications, II (Battelle Institute Conference, Seattle, Wash., 1968,
Vol. Two), pages 134–145. Springer, 1969b.
F.W. Lawvere. Equality in hyperdoctrines and comprehension schema as an adjoint functor. In
A. Heller, editor, Proc. New York Symposium on Application of Categorical Algebra, pages
1–14. Amer.Math.Soc., 1970.
F.W. Lawvere and R. Rosebrugh. Sets for Mathematics. Cambridge University Press, 2003.
Maria Emilia Maietti. Joyal’s arithmetic universe as list-arithmetic pretopos. Theory Appl.
Categ., 3:No. 24, 39–83, 2010.
M.E. Maietti. Modular correspondence between dependent type theories and categorical uni-
verses including pretopoi and topoi. Math. Structures Comput. Sci., 15(6):1089–1149,
2005.
M.E. Maietti. A minimalist two-level foundation for constructive mathematics. Ann. Pure Appl.
Logic, 160(3):319–354, 2009.
M.E. Maietti and G. Rosolini. Elementary quotient completion. Theory Appl. Categ., 27:445–
463, 2013a.
M.E. Maietti and G. Rosolini. Quotient completion for the foundation of constructive mathemat-
ics. Log. Univers., pages 371–402, 2013b.
M.E. Maietti and G. Rosolini. Unifying exact completions. Appl. Categ. Structures, 23:43–52,
2015.
M. Makkai and G. Reyes. First Order Categorical Logic, volume 611 of Lecture Notes in Math.
Springer-Verlag, 1977.
P. Martin-Löf. 100 years of Zermelo’s axiom of choice: what was the problem with it? The
Computer Journal, 49(3):10–37, 2006.
P. Taylor. Practical Foundations of Mathematics. Cambridge University Press, 1999. URL
ftp://ftp.dcs.qmw.ac.uk/pub/lfp/pt/book-contents.
J. van Oosten. Realizability: An Introduction to its Categorical Side, volume 152. North Holland
Publishing Company, 2008.

Roman Murawski
Some Historical, Philosophical
and Methodological Remarks on Proof
in Mathematics
Abstract: The paper is devoted to historical and philosophical as well as method-
ological considerations on the role and meaning of proof in mathematics. The role
of informal proofs in mathematical research practice is discussed. Next the con-
cept of formal proof is considered. The problem of the distinction: (formal) prov-
ability vs. truth is presented. Relations between informal and formal proofs are
discussed.
Keywords: Formal proof, Informal proof, Truth, Mathematical knowledge, Ax-
iomatic method
Mathematics Subject Classiﬁcation 2010: 00A30, 03A05, 00A35
1 Introduction
Proofs play an important role in mathematics and its methodology (in the con-
text of justiﬁcation). They form the main method of justifying mathematical state-
ments. Only statements that have been proved can be treated as belonging to the
corpus of mathematical knowledge. Proofs are used to convince the readers of the
truth of presented theorems. But what is in fact a proof? In mathematical research
practice proof is a sequence of arguments that should show the truth of the claim.
Of course the particular arguments used in a proof depend on the situation, on
the audience, on the type of a claim, etc. Hence a concept of a proof has in fact a
cultural, psychological and historical character. In practice mathematicians gen-
erally agree whether a given argumentation is or is not a proof. More diﬃcult is the
task to deﬁne a proof as such. Beside proofs used in the research practice there is
a concept of a formal proof developed by logic. What are the relations between
them? What roles do they play in mathematics?
Problems of that type will be considered in the paper. We start (Section 1) by
some historical remarks showing in what circumstance the idea of a proof (infor-
mal and formal) appeared. Next (Section 2) the features and role played by infor-
mal proofs will be considered. The subject of Section 3 will be formal proofs and
Roman Murawski: Adam Mickiewicz University, Faculty of Mathematics and Computer Science,
ul. Umultowska 87, 61–614 Poznań, Poland, e-mail: rmur@amu.edu.pl

252
|
R. Murawski
their relation to the concept of truth. In the closing Section 4 some conclusions
will be made and a thesis (similar to Church-Turing Thesis in the computation
theory) formulated.
2 Historical remarks
The model of mathematics as a science, its paradigm functioning in fact till today
was formulated and developed in the ancient Greece about the 4th century B.C.
Earlier, for example in ancient Egypt or Babylon mathematics consisted of prac-
tical procedures that should help to solve everyday problems such as measuring
surface area or the amount of cereal in a granary or oil in a jug. In those both pre-
Greek mathematics – though they were advanced and sophisticated (especially
the Babylonian mathematics) – there was no need to prove statements. In fact
there were no general statements and no attempts were undertaken to deduce the
results or to explain their validity. One was satisﬁed by instructions what should
be done in order to receive the result or to perform the required task. In fact mathe-
matics there was a collection of separate algorithms (as one would say today) and
resembled in certain sense informatics (though without sophisticated technical
equipment). Similar was the situation in China – Chinese mathematics was also
a collection of procedures (transferred from generation to generation).
Proofs as deduction from explicitly stated postulates was conceived by the
Greeks. It was connected with the axiomatic method. Since Plato, Aristotle and
Euclid the axiomatic method was considered as the best method to justify and to
organize mathematical knowledge. The ﬁrst mature and most representative ex-
ample of its usage in mathematics were the Elements of Euclid. They established
a pattern of a scientiﬁc theory and in particular a paradigm in mathematics. Since
Euclid till the end of the 19th century mathematics was developed as an axiomatic
– in fact rather a quasi-axiomatic – theory based on axioms, postulates and def-
initions. Axioms were principles common to all sciences, postulates – speciﬁc
principles taken for granted by a mathematician engaged in the demonstration
of theorems in a particular domain. Deﬁnitions should provide meaning to new
notions – in practice deﬁnitions were rather explanations of notions than proper
deﬁnitions in the strict sense, moreover, they were explanations in the unprecise
everyday colloquial language. Note that the language of a theory was not sepa-
rated from the natural language. Proofs of theorems contained several gaps – in
fact the lists of axioms and postulates were not complete, one freely used in proofs
various “obvious” truths or referred to the intuition. Consequently proofs were
only partially based on axioms and postulates. In fact proofs were informal and

Some Historical, Philosophical and Methodological Remarks on Proof
|
253
intuitive, they were rather demonstrations and the very concept of a proof was of
a psychological and sociological (and not of a logical) nature.
Note that the language of theories was simply the unprecise colloquial lan-
guage. Till the end of the 19th century mathematicians were convinced that ax-
ioms and postulates should be true statements, hence sentences describing the
real state of aﬀairs (in the mathematical reality).¹ It seems to be connected with
Aristotle’s view that a proposition is demonstrated (proved to be true) by showing
that it is a logical consequence of propositions already known to be true. Demon-
stration was conceived here of as a deduction whose premises are known to be
true and a deduction was conceived of as a chaining of immediate inferences.
It should be noted that the Euclid’s approach (connected with Platonic ide-
alism) to the problem of the development of mathematics and the justiﬁcation of
its statements (which found its fulﬁlment in the Euclidean paradigm), i.e. justi-
ﬁcation by deduction (by proofs) from explicitly stated axioms and postulates,
was not the only approach and method which was used in the ancient Greek (and
later). The other one (call it heuristic) was connected with Democritus’ materi-
alism. It was applied for example by Archimedes who used in his mathematical
works not only deduction but any methods, such as intuition or even experiments
(not only mental ones) to solve problems. One can see this, for example, in his
considerations concerning the calculation of the volume of a sphere using cylin-
der with two excavated cones or in his quadrature of the parable.
Though the Euclidean approach won and dominated in the history, one
should note that it formed rather an ideal and not the real scientiﬁc practice of
mathematicians. In fact rigorous, deductive mathematics was rather a rare phe-
nomenon. On the contrary, intuition and heuristic reasoning were the animating
forces of mathematical research practice. The vigorous but rarely rigorous math-
ematical activity produced “crises” (for example the Pythagoreans’ discovery of
the incommensurability of the diagonal and the side of a square, Leibniz’s and
Newton’s problems with the explanation of the nature of inﬁnitesimals, Fourier’s
“proof” that any function is representable in a Fourier series, antinomies con-
nected with Cantor’s imprecise and intuitive notion of a set).
New elements appeared in the 19th century with the trend whose aim was
the clariﬁcation of basic mathematical concepts, especially those of analysis (cf.
works by Cauchy, Weierstrass, Bolzano, Dedekind). Still another factor was the
discovery of antinomies, in particular in set theory (C. Burali-Forte, G. Cantor,
1 In fact the discussion about the truth of mathematical statements started already with the dis-
covery of non-Euclidean geometries but the conviction of the truth of mathematical theses dom-
inated.

254
|
R. Murawski
B. Russell) and of the semantical antinomies (G.D. Berry, K. Grelling). They forced
the revision of some basic ideas of mathematics. Among formulated proposals
was the foundational program of David Hilbert and his Beweistheorie. Note that
“this program was never intended as a comprehensive philosophy of mathemat-
ics; its purpose was instead to legitimate the entire corpus of mathematical knowl-
edge” [Rowe, 1989, p. 200].
The main role in Hilbert’s program was played by formal (or formalized)
proofs. This device was introduced on the basis of (and thanks to) the mathemat-
ical logic developed in the 19th century, in particular on the basis of the work
of Gottlob Frege who constructed the ﬁrst formalized system – it was the system
of propositional calculus based on two connectives: negation and implication.
Investigations carried out in the framework of Hilbert’s program established the
new scientiﬁc discipline, i.e., the metamathematics.
Recall that the concept of a formal proof must be related to a given formal
theory. To express such a theory one should at the beginning ﬁx its language. The
rules of forming formulas in it should have strictly formal and syntactic charac-
ter – only the shape of symbols can be taken into account and one should en-
tirely abstract from their possible meaning or interpretation. Next one ﬁxes ax-
ioms (logical, non-logical and usually identity axioms) and rules of inference.
The latter must have entirely syntactic and formal character. A formal proof of a
statement (formula) φ is now a ﬁnite sequence of formulas in the given language
φ1, φ2, . . . , φn such that the last member of the sequence is the formula φ and
all members of it either belong to the set of presumed axioms or are consequences
of previous members of the sequence according to one of the accepted rules of in-
ference. Observe that this concept of a formal proof has a syntactic character and
does not refer to any semantical notions such as meaning or interpretation.
As a result of the described development one has to deal nowadays in mathemat-
ics with at least two concepts of a proof: the formal one, used mainly by logicians
and specialists in metamathematics in the foundational studies as well as by com-
puter scientists (cf. modern theorem provers) and on the other hand the “normal”,
“usual” concept of a proof used in mathematical research practice. What are the
relations between them? Is the metamathematical concept a precise explication
of the “everyday” concept? Do they play similar roles in mathematics or not? To
what extent does the concept of a formal proof reﬂect the main features and the
nature of an informal proof used by mathematicians in their researches?

Some Historical, Philosophical and Methodological Remarks on Proof
|
255
3 Informal proofs and their role
Mathematics was and is developed in an informal way using intuition and heuris-
tic reasonings – it is still developed in fact in the spirit of Euclid (or sometimes of
Archimedes) in a quasi-axiomatic way. Moreover, informal reasonings appear not
only in the context of discovery but also in the context of justiﬁcation. Any correct
methods are allowed to justify statements. But what does it mean “correct”? In the
research practice this was and is decided by the community of mathematicians.
Consequently the criteria of being correct have been changing in the history and
in the process of developing mathematics. The concept of proof was and is in fact
not an absolute notion but it was and is culturally and sociologically dependent
and motivated, it had and has a cultural and sociological components. The main
aim of a mathematician is always to convince the audience that the given result is
justiﬁed, correct and true (the latter concept being used in an intuitive and vague
way) and not to answer the question whether it can be deduced from stated ax-
ioms. In the research practice a proof is in fact an argumentation that should in-
dicate the correctness of a claimed thesis – in particular its form depends on and
is relative to a background knowledge of those to whom the proof is presented.
And here appears a psychological moment in the understanding and functioning
of proofs.
The ultimate aim of mathematics is “to provide correct proofs of true theo-
rems” [Avigad, 2006, p. 105]. In their research practice mathematicians usually do
not distinguish concepts “true” and “provable” and often replace them by each
other. Mathematicians used to say that a given theorem holds or that it is true and
not that it is provable in such and such theory. In fact they do not distinguish con-
cepts ‘true’ and ‘provable’ and often replace them by each other Add that axioms
of theories being developed are not always precisely formulated and admissible
methods precisely described.
Proofs play various roles in the mathematical research practice. One can dis-
tinguish (cf. [De Villiers, 1999, CadwalladerOlsker, 2011]) among others the role
of:
(1) veriﬁcation,
(2) explanation,
(3) systematization,
(4) discovery,
(5) intellectual challenge,
(6) communication,
(7) justiﬁcation of deﬁnitions.

256
|
R. Murawski
The most familiar to research mathematicians is the role of veriﬁcation. A state-
ment can be treated as belonging to the body of mathematics only when it has
been veriﬁed. The proof should not only show that a given sentence is true and
holds but should also explain why it is true and holds. This role explains why
mathematicians are often looking for new proofs of known theorems – new proofs
should have more explanatory power. The role of systematization was exempliﬁed
already by Euclid’s Elements. In this work many theorems known to Greeks have
been collected and organized in such a way that they followed from axioms, pos-
tulates, deﬁnitions and previously proved theorems. It was shown in this way that
the accepted axioms, postulates and deﬁnitions form a suﬃcient base on which
the whole ediﬁce of mathematics can be developed. Note that the role of discovery
may be – prima facie – rather seldom associated with proofs but it is not excluded.
In fact, e.g., non-Euclidean geometries were arrived at through purely deductive
means. Recall that since Euclid one asked the question whether the ﬁfth postu-
late on parallels formulated in Elements is independent of other axioms and pos-
tulates or can be deduced from them. After several attempts undertaken through
the centuries it has been shown in the 19th century that it is reasonable to con-
sider systems of geometry in which the negation of the ﬁfth postulate is assumed
instead of the ﬁfth postulate itself and it is possible to show that such systems are
consistent.
Finding proofs is the intellectual challenge for mathematicians: there is a the-
orem – we want to prove it. Proofs serve in the community of mathematicians
as communication means. They communicate not only the reasons why a given
statement is a true theorem but introduce also new methods which can be used
sometimes in other domains. Proofs can provide also justiﬁcation of deﬁnitions.
The most important roles played by proofs in the research mathematical prac-
tice are of course veriﬁcation and explanation. Note that a proof that veriﬁes a the-
orem does not have to explain why it holds. One can distinguish between proofs
that convince and proofs that explain. The former should show that a statement
holds or is true and can be accepted, the latter – why it is so. Of course there are
proofs that both convince and explain. The explanatory proof should give an in-
sight in the matter whereas the convincing one should be concise or general.
One can distinguish also between explanation and understanding. Mathe-
maticians often treat simplicity as a characteristic feature of understanding. Ob-
serve that, as G.-C. Rota writes in [1997, p. 192]:
[i]t is an article of faith among mathematicians that after a new theorem is discovered, other,
simpler proof of it will be given until a deﬁnitive proof is found.

Some Historical, Philosophical and Methodological Remarks on Proof
|
257
In this context it is worth distinguishing between unveiling proofs and consolidat-
ing ones. The former one is “a proof which proves a theorem which was unknown
before” and the latter is “a proof of a theorem which is already known to be true”
[Kahle, 2015]. Proofs of the second type do not contribute to the truth of a theo-
rem – they consolidate our knowledge of this truth. Such a proof can be quite
diﬀerent from the original one. Aschbacher wrote about this phenomenon in the
following way [2005, p. 2403]:
The ﬁrst proof of a theorem is usually relatively complicated and unpleasant. But if the re-
sult is suﬃciently important, new approaches replace and reﬁne the original proof, usually
by embedding it in a more sophisticated conceptual context, until the theorem eventually
comes to be viewed as an obvious corollary of a larger theoretical construct. Thus proofs
are a means for establishing what is real and what is not, but also a vehicle for arriving at a
deeper understanding of mathematical reality.
There are many examples from the history of mathematics that conﬁrm this. In
this context one can mention Paul Erdős’ idea of proofs from The Book in which
God maintains the perfect proofs for mathematical theorems – he followed the
dictum of G.H. Hardy that there is no permanent place for ugly mathematics. Erdős
stressed that one need not believe in God but, as a mathematician, one should
believe in The Book.²
Note that a proof that convinces can be more (or even quite) formal. Explana-
tory proofs cannot be strictly formal. Mathematicians set a high value on explana-
tory proofs. Such a proof is more valued when “it exhibits methods that are power-
ful and informative” [Avigad, 2006, p. 106]. Hersh says in [1997, p. 60] that “[p]roof
is a tool in service of research, not a shackle on the mathematician’s imagina-
tion”.³
Sometimes theorems are veriﬁed in mathematics by checking all particular
cases but this usually does not give an explanation why the theorem holds. The
explanation should give a general principle by which the theorem holds. A famous
example of a theorem veriﬁed by checking cases but not giving reasons is the Four-
Color Theorem proved by Appel and Haken and stating that every planar graph is
four-colorable, i.e., in another words, that four colors suﬃce to color every map
on the plane in such a way that two regions receive diﬀerent colors whenever they
have a common border.
2 In 1998 Springer Verlag published Proofs From The Book by M. Aigner and G.M. Ziegler (cf.
[Aigner and Ziegler, 1998]). It is treated by the authors as “a ﬁrst (and very modest) approximation
of The Book” (Preface).
3 On the concept of explanation in mathematics see for example [Steiner, 1978] and [Mancosu,
2000] and [Mancosu, 2001].

258
|
R. Murawski
The example of the Four-Color Theorem indicates other features of proofs in
mathematics. Observe that the ﬁrst purported proof of it given by Kempe in 1879
was accepted for a decade before it was found to be incorrect. This was neither
the ﬁrst nor the last example of such a situation. It means that the community of
mathematicians can be fallible.
The Four-Color Theorem opened eyes of philosophers of mathematics to the
problem of methods acceptable in a proof or in a veriﬁcation of cases. The unique
known proof – that by Appel and Haken – was obtained by using computer and no
traditional proof (without computer) is known so far. Moreover the existing proof
cannot be made by a human being because an essential part of it was a compu-
tation requiring about 1200 hours of computer time and is beyond the capacities
of any mathematician. This initiated a discussion concerning the admissibility of
experimental methods in mathematical proofs. Several arguments pro and contra
have been formulated – we will not enter here the details of the discussion. Let us
say only that the usage of a technical tool (like a computer) seems to refute the
commonly accepted thesis that mathematical knowledge is a priori. There arises
also a question whether a computer-aided proof is (or can be treated as) a math-
ematical proof and consequently, whether in particular the Four-Color Theorem
can be called “theorem” or it is still rather a hypothesis.
In this debate initiated by a paper by Tymoczko [1979] a question was asked
what are in fact the characteristic features of a “normal” mathematical proof. Ty-
moczko says that a proof in mathematics should be:
(1) convincing,
(2) surveyable,
(3) formalizable.
The ﬁrst feature is – as Tymoczko says – of an “anthropological” character, the
other two are treated by him as “deep features”. He claims also that “surveyability
and formalizability can be seen as two sides of the same coin” [Tymoczko, 1979,
p. 61]. Formalizability “idealizes surveyability, analyzes it into ﬁnite reiterations
of surveyable patters” (ibidem). It can be assumed that all surveyable proofs are
formalizable. Are also all formalizable proofs surveyable? Tymoczko answers this
negatively: “[w]e know that there must exist formal proofs that cannot be surveyed
by mathematicians if only because the proofs are too long or involve formulas
that are too long” and the phrase “too long” means here “can’t be read over by
a mathematician in a human life time” (ibidem). On the other hand one should
observe that “it is not at all obvious that mathematicians could come across formal
proofs and recognize them as such without being able to survey them” [Tymoczko,
1979, p. 62].

Some Historical, Philosophical and Methodological Remarks on Proof
|
259
Considering surveyability one should distinguish local and global surveyabil-
ity. Bassler in [2006, p. 100] characterizes them in the following way:
local surveyability requires the surveying of each of the individual steps in a proof in some
order, while global surveyability requires the surveying of the entire proof as a comprehen-
sive whole.
Hence a local surveyability does not mean that a proof is practically surveyable.
One can say that the proof of the Four-Color Theorem is globally surveyable with-
out being locally surveyable (provided one is willing to countenance a distinction
between proof and calculation). On the other hand if one accepts the assump-
tion that global surveyability receives its foundation in local surveyability then
this statement is false. Add that one should also distinguish the surveyability of a
proof and the fact that it can be (formally) checked on the one hand and the fact
that it gives an understanding, that it reveals the deep reasons for the theorem
being proved.
The concept of surveyability is not precise enough. In the 20th century there
was a trend to link surveyability with the development of formal and complete
foundations of mathematics and formalization was treated as a method providing
the local surveyability. The works of Frege, Russell and their followers, especially
Hilbert, were guided by the desire to ﬁnd a perspicuous syntactic representation
of the relations of semantic content within a proposition.
Computers and methods connected with them were and are used in mathe-
matics not only in the proof of the Four-Color Theorem. They are used in various
contexts in mathematics, in particular:
(1) to perform numerical calculations,
(2) to ﬁnd (usually approximate) solutions of equations and systems of algebraic
or diﬀerential equations or of integrals,
(3) in automating proofs of theorems,
(4) in checking the correctness of mathematical proofs,
(5) in proving theorems (one says then about computer-aided proofs),
(6) in various experiments with mathematical objects (e.g., in the theory of frac-
tals).
From our point of view the most important applications are (3) and (4) – the appli-
cation of the type (5) has been discussed above on the example of the Four-Color
Theorem.
The automating proving of theorems is connected with the idea of mecha-
nization and automatization of reasoning due to Leibniz (cf. [Marciszewski and

260
|
R. Murawski
Murawski, 1995]). This idea (as one of the factors) led to the development of for-
mal logic and in consequence to the idea of a formal proof.
4 Formal proofs and their role
Formal proofs were introduced to provide an explication of the informal notion
of a proof and to solve some metamathematical problems. They should explain
the virtue by which usual proofs used in the research practice are judged to be
correct. They should also explain what does it mean that a given statement is a
logical or deductive consequence of certain assumptions. As indicated above they
were introduced in the atmosphere of a crisis in the foundations of mathematics.
For Frege and Russell they were means to an end, a way of precisely isolating the
permissible proofs and making sure that all use of axioms was explicit. On the
other hand observe that Hilbert was not really interested in actually formalizing
proofs and replacing the “normal” research proofs by formalized ones. He treated
formalization and formal proofs as a tool to justify mathematics as a science and
to establish its consistency. They should serve theoretical purposes – in particular
to prove results about mathematics, hence to obtain metamathematical results.
In fact, the development of logic and the concept of a formal proof based only
on syntactical properties made possible the development of metamathematics. A
lot of interesting results have been obtained here. First of all the old paradigm of
mathematics that was functioning since Euclid has been made precise – in fact
it has been replaced by a new logico-settheoretical paradigm (cf. [Batóg, 1996]).
The main features of this new paradigm can be described as follows:
1.
Set theory became the fundamental domain of mathematics, in particular
some set-theoretical notions and methods are present in any mathematical
theory and set theory is the basis of mathematics in the sense that all mathe-
matical notions can be deﬁned by primitive notions of set theory and all the-
orems of mathematics can be deduced from axioms of set theory.
2.
Languages of mathematical theories are strictly separated from the natural
language, they are artiﬁcial languages and the meaning of their terms is de-
scribed exclusively by axioms; some primitive concepts are distinguished and
all other notions are deﬁned in terms of them according to precise rules of
deﬁning notions.
3.
Mathematical theories have been axiomatized.
4.
There is a precise and strict distinction between a mathematical theory and
its language on the one hand and metatheory and its metalanguage on the
other (the distinction was explicitly made by A. Tarski).

Some Historical, Philosophical and Methodological Remarks on Proof
|
261
Note also that two concepts, crucial for mathematics: the concept of a syntactical
consequence (being provable) and the concept of being a semantical consequence
have been precisely deﬁned and strictly distinguished. One could also precisely
distinguish provability and truth. In a “normal” research mathematical practice–
as we indicated above – they are usually identiﬁed or at least not distinguished–
one says that a theorem holds, i.e., has been proved (in a “normal”, informal sense
of this notion), or that it is true and treats both as equivalent and synonymous. The
very process of distinguishing them was long and not so simple – cf. [Murawski,
2002a] and [Murawski, 2002b]. The crucial role was played here by Gödel’s incom-
pleteness theorems.
The incompleteness results of Gödel showed that any theory (based on a re-
cursive set of axioms and ﬁnitary rules of inference) including arithmetic of natu-
ral numbers is in fact incomplete, hence there exist sentences that are true but are
neither provable nor refutable, i.e., they are undecidable in a given theory. Before
Gödel it was believed that formal demonstrability is an analysis of the concept of
mathematical truth. Gödel wrote in a letter of 7th March 1968 to Hao Wang (cf.
[Wang, 1974, p. 10]):
[...] formalists considered formal demonstrability to be an analysis of the concept of math-
ematical truth and, therefore were of course not in a position to distinguish the two.
Indeed, the informal concept of truth was not commonly accepted as a deﬁnite
mathematical notion at that time.⁴ Gödel wrote in a crossed-out passage of a draft
of his reply to a letter of the student Yossef Balas: “[...] a concept of objective
mathematical truth as opposed to demonstrability was viewed with greatest sus-
picion and widely rejected as meaningless” (cf. [Wang, 1987, pp. 84–85]). It is
worth comparing this with a remark of R. Carnap. He writes in his diary that when
he invited A. Tarski to speak on the concept of truth at the September 1935 Interna-
tional Congress for Scientiﬁc Philosophy, “Tarski was very sceptical. He thought
that most philosophers, even those working in modern logic, would be not only
indiﬀerent, but hostile to the explication of the concept of truth”. And indeed at
the Congress “[...] there was vehement opposition even on the side of our philo-
sophical friends” (cf. [Carnap, 1963, pp. 61–62]).
All these explains in some sense why Hilbert preferred to deal in his meta-
mathematics solely with forms of formulas, using only ﬁnitary reasonings which
were considered to be save – contrary to semantical reasonings which were non-
ﬁnitary and consequently not save. Non-ﬁnitary reasonings in mathematics were
4 Note that there was at that time no precise deﬁnition of truth — this was given only in 1933 by
A. Tarski (cf. [Tarski, 1933]).

262
|
R. Murawski
considered to be meaningful only to the extent to which they could be interpreted
or justiﬁed in terms of ﬁnitary metamathematics.⁵
On the other hand there was no clear distinction between syntax and seman-
tics at that time. Recall for example that the axiom systems came by Hilbert often
with a built-in interpretation. Add also that the very notions necessary to formu-
late properly the diﬀerence syntax–semantics were not available to Hilbert though
he was aware of the complex of problems – cf. his statement of the question in
Hilbert and Ackermann [1928] which led to Gödel’s completeness theorem.
Gödel proved that truth can not be adequately achieved and expressed by
provability, that the whole of mathematics (or even parts of it) cannot be included
in a formalized system. This indicated certain weakness of the concept of a formal
proof. Gödel’s results showed also that one should not limit or bound the creative
invention of mathematicians. In the framework of formalized theories one can ex-
tend them by adding new axioms or by admitting new inference rules. The second
possibility means that inﬁnitary rules are admitted – but this changes the whole
picture and the whole paradigm! Note that Hilbert had in fact no problem with
such a change, to the opposite – in view of Gödel’s result – he encouraged it. On
the other hand one can ask whether the process of adding new axioms, though
necessary to solve problems undecidable in a given theory, is suﬃcient? Will it
suﬃce to express the creativity of a mathematical mind, the creativity of mathe-
maticians?
The incompleteness theorems of Gödel belong to the so called limitation re-
sults. They are results stating that certain properties important and desired from
a metamathematical point of view (but also from the point of view of a work-
ing mathematician) cannot be achieved. Among them is the theorem of Tarski
stating the undeﬁnability of the concept of truth and the theorem of Löwenheim
and Skolem showing that a mathematical structure cannot be adequately and
uniquely described by a formalized theory (a theory having a model has in fact
many various models). Tarski wrote (cf. [Tarski, 1969, p. 74]):
5 Cf. Gödel’s letter to Hao Wang dated 7th December 1967 — see [Wang, 1974, p. 9]. He wrote there:
„I may add that my objectivist conception of mathematics and metamathematics in general, and
of transﬁnite reasoning in particular, was fundamental also to my other work in logic. How in-
deed could one think of expressing metamathematics in the mathematical systems themselves,
if the latter are considered to consist of meaningless symbols which acquire some substitute of
meaning only through metamathematics. [...] it should be noted that the heuristic principle of
my construction of undecidable number theoretical propositions in the formal systems of math-
ematics is the highly transﬁnite concept of ‘objective mathematical truth’ as opposed to that of
‘demonstrability’ (cf. M. Davis, The Undecidable, New York 1965, p. 64 where I explain the heuris-
tic argument by which I arrive at the incompleteness results), with which it was generally con-
fused before my own and Tarski’s work.”

Some Historical, Philosophical and Methodological Remarks on Proof
|
263
It was undoubtedly a great achievement of modern logic to have replaced the old psycho-
logical notion of proof, which could hardly ever be made clear and precise, by a new simple
notion of a purely formal character. But the triumph of the method carried with it the germ
of a future setback.
Considerations concerning formal proofs enlightened also the role played by in-
ﬁnity in mathematics, in particular in the process of proving. Gödel’s results show
that ﬁnite/ﬁnitistic methods of syntactical formal provability do not exhaust the
variety of mathematical truth. In fact, if one wants to obtain a complete theory
then some inﬁnite/inﬁnitistic rules (such as, e.g., the ω-rule) are necessary. Re-
call that the ω-rule is an inference rule with inﬁnitely many premisses, i.e., it is
the following rule:
φ(0), φ(1), φ(2), . . . , φ(n), . . .
(n ∈ℕ)
∀xφ(x)
.
In mathematical research practice nobody restricts himself/herself to ﬁnite meth-
ods, on the contrary, any correct methods, among them inﬁnite (in particular set-
theoretical and semantical) are applied.
Being not so ideal as it was hoped, formal proofs play an important role in
metamathematics, i.e., in the study of mathematical theories or of mathematics
as a collection of theories – but not only there. They enable also the automati-
zation and mechanization of proofs in mathematics, hence they make possible
the construction of automated proofs and the veriﬁcation of proofs by computers.
Veriﬁcation of (formal) proofs is possible because the relation “x is a proof of y”
is – as was shown in mathematical logic – recursive, hence eﬀective and can be
implemented. On the other hand constructing and ﬁnding proofs is not an eﬀec-
tive (recursive) procedure, there is no universal method of doing this (as results of
Turing, Church and Gödel show). In fact it is only recursively enumerable. Hence
every formal proof is a result of a creative invention of a human being. One can say
that “[f]ormalization is about checking, and not about discovery” (cf. [Wiedijk,
2008, p. 1414]).
Observe that the concept of a formalized proof is one for all theories, it is in
a sense a uniform concept. It is independent of subjective, cultural and sociolog-
ical elements and factors. Moreover, the completeness theorem of Gödel states
that the logical means of the ﬁrst-order logic (ﬁrst-order predicate calculus) are
suﬃcient.⁶ This concept enables us to make the concept of a proof more objective.
It also makes possible the precise study of provability in mathematics – under
6 Note that in the case of, e.g., second-order logic the situation is diﬀerent – one does not have
here the completeness phenomenon.

264
|
R. Murawski
the assumption that the logical concept of a proof reﬂects all important and es-
sential features of proofs from the research practice of mathematicians. One can
prove results stating that a given statement is not a theorem of a given theory, i.e.,
that there exist no (formal) proof of a given statement or that a given sentence
is (formally) undecidable (in a given theory). It enables also the study of impor-
tant metamathematical properties of mathematical theories such as consistency,
completeness, independence of axioms or axiomatizability in a given way, etc.
The concept of a formal proof is also helpful in the philosophy of mathemat-
ics. It can be used in attempts to answer the question about the existence and cha-
racter of mathematical objects as well as in considerations concerning the epis-
temology of mathematics. On the other hand all philosophies of mathematics re-
ducing mathematics to formalized axiomatic theories (among them logicism and
formalism) have a reductionist character and do not take into account the actual
research practice of mathematicians. Their aim is to justify mathematics and not
to explain the real mathematical practice. It is worth noting that in recent trends in
the philosophy of mathematics still more and more attention is paid to the study
of the research practice in mathematics – one takes into account various socio-
logical, psychological and cultural factors. Unfortunately it is done only by the
analysis of particular single discoveries and achievements, hence by case stud-
ies. There are no general conceptions. But is it possible to develop such general
conceptions?
In fact formal proofs are connected rather with foundational studies than with
research practice. Observe that a formal proof does not give an understanding, it
does not explain the deep reasons of a theorem. They are also not suitable for the
practice – they are simply too long, they are too tedious and painstaking. In such a
proof the underlying intuition may get lost. Formalized mathematics may be also
more error-prone than the usual informal one – in fact formal manipulations may
become very complicated. As Bourbaki wrote (cf. [Bourbaki, 1968]):
If formalized mathematics were as simple as the game of chess, then once our chosen for-
malized language had been described there would remain only the task of writing out proofs
in this langauge, [...] But the matter is far from being as simple as that, and no great experi-
ence is necessary to perceive that such a project is absolutely unrealizable: the tinest proof
at the beginning of the Theory of Sets would already require several hundreds of signs for
its complete formalization. [...] formalized mathematics cannot in practice be written down
in full, [...] We shall therefore very quickly abandon formalized mathematics, [...]
CadwalladerOlsker writes in [CadwalladerOlsker, 2011, p 42]:
A purely formal proof [...] cannot be very complex without becoming so lengthy as to be
incomprehensible to a human reader. Such a formal proof is rarely able to be explanatory,

Some Historical, Philosophical and Methodological Remarks on Proof
|
265
and may only be convincing to the degree that it can be read and understood by the reader
or checked by a computer.
Add that a transcription of a single traditional (hence informal) proof into a formal
one is a major undertaking.
5 Conclusion
We have shown that one has two concepts of a proof in mathematics: an informal
one used by mathematicians in their usual research practice and the concept of a
formal or formalized proof used mainly in logic and the foundations of mathemat-
ics. The ﬁrst one is not deﬁned precisely, it is simply practised and any attempts
to deﬁne it fail. It is – so to speak – a practical notion. It has a psychological, so-
ciological and cultural character. The second one is precisely deﬁned in terms of
logical concepts. Hence it is a logical concept having rather theoretical than prac-
tical character. The ﬁrst one has – in a part at least – semantical character, the
second is entirely syntactical in nature.
Hence this situation can be compared with the situation concerning Church-
Turing thesis. This thesis states the equivalence of two concept: eﬀective com-
putability (in the intuitive sense) and recursivity (or Turing computability or com-
putability in the sense of Markov or any other precisely deﬁned and equivalent
sense). As is known this equivalence cannot be proved with the degree of preci-
sion usual and required in mathematics. The reason is that one part of this equiv-
alence contains an intuitive vague concept formulated in the everyday language
and the other a precise concept deﬁned in the language of mathematics (cf. [Mu-
rawski, 2004], [Murawski and Woleński, 2006]).
With such a situation one has to do also in other parts of mathematics – see
for example the concepts of function, of truth, of logical validity or of limit (cf.
[Mendelson, 1990]). In fact, till the 19th century a function was tied to a rule for
calculating it, generally by means of a formula. In 19th and 20th centuries math-
ematicians started to deﬁne a function as a set of ordered pairs satisfying appro-
priate conditions (hence a function is identiﬁed here with its graph). The identiﬁ-
cation of those notions, i.e., of an intuitive notion and the precise set-theoretical
one, can be called “Peano thesis”. Similarly “Tarki’s thesis” is the thesis identi-
fying the intuitive notion of truth and the precise notion of truth given by Tarski
in [1933]. The intuitive notion of a limit widely used in mathematical analysis in
the 18th century and then in the 19th century applied by A. Cauchy to deﬁne basic
notions of the calculus has been given a precise form only by K. Weierstrass in the

266
|
R. Murawski
language of ε −δ. There are many other such examples: the notion of a measure
as an explication of area and volume, the deﬁnition of dimension in topology, the
deﬁnition of velocity as a derivative, etc.
Comparing the two concepts of a proof in mathematics one can formulate
a thesis stating that they are equivalent – one can call such a thesis a proof-
theoretical thesis.⁷ As in the case of Church Thesis, no precise and strict proof of it
can be given.⁸ One can only formulate arguments in favor or against it. The main
argument for this thesis is the conviction – being popular among mathemati-
cians and logicians – that every “normal” mathematical proof can be formalized,
i.e., can be written as a formal proof in a suitable axiomatic theory. There are, of
course, no general rules describing how this can and should be done. In fact a for-
malization of an informal proof requires often some original and not so obvious
ideas.
In this way we come to the following conclusion: there are two concepts of a
proof in mathematics. They play diﬀerent but complementary roles: formal proofs
are used mainly in metamathematical and logical considerations, whereas infor-
mal proofs are used in the research practice of mathematicians.
Acknowledgment: The paper is based on my talks at the conferences “Philosophy
in Science” (Kraków, Poland, 2012) and “Proof” (International Conference within
the frame of Humboldt-Kollegs; Bern, Switzerland, 2013). I would like to thank the
referee for helpful comments and suggestions.
References
M. Aigner and G. M. Ziegler. Proofs From The Book. Springer Verlag, Berlin/Heidelberg/New
York 2001, third edition 2004, second edition, 1998.
M. Aschbacher. Highly complex proofs and implications of such proofs. Philosophical Transac-
tions of the Royal Society A, 363:2401–2406, 2005.
J. Avigad. Mathematical method and proof. Synthese, 153:105–159, 2006.
7 Add that this formulation is consciously rather vague – for example it is not speciﬁed here in
which formal theory (or theories) formal proofs should be constructed and what should be the
underlying logic. A similar but stronger thesis was formulated by Barwise [1977, p. 41] under the
name “Hilbert’s Thesis” where he wrote: “ ...the informal notion of provable used in mathematics
is made precise by the formal notion provable in ﬁrst-order logic. Following the sug[g]estion of
Martin Davis, we refer to this view as Hilbert’s Thesis”. This thesis says that ﬁrst-order logic is the
logic of mathematics.
8 Note that in the case of Church Thesis the formal framework is precisely speciﬁed: the intuitive
notion of computability should be captured by one speciﬁc formal model of computation.

Some Historical, Philosophical and Methodological Remarks on Proof
|
267
J. Barwise. An introduction to ﬁrst-order logic. In J. Barwise, editor, Handbook of Mathematical
Logic, pages 5–46. North-Holland, Amsterdam–New York–Oxford, 1977.
G. B. Bassler. The surveyability of mathematical proof: a historical perspective. Synthese, 148:
99–133, 2006.
T. Batóg.
Dwa paradygmaty matematyki. Studium z dziejów i ﬁlozoﬁi matematyki ().
Wydawnictwo Naukowe Uniwersytetu im. Adama Mickiewicza, Poznań, 1996. Two
Paradigms of Mathematics. A Study in the history and Philosophy of Mathematics.
N. Bourbaki. Theory of Sets. Addison-Wesley, Reading, Mass, 1968.
T. CadwalladerOlsker. What do we mean by mathematical proof? Journal of Humanistic Mathe-
matics, 1:33–60, 2011.
R. Carnap. Intellectual autobiography. In P. A. Schilpp, editor, The Philosophy of Rudolf Carnap,
pages 3–84. Open Court, La Salle, Ill., 1963.
M. D. De Villiers. Rethinking Proof with the Geometer’s Sketchpad. Key Curriculum Press,
Emeryville, CA, 1999.
R. Hersh. What Is Mathematics, Really? Oxford University Press, New York, 1997.
D. Hilbert and W. Ackermann. Grundzüge der theoretischen Logik. Springer, Berlin, 1928.
R. Kahle. What is a proof? Axiomathes, 25:79–91, 2015. 10.1007/s10516-014-9252-9.
P. Mancosu. On mathematical explanation. In E. Grosholz and H. Breger, editors, The Growth of
Mathematical Knowledge, pages 103–119. Kluwer Academic, Dordrecht, 2000.
P. Mancosu. Mathematical explanation: problems and prospects. Topoi, 20:97–117, 2001.
W. Marciszewski and R. Murawski. Mechanization of Reasoning in a Historical Perspective.
Editions Rodopi, Amsterdam/Atlanta, GA, 1995.
E. Mendelson. Second thoughts about church’s thesis and mathematical proofs. The Journal of
Philosophy, 87:225–233, 1990.
R. Murawski. Truth vs. provability – philosophical and historical remarks. Logic and Logical
Philosophy, 10(2002):93–117, 2002a.
R. Murawski. On the distinction proof-truth in mathematics. In P. Gärdenfors et al., editors,
In the Scope of Logic, Methodology and Philosophy of Science, pages 287–303. Kluwer
Academic, Dordrecht–Boston–London, 2002b.
R. Murawski. Church’s thesis and its epistemological status. Annales Universitatis Mariae
Curie-Skłodowska, Sectio AI, Informatica, 2(2004):57–70, 2004.
R. Murawski and J. Woleński. The status of Church’s thesis. In J. Woleński A. Olszewski and
R. Janusz, editors, Church’s Thesis After 70 Years, pages 310–330. Ontos, Frankfurt, 2006.
G.-C. Rota. The phenomenology of mathematical proof. Synthese, 111:183–196, 1997.
D. E. Rowe. Klein, Hilbert, and the Göttingen mathematical tradition. Osiris, 2(5):186–213,
1989.
M. Steiner. Mathematical explanation. Philosophical Studies, 34:133–151, 1978.
A. Tarski. Pojęcie prawdy w językach nauk dedukcyjnych. Nakładem Towarzystwa Naukowego
Warszawskiego, Warszawa, 1933.
A. Tarski. Truth and proof. Scientiﬁc American, 220(6):63–77, 1969.
T. Tymoczko. The four-color problem and its philosophical signiﬁcance. The Journal of Philoso-
phy, 76:57–83, 1979.
Hao Wang. From Mathematics to Philosophy. Routledge and Kegan Paul, London, 1974.
Hao Wang. Reflections on Kurt Gödel. M.I.T. Press, Cambridge, Mass, 1987.
F. Wiedijk. Formal proof – getting started. Notices of the American Mathematical Society, 55:
1408–1414, 2008.


Sara Negri and Jan von Plato
Cut Elimination in Sequent Calculi
with Implicit Contraction, with a Conjecture
on the Origin of Gentzen’s Altitude Line
Construction
Abstract: Sequent calculi are given in which contexts represent ﬁnite sets of for-
mulas. Standard cut elimination will not work if the principal formula of a logical
rule is already found in a premiss, i.e., if there is an implicit contraction on it. A
procedure is given in which cut with the original cut formula is ﬁrst permuted up,
followed by cuts on its immediate subformulas. It is next adapted to sequent cal-
culi with multisets and explicit contraction, by which Gentzen’s mix rule trick is
avoided, a procedure strikingly similar to the peculiar “altitude line” construction
that Gentzen used in his second proof of the consistency of arithmetic in 1938. The
conjecture is close at hand that this is indeed the way Gentzen originally proved
cut elimination in 1933.
Keywords: Cut elimination, Contraction, Altitude line
Mathematics Subject Classiﬁcation 2010: 01A60, 03-03, 03F07
1 Introduction
Axiomatic logic began with Frege and was perfected in the Hilbert school in the
1920s, with the aim to apply it in the formalization of mathematical proofs. The
crucial deduction theorem shows how this goes: Given some axiomatic system
with axioms H expressed in the language of logic, it should be possible to treat
it, not as a collection of truths added to the logical axioms, but as hypotheses.
Thus, derivations in axiomatic logic were extended to include derivations under
hypotheses, as in the book that ﬁrst deﬁned a complete formal system of predicate
logic, [Hilbert and Ackermann, 1928], and very soon the aim was reached: A proof
of a proposition P by the mathematical axioms can be converted into a purely lo-
gical proof of the implication H⊃P. The matter is not as trivial as it might seem:
Say, if A(x) is provable without assumptions, ∀xA(x) can be concluded, whereas
if A(x) is proved under assumptions, nothing of the kind need follow.
Sara Negri and Jan von Plato: Department of Philosophy, University of Helsinki, Finland,
e-mail: jan.vonplato@helsinki.ﬁ, sara.negri@helsinki.ﬁ

270
|
S. Negri and J. von Plato
Turing in a manuscript of 1944, The reform of mathematical notation and
phraseology, was keenly aware of how mathematical proof hangs on the deduc-
tion theorem. A version of Turing’s manuscript is found printed in [Cooper and
van Leeuwen, 2013] to which we refer. The ﬁrst of his two central points was (p.
246): 1. “Free and bound variables should be understood by all and properly re-
spected.” He then gives an example of constants and variables and adds: “The
diﬀerence between the constants and the free variables is somewhat subtle. The
constants appear in the formula as if they were free variables, but we cannot
substitute for them. In these cases there has always been some assumption made
about the variable (or constant) previously.”
Turing’s second point was (ibid.): 2. “The deduction theorem should be taken
account of.” The deduction theorem is the main way of handling free variables:
“This process whereby we pass from P proved under an assumption H to ‘If H
then P’ may be called ‘absorption of hypotheses’. The process converts constants
or ‘restricted variables’ into free variables.”
His example, slightly rephrased, is: Let the radius a and volume v of a sphere
be given. Then v = 4
3 πa3.
The ‘deduction theorem’ states that in such a case, where we have obtained a result by means
of some assumptions, we can state the result in a form in which the assumptions are in-
cluded in the result, e.g., ‘If a is the radius and v is the volume of the sphere then v = 4
3 πa3.
In this statement a and v are no longer constants.
A suﬃciently detailed proof of the deduction theorem, as in [Hakli and Negri,
2012] or [von Plato, 2013, section 3.6] gives an algorithm for converting hypotheti-
cal proofs that use mathematical axioms as assumptions into purely logical proofs
without assumptions, but the algorithm is hopelessly clumsy for any practical use.
Axiomatic logic was put to rest as a proof system of logic in an act that rendered
the famous deduction theorem a proof-theoretical triviality: it became the rule of
implication introduction of natural deduction. Indeed, if a translation from the
latter to axiomatic logic is deﬁned in suﬃcient detail, the deduction theorem will
come out simply as the image of implication introduction under that translation
(as in [von Plato, 2013, p. 55]). When written in terms of sequent calculus with the
sequent arrow Γ →C that indicates the derivability of C under the collection of as-
sumptions Γ, the deduction theorem becomes the rule: If H →P, then →H⊃P,
with no assumptions left.
In proving the deduction theorem of axiomatic logic, there are two limiting
cases: an axiom H was not at all used in a proof, and secondly, it was used re-
peatedly. The former is easy and the latter routinely skimmed over in logic books.
Now we have come to the central problem: How to count the multiplicity of as-

Cut Elimination in Sequent Calculi with Implicit Contraction
|
271
sumptions in proofs? Many books in proof theory are as light-hearted about this
problem as are books on axiomatic logic. The latter may include Frege’s contrac-
tive axiom (A⊃(A⊃B))⊃(A⊃B) that can be used for reducing a multiple deduction
theorem to a singular one.
The easiest way with assumptions would be if they could be just named and
counted once. In a second approach, we could list them in the order in which they
are taken, in a third, we could repeat in this list assumptions that were used more
than once. Finally, we could ignore the order that seems perhaps not to be intrinsic
but at least in part imposed by the linearity of writing proofs as texts, which makes
the ﬁrst and second approach collapse into one that uses ﬁnite sets. The third uses
lists with multiplicity, or lists for short, and the fourth ﬁnite multisets.
Logical rules are next to the formulas the central part of the syntax of a logical
proof system; thus, the rules act on expressions. Lists in contrast to sets seem to be,
by their very nature, already formal objects of a syntax. We shall therefore begin
with a little theory of expressions for ﬁnite sets, then put up a logical sequent cal-
culus and prove the crucial cut elimination theorem directly by the use of sets. In a
second part, starting with Sec. 4, we draw conclusions about our proof that point
at so far unnoticed passages and constructions in Gentzen’s original work con-
nected to his cut elimination procedure: ﬁrst, his actual use of the “sequents with
sets” approach in the proof of decidability of intuitionistic propositional logic in
1933 that can be easily turned into a new kind of cut elimination procedure, de-
tailed out in Sec. 5; whether Gentzen actually saw this possibility is not known at
present. Secondly there is his, quite opposite, strict adherence to lists in the “al-
titude line” construction in the consistency proof of arithmetic of 1938, presented
in detail in Sec. 6, that gives an alternative cut elimination procedure known to
Gentzen.
2 Sequents with sets
Sequent calculus is the proper setting for a precise discussion of the treatment of
assumptions in proofs. The rules of sequent calculus display the collection of open
assumptions Γ at the left of an arrow and the consequence C of those assumptions
at right, in a sequent Γ →C. Each logical rule modiﬁes derivability relations, as
in rule R⊃that gives the result Γ →A⊃B from the premiss A, Γ →B, as in
A, Γ →B
Γ →A ⊃B R ⊃
Here A and B are the active formulas of the rule, A⊃B its principal formula, and

272
|
S. Negri and J. von Plato
Γ the context. It is customary to speak of derivations even in sequent calculus; no
harm, if the double sense of derivability is kept in mind. The word “conclusion”
can have a similar double use, either as the consequence C in a sequent Γ →C,
or the conclusion of a rule of sequent calculus. Assumptions A are presented in
sequent calculus as initial sequents A →A, as a limiting case in which the con-
clusion A depends on the assumption A.
In Gentzen’s doctoral work of 1933, published as [Gentzen, 1934–35], the as-
sumptions Γ were given as a list of formulas, thus, the order and multiplicity of
occurrences of formulas was counted. Later, Katudi Ono [Ono, 1938] introduced
lists in which order is not counted and proved that the resulting calculi are equiv-
alent to Gentzen’s, a discovery known to the latter (cf. his review of Ono’s work,
[Gentzen, 1939]), and reinvented by Kleene, Curry, and others in the 1950s. In se-
quent calculi as well as natural deduction, formal derivations have the form of a
tree, and there is no intrinsic linear order of assumptions. Perhaps in reﬂection
of this latter fact, it has become customary to formulate sequent calculi so that
the open assumptions form ﬁnite multisets, and similarly for the open cases if a
symmetric sequent calculus with more than one succedent formula is used. Below
we pay only marginal attention to Gentzen’s original exchange rules by which the
order of formula occurrences in lists of assumptions and cases can be changed.
The idea has been often entertained of dispensing, next to order, also with
multiplicity, known as the “sequents with sets” idea. There will be some diﬃcul-
ties in carrying the idea through on the level of formalization: Logical languages
are inductively deﬁned classes of formulas, and a system of logical rules gives an
inductive deﬁnition of the class of derivations. Sets are objects and two sets are
equal if they have the same members. However, two diﬀerent expressions for the
same set cannot be just like that substituted one for the other in logical rules,
because syntactically incorrect rule instances can be produced: For example, a
single left rule of conjunction has the premiss A, B, Γ →C and the conclusion
A & B, Γ →C. If A and B are identical, the premiss collapses into A, Γ →C with
no match with the premiss of the rule. Therefore a little theory of expressions for
sets needs to be put up. This theory will contain rules by which, say , an expres-
sion
{A, . . . , B, B, . . . , C}
for a set of formulas can be replaced by the expression
{A, . . . , B, . . . , C},
thus, a rule of contraction. Details such as the above have a bearing on the modu-
larity of sequent calculus proof systems, as expressed by the rule of cut that shows
how two derivations can be combined, and how it is removed in a process of cut

Cut Elimination in Sequent Calculi with Implicit Contraction
|
273
elimination. Formally, we have a derivation of some result A, and another deriva-
tion in which A occurs as an assumption, combined as in the scheme:
Γ →A
A, ∆→C
Γ, ∆→C
Cut
In the cut elimination procedure to be presented we shall, instead of a theory of
expressions for sets, use canonical expressions for sets, as lists without repetition
and with a prescribed lexicographical order, and the principle:
At each rule instance, any potential multiplication of formula occurrences in the conclusion is
erased when the conclusion is written down.
Initial sequents have already the property of a singleoccurrence,andourprinciple
makes conclusions of logical rules inherit that property. The eﬀect is that the rule
of contraction, needed when diﬀerent expressions for the same set are allowed,
will become implicit.
Cut elimination for sequent calculi with implicit contraction is diﬀerent from
the Gentzen-style cut elimination procedure in which, whenever the cut formula
is concluded in both premisses of cut by the rules that correspond to its logical
form, cuts on shorter formulas replace the given cut. The diﬀerence is seen when,
for example, the right premiss of cut has been concluded by the left conjunction
rule, with an implicit contraction on the cut formula A & B. In this case, the cut
on A & B does not get removed, but is ﬁrst permuted up, followed by cuts on the
two immediate subformulas of A & B. We show ﬁrst that the cut elimination pro-
cedure to be deﬁned works for a single-succedent calculus, then extend it to a
calculus with symmetric sequents of the form Γ →∆that can have several cases
in the succedent part. These proofs of cut elimination use the standard rule of
cut, whereas in Gentzen’s original work, cut elimination is done through the “mix
rule,” or rule of multicut as one often says, in which any number of cut formulas
in the two premisses can be deleted:
Γ →A
A∗, ∆→C
Γ, ∆→C
Mix
Here A∗denotes any number n ⩾1 of copies of A. [Gentzen, 1934–35] has the
comment that the rule is used “to make the proof easier.” The problematic case of
cut elimination that led Gentzen to the mix rule is that the right premiss has been
concluded by a rule of contraction.

274
|
S. Negri and J. von Plato
Here is such a derivation:
Γ
...
→A
A, A, ∆→C
A, ∆→C
Ctr
Γ, ∆→C
Cut
The obvious idea of cutting twice with Γ →A gives:
Γ
...
→A
Γ
...
→A
A, A, ∆→C
A, Γ, ∆→C
Cut
Γ, Γ, ∆, Θ →C
Cut
The derivation of the right premiss of the lower cut has clearly grown in some
sense, with an instance of contraction replaced by an instance of cut, and no sim-
ple solution has been found to correct the situation. Intrigued by Gentzen’s re-
mark about making the proof easier, the second author produced in [von Plato,
2001] a proof of cut elimination with the standard cut rule, based on an analy-
sis of how the premiss of contraction was derived. Contraction was then reduced
by inversion lemmas to contractions on shorter formulas. These lemmas require
subtle changes in the sequent calculi used, unknown to Gentzen.
2.1 Cut elimination for sequents with sets
The cut elimination procedure to be deﬁned is rather straightforward for a single-
succedent sequent calculus. Logical rules with two premisses have contexts that
are added up in the conclusion, with possible multiplications of formulas erased.
When a rule is written, no premiss has duplications of formulas. A “bra–ket” no-
tation ⟨Γ⟩, adopted from a manuscript of Gentzen’s of 1944, indicates a context
Γ in the conclusion of a rule such that no duplications in the antecedent remain.
Such duplications can arise either because the principal formula of a rule was al-
ready found in Γ or because the antecedents of two premisses of a rule overlapped
with some formulas. Rules R& and L∨are written in the manner of rule L⊃, with
contexts added up in the conclusion.
Table 1. Initial sequents of LIS
Initial sequents of the calculus LIS
C →C
⊥→C
(C an arbitrary formula)

Cut Elimination in Sequent Calculi with Implicit Contraction
|
275
Table 2. Logical rules of LIS
Logical rules of the calculus LIS
A, Γ →C
⟨A & B, Γ⟩→C L&
B, Γ →C
⟨A & B, Γ⟩→C L&
Γ →A
∆→B
⟨Γ, ∆⟩→A & B R&
A, Γ →C
B, ∆→C
⟨A ∨B, Γ, ∆⟩→C
L∨
Γ →A
Γ →A ∨B R∨
Γ →B
Γ →A ∨B R∨
Γ →A
B, ∆→C
⟨A⊃B, Γ, ∆⟩→C L⊃
A, Γ →B
Γ →A ⊃B R⊃
A(t), Γ →C
⟨∀xA(x), Γ⟩→C L∀
Γ →A(y)
Γ →∀xA(x) R∀
A(y), Γ →C
⟨∃xA(x), Γ⟩→C L∃
Γ →A(t)
Γ →∃xA(x) R∃
For the structural rules, note that if the weakening formula is found in the context,
the conclusion is identical to the premiss.
Table 3. Structural rules of LIS
Structural rules of the calculus LIS
Γ →C
⟨A, Γ⟩→C Wk
Γ →A
A, ∆→C
⟨Γ, ∆⟩→C
Cut
Note that in rule L&, for example, the principal formula A & B can very well oc-
cur in Γ, whereas if there is no such occurrence, ⟨A & B, Γ⟩could be written as
A & B, Γ.
We have chosen to have two left rules for conjunction, instead of a single rule
with the premiss A, B, Γ →C, to avoid the complication that occurs if A and B are
identical. As mentioned, this case would make the premiss collapse into A, Γ →C
with no match with the conclusion.
Theorem 1 (Cut elimination for LIS). The rule of cut can be eliminated from deriva-
tions in LIS.
Proof: We show that uppermost occurrences of rule Cut can be permuted upwards
until they hit initial sequents and get removed. The height of a cut is the sum of
the heights of the derivations of its premisses, i.e., of the longest branches in each.

276
|
S. Negri and J. von Plato
In each case, a cut is replaced by cuts that can have the same cut formula but a
lesser height or else they have a shorter cut formula. The cases are:
1.
One premiss of cut is an initial sequent.
(a) If it is of the form C →C, the conclusion is identical to the other premiss
and the cut deleted.
(b) The left premiss of cut is an initial sequent of the form ⊥→C and we
have:
⊥→D
D, Γ →C
⟨⊥, Γ⟩→C
Cut
The conclusion is obtained from the initial sequent ⊥→C by repeated
weakenings.
(c) The right premiss of cut is an initial sequent of the form ⊥→C and we
have:
Γ →⊥
⊥→C
Γ →C
Cut
The cut formula cannot be principal in the left premiss and cut is per-
muted up until a sequent of the form ⊥, ∆→⊥is reached:
⊥, ∆→⊥
⊥→C
⟨⊥, ∆⟩→C
Cut
The conclusion of that cut is obtained from the right premiss by weaken-
ings.
2.
The left premiss of cut is a conclusion of a left rule. Cut is permuted up until
case 1 is met, or the left premiss has been concluded by a right rule:
3.
There are ﬁve cases of right rules in the left premiss of cut.
(a) The ﬁrst is rule R& with the cut:
Γ →A
∆→B
⟨Γ, ∆⟩→A & B R&
A & B, Θ →C
⟨Γ, ∆, Θ⟩→C
Cut
Cut is permuted up at right and its height reduced until case 1 is met or
A & B is the principal formula in rule L&. In the latter case we have, say:
Γ →A
∆→B
⟨Γ, ∆⟩→A & B R&
A, Θ →C
⟨A & B, Θ⟩→C L&
⟨Γ, ∆, Θ⟩→C
Cut
If A & B does not occur in Θ, cut can be permuted as in [Gentzen, 1934–35].

Cut Elimination in Sequent Calculi with Implicit Contraction
|
277
The derivation with the permuted cut is
Γ →A
A, Θ →C
⟨Γ, Θ⟩→C
Cut
The conclusion of the original cut is now obtained through weakenings.
If A & B instead does occur in Θ, rule L& produces an implicit contraction
on the cut formula, and the Gentzen-style transformation leaves one copy
of A & B in the conclusion: The cut after the transformation can be written
with the notation A & B, Θ耠≡Θ as:
Γ →A
A, A & B, Θ耠→C
⟨Γ, A & B, Θ耠⟩→C
Cut
This problematic case is resolved as follows:
Γ →A
Γ →A
∆→B
⟨Γ, ∆⟩→A & B R&
A, A & B, Θ耠→C
⟨A, Γ, ∆, Θ耠⟩→C
Cut
⟨Γ, ∆, Θ耠⟩→C
Cut
The height of the upper cut is diminished by one. The new cut is on a
shorter formula.
(b) The case of rule R∨is similar.
(c) With rule R⊃we have as in 3.(a) the worst case:
A, Γ1 →B
Γ1 →A⊃B R⊃
A⊃B, Γ2 →A
B, A⊃B, Γ3 →C
⟨A⊃B, Γ2, Γ3⟩→C
L⊃
⟨Γ1, Γ2, Γ3⟩→C
Cut
The transformed derivation is, with the ⟨⟩notation left out to make it ﬁt:
A, Γ1 →B
Γ1 →A⊃B R⊃
A⊃B, Γ2 →A
Γ1, Γ2 →A
Cut
A, Γ1 →B
Γ1, Γ1, Γ2 →B
Cut
A, Γ1 →B
Γ1 →A⊃B R⊃
B, A⊃B, Γ3 →C
B, Γ1, Γ3 →C
Cut
Γ1, Γ1, Γ1, Γ2, Γ3 →C
Cut
Contractions are now made to reproduce the original conclusion. There
are two cuts with the cut formula A⊃B and a lesser cut height, followed
by cuts on the shorter formulas A and B.
(d) The cut formula is ¬A and the transformation nearly a special case of the
above.
(e) The cut formula is ∀xA(x) with the derivation:
Γ1 →A(y)
Γ1 →∀xA(x) R∀
A(t), ∀xA(x), Γ2 →C
∀xA(x), Γ2 →C
L∀
⟨Γ1, Γ2⟩→C
Cut

278
|
S. Negri and J. von Plato
The transformed derivation is, with the substitution [t/y] in the deriva-
tion of the premiss of rule R∀of the original derivation that gives as a
result the derivable sequent Γ1→A(t):
Γ1 →A(t)
t
Γ1→∀xA(x) R∀heΓ1 →A(y)
∀xA(x), A(t), Γ2 →C
⟨A(t), Γ1, Γ2⟩→C
Cut
⟨Γ1, Γ2⟩→C
Cut
The upper cut has a lesser cut height, the lower a shorter cut formula.
(f) The cut formula is ∃xA(x). This case is dual to the previous.
4.
One premiss of cut is derived by rule Wk. If it is the left premiss, cut can be
permuted up, and the same with the right premiss except when the cut for-
mula is principal in weakening. In this case the conclusion is obtained from
the premiss of weakening without any cut.
QED.
The above proof of cut elimination goes through also for a calculus with more
than one succedent formula, even if the details turn out somewhat intricate. Ini-
tial sequents of this classical sequent calculus with sets of formulas LKS have the
form C →C, and negation is treated as a primitive connective. The logical and
structural rules of LKS are displayed below.
Table 4. Logical rules of LKS
Logical rules of the calculus LKS
A, Γ →∆
⟨A & B, Γ⟩→∆L&
B, Γ →∆
⟨A & B, Γ⟩→∆L&
Γ1 →∆1, A
Γ2 →∆2, B
⟨Γ1, Γ2⟩→⟨∆1, ∆2, A & B⟩R&
A, Γ1 →∆1
B, Γ2 →∆2
⟨A ∨B, Γ1, Γ2⟩→⟨∆1, ∆2⟩L∨
Γ →∆, A
Γ →⟨∆, A ∨B⟩R∨
Γ →∆, B
Γ →⟨∆, A ∨B⟩R∨
Γ1 →∆1, A
B, Γ2 →∆2
⟨A⊃B, Γ1, Γ2⟩→⟨∆1, ∆2⟩L⊃
A, Γ →∆, B
Γ →⟨∆, A ⊃B⟩R ⊃
Γ →∆, A
⟨¬A, Γ⟩→∆L¬
A, Γ →∆
Γ →⟨∆, ¬A⟩R¬
A(t), Γ →∆
⟨∀xA(x), Γ⟩→∆L∀
Γ →∆, A(y)
Γ →⟨∆, ∀xA(x)⟩R∀
For the structural rules, note that if the weakening formula is found in the context,
the conclusion is identical to the premiss.

Cut Elimination in Sequent Calculi with Implicit Contraction
|
279
Table 5. Structural rules of LKS
Structural rules of the calculus LKS
Γ →∆
⟨A, Γ⟩→∆LW
Γ →∆
Γ →⟨∆, A⟩RW
Γ1 →∆1, A
A, Γ2 →∆2
⟨Γ1, Γ2⟩→⟨∆1, ∆2⟩
Cut
Theorem 2 (Cut elimination for LKS). The rule of cut can be eliminated from deri-
vations in LKS.
Proof: The proof is similar to that of theorem 1 in which uppermost instances of
cut are eliminated. The cases are:
1.
One premiss of cut is an initial sequent. The conclusion is identical to the
other premiss and the cut is deleted.
2.
Cut is permuted up in the left and right premisses until case 1 is met.
3.
Cut is permuted up in the left and right premisses until the cut formula is
principal in both premisses of cut. There are six cases:
(a) The cut formula is A & B, and we may assume that the principal formula
in rules L&, R& occurs in each premiss. Should it lack from some, either
a simpler cut elimination procedure is made, but with more case distinc-
tions, or, for a uniform procedure, possible missing principal formulas
in premisses of L&, R& are added through weakenings. Further, to ﬁt the
derivations on a page, we leave out the ⟨⟩-notation:
Γ1 →∆1, A & B, A
Γ2 →∆2, A & B, B
Γ1, Γ2 →∆1, ∆2, A & B
R&
A, A & B, Γ3 →∆3
A & B, Γ3 →∆3
L&
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3
Cut
The transformed derivation is shown in Figure 1 below. The two upper
cuts have a lesser height of cut, the lower cut a shorter cut formula. The
transformation is similar with the second form of rule L&.
(b) The cut formula is A ∨B. This case is dual to cut formula A & B.
(c) The cut formula is A⊃B with the derivation:
A, Γ1 →∆1, A⊃B, B
Γ1 →∆1, A⊃B
R⊃
A⊃B, Γ2 →∆2, A
B, A⊃B, Γ3 →∆3
A⊃B, Γ2, Γ3 →∆2, ∆3
L⊃
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3
Cut
The transformed derivation is too broad to be displayed as such. We shall
show the active and principal formulas and indicate the contexts by num-
bers on top of the sequent arrows so that, for example, A
1→A ⊃B, B
stands for the sequent A, Γ1 →∆1, A⊃B, B:

280
|
S. Negri and J. von Plato
Here, the active and principal formulas of the transformed derivation.
A
1→A⊃B, B
1→A⊃B
R⊃
A⊃B
2→A
1,2
→A
Cut
A
1→B, A⊃B
A⊃B
2→A B, A⊃B
3→
A⊃B
2,3
→
L⊃
A
1,2,3
→B
Cut
1,2,3
→B
Cut
A
1→A⊃B, B
1→A⊃B
R⊃
B, A⊃B
3→
B
1,3
→
Cut
1,2,3
→
Cut
There are three cuts with the cut formula A⊃B and a lesser cut height,
followed by cuts on the shorter formulas A and B.
(d) The cut formula is ¬A and the transformation nearly a special case of the
above.
(e) The cut formula is ∀xA(x) with the derivation:
Γ1 →∆1, ∀xA(x), A(y)
Γ1 →∆1, ∀xA(x)
R∀
A(t), ∀xA(x), Γ2 →∆2
∀xA(x), Γ2 →∆2
L∀
Γ1, Γ1, Γ2, Γ2 →∆1, ∆1, ∆2, ∆2
Cut
The transformed derivation is, with the substitution [t/y] in the deriva-
tion of the premiss of rule R∀of the original derivation that gives as a
result the derivable sequent Γ1→∆1, ∀xA(x), A(t).
Γ1→∆1, ∀xA(x), A(t)
A(t), ∀xA(x), Γ2→∆2
∀xA(x), Γ2→∆2
L∀
Γ1, Γ2→∆1, ∆2, A(t)
Cut
Γ1→∆1, ∀xA(x), A(y)
Γ1→∆1, ∀xA(x)
R∀∀xA(x), A(t), Γ2→∆2
A(t), Γ1, Γ2→∆1, ∆2
Cut
Γ1, Γ2→∆1, ∆2
Cut
The two upper cuts have a lesser cut height, the last cut a shorter cut for-
mula.
(f) The cut formula is ∃xA(x). This case is dual to the previous.
4.
One premiss of cut has been derived by weakening. If the weakening formula
is the cut formula, the weakening and cut are removed. Else cut is permuted
above the weakening.
QED.
Γ1→∆1, A & B, A
A, A & B, Γ3→∆3
A & B, Γ3→∆3 L&
Γ1, Γ3→∆1, ∆3, A
Cut
Γ1→∆1, A & B, A
Γ2→∆2, A & B, B
Γ1, Γ2→∆1, ∆2, A & B
R& A, A & B, Γ3→∆3
A, Γ1, Γ2, Γ3→∆1, ∆2, ∆3
Cut2
Γ1, Γ2, Γ3→∆1, ∆2, ∆3
Cut
Fig. 1. Transformed derivation of case 3.(a)

Cut Elimination in Sequent Calculi with Implicit Contraction
|
281
3 Proof of decidability of intuitionistic
propositional logic
The ﬁrst published application of sequent calculus was a proof of the decidabil-
ity of intuitionistic propositional logic. Gentzen’s argument here is purely verbal,
without a single formula [Gentzen, 1934–35, IV Sec. 1]. A sequent is deﬁned to be
reduced if it has at most three copies of the same formula on either side. Given a
derivation of a reduced sequent, all contexts are rewritten so that they have no
multiple occurrences of formulas. As Gentzen notes, sequents that appear as con-
clusions of a rule and as premisses of a successive rule need after this modiﬁca-
tion not conform to the form of the rules as deﬁned earlier in the setting up of the
calculus. He adds, however, that a syntactically correct derivation can always be
produced, by the structural rules of weakening, contraction, and exchange.
Gentzen’s derivations reduced to single occurrences of each formula are precisely derivations
in a sequent calculus with sets.
His main observation is that the occurrences of formulas on either side of a se-
quent in a derivation in his calculi LI and LK, the rule of cut included, can be lim-
ited to at most three, provided this holds for the sequent to be derived. It is easy to
see where this number comes from: In Gentzen’s rule L⊃, we can have one occur-
rence of A⊃B in both premisses, with the condition of a single occurrence in each
context respected. With Γ ≡A⊃B, Γ耠and ∆≡A⊃B, ∆耠, respectively, we have:
A⊃B, Γ耠→A
B, A⊃B, ∆耠→C
A⊃B, A⊃B, A⊃B, Γ耠, ∆耠→C
L⊃
Next the conclusion is rewritten as A⊃B, Γ耠, ∆耠→C, a sequent that can be equally
well obtained from the conclusion of L⊃by two contractions on A⊃B. Thus, the re-
sult is that all derivations of a reduced sequent can be transformed into a reduced
form, with at most three copies of a formula in each antecedent or succedent of
a sequent and, as we may add, with at most two successive contractions on the
same formula. Gentzen’s other two-premiss rules R& and L∨have shared contexts
and behave like one-premiss rules in this respect, with at most two copies of the
same formula in the conclusion and at most one contraction. Cut has no principal
formula and can produce at most duplications.

282
|
S. Negri and J. von Plato
4 Cut elimination without the mix rule
The observations at the end of the previous Section can be turned into a cut elim-
ination procedure for Gentzen’s calculi LI and LK, with no need for the mix rule
trick. Sequents will have multisets as antecedents and succedents, with logical
rules as in the above tables but without the bra-ket notation, and the insubstan-
tial diﬀerence that we have independent contexts in rules R& and L∨. Gentzen has
shared contexts in these rules, which takes away one step in cut elimination. His
rule L⊃is as above, with independent contexts for the reason that that is the only
way to arrive at a single-succedent instance of the rule; the proof of cut elimina-
tion was designed so that a proof for the intuitionistic calculus LI came out as a
single-succedent special case.
To the structural rules are added left and right contraction:
A, A, Γ →∆
A, Γ →∆
LC
Γ →∆, A, A
Γ →∆, A
RC
Theorem 3 (Cut elimination for LI). The rule of cut can be eliminated from deriva-
tions in LI.
Proof: By the above, a given derivation with cuts can be transformed into one in
which there are at most two successive contractions on the principal formula with
rule L⊃and one with the rest.
All cases except when the right premiss of cut has been derived by contrac-
tion have been covered in the proof of theorem 1. We show the most involved case
of rule L⊃. If between the rule and the cut there are other rules than the two con-
tractions, they can be permuted, so we have the derivation:
Γ1 →A⊃B
A⊃B, Γ2 →A
B, A⊃B, Γ3 →C
A⊃B, A⊃B, A⊃B, Γ2, Γ3 →C
L⊃
A⊃B, A⊃B, Γ2, Γ3 →C
LC
A⊃B, Γ2, Γ3 →C
LC
Γ1, Γ2, Γ3 →C
Cut
Cut is permuted up at left until the cut formula is principal, concluded by rule R⊃,
and the transformation of case 3.3 in theorem 1 applies, and similarly for all the
other cases.
QED.
As Gentzen notes, the notion of a reduced sequent applies as well to the symmetric
classical calculus LK. Therefore theorem 2 and its proof turns equally well into a
proof for LK:

Cut Elimination in Sequent Calculi with Implicit Contraction
|
283
Theorem 4 (Cut elimination for LK). The rule of cut can be eliminated from deriva-
tions in LK.
Proof: Similar to the previous. For reasons of comparison in Sec. 7, we show the
case of cut formula ∀xA(x) and assume the worst case, with the principal formula
found already in the premisses of rules R∀, L∀. After suitable permutations, we
have single contractions right after these logical rules, followed by a cut:
Γ1 →Θ1, ∀xA(x), A(y)
Γ1 →Θ1, ∀xA(x), ∀xA(x) R∀
Γ1 →Θ1, ∀xA(x)
RC
A(t), ∀xA(x), Γ2 →Θ2
∀xA(x), ∀xA(x), Γ2 →Θ2 L∀
∀xA(x), Γ2 →Θ2
LC
Γ1, Γ2 →Θ1, Θ2
Cut
The premiss of R∀has the eigenvariable y that can be changed into the term t
throughout the derivation of the premiss, after which the transformation is into:
Γ1→Θ1, ∀xA(x), A(t)
A(t), ∀xA(x), Γ2→Θ2
∀xA(x), ∀xA(x), Γ2→Θ2L∀
∀xA(x), Γ2→Θ2
LC
Γ1, Γ2→Θ1, Θ2, A(t)
Cut
Γ1→Θ1, ∀xA(x), A(t)
Γ1→Θ1, ∀xA(x), ∀xA(x)R∀
Γ1→Θ1, ∀xA(x)
RC
A(t), ∀xA(x), Γ2→Θ2
A(t), Γ1, Γ2→Θ1, Θ2
Cut
Γ1, Γ1, Γ2, Γ2 →Θ1, Θ1, Θ2, Θ2
Cut
A suﬃcient number of contractions gives the original conclusion of cut.
QED.
Another case in the proof is covered in the discussion in Sec. 7. It might seem at a
ﬁrst sight that nothing is gained by the above transformation, for the contractions
are still there. However, in the left branch, the left premiss of the upper cut is not
derived by right contraction but by some other rule, and similarly for the right
branch. The elimination of these upper cuts proceeds now by an analysis of how
the respective left and right premisses were derived.
4.1 The notion of an altitude line
The method of cut elimination for LKS above, in theorem 2, is quite similar to
one connected with the intricate “altitude line” construction (Höhenlinie) found
in Gentzen’s 1938 proof of the consistency of Peano arithmetic [Gentzen, 1938], the
origin of which has been wondered by many. It is quite plausible, in the light of
how cut elimination is adapted to a calculus with an explicit rule of contraction,
theorem 4, that Gentzen had done his original cut elimination theorem of 1933
along the lines given here, then changed for the simpler mix rule proof for ex-
pository reasons. As we shall point out, the mix rule cannot be used in the proof

284
|
S. Negri and J. von Plato
theory of arithmetic, so ﬁve years later, the original methods of cut elimination
resurfaced in his consistency proof.
After the new consistency proof of 1938 that used the classical calculus LK,
Gentzen worked hard with the proof theory of intuitionistic arithmetic and anal-
ysis. In the Summer of 1944, he prepared a summary of calculi and reductions in
consistency proofs, the extant shorthand series WKRd that is explained in some
detail in [von Plato, 2012, pp. 356–358] and in detail in the introduction to the
ﬁrst volume of Gentzen’s shorthand notes, [Gentzen, 2016]. The central problem
was always the multiplication of formulas in steps of reduction, and one sug-
gested remedy in WKRd was a “contractive cut” (Zusammenziehungsschnitt). None
of Gentzen’s attempts at keeping contraction a business separate from the logical
rules worked, though. Above we used already Gentzen’s notation, here given di-
rectly from the edited shorthand manuscript WKRd [Gentzen, 1944, p. 5]:
Γ →D
D ∆→C
⟨Γ ∆⟩→C
Gentzen explains the ⟨⟩notation by: “Meaning: the formulas Γ ∆contracted
throughout.” On p. 4, he uses a similar notation [Γ ∆] for lists without order, with
the explanation: “[ ]: arbitrary order of the formulas in question.”
The altitude line construction of 1938: Gentzen’s 1938 ‘New formulation of the
consistency proof for pure number theory’ is in terms of the classical sequent cal-
culus LK. In a letter to Bernays dated 12 May 1938, included in [Gentzen, 2016],
he writes that the proof of consistency is organized similarly to the way in which
he found the original proof of cut elimination in 1933. Inconsistency is expressed
as the derivability of the empty sequent →. Logical rules import a formula on
one or the other side of a sequent. Therefore, if the empty sequent is derivable,
there is in the derivation an endpiece in which only structural rules and steps of
inductive inference are found. The uppermost sequents of the endpiece are con-
clusions of logical rules. Instances of the rule of induction in the endpiece become
reduced into repeated cuts, after which contractions and cuts are used to arrive at
the empty endsequent. A crucial lemma 3.4.3 in the proof states that there is at
least one cut formula in the endpiece such that the cut formula is principal in a
left, resp. a right logical rule that delimits the endpiece. Such a cut is permuted so
that it applies right after the logical rules, by which the cut formula becomes the
principal formula in both premisses of cut. Thus, there is a precise analogy to cut
elimination for pure logic, but with a price:
In the proof that the reduction of derivations of the empty sequent through
cut elimination terminates, Gentzen uses a strange proof transformation and the
related notion of “altitude line.”

Cut Elimination in Sequent Calculi with Implicit Contraction
|
285
Here is his example of an altitude line, with the given part of a derivation [Gentzen,
1938, p. 34]:
Γ1 →Θ1, F(a)
Γ1 →Θ1, ∀xF(x) R∀
....
Γ →Θ, ∀xF(x)
F(n), Γ2 →Θ2
∀xF(x), Γ2 →Θ2 L∀
....
∀xF(x), ∆→Λ
Γ, ∆→Θ, Λ
Cut
....
Γ3 →Θ3 Altitude line
....
→
An altitude line in a derivation is any inference line of a cut with a formula such
that all cut formulas from the line to the endsequent are shorter. Gentzen uses
the word Höhe (altitude) even for the length of a cut formula that determines an
altitude line, a notion not to be confused with other uses of English equivalents
of Höhe, such as in the height of a cut in Section 3 or the height of a derivation.
The cut formula ∀xF(x) of the example has a length ϱ that is also assumed to
be an altitude; thus, the line of cut is an altitude line. At the indicated Altitude line
lower down, this altitude diminishes from ϱ to some σ through another cut, so we
have σ < ϱ.
The transformed derivation is, disregarding rules of exchange in the original
[Gentzen, 1938, p. 35]:
....
Γ1 →Θ1, F(n)
Γ1 →Θ1, F(n), ∀xF(x) RW
....
Γ →Θ, F(n), ∀xF(x)
....
F(n), Γ2 →Θ2
∀xF(x), Γ2 →Θ2 L∀
....
∀xF(x), ∆→Λ
Γ, ∆→Θ, Λ, F(n)
....
Γ3 →Θ3, F(n)
....
Γ1 →Θ1, F(a)
Γ1 →Θ1, ∀xF(x) R∀
....
Γ →Θ, ∀xF(x)
....
F(n), Γ2 →Θ2
∀xF(x), F(n), Γ2 →Θ2 LW
....
∀xF(x), F(n), ∆→Λ
F(n), Γ, ∆→Θ, Λ
....
F(n), Γ3 →Θ3
Γ3, Γ3 →Θ3, Θ3
New Cut
Γ3 →Θ3
Contractions
....
→
Gentzen indicates only in the text but not in the ﬁgure that altitude lines with a
lowered altitude < ϱ appear higher up in the transformed derivation, above the
sequents Γ3 →Θ3, F(n) and F(n), Γ3 →Θ3. On the whole, the idea is that altitude
lines are being pushed up in the endpiece. The empty endsequent has altitude 0,
and the transformations force this to be the case for the whole endpiece, by which
there is no derivation of the empty sequent.

286
|
S. Negri and J. von Plato
When explaining the transformation, Gentzen writes (p. 34):
The inference ﬁgures represent an introduction and an elimination of ∀in ∀xF(x). Following
the original basic idea, both should be put aside and ∀xF(x) should be substituted by F(n)–
its grade [length] is one less; in place of the cut with the cut formula ∀xF(x) there would
occur a cut with the cut formula F(n). There appears, however, the diﬃculty already men-
tioned, namely that the formula ∀xF(x) can have been used and even introduced in several
places.
To resolve the diﬃculty, the mix rule cannot be used, as will be made clear in
our closing paragraph. Instead, cuts on the formula ∀xF(x) are maintained, but
Gentzen notes that the essential point of the transformation is that above the two
cuts on the old cut formula, the inferences have been simpliﬁed because one step
of logical inference has been removed in each. This, precisely, is what happened
in the transformations in our proofs of cut elimination for LIS and LKS, theorems
1 and 2 of Section 3. As to why the steps of weakening are added in which the
formula ∀xF(x) reappears, Gentzen notes that “this is a matter of convenience,
for one would have to count anyway with its appearance further down, so in this
way the new form of the derivation is taken over from the old one in the most
convenient way.”
5 Contraction and altitude lines
As Gentzen notes, copies of the formula ∀xF(x) can appear through branches
above the step of the original cut other than the branch shown. (In fact, Gentzen’s
ﬁgure has three-pronged upward-pointing “forks” that we failed to reproduce.)
These formula occurrences would have to be contracted before the cut. Assume
now that instead of a weakening, the extra copy of the cut formula was already
there in the premisses of the logical rules of the original derivation to be trans-
formed, and vanished right after the step in which it became principal, in a step
of contraction. As noted above in Section 4, with a one-premiss rule, there need
be at most one such contraction present:
Γ1 →Θ1, ∀xF(x), F(a)
Γ1 →Θ1, ∀xF(x), ∀xF(x) R∀
Γ1 →Θ1, ∀xF(x)
RC
....
Γ →Θ, ∀xF(x)
F(n), ∀xF(x), Γ2 →Θ2
∀xF(x), ∀xF(x), Γ2 →Θ2 L∀
∀xF(x), Γ2 →Θ2
LC
....
∀xF(x), ∆→Λ
Γ, ∆→Θ, Λ
Cut
....

Cut Elimination in Sequent Calculi with Implicit Contraction
|
287
....
Γ, ∆→Θ, Λ
....
Γ3 →Θ3 Altitude line
....
→
Permuting Cut up, the essential case to consider is:
Γ1 →Θ1, ∀xF(x), F(a)
Γ1 →Θ1, ∀xF(x), ∀xF(x) R∀
Γ1 →Θ1, ∀xF(x)
RC
F(n), ∀xF(x), Γ2 →Θ2
∀xF(x), ∀xF(x), Γ2 →Θ2 L∀
∀xF(x), Γ2 →Θ2
LC
Γ1, Γ2 →Θ1, Θ2
Cut
....
Γ, Γ2 →Θ, Θ2
....
Γ, ∆→Θ, Λ
....
Γ3 →Θ3
....
→
After the cut, there follow the steps that led originally from Γ1 →Θ1, ∀xF(x) to
Γ →Θ, ∀xF(x), with ∀xF(x) kept intact, then the steps that led originally from
∀xF(x), Γ2 →Θ2 to ∀xF(x), ∆→Λ. This derivation is transformed following
strictly Gentzen’s general procedure for the speciﬁc case of contractions. We have
the substitution [n/a] in the derivation of the sequent Γ1 →Θ1, ∀xF(x), F(a) and
just one step of logical inference instead of two above each of the cuts on ∀xF(x):
Γ1→Θ1, ∀xF(x), F(n)
F(n), ∀xF(x), Γ2→Θ2
∀xF(x), ∀xF(x), Γ2→Θ2L∀
∀xF(x), Γ2→Θ2
LC
Γ1, Γ2→Θ1, Θ2, F(n)
Cut
Γ1→Θ1, ∀xF(x), F(a)
Γ1→Θ1, ∀xF(x), ∀xF(x)R∀
Γ1→Θ1, ∀xF(x)
RC
F(n), ∀xF(x), Γ2→Θ2
F(n), Γ1, Γ2→Θ1, Θ2
Cut
Γ1, Γ2 →Θ1, Θ2
Cut
....
Γ, Γ2 →Θ, Θ2
....
Γ, ∆→Θ, Λ
....
Γ3 →Θ3
....
→

288
|
S. Negri and J. von Plato
As in the proof of theorem 4, the two contractions in the derivation of the pre-
misses of the upper cuts remain, but the other premiss has in both cases a reduced
derivation.
In the proof of theorem 2, cut elimination for LKS, we assumed the principal
formula to occur in each premiss. Should it be lacking from some, either a simpler
cut elimination procedure is made, but with more case distinctions as in the proof
of theorem 1, or, for a uniform procedure as in our proof of theorem 2, possible
missing principal formulas in premisses are added through weakenings, just as
in Gentzen’s 1938 proof.
If contraction is an explicit rule, we have now precisely the problematic case
of cut elimination in the calculus LK, namely the one in which the cut formula
has been contracted and that led Gentzen to introduce the mix rule idea [Gentzen,
1934–35]:. For a second example, consider a cut on A⊃B with the “worst case” of
A⊃B repeated in each of the three premisses, as in the proof of theorem 2 (case
3.3), and with contractions before the instance of Cut. Even this case would be one
in a detailed proof of theorem 4:
A, Γ1 →∆1, A⊃B, B
Γ1 →∆1, A⊃B, A⊃B R⊃
Γ1 →∆1, A⊃B
RC
A⊃B, Γ2 →∆2, A
B, A⊃B, Γ3 →∆3
A⊃B, A⊃B, A⊃B, Γ2, Γ3 →∆2, ∆3
L⊃
A⊃B, A⊃B, Γ2, Γ3 →∆2, ∆3
LC
A⊃B, Γ2, Γ3 →∆2, ∆3
LC
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3
Cut
The contracted premisses of Cut cannot be resolved by simply cutting several
times, say twice in the premiss of RC, as in (with duplications of the contexts
omitted):
A, Γ1 →∆1, A⊃B, B
Γ1 →∆1, A⊃B, A⊃BR⊃A⊃B, Γ2, Γ3
...
→∆2, ∆3
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3, A⊃B
Cut A⊃B, Γ2, Γ3
...
→∆2, ∆3
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3
Cut
The “vertical dots” stand for a derivation of the right premiss of the original cut,
and it is seen that the lower cut is not reduced, because the derivation of the left
premiss has grown. Therefore the derivation with contracted premisses of cut has
to be transformed analogously to case 3.3 of our theorem 2. There will be alto-
gether ﬁve cuts in the new derivation, three of them on A⊃B with the height of
cut reduced in each, followed by two on the shorter formulas A and B. The trans-
formation of the derivation is displayed for typographical reasons in parts.
A, Γ1 →∆1, A⊃B, B
Γ1 →∆1, A⊃B, A⊃B R⊃
Γ1 →∆1, A⊃B
RC
A⊃B, Γ2 →∆2, A
Γ1, Γ2 →∆1, ∆2, A
Cut

Cut Elimination in Sequent Calculi with Implicit Contraction
|
289
The second part is:
A, Γ1 →∆1, A⊃B, B
A⊃B, Γ2 →∆2, A
B, A⊃B, Γ3 →∆3
A⊃B, A⊃B, A⊃B, Γ2, Γ3 →∆2, ∆3
L⊃
A⊃B, A⊃B, Γ2, Γ3 →∆2, ∆3
LC
A⊃B, Γ2, Γ3 →∆2, ∆3
LC
A, Γ1, Γ2, Γ3 →∆1, ∆2, ∆3, B
Cut
The third part is:
A, Γ1 →∆1, A⊃B, B
Γ1 →∆1, A⊃B, A⊃B R⊃
Γ1 →∆1, A⊃B
RC
B, A⊃B, Γ3 →∆3
B, Γ1, Γ3 →∆1, ∆3
Cut
These parts are combined by two cuts as follows, with the duplications of the con-
texts omitted:
Γ1, Γ2
...
→∆1, ∆2, A
A, Γ1, Γ2, Γ3
...
→∆1, ∆2, ∆3, B
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3, B
Cut
B, Γ1, Γ3
...
→∆1, ∆3
Γ1, Γ2, Γ3 →∆1, ∆2, ∆3
Cut
As can be seen from this transformation, from the one for the cut formula ∀xF(x),
as well as from the transformations displayed in the proof of theorem 2, the pro-
cedure is somewhat involved, even if in principle clear.
The proof transformations we have found for sequent calculi with implicit
contraction are not altogether unknown: In the contraction-free intuitionistic se-
quent calculus G3i, the principal formula A⊃B of rule L⊃is repeated in the an-
tecedent of the left premiss, with the eﬀect of an implicit contraction at that point.
In the proof transformation, there is ﬁrst a cut on A⊃B with a reduced height of
cut, followed by cuts on A and B (as in [Negri and von Plato, 2001, p. 40]).
We cited Gentzen’s reason for the use of the mix rule in the published proof,
namely to make the proof easier. What he writes clearly indicates that he had
some previous proof at hand that was changed. The most likely candidate for
such a proof is the one presented here. Gentzen had, as is now well known, writ-
ten down a detailed proof of normalization for intuitionistic natural deduction
in 1933 [Gentzen, 2008]. Somehow the level of complexity escaped out of hands
with cut elimination for LK, in comparison to natural deduction, so for reasons of
exposition, Gentzen took into use the mix rule.
Finally, one may wonder why Gentzen went to the trouble of introducing the
cut rule and the altitude line construction in 1938, instead of the well-behaving
mix rule of 1933. It might seem a routine matter to treat the proof theory of arith-
metic with the sequents-as-sets idea. Instead, what happens is that the cut elim-

290
|
S. Negri and J. von Plato
ination procedures of Section 3 are useless, because two cuts cannot necessarily
be permuted with each other when sets are used, contrary to a calculus with mul-
tisets or lists and explicit contractions. The same is true of Gentzen’s mix rule, so
here is the true reason for the intricacies of the 1938 paper: The essential step in
the 1938 proof of consistency, namely the permutation of a “suitable cut” as given
by Gentzen’s lemma 3.4.3 to the upper limit of the endpiece, would get blocked.
Were it possible to do the consistency proof with sets and thus no contractions in
the endpiece, an ordinal assignment could be given that beats Gödel’s theorem!
This particular detail about “sequents with sets” was found out in 2005 and re-
mained a puzzle until Michael Rathjen pointed out that two instances of the mix
rule do not necessarily permute.
References
B. Cooper and J. van Leeuwen. Alan Turing: His Work and Impact. Elsevier, 2013.
G. Gentzen. Untersuchungen über das logische Schliessen. Mathematische Zeitschrift, 39:
176–210, 1934–35.
G. Gentzen. Neue Fassung des Widerspruchsfreiheitsbeweises für die reine Zahlentheorie.
Forschungen zur Logik und zur Grundlegung der exakten Wissenschaften, 4:19–44, 1938.
G. Gentzen. Review of Ono (1938). Zentralblatt für Mathematik und ihre Grenzgebiete, 19:242,
1939.
G. Gentzen. WKRd (Widerspruchsfreiheitsbeweis: Kalküle und Reduktionen). Shorthand notes
dated VIII.44, 8 pages. Available at the Philosophisches Archiv der Universität Konstanz.
1944.
G. Gentzen. The normalization of derivations. The Bulletin of Symbolic Logic, 14:245–257,
2008.
G. Gentzen. Saved from the Cellar: Gerhard Gentzen’s Shorthand Notes on Logic and Foun-
dations of Mathematics. With an Introduction and English Translation by Jan von Plato,
Springer, 2016.
R. Hakli and S. Negri. Does the deduction theorem fail for modal logic? Synthese, 187:849–
867, 2012.
D. Hilbert and W. Ackermann. Grundzüge der theoretischen Logik. Springer, 1928.
S. Negri and J. von Plato. Structural Proof Theory. Cambridge University Press, 2001.
K. Ono. Logische Untersuchungen über die Grundlagen der Mathematik. Journal of the Faculty
of Science, Imperial University of Tokyo, 3:329–389, 1938.
J. von Plato. A proof of Gentzen’s hauptsatz without multicut. Archive for Mathematical Logic,
40:9–18, 2001.
J. von Plato. Gentzen’s proof systems: byproducts in a work of genius. The Bulletin of Symbolic
Logic, 18:313–367, 2012.
J. von Plato. Elements of Logical Reasoning. Cambridge University Press, 2013.
A. Turing. The reform of mathematical notation and phraseology. Manuscript in the Turing
Archives, 1944.

Wolfram Pohlers
Hilbert’s Programme and Ordinal Analysis
Abstract: We claim that there are two aspects of Hilbert’s programme. The quest
for ﬁnitistic consistency proofs and the elimination of ideal objects. Though rigid
ﬁnitistic consistency proofs turned out to be impossible by Gödel’s second incom-
pleteness theorem we argue that ordinal analysis not only yields an elimination
of ideal elements but is actually based on elimination of ideal methods.
Keywords: Hilbert’s programme, Ordinal analysis, Ordinal notations, Semi-
formal calculi, Cut elimination, Normalization, Provably recursive functions
Mathematics Subject Classiﬁcation 2010: 03-02, 03A99, 03F05, 03F15, 03F35
1 Introduction
In his famous talk on unsolved mathematical problems presented at the interna-
tional congress of mathematicians in Paris 1900 Hilbert named the “Consistency
of the Arithmetical Axioms” as the second grand mathematical problem, directly
after the continuum hypothesis. Towards a solution of this problem Hilbert him-
self launched a programme—Hilbert’s programme—to solve this problem. He pub-
lished his programme as a “ﬁrst notiﬁcation (Erste Mitteilung)” 1922 in [Hilbert,
1922]. The aim of Hilbert’s programme was to establish the consistency of Analysis
by intangible means, ﬁnitistic means as he called them.
That this was an illusion became clear when Kurt Gödel in 1931 published his
incompleteness results ([Gödel, 1931]). According to Gödel’s results a rigid con-
sistency proof for suﬃciently rich axiom systems by intangible ﬁnitistic means is
impossible. In this sense one can state that Hilbert’s programme failed.
Nevertheless, unperturbed by Gödel’s results¹ Gentzen published 1936 in
[Gentzen, 1936] the ﬁrst version of his famous consistency proof for Peano arith-
metic and a bit later in 1938 the improved version. Together with his 1943 paper
[Gentzen, 1943] these papers gave birth to a branch of proof theory which we
nowadays call “ordinal analysis”.
1 In page 560 in [Gentzen, 1936] he addresses Gödel’s results and remarks that his proof does not
conﬂict with Gödel’s theorem.
Wolfram Pohlers: Institut für mathematische Logik und Grundlagenforschung, Westfälische
Wilhelms-Universität, Münster, Germany, e-mail: pohlers@math.uni-muenster.de

292
|
W. Pohlers
From a malicious point of view one could state that Gentzen’s proofs did
not really contribute to Hilbert’s programme since his methods did not—and by
Gödel’s results even could not—meet the strict ﬁnitistic ambitions of the pro-
gramme.
In this paper we want to argue that ordinal analysis, launched by Gentzen’s
work, not only pinpoints the inﬁnitary content of formal theories but also helps
us to a deep understanding of another aspect of Hilbert’s programme which is
independent of the aspect of ﬁnitistic consistency proofs: the elimination of ideal
elements. We will even indicate that the ordinal analysis of a formal theory rests
on the elimination of ideal objects.
I want to thank the anonymous referee for helpful comments.
2 Hilbert’s programme revisited
In his 1927 talk given in Hamburg (published in [Hilbert, 1928]) Hilbert mentions
the importance of the addition of “ideal propositions” to the “real propositions”
in a mathematical theory and claims that only “the introduction of ideal propo-
sitions makes mathematical reasoning possible.”² To secure that the addition of
ideal propositions does not lead to inconsistencies we have to check that “after
the elimination of the ideal entities the old entities keep their original validity”.³ So
we again have the problem of a consistency proof but in the milder form that we
only have to secure that the “old entities” keep their validity.
Admittedly the whole section in page 9 of [Hilbert, 1928] appears rather vague
to me. Although there are examples for “ideal entities” it becomes—at least for my
reading—not completely clear which entities have to be regarded as “ideal”. He
apparently subsumes under “ideal” any form of abstract reasoning. I will come
back to this later.
On the other hand there is a passage in page 15 of [Hilbert, 1928] which I think
makes pretty clear what Hilbert understood by “real entities”. There Hilbert com-
pares mathematical reasoning with the work of a physicist. In my translation the
passage says “The physicist requires for a theory that its theorems can be formally
derived from the laws of nature and its hypotheses alone without referring to outside
perceptions. Only certain combinations and conclusions of physical laws are check-
2 “[...], so ist durch Einführung der idealen Aussagen erst wissenschaftliche Mathematik
möglich”. Page 9 in [Hilbert, 1928].
3 “[...], wenn also die Beziehungen, die sich bei der Elimination der idealen Gebilde für die alten
Gebilde herausstellen, stets im alten Bereich gültig sind.” [ibd]

Hilbert’s Programme and Ordinal Analysis
|
293
able by experiments—this is also true for my proof theory in which only real state-
ments are veriﬁable.”⁴ According to this passage “real statements” are statements
that are veriﬁable corresponding to the physical statements that are experimen-
tally checkable. We cannot perform experiments in mathematics. But the math-
ematical activity which is closest to an experiment is checking a statement by a
formal computation, i.e., a computation that in principle could be performed by
a machine.
Clearly, we cannot expect to check a universally quantiﬁed sentence, i.e., an
arithmetical Π0
1-sentence, by a computation but we can check any arbitrary nu-
merical instances of it by a computation. This again resembles the situation in
physics where we also can only experimentally check instances of a predicted
physical phenomenon.⁵ That this interpretation of Hilbert’s intention is not com-
pletely absurd is substantiated by the passage in page 194 of [Hilbert, 1935] (a pas-
sage taken from [Hilbert, 1931]) in which he introduces an ω-rule for Π0
1-sentences
which he even regards as ﬁnitistic.⁶
Based on this interpretation we may subsume Π0
1-statements under “real
statements”. Extending this interpretation we may even subsume Π0
2-statements,
i.e. sentences of the form (∀x)(∃y)F(x, y, ⃗n) with a primitive recursive matrix
F(x, y, ⃗n), under “real statements” provided that we can ﬁnd a test-function, i.e.,
a computable function f which for any numeral n provides us with a value f(n, ⃗n)
such that (∃y)F(n, y, ⃗n) becomes checkable by testing all instances k ≤f(n, ⃗n) for
the variable y. In such a situation we can check every instance of (∀x)(∃y)F(x, y, ⃗n)
by an “experiment”, i.e., by ﬁnitely many computations. For a true Π0
2-sentence
(∀x)(∃y)F(x, y, ⃗n) the function fF: x 㨃→min {y F(x, y, ⃗n)} is computable and thus
a test-function. Therefore any Π0
2-sentence that is provable in a sound theory T
possesses a test-function.
Given an axiomatized theory T we of course cannot expect to obtain a global
test-function which simultaneously tests all the provable Π0
2-sentences of T. Let
f be any arithmetical function and m := f(0) + 1. Then f cannot be a testfunction
4 Der Physiker verlangt gerade von einer Theorie, dass ohne die Heranziehung von anderwei-
tigen Bedingungen aus den Naturgesetzen oder Hypothesen die besonderen Sätze allein durch
Schlüsse, also auf Grund eines reinen Formelspiels abgeleitet werden. Nur gewisse Kombina-
tionen und Folgerungen der physikalischen Gesetze können durch Experimente kontrolliert
werden—so wie in meiner Beweistheorie nur die realen Aussagen unmittelbar einer Veriﬁkation
fähig sind. (Cited from [Hilbert, 1928] page 15)
5 Which is in accordance to Popper’s criterion that physical theories can at most be falsiﬁable.
6 Perhaps this is one of the reasons why Hilbert never directly reacted to Gödel’s results which
rely on an ω-defect. Though ¬Bew(n, 0 = 1 ) is provable for any numeral n its universal quan-
tiﬁcation becomes unprovable. This type of ω-rule was apparently a triviality for Hilbert.

294
|
W. Pohlers
for the sentence (∀x)(∃y)[y = m].⁷ So all we can expect is a function ΦT which
eventually majorizes all the test-functions for the Π0
2-sentences with parameters
that are provable in T. These considerations motivate the following deﬁnition.
Deﬁnition 2.1. A theory T whose language comprises the language of arithmetic
is experimentally checkable if there is a computable function ΦT such that for any
Π0
2-sentence with parameters that is provable in T a test-function is eventually ma-
jorized by ΦT. More precisely this means that for any Π0
2-sentence F( ⃗n) that is prov-
able in T there is a number k such that λx . ΦT(k + x, ⃗n) is a test-function for F( ⃗n).
We then say that ΦT designs experiments for the theory T.
In a Π0
2 analysis of an axiom system T we try to construct a computable function
that designs experiments for T.
Note 2.2. As an aside we want to emphasize the role of the parameters in the
above Π0
2-sentences. For diﬀerent parameters e in a T-provable Π0
2-sentence
(∀x)(∃y)F(x, y, e) there might be diﬀerent proofs depending on e. As we will indicate
later the test-function for (∀x)(∃y)F(x, y, e) will depend on its T-proof. So it makes a
big diﬀerence if T uniformly proves (∀e)(∀x)(∃y)F(x, y, e) or just (∀x)(∃y)F(x, y, e)
for certain number parameter e.
This corroborates the importance of the index e in the characterization of the
provably recursive functions {e}(x) ≃U(µy.T(e, x, y)) of a sound theory T, i.e., the
functions for which T proves (∀x)(∃y)T(e, x, y) where T denotes the Kleene predi-
cate.
According to this interpretation of “real entities” all statements above, i.e., more
complex than Π0
2 have to be regarded as “ideal”. Loosely speaking real statements
are statements which represent a computational content while ideal statements
are abstract in that sense that their instances cannot be computationally checked.
We will argue that this can be pinpointed by the sentence all methods that take ω
for an “actual inﬁnitary quantity” should be considered as “ideal”.
Given a formal theory T Hilbert’s programme of “elimination of ideal entities”
then requires the elimination of all ideal statements in a T proof of a Π0
2-statement.
We will report that an elimination of ideal statements can be obtained by re-
ﬁnements of Gentzen’s ordinal analysis and thus exhibits an additional aspect
how ordinal analysis contributes to Hilbert’s programme. We will moreover indi-
cate that this simultaneously allows for the construction of a test-function for the
Π0
2-statement and moreover a computable function that designs experiments for
T.
7 This simple argument is due to the referee.

Hilbert’s Programme and Ordinal Analysis
|
295
In course of this paper we will see that it is useful to distinguish diﬀerent levels
of ideality. The strict one, which comprises all statements above Π0
2—and thus al-
ready regards ω as an ideal ordinal—and the more abstract ones which comprise
the introduction of ideal notions on the more abstract level, e.g., sets obtained
by comprehensions, cardinals, ordinals obtained by reﬂections and similar “ab-
stract” processes. Before we go into the details of this distinction we brieﬂy resume
the main features of ordinal analysis.
3 Ordinal analysis
By an ordinal analysis of a mathematical theory T we commonly understand the
computation of its proof theoretic ordinal, i.e., the supremum of the order-types of
in T elementarily deﬁnable well-orderings whose well-foundedness is provable
from the axioms of T. Though I do not want to become too technical I will sketch
the main lines of an ordinal analysis. To do this we have to distinguish two forms
of proof theory. Predicative proof theory which analyzes predicative theories and
centers around subsystems of second order number theory and and impredicative
proof theory which is needed in the analysis of impredicative theories and today
centers primarily around subsystems of set theory.
3.1 Predicative proof theory
Predicative proof theory originated from Gentzen’s ordinal analysis of Peano arith-
metic. A central point in predicative proof theory is the fact that in the language
of arithmetic well-foundedness is a genuine Π1
1-notion.
The biggest progress since Gentzen is the use of inﬁnitary logic. The key no-
tion here is the well-known ω-rule which allows us to derive a formula (∀x)F(x)
from the inﬁnitely many premises F(n) for all numerals n ∈ℕ. A theorem by
Henkin and Orey ([Henkin, 1954], [Orey, 1956]) shows that ω-logic is complete for
the Π1
1-sentences that are true in the standard model ℕ. This can be reﬁned in so
far that even cut-free ω-logic is complete for Π1
1-sentences in that sense that a Π1
1-
sentence (∀X)F(X) is true in ℕiﬀthere is a countable (even recursive) ordinal α
such that
α
0 F(X) . Proof ﬁgures in cut-free ω-logic are well-founded ω-branching
inﬁnitary trees whose lengths are canonically measured by ordinals. The notion
α
0 F then stands for the fact that there is a proof tree for F in cut-free ω-logic
whose length is bounded by the ordinal α.

296
|
W. Pohlers
Using the cut-free ω-calculus we can deﬁne the truth-complexity of a Π1
1-
sentence by
tc((∀X)F(X)) :=
{
{
{
min {α
α
0 F (X)}
if this exist
ω1
otherwise.
If we express the well-foundedness of an arithmetically deﬁnable order-relation
≺(with ﬁeld ℕ, for simplicity) by
Wf(≺) ⇔(∀X)[(∀x)[(∀y≺x)y ∈X →x ∈X] →(∀x)[x ∈X]]
we obtain the connection between the order-type of ≺and the truth-complexity of
Wf(≺) by the boundedness property
otyp(≺) = tc(Wf(≺))
(1)
which is at least exactly true if ≺has a limit order-type. In general we only have ≤,
but this is due to silly syntactical details of the cut-free ω-calculus.
To compute upper bounds for the proof theoretic ordinal of a theory it thus
suﬃces to compute upper bounds for the truth-complexities of the provable
(pseudo)⁸ Π1
1-sentences that are provable in the theory.
The classical example for an ordinal analysis is Gentzen’s result for Peano
arithmetic. Via truth-complexities the computation of an upper bound for the
proof theoretic ordinal of Peano arithmetic is obtained by unraveling a formal
proof in Peano arithmetic into an inﬁnitary proof in ω-logic and then eliminat-
ing the cuts. The length of the such obtained cut free derivation then yields an
upper bound for the truth-complexity of the proved formula.
This pattern can be extended to “predicative” subtheories of second order
number theory. Second order number theory is Peano arithmetic formulated in
a second order language augmented by the comprehension scheme
(∃X)[(∀y)[y ∈X ↔F(y)]].
(CA)
Here F(y) is a formula in the language of second order number theory which must
not contain the second order variable X freely.
Since the formula F(y) in the comprehension scheme may contain second or-
der quantiﬁers which are supposed to range over sets of natural numbers it incor-
porates “impredicative deﬁnitions”. Informally we call an object “impredicatively
8 By a pseudo Π1
1-sentence we understand an arithmetical formula that must not contain free
number variables but may contain free second order variables.

Hilbert’s Programme and Ordinal Analysis
|
297
deﬁned” if its deﬁnition is circular, i.e., if its deﬁnition refers to an entity to which
the object itself belongs.
A remedy to avoid circularities is ramiﬁed analysis. We obtain a ramiﬁcation
of second order number theory by
–
saying that all quantiﬁers ranging over natural numbers are quantiﬁers of
stage 0,
–
deﬁning the stage of a formula as the maximum of the stages of all quantiﬁers
occurring in it,
–
introducing comprehension terms {y F(y)} of stage α + 1 if F(y) is a formula
of stage α and
–
stipulating that quantiﬁers of stage σ > 0 are supposed to range over compre-
hension terms of stages less than σ.
In addition to the ω-rule there is also a canonical inﬁnitary rule for the language
of ramiﬁed analysis which says that you can derive a formula (∀Xσ)F(X) from the
inﬁnitely many premises F(T) where T ranges over all comprehension terms of
stages less than σ. Derivations in ramiﬁed analysis are thus inﬁnite well-founded
trees whose lengths can be measured by countable ordinals. To make this formally
work we have to ﬁx some kind of calculus for ramiﬁed analysis. We will not— and
need not—introduce such a calculus in all details but, since we want to refer to
that also later, at least brieﬂy indicate such a calculus.
We use a one-sided sequent calculus a là Tait which derives ﬁnite sets of for-
mulas which are to be read as ﬁnite disjunctions.⁹ We denote by
α
ρ ∆that there
is a derivation of ∆of length ≤α whose cut-formulas have all a complexity strictly
less than ρ. To give two examples of the rules we display the cut rule
α
ρ ∆, F ,
α
ρ ∆, ¬F , α < β and rnk(F) < ρ
⇒
β
ρ ∆
and the inﬁnitary universal quantiﬁcation rule
αT
ρ ∆, F(T) and αT < β for all
comprehension terms of stages < τ
⇒
β
ρ ∆, (∀Xτ)F(X) .
The main meta-theorem for the calculus of ramiﬁed analysis is the following.
Theorem 3.1. Any derivation
α
β+ωρ ∆can be converted into a derivation
φρ(α)
β
∆.
Here φ denotes the binary Veblen function which is deﬁned such that φ0(α) =
ωα and for ρ > 0 the function φρ enumerates the common ﬁxed-points of the
9 Details about such calculi can e.g. be found in [Pohlers, 2009].

298
|
W. Pohlers
functions φξ for ξ < ρ. An ordinal that is closed under the binary Veblen function
is called strongly critical.
The technique to obtain upper bounds for subsystems of second order num-
ber theory is in principle the same as for Peano arithmetic. The ﬁrst step is to un-
ravel formal proofs into inﬁnitary proofs in ramiﬁed analysis and then to use The-
orem 3.1 and the boundedness property (1) to obtain an upper bound for the proof
theoretic ordinal.
Since there are no circularities in ramiﬁed analysis any theory that can be em-
bedded into it is apparently predicative. According to Theorem 3.1 any subtheory
of second order number theory that can be embedded into ramiﬁed analysis has
a proof theoretic ordinal that is less than or equal to the ﬁrst strongly critical or-
dinal Γ0. It is a famous result by S. Feferman and K. Schütte that conversely every
ordinal less than Γ0 can be predicatively justiﬁed. An ordinal α is predicatively
justiﬁed if it can be represented by a well-ordering ≺on the natural numbers for
which not only the deﬁnition of x ≺y is non-circular but also the proof of its
well-foundedness can be embedded into a system RAα which is ramiﬁed analy-
sis in which all formulas and comprehension terms have stages less than α and
only derivations of lengths less than α are permitted. In this technical sense the
Schütte-Feferman ordinal Γ0 is regarded as the bounding ordinal for predicativity.
There are series of subsystems of second order number theory that are embed-
dable into ramiﬁed analysis reaching from arithmetical comprehension, which is
conservative over Peano arithmetic over ∆1
1-comprehension, Σ1
2-choice to the sys-
tem (ATR)0 of autonomously iterated arithmetical comprehension that reaches Γ0.
3.2 A remark on semi-formal systems
We call deduction calculi with inﬁnitary rules semi-formal. Before we turn to im-
predicative systems we want to make some general remarks on semi-formal sys-
tems. For more information about semi-formal systems in general cf. [Pohlers,
2015].
Let S be any countable structure. A semi-formal system for S is commonly
built around a veriﬁcation calculus for S. The veriﬁcation calculus mimics the
truth deﬁnition for the elementary language LS of S. As to the intended extension
to a semi-formal system it makes sense to deﬁne the veriﬁcation for ﬁnite sets of
S-sentences which again should be read as ﬁnite disjunctions. It is technically
convenient to formulate the language LS in Tait style, i.e., to assume that there
is no negation symbol but to deﬁne negation via deMorgan’s laws. This requires
that for any relation in S there is also a symbol for its complement. We may then
divide the language LS into sentences in ⋁–type and sentences in ⋀–type and

Hilbert’s Programme and Ordinal Analysis
|
299
decorate every sentence F with a characteristic sequence CS(F) of sentences such
that
S 　㨐G for some G ∈CS(F) implies S 　㨐F
(2)
for sentences F in ⋁–type, and
S 　㨐G for all G ∈CS(F) implies S 　㨐F
(3)
for sentences F in ⋀–type.
Let us illustrate types and characteristic sentences by examples. To satisfy (3)
all sentences in the diagram of S, i.e. all true atomic sentences of S, should be
put into into ⋀–type with empty characteristic sequence. Similarly all sentences
(∃x)F(x) starting with a an existential quantiﬁer ranging over the domain of S
should be put into ⋁–type with CS((∃x)F(x)) = ⟨F(s) s ∈S⟩. Similarly (∀x)F(x)
should be put into ⋀–type with characteristic sequence ⟨F(s s ∈S⟩etc.
The veriﬁcation relation
α ∆is then given by two rules.
–
(⋁) From
αG ∆, G for some G ∈CS(F) infer
α ∆, F for all α > αG.
–
(⋀) From
αG ∆, G and αG < α for all G ∈CS(F) infer
α ∆, F.
The veriﬁcation calculus is clearly sound for S. Therefore we always have
α ∆implies S 　㨐⋁∆.
(4)
The ordinal α in
α ∆should be regarded as (an upper bound for) a measure of the
complexity of a veriﬁcation of the sentence ⋁∆. If the decoration is given in such a
way, that every sentence in the characteristic sequence of a sentence F has a lower
complexity than F and that also the opposite directions hold in (2) and (3)—which
holds true in case that S is the standard model for arithmetic—a simple induction
on the complexity of F even shows
S 　㨐F iﬀ
α F,
(5)
where α denotes the complexity of F.
In general the veriﬁcation calculus does not suﬃce for an ordinal analysis.
We have to extend it to a semi-formal system
α
ρ ∆by replacing
α ∆by
α
ρ ∆in
the (⋁) and (⋀)-rules and adding additional rules, among them the cut rule as
displayed below.
–
(cut): from
α
ρ ∆, F and
α
ρ ∆, ¬F for an LS-sentence F of rank < ρ infer
β
ρ ∆for all β > α.
Since well-foundedness is Π1
1-complete in the language of arithmetic we need free
second order variables in the deﬁnition of the proof theoretic ordinalsof arithmeti-
cal theories. To extend the veriﬁcation calculus for ℕto a semi-formal system that

300
|
W. Pohlers
is suited for an ordinal analysis we thus have to add a “rule” for second order vari-
ables, i.e., the rule
–
(X-rule): if s and t are arithmetical terms such that sℕ= tℕthen
α
ρ ∆, s ∉X, t ∈X holds for all ordinals α and ρ.
We then obtain that
α ∆implies
α
0 ∆, while the opposite direction only holds
for arithmetical sentences.¹⁰ In contrast to the completeness of
α F, which is a
triviality for arithmetical sentences, the completeness of
α
0 F is a non-trivial
theorem.¹¹ The truth-complexities for arithmetical sentences are ﬁnite while it
follows from the boundedness property (1) that for pseudo Π1
1-sentences truth-
complexities up to ωCK
1 are possible. This indicates that the presence of free second
order variables is indispensable—at least in the ordinal analysis of Peano arith-
metic and subsystems of second order number theory.
The presence or absence of second order variables in semi-formal systems
makes, however, a big diﬀerence. Theorem 3.1 shows that the elimination of cuts
in semi-formal systems with second order variables raises the derivation length
and gauging this raise is essential for the ordinal analysis. For semi-formal sys-
tems that only derive sentences the situation is diﬀerent. Here cut-elimination is
nearly a triviality.
Theorem 3.2. (Semantical cut elimination) Let
α
ρ ∆be the proof relation for a
semi-formal system that is sound for a structure S and only talks about sentences.
Then
α
ρ ∆already entails
α ∆.
Proof: Let
αι
ρ ∆, Gι for ι ∈I
⇒
α
ρ ∆, F
be a rule of the semi-formal system. Since
α
ρ ∆is sound for S we obtain from
S
̸　㨐F that S
̸　㨐Gι holds for at least one ι ∈I. Using this fact we obtain by an easy
induction on α:
if
α
ρ ∆, Γ holds true for a ﬁnite set Γ and S
̸　㨐G for all G ∈Γ then
α ∆.
The lemma then follows for Γ = 0.
◻
10 In former publications I deﬁned
α ∆such that
α
0 ∆also implies
α ∆. In view of the treat-
ment of impredicative systems it would have been wiser to distinguish these notions as I do it
here.
11 Cf.,e. g. [Pohlers, 2009] Theorem 5.4.9.

Hilbert’s Programme and Ordinal Analysis
|
301
3.3 Impredicative proof theory
Recall the proven schema to obtain upper bounds for the proof theoretical ordi-
nals of predicative theories which is:
–
Unravel a formal proof into a semi-formal proof
–
Eliminate the cuts
–
Use the boundedness property to obtain upper bounds for the proof theoreti-
cal ordinal.
The essential (metamathematical) step in this procedure is apparently cut elimi-
nation (Theorem 3.1) although for axiom systems above Peano arithmetic the step
of unraveling may also require sophisticated arguments.
If we imagine a situation in which we can deﬁne the proof theoretical ordi-
nal of a formal theory T by a sentence in the language of its standard model we
could replace cut elimination by semantical cut elimination and thus apparently
trivialize the procedure.
On the example of subsystems of set theory we are going to show that for im-
predicative axiom systems there is in fact a possibility to deﬁne their proof the-
oretical ordinals by properties expressible as sentences in the language of their
“standard models”. We will, however, also indicate that in these cases the un-
raveling procedure can only be obtained by introducing “abstract ideal ordinals”
which makes semantical cut elimination useless for ordinal analyses.
3.3.1 Axiom systems for set theory
When dealing with axiom systems in the language of set theory the ﬁrst problem
is that there is no commonly accepted standard model for set theory for which
we could design the semi-formal system. However, since we are still struggling
with axiom systems far below ZFC we may regard the constructible universe L as
the standard model. So in some sense L plays the role that ℕplays in the ordinal
analysis of subsystems of second order number theory.
Our basis axiom system BST for basis set theory comprises the axioms of
extensionality, pair, union and the schemes of absolute separation, i.e., ∆0-
separation, and foundation. Adding also the scheme of Σ1-collection we obtain
the system KP of Kripke-Platek set theory (cf. [Barwise, 1975]). KPω is Kripke-
Platek set theory plus the axiom of inﬁnity.
Using the constructible hierarchy L we are able to deﬁne characteristic ordi-
nals for axiom systems of set theory.

302
|
W. Pohlers
Deﬁnition 3.3. Let T be an axiom system in the language of set theory that pos-
sesses a model in the constructible hierarchy. Put
||T|| := min {α (∀F ∈Π2)[T
F ⇒Lα 　㨐F]}
and for admissible ordinals π > ω
||T||π := min {α (∀F ∈Π2)[T
FLπ ⇒Lα 　㨐F]}.
Clearly the second deﬁnition requires that T can talk about Lπ.
From the proof theoretical point of view we are of course only interested in ||T||π
for countable admissible ordinals π. Of special interest are the ordinals ||T||ωCK
1 and
later the ordinal ||T||ω, whose deﬁnition we have to postpone.
For axiom systems which comprise KPω the ordinal ||T||ωCK
1 corresponds¹² to
the proof theoretic ordinal |T|. We brieﬂy sketch why.
For a theory T in the language of arithmetic the proof theoretic ordinal |T|
is the supremum of the order-types of arithmetically deﬁnable well-orderings ≺
which T proves to be well-founded. Now let T be a theory in the language of set
theory comprising KPω. Then the language of arithmetic can be regarded as sub-
language of T in such a way that all arithmetical formulas become ∆0-formulas.
All arithmetically deﬁnable relations on ℕare thus sets by ∆0-separation. The
canonical generalization of the proof theoretic ordinal |T| for a theory T in the lan-
guage of set theory is therefore the supremum of the order-types of order-relations
that are sets in T and T proves their well-foundedness.
So let ≺be a well-ordering which is a set. The function otyp≺(x) which assigns
to every element x in the ﬁeld of ≺its order-type is Σ-deﬁnable. If we assume that
T is strong enough to prove the basic properties of LωCK
1 we thus may assume
T
(∀x ∈ﬁeld(≺))(∃α ∈LωCK
1 )[otyp≺(x) = α]
where we tacitly presuppose that lower case Greek letters denote ordinals. Since
this is a Π
LωCK
1
2
-sentence there is an ordinal below ||T||ωCK
1 that bounds the order-type
of the relation ≺. Hence |T| ≤||T||ωCK
1 .
For the opposite direction we refer to the fact that the least model for the prov-
able Π
LωCK
1
2
-sentences in the constructible hierarchy coincides with the least model
for the provable Σ
LωCK
1
1
-sentences.¹³ Assume β := |T| < ||T||ωCK
1 . Again we will assume
that T is strong enough to prove Σ1-reﬂection on LωCK
1 , i.e.
G
LωCK
1 →(∃x ∈LωCK
1 )(∃ξ ∈LωCK
1 )[x = Lξ ∧Gx]
(6)
12 If T is KPω the ordinal ||T||ωCK
1 is not deﬁned. In this case replace it by ||KPω||.
13 Cf.,e.g. [Pohlers, 1998] Lemma 1.2.3.

Hilbert’s Programme and Ordinal Analysis
|
303
for Σ1-sentences G. Moreover we assume that T allows for the deﬁnition of the
Σ-function ξ 㨃→Lξ and the deﬁnition of the canonical ∆1-relation <L that well-
orders the constructible sets. The assumption β < ||T||ωCK
1 entails that there is a
Σ1-sentence G such that T
G
LωCK
1 but Lβ
̸　㨐G. Then we obtain by (6)
T
(∃u ∈LωCK
1 )(∃ξ ∈LωCK
1 )[u = Lξ ∧Gu ∧(∀x ∈u)(∃y)[x <L y]]
where <L is the cononical well-ordering of L. Using Σ-reﬂection this entails
T
(∃z ∈LωCK
1 )(∃u ∈LωCK
1 )(∃ξ ∈LωCK
1 )[u = Lξ ∧Gu ∧(∀x ∈u)(∃y ∈z)[x <L y]].
Since this is a Π2-sentence relativized to LωCK
1 we get ξ < ||T||ωCK
1 . Because of Lβ
̸　㨐G
it follows β < ξ. Since otyp(<L ∩(Lξ × z)) ≥ξ > β and <L ∩(Lξ × z) is a set this
contradicts the deﬁnition of β. Hence ||T||ωCK
1 ≤|T|.
Because of the correspondence of ||T||ωCK
1 to |T| we call the computation of
||T||ωCK
1 still a Π1
1-analysis of T.
To deﬁne Π0
2-analysis also for theories in the language of set theory we have
to modify Deﬁnition 2.1.
The role of Π0
2-sentences is played by ΠLω
2 -sentences, i.e. sentences of the form
(∀x ∈Lω)(∃y ∈Lω)F(x, y, ⃗a) where F(x, y, ⃗x) is a ∆0-formula and ⃗a = a1, . . . , an a
tuple of elements in Lω.
A function Φ: Lω 㨀→ω is a test-function for (∀x)(∃y)F(x, y, ⃗a)Lω if for every
a ∈Lω there is a t ∈Lm such that Lω 　㨐F(a, t, ⃗a) and m ≤Φ({a} ∪{ ⃗a}).
A function Φ: Lω 㨀→ω is eventually majorized by a function Ψ: Lω 㨀→ω if
there is a k ∈ω such that Φ(a) < Ψ(a) holds true for all a ∈Lω \ Lk.
Deﬁnition 3.4. A function Φ: Lω 㨀→ω designs experiments for a theory T in the
language of set theory, if for any ΠLω
2 sentence with parameters from Lω which is
provable in T there is a test-function that is eventually majorized by Φ.
In a Π0
2-analysis of a theory T we try to construct a function that designs exper-
iments for T.
We will see that a function that designs experiments for a theory T can be ob-
tained via a subrecursive hierarchy indexed by ordinals. We may thus deﬁne ||T||ω
as the least ordinal at which the designing function appears. This deﬁnition is, how-
ever, less robust than the ordinal ||T||ωCK
1 since it depends on an eﬀectively deﬁnable
norm on the ordinals for which, in general, there are diﬀerent choices.¹⁴
14 Actually the resulting subrecursive hierarchy is pretty immune to diﬀerent choices.

304
|
W. Pohlers
3.3.2 Ramiﬁed set theory
To ﬁx the language for a veriﬁcation calculus for L we deﬁne the language LRS
of ramiﬁed set theory. The terms and sentences of LRS are given by the following
clauses:
–
For every ordinal α the term Lα is an atomic term of stage α and
–
if a1, . . . , an are terms of stages less than α and F(x, x1, . . . , xn) is a formula
in the language of set theory then {x ∈Lα F(x, a1, . . . , an)Lα} is a composed
term of stage α.
–
If F(x1, . . . , xn) is a ∆0-formula in the language of set theory whose free vari-
ables occur all in the list x1, . . . , xn and a1, . . . , an are terms of ramiﬁed set
theory then F(a1, . . . , an) is a sentence of ramiﬁed set theory.
By L<α we denote the sequence of all LRS-terms of stages less than α ordered by
the relation <L.
The ⋁–type of LRS comprises all sentences of the form a ∈b, F ∨G and
(∃x ∈a)F(x) and dually the ⋀–type comprises the sentences a ∉b, F ∧G and
(∀x ∈a)F(x).
For the sentences in ⋁–type the decoration is given by
–
CS(a ∈Lα) := ⟨a = s s ∈L<α⟩,
–
CS(a ∈{x ∈Lα F(x)}) := ⟨a = s ∧F(s) s ∈L<α⟩,
–
CS(F ∨G) := ⟨F, G⟩,
–
CS((∃x ∈Lα)F(x)) := ⟨F(s) s ∈L<α⟩,
–
CS((∃x ∈a)F(x)) := ⟨F(s) ∧G(s) s ∈L<α⟩if a is a composed
term {x ∈Lα G(x)}.
Dually we deﬁne a decoration CS(F) = ⟨¬G G ∈CS(¬F)⟩for the sentences in
⋀–type.
Having deﬁned a decoration for LRS we obtain a veriﬁcation calculus
α ∆for
ﬁnite sets of LRS-sentences.
The semantics for ramiﬁed set theory is obvious. Each atomic term Lα is in-
terpreted by the stage Lα in the constructible hierarchy and every composed term
is interpreted by the corresponding set in the constructible hierarchy. We did not
even make the eﬀort to distinguish the LRS-terms and the corresponding sets in
the constructible hierarchy notationally.
Observe that we only talk about ∆0-sentences in LRS. It is now easy to see
that the veriﬁcation calculus is sound and complete for L in the form that an LRS-
sentence is true in Lβ iﬀthere is an ordinal α such that
α FLβ.

Hilbert’s Programme and Ordinal Analysis
|
305
There is also a counterpart to the boundedness property (1) which roughly
says that
α FLβ for a Σ-sentence F containing only parameters from L<α entails
Lα 　㨐F.
To unravel formal proofs of Peano arithmetic (and other predicative theories)
into semi-formal derivations it suﬃces to augment the veriﬁcation calculus by the
(X-rule) for second order variables and the cut rule. This turns out not to be suf-
ﬁcient for impredicative systems. While there is no problem to embed BST into
a system augmented by a cut-rule there is no chance to embed the scheme of Σ-
collection, i.e., to get an embedding of KPω let alone of even stronger systems.
To be able to embed stronger theories we need “abstract ideal” objects, e.g.,
for KPω an abstract ideal ordinal Ωwhich is axiomatized by a reﬂection rule
α
ρ ∆, FLΩ
⇒
β
ρ ∆, (∃a ∈LΩ)[a
̸= 0 ∧Tran(a) ∧Fa]
(7)
for β > α where F is supposed to be a Π2-sentence.
If we interpret Ωby ωCK
1 the thus obtained semi-formal system is sound and
therefore enjoys semantical cut elimination. Interpreting Ωby ωCK
1 implies that we
need at least ωCK
1 many steps to embed the foundation scheme. The embedding
therefore produces semi-formal derivations with lengths above ωCK
1 in case that
the foundation scheme is among the axioms of our formal theory.¹⁵ Semantical
cut elimination together with the boundedness property will therefore not help
us in the computation of reasonable upper bounds for ||T||ωCK
1 which is always an
ordinal below ωCK
1 .
On the other hand it is clear by semantical reasons that for a tuple ⃗a ∈L<ωCK
1
and a Σ1-formula F( ⃗a) for which we have LωCK
1 　㨐F( ⃗a) there is an ordinal α < ωCK
1
such that
α F( ⃗a)
LωCK
1 . So there should exist a collapsing procedure that allows
us to collapse derivations of ΠLΩ
2 sentences into derivations of lengths below ωCK
1 .
Here we encounter the necessity for a collapsing procedure which is apparently
inevitable in any ordinal analysis of impredicative systems.
4 Elimination of ideal objects
In this section we want to discuss how ordinal analysis contributes to Hilbert’s
programme of elimination of ideal objects. We start with the elimination of “ab-
15 One might ask what happens if the foundation scheme is lacking or modiﬁed. This leads to a
series of theories which are either predicative (cf. [Jäger, 1986], [Pohlers, 2009]) or metapredica-
tive as Jäger and his school call them. Cf. [Jäger, 2005] for further information.

306
|
W. Pohlers
stract ideal objects” which is aﬃliated to the ordinal analysis of impredicative ax-
iom systems. The elimination of “all ideal objects” is more involved and will be
treated later.
4.1 Impredicative proof theory and the elimination of
“abstract ideal objects”
In the previous section we emphasized that the ordinal analysis of impredicative
axiom systems needs in general a collapsing procedure for semi-formal deriva-
tions. This clearly implies that we also need a collapsing function on the ordinals
that measure the lengths of semi-formal derivations. Since ordinals are transitive
and thus incollapsible this means that the lengths of the semi-formal derivations
that arise in the unravelling procedure must only be measured by ordinals that
are taken from a subset of the ordinals containing gaps which are large enough to
allow for the necessary collapsing. Finding the suitable sets of ordinals is actually
the most diﬃcult problem in impredicative ordinals analysis.
4.1.1 Iterated Skolem hull operators
A proven technique to obtain suitable sets of ordinals are iterations of Skolem
hull operators. A technique whose foundations have been laid by (mostly unpub-
lished) work of S. Feferman, P. Aczel, J. Bridge ([Bridge, 1975]) and W. Buchholz
([Buchholz, 1974], [Buchholz, 1975]).
Let F be a set of functions that assign ordinals to tuples of ordinals. The
Skolem hull operator HF: Pow(On) 㨀→Pow(On) generated by F is inductively
deﬁned by the clauses
–
HF
0 (X) = X,
–
HF
n+1(X) = HF
n (X) ∪{f(ξ1, . . . , ξk) ξ1, . . . , ξk ∈HF
n (X) ∧f ∈F}.
–
HF(X) = ⋃n HF
n (X).
A Skolem hull operator is Cantorian closed if ordinal addition and exponentiation
to the basis ω are among its generating functions.
Generated Skolem hull operator are apparently inﬂationary, monotone and
idempotent and thus not iterable. To obtain iterations of a Skolem hull operator
we therefore have to increase the set of generating functions in each iteration step.
An obvious way to do this is to add ordinals which are inaccessible by the so far
iterated Skolem hull operator. An ordinal ξ is F-inaccessible if ξ ∉HF(ξ), where
ξ is viewed as the set of its predecessors. So we deﬁne simultaneously iterations

Hilbert’s Programme and Ordinal Analysis
|
307
HF,α and functions ψF such that
ψF(α) := min {ξ ξ ∉HF,α(ξ)}
(8)
and augment for α > 0 the generators of HF,α by ψF↾α. As an example let us
assume that F = {+}. Then HF(0) = 0, hence ψF(0) = 0; HF,1(1) = 1, hence
ψF(1) = 1; HF,2(ω) = ω, hence ψF(2) = ω; ψF(n + 1) = ωn; ψF(ω) = ωω and
the least ordinal σ such that HF,σ(σ) = σ, i.e., ψF(σ) = σ is ε0, the proof theo-
retic ordinal of the axiom system PA. So ε0 is the largest transitive segment of the
ordinals which we can access by iterations of the Skolem hull operator generated
by {+}. Increasing the set F of generators to {+, λξ.ωξ} would give ψF(2) = ε0. But
even if we augment the set of generating functions by the Veblen function φ the
eventually attained segment is still too small as to capture the proof theoretic or-
dinals of “small” impredicative axiom systems such as ID1, the axiomatization of
non-iterated arithmetically deﬁnable positive inductive deﬁnitions, or KPω.
The operators and their iterations in these examples are transitive (or replete
as Feferman calls them in [Feferman, 1968]) in the sense that applied to a transi-
tive set of ordinals they return a transitive set of ordinals. For these operators we
have
ψF(α) = min {ξ HF,α(ξ) = ξ}.
As pointed out at the begin of this section we need a set of ordinals with gaps that
are large enough for the needed collapsing procedure. This can be obtained by
augmenting the set of generating functions by functions (or ordinals) which we
regard as “abstract ideal”. The simplest example is the addition of an ideal ordi-
nal Ωwhich lays safely outside the eventually obtained initial segment. Since the
eventually obtained segment is countable a possible interpretation for Ωcould be
the ﬁrst uncountable cardinal. The such obtained subset of the ordinals suﬃces
for an ordinal analysis of ID1, KPω or Π2 −Ref which is Kripke–Platek set theory
with the scheme of Π2-reﬂections. Adding the single ideal ordinal Ωto the func-
tions {+, λξ.ωξ}¹⁶ may thus be regarded as “the ﬁrst step into impredicativity”.
An obvious extension of the “ﬁrst step” is to add the function α 㨃→α+ to the
generators of F where α+ denotes the ﬁrst cardinal that is larger than α.
Augmenting the generating functions of an operator by ideal ordinals or func-
tions will in general spoil the transitivity of the generated operator. However, what
is kept in our examples is transitivity within number classes, i.e., HF耠(κ) ∩κ+ is a
transitive set for all cardinals κ. To obtain iterations of the so generated operator
16 Adding also the Veblen function is possible—and common—but does not increase the even-
tually obtained transitive segment.

308
|
W. Pohlers
we simultaneously deﬁne the iterations Hα (omitting now the superscript F耠and
suppressing technicalities) and functions ψκ+ by
–
ψκ+(α) := min {ξ Hα(ξ) ∩κ+ = ξ},
–
and add for α > 0 all functions ψλ+↾α to the generators of Hα.
Due to this deﬁnition we get Hα(ξ) = Hα+1(ξ) in case that α ∉Hα(ξ). So ψλ+(α) =
ψλ+(α + 1) and the functions are not one-to-one. To obtain one-to-one functions
we may build in the normal-form condition α ∈Hα(ξ), deﬁne
Ψα
κ+ := min {ξ α ∈Hα(ξ) ∧Hα(ξ) ∩κ+ = ξ}
and augment the generators in the iteration step by all functions Ψλ+↾α.
The price to pay is that the new functions Ψλ+ are partial but it is not too hard
to prove that all the iterations Hα are again transitive on number classes such that
Hα(κ) ∩κ+ = min {ξ κ ≤ξ ∉Hα(ξ) ∧α ∈Hα(ξ)}
= min {ξ Hα(ξ) ∩κ+ = ξ ∧α ∈Hα(ξ)} = Ψα
κ+.
Since Ψα
κ+ < κ+ holds true for all ordinals α the functions Ψκ+ are collapsing.¹⁷
Adding Ωω, the ﬁrst cardinal that is closed under cardinal successors, the so
obtained set of ordinals suﬃces for the ordinal analysis of KPl, an axiom system
based on Kripke-Platek set theory with a limit axiom that axiomatizes that every
set is contained in an admissible set.
Stronger systems can be obtained by adding further abstract ordinals, e.g.,
the ﬁrst weakly inaccessible cardinal. The thus obtained ordinal set suﬃces for
the analysis of KPi, an axiom system which axiomatizes an admissible universe
which is also the union of admissible universes (cf. [Jäger and Pohlers, 1983]).
Adding a Mahlo cardinal (together with the necessary modiﬁcation of the gen-
erating functions, cf. [Rathjen, 1990]) leads to a set of ordinals that suﬃces for the
ordinal analysis of KPM, a theory which axiomatizes a recursively Mahlo universe.
Yet stronger systems require a reﬁnement in the addition of abstract ideal or-
dinals. The iteration of the Skolem hull operator has to be combined with itera-
tions of thinning procedures on the cardinals, i.e., on the abstract ideal ordinals.
Thinning operations are a familiar tool in the development of ordinal notations
systems. A well-known example is the derivative of a class of ordinals which is
the class of ﬁxed-points of its enumerating function. So we obtain the Veblen
functions as enumerating functions of classes that are obtained as transﬁnitely
iterated derivatives of the class of additively indecomposable ordinals (cf., e.g.
[Pohlers, 2009] Section 3.4).
17 Cf.[Buchholz, 1986] for more information.

Hilbert’s Programme and Ordinal Analysis
|
309
An important thinning operation on the cardinals is the Mahlo-operation
M(X) := {π ∈X X is stationary in π}.
Starting with a cardinal κ we get an iteration of the Mahlo-operation by deﬁning
M0
κ = κ, Mα+1
κ
= M(Mα
κ) and taking the diagonal intersection
Mλ
κ = {ξ ∈λ (∀η < ξ)[ξ ∈M(Mη
κ)]}
at limit levels λ. To combine this with the iterations of a Skolem hull operator H
we then deﬁne the sets
Mα
κ := {ξ ∈κ (∀η ∈Hα(ξ) ∩α)[ξ ∈M(Mη
κ)] ∧Hα(ξ) ∩κ = ξ ∧α ∈Hα(ξ)}
for regular cardinals κ, put Ψα
κ := min Mα
κ and let Hα be the iterations of the
Skolem hull operator H whose generators are augmented by all functions Ψκ↾α in
the iteration step. Michael Rathjen has shown in [Rathjen, 1992] that, starting with
the ﬁrst weakly compact cardinal, (a reﬁnement of) this procedure—the technical
details do not matter in our discussion—suﬃces to obtain a set of ordinals that
allows for an analysis of Kripke-Platek set theory augmented by the scheme of
Π3-reﬂection.
For stronger theories more sophisticated thinning operations become neces-
sary which make the technical details much more complicated. (cf. e.g. [Rathjen,
2005a], [Rathjen, 2005b], [Pohlers and Stegert, 2012]). To explain the principle we
do not need these details. However, we should mention that for successor cardi-
nals we can put M(Mα
κ+) = 0. All cardinals that are relevant in the iteration of the
thinning procedure are regular limit cardinals. Observe that this implies
Ψα
κ+ = min {ξ Hα(ξ) ∩κ+ = ξ ∧α ∈Hα(ξ)}
which shows that these functions are still collapsing and continue the previously
deﬁned Ψκ+ functions without thinning operations.
The cardinals that are needed in the ordinal analysis of Πn+3-reﬂection,
i.e., basis set theory BST plus the reﬂection scheme for Πn+3-formulas are Π1
n+1-
indescribable cardinals. Recall that the ﬁrst weakly compact cardinal is the ﬁrst
Π1
1-indescribable cardinal.
For the theory Ref which is BST plus full reﬂection we need a cardinal Ξ that
is Π1
n-indescribable for all n ∈ω. (cf. [Pohlers and Stegert, 2012]).
The theory of stability, i.e., Kripke-Platek set theory augmented by the weak
stability axiom which requires for every ordinal α and every ordinal ξ the exis-
tence of an ordinal κ ≥α such that Lκ is a Σ1-elementary substructure of Lκ+ξ,
needs cardinals that are ν-indescribable. For an ordinal ν =NF ω ⋅λ + m a car-
dinal κ is ν-indescribable if for any Π1
m-formula F(X1, . . . , Xn) with variables

310
|
W. Pohlers
X1, . . . , Xn and sets Pi ⊆Vκ such that (Vκ+λ, P1, . . . , Pn) 　㨐F(X1, . . . , Xn) there
is an ordinal π < κ such that (Vπ+λ, P1 ∩Vπ, . . . , Pn ∩Vπ) 　㨐F(X1, . . . , Xn).¹⁸.
Below a subtle cardinal there is a least cardinal 훶such that for all ν < 훶there is a
κ < 훶such that κ is ν-indescribable and for every ν-indescribable cardinal κ < 훶
we already have ν < 훶. Adding this cardinal together with the associated thinning
operations (which actually are pretty involved) the eventually obtained ordinal
set suﬃces for an ordinal analysis of stability. Details will appear in [Pohlers,
201xb].
Even lager cardinals have to be added to obtain a subset of the ordinals which
allows for an ordinal analysis of the theory STAB, which is Kripke-Platek set theory
augmented by the axiom of full stability which says that for every ordinal α there
is a cardinal κ ≥α such that Lκ is a Σ1-elementary substructure of L. Here we need
cardinals that are gap-indescribable, similar to the ν-indescribable cardinals, but
also move the length of the reﬂected gap. The theory STAB is equivalent to Kripke-
Platek set theory with the scheme of Σ1-separation which in turn is equivalent to
second order number theory with the axiom of parameter free Π1
2-comprehension.
These theories represent the present summit of theories for which an ordinal anal-
ysis is obtainable.
Observe that every ordinal in Hα(X) can be represented by an ordinal-term,
i.e. a ﬁnite string of symbols that is built up from symbols for the generators, the
symbol Ψ and the parameters in X. It thus provides a notation system for the or-
dinals in the initial transitive segment.
An essential point to mention is that already the construction of the ordinal
sets via iterated Skolem hull operators has the ﬂavor of elimination of abstract
ideal objects. Although constructed with the aid of large cardinals the eventually
obtained set of ordinals is primitive-recursively deﬁnable as a set of ordinal-terms
and the “less than”-relation restricted to ordinal-terms is primitive-recursively de-
cidable.
This entails that the eventually obtained transitive segment of the ordinal set
is an ordinal less than ωCK
1 which means that the function Ψω1 is not only collaps-
ing below ω1 but actually collapsing below ωCK
1 . A fact that is essential for the
ordinal analysis since we are looking for an upper bound below ωCK
1 .
Another consequence is that the eventually obtained set of ordinals may be
constructed without reference to large cardinals as a primitive-recursively deﬁned
set of ordinal-terms with a primitive-recursive order relation on them. This adheres
to an elimination of the ideal abstract object “large cardinal”.
18 This is a variation of the deﬁnition in [Drake, 1974] CH. 9, §4.

Hilbert’s Programme and Ordinal Analysis
|
311
In doing so we clearly loose the information that this ordering is well-
founded. The well-foundedness of the ordering then has to be secured by a well-
foundedness proof which (at least in all known examples) exceeds the means of
the analyzed theory “by an ω-defect”. Here we say that a sentence (∀x)F(x) ex-
ceeds the means of a theory T by an ω-defect if T proves F(n) for every standard
number n but is unable to prove (∀x)F(x).
4.1.2 Axiomatization of ideal ordinals
We have seen in (7) that the abstract ideal ordinal Ωis axiomatized by a rule
that is aﬃliated to the complexity class of Π2-formulas. Similar rules are needed
for other abstract ideal objects, e.g., ordinals with stronger reﬂection properties.
Again these abstract ideal ordinals are in general aﬃliated to certain complexity
classes of formulas. Since we want only explain the principles we will not specify
them in full detail.
Nevertheless there is one feature which is worth while mentioning. While
we use indescribable cardinals in iterating the Skolem hull operators we axiom-
atize them in ramiﬁed set theory by rules for reﬂecting ordinals. Recall that an
ordinal κ is Πm-reﬂecting if for every Πm-formula F(a1, . . . , an) with parameters
a1, . . . , an ∈Lκ such that Lκ 　㨐F(a1, . . . , an) there is an ordinal π < κ such that
a1, . . . , an ∈Lπ and Lπ 　㨐F(a1, . . . , an). Generalizing that to gap-reﬂection we
say that an ordinal κ is Πm-λ-gap-reﬂecting if for every Πm-sentence F(a1, . . . , an)
with parameters a1, . . . , an ∈Lκ+λ such that Lκ+λ 　㨐F(a1, . . . , an) there is an ordi-
nal π < κ such that Lπ+λ 　㨐F(a1κ↓π, . . . , anκ↓π) where aκ↓π is a pruning procedure
in which all occurrences of Lκ are replaced by Lπ.¹⁹. For ν =NF ω ⋅λ + m we call an
ordinal ν-reﬂecting if it is Πm-λ-gap-reﬂecting.
The correspondence between indescribable cardinals and reﬂecting ordinals
is such that for m < ω an m + 1-indescribable cardinal is axiomatized by a Πm+3-
reﬂection rule while for ω < ν =NF ω ⋅λ + m a ν-indescribable cardinal is axioma-
tized by a rule for a ν-reﬂecting ordinal. This is in accordance with the studies of
Peter Aczel and Wayne Richter who showed that Πm+3-reﬂecting ordinals are the
“recursive counterparts” of Π1
m+1-indescribable cardinals in [Aczel and Richter,
1972] for the case m = 0. The generalization to arbitrary ﬁnite m is more or less
obvious. A result that is corroborated by the fact that the axiomatization of Π1
m+1-
indescribable cardinals by Πm+3-reﬂecting ordinals gives the correct proof theo-
retic ordinals.
19 Details will appear in [Pohlers, 201xb].

312
|
W. Pohlers
Here we encounter yet another level of “abstract idealizations”. Reﬂecting
ordinals as a “generalized-constructive” idealization and the correponding large
cardinals as their “absolute” abstractions. Since the eﬀort to develop the itera-
tions of Skolem hull operators on the basis of ν-reﬂecting ordinals instead of ν-
indescribable cardinals turns out to be extreme this situation may serve as an-
other example for Hilbert’s dictum “that only the introduction of ideal propositions
makes mathematical reasoning possible”.
The fact that we eventually can eliminate the ideal object “large cardi-
nal” to such an extend that we end up with an “experimentally checkable Π0
2-
statement”—i.e., a statement that is obtainable without any reference to ideal
objects, let alone “large cardinals”—may be taken as an aﬃrmation even if not
for the existence then for the usefulness of large cardinals.
4.1.3 Operator controlled derivations
Given a semi-formal system we call the ordinals which have to be axiomatized by
rules the “ideal ordinals” of the system. E.g. all regular cardinals are ideal.
To exploit the subsets of the ordinals obtained by iterations of Skolem hull op-
erators proof-theoretically we introduce operatorcontrolled inﬁnitaryderivations.
A method invented by Wilfried Buchholz in [Buchholz, 1992] as an improvement
of the method of local predicativity (cf. [Pohlers, 1981]).
In a ﬁrst step we deﬁne the ordinal parameters of a sentence in the semi-
formal system. If F is a sentence of the language LRS its parameters are the stages
of all the terms occurring in it. Let par(F) denote the set of parameters occurring
in F and equally par(∆) denote the set of all parameters occurring in the sentences
of the ﬁnite set ∆.
Deﬁnition 4.1. We modify the deﬁnition of a semi-formal derivation
α
ρ ∆to a semi-
formal derivation controlled by an operator H (denoted by H
α
ρ ∆) by requiring that
α ∈H(par(∆)) and also par(∆ι) ⊆H(par(∆)) for every inference
αι
ρ
∆ι
⇒
α
ρ ∆
which is not an inference according to (⋀).
The restriction to α ∈H(par(∆)) in the ordinal assignment of an operator con-
trolled derivation ensures that only collapsible ordinals are assigned.
The cut elimination theorem for predicative proof theory (Theorem 3.1) re-
mains true for operator controlled derivations provided that there are no ideal
ordinals strictly between β and β + ωρ.

Hilbert’s Programme and Ordinal Analysis
|
313
The main theorem for operator controlled derivations, formulated for a semi-
formal system for ramiﬁed set theory LRS, then has (very roughly²⁰ ) the following
form.
Theorem 4.2. Let F be a sentence belonging to the complexity class of the ideal
ordinal π. Then
H
α
κ+1 FLπ for an ideal ordinal κ implies Hωα=‖ κ=‖µ+1
Ψ ωα=‖ κ=‖ µ+ω
π
Ψ ωα=‖ κ=‖ µ
π
FLµ for all µ ∈Mωα=‖ κ
π
.
Since Ψωα=‖ κ=‖µ+ω
π
is always an ordinal below π no rules for ideal ordinals ≥π oc-
cur in the derivation that is reduced according to Theorem 4.2. The reduction thus
incorporates an elimination of all ideal ordinals ≥π in semi-formal proofs of sen-
tences belonging to the complexity class of π.
Deﬁnition 4.3. We say that a formal theory T (in the language of set theory) has
a model in ramiﬁed set theory at level π if there are a transitive Cantorian closed
Skolem hull operator H and for every theorem F of T ordinals α < επ+1 and n < ω
such that H
α
π+n FLπ.
For a theory T that has a model in ramiﬁed set theory at an abstract ideal ordinal
π we obtain an ordinal analysis in the following way. Let F be a Π2-sentence such
that F
LωCK
1 is provable in T. We ﬁrst get H
α
π+1 FLΩfor an ordinal α < επ+1 by the
fact that T has a model in ramiﬁed set theory at π and predicative cut elimination.
Since Π2 is the complexity class which belongs to Ω, and we further have that
Ω> Ψεπ+1
Ω
> 훾:= Ψωα=‖ π=‖Ω
Ω
∈Mωα=‖ π
Ω
we obtain by Theorem 4.2
Hωα=‖ π=‖훾+1
Ψ
ωα=‖ π=‖훾+ω
Ω
Ψ
ωα=‖ π=‖훾
Ω
FL훾
and thus ||T||ωCK
1 ≤Ψεπ+1
Ω
. More precisely we know from
Ψ
ωα=‖ π=‖훾
Ω
< Ψ
ωα=‖ π=‖훾+ω
Ω
< Ω
and 훾< Ωthat the semi-formal derivation of FL훾as shown above cannot contain
rules for abstract ideal ordinals. Therefore we obtained an ordinal analysis of T
20 For the sake of simplicity we suppress all technical details. See [Pohlers and Stegert, 2012]
and [Pohlers, 201xb] for details. Theorem 4.2 below can be proved from Theorem 5.9 in [Pohlers
and Stegert, 2012] similar to Theorem 5.10 in [Pohlers and Stegert, 2012]. The notion α =‖ β denotes
the natural (symmetrical) sum of ordinals.

314
|
W. Pohlers
by eliminating all “abstract” ideal objects in a formal proof of a Π
LωCK
1
2
-sentence for
the costs of transforming the formal derivation into an inﬁnitary derivation. How-
ever, as mentioned at the end of Section 4.1.1, the “inﬁnity” of this derivation can be
measured by the order-type of a relation on the natural numbers which is primitive-
recursively deﬁnable without the use of abstract ideal objects.
4.2 Subrecursive hierarchies and the elimination of all
idealizations
The elimination of abstract ideal objects as demonstrated in the previous section
becomes only visible in impredicative theories. It may even be viewed as charac-
teristic for impredicative theories that their ordinal analyses need the introduc-
tion of abstract ideal ordinals which (in combination with a foundation scheme)
reﬂect the impredicative content of the analyzed theory.
It is much harder to see how to eliminate all ideal objects in the strict sense,
i.e., all objects whose descriptions have complexities beyond Π0
2. Since the com-
putability of a recursive function with index e can be expressed by the Π0
2-
sentence (∀y)(∃y)T(e, x, y) the complexity class Π0
2 represents the bounding of
algorithmic computatiblity. The “ideal objects”, i.e. the objects of larger complex-
ity than Π0
2, may thus be regarded as those which reﬂect a non-computational
content.
On the ordinal side the elimination of all strictly ideal objects means the elimi-
nation of all actually inﬁnite ordinals including ω. The actual closure properties of
ordinals will be “potentially” approximated by suﬃciently increasing functions.
Already in the embedding of formal derivations into the semi-formal system
we have to treat ω as an ideal ordinal. While no additional axioms to ﬁx ω as an
ideal ordinal are necessary in subsystems of second order number theory—there
all ﬁrst order quantiﬁers are supposed to range over ω and ω is suﬃciently axiom-
atized by the ﬁrst order axioms of Peano arithmetic and the scheme of mathemat-
ical induction—we need deﬁning axioms for Lω in the framework of set theory. To
deﬁne Lω as the set of hereditarily ﬁnite sets turned out to be a good choice.
We are going to indicate that a Π0
2-analysis of a theory T is obtained by elim-
inating all objects that are ideal in the strict sense. Recall that a Π0
2-analysis of a
theory T means the computation of a function that designs experiments for T.
For Peano arithmetic such functions have been known for long (cf. [Schwicht-
enberg and Wainer, 2012] Chapter 4 for more information). Here we want to indi-
cate on the example of subsystems of set theory that such functions can be ob-

Hilbert’s Programme and Ordinal Analysis
|
315
tained via a reﬁned ordinal analysis in a very general way.²¹ A way the emphasis
of which lays on the elimination of all ideal objects. Clearly we can only outline the
main features suppressing all technical details. Details are in [Pohlers, 2009] (for
Peano Arithmetic) and [Pohlers and Stegert, 2012] (for a subsystem of set theory)
and will appear for systems of iterated inductive deﬁnitions in [Pohlers, 201xa].
In contrast to the “abstract ideal ordinals” we do not need a deﬁning rule for ω
in ramiﬁed set theory. It is possible to exploit the fact that Lω coincides with the
hereditarily ﬁnite sets. Choosing an adequate starting function Φ there is a frag-
mented controlled derivation—as deﬁned below—in ramiﬁed set theory of the fact
that every set in Lω is hereditarily ﬁnite.
4.2.1 Subrecursive hierarchies
To outline the strategy we ﬁrst cite a deﬁnition which is due to Andreas Weiermann
(cf. [Buchholz et al., 1994]) . Given a starting function Φ: ℕ㨀→ℕand a set O of
ordinals such that every ordinal α ∈O possesses a norm N(α) < ω satisfying some
natural prerequisites we can deﬁne a function ψ: O 㨀→ω by
ψ(α) := sup {ψ(β) + 1 β < α ∧N(β) < Φ(N(α))} ∪{0}.
Deﬁning Φα(x) := ψ(ω ⋅α + x) we obtain Φn(x) ≈Φn(x) where the latter means
the familiar iteration of the function Φ. Therefore Φα is closely connected to the
more familiar fast growing subrecursive hierarchy Φα which is deﬁned by
Φ0(x) = x, Φα+1(x) = Φ(Φα(x)) and Φλ(x) = Φλ[x](x)
for limit ordinals λ where λ[x] denotes the xth member of a ﬁxed fundamental se-
quence for λ. Starting with a primitive-recursive function Φ satisfying some mild
conditions we obtain that Φε0 designs experiments for Peano arithmetic.²²
4.2.2 Elimination of all ideal objects
We will indicate that Weiermann’s deﬁnition of subrecursive hierarchies com-
bined with (iterations of) Skolem hull operators provides a Π0
2-analysis of a the-
ory, i.e., a function ΦT that designs experiments for T. The pioneering work in
this direction has been done by Weiermann and Benjamin Blankertz ([Blankertz
and Weiermann, 1996], [Blankertz, 1997]).
21 This can be easily transfered to systems of iterated inductive deﬁnitions (cf. [Pohlers, 201xa]).
22 Cf. [Pohlers, 2009] Chapter 10.

316
|
W. Pohlers
Recall that the ordinals in H(X) can be notated by ﬁnite strings built up from
the generators of H and the parameters in X. This can be made unique such that
every ordinal α ∈H(X) can be equipped with a norm function N(α) which is the
length of its notation. Let Φ: ℕ㨀→ℕbe a primitive recursive function.
Deﬁnition 4.4. Let X be a set of ordinals. Then we we deﬁne recursively
ψH(X)
Φ
(α) := sup {ψH(X)
Φ
(β) + 1 β ∈H(X) ∩α ∧N(β) < Φ(N(α))} ∪{0}.
Since there are only ﬁnitely many β < α such that N(β) < Φ(N(α)) the values of
ψH(X)
Φ
are ﬁnite. The function ψH(X)
Φ
therefore collapses α below ω and we deﬁne
for regular cardinals κ the function ΦH(X)
κ
: ℕ㨀→ℕby
ΦH(X)
κ,α (x) := ψHα(X)
Φ
(Ψα
κ + x).
By the remark in the end of Section 4.1.1 the ordinals Ψα
Ωare deﬁnable without use
of abstract ideal ordinals. Therefore the functions ΦH(X)
Ω,α
can be regarded as con-
tinuations of their predicative versions Φα mentioned above.²³
For a Π0
2-analysis also the “ﬁnite content” of parameters matters. Therefore we
deﬁne for a ﬁnite set X of ordinals
|X| := max({N(α) + 1 α ∈X} ∪{X + 1}),
where X stands for the cardinality of the set X, and deﬁne the fragmented iteration
fΦHα
κ of a Skolem-hull operator H by²⁴
fΦHα
κ(X) := {ξ ∈Hα(X) N(ξ) < ΦHα(X)
κ,α
(|X|)}.
Then we deﬁne fragmented controlled derivations²⁵ in complete analogy to opera-
tor controlled derivations in ramiﬁed set theory.
Deﬁnition 4.5. We modify the notion of an operator controlled derivation to a frag-
mented operator controlled derivation fΦH훾
κ
α
ρ ∆by requiring α ∈fΦH훾
κ(par(∆))
and also par(∆ι) ∪{|par(∆ι)|} ⊆fΦH훾
κ(par(∆)) for every inference
αι
ρ
∆ι
⇒
α
ρ ∆
not according to (⋀).
23 Since we deﬁned Ψα
κ only for regular κ, this subrecursive hierarchy is much coarser than the
previous one. In fact it skips the whole predicative part. To retrieve also the predicative part one
could deﬁne Ψα
0 = α and ΦH(X)
κ,α
(x) := ψHα(X)
Φ
(ω ⋅Ψα
κ + x). But this is inessential for our purpose.
24 This notation deviates from [Pohlers and Stegert, 2012] where we denoted it by FH
κ,α suppress-
ing to mention the ﬁxed starting function Φ
25 This technique is due to Jan Carl Steger ([Stegert, 2011]).

Hilbert’s Programme and Ordinal Analysis
|
317
Predicative cut-elimination (Theorem 3.1) remains true for fragmented controlled
semi-formal derivations in the modiﬁcation
fΦH훾
κ
α
β+ωρ ∆⇒fΦH훾=‖φρ(α)+1
κ
φρ(α)
β
∆
and the main theorem (Theorem 4.2) modiﬁes to
Theorem 4.6. Let F be a formula belonging to the complexity class of the ideal or-
dinal π. Then
fΦHπ
α
κ+1 FLπ implies fΦHωα+κ+µ+1
π
Ψ ωα+κ+µ+ω
π
Ψ ωα+κ+µ
π
FLµ for all µ ∈Mωα+κ
π
.
We already mentioned that we do not need a deﬁning rule for ω in ramiﬁed set
theory. The ordinal ω can be characterized by the fact that all sets in Lω are hered-
itarily ﬁnite. To gauge the exponential growth of the stages of the hereditarily ﬁnite
sets in a fragmented controlled semi-formal derivation we have to start with an ex-
ponentially growing function Φ. Therefore we deﬁne ϕ(0) := 1, ϕ(n + 1) := 2ϕ(n)
and Φ := ϕ2. Though there is no rule and thus no complexity class aﬃliated to a
rule for ω there is a theorem which connects ω to the class of Π2 sentences that
are valid in Lω. To save indices let Φ
α
κ(X) := ΦHα(X)
κ,α
(|X|).
Theorem 4.7. (Witnessing
Theorem) Assume
fΦH훾
κ
α
0 (∃x)F(a1, . . . , an, x)Lω
holds true for a Σ1-formula (∃x)F(x1, . . . , xn, x) and a tuple a1, . . . , an of LRS-
terms of stages less than ω. Then there is a t ∈Lm such that Lω 　㨐F(a1, . . . , an, t)
and m < Φ
훾+ωα+1
κ
({a1, . . . , an}).
From the witnessing theorem we obtain for a Π2-formula F ≡(∀x)(∃y)G(x, y, ⃗a)
and a, ⃗a ∈Lω such that fΦH훾
κ
α
0 FLω the function Φ
훾+ωα+1
κ
as a test-function for F.
Since testing Lω 　㨐G(a, t, ⃗a) for all t ∈Lm with m < Φ
훾+ωα+1
κ
({a1, . . . , an, a}) is
just a computation that needs not to refer to ideal objects it constitutes an elimi-
nation of all ideal objects.
Observe that even for the ordinal notation system we do not need ω as an
“actual inﬁnity” since it can be represented by a primitive-recursive ordering on
ℕfor which we need ℕ, i.e., ω, only as “potential inﬁnity”. So we may in fact talk
about an elimination of ω as completed inﬁnity.
We sharpen Deﬁnition 4.3 by saying that T has a strict model in ramiﬁed set
theory at level π if there are a primitive-recursive function Φ, a Cantorian closed
Skolem hull operator H and for all theorems F of T ordinals α < επ+1 and n < ω
such that fΦHΩ
α
π+n FLπ .
If a formal theory T has a strict model at level π in ramiﬁed set theory and
T
FLω for a Π2 sentence F we obtain from predicative elimination (Theorem 4.6)

318
|
W. Pohlers
and the Witnessing Theorem an α < Ψεπ+1
Ω
such that Φ
α
Ωis a test-function for F.
However, α < β does not yet entail Φ
α
Ω(X) < Φ
β
Ω(X), since we not necessarily have
N(Ψα
Ω+ |X|) < Φ
β
Ω(N(Ψβ
Ω+ |X|)). This, however, becomes true for large enough
|X|. Therefore Φ
Ψ
επ+1
Ω
Ω
eventually majorizes a test-function for any ΠLω
2 -sentence F
provable in T and thus designs experiments for T. So we obtain ||T||ω = Ψεπ+1
Ω
=
||T||ωCK
1 .
5 Conclusion
The aim of the paper was to discuss an aspect of the relation of ordinal analyses to
Hilbert’s programme. Though consistency is a byproduct of ordinal analysis it can
hardly be argued that it fully meets Hilbert’s demand for a ﬁnitistic consistency
proof. Of course one could debate in how far the reduction of the consistency of
an abstract axiom system to the well-foundedness of a primitive-recursively de-
ﬁnable ordering on the natural numbers constitutes a step towards an “eﬀective”
consistency proof. But this was not the concern of this paper.
Here we wanted contrariwise argue that ordinal analysis itself rests on an-
other aspect of Hilbert’s programme, the elimination of ideal elements. We had to
distinguish three levels of ideal objects which can be symbolized by the existence
of certain ordinals. Ideal objects in the strict sense, symbolized by the existence
of ω. Ideal objects of the ﬁrst level of abstraction, symbolized by the existence of
certain admissible ordinals above ω and ideal objects of the second level of ab-
straction, symbolized by the existence of indescribable cardinals.
Elimination of abstract ideal objects is the main feature of impredicative proof
theory. Ideal objects of the ﬁrst level of abstraction, formalized by rules for ad-
missible ordinals above ω, are needed to unravel formal proofs into semi-formal
proofs. Abstract ideal objects of the second level of abstraction are needed in the
construction of the sets of ordinals that contain the necessary gaps for collapsing.
While indescribable cardinals are already eliminated during the construction
of the ordinal sets the elimination of rules for admissible ordinals (> ω) takes
place in the Π1
1-analysis. Π0
2-analysis in addition needs the elimination of all com-
plexites above Π0
2.
Predicative systems do not need abstract ideal objects. The only ideal object
needed there is ω, axiomatized formally by the scheme of mathematical induction
and by the ω-rule in the semi-formal systems. Similar to Section 4.2 this rule is
eliminated—in a controlled way—in a Π0
2-analysis of predicative systems. Details

Hilbert’s Programme and Ordinal Analysis
|
319
for the case of Peano arithmetic are in [Pohlers, 2009] Chapter 10 and for iterated
inductive deﬁnitions in [Pohlers, 201xa].
References
Peter Aczel and Wayne H. Richter. Inductive deﬁnitions and analogues of large cardinals. In
Wilfrid Hodges, editor, Conference on Mathematical Logic – London 1970, number 255 in
Lecture Notes in Mathematics, pages 1–9, Heidelberg/New York, August 1972. Springer.
Jon Barwise. Admissible Sets and Structures. Perspectives in Mathematical Logic. Springer,
Berlin/Heidelberg/New York, 1975.
Benjamin Blankertz. Beweistheoretischen Techniken zur Bestimmung von Π0
2–Skolem Funktio-
nen. Dissertation, Westfälische Wilhelms-Universität, Münster, 1997.
Benjamin Blankertz and Andreas Weiermann. How to characterize provably total functions
by the Buchholz operator method. Number 6 in Lecture Notes in Logic. Springer, Heidel-
berg/New York, 1996.
Jane Bridge. A simpliﬁcation of the Bachmann method for generating large countable ordinals.
Journal of Symbolic Logic, 40:171–185, 1975.
Wilfried Buchholz. Rekursive Bezeichungssysteme für Ordinalzahlen auf der Grundlage
der Feferman–Aczelschen Normalfunktionen Θα. Dissertation, Ludwig Maximilians–
Universität, München, 1974.
Wilfried Buchholz. Normalfunktionen und konstruktive Systeme von Ordinalzahlen. In Justus
Diller and Gert H. Müller, editors, 　㨐ISILC Proof Theory Symposium, number 500 in Lecture
Notes in Mathematics, pages 4–25, Heidelberg/New York, July 1975. Springer.
Wilfried Buchholz. A new system of proof-theoretic ordinal functions. Annals of Pure and
Applied Logic, 32:195–207, 1986.
Wilfried Buchholz. A simpliﬁed version of local predicativity. In Peter Aczel, Harold Simmons,
and Stanley S. Wainer, editors, Proof Theory, pages 115–147, Cambridge, July 1992. Cam-
bridge University Press.
Wilfried Buchholz, E. Adam Cichon, and Andreas Weiermann. A uniform approach to fundamen-
tal sequences and hierarchies. Mathematical Logic Quarterly, 40:273–286, 1994.
Frank R. Drake. Set Theory: An introduction to large cardinals. Number 76 in Studies in Logic
and the Foundations of Mathematics. North-Holland, Amsterdam, 1974.
Solomon Feferman. Systems of predicative analysis II: Representation of ordinals. Journal of
Symbolic Logic, 33:193–220, 1968.
Kentaro Fujimoto. Notes on some second order systems of inductive deﬁnitions and Π1
1–
comprehensions and relevant subsystems of set theory. Annals of Pure and Applied Logic,
166:409–463, 2014.
Gerhard Gentzen. Die Widerspruchsfreiheit der reinen Zahlentheorie. Mathematische Annalen,
112:493–565, 1936.
Gerhard Gentzen. Beweisbarkeit und Unbeweisbarkeit von Anfangsfällen der transﬁniten
Induktion in der reinen Zahlentheorie. Mathematische Annalen, 119:140–161, 1943.
Kurt Gödel. Eine Interpretation des intuitionistischen Aussagenkalküls. Ergebnisse eines
Mathematischen Kolloquiums, 4:39–40, 1931.

320
|
W. Pohlers
Leon Henkin. A generalization of the notion of ω-consistency. Journal of Symbolic Logic, 19:
183–196, 1954.
David Hilbert. Neubegründung der Mathematik. Abhandlungen aus dem Math. Seminar d.
Hamb. Univ., I:157–122, 1922.
David Hilbert. Die Grundlagen der Mathematik. Vortrag gehalten auf Einladung des Mathema-
tischen Seminars im Juli 1927 in Hamburg. Hamburger Mathematische Einzelschriften, 5.
Heft:1–21, 1928.
David Hilbert. Die Grundlegung der elementaren Zahlenlehre. Mathematische Annalen, 104:
485–494, 1931.
David Hilbert, editor. Gesammelte Abhandlungen, volume III. Springer, Berlin, 1935.
Gerhard Jäger. Theories for Admissible Sets. A Unifying Approach to Proof Theory. Number 2 in
Studies in Proof Theory, Lecture Notes. Bibliopolis, 1986.
Gerhard Jäger. Metapredicative and explicit mahlo: a proof-theoretic perspective. In Rene Cori,
Alexander Razborov, Stevo Todorcevic, and Carol Wood, editors, Logic Colloquium ’00,
volume 19 of Lecture Notes in Logic, pages 272–293, Wellesley, MA, 2005. AK Peters.
Gerhard Jäger and Wolfram Pohlers. Eine beweistheoretische Untersuchung von (∆1
2-CA) + (BI)
und verwandter Systeme. Bayerische Akademie der Wissenschaften, Sitzungsberichte
1982, pages 1–28, 1983.
S. Orey. On ω-consistency and related properties. Journal of Symbolic Logic, 21:246–252,
1956.
Wolfram Pohlers. Proof-theoretical analysis of IDν by the method of local predicativity. In Wil-
fried Buchholz, Solomon Feferman, Wolfram Pohlers, and Wilfried Sieg, editors, Iterated
Inductive Deﬁnitions and Subsystems of Analysis: Recent Proof-Theoretical Studies, num-
ber 897 in Lecture Notes in Mathematics, pages 261–357. Springer, Heidelberg/New York,
1981.
Wolfram Pohlers. Subsystems of set theory and second order number theory. In Samuel R.
Buss, editor, Handbook of Proof Theory, Studies in Logic and the Foundations of Mathe-
matics, pages 209–335. North-Holland, 1998.
Wolfram Pohlers. Proof Theory. The ﬁrst step into impredicativity. Universitext. Springer,
Berlin/Heidelberg/New York, 2009.
Wolfram Pohlers. Semi-formal calculi and their applications. In Reinhard Kahle and Michael
Rathjen, editors, Gentzen’s Centenary: The quest for consistency, pages 195–232.
Springer, 2015.
Wolfram Pohlers. Iterated inductive deﬁnitions revisited. submitted, page 28, 201xa.
Wolfram Pohlers. Stability. A proof theoretic study. In preparation, 201xb.
Wolfram Pohlers and Jan Carl Stegert. Provably recursive functions of reflections. In Ulrich
Berger, Hannes Diener, Peter Schuster, and Seisberger Monika, editors, Logic, Construc-
tion, Computation, volume 3 of Ontos Mathematical Logic, pages 381–474. Ontos, Frank-
furt, Paris, Lancaster, New Brunswick, 2012.
Michael Rathjen. Ordinal notations based on a weakly Mahlo cardinal. Archive for Mathemati-
cal Logic, 29:249–263, 1990.
Michael Rathjen. Eine Ordinalzahlanalyse der Π3-Reflexion. Habilitationsschrift, Westfälische
Wilhelms-Universität, Münster, 1992.
Michael Rathjen. An ordinal analysis of stability. Archive for Mathematical Logic, 48/2:1–62,
2005a.
Michael Rathjen. An ordinal analysis of parameter free Π1
2-comprehension. Archive for Mathe-
matical Logic, 48/3:263–362, 2005b.

Hilbert’s Programme and Ordinal Analysis
|
321
Helmut Schwichtenberg and Stanley Wainer. Proofs and Computations. Perspectives in Logic.
Cambridge University Press, Cambridge, UK, 2012.
Jan-Carl Stegert. Ordinal proof theory of Kripke–Platek set theory augmented by strong reflec-
tion principles. PhD thesis, Westfälische Wilhelms-Universität, Münster, 2011.


Jan von Plato
Aristotle’s Deductive Logic:
a Proof-Theoretical Study
Abstract: Aristotle’s deductive logic, as presented in his book Prior Analytics, is a
system of rules of proof. The structure of derivations by these rules is analyzed.
It is shown that derivations can be so transformed that steps of indirect proof are
applied at most once as a last rule, the only way in which Aristotle used indirect
proof.
Keywords: Aristotle’s logic, Syllogism, Tree derivation
Mathematics Subject Classiﬁcation 2010: 01A20, 03-03, 03F07
Introduction
Aristotle’s system of deductive logic, also known as the “theory of syllogisms,”
has been interpreted in various ways in the long time since it was conceived. The
situation is not diﬀerent from the reading of other chapters of the formal sciences
of antiquity, such as Euclid’s geometry and works of Archimedes. With the advent
of predicate logic, it became common to read the Aristotelian forms of proposi-
tions, such as Every A is B, as ∀x(A(x) ⊃B(x)). Here we have a universal quan-
tiﬁcation over some domain, and the predicates A and B, and the sentence is For
every x, A(x) implies B(x). Aristotelian inferences, such as the conclusion of Every
A is C from the premisses Every A is B and Every B is C, were similarly interpreted
in predicate logic. Some, [Lukasiewicz, 1957] in the ﬁrst place, even claimed that
Aristotle intended his logic in the sense given to it by predicate logic, but failed to
make explicit the underlying logical principles.
In the early 1970’s, John Corcoran and Timothy Smileytookdecisively distance
from the predicate-logical interpretation, and read the Prior Analytics for what it
is: There are certain basic forms of propositions, analyzed in the Aristotelian way
into a subject, a copula, and a predicate. Thus, in Every A is B, A is the subject,
Every ...is ... the copula, and B the predicate. Both authors concentrated on the
smallest system of rules that suﬃces for Aristotelian syllogistic derivations. It has
two one-premiss rules, two two-premiss rules, and a schematic rule of indirect
proof.
Jan von Plato: Department of Philosophy, University of Helsinki, Finland
e-mail: jan.vonplato@helsinki.ﬁ

324
|
J. von Plato
Aristotle’s proofs, i.e., deductions within his system, are given as texts, one
sentence following another. They are thus linearly arranged, as a logician would
say today, instead of having, say, tree form. Even so, they are at ground formal in
nature.
An impressive feature of the Aristotelian proof texts is the following: When-
ever a rule of inference is applied, the premisses of the rule appear in the text
right before the rule, and in a standard order that conforms to the pattern of the
rule. Such an arrangement is otherwise found in the axiomatic systems of logic
of Frege and Bernays and Hilbert. In a derivation with modus ponens as the only
rule, when the rule is applied repeatedly, not both premisses of the rule can be
instances of the logical axioms. In a linear arrangement of formulas, a number or
other marker is given to each formula in a derivation so that its use as a premiss
in a rule lower down in the derivation can be indicated. Aristotle simply repeats a
premiss earlier assumed or derived and adds words such as “But it was assumed
that ...,” to have an exact formal match of premisses and conclusion in each rule
instance. This “rule of repetition,” as it is called in [Corcoran, 1974], is nothing
but part of the inductive deﬁnition of a formal derivation: Whenever there is a
derivation of some formula P and a rule instance in which that same P acts as a
premiss, the rule can be applied to yield a derivation of its conclusion. More gen-
erally, if there is a derivation of P and another derivation in which P appears as
an assumption, it should be possible to compose the two derivations into one that
derives the conclusion of the second derivation from the assumptions of the ﬁrst
and second derivation together, P excluded.
Aristotle uses a symbolic notation only for subjects and predicates and na-
tural language for the rest, but the times are long past when in logical research
it was thought that an exclusive use of symbols instead of words is the hallmark
of formality. All steps of inference, what the premisses are and what the conclu-
sion, are clearly indicated in Aristotle’s texts; nothing is left to guesswork in this
respect.
[Corcoran, 1974], and later [Smith, 1989] following the former found that Aris-
totle’s main interest with his system of deductive logic was to study its general
properties, not to use it for the actual construction of derivations. Thus, in their
view, Aristotle gave his system of deductive logic as an example of the organi-
zation of such systems in general, and not as a closed system of logic to which
nothing need be added.
A serious limitation of Aristotle’s formal analyses of the proofs should be
noted: With a few exceptions, the derivations Aristotle considers contain just one
syllogistic rule. What are called conversions are not considered proper deductive
steps. We shall go through those places in which Aristotle refers to the combina-
tion of several syllogistic rules. The overall conclusion seems to be that he did not

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
325
succeed, or even try, to extend the meticulous analysis of one-syllogism deriva-
tions into the general case.
Both of the last-mentioned authors continued to present Aristotle’s formal
proofs as linear derivations. We shall give them as derivation trees, which gives
a much improved control over their structure. In this representation, all assump-
tions are topformulas in derivations, and it will be easy to show, for example, that
derivations that contain indirect steps of proof can be so transformed that there
is at most one such step as a last rule. The result conforms to Aristotle’s practice
of always using indirect proof in that way.
Most of the Prior Analytics is devoted to syllogisms in which the premisses
and conclusion are modal formulas. We shall not consider such modal syllogisms
here.
This article is in three parts. Section 1 goes through the ﬁrst chapters of the
Prior Analytics from the point of view of proof systems. Section 2 gives a proof-
theoretical analysis of Aristotle’s system of deductive logic. This part can be read
independently, when the notation from table 2 is gathered, as well as the rule of
indirect proof of table 3, the two ﬁrst rules of table 5, and the two rules of table 8.
Section 3 discusses the issue of Aristotle’s “underlying logic.”
1 Justiﬁcation of the rules of Aristotle’s deductive
logic
1.1 The forms of propositions
There are ﬁve forms of propositions in the logic of the Prior Analytics:
1. The Aristotelian forms of propositions
Universal aﬃrmative:
Every A is B
Universal negative:
No A is B
Particular aﬃrmative:
Some A is B
Particular negative:
Some A is not-B
Indeﬁnite:
A is B
The last one is not usually present in the rules of inference, even though it can so
be (cf. 26a28).
Subjects and predicates together are terms. The indeﬁnite form A is B has var-
ious other readings: Subject A has the predicate B, predicate B belongs to subject

326
|
J. von Plato
A, B belongs to A, etc. The last one is preferred by Aristotle, and he writes the other
forms similarly:
B belongs to every A, B belongs to no A, B belongs to some A, B does not belong to some A.
Here the copula is written as one connected expression between the predicate and
the subject, which underlines the formal character of the sentence construction.
Another useful way of expressing the Aristotelian propositions is:
Every A is B, No A is B, Some A is B, Not every A is B.
Now the indeﬁnite form A is B is a constant part of the propositions and the vary-
ing quantiﬁer structure is singled out. It is seen clearly that the ﬁrst and last are
opposites, and that the second and third are likewise opposites.
The main principle in the formation of propositions is that subjects and predi-
cates are treated symmetrically: Whenever Every A is B is a proposition, also Every
B is A is one, and similarly for the universal negative and the particular forms. A
formal structure is imposed that is not a natural feature of natural language, as
in Some man is wise, the converse of which, Some wise is man, would not be a
natural expression, but would have to be paraphrased, as in Some wise being is a
man.
The symmetry of the subject and predicate in a proposition can break down
with indeﬁnite propositions. As Aristotle says, individuals cannot be predicated of
other things, but instead other things are predicated of them (43a40). An example
such as Socrates is wise conﬁrms this: It does not convert, because there is no
sense in this context in Wise is Socrates, or, The predicate Socrates belongs to the
subject wise.
1.2 Semantical explanation of assertions
Logical rules seem to act on propositions, but the impression is wrong. When the
notion of a logical derivation is deﬁned, it is stipulated how a derivation can be-
gin. In axiomatic systems, it can begin with instances of axioms. These are logical
truths, not plain propositions. Similarly, in proof systems that have just rules and
no axioms, as in Aristotle, derivations begin with assumptions. These are propo-
sitions assumed to hold, not plain propositions.
By the above, the conclusion of a logical rule is then either a logical truth, as
in axiomatic systems of logic, or a claim that holds if the assumptions hold, as in
systems that have just rules. For the latter, we can equally call the assumptions
and conclusions from them assertions, a notion that is more general than truth

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
327
because assertions can be hypothetical, but truth in axiomatic systems of logic is
categorical.
We shall use the following notation for the propositions of Aristotle’s logic:
2. Notation for the Aristotelian propositions
Π+(A, B)
for
Every A is B
Π−(A, B)
for
No A is B
Σ+(A, B)
for
Some A is B
Σ−(A, B)
for
Some A is not-B
In Aristotle’s times, there were no lower-case letters in Greek. Today it is custom-
ary in logic to denote individuals by lower case and predicates by upper case let-
ters. We shall write (c : A)B(c) for some A, say c, is B, a construction Aristotle uses
at places (e.g., 25a16). It is not used below, except for the semantical explanations
of the four forms of expression of tables 1 and 2. From today’s point of view, such
an arbitrary instance of an existential assertion is an eigenvariable used to elim-
inate the existential quantiﬁer. The reading of (c : A)B(c) is c in A such that B(c).
In Aristotle’s terminology, the terms in the ﬁrst four forms of propositions are
universal and particular, respectively, and those in the ﬁfth indeﬁnite. The four
kinds of propositions contain terms that designate, in the subject position, types
of objects, whereas the ﬁfth form can have in subject position instances. This fea-
ture is captured by the lower case letters in our notation for the indeﬁnite form of
proposition.
The universal quantiﬁer of the Aristotelian form Π+(A, B) is explained as fol-
lows in the Prior Analytics (24b28):
A thing is predicated of all of another when there is nothing to be taken of which the other could
not be said.
This passage has been translated in various ways, even as ...whenever no instance
of the subject can be found of which the other term cannot be asserted (in the Oxford
edition of Aristotle’s works, 1928).
Aristotle’s explanation of the universal quantiﬁer is not unlike some later ex-
planations found in logic that, together with the one of Aristotle, can be termed
no-counterexample interpretations: The formula ∀xB(x) is true in a given dis-
course (i.e., in a given domain A and interpretation of B) if there is no object c in
A such that B(c) fails. Put the type A in place of A and you have the Aristotelian
formulation (24b29–30): There is nothing to be taken [no c : A] of which the other
[B(c)] could not be said. In correspondence with the explanation, the syntactic

328
|
J. von Plato
form of the universal quantiﬁer makes it bounded to a domain of quantiﬁcation
that varies from one quantiﬁer occurrence to another.
Instances of types of objects are used sometimes, as when Aristotle shows un-
provabilities through counterexamples in chapter 4. The notation is just a juxtapo-
sition of two terms, as in B Γ, B belongs to some Γ (cf. 26b29). Say, if the premisses
are Σ−(B, A) and Π+(C, B), then Σ−(A, C) does not necessarily follow.
–
The universal negative quantiﬁer. There is nothing in A of which B could be
said.
With the above notation, we have: There is no c of type A such that B(c).
Next, the explanation of Σ+(A, B) builds on that of Π−(A, B) (25a21–23):
–
The existential quantiﬁer. It is impossible that no A is B.
The explanation is quite natural, on the face of Aristotle’s treatment of
Π−(A, B) and Σ+(A, B) as a contradictory pair. Similarly with Σ−(A, B); Its
contradictory is Π+(A, B) and the explanation becomes:
–
The existential negative quantiﬁer. It is impossible that an A could not be
taken such that not-B could not be said.
By Aristotle’s principle of indirect proof, direct and indirect existence
claims are equated, as we shall point out in detail later, so that Σ+(A, B) be-
comes explained as A c of type A can be taken such that B(c), and Σ−(A, B) as
A c of type A can be taken such that not-B(c).
1.3 Indirect proof
The pairs Σ+(A, B), Π−(A, B) and Π+(A, B), Σ−(A, B) are contradictory opposites.
Furthermore, because from Π−(A, B) the weaker Σ−(A, B) follows, also Π+(A, B)
and Π−(A, B) together lead to a contradictory pair. We shall indicate the contra-
dictory opposite of a formula P by the orthogonality symbol, P⊥. In general, if an
assumption P has led to contradictory consequences Q and Q⊥, P⊥can be con-
cluded and the assumption P closed. The rule of indirect proof thus takes on the
following schematic form:
3. The scheme of indirect proof
1
Pm....
Q
1
Pn....
Q⊥
P⊥
Raa,1

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
329
This schematic proof ﬁgure is to be understood as follows: The assumption may
appear among those that were used in the derivations of Q and Q⊥, respectively.
Any numbers m, n ⩾0 of occurrences of P in the two subderivations can be
closed at the inference. The closed ones are indicated by a suitable label, such
as a number, so that each instance of rule Raa (for reductio ad absurdum) clearly
shows which occurrences of P are closed at the inference. It is typical of Aristo-
tle’s proofs that an assumption closed in indirect proof occurs just once, i.e., either
m = 1, n = 0 or m = 0, n = 1. We then have one of
4. Aristotelian special cases of indirect proof
1
P....
Q
Q⊥
P⊥
Raa,1
Q
1
P....
Q⊥
P⊥
Raa,1
As mentioned, Aristotle’s derivations have at most one instance of indirect proof,
as a last rule. A rule of indirect proof in which the premisses of Raa are Π+(A, B)
and its contrary Π−(A, B) can be derived from the rest of the rules.
1.4 The rules of conversion
Aristotle’s system of deductive logic begins properly with his rules of conversion:
5. The rules of conversion
Π−(A, B)
Π−(B, A) Π−C
Π+(A, B)
Σ+(B, A) Π+C
Σ+(A, B)
Σ+(B, A) Σ+C
As noted by [Smiley, 1973, p. 142], the third rule of conversion is a derivable rule:
Its conclusion is derivable from its premiss by the ﬁrst conversion rule and the
rule of indirect proof. Aristotle, in fact, notes the same (24a22) as we shall see in
a while.
The semantical justiﬁcation of the rules of conversion in Aristotle is as fol-
lows. For rule Π−C assume Π−(B, A). To justify the conclusion Π−(A, B), assume
the contradictory Σ+(A, B). Aristotle’s argument is (25a15):
If B did not belong to some A, say C, it would not be true that A belongs to no B, for C is a B.

330
|
J. von Plato
By the semantical explanation, we can conclude from Σ+(A, B) to some instance
(c : A)B(c) in the notation of Section 2. The crucial point of Aristotle’s conversion
argument is that if (c : A)B(c), then (c : B)A(c). Let us call this principle instance
conversion. In this light, the semantical argument for rule Π−C can be given as an
indirect one: If Π−(A, B), then, by the semantical explanation, there is no instance
c : A such that B(c), i.e., (c : A)B(c) is impossible. On the other hand, assuming
Σ+(B, A), we have c : B such that A(c), or (c : B)A(c), because this is the same
as the semantical explanation no A is B is impossible. By instance conversion of
(c : B)A(c), we have (c : A)B(c), a contradiction. Therefore the contradictory
Π−(B, A) of the assumption Σ+(B, A) follows.
The distinction into terms as types and singular terms is central in the above
reading of Aristotle: The ground for the semantical explanation of the four Aris-
totelian quantiﬁers lies in what we called instance conversion. It, together with
the principle of indirect proof, led to the justiﬁcation of the rule of Π−-conversion
that in turn leads to the justiﬁcation of the other two convertibilities, and to the
rest of the rules of deduction. The same division into, let’s say, generic and sin-
gular terms, is discussed at length by Aristotle. We saw above an example of the
failure of convertibility when a singular term occurred in an indeﬁnite proposition
(Socrates is wise.) Similarly, singular terms cannot appear as subjects in proposi-
tions that are not indeﬁnite: An example such as Some Socrates is wise is suﬃcient
to bring home this point.
Behind the principle of instance conversion we ﬁnd the following: A generic
term can be treated both as a type and a property. In c : A such that B(c), we can
turn the predicate B into a subject, the type of all objects that have the property.
Likewise, we can turn the type A into a property A. At this point it is clear that
singular terms, even though they appear in notation (upper case letters) to be like
any terms, do not have the type-property correspondence.
Next we have the second of the conversion rules, from Π+(B, A) to conclude
Σ+(A, B). Aristotle’s semantical justiﬁcation is as follows (25a18):
If A belongs to every B, then B will belong to some A. For if it belongs to none, neither will
A belong to any B. But it was assumed to belong to everyone.
These words correspond exactly to the following formal derivation:
Π+(B, A)
1
Π−(A, B)
Π−(B, A) Π−C
Σ+(A, B)
Raa,1

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
331
Aristotle uses indirect proof with a formula and its contrary, instead of contradic-
tory. From the point of view of a system of proof, either that has to be done, or the
conversion of Π+(B, A) into Σ+(A, B) taken as a primitive rule.
The second conversion rule has been criticized because its premiss does not
presuppose the existence of any A, whereas the conclusion does. The predicate-
logical interpretation shows this: The premiss would be ∀x(A(x) ⊃B(x)), the con-
clusion ∃x(A(x)&B(x)), and the former holds but the latter fails if A is always false.
It is seen from Aristotle’s arguments that he assumed every subject to be inhab-
ited, which resolves the conﬂict.
The third conversion rule is, from Σ+(B, A) to conclude Σ+(A, B). Aristotle’s
justiﬁcation is again in terms of rule Π−C: Assume the contradictory of Σ+(A, B).
Then (25a22): If B belongs to no A, then neither A to no B. In our notation, the
justiﬁcation is the derivation
Σ+(B, A)
1
Π−(A, B)
Π−(B, A) Π−C
Σ+(A, B)
Raa,1
Only one of the conversion rules is needed and the rest are derivable if indirect
proof is used in Aristotle’s way. If, instead, the second conversion rule is taken,
the contrary premisses Π+(A, B) and Π−(A, B) lead to a contradiction. The con-
tradictory of the latter is Σ+(A, B). It is derived by
Π+(A, B)
Σ+(B, A) Π+C
Σ+(A, B) Σ+C
Thus, we have as a derived indirect rule the following.
6. The scheme of indirect proof
1
Pm....
Π+(A, B)
1
Pn....
Π−(A, B)
P⊥
Raa,1
We sum up the above results as follows:
Proposition 1. The system with the conversion rules Π−C and Π+C and rule Raa is
equivalent to the system with rule Π−C, Raa, and indirect proof with contrary pre-
misses.

332
|
J. von Plato
Having proved that two of the conversion rules follow from that for the quanti-
ﬁer Π−and indirect proof, Aristotle shows that the existential negative quantiﬁer
expression does not convert. The example is (25a25): Man does not belong to all
living creatures, but living creature belongs to all men. It should be noted that two
readings are given (in 25a15–18) to what we wrote as Σ−(A, B): B does not belong
to some A and B does not belong to all A, i.e., some A is not-B and not all A are B.
Aristotle’s counterexample uses the latter wording.
1.5 The syllogistic rules
So far we have one primitive rule of conversion and two schemes of indirect proof,
or the other way around. Two more rules enter into Aristotle’s deductive logic, the
proper syllogisms as this word has been understood for a long time. Its meaning
in Aristotle vacillates between a single syllogism and what today is called a de-
duction. The major part of the Prior Analytics deals with derivations that consist
of a single syllogism, conversions, and a single step of indirect inference. The two
syllogistic rules are (25b38-26a2):
7. Aristotle’s formulation of the syllogistic rules
When A of every B and B of every C, it is necessary that A is said of every C. For we have
explained above what we mean by every.
Correspondingly also when A of no B, B instead of every C, then A will not belong to any C.
Aristotle does not elaborate on the justiﬁcation of the ﬁrst rule through the expla-
nation of the universal quantiﬁer, but it is straightforward. With our notation, we
have the premisses and their semantical explanations:
1.
Π+(B, A), no d : B can be taken such that A(d) could not be asserted,
2.
Π+(C, B), no e : C can be taken such that B(e) could not be asserted.
Assume the contradictory of the conclusion Π+(C, A):
3.
Σ−(C, A), an f : C can be taken such that not-A(f).
By f : C from 3. and by 2., we have B(f). By the correspondence between types and
properties, f : B, so that by 1., A(f), a contradiction with 3.
The second syllogistic rule is justiﬁed similarly:
1.
Π−(B, A), no d : B can be taken such that A(d) could be asserted,
2.
Π+(C, B), no e : C can be taken such that B(e) could not be asserted.

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
333
Assume the contradictory of the conclusion Π−(C, A):
3.
Σ+(C, A), an f : C can be taken such that A(f).
By f : C and 2., we have B(f). By the correspondence between types and properties,
f : B, so by 1., A(f) cannot be asserted, a contradiction with A(f) from 3.
We write the above two rules as:
8. The syllogistic rules
Π+(A, B)
Π+(B, C)
Π+(A, C)
Π+S
Π+(A, B)
Π−(B, C)
Π−(A, C)
Π−S
The order of the premisses, from left to right, is the reverse of Aristotle’s proof
texts. At some stage, it became customary to read the propositions with the sub-
ject ﬁrst, so, to have the middle term in the middle, the order of premisses was
changed.
1.6 Two example proofs
Some examples will show the advantage of a proof tree form instead of a linear
one. The following proof text is from (27a10):
9. An Aristotelian proof text
If M belongs to every N but to no X, then neither will N belong to any X. For if M belongs to no
X, then neither does X belong to any M; but M belonged to every N; therefore, X will belong to
no N (for the ﬁrst ﬁgure has come about). And since the privative converts, neither will N belong
to any X.
[Corcoran, 1974] writes this as a linear succession of formulas, each line numbered
and justiﬁed. In our notation, the linear derivation is:

334
|
J. von Plato
10. A linear derivation
1. Π+(S, R)
assumption.
2. Σ−(S, P)
assumption.
3. Π+(R, P)
assumption contradictory to Σ−(R, P).
4. Π+(S, R)
1.
5. Π+(S, P)
3,4.
6. Σ−(S, P)
2.
7.
Σ−(R, P)
5,6.
The premisses of each rule instance are written right above the instance, in the
proper order. To achieve this, line 1 has to be repeated on line 4. The same is seen
in Aristotle’s proof text.
The next example gives an indirect proof (28b17):
11. An Aristotelian proof text
If R belongs to every S but P does not belong to some, then it is necessary for P not to belong to
some R. For if P belongs to every R and R to every S, then P will also belong to every S; But it
did not belong.
The linear indirect derivation of Σ−(R, P) is, as adapted from [Corcoran, 1974, p.
111]:
12. An indirect linear derivation
1. Π+(S, R)
assumption.
2.
Σ−(S, P)
assumption.
3.
Π+(R, P)
assumption contradictory to Σ−(R, P).
4.
Π+(S, R)
1.
5.
Π+(S, P)
3,4.
6.
Σ−(S, P)
2.
7.
Σ−(R, P)
5,6.
The temporary assumption from line 3 has led to the contradictory conclusions 5
and 6. Therefore Σ−(R, P) follows. It has been added as a seventh line. The tempo-
rary assumption on line 3 is closed at this step. Note the two repetitions, on lines
4 and 6.
We shall translate linear derivations into a tree form:

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
335
13. Translation algorithm from linear to tree form
1.
Take the last formula, draw an inference line above it, with the name of the rule that
concluded it next to the line. Write the formulas that correspond to the lines of the
premisses of the last rule, as indicated by the numbers, in the given order above the
inference line.
2.
Repeat the procedure until assumptions are arrived at. If an assumption closed by Raa is
reached, write the number of its line above it.
The translation produces derivations in which all assumptions are topformulas
that begin derivation branches.
The result of the application of this translation algorithm to example deriva-
tions 10 and 12 is:
14. The example derivations translated into tree form
Π−(X, M)
Π−(M, X) Π−C
Π+(N, M)
Π−(N, X)
Π−S
Π−(X, N) Π−C
3
Π+(R, P)
Π+(S, R)
Π+(S, P)
Π+S
Σ−(S, P)
Σ−(R, P)
Raa,3
The order of the premisses in the two-premiss rules is the reverse of our rule, but
this is just a notational convention. As can be seen, the tree form does not mix as-
sumptions and conclusions of rules, but the former are always topformulas and it
is seen at once what depends on what. The purely formal character of the trans-
lation algorithm is shown by the label 3 produced for the assumption closed in
indirect proof. Otherwise, constructing tree derivations directly, one would start
numbering labels from 1. No repetitions appear. Had an assumption been used
more than once, that would also be seen. Most remarkably, it becomes possible to
compose two derivations, and to permute the order of application of the rules.
In the earlier parts of the Prior Analytics, deductions are identiﬁed with sin-
gle instances of syllogistic rules, modulo conversions, possibly ﬁnished with an
indirect proof. We say modulo conversions, because Aristotle doesn’t seem to take
them as steps of deduction proper (cf. 40b36 where he writes that nothing results
from a single premiss). In the latter parts of the book, Aristotle considers situa-
tions with more than one syllogistic rule. The places are chapter 25 of book A, and
chapters 5, 18, and 19 of book B. Aristotle expresses himself in diﬀerent ways. One
is to say that there are several conclusions (42a5) or syllogisms 42a18), or that they

336
|
J. von Plato
are multiple (42a21).¹ He has some diﬃculty in taking such several syllogisms as
one united deductive argument. They can be either related or unrelated to each
other (as in 42a21, where multiple syllogistic conclusions do not touch each other).
Another expression is that several syllogisms can lie together composed (68a11).
He also writes at one place (42b6) that the conclusion is reached by means of prior
syllogisms.
If we think of the Aristotelian proof texts, combination of syllogisms would
not pose a problem. In the application of a syllogistic or other rule, one would
just repeat a premiss that has been deduced earlier by another syllogism. One
such case is in (42a1): There are the premisses D and E that give a conclusion A,
next the premisses F and G that give a conclusion B. The conclusions A and B can
in turn lead to a conclusion C. Aristotle writes that there are several syllogisms, for
the conclusions are many (42a5).² Thus, a whole chain of syllogistic inferences is
possible in Aristotle. The structure of these derivations is clear if they are given in
tree form, as for the above example:
D
E
A
F
G
B
C
Aristotle does not really come into grips with the composition of several single
syllogisms into a deduction. At one place (42a36) he uses the expression deduc-
tive argument.³ His analysis of one-syllogism deductions is complete, but he has
no general results about deductive arguments with several syllogisms, except for
one: Namely, at (42b12–13), he proves that when the premisses are even, the terms
will be odd, and when the terms are even, the premisses will be odd. The proof is a
clear structural induction on the number of steps in a combined deduction.⁴
In general, given a derivation of P from the assumptions A1, . . . , Am and an-
other derivation of Q from the assumptions P, B1, . . . , Bn, these two derivations
can be composed into a derivation of Q from the assumptions A1, . . . , Am and
B1, . . . , Bn. Composition can be represented schematically as
1 Smith translates several deductions when several syllogisms would be clearer. Similarly, at
(50a5) Aristotle talks about conclusions from a single ﬁgure, and these are not just any deduc-
tions, but single instances of a syllogistic rule.
2 Again, Smith has several deductions.
3 In Smith’s translation, from logos sullogistikos.
4 A related proof by induction in antiquity has been observed by [Acerbi, 2000].

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
337
15. The scheme of composition of derivations
A1, . . . , Am
....
P
and
P, B1, . . . , Bn
....
Q
compose into
A1, . . . , Am
....
P , B1, . . . , Bn
....
Q
2 Proof-theoretical analysis of Aristotle’s
deductive logic
2.1 Properties of tree derivations
We shall write in general P, Q, . . . , R ⊢S to indicate that there is a derivation of S
from the assumptions P, Q, . . . , R. We also count the multiplicity of occurrences
of assumption formulas, and gather them into multisets, denoted Γ, ∆, . . . . In par-
ticular, the assumption P is at the same time a degenerate derivation of P from P.
In terms of the derivability relation, we have thus P ⊢P. The derivability relation
also allows us to write the composition of two derivations as a rule:
Γ ⊢P
P, ∆⊢Q
Γ, ∆⊢Q
Comp
This is an admissible rule in Aristotle’s system of logic: Whenever its premisses
are derivable by the rules of the system, also the conclusion is derivable. Admis-
sibility is a weaker notion than the derivability of a rule. The latter requires that
the conclusion be derivable from the premisses.
Proposition 2 (Composition of derivations). Given two derivations Γ
⊢
P and
P, ∆⊢Q, if all labels in instances of Raa in the two derivations are distinct, they can
be composed into a derivation Γ, ∆⊢Q.
Proof: The proof is by induction on the greatest number of successive steps of
inference in the derivation P, ∆⊢Q. If it is an assumption, we have
Γ....
P
and
P
Composition with the degenerate derivation P just gives the original derivation.
Assume next that Q has been derived by a proper rule, say a one-premiss rule. We

338
|
J. von Plato
then have the derivations
Γ....
P
and
P, ∆
....
R
Q
Rule
The derivation of R from P, ∆is one step shorter, so we can make by the inductive
hypothesis the composition
Γ....
P, ∆
....
R
Now Rule is applied to conclude Q. If Rule is Raa, the assumption closed at the
original inference is kept open, the composition with a shorter derivation done,
and then Raa applied and the assumption closed.
QED.
Whenever there is a clash of the numerical labels in Raa, these can be renamed.
In general, whenever a formula P appears twice in a derivation branch, the
part between the two occurrences can be cut out, to eliminate the loop. It can
happen that assumptions are used in the part eliminated, so that such assump-
tions get removed from the list of open assumptions of the overall derivation. If
this happens, it just improves the overall result, because the endformula of the
derivation then follows from fewer assumptions.
The tree form makes it possible to permute the order of application of two
rules. Say, we have
Π+(A, B)
Π+(B, C)
Π+(A, C)
Π+S
Π+(C, D)
Π+(A, D)
Π+S
The middle term B is removed ﬁrst, then the middle term C. The order of removal
can be changed, as in
Π+(A, B)
Π+(B, C)
Π+(C, D)
Π+(B, D)
Π+S
Π+(A, D)
Π+S
Any number of successive instances of rule Π+ can be so transformed that, say,
the left premisses are assumptions.
Finally, we note a remarkable property of the rules of Aristotle’s deductive
logic:

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
339
Each term in a conclusion of a rule other than indirect proof is a term in some premiss.
By this property, any term in a derivation without indirect proof can be traced up
to at least one topformula, i.e., an assumption.
2.2 Reflexivity
Aristotle forbids the “self-predication” of a subject, such as in the reflexive in-
stance Π+(A, A). This ban on reﬂexivity is not categorical, though, for in (68a19),
self-predication is applied.
We shall show that reﬂexive instances of the four kinds of Aristotelian quan-
tiﬁed formulas produce no harm in derivations. In most cases, they just produce
what Aristotle forbids in his deﬁnition of a deduction (24b19), namely a conclu-
sion that is identical to a premiss. In other cases, they produce an impossibility.
We notice that the ﬁrst syllogistic rule produces a loop whenever one premiss
is reﬂexive, as in
Π+(A, A)
Π+(A, B)
Π+(A, B)
Π+S
For the second syllogistic rule, there is a loop if the universal positive premiss is a
reﬂexivity:
Π+(A, A)
Π−(A, B)
Π−(A, B)
Π−S
Universal negative conversion produces likewise a loop if its premiss is the nega-
tive reﬂexivity Π−(A, A).
If we grant the positive reﬂexivity Π+(A, A), then the positive reﬂexivity
Σ+(A, A) follows by conversion. The contradictories of these two, the negative
reﬂexivities Σ−(A, A) and Π−(A, A), respectively, are then impossible.
If the second premiss in rule Π−S is a reﬂexivity, we have
Π+(A, B)
Π−(B, B)
Π−(A, B)
Π−S
The conclusion is the contrary of the ﬁrst premiss.
Thus, the admission of reﬂexivities in the Aristotelian forms of propositions
causes no essential change in derivability: Their only use is in the conclusion of
Σ+(A, A) from Π+(A, A).

340
|
J. von Plato
2.3 A normal form for tree derivations
The deductions found in the Prior Analytics are such that the rule of indirect proof
is applied at most once, and always as a last rule. The reason is that Aristotle does
not even begin the analysis of combined derivations. We shall show that all deriva-
tions by the rules of Aristotle’s deductive logic can be brought to a normal form
such that the stated property for indirect proof holds. We show in particular that
two consecutive instances of rule Raa contract into one, and that any other in-
stance of Raa than one as a last rule can be removed.
Theorem 3 (Normal form for derivations). All derivations in Aristotle’s deductive
logic can be so transformed that the rule of indirect proof is applied at most once as
a last rule.
Proof: Consider an uppermost instance of Raa in a derivation. If it is followed by
another instance of Raa, we have a part of derivation such as
1
P....
Q
....
Q⊥
P⊥
Raa,1
2
R....
P
R⊥
Raa,2
This derivation is transformed into
1
R....
P....
Q
....
Q⊥
R⊥
Raa,1
Admissibility of composition guarantees that the derivation of P from R can be
continued by the derivation of Q from P.
The above transformation is repeated until there is just one instance of Raa.
If the conclusion R⊥is existential, it cannot be a premiss in any rule and the claim
of the theorem follows. If the conclusion is universal, we have one of
1
Σ−(A, B)
....
Q
....
Q⊥
Π+(A, B) Raa,1
1
Σ+(A, B)
....
Q
....
Q⊥
Π−(A, B) Raa,1

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
341
There are by assumption no instances of Raa above the ones shown. Therefore the
existential formulas that are closed cannot be premisses in any other rules than
the instances of Raa shown. Then the derivations of the left premisses of Raa are
degenerate, with Σ−(A, B) ≡Q and Σ+(A, B) ≡Q, respectively. The derivations are
therefore
1
Σ−(A, B)
....
Π+(A, B)
Π+(A, B)
Raa,1
1
Σ+(A, B)
....
Π−(A, B)
Π−(A, B)
Raa,1
A loop is produced in both, and therefore the instances of Raa can be removed.
QED.
The formulas of Aristotle’s deductive logic are atomic formulas in today’s termi-
nology, and his rules act only on such atomic formulas. The question of the deriv-
ability of an atomic formula from given atomic formulas used as assumptions is
known as the word problem. The terminology stems from algebra where the word
problem concerns the derivability of an equality from given equalities. The solu-
tion of this problem in Aristotle’s deductive logic, i.e., the decidability of derivabil-
ity by his rules, follows at once by the above results. It is suﬃcient to show that
the terms in a derivation of P from the assumptions Γ can be restricted to those
included in the assumptions and the conclusion. If the proof is direct, this is so by
the property of the rules noted at the end of Section 2.1, by which terms in formu-
las can be traced up to assumptions. Otherwise, the last step is indirect, but the
closed assumption is P⊥so that the terms in a derivation are as in the direct case.
With a bounded number of terms, there is a bounded number of distinct formulas.
The number of possible consecutive steps of inference in a loop-free derivation,
i.e., the height of a branch in a derivation tree, is bounded by the number of dis-
tinct formulas and we have:
Theorem 4 (Word problem for Aristotle’s deductive logic). The derivability of a
formula P from given formulas Γ used as assumptions is decidable.
3 The issue of Aristotle’s underlying logic
3.1 From rules to axioms
When the study of logic was revived in the mid-nineteenth century, Aristotle’s
logic was interpreted as a logic of classes. Venn diagrams showed easily what its
basic forms of inference amounted to. These diagrams can be equally well used

342
|
J. von Plato
to model monadic predicate logic, and the latter in turn gives one interpretation
of Aristotle’s logic.
We have followed Corcoran and Smiley and taken Aristotle’s logic simply as a
system of rules of inference. Such rules stand on their own feet without any under-
lying logical interpretation. On the other hand, proof systems based on rules can
be turned into systems that use axioms and maybe just one or two rules. Today’s
predicate logic was born, in the hands of Frege and Russell, as precisely such an
axiomatic system of logic. The formulation as a system of rules of proof was found
by Gentzen in the 1930s.
Frege and Russell followed a trend of the time of axiomatizing logic as a
branch of mathematics, similarly to axiomatizations of geometry and arithmetic.
Many such axiomatizations can be turned, in perfect analogy to Gentzen’s work
in pure logic, into systems of rules. In the other direction, systems of rules can be
turned into axiomatic systems. An example, close to Aristotle’s system of rules,
illustrates this correspondence: The theory of equality consists of a two-place
relation over a given domain of elements a, b, c, . . . and the following axioms:
1.
a = a (reﬂexivity),
2.
a = b ⊃b = a (symmetry),
3.
a = b&b = c ⊃a = c (transitivity).
These are “free-variable” axioms, i.e., the terms in the equations are parameters
that can be instantiated in any way.
A system of rules that corresponds to the axioms of equality is:
16. A rule system for equality
a = a Ref
a = b
b = a Sym
a = b
b = c
a = c
Tr
Derivations begin with assumptions and instances of the zero-premiss rule of re-
ﬂexivity. Consider a derivation by the rules such as
a = b
c = b
b = c Sym
a = c
Tr
c = a Sym

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
343
The equality c = a is derived by the rules from the equalities a = b and c = b used
as assumptions. The corresponding derivation that uses axioms is:
a = c ⊃c = a
a = b & b = c ⊃a = c
a = b
c = b ⊃b = c
c = b
b = c
⊃E
a = b & b = c
&I
a = c
⊃E
c = a
⊃E
The use of logic in the writing of the axioms of equality forces a use of logic in the
proof that is not quite natural. The uppermost step has as one premiss an instance
of symmetry, followed by rule ⊃E that puts to use the symmetry. Rule &I builds up
the minor premiss of another implication elimination that corresponds to the step
of transitivity. Finally, there is one more step of ⊃E that corresponds to the last rule
in the ﬁrst derivation.
Consider now the Aristotelian derivation
Π+(A, B)
Π−(C, B)
Π−(B, C) Π−C
Π−(A, C)
Π−S
Π−(C, A) Π−C
Aristotle would say: If every A is B and no C is B then no C is A. The derivation,
however, was not obtained by an application of Aristotle’s rules, but directly from
the preceding rule-based derivation for equality. The notationfor the relations was
changed suitably, and the names of the rules, but the geometry of the proof tree
that is the diﬃcult part to write out was taken directly from the equality derivation.
It is instructive to see what happens if reﬂexivity appears as a premiss. The
possibilities are
a = a Ref
a = a Sym
a = a Ref
a = c
a = c
Tr
a = b
b = b Ref
a = b
Tr
These derivations, similar to those in Section 2.2, show that the only use of rule
Ref is in the derivation of reﬂexivities, for in all other cases, a loop is produced.
We shall look at an axiomatic formulation of Aristotle’s rules. The axioms are:
17. Aristotle’s rules as axioms
Π−(A, B) ⊃Π−(B, A)
(conversion)
Π+(A, B) ⊃Σ+(B, A)
(conversion)
Π+(A, B)&Π+(B, C) ⊃Π+(A, C)
(syllogism)
Π+(A, B)&Π−(B, C) ⊃Π−(A, C)
(syllogism)

344
|
J. von Plato
We could now write, in a manner similar to the case of equality, the axiomatic
derivation that corresponds to the above derivation by rules, but it would grow
too broad to be printed comfortably.
3.2 Logic in Aristotle’s proofs
Aristotle has no explicit connectives for conjunction and implication. These logi-
cal particles appear in his proofs, however, as an underlying structure. When two
assumptions are used together, there would in logical notation appear a conjunc-
tion, as in the axiomatic equality derivation. When a rule is instantiated, there
would in logical notation appear an implication, and an implication elimination.
Similarly, when Aristotle proves a result of the form If P, then Q, he does it by as-
suming P, then deriving Q. When this has been done, he concludes that the con-
ditional has been proved, which in logical notation is implication introduction.
None of this is explicit in Aristotle.
If we state syllogisms with logical notation added, the above syllogistic
derivation by Aristotle’s rules grows into:⁵
2
Π+(A, B) & Π−(C, B)
1
Π+(A, B)
1
Π−(C, B)
Π−(B, C) ΠC
Π−(A, C)
Π
Π−(C, A) ΠC
Π−(C, A)
&E, 1
Π+(A, B) & Π−(C, B) ⊃Π−(C, A) ⊃I, 2
Now the statement of the syllogism is in a logical notation that uses one conjunc-
tion and one implication, and there are correspondingly two logical steps in the
derivation. The rest of the derivation, the one that corresponds to Aristotelian
rules of proof, is separated from the logical part as a neat subderivation of the
minor premiss of rule &E. This separation can be always upheld when the rules
of logic are formulated suitably (as explained in the preceding footnote). Were
5 The second-to-last step is a conjunction elimination of a more general form than the one stan-
dardly used. With a conjunction A&B as a major premiss, conjunction elimination would nor-
mally allow the conclusion of A and B separately. In the general rule, the conjuncts A and B
appear as temporary hypotheses that lead to some conclusion C. When the inference is drawn, C
is concluded and the temporary hypotheses A and B closed. With A in place of C (resp. B in place
of C), the standard rules follow as special cases. The rest of the connectives and quantiﬁers can
be formulated similarly [von Plato, 2001].

Aristotle’s Deductive Logic: a Proof-Theoretical Study
|
345
this not the case, the logical rules would not be conservative relative to Aristotle’s
syllogistic as formulated in theorem 4 above.
Our result is thus that the underlying logic of Aristotle’s four rules is that of na-
tural deduction for conjunction and implication, hardly a surprise, because natu-
ral deduction arose from an attempt at analyzing the logic of mathematical proofs
“as they appear in practice” [Gentzen, 1934–35, p. 176].
One ﬁnal point can be mentioned: We noticed brieﬂy that Aristotle takes
sometimes an arbitrary instance of an existential assertion. The correct way to
handle such is to introduce eigenvariables. There has been a lot of discussion as
to what the nature of proofs through instantiation (ekthesis) is. Proofs in geometry
often state things such as: Let a,b, and c be three points such that A, where A is
some property of points. This is undoubtedly an existential assumption. The the-
orem to be proved, instead, is typically universal in form: For any three points, if
A, then B. This common practice of any mathematical proof is rendered explicit by
the predicate-logical equivalence of ∀x∀y∀z(A ⊃B) and ∃x∃y∃zA ⊃B. To prove
the universal ∀x∀y∀z(A ⊃B), we can assume the existential ∃x∃y∃zA, then take
an instance with the eigenvariables a, b, and c, and prove B.
Acknowledgment: I thank Bianca Boretti and Kati Näätsaari for their help in the
reading of the crucial original passages in Aristotle, Per Martin-Löf for pointing
me to [Corcoran, 1974], and John Corcoran for making this early work of his readily
available.
Primary sources
Aristotles. Erste Analytik – Translated by Hans Zekl. Meiner, Hamburg, 1929.
Aristotle. Prior analytics. In Maria C. Pantelia, editor, Thesaurus Linguae Graecae® Digital
Library. University of California, Irvine, 2015. URL http://www.tlg.uci.edu.
S. J. Jenkinson. Aristotle: Prior Analytics – Translated by A. J. Jenkinson. Clarendon Press,
Oxford, 1928.
R. Smith. Aristotle’s Prior Analytics. Hackett, 1989.
References
F. Acerbi. Plato: Parmenides 149a7-c3. A proof by complete induction? Archive for History of
Exact Sciences, 55:57–76, 2000.
J. Corcoran. Completeness of an ancient logic. The Journal of Symbolic Logic, 37:696–702,
1972.

346
|
J. von Plato
J. Corcoran. Aristotle’s natural deduction system. In J. Corcoran, editor, Ancient Logic and Its
Modern Interpretations, pages 85–131. Reidel, 1974.
G. Gentzen. Untersuchungen über das logische Schliessen. Mathematische Zeitschrift, 39:
176–210, 1934–35.
J. Lukasiewicz. Aristotle’s Syllogistic from the Standpoint of Modern Formal Logic, 2nd ed.
Oxford, 1957.
T. Smiley. What is a syllogism? Journal of Philosophical Logic, 2:136–154, 1973.
R. Smith. Introduction to the 1989 translation of Prior Analytics. 1989.
J. von Plato. Natural deduction with general elimination rules. Archive for Mathematical Logic,
40:541–567, 2001.

Michael Rathjen
Remarks on Barr’s Theorem:
Proofs in Geometric Theories
Abstract: A theorem, usually attributed to Barr, yields that (A) geometric impli-
cations deduced in classical L∞ω logic from geometric theories also have intu-
itionistic proofs. Barr’s theorem is of a topos-theoretic nature and its proof is non-
constructive. In the literature one also ﬁnds mysterious comments about the ca-
pacity of this theorem to remove the axiom of choice from derivations. This arti-
cle investigates the proof-theoretic side of Barr’s theorem and also aims to shed
some light on the axiom of choice part. More concretely, a constructive proof of
the Hauptsatz for L∞ω is given and is put to use to arrive at a simple proof of (A)
that is formalizable in constructive set theory and Martin-Löf type theory.
Keywords: Geometric theory, Topos, Axiom of choice, Cut elimination in L∞ω
Mathematics Subject Classiﬁcation 2010: 18B25, 03F05, 03F50, 03G30
1 Introduction
A signature Σ consists of constant symbols, function symbols, and relation sym-
bols together with an assignment of a unique positive integer (arity) to any object
of the latter two kinds. A language L is comprised of a signature Σ and formation
rules, i.e., rules for forming formulae over Σ. The familiar Tarskian way of assign-
ing meaning to the symbols of L proceeds by associating set-theoretic objects to
them, notably functions and relations construed set-theoretically, giving rise to
the notion of (set-theoretic) structure for L and model of T for any theory T in the
language of L. There is also a more general notion of structure in a suﬃciently
rich category C. For example, if C has ﬁnite products, then any equational lan-
guage (i.e., equality being the sole relation symbol and equations the only formu-
lae) allows for interpretation in C, by viewing terms as morphisms and function
symbol application as composition. Another prominent example is the interpreta-
tion of the typed λ-calculus in cartesian closed categories (cf. [Lambek and Scott,
1988]). For still richer languages one must impose more conditions on C. If one
wants to extend this idea to higher order logic, then C is required to be a topos (cf.
[Johnstone, 2002, D1.2]). This extra level of generality of interpretation, however,
Michael Rathjen: Department of Pure Mathematics, University of Leeds, Leeds LS2 9JT, United
Kingdom, e-mail: rathjen@maths.leeds.ac.uk

348
|
M. Rathjen
comes with a penalty to pay in that only intuitionistically valid consequences can
be guaranteed to survive the interpretation.
One is often interested in transferring results from the category of sets, Set,
where classical logic, the axiom of choice and more reign, to an arbitrary topos E.
This is possible, for instance, for the following (non ﬁrst-order) assertion:
All modules over ﬁelds are ﬂat.¹
A result that ensures this transfer is commonly called Barr’s Theorem (cf. e.g.[Lane
and Moerdijk, 1992, p.515])² but it can also be inferred from cut elimination for the
inﬁnitary logic Lω1ω (see later parts of this paper). For this to work, however, the
formalization of mathematical notions is important. They have to be chosen care-
fully, as familiar equivalences are liable to fail in an intuitionistic setting. More-
over, to ensure survival of statements it will be important to develop mathematics
within (classical) geometric theories and to couch statements as geometric impli-
cations. The topos-theoretic result alluded to above is the following.
Theorem: 1.1. For every Grothendieck topos E there exists a complete Boolean al-
gebra B and a surjective geometric morphism Sh(B) →E. Here Sh(B) is the topos
of sheaves on the Boolean algebra with the usual sup topology. Moreover, Sh(B)
is a Boolean topos and satisﬁes the axiom of choice, in the sense that for any epi
e : Y 䀀䀤X there exists s : Y →X such that e ∘s = 1Y.
As a consequence³ one arrives at the following insight.
Corollary: 1.2. If T is a geometric theory and A is a geometric statement deducible
from T with classical logic, then A is also deducible from T with intuitionistic logic,
where by logic we mean inﬁnitary L∞ω-logic.
Though this Corollary also follows from a syntactic cut elimination result for L∞ω
(see section 7), Barr’s theorem is often alleged to achieve more in that it also allows
to eliminate uses of the axiom of choice. This is borne out by the following quotes:
1 This is just a simple example. Flatness of a module M, a notion introduced by Serre in 1956,
is usually deﬁned by saying that tensoring with M preserves injectivity. An equivalent way of
expressing in Lω1ω that M is a ﬂat R-module for a ring R is the following: For all m ∈ℕ, whenever
x1, . . . , xm ∈M and r1, . . . , rm ∈R satisfy ∑rixi = 0,then there exist y1, . . . , yn ∈M and aij ∈R
such that xi = ∑aijyj and ∑riaij = 0.
2 Disclaimer applying to the entire paper: This is not a paper on the history of certain pieces
of mathematics. The attribution of results to persons is borrowed from standard text books or
articles in the area, and therefore may well be historically inaccurate, as is so often the case.
3 There are several steps and further theorems involved; cf. [Johnstone, 2002, 3.1.16].

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
349
METATHEOREM. If a geometric sentence is deducible from a geometric theory in classical
logic, with the axiom of choice, then it is also deducible from it intuitionistically." (G.C.
Wraith: Intuitionistic Algebra: Some Recent Developments in Topos Theory. Proceedings of
the International Congress of Mathematicians, Helsinki, 1978 331–337)
This has the advantage that all such toposes satisfy the Axiom of Choice; so we obtain a
further conservativity result ..., asserting that uses of the Axiom of Choice may be elimi-
nated from any derivation of a geometric sequent from geometric hypothesis. (P. Johnstone:
Sketches of an elephant, vol. 2, p. 899)
Judging from conversations with logicians and discussions on internet forums
(e.g. MathOverﬂow), it is probably fair to say that the main appeal of Barr’s theo-
rem stems from its mysterious power to utilize AC and then subsequently get rid
of it. But can it really perform these wonders? As a backcloth for the discussion it
might be useful to recall some famous AC-removal results.
Theorem: 1.3. Below GCH stands for the generalized continuum hypothesis.
1.
(Gödel 1938–1940) If A is a number-theoretic statement and ZFC + GCH ⊢A
then ZF ⊢A.
2.
(Shoenﬁeld 1961, Platek, Kripke, Silver 1969) If B is a Π1
4-statement of second
order arithmetic and ZFC + GCH ⊢B then ZF ⊢B.
3.
(Goodman 1976, 1978) If A is a number-theoretic statement and HAω +ACtype ⊢
A, then HA ⊢A. Here HA stands for intuitionistic arithmetic also known as
Heyting arithmetic. HAω denotes Heyting arithmetic in all ﬁnite types with
ACtype standing for the collection of all higher type versions ACστ of the axiom
of choice with σ, τ arbitrary ﬁnite types.
So should Barr’s theorem be added to this list of renowned theorems with AC-
eliminatory powers? The above quotes by Wraith and Johnstone seem to suggest
that the addition of the axiom of choice to a geometric theory does not produce
new geometric theorems. But one immediately faces the question of what it means
to add AC to a theory T. Here it might be useful to introduce a rough distinction
which separates two ways of doing this. The ﬁrst route, which consists in express-
ing AC in the same language as T, will be referred to as an internal addition of
AC. If, on the other hand, AC is expressed in a richer language with a new sort of
objects where the choice functions live; we shall term it an external addition. If T
is a ﬁrst-order theory, then adding AC internally to T requires the language of T to
be suﬃciently rich. Moreover, internal AC forces the choice functions to be objects
falling under the ﬁrst order quantiﬁers of T, and thus, in general, the axioms of
T will “interact" with AC in this augmentation. By contrast, an external addition
of AC refers to a potentially larger universe, where the choice functions needn’t
be denizens of the realm that the original theory T speaks about. The foregoing

350
|
M. Rathjen
distinction is still very coarse, though. For instance the choice functions might be
external but they can certainly act on the original objects of T. Therefore if one
also demands principles of T (e.g. induction) to hold for terms that involve these
choice functions (like in the Goodman result) it is conceivable that conservativity
will be lost (as is the case with the classical version PAω +ACtype of HAω +ACtype).
Notwithstanding that there are multifarious possibilities to add AC, labeling some
of them as internal and others as external augmentations provides a useful, if
crude, heuristics.
In view of Theorem 1.3 one can also ask if Barr’s Theorem can be beefed up
to include more than just AC. For instance, how about the continuum hypothesis,
V = L, ◊and other axioms?
2 Geometric and ∞-geometric theories
Below we will work in the extension L∞ω of ﬁrst order logic (Lωω) which has all
the formulae engendering rules of the latter but also allows to form inﬁnitely long
conjunctions ⋀Φ and disjunctions ⋁Φ from any set Φ of already constructed
formulae. A particulary well-behaved fragment of L∞ω is Lω1ω where the set Φ
in ⋀Φ and ⋁Φ is always required to be countable. Inﬁnitary logics began to play
an important role in logic in the 1950s.⁴
2.1 Geometric theories
Deﬁnition: 2.1. The geometric formulae are inductively deﬁned as follows: Every
atom is a geometric formula. If A, B, and C(a) are geometric formulae then so are
A ∨B, A ∧B and ∃x C(x) (where x does not occur in C(a).
Another way of saying this is that a formula is geometric iﬀit does not contain
any of the particles →, ¬, ∀.
A formula is called a geometric implication if it is of either form ∀⃗x A or ∀⃗x ¬A
or ∀⃗x (A →B) with A and B being geometric formulae. Here ∀⃗x may be empty. In
particular geometric formulae and their negations are geometric implications.
A theory is geometric if all its axioms are geometric implications.
4 “Yet inﬁnitary logic has a long prehistory. Inﬁnitely long formulas were introduced by C.S.
Peirce in the 1880s, used by Schröder in the 1890s, developed further by Löwenheim and Lewis
in the 1910s, explored by Ramsey and Skolem in the 1920s, extended by Zermelo and Helmer
in the 1930s, studied by Carnap, Novikov, and Bochvar (and explicitly rejected by Gödel) in the
1940s, and exploited by A. Robinson (1951).” [Moore, 1997]

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
351
Below we shall give several examples of geometric theories.⁵
Examples: 2.2.
1.
Robinson arithmetic. The language has a constant 0, a unary successor func-
tion suc and binary functions + and ⋅. Axioms are the equality axioms and the
universal closures of the following.
(a) ¬suc(a) = 0.
(b) suc(a) = suc(b) →a = b.
(c) a = 0 ∨∃y a = suc(y).
(d) a + 0 = a.
(e) a + suc(b) = suc(a + b).
(f) a ⋅0 = 0.
(g) a ⋅suc(b) = a ⋅b + a
A classically equivalent axiomatization is obtained if (3) is replaced by
¬a = 0 →∃y a = suc(y)
but this is not a geometric implication.
2.
The theories of groups, rings, local rings and division rings have geometric ax-
iomatizations. Local rings are commutative rings with 0
̸= 1 having just one
maximal ideal. On the face of it, the latter property appears to be second order
but it can be rendered geometrically as follows:
∀x (∃y x ⋅y = 1 ∨∃y (1 −x) ⋅y = 1).
3.
The theories of ﬁelds, ordered ﬁelds, algebraically closed ﬁelds and real closed
ﬁelds have geometric axiomatizations. To express invertibility of non-zero ele-
ments one uses ∀x (x = 0 ∨∃y x ⋅y = 1) rather than the non-geometric axiom
∀x (x
̸= 0 →∃y x ⋅y = 1).
To express algebraic closure replace axioms
s
̸= 0 →∃x sxn + t1xn−1 + . . . + tn−1x + tn = 0
by
s = 0 ∨∃x sxn + t1xn−1 + . . . + tn−1x + tn = 0
where sxk is short for s ⋅x ⋅. . . ⋅x with k many x.
Also the theory of diﬀerential ﬁelds has a geometric axiomatization. This theory
5 For more detailed descriptions of these theories and also the ones considered in Section 2.2,
see e.g. [Barwise, 1977], [Chang and Keisler, 1990, 1.4], [Hodges, 1993, Appendix: Examples].

352
|
M. Rathjen
is written in the language of rings with an additional unary function symbol δ.
The axioms are the ﬁeld axioms plus the axioms ∀x∀y δ(x+y) = δ(x)+δ(y) and
∀x∀y δ(x ⋅y) = x ⋅δ(y) + y ⋅δ(x).
4.
The theory of projective geometry has a geometric axiomatization.
5.
The theories of equivalence relations, dense linear orders, inﬁnite sets and
graphs also have geometric axiomatizations.
2.2 The inﬁnite geometric case
Inﬁnitary logics are much more expressive and it is interesting to investigate no-
tions of geometricity in these expanded settings. The inﬁnitary languages we have
in mind are such that they accommodate inﬁnite disjunctions ⋁Φ and conjunc-
tions ⋀Φ, where Φ is set of (inﬁnitary) formulae.⁶ This language is customarily
denoted by L∞ω.
In this richer language a formula is said to be inﬁnite geometric, notated ∞-
geometric, if in addition to ∨, ∧, ∃one also allows inﬁnite disjunctions ⋁Φ, where
Φ is already a set of ∞-geometric formulae satisfying the above proviso on the
number of variables.
An example of an axiom expressible in this richer language via a ∞-geometric
implication is the Archimedean axiom:
∀x (x < 1 ∨x < 1 + 1 ∨. . . ∨x < 1 + . . . + 1 ∨. . .)
or in more compact way with ℕ+ = {n ∈ℕ| n > 0}:
∀x ⋁
n∈ℕ+
x < n.
One often only considers the sublanguage Lω1ω of L∞ω where the formation of
⋁Φ and ⋀Φ is only permissible for countable sets of formulae Φ.
Deﬁnition: 2.3. The ∞-geometric formulae are inductively deﬁned as follows: Ev-
ery atom is a ∞-geometric formula. If A and B are ∞-geometric formulae then so
are A ∨B and A ∧B. If C(a) is a ∞-geometric formula with all occurrences of a
indicated and x is a bound variable that does not occur in C(a) then ∃x C(x) is a
∞-geometric formula. If Φ is a set of ∞-geometric formulae having a ﬁnite number
of free variables then ⋁Φ is a ∞-geometric formula.
6 It will be assumed that the total number of free variables occurring in the formulae of Φ is ﬁnite.
The reason for this commonly found restriction appears to be that in this language only ﬁnitely
many variables can be quantiﬁed at a time. So if one allowed inﬁnitely many free variables there
would be formulae which cannot be closed.

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
353
Another way of saying this is that a formula is ∞-geometric iﬀit does not con-
tain any of the particles →, ¬, ∀, ⋀.
The collection of ∞-geometric implications is generated as follows:
1.
If A, B are ∞-geometric formulae then A, ¬A and A →B are ∞-geometric
implications.
2.
If C(a) is a ∞-geometric implication and a is a free variable with all occurrences
indicated and x does not occur in C(a), then ∀x C(x) is a ∞-geometric implica-
tion.
3.
If Ψ is a set of ∞-geometric implications having a ﬁnite number of free variables
then ⋀Ψ is a ∞-geometric implication.
A theory is ∞-geometric if all its axioms are ∞-geometric implications.
Examples: 2.4. We list some examples of Lω1ω theories.
1.
The theory of torsion groups is characterized by the group axioms plus the ax-
iom
∀x ⋁{x ∘. . . ∘x
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
n-times
= e | n ≥1}.
2.
The theory of ﬁelds with characteristic a prime is characterized by the ﬁeld ax-
ioms together with the axiom
⋁{1 + . . . + 1
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
n-times
= 0 | n ≥2}.
3.
The theory of archimedean ordered ﬁelds is characterized by the ordered ﬁeld
axioms together with the axiom
∀x ⋁{x < 1 + . . . + 1
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
n-times
| n ≥1}.
4.
The class of structures isomorphic to the standard model of Peano arithmetic is
characterized by the axioms of PA conjoined with the axiom
∀x ⋁{x = 0 + 1 + . . . + 1
⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟⏟
n-times
| n ≥0}.
(1)
5.
The theory of connected graphs has the usual axioms for graphs and addition-
ally has the axiom
∀x∀y[x = y ∨⋁{∃z0 . . . ∃zn(x = z0 ∧y = zn ∧Ez0z1 ∧. . . Ezn−1zn) | n ≥1}],
where E is a two-place relation such that Ezizi+1 expresses that there is an edge
going from zi to zi+1.
The above theories, with the exception of the fourth example, are ∞-geometric. How-
ever, in the fourth example the induction axioms are not really needed as they are

354
|
M. Rathjen
implied in inﬁnitary logic by the axiom (1) and the axioms of Robinson arithmetic,
i.e. the axioms of PA pertaining to 0, suc, +, ⋅. They can be expressed by means of
geometric formulae as shown in 2.2.
In the logic L∞ω one has rules for ⋀and ⋁that generalize those for ∧and ∨,
respectively. In the sequent calculus version they can be rendered thus.
–
⋀-Conjunction:
A, Γ ⇒∆
and A ∈Φ
⋀L
⋀Φ, Γ ⇒∆
Γ ⇒∆, A
for all A ∈Φ
⋀R
Γ ⇒∆, ⋀Φ
–
⋁-Disjunction:
Γ ⇒∆, A
and A ∈Φ
⋁R
Γ ⇒∆, ⋁Φ
A, Γ ⇒∆
for all A ∈Φ
⋁L
⋁Φ, Γ ⇒∆
A detailed proof system for the logic L∞ω will be provided in section 5. Since the
technique of cut elimination will be an essential tool in our investigations, the
sequent calculus is most appropriate.
3 Adding the axiom of choice (internally) to
geometric theories does not preserve
conservativity
This section features two examples of geometric theories where the internal addi-
tion of AC does not preserve geometric conservativity. In the subsequent section
we will argue that the external addition of AC, in a certain sense, just amounts to
arguing in a stronger background theory. It might produce interesting results but
perhaps nothing that’s not easily obtainable from the Boolean-valued approach⁷
to forcing combined with the completeness result for Lω1ω (both from the 1960s).
7 In the Boolean-valued model approach one starts with a complete Boolean algebra 픹and
builds the 픹-valued extension V픹= ⋃α V픹
α of the universe V by letting V픹
α be the set of all func-
tions taking values in 픹whose domain is a subset of V픹
ξ for some ξ < α. Each formula of set
theory with parameters in V픹gets assigned a ‘truth value’ in 픹. So V픹is a model in many-valued
logic, with truth values lying in 픹.
The completeness theorem for Lω1ω says that a sentence of Lω1ω is deducible if and only
if it holds in all models of the underlying language. Note that while each formula of Lω1ω is

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
355
3.1 First example
The example to be presented is a ﬁrst-order theory. To deﬁne it we draw on a sim-
ple method, that is sometimes called Morleyisation, by which every theory can be
given a geometric axiomatization in a richer language.⁸
Deﬁnition: 3.1. Let L be a language In this subsection we shall only be concerned
with ﬁrst order formulae. ∀⃗x (A1( ⃗x ) 䀘䀯A2( ⃗x )) will stand for two formulae namely
∀⃗x (A1( ⃗x ) →A2( ⃗x )) and ∀⃗x (A2( ⃗x ) →A1( ⃗x )).
For each formula A(u1, . . . , un) of L with all free variables indicated we
add two new n-ary relation symbols PA( ⃗u ) and NA( ⃗u ) to the language, where
⃗u = u1, . . . , un. Call the new language La. The ﬁrst-order theory Ma in the lan-
guage La has the following axioms:
1.
∀⃗x ¬(PA( ⃗u )( ⃗x) ∧NA( ⃗u )( ⃗x)).
2.
∀⃗x (PA( ⃗u )( ⃗x) ∨NA( ⃗u )( ⃗x)).
3.
If A( ⃗u ) is atomic add the axioms ∀⃗x (PA( ⃗u )( ⃗x) 䀘䀯A( ⃗x )).
4.
If A( ⃗u ) is B( ⃗u ) ∧C( ⃗u ) add ∀⃗x (PA( ⃗u )( ⃗x ) 䀘䀯PB( ⃗u )( ⃗x ) ∧PC( ⃗u )( ⃗x )).
5.
If A( ⃗u ) is B( ⃗u ) ∨C( ⃗u ) add ∀⃗x (PA( ⃗u )( ⃗x ) 䀘䀯PB( ⃗u )( ⃗x ) ∨PC( ⃗u )( ⃗x )).
6.
If A( ⃗u ) is ¬B( ⃗u ) add ∀⃗x (PA( ⃗u )( ⃗x ) 䀘䀯NB( ⃗u)( ⃗x )).
7.
If A( ⃗u ) is B( ⃗u ) →C( ⃗u ) add ∀⃗x (PA( ⃗u )( ⃗x ) 䀘䀯NB( ⃗u )( ⃗x ) ∨PC( ⃗u )( ⃗x )).
8.
If A( ⃗u ) is ∃yB( ⃗u, y) add ∀⃗x (PA( ⃗u )( ⃗x ) 䀘䀯∃y PB( ⃗u,v)( ⃗x, y)).
9.
If A( ⃗u ) is ∀yB( ⃗u, y) add ∀⃗x (NA( ⃗u )( ⃗x ) 䀘䀯∃y NB( ⃗u,v)( ⃗x, y)).
If T is a ﬁrst-order theory, we denote by Ta the theory Ma augmented by the axioms
∀⃗x PA( ⃗u)( ⃗x )
for all axioms ∀⃗x A( ⃗x ) of T.
Clearly, Ma and Ta are ﬁnite geometric theories.
countable, the collection of all formulae is uncountable. The completeness result also holds for
nice countable sets of formulae called fragments. For any countable fragment LA of Lω1ω and a
sentence φ in LA, φ is deducible in LA (i.e., φ has a proof in Lω1ω such that every formula of
the proof belongs to LA) if and only if φ holds in all models.
8 One place where one can ﬁnd this terminology is Sacks’ book from 1972 [Sacks, 1972, p. 256].
The technique was used by Skolem in the 1920s and conceivably could have even older roots.
Albeit Skolemization would be more appropriate, that name is already used for something else.
Keisler in his 1977 paper [Keisler, 1977, Theorem 2.18] refers to this gadget as the introduction of
Skolem relations. Hodges, in his book [Hodges, 1993, p. 62] from 1993, called this method of gain-
ing a ∀∃axiomatization and quantiﬁer elimination in a richer language atomization. For Mor-
leyization in a topos-theoretic setting see e.g. Johnstone’s book [Johnstone, 2002, p. 858] from
2002.

356
|
M. Rathjen
Lemma: 3.2. Let Ma, T and Ta as above. Let ⊢i signify intuitionistic deducibility.
1.
For every formula A( ⃗u ) of L with all free variables indicated,
Ma ⊢i ∀⃗x [A( ⃗x ) ↔PA( ⃗u)( ⃗x )].
2.
As a classical theory, Ta is conservative over T, that is, for every L-sentence B,
T ⊢c B
iﬀ
Ta ⊢c B.
This is in general not true for T based on intuitionistic logic.
Proof: (1.) is proved by induction on the generation of A( ⃗u), making use of the
excluded middle principle for PA( ⃗u) that is encapsulated in the ﬁrst two axioms of
Ma.
(2.) This can be shown syntactically but the model-theoretic proof is shorter.
Every L-structure A can be expanded in just one way to an La-structure Aa which
is a model of Ma. Hence every model M of T can be expanded in just one way to
an La-structure. Moreover, Ma is a model of Ta. Also, by (1.), Ta comprises T as
it proves all axioms of T.
◻
Corollary: 3.3. Let L be the language of set theory and ZFa be the Morleyization
of Zermelo-Fraenkel set theory. ZFa + AC is not conservative over ZFa for geometric
implications of La.
Proof: Let AC be the statement ∀⃗x B( ⃗x ). By Lemma 3.2(1.) we have
ZFa ⊢AC ↔∀⃗x PB( ⃗u )( ⃗x ),
and hence ZFa + AC ⊢∀⃗x PB( ⃗u )( ⃗x ). If ZFa + AC were conservative over ZFa for
geometric formulae we could infer that ZFa ⊢∀⃗x PB( ⃗u )( ⃗x ) and hence ZFa ⊢AC,
which would yield ZF ⊢AC by Lemma 3.2(2.).
◻
3.2 Second example
Here we study an inﬁnitary theory. Let L耠be the language with a set of constants
X and inﬁnitely many unary predicates Pn and Qn for n ∈ℕ. Let T耠be the L耠
∞ω-
theory with the following axioms:
1.
∀z ¬[Pn(z) ∧Qn(z)] for all n ∈ℕ.
2.
⋁a∈X Pn(a) for all n ∈ℕ;
3.
⋁n∈ℕQn(f(n)) for all f ∈Xℕ.
Note that f does not appear as a function symbol in (3.); f(n) is just a constant from
X. T耠is clearly a ∞-geometric theory.

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
357
In L耠
∞ω we can express an instance Acc of countable choice as follows:
⋀
n∈ℕ
⋁
a∈X
Pn(a) →
⋁
f∈Xℕ
⋀
n∈ℕ
Pn(f(n)).
Now observe that T耠+ Acc is a syntactically inconsistent theory, where the latter
means that an inconsistency B ∧¬B for some formula B can be deduced with the
help of the usual logical rules and the inﬁnitary proof rules given at the end of
Section 2.2.⁹ By contrast, T耠is syntactically consistent as long as X has at least
two elements; although T耠does not have a model in Set if we assume countable
choice to hold in Set. That T is syntactically consistent can be seen as follows. Let
V[G] be a forcing extension of the ground model V in which the set Y := XN of
V becomes countable. In V[G] there is an enumeration of all functions f ∈Y, say
Y = {f0, f1, f2, . . .}. Let g : ℕ→X be deﬁned in such a way that g(n)
̸= fn(n). This
is possible since X has more than one element. Now deﬁne a model M for T耠in
V[G] by letting M = X and interpreting PM
n as {g(n)} and QM
n as X \ {g(n)}. This
shows that T耠has a model in V[G] and thus T耠is syntactically consistent.
4 Adding the axiom of choice externally to
geometric theories does preserve
conservativity
Let L be a language and T be a L∞ω-theory. We extend L to L耠by adding two
unary predicate symbols S and U and the binary relation symbol ∈. The idea is to
deﬁne a set theory with urelements where the axioms of T are supposed to hold for
the urelements. Formally this means that every axiom A of T has to be relativized
to U, denoted AU, i.e. all quantiﬁer occurrences ∀x . . . x . . . and ∃y . . . y . . . in A
have to be replaced by ∀x(U(x) →. . . x . . .) and ∃x(U(x) ∧. . . x . . .), respectively.
TU denotes the theory with language L耠and all axioms AU where A is an axiom
of T.
The axioms of set theory then hold for the objects in S. The axiom of exten-
sionality has to be given in the form
∀x, y[S(x) ∧S(y) ∧∀z(z ∈x ↔z ∈y) →x = y].
Further axioms proclaim that everything is either an urelement or a set but not
both, that urelements have no elements, and that the urelements form a set:
∀x [U(x)∨S(x)], ∀x ¬[U(x)∧S(x)], ∀x, y[U(x) →y ∉x], ∃y[S(y)∧∀x[x ∈y ↔U(x)].
9 Details of the inﬁnitary proof system will be provided in Section 5.

358
|
M. Rathjen
Let ZFU
n denote the set theory with language L耠with urelement axioms having
the above axioms, the usual axioms of set theory (Pairing, Union, Foundation,
Powerset) expressed for objects of sort S, Separation extended to the language
L耠, but with Replacement restricted to Σn-formulae of L耠.
Below we refer to deﬁnable global choice by which we mean that a formula
of set theory (usually with extra parameters) deﬁnes a well-ordering on the entire
universe (see [Levy, 1979, V.3.9] for details). The actual formula will be revealed in
the proof of the next theorem. We then have the following conservativity result.
Theorem: 4.1 (ZFC). Let B be a sentence of L∞ω. Then:
T ⊢B
iﬀ
ZFU
n + deﬁnable global choice + GCH + TU ⊢BU.
If T is ∞-geometric and A is a geometric implication, then also
T ⊢i B
iﬀ
ZFU
n + deﬁnable global choice + GCH + TU ⊢BU.
Proof: We argue in our background universe satisfying ZFC. Suppose ZFU
n +
global choice+GCH+TU ⊢BU. We then switch to a forcing extension V[G] in which
the language L耠, the formula B and its subformulae as well as the axioms of TU
together with their subformulae belong a countable transitive set X. Let f : X →N
be a bijection. Arguing in V[G], we shall work in the relativized constructible hi-
erarchy L(f) which starts with TC(f), the transitive closure of {f} (see [Jech, 2003,
13.24]). L(f) has a global deﬁnable well-ordering since TC(f) is countable in V[G].
It’s also a model of GCH. Using the reﬂection principle of ZF, we can take any
model M of T in L(f) and expand it into a model of ZFU
n +global choice+GCH+TU.
Thus M will satisfy B. But in L(f), T is a Lω1ω-theory and therefore, by the com-
pleteness theorem for this logic, there exists a deduction of B from T in L(f).
Consequently, if we work in a sequence calculus, invoking Theorem 7.9 yields that
there exists also a cut-free deduction of ⋀T →B in L(f), where ⋀T signiﬁes the
conjunction of all axioms of T.
Now it’s crucial to observe that ⋀T and B both belong to the ground model.
It remains to show that there is also a deduction of ⋀T →B in the ground model
V. To this end we shall prove a more general result:
(∗) If there is cut free deduction D of the sequent Γ ⇒∆in V[G] and Γ ⇒∆
belongs to the ground model V, then there already exists a deduction of Γ ⇒
∆in V.
In (∗) we refer to the sequent calculus for Lω1ω to be described in section 5. A se-
quent Γ ⇒∆consists of two ﬁnite sequences of Lω1ω-formulae Γ and ∆. We pro-
ceed by induction on the rank of D. It is crucial that D contains no cuts lest the
end sequents of the immediate subderivations of D contain formulae that are not

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
359
in the ground model and the inductive proof breaks down. The proof is straight-
forward except for the cases of a ⋀R or ⋁L inferences that require a bit more
attention. So suppose that the last inference of D was ⋀R. Then ∆is of the form
∆0, ⋀Φ and we have deductions DA of Γ ⇒∆0, A for all A ∈Φ. With Φ ∈V
we also have A ∈V for all A ∈Φ. Thus inductively for every A in Φ there exists
a deduction D耠
A of Γ ⇒∆0, A. Using collection and the axiom of choice we can
then compose a deduction D耠of Γ ⇒∆0, ⋀Φ in V. The case of an ⋁L inference
is similar.
The ﬁnal issue to be resolved is how the forcing extension V[G] can be ac-
cessed from the ground model V. There are several approaches to this (cf. [Kunen,
1980, Ch. VII.9]). One proper formal way is to resort to the Boolean valued ap-
proach (cf. [Bell, 1977]). Also note that in case the language L, the theory T and B
are all countable, it is not necessary to take a forcing extension. Then L(f) ⊆V and
the main ingredient for proving the theorem is just the completeness of Lω1ω.
◻
Remark: 4.2. The declared background theory for the previous Theorem is ZFC,
however, ZF would be suﬃcient. The axiom of choice can be dropped, though this re-
quires a more careful deﬁnition of the notion of inﬁnitary deduction which does not
have the axiom of choice built into its very deﬁnition. The problem lies with the in-
ﬁnitary rules ⋀R and ⋁L. AC is needed when we have to pick exactly one deduction
for each of the inﬁnitely many premisses of these inferences. But this can be avoided
by allowing non-empty sets of subdeductions of the same end sequent to ﬁgure in
a deduction. Details will be deferred to section 5.1. It should perhaps be mentioned
that jettisoning AC when dealing with inﬁnitary deductions is also important for the
Barwise completeness theorem (see [Barwise, 1975, III.5]).
A possible interpretation of those earlier quotes to the eﬀect that adding the axiom
of choice to a geometric theory T does not produce new geometric theorems is that
AC is simply added to an ambient external type theory IL which is grafted onto T.
Here IL is the intuitionistic type theory that holds in all toposes also known as the
internal logic of toposes (see [Lambek and Scott, 1988, II]). The axiom of choice
can be expressed in the language for the internal logic (the so-called Mitchell-
Bénabou language) in a straightforward way ([Lambek and Scott, 1988, II.6]). If
one now assumes that the language of T is incorporated into the Mitchell-Bénabou
language via relativization to a speciﬁc sort U and one also has an appropriate
treatment of the inﬁnite connectives then one gets the following result.

360
|
M. Rathjen
Corollary: 4.3. Let B be a sentence of L∞ω. Then:
Internal Logic + TU + AC ⊢c BU
iﬀ
Internal Logic + TU ⊢i BU
iﬀ
T ⊢i B
where ⊢c and ⊢i signify classical and intuitionistic derivability, respectively.
Proof: As the internal logic can be interpreted in a small fragment of ZF, this is a
consequence of Theorem 4.1.
◻
5 A sequent calculus for L∞ω
In his thesis Gentzen introduced a form of the sequent calculus and his technique
of cut elimination. The sequent calculus can be generalized to L∞ω.
A sequent is an expression Γ ⇒∆where Γ and ∆are ﬁnite sequences of
L∞ω-formulae A1, . . . , An and B1, . . . , Bm, respectively. We also allow for the
possibility that Γ or ∆(or both) are empty. The empty sequent will be denoted
by 0. Σ ⇒∆is read, informally, as Γ yields ∆or, rather, the conjunction of the Ai
yields the disjunction of the Bj. In particular, we have:
–
If Γ is empty, the sequent asserts the disjunction of the Bj.
–
If ∆is empty, it asserts the negation of the conjunction of the Ai.
–
if Γ and ∆are both empty, it asserts the impossible, i.e. a contradiction.
We use upper case Greek letters Γ, ∆, Λ, Θ, Ξ . . . to range over ﬁnite sequences of
formulae. Γ ⊆∆means that every formula of Γ is also a formula of ∆. Γ, A stands
for the sequence Γ extended by A.
Next we list the axioms and rules of the ﬁrst-order sequent calculus.
–
Logical Axioms
Γ, A ⇒∆, A
where A is any formula. In point of fact, one could limit this axiom to the case
of atomic formulae A.
–
Cut Rule
Γ ⇒∆, A
A, Λ ⇒Θ
Cut
Γ, Λ ⇒∆, Θ
The formula A is called the cut formula of the inference.
–
Structural Rules
Γ ⇒∆
Γ耠⇒∆耠
if Γ ⊆Γ耠, ∆⊆∆耠.

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
361
A special case of the structural rule, known as contraction, occurs when the
lower sequent has fewer occurrences of a formula than the upper sequent. For
instance, A, Γ ⇒∆, B follows structurally from A, A, Γ ⇒∆, B, B.
–
Rules for Logical Operations
Left
Right
Γ ⇒∆, A
¬A, Γ ⇒∆
B, Γ ⇒∆
Γ ⇒∆, ¬B
Γ ⇒∆, A
B, Λ ⇒Θ
A →B, Γ, Λ ⇒∆, Θ
A, Γ ⇒∆, B
Γ ⇒∆, A →B
A, Γ ⇒∆
A ∧B, Γ ⇒∆
B, Γ ⇒∆
A ∧B, Γ ⇒∆
Γ ⇒∆, A
Γ ⇒∆, B
Γ ⇒∆, A ∧B
A, Γ ⇒∆
B, Γ ⇒∆
A ∨B, Γ ⇒∆
Γ ⇒∆, A
Γ ⇒∆, A ∨B
Γ ⇒∆, B
Γ ⇒∆, A ∨B
F(t), Γ ⇒∆
∀L
∀x F(x), Γ ⇒∆
Γ ⇒∆, F(a)
∀R
Γ ⇒∆, ∀x F(x)
F(a), Γ ⇒∆
∃L
∃x F(x), Γ ⇒∆
Γ ⇒∆, F(t)
∃R
Γ ⇒∆, ∃x F(x)
In ∀L and ∃R, t is an arbitrary term. The variable a in ∀R and ∃L is an eigenvariable
of the respective inference, i.e. a is not to occur in the lower sequent.
The logic L∞ω in addition has rules for ⋀and ⋁that generalize those for ∧
and ∨, respectively.
A, Γ ⇒∆
and A ∈Φ
⋀L
⋀Φ, Γ ⇒∆
Γ ⇒∆, A
for all A ∈Φ
⋀R
Γ ⇒∆, ⋀Φ
Γ ⇒∆, A
and A ∈Φ
⋁R
Γ ⇒∆, ⋁Φ
A, Γ ⇒∆
for all A ∈Φ
⋁L
⋁Φ, Γ ⇒∆
In the rules for logical operations, the formulae highlighted in the premisses are
called the minor formulae of that inference, while the formula highlighted in the
conclusion is the principal formula of that inference. The other formulae of an
inference are called side formulae.

362
|
M. Rathjen
5.1 What are proofs in L∞ω?
Proofs in Lωω are ﬁnite objects and as a result its notion of proof is very robust.
For instance, if one knows for a fact that a formula A is provable in a primitive
recursive theory T, then one can conclude that it is inferrable in Heyting arith-
metic that T proves A. In other words, it is immaterial in which background theory
(e.g. ZFC plus large cardinals) we gained the insight that this fact is true. Things
are very diﬀerent when it comes to inﬁnite proofs. An example is provided by the
L∞ω intuitionistic (∞-geometric) theory HA∞whose axioms are those of Robin-
son arithmetic augmented by the axiom ∀x ⋁n∈ℕx =
̄n, where ̄n stands for the
n-th numeral. In ZF one can show that there exists an intuitionistic HA∞-proof of
a particular statement A that cannot be shown to exist in intuitionistic Zermelo-
Fraenkel set theory IZF.¹⁰
Even in a classical context it may be relevant to choose a suitable formaliza-
tion of inﬁnite proof. For instance, for Barwise’s completeness theorem for admis-
sible fragments is it important to choose a notion of proof that “does not have the
axiom of choice built into its very deﬁnition" ([Barwise, 1975], p. 96).
Deﬁnition: 5.1 (CZF). We will assume that the language L is a set. For the formal-
ization of the L-formulae as set-theoretic objects, we proceed in the same way as
Barwise in [Barwise, 1975, III.3]. They form an inductively deﬁned (proper) class of
sets. An additional assumption we shall make is that the proper subformulae of a
formula A are elements of the transitive closure of A which has the pleasant conse-
quence that the rank of a proper subformula of A is an element of the rank of A; in
symbols rank(B) ∈rank(A). Here we use the usual rank deﬁnition for sets, i.e.,
rank(a) = ⋃{rank(x) + 1 | x ∈a}.
Note that rank(a) is always an ordinal and x + 1 stands for x ∪{x}. Just as in the
classical world, an ordinal is a transitive set whose elements are transitive. How-
ever, the crucial diﬀerence between the classical and the intuitionistic context is the
forfeiture of the right to use the trichotomy law for ordinals in the latter, i.e., the
assertion α ∈β ∨β ∈α ∨α = β can no longer be guaranteed to hold.
Deﬁnition: 5.2. The class of L∞ω-proofs (also called deductions or derivations)
will be deﬁned inductively. It is desirable to ensure that the inferred formula and the
10 A can be taken of complexity Π0
3, namely ∀x∃y∀z (T(x, x, y) ∨¬T(x, x, z)), where T is the pred-
icate from Kleene’s normal form theorem. Now in the presence of countable choice, A implies the
existence of a non-computable function. That the existence of a HA∞proof of A cannot be shown
in IZF follows from the fact that IZF plus countable choice is compatible with the statement that
all functions from ℕto ℕare computable.

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
363
last inference together with its principal and minor formulae are straightforwardly
retrievable from any proof P. Firstly, sequents A1, . . . , Ar ⇒B1, . . . , Bs are eas-
ily coded set-theoretically as a pair of tuples ⟨⟨A1, . . . , An⟩, ⟨B1, . . . , Bs⟩⟩; we will
continue to use the former notation even when we refer to its set-theoretic coding.
We shall not write down all the clauses for the inductive deﬁnition of proofs.
Rather we will provide two illustrative cases, the ﬁnitary (∧R) and the inﬁnitary
(⋁L).
Suppose now we have two proofs D1 and D2 of sequents A1, . . . , Ar
⇒
B1, . . . Bs and A1, . . . , Ar ⇒B耠
1, . . . B耠
s and 1 ≤i0 ≤s such that Bi = B耠
i for
all i
̸= i0. Then
D : = ⟨⟨P1, P2⟩, ⟨∧R, i0, k0⟩, C1, . . . , Cp ⇒D1, . . . , Dq⟩
is a proof of C1, . . . , Cp ⇒D1, . . . , Dq⟩if 1 ≤k0 ≤q and Bi0 ∧B耠
i0 = Dk0, Ai ∈
{C1, . . . , Cp} for all 1 ≤i ≤r and Bi ∈{D1, . . . , Dq} whenever 1 ≤i ≤s and i
̸= i0.
It is clear that from P we can retrieve the last inference together with its principal
and minor formulae.
Next assume Φ is a set of L∞ω-formula and there is a function f with domain Φ
such that there are ﬁnite sequences Γ1, Γ2, ∆of formulae such that for every A ∈Φ,
f(A) is an inhabited set of proofs of Γ1, A, Γ2 ⇒∆. Let i0 be the position of any such
A in Γ1, A, Γ2. Then
D耠:= ⟨f, ⟨⋁L, i0, k0⟩, C1, . . . , Cp ⇒D1, . . . , Dq⟩
is a proof of C1, . . . , Cp ⇒D1, . . . , Dq if 1 ≤k0 ≤p, ⋁Φ = Ck0, C ∈{C1, . . . , Cp}
for every C ∈Γi with i ∈{0, 1}, and D ∈{D1, . . . , Dq} for all D ∈∆.
It should by now be obvious how to deal with the other inference rules.
Observe that the above deﬁnition allows to combine each inference step with
a structural rule. This has the advantage that structural rules needn’t be treated
as separate rules. There is a lot of leeway as to the details of formalizing inﬁnitary
proofs constructively. However, observe that the above deﬁnition of proof in the case
of (⋁L) (and dually (⋀R)) contains a crucial part that enables one to construct new
proofs from a collection of proofs. It has the advantage that in CZF one can prove
from the assumption that there exists a proof of Γ1, A, Γ2 ⇒∆for every A ∈Φ, that
there also exists a proof of Γ1, ⋁Φ, Γ2 ⇒∆by invoking Strong Collection (see [Aczel
and Rathjen, 2001, Aczel and Rathjen:, 2010]). In general, we wouldn’t be able to
single out a particular proof of Γ1, A, Γ2 ⇒∆for every A ∈Φ without relying on the
axiom of choice.
Let ⊢Γ ⇒∆signify that there is a proof of Γ ⇒∆. We also deﬁne provability with
length α and cut-degree ρ,
α
ρ Γ ⇒∆

364
|
M. Rathjen
to mean that there is a proof P of Γ ⇒∆such that rank(P) ∈α + 1 and for all cut
formulae C in P we have rank(C) ∈ρ. In particular
α
0 Γ ⇒∆then conveys that there
is a proof without cuts.
Naturally, proofs in theories will also be considered. An L∞ω-theory T is a set of
L∞ω-formulae without free variables. The T-proofs are deﬁned as the L∞ω-proofs
except that one adds the additional axioms Γ ⇒∆, A with A ∈T to the sequent
calculus.
That there is a T-proof of Φ ⇒Θ will be conveyed by T ⊢Φ ⇒Θ. Since the
theory T can be expressed in L∞ω via a single formula ⋀T we also have
T ⊢Φ ⇒Θ
iﬀ
⊢Φ, ⋀T ⇒Θ.
(2)
6 Turning classical ∞-geometric proofs into
intuitionistic ones
Recall that intuitionistic L∞ω-proofs are those obeying the simple structural re-
striction that there can be at most one formula on the right hand side of the se-
quent symbol ⇒. Below we shall indicate intuitionistic proofs in L∞ω by putting
I∞before the turn style symbol.
The fact that Lωω geometric proofs can be turned into intuitionistic ones is
basically a consequence of Gentzen’s Hauptsatz. It could have been proved by
Gentzen in 1934. It is not clear to the present author who ﬁrst made this observa-
tion but it can be found in Orevkov’s 1968 paper [Orevkov, 1968].¹¹ As for the L∞ω
case it is not clear to him whether there are any syntactic proofs in the published
literature (before [Rathjen, 2012]). But the purpose of this part of the article, rather
than originality, is to show that there is an easy syntactic proof that can also be
formalized in the constructive set theory CZF (see [Aczel and Rathjen, 2001, Aczel
and Rathjen:, 2010]). Closer inspection would actually reveal that intuitionistic
Kripke-Platek set theory (see [Aczel and Rathjen, 2001, Aczel and Rathjen:, 2010])
suﬃces. As in the ﬁnite case the crucial tool is the Hauptsatz for L∞ω.
Theorem: 6.1. If
α
ρ Γ ⇒∆then there exists α耠such that
α耠
0 Γ ⇒∆.
11 This is not to say that there are no interesting research questions left. Since cut elimination is
costly there are still unsolved problems as to how eﬃcient this procedure can be, in general and
for special theories (see e.g. [Mints, 2012]).

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
365
The proof of 6.1 in CZF will be deferred to section 7. Without paying attention to
constructivity issues, for the countable logic Lω1ω this was essentially shown by
Tait [Tait, 1968].
The main result of this section requires knowledge of some basic facts.
Lemma: 6.2 (Substitution). Let Γ(a) ⇒∆(a) be a sequent with all occurrences of
the free variable a indicated. Further, let t be an arbitrary term. If
α
ρ Γ(a) ⇒∆(a) ,
then
α
ρ Γ(t) ⇒∆(t) .
Proof: Proceed by induction on α.
◻
Lemma: 6.3 (Inversion).
1.
If
α
ρ Γ, A ∧B ⇒∆then
α
ρ Γ, A, B ⇒∆.
2.
If
α
ρ Γ ⇒∆, A ∧B then
α
ρ Γ ⇒∆, A and
α
ρ Γ ⇒∆, B .
3.
If
α
ρ Γ, A ∨B ⇒∆then
α
ρ Γ, A ⇒∆and
α
ρ Γ, B ⇒∆.
4.
If
α
ρ Γ ⇒∆, A ∨B then
α
ρ Γ ⇒∆, A, B .
5.
If
α
ρ Γ ⇒A →B, ∆then
α
ρ A, Γ ⇒∆, B .
6.
If
α
ρ Γ, A →B ⇒∆then
α
ρ Γ ⇒∆, A and
α
ρ Γ, B ⇒∆.
7.
If
α
ρ Γ ⇒¬A, ∆then
α
ρ Γ, A ⇒∆.
8.
If
α
ρ Γ, ¬A ⇒∆then
α
ρ Γ ⇒∆, A .
9.
If
α
ρ Γ ⇒∆, ∀x B(x) then
α
ρ Γ ⇒∆, B(s) for any term s.
10. If
α
ρ Γ, ∃x B(x) ⇒∆then
α
ρ Γ, B(s) ⇒∆for any term s.
11. If
α
ρ Γ, ⋁Φ ⇒∆then
α
ρ Γ, A ⇒∆for every A ∈Φ.
12. If
α
ρ Γ ⇒∆, ⋀Φ then
α
ρ Γ ⇒∆, A for every A ∈Φ.
13. With the exception of 4., 6. and 8. the above inversion properties remain valid
for the intuitionistic sequent calculus. One half of 6. also remains valid intution-
istically:
if I∞
α
ρ Γ, A →B ⇒∆then I∞
α
ρ Γ, B ⇒∆.
Proof: All can be shown easily by induction on α.
◻
Below we use ⋁(Φ, A) to stand for ⋁(Φ ∪{A}).
Lemma: 6.4.
1.
If I∞
Γ ⇒⋁(Φ, F(s)) , then I∞
Γ ⇒⋁(Φ, ∃x F(x)) .
2.
If I∞
Γ ⇒⋁(Φ, B) and I∞
Γ ⇒⋁(Φ, C) , then I∞
Γ ⇒⋁(Φ, B ∧C) .
3.
If I∞
Γ ⇒⋁(Φ, A) , then I∞
Γ, ¬A ⇒⋁Φ .
4.
If I∞
Γ, B ⇒⋁Φ and I∞
Γ ⇒⋁(Φ, A) , then I∞
Γ, A →B ⇒⋁Φ .
5.
If I∞
Γ ⇒⋁(Φ, A) and A ∈Θ, then I∞
Γ ⇒⋁(Φ, ⋁Θ) .

366
|
M. Rathjen
Proof: (1.) We have
D ⇒D
(⋁R)
D ⇒⋁(Φ, ∃xF(x)) for all D ∈Φ
F(s) ⇒F(s)
(∃R)
F(s) ⇒∃xF(x)
(⋁R)
F(s) ⇒⋁(Φ, ∃xF(x))
(⋁L)
⋁(Φ, F(s)) ⇒⋁(Φ, ∃xF(x))
As I∞
Γ ⇒⋁(Φ, F(s)) , a cut with ⋁(Φ, F(s)) yields I∞
Γ ⇒⋁(Φ, ∃x F(x)) .
(2.) We have
B, D ⇒D
(⋁R)
B, D ⇒⋁(Φ, B ∧C) all D ∈Φ
B, C ⇒B
B, C ⇒C
(∧R)
B, C ⇒B ∧C
(⋁R)
B, C ⇒⋁(Φ, B ∧C)
(⋁L)
B, ⋁(Φ, C) ⇒⋁(Φ, B ∧C)
and therefore
D, ⋁(Φ, C) ⇒D
(⋁R)
D, ⋁(Φ, C) ⇒⋁(Φ, B ∧C) all D ∈Φ
B, ⋁(Φ, C) ⇒⋁(Φ, B ∧C)
(⋁L)
⋁(Φ, B), ⋁(Φ, C) ⇒⋁(Φ, B ∧C)
Cuts with I∞
Γ ⇒⋁(Φ, B) and I∞
Γ ⇒⋁(Φ, C) yield the desired outcome
I∞
Γ ⇒⋁(Φ, B ∧C) .
(3.) is shown as follows:
Γ, A ⇒A
(⋁R)
Γ, A ⇒⋁Θ
(⋁R)
Γ, A ⇒⋁(Φ, ⋁Θ)
Γ, B ⇒B
(B ∈Φ)
(⋁R)
Γ, B ⇒⋁(Φ, ⋁Θ)
(⋁L)
Γ, ⋁(Φ, A) ⇒⋁(Φ, ⋁Θ)
Γ ⇒⋁(Φ, A)
(Cut)
Γ ⇒⋁(Φ, ⋁Θ)
(4.) We have
Γ, A ⇒A
Γ, B ⇒⋁Φ
(→L)
A, Γ, A →B ⇒⋁Φ
Γ, C, A →B ⇒C
(∨R)
Γ, C, A →B ⇒⋁Φ all C ∈Φ
(∨L)
Γ, A →B, ⋁(Φ, A) ⇒⋁Φ

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
367
Cutting out ⋁(Φ, A) with I∞
Γ ⇒⋁(Φ, A) yields I∞
Γ, A →B ⇒⋁Φ .
(5.) is shown as follows:
Γ, A ⇒A
(⋁R)
Γ, A ⇒⋁Θ
(⋁R)
Γ, A ⇒⋁(Φ, ⋁Θ)
Γ, B ⇒B
(B ∈Φ)
(⋁R)
Γ, B ⇒⋁(Φ, ⋁Θ)
(⋁L)
Γ, ⋁(Φ, A) ⇒⋁(Φ, ⋁Θ)
Γ ⇒⋁(Φ, A)
(Cut)
Γ ⇒⋁(Φ, ⋁Θ)
◻
Lemma: 6.5. Let ∆be a ﬁnite set of ∞-geometric formulae and Γ be a ﬁnite set of
∞-geometric implications.
If
Γ ⇒∆then I∞
Γ ⇒⋁∆.
Proof: Here we rely on Gentzen’s Hauptsatz, Theorem 6.1, for classical L∞ω logic.
Let D be a cut free deduction of Γ ⇒∆. The proof proceeds by induction on
the ordinal height α of D.
If Γ ⇒∆is an axiom then there exists an atom A such that A ∈Γ ∩∆. Thus
I∞
Γ ⇒A and therefore, via (⋁R), we get to I∞
Γ ⇒⋁∆.
Now suppose that Γ ⇒∆is the result of an inference rule. We inspect the last
inference of D. Note that ∀R, ⋀R, ¬R and →R are ruled out since their principal
formulae are not ∞-geometric formulae and would have to occur in the succedent
∆.
If the last inference was of the form ∀L, ⋀L, ∧L, ∃L, ⋁L, or ∨L we can simply
apply the induction hypothesis to the premisses and re-apply the same inference
in the intuitionistic calculus.
If the last inference was ∃R we apply the induction hypothesis to its premiss
and subsequently use Lemma 6.4 (1) to get the desired result.
If the last inference was ∧R we apply the induction hypothesis to its premisses
and subsequently use Lemma 6.4 (2).
If the last inference was ¬L then its minor formula must be ∞-geometric.
Thus we can apply the induction hypothesis to its premiss and subsequently use
Lemma 6.4 (3).
If the last inference was →L then apply the induction hypothesis to its pre-
misses and subsequently use Lemma 6.4 (4).
If the last inference was ⋁R then apply the induction hypothesis to its pre-
misses and subsequently use Lemma 6.4 (5).
The case when the last inference was ∨R is similar to the previous one.
◻

368
|
M. Rathjen
Theorem: 6.6. Let T be a ∞-geometric theory and suppose that there is a classical
proof of a ∞-geometric implication G from T. Then there is an intuitionistic proof of
G from the axioms of T.
Proof: Below we shall write T ⊢A for T ⊢⇒A and T ⊢i A if there is an intuition-
istic proof of ⇒A from the axioms of T.
We proceed by induction on the buildup of G. First suppose that G is of the
form ∀⃗x F( ⃗x ) where F( ⃗a ) is a ∞-geometric implication. By (2) we have
⋀T ⇒G
where ⋀T is the conjunction of all axioms of T. Using the Inversion Lemma 6.3 (9.)
we get
⋀T ⇒F( ⃗a ) and hence T
F( ⃗a ) . The induction hypothesis (since
F( ⃗a) is a shorter formula than G) thus yields T ⊢i F( ⃗a) from which T ⊢i G follows
via (several) ∀R inferences.
Now suppose that G is of the form ⋀Φ, where Φ is a set of ∞-geometric for-
mulae. By ⋀-inversion on the right we get
⋀T ⇒H
for all H ∈Φ, and thus inductively we have
I∞
⋀T ⇒H
for all H ∈Φ, so that via (⋀R) we arrive at I∞
⋀T ⇒G , thus T ⊢i G.
If G is of the form ¬G0 with G0 ∞-geometric we apply the Inversion Lemma
6.3 (7.) to get
⋀T, G0 ⇒.
By Lemma 6.5 we infer that I∞
⋀T, G0 ⇒and thus, by ¬R, we have
I∞
⋀T ⇒¬G0 ,
thus T ⊢i G.
If F is of the form F0 →F1 with Fi geometric formulae we apply the Inversion
Lemma 6.3 (5.) to get
⋀T, F0 ⇒F1 .
By Lemma 6.5 we infer that I∞
⋀T, F0 ⇒F1 . By employing →R we get
I∞
⋀T ⇒F0 →F1 and hence T ⊢i G.
◻

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
369
7 Constructive cut elimination for L∞ω
The usual cut elimination proof for L∞ω uses the Veblen functions (see [Veblen,
1908]) φα in order to measure the “cost" of cut elimination. In a constructive set-
ting, however, one looses the linearity of ordinals as well as the principle that
every inhabited set of ordinals has a least element. As a result, the deﬁnition of
analogs of the φα functions has to be carried out in a diﬀerent way. A central gad-
get of cut elimination in inﬁnitary systems is the “natural" commutative sum of
ordinals α#β. Its deﬁnition utilizes the Cantor normal form of ordinals to base ω.
This normal form is not available in CZF (or IZF) and thus a diﬀerent approach is
called for. We shall have use for the following induction and recursion principle
on ordinals, henceforth referred to as ◁-induction and ◁-recursion.
Lemma: 7.1. Deﬁne (α, β) ◁(α耠, β耠) by
α = α耠∧β ∈β耠or α ∈α耠∧β = β耠or α ∈α耠∧β ∈β耠.
1.
(CZF) ∀α∀β [∀훾∀δ((훾, δ) ◁(α, β) →F(훾, δ)) →F(α, β)] →∀α∀β F(α, β).
2.
(CZF) If G is a total (n + 3-ary class function G : Vn × ON × ON × V →ON then
there is a (unique) (n+2)-ary class function F : Vn × ON × ON →ON such that
F( ⃗x, α, β) = G( ⃗x, α, β, {⟨훾, δ, F( ⃗x, 훾, δ)⟩| (훾, δ) ◁(α, β)}).
Proof: (1.) Assume
∀α∀β [∀훾∀δ((훾, δ) ◁(α, β) →F(훾, δ)) →F(α, β)].
(3)
Fix an arbitrary ordinal ρ. We show
∀ξ ∈ρ F(α, ξ)
(4)
by induction on α ∈ρ. So the inductive assumption gives ∀α0 ∈α ∀ξ ∈ρ F(α, ξ).
We then use use a further subsidiary induction on β ∈ρ to show F(α, β). By (3) it
suﬃces to show
∀훾∀δ[(훾, δ) ◁(α, β) →F(훾, δ)].
(5)
So suppose that (훾, δ) ◁(α, β).
Case 1: 훾= α and δ ∈β. F(훾, δ) follows by the subsidiary induction hypothesis.
Case 2: 훾∈α and δ = β. F(훾, δ) follows by the main induction hypothesis.
Case 3: 훾∈α and δ ∈β. F(훾, δ) also follows by the main induction hypothesis.

370
|
M. Rathjen
Thus we have shown (5). This establishes (4). Since ρ was arbitrary it follows
that F(α, β) holds for all α, β.¹²
(2.) Noting that {(훾, δ) | (훾, δ) ◁(α, β)} is a set, (2.) follows from (1.) in the
same manner as ordinary ∈-recursion follows from ∈–induction. For more details
see [Aczel and Rathjen:, 2010].
◻
Deﬁnition: 7.2. For a class X, let X∪:= X ∪{u | ∃y ∈X u ∈y}.
Deﬁne α#β by ◁-recursion as follows:
α#β
=
{훾#δ | (훾, δ) ◁(α, β)}∪
(6)
=
{α#δ | δ ∈β}∪∪{η#β | η ∈α}∪∪{η#δ | η ∈α ∧η ∈β}∪.
Lemma: 7.3.
1.
If X is a set of ordinals then X∪is an ordinal.
2.
α#β is an ordinal and α#β = β#α.
3.
If (훾, δ) ◁(α, β), then 훾#δ ∈α#β.
Proof: (1.) Let X be a set of ordinals. Then X∪is also a set of ordinals. It remains
to show that X∪is transitive. Suppose α ∈β ∈X∪. Then β ∈X or β ∈δ for some
δ ∈X. In the ﬁrst case we have α ∈⋃X ⊆X∪. In the second case we infer that
α ∈δ since δ is an ordinal, thus α ∈⋃X ⊆X∪.
(2.) follows by ◁-induction (also using (1.)).
(3.) is obvious by deﬁnition of α#β.
◻
Deﬁnition: 7.4. Let I be a set and (fi)i∈I be a deﬁnable collection of functions
fi : ONa(i) →ON
with arity a(i) ∈ℕ. Let X be a set of ordinals. Then the closure of X under (fi)i∈I,
Cl(X, (fi)i∈I), is deﬁned as follows:
X0
=
X∪∪{0}
Xn+1
=
Xn ∪{fi(α1, . . . , αa(i)) | α1, . . . αa(i) ∈Xn}∪
Cl(X, (fi)i∈I)
=
⋃
n∈ℕ
Xn.
Lemma: 7.5. Under same assumptions as in the foregoing deﬁnition, Cl(X, (fi)i∈I) is
an ordinal which contains 0 and all elements of X. Moreover, Cl(X, (fi)i∈I) is closed
under (fi)i∈I, i.e., if ⃗α ∈Cl(X, (fi)i∈I) then fi( ⃗α) ∈Cl(X, (fi)i∈I) for all i ∈I.
12 The reason for restricting the quantiﬁer in (4) to ρ is that it shows that ◁-induction with
F(α, β) follows from ∈-induction using a formula having no more unbounded quantiﬁers than
F. Of course, this is not essential to the current paper.

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
371
Proof: Induction on n shows that X ⊆X0 ⊆X1 ⊆. . . ⊆Xn and all Xn are
ordinals. Hence Cl(X, (fi)i∈I) is an ordinal. If α1, . . . , αa(i) ∈Cl(X, (fi)i∈I), then
α1, . . . , αa(i) ∈Xn for some n since a(i) ∈ℕ, and hence fi(α1, . . . , αa(i)) ∈Xn+1 ⊆
Cl(X, (fi)i∈I).
◻
Deﬁnition: 7.6. By main recursion on α and subsidiary recursion on β we deﬁne the
functions φα : ON →ON by letting φα(β) be the closure of
{φα(ξ) | ξ ∈β}
under the functions # and (φη)η∈α.
Lemma: 7.7. (CZF) For all α, β, φα(β) exists. Also 0 ∈φα(β).
1.
If δ, ξ ∈φα(β) then φδ(ξ) ∈φα(β).
2.
If δ ∈β then φα(δ) ∈φα(β).
3.
If δ, ξ ∈φα(β), then δ#ξ ∈φα(β).
Proof: The existence of φα(β) follows by main induction on α and subsidiary in-
duction on β, using Lemma 7.5. (1.), (2.), and (3.) are immediate by the closure
properties of φα(β).
◻
Lemma: 7.8 (Reduction).
Suppose ρ = rank(C). If
α
ρ Γ, C ⇒∆and
β
ρ Ξ ⇒Θ, C , then
α#α#β#β
ρ
Γ, Ξ ⇒∆, Θ .
Proof: The proof is by induction on α#α#β#β. We only look at two cases where C
was the principal formula of the last inference in both derivations.
Case 1. The ﬁrst is when C is of the form ⋀Φ. Then we have
α1
ρ Γ, C, A0 ⇒∆
and
βA
ρ Ξ ⇒Θ, C, A
for some α1 < α and A0 ∈Φ as well as βA < β for all A ∈Φ. By the induction
hypothesis we obtain
α1#α1#β#β
ρ
Γ, Ξ, A0 ⇒∆, Θ
and
α#α#βA#βA
ρ
Γ, Ξ ⇒∆, Θ, A0 .
As A0 is a subformula of C we have rank(A0) ∈ρ. Cutting out A0 thus gives
α#α#β#β
ρ
Γ, Ξ ⇒∆, Θ .

372
|
M. Rathjen
Case 2. The second case is when C is of the form ∀x A(x) Then we have
α1
ρ Γ, C, A(t) ⇒∆
and
β0
ρ Ξ ⇒Θ, C, A(a)
for some α1 < α, term t as well as β0 < β for some eigenvariable a. By Lemma 6.2
we have
β0
ρ Ξ ⇒Θ, C, A(t) .
By the induction hypothesis we thus get
α1#α1#β#β
ρ
Γ, Ξ, A(t) ⇒∆, Θ
and
α#α#β0#β0
ρ
Γ, Ξ ⇒∆, Θ, A(t) .
Observing that rank(A(t)) ∈rank(∀x A(x)) = ρ, cutting out A(t) gives
α#α#β#β
ρ
Γ, Ξ ⇒∆, Θ .
◻
Theorem: 7.9 (Cut Elimination Theorem).
If
α
ρ Γ ⇒∆then
φρ(α)
0
Γ ⇒∆.
Proof: We use induction on ρ with a subsidiary induction on α.
If Γ ⇒∆is an axiom then we clearly get the desired result. So let’s assume
that Γ ⇒∆is not an axiom. Then we have a last inference (I) with premisses
Γi ⇒∆i. Suppose the inference was not a cut. We then have
αi
ρ Γi ⇒∆i for
some αi < α. By the subsidiary induction hypothesis we obtain
φρ(αi)
0
Γi ⇒∆i .
Applying the same inference (I) yields
φν(α)
ρ
Γ ⇒∆.
Now suppose the last inference was a cut with cut formula C. Then rank(C) ∈
ρ and there exist derivations
α0
ρ Γ1, C ⇒∆1 and
α1
ρ Γ2 ⇒∆2, C for some
α0, α1 ∈α such that Γ1, Γ2 ⊆Γ and ∆1, ∆2 ⊆∆. By the subsidiary induction hy-
pothesis we conclude that
φρ(α0)
0
Γ1, C ⇒∆1 and
φρ(α1)
0
Γ2 ⇒∆2, C . By the
Reduction Lemma 7.8 we can infer
φρ(α0)#φρ(α0)#φρ(α1)#φρ(α1)
ν
Γ ⇒∆
where ν = rank(C). Since ν ∈ρ we can now employ the main induction hypothe-
sis, yielding
φν(φρ(α0)#φρ(α0)#φρ(α1)#φρ(α1))
0
Γ, C ⇒∆.

Remarks on Barr’s Theorem: Proofs in Geometric Theories
|
373
Since φν(φρ(α0)#φρ(α0)#φρ(α1)#φρ(α1)) ∈φρ(α) we arrive at
φρ(α)
0
Γ ⇒∆.
◻
Acknowledgment: Part of the material is based upon research supported by the
EPSRC of the UK through grant No. EP/K023128/1. This research was also sup-
ported by a Leverhulme Research Fellowship and a Marie Curie International Re-
search StaﬀExchange Scheme Fellowship within the 7th European Community
Framework Programme. This publication was made possible through the support
of a grant from the John Templeton Foundation. The opinions expressed in this
publication are those of the author and do not necessarily reﬂect the views of the
John Templeton Foundation.
Thanks are owed to the anonymous referee of this paper for valuable com-
ments that helped to improve the paper.
References
P. Aczel and M. Rathjen. Notes on constructive set theory. Technical Report 40, Institut Mittag-
Leﬀler, The Royal Swedish Academy of Sciences, Stockholm, 2001.
P. Aczel and M. Rathjen:. Constructive set theory. book draft, 2010.
J. Barwise. Admissible Sets and Structures. Springer, Berlin, 1975.
J. Barwise. An introduction to ﬁrst-order logic. In Handbook of Mathematical Logic, pages
5–46. North-Holland, Amsterdam, 1977.
J. R. Bell. Boolean-valued models and independence proofs in set theory. Clarendon Press,
Oxford, 1977.
C. C. Chang and H. R. Keisler. Model Theory. North-Holland, Amsterdam, 3 edition, 1990.
W. Hodges. Model theory. Cambridge University Press, 1993.
T. Jech. Set Theory. Springer, Berlin, 3 edition, 2003.
P. Johnstone. Sketches of an elephant: A topos theory compendium, volume 2. Clarendon Press,
Oxford, 2002.
J. Keisler. Fundamentals of model theory. In J. Barwise, editor, Handbook of Mathematical
Logic. North-Holland, Amsterdam, 1977.
K. Kunen. Set theory: An introduction to independence proofs. North-Holland, Amsterdam,
1980.
J. Lambek and P. J. Scott. Introduction to Higher Order Categorical Logic. Cambridge University
Press, 1988.
S. Mac Lane and I. Moerdijk. Sheaves in Geometry and Logic. Springer, Berlin, 1992.
A. Levy. Basic set theory. Springer, Berlin, 1979.
G. Mints. Classical and intuitionistic geometric logic. In Philosophy, Mathematics, Linguistics:
Aspects of Interaction 2012. Talk at Conference, May 2012.

374
|
M. Rathjen
G. H. Moore. The prehistory of inﬁnitary logic: 1885 – 1955. In Mundici Dalla Chiara, Doets and
Benthem, editors, Structures and norms in science. Kluwer, Dordrecht, 1997.
V. P. Orevkov. Glivenko’s sequence classes. In V. P. Orevkov, editor, Logical-mathematical
calculus. Part 1, pages 131–154. Inst. Steklov, Leningrad, 1968.
M. Rathjen. Proof Theory. Lecture notes for a postgraduate course, Leeds, 2012.
G. Sacks. Saturated model theory. Benjamin, 1972.
W. W. Tait. Normal derivability in classical logic. Springer, Berlin, 1968.
O. Veblen. Continuous increasing functions of ﬁnite and transﬁnite ordinals. Trans. Amer.
Math. Soc., 9:280–292, 1908.

