Encryption and 
Decryption Algorithms 
for Plain Text and 
Images using 
Fractional Calculus
Synthesis Lectures on 
Engineering, Science, and Technology
Rafael Martínez-Guerra 
Juan Javier Montesinos-García
Juan Pablo Flores-Flores

Synthesis Lectures on Engineering, Science,
and Technology

The focus of this series is general topics, and applications about, and for, engineers
and scientists on a wide array of applications, methods and advances. Most titles cover
subjects such as professional development, education, and study skills, as well as basic
introductory undergraduate material and other topics appropriate for a broader and less
technical audience.


Rafael Martínez-Guerra •
Juan Javier Montesinos-García •
Juan Pablo Flores-Flores
Encryption and Decryption
Algorithms for Plain Text
and Images using Fractional
Calculus

Rafael Martínez-Guerra
Automatic Control
Center for Research and Advanced Studies of
the National Polytechnic Institute
(CINVESTAV-IPN)
Mexico City, Mexico
Juan Javier Montesinos-García
Institute of Electronics and Mechatronics
Technological University of the Mixteca
Huajuapan de León, Mexico
Juan Pablo Flores-Flores
Automatic Control
Center for Research and Advanced Studies of
the National Polytechnic Institute
(CINVESTAV-IPN)
Mexico City, Mexico
ISSN 2690-0300
ISSN 2690-0327
(electronic)
Synthesis Lectures on Engineering, Science, and Technology
ISBN 978-3-031-20697-9
ISBN 978-3-031-20698-6
(eBook)
https://doi.org/10.1007/978-3-031-20698-6
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland AG
2023
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether the
whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now
known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does
not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant protective
laws and regulations and therefore free for general use.
The publisher, the authors, and the editors are safe to assume that the advice and information in this book are
believed to be true and accurate at the date of publication. Neither the publisher nor the authors or the editors
give a warranty, expressed or implied, with respect to the material contained herein or for any errors or omissions
that may have been made. The publisher remains neutral with regard to jurisdictional claims in published maps
and institutional afﬁliations.
This Springer imprint is published by the registered company Springer Nature Switzerland AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

In memory of my father,
Carlos Martínez Rosales.
To my wife and sons,
Marilen, Rafael, and Juan Carlos.
To my mother and brothers,
Virginia, Victor, Arturo, Carlos,
Javier, and Marisela.
Rafael Martínez-Guerra
To my mother Irma and my father Javier,
whose love and support allowed me
to reach all my goals.
To my aunt Rosario and Uncle Clemente,
their teachings, love and support were
instrumental in my formation up to today.
To my cousin Oscar, for all these years
of support and assertive counsel.
In loving memory of my grandmother Soﬁa,
aunt Margarita and cousin Daniel.
Juan Javier Montesinos-García
To my family,
Eladio, Candelaria, Edy, Abril,
Mario, Amaia, Akane and Najmeh.
Juan Pablo Flores-Flores

Preface
Many people know that it is possible to intercept and modify data if an application does
not protect it when travels on an untrusted network, and the application then becomes
a disaster when it comes to security. In this book, we offer an alternative to encrypt and
decrypt messages using objects called integer and fractional-order estimators or observers,
by means of security codes. We establish a class of observers capable of carrying out this
work, by means of security codes where ﬁnally, since an observer is nothing more than
a mathematical model represented through nonlinear differential equations that can be
of integer or fractional type that serve as means to send messages either of the plain-
text type or of the image type whose key or security code to encrypt or decrypt is
nothing more than a set of initial conditions where it makes sense to speak of this means
of transporting the message either plain-text or image for speciﬁc attacks for chaotic
cryptosystems of the stream cipher type. In this book, we mention the type of observers to
treat either the integer or fractional order type and their main characteristics. We discuss
an important property of some systems such as Liouville systems that is very important
for the encryption and decryption of messages in integer and fractional order nonlinear
systems by using the synchronization property of chaotic systems where we address some
logistic maps such as Mandelbrot sets including Julia and fractal sets taking advantage of
their characteristics to encrypt or recover messages. We discuss some issues about stream
and block ciphers and some state observers. Various types of observers are proposed for
nonlinear systems of integer and fractional order from the simplest (Luenberger Observer)
to the most sophisticated such as the Supertwisting Observer for message receivers as well
as their vulnerability to attacks. Observers of the exponential polynomial type are proposed
together with the property of the Liouville type. We also propose the usefulness of robust
fractional systems of sliding modes with Liouville characteristics as means of transmission
and reception of plain-text and image messages. Of all the alternatives for encryption
and decryption of messages shown here, a vulnerability analysis to cryptographic attacks
(cryptoanalysis) is made, this is a security analysis, an important topic on the subject of
secure communications. The book is self-contained, that is to say, the necessary tools
to address the issues such as fractional calculus are given in the same book and several
vii

viii
Preface
examples are presented. Moreover, this book includes exercises that are left to the reader.
The book is directed to an audience such as professionals in the areas of mathematics,
physics and engineering and researchers in general and related areas with a minimum
of knowledge in higher mathematics. However, it also contains advanced research topics
for people interested in encryption and decryption, observers, synchronization and secure
communications areas. The book is organized as follows. In Chap. 1, a brief overview
of the main topics covered is presented giving an introduction to the state of the art on
encryption and decryption algorithms, synchronization of chaotic systems, security keys or
codes, security analysis such as cryptographic attacks, linear and differential cryptanalysis,
in addition to speciﬁc attacks for chaotic cryptosystems of type stream cipher. In Chap. 2,
some deﬁnitions are given about the Lyapunov exponents, stability, and state observers;
also fractals and synchronization are brieﬂy introduced. Chapter 3 shows the stream and
block ciphers and observers, binary representations as well as some conversions from
binary to decimal and vice versa, representations of plain text and images in integer bits
and ciphers with generalized synchronization. Chapter 4 deals with the study of Liouville
systems and cryptography, and a supertwisting observer is addressed as a receiver as
well as its vulnerability to cryptanalysis. Chapter 5 presents some basic concepts of state
observers, the exponential polynomial observer is used as a receptor, and the receptors are
based on properties related to Liouville systems. Chapter 6 shows some basic elements
of fractional calculus and some observers. Chapter 7 deals with the implementation of
systems with the property of Liouville and fractional order systems used for the encryption
and decryption of plain-text and image messages. In Chap. 8, we present robust fractional
order state observers as means of encryption and decryption, presenting a security analysis
and situations that lead to decryption failures. Finally, in Chap. 9, a new topic is described
in secure communications, and we present encryption and decryption algorithms by using
state observers that are represented by means of fractional-order chaotic systems with the
Atangana-Baleunu fractional derivative. Additionally, the reader will ﬁnd throughout this
material some exercises to strengthen the knowledge acquired.
Mexico City, Mexico
Rafael Martínez-Guerra
Juan Javier Montesinos-García
Juan Pablo Flores-Flores

Contents
1
Introduction .........................................................................
1
1.1
Chaotic System Synchronization and Encryption Algorithms ...............
1
1.1.1
Encryption Through Chaotic Systems ................................
2
1.2
Key or Security Code ..........................................................
3
1.3
Security Analysis...............................................................
4
1.3.1
Cryptographic Attacks (Cryptanalysis) ...............................
4
1.3.2
Differential Cryptanalysis .............................................
5
1.3.3
Linear Cryptanalysis...................................................
6
1.4
Speciﬁc Attacks for Stream Cipher-Type Chaotic Cryptosystems...........
6
1.4.1
Message Extraction ....................................................
6
1.4.2
Parametric Estimation .................................................
7
1.4.3
Brute Force Attacks....................................................
7
References ............................................................................
7
2
Synchronization of Chaotic Systems ..............................................
9
2.1
Chaotic Systems................................................................
9
2.1.1
Lyapunov Exponents ..................................................
10
2.2
Stability .........................................................................
12
2.2.1
Nonlinear Systems .....................................................
13
2.2.2
Stability and Linearization ............................................
15
2.2.3
Lyapunov’s Direct Method ............................................
24
2.3
State Observers.................................................................
30
2.3.1
Luenberger Observer ..................................................
30
2.4
Fractals and Synchronization ..................................................
38
References ............................................................................
46
3
Stream Cyphers and Block Cyphers ..............................................
47
3.1
Message and Data Carrier Signals ............................................
47
3.1.1
Decimal and Binary Numbers.........................................
48
ix

x
Contents
3.1.2
Binary to Decimal and Decimal to Binary Conversions .............
53
3.1.3
Representation of Plaintext with 8 Integers ..........................
55
3.1.4
Representation of Plain Images with 8 Bit Integers ..................
58
3.1.5
Data Carrier Signal ....................................................
69
3.2
Stream Ciphers and State Observers ..........................................
72
3.2.1
Pseudorandom Number Generator ....................................
73
3.2.2
The Luenberger Observer in a Stream Cipher ........................
77
3.3
Block Ciphers and Observers..................................................
83
3.3.1
Block Cipher ...........................................................
85
References ............................................................................
95
4
Liouvillian Systems and Cryptography ..........................................
97
4.1
Introduction ....................................................................
97
4.2
Transmitter .....................................................................
98
4.3
Receiver ........................................................................
101
4.3.1
Super-Twisting Based Receiver .......................................
101
4.3.2
Proof of Stability ......................................................
103
4.3.3
Reconstruction of the States Based Receiver .........................
107
4.4
Numerical Simulation..........................................................
108
4.5
Vulnerability to Cryptanalysis .................................................
113
4.6
Concluding Remarks...........................................................
114
References ............................................................................
115
5
State Observers and Cryptography ...............................................
117
5.1
Introduction ....................................................................
117
5.2
Encryption ......................................................................
118
5.2.1
Generating Pseudo-Random Numbers................................
118
5.2.2
Encryption Algorithm .................................................
119
5.3
Data Recovery..................................................................
123
5.3.1
Exponential Polynomial Receiver.....................................
123
5.3.2
Stability ................................................................
124
5.3.3
Liouvillian System Properties Based Receiver .......................
126
5.4
Numerical Simulation..........................................................
128
5.5
Concluding Remarks...........................................................
129
References ............................................................................
132
6
Fractional Systems ..................................................................
133
6.1
Gamma Function ...............................................................
133
6.1.1
Some Properties of the Gamma Function.............................
135
6.2
Beta Function ..................................................................
138
6.3
Euler’s Number and Its Relation to the Gamma Function ...................
141
6.4
Miscellaneous Examples.......................................................
144

Contents
xi
6.5
Fractional-Order Differential Equations ......................................
151
6.5.1
Laplace Transform of Fractional-Order Functions ...................
152
6.5.2
Solution of FODE by Means of the Laplace Transform .............
154
6.6
Fractional Dynamical System .................................................
156
6.6.1
Commensurate Fractional-Order Systems ............................
156
6.6.2
Incommensurate Fractional-Order Systems ..........................
157
References ............................................................................
157
7
Fractional-Order Liouvillian Systems and Encryption.........................
159
7.1
Introduction ....................................................................
159
7.2
Preliminaries ...................................................................
160
7.3
Fractional Derivative Numerical Estimation..................................
163
7.4
Encryption Algorithm..........................................................
165
7.5
Decryption .....................................................................
169
7.6
Numerical Results..............................................................
171
7.7
Security Analysis...............................................................
175
7.8
Concluding Remarks...........................................................
184
References ............................................................................
187
8
Fractional-Order Robust State Observers and Encryption ....................
191
8.1
Introduction ....................................................................
191
8.2
Preliminaries ...................................................................
192
8.3
Encryption Algorithm..........................................................
193
8.4
Receiver and Decryption.......................................................
197
8.5
Numerical Results..............................................................
201
8.5.1
Situations that Lead to Decryption Failure ...........................
207
8.6
Security Analysis...............................................................
208
8.7
Concluding Remarks...........................................................
217
References ............................................................................
217
9
Secure Communications by Using Atangana-Baleanu Fractional
Derivative ............................................................................
221
9.1
Introduction ....................................................................
221
9.2
Preliminaries ...................................................................
222
9.3
Encryption Algorithm..........................................................
224
9.4
Receiver and Decryption.......................................................
226
9.5
Numerical Results..............................................................
228
9.6
Security Analysis...............................................................
231
9.7
Concluding Remarks...........................................................
235
References ............................................................................
236
Index ......................................................................................
239

Notations and Abbreviations
N
The set of natural numbers
Z
The set of integers numbers
Q
The set of rational numbers
R
The set of real numbers
C
The set of complex numbers
A, B, . . .
Capital letters represent arbitrary sets
x, y, . . .
Lowercase letters represent elements of a set
A ⊂B
A is subset of B
x ∈A
x is element of A
A ∪B
The union of two sets
A ∩B
The intersection of two sets
Ac
Complement set of A
A \ B
Difference of sets A and B
⊕
Bitwise XOR logical operation
∅
Empty set
⇐⇒
Necessary and sufﬁcient condition
∀
For all
∼
Equivalence relation
a ≡b mod n
a is congruent with b module n
∗
Binary operation for groups
det(A)
The determinant of a square matrix A ∈Rn×n
| A |
The determinant of a square matrix A ∈Rn×n
Tr(A)
The trace of a matrix A
A⊺
The transpose of a matrix A
{}
Set
(aij)i,j
m × n matrix with entries aij, 1 ≤i ≤m, 1 ≤j ≤n
rank(A)
Rank of a matrix A
A−1
Inverse of A
˙y = dy
dt
First derivative of y with respect to t
xiii

xiv
Notations and Abbreviations
⊓⊔
Designation of the end of a proof
< (>)
Less (greater) than
≤(≥)
Less (greater) than or equal to

List of Figures
Fig. 2.1
State trajectories with different types of stability. Notice how the
asymptotic stability implies convergence to zero .........................
14
Fig. 2.2
State trajectories of the Dufﬁng unforced system, (a) x1 and (b) x2......
18
Fig. 2.3
State trajectories of the Van Der Pol oscillator, (a) x1 and (b) x2.........
20
Fig. 2.4
State trajectories of the Rössler chaotic oscillator, (a) x1 and (b) x2 ....
23
Fig. 2.5
State trajectories of a stable linearized dufﬁng oscillator .................
26
Fig. 2.6
State trajectories of the chaotic forced dufﬁng equation ..................
28
Fig. 2.7
Forced dufﬁng oscillator, state trajectories and estimates, (a) x1
and (b) x2 ....................................................................
33
Fig. 2.8
State estimation for the forced dufﬁng oscillator, (a)
synchronization error and (b) convergence of both trajectories
(oscillator and observer) ....................................................
34
Fig. 2.9
Van Der Pol oscillator, state trajectories and estimates, (a) x1 and
(b) x2 ........................................................................
36
Fig. 2.10
State estimation for the Van Der Pol oscillator, (a) synchronization
error and (b) convergence of both trajectories (oscillator and
observer) .....................................................................
37
Fig. 2.11
Rössler oscillator, state trajectories and estimates, (a) x1, (b) x2
and (c) x3 ....................................................................
39
Fig. 2.12
State estimation for the Rössler oscillator, (a) synchronization
error and (b) convergence of both trajectories (oscillator and
observer) .....................................................................
40
Fig. 2.13
Non autosimilar shape ......................................................
41
Fig. 2.14
Mandelbrot fractal...........................................................
43
Fig. 2.15
Julia fractal ..................................................................
44
Fig. 2.16
Synchronization of the mandelbrot and julia sets .........................
45
Fig. 3.1
Grayscale image ............................................................
59
Fig. 3.2
Grayscale operation image..................................................
60
Fig. 3.3
Grayscale image after the decryption process is successful ..............
61
Fig. 3.4
Grayscale image after the decryption process fails .......................
63
xv

xvi
List of Figures
Fig. 3.5
Color image with RGB pixels ..............................................
64
Fig. 3.6
Image representation with encrypted colors ...............................
66
Fig. 3.7
Original color image after the decryption process ........................
67
Fig. 3.8
Plain image after the decryption process fails .............................
68
Fig. 3.9
Ciphertext data signal .......................................................
70
Fig. 3.10
Cipher image signal .........................................................
71
Fig. 3.11
Representation of the stream cipher process ...............................
72
Fig. 3.12
Representation of the ciphertext auto key (CTAK) process ..............
73
Fig. 3.13
State trajectories of the attractor for the Dufﬁng oscillator ...............
76
Fig. 3.14
Original message to be encrypted by the Van der Pol oscillator .........
80
Fig. 3.15
Van der Pol oscillator and Luenberger observer convergence for
decryption of the image .....................................................
81
Fig. 3.16
Message recovery error by using the Van der Pol oscillator ..............
82
Fig. 3.17
Encrypted message by the output of the Van der Pol oscillator ..........
83
Fig. 3.18
Recovered message by the Luenberger observer after the
encryption of the Van der Pol oscillator....................................
84
Fig. 3.19
Original message to be encrypted by the Colpitts oscillator ..............
85
Fig. 3.20
Colpitts oscillator and Luenberger observer convergence for
decryption of the image ....................................................
86
Fig. 3.21
Message recovery error by using the Colpitts oscillator ..................
87
Fig. 3.22
Encrypted message by the output of the Colpitts oscillator ..............
88
Fig. 3.23
Recovered message by the Luenberger observer after the
encryption of the Colpitts oscillator .......................................
89
Fig. 3.24
Original message to be encrypted by the Rössler oscillator ..............
90
Fig. 3.25
Rössler oscillator and Luenberger observer convergence for
decryption on the image ....................................................
91
Fig. 3.26
Message recovery error by using the Rössler oscillator ...................
92
Fig. 3.27
Encrypted message by the output of the Rössler oscillator ...............
93
Fig. 3.28
Recovered message by the Luenberger observer after the
encryption of the Rössler oscillator ........................................
94
Fig. 4.1
Transmitted data.............................................................
109
Fig. 4.2
Encrypted data by Super-Twisting observer ...............................
110
Fig. 4.3
Encrypted data by reconstruction based receiver ..........................
110
Fig. 4.4
Recovered data by Super-Twisting observer ...............................
111
Fig. 4.5
Recovered data by reconstruction based receiver..........................
112
Fig. 4.6
Chosen image ...............................................................
114
Fig. 4.7
Recovered image by chosen plaintext attack...............................
115
Fig. 5.1
Diagram of the encryption process ........................................
120
Fig. 5.2
Plain image ..................................................................
128
Fig. 5.3
Encrypted image by observer (a) and its red (b), green (c) and
blue (d) histograms..........................................................
129

List of Figures
xvii
Fig. 5.4
Encrypted image by the reconstruction (a) and its red (b), green
(c) and blue (d) histograms .................................................
130
Fig. 5.5
Recovered image by the observer (a) and its red (b), green (c) and
blue (d) histograms..........................................................
131
Fig. 5.6
Recovered image by the reconstruction (a) and its red (b), green
(c) and blue (d) histograms .................................................
132
Fig. 7.1
Making an 8 bit integer by using the outer bits ............................
168
Fig. 7.2
Encryption and decryption..................................................
170
Fig. 7.3
Message and its red, green and blue histograms ...........................
172
Fig. 7.4
Convergence of the attractors and error ....................................
173
Fig. 7.5
Encrypted message and its red, green and blue histograms ...............
174
Fig. 7.6
Recovered message and its red, green and blue histograms...............
175
Fig. 7.7
Fractional derivative of the output and its estimated value................
176
Fig. 7.8
Data carrier signal and the recovered data carrier signal ..................
177
Fig. 7.9
Results for Luenberger(up) and Sliding modes (down) ...................
178
Fig. 7.10
First test for a data carrier signal contaminated by noise..................
179
Fig. 7.11
Second test for a data carrier signal contaminated by noise...............
180
Fig. 7.12
Effects of noise on the recovery of an image ..............................
181
Fig. 7.13
Chosen plain image and resulting image of the attack ....................
182
Fig. 7.14
Correlation of adjacent pixels of the plain image and the encrypted
image ........................................................................
183
Fig. 7.15
Chosen plaintext attack result ..............................................
184
Fig. 7.16
Noise effects on the scaled data carrier signal .............................
185
Fig. 7.17
Noise effects on the images ................................................
186
Fig. 8.1
Common sliding modes performance ......................................
195
Fig. 8.2
Signal representation of integer 173........................................
196
Fig. 8.3
(a) Message and recovered message, (b) message recovery error ........
202
Fig. 8.4
(a) x1 and ˆx1, (b) Synchronization error ...................................
203
Fig. 8.5
(a) x2 and ˆx2, (b) Synchronization error ...................................
204
Fig. 8.6
Message and its red, green and blue histograms ...........................
205
Fig. 8.7
Encrypted message and its red, green and blue histograms ...............
206
Fig. 8.8
Recovered message and its red, green and blue histograms...............
207
Fig. 8.9
Improper message reconstruction ..........................................
209
Fig. 8.10
Chosen plain image and resulting image of plaintext attack ..............
211
Fig. 8.11
Message and resulting image of synchronization attack ..................
213
Fig. 8.12
Chosen plain image and resulting image of plaintext attack ..............
214
Fig. 8.13
Message and resulting image of synchronization attack ..................
215
Fig. 8.14
Correlation of adjacent pixels of the plain image and the encrypted
image ........................................................................
216
Fig. 9.1
Signal representation of the integer number 173 ..........................
225
Fig. 9.2
Original message ............................................................
231
Fig. 9.3
Encrypted message ..........................................................
232

xviii
List of Figures
Fig. 9.4
Recovered message .........................................................
232
Fig. 9.5
The number 173 as message and the recovered signal ....................
233
Fig. 9.6
Message recovery error .....................................................
233
Fig. 9.7
Attractor synchronization ...................................................
234
Fig. 9.8
Synchronization error .......................................................
235
Fig. 9.9
Cryptanalysis result .........................................................
236

1
Introduction
Abstract
In this chapter we give an overview of cryptography and cryptanalysis where basic
concepts and deﬁnitions are given, also the relation of cryptography to chaotic systems
synchronization is addressed.
1.1
Chaotic System Synchronization and Encryption Algorithms
Chaotic systems synchronization was introduced in [1]. There is proposed a methodology
such that a chaotic system called slave, follows the state trajectories of a second chaotic
system called master. This, by means of a coupling signal. Subsequently, numerous
proposals have emerged to achieve the same goal, such as complete synchronization,
generalized synchronization, impulsive synchronization, phase synchronization, delay
synchronization, etc. As a result, multiple applications of chaotic systems synchronization
have been found. One of the most important is secure communications [2–9], which is the
main topic of this book.
Most encryption algorithms based on chaotic systems can be classiﬁed into one of the
following kinds of encryption:
•
Chaotic masking: It consists of adding the signal message on the output of a chaotic
system.
•
Chaos shift keying (CSK): It consists of transmitting a message as variations of a
given parameter of the chaotic system. It usually requires converting the message to
its binary equivalent, therefore, in this scheme 1 corresponds to a speciﬁc parameter
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_1
1

2
1
Introduction
value and 0 to another. As a result, changes occur in the behavior of the chaotic system
attractor.
•
Chaotic modulation: Here, the message changes the value of some parameter of the
chaotic system.
These are the best known methods that consist in encrypting messages with chaotic
systems and then recovering them by means of a synchronization. A more extensive
explanation of these encryption algorithms, based on chaotic systems is given below.
1.1.1
Encryption Through Chaotic Systems
There exist two basic types of chaotic cryptosystems: analog and digital. The former
are mainly based on the synchronization of chaotic systems, the second ones, can be
independent of synchronization and are completely digital. The implementation of an
analog encryption algorithm requires the circuits responsible of generating chaos to be
described in sufﬁcient detail, such as the explicit form of the differential equation of the
system and parameters that generate chaotic behavior. Meanwhile, for digital systems,
precision, arithmetic (ﬂoating or ﬁxed point), hardware conﬁguration, among others, must
be given.
In general, encryption algorithms are typically divided into two kinds: symmetric key
and asymmetric key. The former uses the same key to encrypt and decrypt information, as
a consequence these are extremely fast and useful to handle large volumes of data at high
speed. This kind of algorithms are divided into two classes:
•
Stream cipher: These generate a pseudo-random stream of symbols (keystream) by
means of a public deterministic algorithm, which is governed by a secret key. Thus,
the message is combined with the keystream, usually with a two-module sum or with
a bitwise XOR. Among the most common stream ciphers we have: A5 / 1, A5 / 2, E0.
RC4, SEAL, etc.
•
Block encryption: These encrypt the original message by clustering its elements
in blocks of two or more, so that each encrypted block is of the same size. These
algorithms usually consist of an initial transformation, a cryptographic function
iterated certain number of times and a ﬁnal transformation. Then, the key is expanded
using some algorithm so that enough key elements are obtained for each round of
encryption. The most popular algorithms of this kind are: AES, DES, RC5, etc.
Symmetric key algorithms generally have keys between 128 and 256 bits. On the other
hand, asymmetric key algorithms use two keys for the encryption and decryption process.
Usually one of the keys is public and the other private. When encrypting, both keys are
used and to decrypt only the private key is necessary. These algorithms are generally slow
as require complex operations with large integers, so they are used to encrypt small data

1.2
Key or Security Code
3
packets such as digital signatures, secret key agreements, etc. The most common public
key algorithm is RSA and its keys usually require between 1024 and 4096 bits [10].
The key is fundamental in any encryption algorithm. However, very few works in the
literature, proportionate detailed information about the key. Therefore, in the following
a simple introduction is given to understand the importance of these keys and how they
should be obtained for chaotic cryptosystems.
1.2
Key or Security Code
A common element in all encryption algorithms is the key. The security code of an
encryption algorithm must depend exclusively on the key [11].
No matter how strong and how well designed an algorithm is, if the key is not adequate,
then the encryption will be easily violated [10]. As has been said, there is little information
about how to choose or design the keys. Moreover, fundamental speciﬁcations such as the
space of the key or the variables to be used as key are not presented. Therefore, here this
will be one of the main aspects to be covered when proposing encryption algorithms.
The key space is deﬁned as the set of values that can be used as keys. The size of
the key space is given by the number of possible keys for the system. The keys from
classical encryption algorithms are usually strings of random bits that are generated by
some automatic process. In the chaotic encryption schemes, the properties of the key space
elements are not the same, since not all keys are equally strong. For this, a bifurcation
diagram can be useful to ﬁnd intervals in which a key produces periodic orbits and thus
avoid the use of weak keys (degenerate keys).
When many parameters are used simultaneously as a key, ﬁnding the most convenient
intervals (without degenerate keys) might be difﬁcult due to the dependence between the
parameters. In such case, the positive Lyapunov exponents can be used to describe the key
space. Thus, it must be obtained the largest Lyapunov exponent for the desired parameter
combinations, then, if the obtained exponent is positive, the parameter combination can be
used as a key.
The key space must be large enough to avoid brute force attacks. However, if the region
that produces chaotic behavior is not large enough, it must be increased as much as possible
to avoid equivalent keys. That is, to avoid a group of keys that can decrypt the same
encrypted message due to its closeness. Thus, the region that produces chaotic behavior
must be discretized so that the space between adjacent keys does not produce equivalent
keys.
The keys should favor the presence of the so called avalanche property, that is, when
a change occurs in the key the encrypted message will change radically and ideally it
should change at least half of the values of the encrypted message. In some cases, the
chaotic system parameters are set and only one of them is used as a key, which can be
counterproductive since it is possible to use a bit-error-rate (BER) attack in which some
system parameters are set and from these, an approximation of the one used as the key can

4
1
Introduction
be obtained. Therefore, the partial knowledge of the key should never reveal information
about the message or the unknown part of the key.
The security of an encrypted message is usually given by the priority when designing
an encryption algorithm. When a new encryption algorithm is presented, it is common
to provide a security analysis of it. Therefore, in the following will be presented an
explanation on what an appropriate security analysis should contain for each type of
cryptosystem.
1.3
Security Analysis
Security is the main interest of an encryption algorithm, so it must be evaluated at least by
a basic security analysis. This is, it must at least withstand the most known and popular
attacks to identify and correct defects before the system is published.
The algorithm will be resistant to the most common attacks if have two basic
characteristics: confusion and diffusion. The ﬁrst makes the relationship between the key
and the encrypted message as complex as possible, making difﬁcult to ﬁnd redundancies or
statistical patterns in the encrypted message. The second property consists of rearranging
or scattering the bits in a message so that the inﬂuence of the message and the key are
dispersed as best as possible within the encrypted message. To fulﬁll these requirements,
the algorithm must satisfy the following [12]
1. Sensitivity with respect to the key, that is, changing a single character of the key
produces completely different encrypted messages when the algorithm is applied to
the same message.
2. Sensitivity with respect to the message, that is, altering one bit of the message should
create totally different encrypted messages.
3. Absence of patterns in the encrypted text.
The ﬁrst two characteristics generate confusion, while the last one is responsible for
providing diffusion.
1.3.1
Cryptographic Attacks (Cryptanalysis)
During the security analysis, must be carried out attacks that assume that the cryptanalyst
knows the exact design of the algorithm and how it works. This is, everything about
the algorithm, except the key, is known. This must be done since the algorithm is sold
to several users and therefore, it is reasonable to assume that it will easily be stolen,
compromising all the details of its operation. Thus, the security of the algorithm must
depend only on its key and not in the secrecy of its operation.

1.3
Security Analysis
5
A cryptographic system can be described by the following elements:
1. P is the set of possible messages.
2. C is the set of possible encrypted messages.
3. K is the space of the key.
4. ek is the encryption algorithm for each element k ∈K.
5. dk is the corresponding decryption algorithm for the element k ∈K mentioned in the
previous point.
The operation of an algorithm can be summarized as follows: given a message x ∈P,
this can be encrypted with a key k ∈K by using the encryption rule e (x, k) = y, y ∈C.
Meanwhile, the encrypted message y is decrypted by using the corresponding decryption
rule d (y, k) = x, such that d (e (x, k) , k) = x.
There are several kinds of attacks to carry out the cryptanalysis of an algorithm. The
most popular ones are listed below, starting with the most complicated:
1. Ciphertext only (encrypted message): The attacker knows one or more encrypted
messages y1, y2, . . . , yn ∈C.
2. Known plaintext (known message): The attacker knows one or more messages
x1, x2, . . . , xn ∈P and its corresponding encrypted message y1, y2, . . . , yn ∈C.
3. Chosen plaintext (chosen message): The attacker has temporary access to the encryp-
tion device and can choose some messages x1, x2, . . . , xn ∈P as well as obtain the
encrypted messages y1, y2, . . . , yn ∈C that are generated.
4. Chosen ciphertext (chosen encrypted message): The attacker has temporary access
to the encryption device and can choose some encrypted messages y1, y2, . . . , yn ∈C
as well as obtain the messages x1, x2, . . . , xn ∈P that are generated.
The objective of each of these attacks is to obtain the key k or some equivalent key that
was used to encrypt the messages. In particular, the attacks of known and chosen message
are very effective in the cryptanalysis of algorithms based on chaotic systems [13–16].
There exist other attacks that are less common. However, these have characteristics of the
already mentioned above. In the case of block encryption algorithms, the analysis on the
susceptibility to differential and linear cryptanalysis should be included.
1.3.2
Differential Cryptanalysis
Differential cryptanalysis was introduced by Guojie et al. [17] and is a variant of the chosen
message attacks, which tries to ﬁnd the key of an iterative encryption algorithm. It consists
of analyzing the differences caused in encrypted messages when performing determined
changes in the messages that generated them. These differences are used to determine the
most probable key among all the possible keys. At the same time, the number of tests that

6
1
Introduction
would be done when implementing a brute force attack is reduced. Usually, the difference
is chosen as the result of a bitwise XOR operation between the two unencrypted messages.
1.3.3
Linear Cryptanalysis
Linear cryptanalysis was introduced in [18] and is essentially a known message attack
whose purpose is to generate a linear expression that approximates a certain block cipher.
A linear expression for a given iteration will be an equation that is based on the module-
two sum between the inputs and outputs of such iteration.
1.4
Speciﬁc Attacks for Stream Cipher-Type Chaotic Cryptosystems
There are several cryptanalysis forms for stream cipher encryption algorithms based on
chaotic systems. These can be classiﬁed as follows:
1. Extraction of the signal from the message s (t) of the transmitted signal y (t).
2. Extraction of the signal that carries the data c (t) and then remove it and retrieve the
message s (t).
3. Estimation of the transmitter’s secret parameters to completely break the algorithm.
4. Brute force attacks.
Each of these analyses is explained in greater detail below.
1.4.1
Message Extraction
When using chaotic masking techniques, extracting the signal is possible if the message
s (t) is a periodic signal during a sufﬁcient amount of time. Methods such as auto-
correlation and cross-correlation analysis, spectral power analysis, ﬁltering techniques,
and generalized synchronization are usually used.
Power spectral analysis and ﬁltering take advantage of the chaotic signals limitations,
which are used to mask the message. The power spectrum of the message must be
completely covered with the power spectrum of the chaotic signal that was used to mask
it. However, several encryption algorithms fail at this, since the commonly used chaotic
oscillators, such as Rössler, Lorenz, Chua, Dufﬁng, etc., have a much lower density power
than common messages. Therefore, these cannot support this type of ﬁlter-based attacks.
The generalized synchronization attack was introduced in [19]. This assumes that
the attractor used is known, but the oscillator parameters are ignored. Its purpose is to

References
7
reconstruct the signals used to hide the message and then access the signal that contains
the message.
1.4.2
Parametric Estimation
Several chaos-based encryption schemes are not sensitive enough to variations in transmit-
ter and receiver parameters, allowing similar parameters to be used for message retrieval.
Different methods can be used for this, for example, it is possible to solve the
differential equations based on the signals that they emit. Also, the parameters can be
estimated from a generalized synchronization scheme. In addition, some adaptive control
techniques can be useful to ﬁnd equivalent keys.
1.4.3
Brute Force Attacks
A brute force attack consists on testing all the possible keys. The effectiveness of this
attack will depend on the size of the key space and the attacker’s processing capacity. It is
commonly considered that any space with less than 2100 elements it is not safe, although
this number increases when the processing power is improved [10].
References
1. Pecora, L. M., & Carroll, T. L. (1990). Synchronization in chaotic systems. Physical Review
Letters A, 64, 821–824.
2. Kocarev, L., Halle, K. S., Eckert, K., Chua, L. O., & Parlitz, U. (1992). Experimental
demonstration of secure communications via chaotic synchronization. International Journal of
Bifurcation and Chaos, 2(03), 709–713.
3. Liao, T. L., & Huang, N. S. (1999). An observer-based approach for chaotic synchronization
with applications to secure communications. IEEE Transactions on Circuits and Systems I:
Fundamental Theory and Applications, 46(9), 1144–1150.
4. Cuomo, K. M., Oppenheim, A. V., & Strogatz, S. H. (1993). Synchronization of Lorenz-
based chaotic circuits with applications to communications. IEEE Transactions on Circuits and
Systems II: Analog and Digital Signal Processing, 40(10), 626–633.
5. Smaoui, N., Karouma, A., & Zribi, M. (2011). Secure communications based on the synchro-
nization of the hyperchaotic Chen and the uniﬁed chaotic systems. Communications in Nonlinear
Science and Numerical Simulation, 16(8), 3279–3293.
6. Wang, S., Kuang, J., Li, J., Luo, Y., Lu, H., & Hu, G. (2002). Chaos-based secure communica-
tions in a large community. Physical Review E, 66(6), 065202.
7. Li, Z., & Xu, D. (2004). A secure communication scheme using projective chaos synchroniza-
tion. Chaos, Solitons & Fractals, 22(2), 477–481.
8. Nana, B., Woafo, P., & Domngang, S. (2009). Chaotic synchronization with experimental
application to secure communications. Communications in Nonlinear Science and Numerical
Simulation, 14(5), 2266–2276.

8
1
Introduction
9. Li, C., Liao, X., & Wong, K. W. (2004). Chaotic lag synchronization of coupled time-delayed
systems and its applications in secure communication. Physica D: Nonlinear Phenomena,
194(3–4), 187–202.
10. Schneier, B. (2007). Applied cryptography: Protocols, algorithms, and source code in C. John
Wiley & Sons.
11. Menezes, A. J., Van Oorschot, P. C., & Vanstone, S. A. (1996). Handbook of applied
cryptography. CRC Press.
12. Alvarez, G., & Li, S. (2006). Some basic cryptographic requirements for chaos-based cryptosys-
tems. International Journal of Bifurcation and Chaos, 16(08), 2129–2151.
13. Biham, E., & Shamir, A. (2012). Differential cryptanalysis of the data encryption standard.
Springer Science & Business Media.
14. Alvarez, G., Montoya, F., Romera, M., & Pastor, G. (2000). Cryptanalysis of a chaotic encryption
system. Physics Letters A, 276(1–4), 191–196.
15. Stojanovski, T., Kocarev, L., & Parlitz, U. (1996). A simple method to reveal the parameters of
the Lorenz system. International Journal of Bifurcation and Chaos, 6(12b), 2645–2652.
16. Li, C., Li, S., Zhang, D., & Chen, G. (2005, May). Chosen-plaintext cryptanalysis of a clipped-
neural-network-based chaotic cipher. In International Symposium on Neural Networks (pp. 630–
636). Berlin, Heidelberg: Springer.
17. Guojie, H., Zhengjin, F., & Ruiling, M. (2003). Chosen ciphertext attack on chaos commu-
nication based on chaotic synchronization. IEEE Transactions on Circuits and Systems I:
Fundamental Theory and Applications, 50(2), 275–279.
18. Matsui, M. (1993, May). Linear cryptanalysis method for DES cipher. In Workshop on the
Theory and Application of of Cryptographic Techniques (pp. 386–397). Berlin, Heidelberg:
Springer.
19. Yang, T., Yang, L. B., & Yang, C. M. (1998). Breaking chaotic switching using generalized
synchronization: Examples. IEEE Transactions on Circuits and Systems I: Fundamental Theory
and Applications, 45(10), 1062–1067.

2
Synchronization of Chaotic Systems
Abstract
This chapter introduces important concepts about chaotic systems and how to determine
if a system is chaotic by Lyapunov exponents, it also gives an introduction to state
observers to synchronize two chaotic system, the observers stability and convergence
is analyzed using the previously given theory on stability. The chapter concludes with
a section introducing fractals and synchronization of fractals using dynamic control
2.1
Chaotic Systems
Most dynamic systems exhibit trajectories that after a transitory time converge to a certain
equilibrium point.
Some dynamic systems have unstable dynamics during this transitory time and in some
cases even show exponential separation between its trajectories, this is that the distance
between the states increases at an exponential rate after every measure, hence the distance
between them increases, but if it nears a sink point it is attracted to it and after some time it
will converge to the sink, this is a common occurrence, where unstable dynamics are just
transitory.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_2
9

10
2
Synchronization of Chaotic Systems
A chaotic trajectory is one that remains bounded and oscillates, this is that it does
not diverge but neither converges to a sink point or periodic orbit, showing a behavior
that seems random, at any moment there are points at the orbit that separate from its
initial condition as time passes, these points are called Lyapunov numbers and Lyapunov
exponents [1,2].
A chaotic system is one where its states have chaotic trajectories, two initial points
(initial conditions) arbitrarily close from each other at the beginning separate as time
passes, never to reach a common sink or orbit.
2.1.1
Lyapunov Exponents
Chaotic trajectories separate from each other as time passes, not every dynamic systems
has this property and in the ones that have it, not every trajectory can do this, the chaotic
motion happens depending on the initial condition and parameters of the system, so it is
necessary to measure if the distance between trajectories grows to determine the set of
values that promote chaotic behavior.
The Lyapunov number is used to better measure the rate of separation of very close
points, the Lyapunov exponent is the natural logarithm of the Lyapunov number, this
means that the trajectories that surround the ﬁxed point will separate from the point in
average a certain number of times each iteration [3].
Consider the state FT (x0) is the point where the trajectory with initial condition x0
converges after t time units, let ˙x = f (x0) be a system of differential equations with
x = (x1, . . . , xn) states, the Lyapunov exponent is deﬁned as follows:
Deﬁnition 2.1 The Lyapunov numbers and exponents of a trajectory are deﬁned as the
Lyapunov numbers and exponents of the associated time map.
It is necessary to obtain the derivative of the map DFt (x0) with respect of the initial
condition v, if the time is ﬁxed into one desired point, the derivative DFt (v) is a linear
map, then
d
dt Ft (x0) = f [Ft (x0)]
By differentiating with respect to t
d
dt DFt (x0) = Df [Ft (x0)] DFt (x0)
Which is the variational equation corresponding to the differential equation that
represents the system, the part DFt (x0) corresponds to the Jacobian of time t map
evaluated in the initial condition v, the ﬁrst part corresponds to the partial derivatives of

2.1
Chaotic Systems
11
the differential equation evaluated in the solution so:
Jt = DFt (x0)
A (t) = Df [Ft (x0)]
Then the derivative is rewritten as ˙Jt = A (t) Jt. The Jacobian Jt, when evaluated at
the initial condition v, maps small variations tangent to the trajectory at the initial time to
small variations to the trajectory at time T , this is:
DFt (x0) f (x0) = f [Ft (t)]
Where Ft (x0) is the trajectory at time T, the equations that determine the system f also
give the direction of the trajectory at all time, the derivative of this last equation is:
d
dt DFT t (x0) f (x0) = Df [Ft (x0)] DFt (x0) f (x0)
Doing a change of variable δ = DFt (x0) f (x0) satisﬁes
˙δ = Df [Ft (x0)] δ
δ (0) = f (x0)
Also the derivative with respect of time of the equation is
d2
dt2 Ft (x0) = Df [Ft (x0)] d
dt Ft (x0)
d
dt f [Ft (x0)] = Df [Ft (x0)] f [Ft (x0)]
Where f [Ft (x0)]=f(x0) at t = 0. An important consequence of this is that a bounded
trajectory either has one Lyapunov exponent equal to zero or an equilibrium in its limit set,
if this does not happen then 0 < b < |f [Ft (x0)]| < B for all t with the positive bound b
and B, if α (n) is the expansion in the direction of f (v) after n time units then
0 ≤lim
n→∞
1
n ln b ≤lim
n→∞
1
n ln α (n) ≤lim
n→∞
1
n ln B ≤0
Hence the Lyapunov exponent in the direction tangent of the trajectory is zero. Deﬁning
Δ (t) = det Jt where ˙Jt = A (t) Jt then:
Δt
′ = Tr [A (t)] △t
Δ0 = det J0 = 1

12
2
Synchronization of Chaotic Systems
So
det Jt = exp
 t
0
TrA (t) dt

This results makes possible to say that a system is dissipative if its time T map decreases
for all T>0, a trace Tr [A (t)] < 0 implies that the system is dissipative.
Let Ft (x0) be a solution for ˙x = f (x0), the orbit is chaotic if:
1. the trajectory Ft (x0) , t ≥0 is bounded.
2. the trajectory Ft (x0) has at least a positive Lyapunov exponent
Example 2.1 Consider the Lorenz system
˙x = −α (x −y)
˙y = βx −xz −y
˙z = xy −bz
The partial derivatives of the differential equation are:
A (t) =
⎡
⎢⎣
−α
α
0
β −z −1 −x
y
x −b
⎤
⎥⎦
Then Δ (t) = exp
 t
0 (−α −1 −b) dt

= e−(α+1+b)t, depending on the selection of
values the Lorenz system can be made chaotic or not
2.2
Stability
Secure communications based on control theory need systems with bounded dynamics,
this means that it is absolutely necessary that those systems are stable, an unstable system
has trajectories that never stop growing, making them useless for encryption purposes.
Various portions of the communication system need an stability analysis, for example
if synchronization or observers are involved it is necessary to show that the states of the
slave or observer converge to the ones of the master system i.e. the error is asymptotically
stable. The most helpful method to determine the stability of the system is based on the
works of Alexander M. Lyapunov named the general problem of motion stability, from this
work spawn two methods to determine the stability of a system: The linearization method
and the Lyapunov’s direct method. The linearization method obtains information about
local stability of an equilibrium point from the stability of a linear approximation of the

2.2
Stability
13
system, the direct method determines the stability by using an energy like scalar function
and is not locally limited. The linearization method is most common in stability analysis
of linear systems, but when dealing with nonlinear systems, the second method is the most
successful.
2.2.1
Nonlinear Systems
Dynamic systems are represented usually by a set of differential equations given by:
˙x = f (x, t)
With the nonlinear vector functionf (x, t). A nonlinear system can be classiﬁed as
autonomous and non autonomous, an autonomous systems states does not depend on the
time, its equation is written as:
˙x = f (x)
A non autonomous systems states depend on the time, a autonomous systems trajecto-
ries are not affected by the initial time but non autonomous trajectories are dependent on
the initial time.
When the trajectories of a system converge to a point it is called an equilibrium point
or equilibrium state:
Deﬁnition 2.2 A state xe is an equilibrium point of a system ˙x (t) = f (x) if the state
x (t) retains the value of xe once it has reach that value, since the equilibrium point satisﬁes
0 = (xe), this last equation makes possible to ﬁnd equilibrium points by solving it.
Example 2.2 Find the equilibrium points of the unforced Dufﬁng oscillator ¨x +d ˙x +bx +
ax3 = 0
By doing the change of variable ˙x = y the oscillator’s space state representation is :

˙x
˙y

=

0
1
−b −ax2 −d
 
x
y


14
2
Synchronization of Chaotic Systems
Fig. 2.1 State trajectories with
different types of stability.
Notice how the asymptotic
stability implies convergence to
zero
Then

0
0

=

0
1
−b −ax2 −d
 
x
y

When solving the equation it is possible to conclude that the equilibrium points are
x = ±√−b/a, y = 0.
Trajectories that enter equilibrium points usually remain within the equilibrium point,
some equilibrium points have basins of attraction, these are regions that surround the
equilibrium point, when a trajectory enters the basin of attraction it converges to the
attraction point or remains in an orbit around it. Nonlinear systems have a variety of
behaviors that may seem different than asymptotic stability and yet, they are stable (see
Fig. 2.1). In order to more accurately describe the stability of nonlinear systems a formal
deﬁnition of stability is given next:
Deﬁnition 2.3 The state x = 0 is said to be stable in the sense of Lyapunov or stable if
for every number R > 0, R ∈R, there exist a r > 0, r ∈R, such that if ∥x (0)∥< r,
then for every t ≥0, ∥x (t)∥< R. If the condition is not satisﬁed the systems is unstable.
The deﬁnition means that the trajectory of the system remains arbitrarily close to the
origin if its initial conditions are sufﬁciently close to the origin, this is, there is a ball of
radius r such that if the initial condition of the states start within that ball, the state remains
contained within a ball of radius R for all time t ≥0, the system is unstable if there is
at least one ball of radius R that for any r > 0 the trajectory does not remains contained
within the ball of radius R even if the initial conditions is within the ball.

2.2
Stability
15
Many control systems require that a state moves to a desired equilibrium point and
remain there, regardless of outside actions over the system, the next deﬁnition refers to
this concept:
Deﬁnition 2.4 An stable equilibrium state x (t) = 0 is said to be asymptotically stable
if there is r > 0, r ∈R such that ∥x (0)∥< r and it makes the state x (t) →0 when
t →∞.
Deﬁnition 2.5 An stable equilibrium state x (t) = 0 that is not asymptotically stable is
called marginally stable.
The deﬁnition states that any state that nears to 0 converges to 0 as time passes, it will
come inﬁnitely close to 0 and reach it when t →∞. this concept of stability only states
that the state will reach the desired equilibrium point after inﬁnite time, another concept
of stability considers how fast a state converges to the equilibrium point:
Deﬁnition 2.6 A stable equilibrium state x (t) = 0 is said to be exponentially stable if
there are numbers a > 0, a ∈R and λ > 0, λ ∈R that satisfy:
∥x (t)∥≤a ∥x (0)∥e−λt, ∀t > 0
The exponential convergence encompasses asymptotic stability and allows to bound the
states during their whole trajectory, the following image illustrates the different types of
stability:
Deﬁnition 2.7 If an exponentially or asymptotically stable equilibrium point remains as it
is for any initial condition, the equilibrium point is said to be globally exponentially stable
or globally asymptotically stable, otherwise the system is locally stable only.
2.2.2
Stability and Linearization
Lyapunov stability has to main methods, the ﬁrst one is about local stability of nonlinear
systems, it borrows from the idea that a nonlinear system should behave very similarly to
a linearized approximation of it when the initial conditions are not to far from the stable
equilibrium point. The linearization is a simple process, consider the nonlinear system:
˙x = f (x)

16
2
Synchronization of Chaotic Systems
The Taylor expansion of the system is
˙x =

∂f
∂x

(x=ep) x+ Ho (x)
where Ho (x) are the higher order terms and

∂f
∂x

is the Jacobian matrix deﬁned by:
J =
 ∂f
∂x1
· · · ∂f
∂xn

=
⎡
⎢⎢⎣
∂f1
∂x1 · · · ∂f1
∂xn
...
...
...
∂fm
∂x1 · · · ∂fm
∂xn
⎤
⎥⎥⎦
Evaluated in the equilibrium point ep. Thus the linear approximation of the system can
be written as:
˙x = Ax, A = J
The method to obtain a linearization of the system for a non autonomous system is
similar, having the system with input u:
˙x = f (x, u)
The Taylor expansion for the non autonomous system is:
˙x =
∂f
∂x

(x=ep,u=0)
x +
∂f
∂u

(x=ep,u=0)
u + Ho (x, u)
With Ho (x, u) being the higher order terms, then making the change of variable for the
Jacobian matrices A =

∂f
∂x

and B =

∂f
∂u

gives the linearization of the non autonomous
nonlinear system:
˙x = Ax + Bu
The Lyapunov linearization method allows to conclude about the stability of the
nonlinear system that:
•
The equilibrium point is asymptotically stable if the eigenvalues of the matrix A of
the linearized system are in the left half of the complex plane.
•
The equilibrium point is unstable if the linearized system is unstable
•
If at least one of the eigenvalues of the matrix A is in the vertical axis of the complex
plane, it is impossible to draw a conclusion about the stability of the system with the
linearization.

2.2
Stability
17
Example 2.3 The unforced Dufﬁng equation has the next space state representation:
˙x = y
˙y = −ay −bx −cx3
where a, b, c ∈R. The partial derivatives for each equation are:
∂f1
∂x = 0
∂f1
∂y = 1
∂f2
∂x = −bx −3cx2
∂f2
∂y = −ay
The terms are then arranged in a more convenient form:
∂f
∂x, y =

0
1
−bx −3cx2 −ay

It is desired to know the stability around the initial condition. x0 = 1, y0 = 1 thus
substituting these values in the previous equation leads to:
∂f
∂x0 = 0, y0 = 0 =

0
1
−b (1) −3c (1)2 −a (1)

then the linearized system is

˙x
˙y

=

0
1
−b −3c −a
 
x
y

The characteristic polynomial of the linearized system is s2 + as + (b + 3c) = 0,
choosing a = 5, b = 1 and c = 1 gives the eigenvalues s1 = −1, s1 = −4 making the
linearized system stable. The states of both, the linearized and nonlinear Dufﬁng unforced
equation, can be observed in Fig. 2.2. Notice that, although the states are not exactly the
same, these show a very similar behavior and over time they converge to the equilibrium
point. Depending on how dominant is the nonlinear part of the system, the linearization
resembles more or less the nonlinear system.

18
2
Synchronization of Chaotic Systems
0
5
10
15
20
25
30
−0.5
0
0.5
1
1.5
2
2.5
Time
States
 
 
x1
x1 linearized
a)
0
2
4
6
8
10
12
14
16
18
20
−3.5
−3
−2.5
−2
−1.5
−1
−0.5
0
0.5
States
States
 
 
x2
x2 linearized
b)
Fig. 2.2 State trajectories of the Dufﬁng unforced system, (a) x1 and (b) x2

2.2
Stability
19
Example 2.4 Another interesting chaotic dynamic system is the Van Der Pol oscillator. It
also has two states and is represented by the equation:
˙x = y
˙y = μ

1 −x2
y −x
Where the real value μ > 0 controls the nonlinear damping. This system has the
following partial derivatives:
∂f1
∂x = 0
∂f1
∂y = 1
∂f2
∂x = −2μxy −1
∂f2
∂y = −μx2 + μ
Then, rewriting the equation:
∂f
∂x, y =

0
1
−2μxy −1 −μx2 + μ

The evaluation of the stability around the point x0 = 0.5, y0 = 0 is done by evaluating
the partial derivatives around this point:
∂f
∂x, y =

0
1
−2μ (0.5) (0) −1 −μ (0.5)2 + μ

Thus the linearized system is:

˙x
˙y

=

0
1
−1 0.75μ
 
x
y

The Characteristic polynomial of the linearized system is s2 −0.75 µs + 1 = 0, being
the nonlinear system chaotic. When the parameters are selected to produce chaos, the
dynamic is bounded, but the linearized system diverges as it is an unstable linear system.
By selecting μ = 5, the linearized system has 0.2889 and 3.4611 as eigenvalues. The
resulting dynamic can be observed in Fig. 2.3

20
2
Synchronization of Chaotic Systems
0
5
10
15
20
25
30
−3
−2
−1
0
1
2
3
Time
States
x1
x1 linearized
a)
0
5
10
15
20
25
30
−10
−8
−6
−4
−2
0
2
4
6
8
10
Time
States
x2
x2 linearized
b)
Fig. 2.3 State trajectories of the Van Der Pol oscillator, (a) x1 and (b) x2

2.2
Stability
21
As expected, the chaotic system remains bounded and the states of the linearized system
diverge. If the parameter is selected such that the linearized system is stable, both systems
behave similarly, however, chaotic behavior is lost as the system is now asymptotically
stable.
This example shows a signiﬁcant difference in the stability of nonlinear systems
compared to the linearized equivalent. This limitation makes this approach less helpful
for the stability analysis of chaotic systems.
Example 2.5 The Rössler chaotic oscillator is deﬁned by the set of equations:
˙x = −y −z
˙y = x + ay
˙z = b + z (x −c)
The oscillator uses the parameters a, b, c ∈R. Changing these values affects the shape
of the attractor and the chaotic behavior. Then, the partial derivatives of the system are:
∂f1
∂x = 0
∂f1
∂y = −1
∂f1
∂z = −1
∂f2
∂x = 1
∂f2
∂y = a
∂f2
∂z = 0
∂f3
∂x = z
∂f3
∂y = 0
∂f3
∂z = x −c

22
2
Synchronization of Chaotic Systems
these results are arranged in a convenient way:
∂f
∂x, y, z =
⎡
⎢⎣
0 −1 −1
1 a
0
z 0 x −c
⎤
⎥⎦
It is desired to know the stability around the origin x0 = 0, y0 = 0, z0 = 0, evaluating
in the origin yields the linearized system:
⎡
⎢⎣
˙x
˙y
˙z
⎤
⎥⎦=
⎡
⎢⎣
0 −1 −1
1 a
0
0 0 −c
⎤
⎥⎦
⎡
⎢⎣
x
y
z
⎤
⎥⎦
With s3 + (c −a)s2 + (1 −ac)s + c = 0 as characteristic polynomial. This can be
further factorized into the expression (s +c)(s2−as +1). Then, if the values a = −2, b =
0.01, c = 3 are selected, the linearized system has −1, −1 and −3 as eigenvalues and it
behaves as is shown in Fig. 2.4.
The Linearization approximately has the same behavior around the origin, but if the
system is made chaotic the linearized equivalent becomes unstable.
Exercise 2.1 Obtain a conclusion about the stability of the Chua oscillator:
˙x = a [y −x −g (x)]
˙y = b (x −y + z)
˙z = −c (y)
g (x) = d1x +
d0 −d1
2

(|x + 1| −|x −1|)
By applying the linearization method, consider that the values a, b, c, d0, d1 ∈R can
be selected to affect the stability of the system.
Exercise 2.2 Obtain a conclusion about the stability of the pendulum given by:
˙x = y
˙y = −a sin x −by

2.2
Stability
23
0
2
4
6
8
10
12
14
16
18
20
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
Time
States
x1
x1 linearized
a)
0
2
4
6
8
10
12
14
16
18
20
−0.2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
Time
states
x2
x2 linearized
b)
Fig. 2.4 State trajectories of the Rössler chaotic oscillator, (a) x1 and (b) x2

24
2
Synchronization of Chaotic Systems
Exercise 2.3 Obtain a conclusion about the stability system:
˙x = x cos y
˙y = x (1 + y) −x2
2.2.3
Lyapunov’s Direct Method
The Lyapunov’s direct method takes the idea from physical system, where the system has
a certain amount of energy, when the system consumes said energy after some time it
depletes all of it and comes to a stop or equilibrium point. Thus, there is a similarity with
the stability of a nonlinear system, where a stable state depletes its energy and falls into
and equilibrium point and remains thereafter. Before advancing onto the needed stability
theorems, it is necessary to provide some deﬁnitions:
Deﬁnition 2.8 A function V (x) is said to be positive semideﬁnite if V (x) ≥0, ∀x ̸= 0
and V (x) = 0, x = 0.
Deﬁnition 2.9 A function V (x) is said to be negative semideﬁnite if V (x) ≤0, ∀x ̸= 0
and V (x) = 0, x = 0.
Deﬁnition 2.10 A function V (x) is said to be positive deﬁnite if V (x) > 0, ∀x ̸= 0 and
V (x) = 0, x = 0.
Deﬁnition 2.11 A function V (x) is said to be negative deﬁnite if V (x) < 0, ∀x ̸= 0 and
V (x) = 0, x = 0.
Theorem 2.1 Lyapunov Stability: Let x = 0 be an equilibrium point for the system
˙x = f (x) If there exists a continuously differentiable positive deﬁnite function V (x)
and its derivative ˙V (x) is negative semideﬁnite the equilibrium point 0 is stable, if ˙V (x)
is negative deﬁnite the system is asymptotically stable.
Proof Having ε > 0 and r ∈(0, ε] that make BR = {x ∈Rn | ∥x∥≤r}, let a =
min∥x∥=r V (x) , a > 0 and b ∈(0, α), so that Br = {x ∈BR | V (x) ≤b}.
Since the derivative ˙V [x (t)] ≤0 implies that V [x (0)] ≤V (0) ≤b, ∀t > 0 because
Br is a compact set, since V (x) is continuous and V (0) = 0 there is a positive real number
d > 0 that fulﬁlls
∥x∥≤d

2.2
Stability
25
and
V (x) < b
Then x (0) ∈Bd, x (0) ∈BR, x (t) ∈BR and x (t) ∈Br, hence ∥x (0)∥< d implies
that x (t) < r ≤ε for all t ≥0, this last part shows that the equilibrium point is stable.
Since V (x) is monotonically decreasing and bounded by zero, V [x (t)] →c ≥0 as
t →∞, suppose that c > 0, the continuity of V (x) implies that there is a δ > 0 such
that Bδ ∈Bc, the limit V [x (t)] →c > 0 implies that the trajectory x (t) is outside the
ball Bδ, let −y = maxδ≤∥x∥≤R ˙V (x) caused by the continuous function ˙V (x) having a
maximum over the compact set δ ≤∥x∥≤R and since −y < 0 it follows that
V [x (t)] = V [x (0)] +
 t
0
˙V [x (τ)] dτ ≤V [x (0)] −yt
Since the right side turns into a negative number as time passes, the inequality
contradicts the assumption that c > 0 showing that c = 0 and that the equilibrium is
asymptotically stable.
⊓⊔
Example 2.6 It was shown that the linearized Dufﬁng oscillator has a stable dynamic, for
convenience it is written as follows:

˙x1
˙x2

=

0
1
−b −3c −a
 
x1
x2

Then we propose to use the Lyapunov candidate function V (x) = xT x to show it is
indeed asymptotically stable, the derivative is:
˙V (x) = xT ˙x + ˙xT x
= xT Ax + xT AT x
=

x1 x2
 
0
1
−b −3c −a
 
x1
x2

+

x1 x2
 
0 −b −3c
1
−a
 
x1
x2

=

x1 x2
 
x2
−ax2 −(b + 3c) x1

+

x1 x2
 
−(b + 3c) x2
x1 −ax2

= [x2 (x1 −ax2) −x1x2 (b + 3c)] + [x1x2 −x2 (ax2 + x1 (b + 3c))]
= −2ax2
2 −x1x2 (2b + 6c −2)

26
2
Synchronization of Chaotic Systems
Choosing the values a = 5, b = 1, c = 0 affects the stability of the system and causes
it to have eigenvalues λ1 = −0.2087, λ2 = −4.7913 then:
˙V (x) = −10x2
2 −x1x2 (2 + 0 −2)
= −10x2
2
Thus the system is stable in the sense of Lyapunov:
˙V (x) ≤0
But knowing that the system is linear, then it is possible to conclude that it is also
asymptotically stable, as it is shown in Fig. 2.5.
Both states converge asymptotically to the origin as indicated by their chosen stable
poles.
0
5
10
15
20
25
30
35
40
45
50
−3
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
Time
States
x1
x2
Fig. 2.5 State trajectories of a stable linearized dufﬁng oscillator

2.2
Stability
27
Example 2.7 Since the Lyapunov’s direct stability is meant to analyze non linear systems
stability, let us ﬁnd out about the stability of the nonlinear forced Dufﬁng oscillator, as
previously, for convenience, it is rewritten:
˙x1 = x2
˙x2 = −ax2 −bx1 −cx3
1 + γ cos (ωt)
The same Lyapunov candidate function is useful in this case V (x) = xT x, the
derivative is
V (x) = xT ˙x + ˙xT x
=

x1 x2
 
x2
−ax2 −bx1 −cx3
1

+

x2 −ax2 −bx1 −cx3
1
 
x1
x2

= 2x1x2 −2x2

cx3
1 + bx1 + ax2

The nonlinear nature of the system makes impossible to assure that the derivative be
V (x) < 0 nor V (x) ≤0 regardless of the choosing of the values a,b and c, this situation
was expected, as chaotic systems are not asymptotically stable nor stable, they are only
bounded, this mean that they do not explode like an unstable linear system would, but also
do not converge to an equilibrium point either, instead they rather “oscillate” around the
equilibrium point. This phenomenon can be better appreciated in Fig. 2.6.
Exercise 2.4 Determine the stability conditions for the forced Dufﬁng oscillator:
˙x = y
˙y = −ay −bx −cx3 + d cos ωt
Exercise 2.5 Give a conclusion about the stability of the Van Der Pol equation:
˙x = y
˙y = μ

1 −x2
y −x
Exercise 2.6 Give a conclusion about the stability of the Chua equation:
˙x = a [y −x −g (x)]
˙y = b (x −y + z)

28
2
Synchronization of Chaotic Systems
0
10
20
30
40
50
60
70
80
90
100
−4
−3
−2
−1
0
1
2
3
Time
States
x1
x2
Fig. 2.6 State trajectories of the chaotic forced dufﬁng equation
˙z = −c (y)
g (x) = d1x +
d0 −d1
2

(|x + 1| −|x −1|)
Chaotic systems fulﬁll several instability theorems based on the Lyapunov stability
method, these could be useful when dealing with chaotic systems.
Theorem 2.2 First instability theorem: If within a region  surrounding the origin there
is a Lyapunov function V (x, t) such that V (0, t) = 0, ∀t ≥t0, V (x, t0) > 0 and ˙V (x, t)
is positive deﬁnite, the equilibrium point 0 is unstable at t = t0.
Theorem 2.3 Second instability theorem: If within a region  surrounding the origin
there is a Lyapunov function V (x, t) which fulﬁlls that V (0, t0) = 0 and V (x, t0) are
positive deﬁnite near the origin and the derivative ˙V (x, t) −λV (x, t) ≥0 where λ > 0
makes the equilibrium be unstable.

2.2
Stability
29
Theorem 2.4 Third instability theorem: If within a region  surrounding the origin there
is a Lyapunov function V (x, t) that has ﬁrst partial derivatives that decrease and V (x, t)
and ˙V (x, t) are positive deﬁnite, the origin is a boundary of the subregion of  called s
and at the boundary points of s V (x, t) = 0, causes the equilibrium point to be unstable.
Example 2.8 Consider the previous stability result on the unforced Dufﬁng oscillator
˙x1 = x2
˙x2 = −ax2 −bx1 −cx3
1
Where the Lyapunov candidate function V (x) = xT x yields the derivative
˙V (x) = 2x1x2 −2x2

cx3
1 + bx1 + ax2

= 2x1x2 −2bx1x2 −2cx3
1x2 −2ax2
2
Choosing a = −1, b = −1 and c = 0 lead to
˙V (x) = 2ax2
2
˙V (x) < 2ax2
2 + 1
Making the system unstable as stated in the ﬁrst instability theorem.
Exercise 2.7 Determine which set of parameters make the Rössler equation unstable as
stated in the second instability theorem;
˙x = −y −z
˙y = x + ay
˙z = b + z (x −c)
Exercise 2.8 Determine the set of parameters that make the Chua oscillator unstable
according to the third instability theorem:
˙x = a [y −x −g (x)]
˙y = b (x −y + z)
˙z = −c (y)
g (x) = d1x +
d0 −d1
2

(|x + 1| −|x −1|)

30
2
Synchronization of Chaotic Systems
Having covered the most important results about stability that are to be relied upon in
the rest of the book, the next step is to introduce state observers, that are one of the most
important part in secure communications based on non linear control theory.
2.3
State Observers
In many cases, dynamical systems do not have all states available to be directly measured
or the sensors required for their measurement are not available, then, it is necessary to
estimate the state variables that are not known, the process of estimating unknown state
variables is named observation and the device that computes the estimate is called a state
observer or simply observer. A state observer estimates the unknown state variables based
on the measure of the state variables that are accessible for the sensors of the system.
A very simple, yet effective solution to this problem is the Luenberger observer, named
after David G. Luenberger, it is most known and used for linear system’s observation, but
it is also capable of working well with non linear chaotic systems, in the next section the
details of its workings are given.
2.3.1
Luenberger Observer
The Luenbergerstate observer is a full dimensional state estimator, this means that it makes
a reconstruction of all the states of the desired system. The observer is basically a copy of
the system with a set of closed loop correction parameters that make the estimation error
asymptotically stable [4].
Consider the non linear autonomous system:
˙x = Ax + f (x)
y = Cx
where the matrix A is the linear part of the system and the vector f (x) contains the
nonlinear parts of each state, the Luenberger state observer for the system is:
˙ˆx = Aˆx + f

ˆx

+ KCe
ˆy = C ˆx
Where ˆx is the estimate of the state, K is a gain vector and e = x −ˆx is the estimation
error. Using the Lyapunov method for stability analysis gives good results and produces

2.3
State Observers
31
an easy way to compute the values of K, the derivative of the error is
˙e = Ax + f (x) −Aˆx −f

ˆx

−KCe
= Ae + f (x) −f

ˆx

−KCe
Making the change of variable φ (e) = f (x) −f ˆx generates the error dynamic
equation:
˙e = Ae + φ (e) −KCe
The proof of stability is based on the following assumptions:
Assumption 2.1 There is solution to the linear matrix inequality AT P + PA + 2αP +
βI < Q with the positive deﬁnite symmetric matrices P = P T > 0, Q = QT > 0 and
the real numbers α > 0, β > 0.
Assumption 2.2 The nonlinear part of the equation complies with the equation
xT Pφ (x) ≤2αxT Px + xT x.
The next Lyapunov equation and its derivative are used for the proof of stability:
V = eT Pe
˙V = ˙eT Pe + eT P ˙e
Proof The derivative is rewritten:
˙V = [Ae + φ (e) −KCe]T Pe + eT P [Ae + φ (e) −KCe]
= eT AT Pe + φ (e)T Pe −(KCe)T Pe + eT PAe + eT Pφ (e) −eT PKCe
= eT AT Pe + φ (e)T Pe + eT PAe + eT Pφ (e) −(KCe)T Pe −eT PKCe
By assumption 2.2
˙V ≤eT AT Pe + eT PAe + 2αeT Pe + eT e −(KCe)T Pe −eT PKCe
≤eT 
AT P + PA + 2αP + I

e −2eT PKCe
If assumption 2.1 is met
˙V < eT [Q −PKC] e

32
2
Synchronization of Chaotic Systems
The gain vector K is then selected to make the matrix Q −PKC deﬁnite negative thus
making the error asymptotically stable in the origin, allowing the observer to reconstruct
the states.
The result above implies that the error is asymptotically stable around the origin,
showing that the states of the observer converge to the states of the targeted system, then
it is safe to assume that after some time, the error is negligible and the observer states are
almost the same as the target system. the next examples show how the states converge and
the asymptotic stability around the origin that the error possess.
Example 2.9 The forced Dufﬁng oscillator is represented by the state equation:
˙x1 = x2
˙x2 = −ax2 −bx1 −cx3
1 + d cos ωt
y = x1
The matrices A =

0
1
−b −a

, f (x) =

0
−cx3
1 + d cos ωt

, x =

x1
x2

and C =

1 0

allow to express the system as:
˙x = Ax + f (x)
y = Cx
A Luenberger observer for the system is
˙ˆx = Aˆx + f

ˆx

+ KCe
ˆy = C ˆx
Where e =

x1 −ˆx1
x2 −ˆx2

and K =

k1
k2

. The obtained results by using the values
a = 0.2, b = −1, c = 1, d = 0.3, ω = 1, k1 = 5 and k2 = 10 are shown in Figs. 2.7
and 2.8.
If the gains are properly selected the error is asymptotically stable as the graphic shows,
the attractors converge and it is possible to see that the initial condition of the observer is
different than the Dufﬁng oscillator, and after a short while it falls into the equilibrium
point 0 and remains thereafter.

2.3
State Observers
33
0
1
2
3
4
5
6
7
8
9
10
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
Time
State
x1
x1 estimate 
a)
0
1
2
3
4
5
6
7
8
9
10
−4
−3
−2
−1
0
1
2
3
time
State
x1
x1 estimate
b)
Fig. 2.7 Forced dufﬁng oscillator, state trajectories and estimates, (a) x1 and (b) x2

34
2
Synchronization of Chaotic Systems
0
1
2
3
4
5
6
7
8
9
10
−6
−5
−4
−3
−2
−1
0
1
2
Time 
state
e1
e2
a)
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
−4
−3
−2
−1
0
1
2
3
x1
x2
system
observer
b)
Fig. 2.8 State estimation for the forced dufﬁng oscillator, (a) synchronization error and (b)
convergence of both trajectories (oscillator and observer)

2.3
State Observers
35
Example 2.10 The Van Der Pol dynamic equation is written as follows:
˙x1 = x2
˙x2 = μ

1 −x2
1

x2 −x1
y = x1
A Luenberger observer for the system has the following state equations:
˙ˆx1 = ˆx2 + k1e
˙ˆx2 = μ

1 −ˆx2
1

ˆx2 −ˆx1 + k2e
y = ˆx1
The observer can be expressed by the matrices:
 ˙ˆx1
˙ˆx2

=

0
1
−1 −μ
 
ˆx1
ˆx2

+

0
−μˆx2
1 ˆx2

+

k1
k2
 
1 0
 
ˆx1 −x1
ˆx2 −x2

ˆy = ˆx1
The Van Der Pol oscillator exhibits a bounded dynamic when μ = 5 and using the
gains k1 = 3 and k2 = 6 the observers behavior can be seen in the Figs. 2.9 and 2.10.
Again the error is asymptotically stable around the origin, both state quickly converge
as does the attractor.
Example 2.11 The Rössler oscillator:
˙x1 = −x2 −x3
˙x2 = x1 + ax2
˙x3 = b + x3 (x1 −c)
y = x2
The values a = 0.2, b = 0.2, c = 5.7 give a bounded dynamic, the state estimator has
gains: k1 = 12 , k2 = 5 and k3 = 17 with the next differential equation system:
˙ˆx1 = −ˆx2 −ˆx3 −k1e
˙ˆx2 = ˆx1 + a ˆx2 −k2
˙ˆx3 = b + ˆx3

ˆx1 −c

−k3e
y = ˆx2

36
2
Synchronization of Chaotic Systems
0
1
2
3
4
5
6
7
8
9
10
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
Time
States
x1
x1 observer
a)
0
1
2
3
4
5
6
7
8
9
10
−8
−6
−4
−2
0
2
4
6
8
Time
States
x2
x2 observer
b)
Fig. 2.9 Van Der Pol oscillator, state trajectories and estimates, (a) x1 and (b) x2

2.3
State Observers
37
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
−8
−6
−4
−2
0
2
4
6
8
x2
Oscillator
Observer
a)
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
−8
−6
−4
−2
0
2
4
6
8
x2
Oscillator
Observer
b)
Fig. 2.10 State estimation for the Van Der Pol oscillator, (a) synchronization error and (b)
convergence of both trajectories (oscillator and observer)

38
2
Synchronization of Chaotic Systems
The resulting graphics are shown in Figs. 2.11 and 2.12
Exercise 2.9 Design a Luenberger state estimator for the Linearized Dufﬁng equation:

˙x1
˙x2

=

0
1
−b −3c −a
 
x1
x2

y = x1
Exercise 2.10 Design a Luenberger observer for the linearized Van Der Pol system:

˙x1
˙x2

=

0
1
−1 0.75μ
 
x1
x2

y = x1
Exercise 2.11 Design a Luenberger state estimator for the Chua oscillator:
˙x1 = a [x2 −x1 −g (x1)]
˙x2 = b (x1 −x2 + x3)
˙x3 = −c (x2)
y = x2
g (x) = d1x +
d0 −d1
2

(|x + 1| −|x −1|)
2.4
Fractals and Synchronization
So far only continuous nonlinear systems have been analyzed, but there are many types
of discrete chaotic systems that are also important such as Logistic maps or fractals, this
last chaotic systems can comprehend real numbers or complex numbers, but all of them
are self similar and have symmetry at various scales, this means that the fractal structure
replicates itself at different scales i.e. it is made of the same structure at different scales
and repeats itself at any scale or magniﬁcation done into the structure, this is known as self
similarity, the main difference between a fractal and a non fractal object is that when the
non fractal is scaled up it does not contains the original object, as an example the Fig. 2.13
it is shown a circle.
When the circle is magniﬁed and does not contain any other circle nor it resembles the
ﬁgure it was magniﬁed from, the circle lacks of self similarity.

2.4
Fractals and Synchronization
39
Fig. 2.11 Rössler oscillator,
state trajectories and estimates,
(a) x1, (b) x2 and (c) x3
0
1
2
3
4
5
6
7
8
9
10
−10
−8
−6
−4
−2
0
2
4
6
8
10
Time
x1
x1
x1 observer
a)
0
1
2
3
4
5
6
7
8
9
10
−8
−6
−4
−2
0
2
4
6
8
Time
x2
x2
x2 observer
b)
0
1
2
3
4
5
6
7
8
9
10
−3
−2
−1
0
1
2
3
4
5
Time
x3
x3
x3 observer
c)

40
2
Synchronization of Chaotic Systems
0
1
2
3
4
5
6
7
8
9
10
−4
−3
−2
−1
0
1
2
3
4
5
Time
Error
e1
e2
e3
a)
−10
0
10
20
−15
−10
−5
0
5
10
−5
0
5
10
15
20
25
x1
x2
x3
System
Observer
b)
Fig. 2.12 State estimation for the Rössler oscillator, (a) synchronization error and (b) convergence
of both trajectories (oscillator and observer)

2.4
Fractals and Synchronization
41
Fig. 2.13 Non autosimilar shape
The main properties of fractals are listed below [5]:
1. Fractals have self similarity, this means that if a part of the fractal is magniﬁed it
resembles the complete object.
2. The topological dimension of the fractal is always less than its fractal dimension.
3. The border of the fractal is not deﬁned as it changes due to self similarity.
4. Fractals are represented by discrete dynamic functions or series.
The focus of this section is complex numbers fractals, in particular Mandelbrot and
Julia sets, consider the quadratic map:
zn+1 = z2
n + c
Where zn, c ∈C, if the parameter c = 0 the map has the ﬁxed point z = 0 that has the
basin of attraction |z| < 1, this means that function maps a point within the unitary circle
to another point within the same circle but, any other point z < 1 that is outside of the
unitary circle goes to inﬁnity, interestingly the values that are z = 1 are not contained in
either groups. the Mandelbrot set builds upon this idea, it represents the basin of attraction
of the values c = z0 that do not diverge to inﬁnity:
Deﬁnition 2.12 The Mandelbrot set is the basin of attraction for the quadratic map zn+1 =
z2
n + c where c = z0.

42
2
Synchronization of Chaotic Systems
Depending on the value of c that is within the Mandelbrot set there are bounded and
unbounded trajectories hence the basin of inﬁnity is nonempty and it has a boundary, this
boundary is called the Julia set:
Deﬁnition 2.13 The Julia set is the set of repelling ﬁxed points and periodic points along
with the limit points of the Mandelbrot set.
Therefore is said that Julia sets are contained within the Mandelbrot set, also consider
that the Julia set also encompasses maps with different orders that 2.
Graphically these two fractals represent the initial conditions of the function that does
not diverge, this could be seen as a sort of graphic representation of the behavior of each
initial condition. These are drawn as a two dimension maps of the initial conditions, in one
axis is the real part of the initial condition and in the other complex part, each pixel of the
graphic contains a different initial condition, the set is then iterated with each pixel, after
several iterations, the unbounded values are colored the same and the convergent values
are assigned a different color, also different colors can be given to individual bounded
values to provide more information about the convergence of the initial conditions within
the fractal.
Example 2.12 The Mandelbrot set given by the equation:
Zn+1 = Z2
n + c, Zn, c ∈C
For this example c = z0, the divergent part is represented by a blue color resulting in
Fig. 2.14.
The internal part of the Mandelbrot set is bounded while all the exterior is not, the
bounded part is also known as the attractor.
Example 2.13 The Julia set is deﬁned by the equation:
Zn+1 = Za
n + c, a ∈R, c ∈C
It is represented the same way as the Mandelbrot set, selecting the values a = 2 and
c = −0.61803, the next result shown in Fig. 2.15 is obtained.
The blue colored parts diverge and the red color parts remain bounded, both graphics
can also be interpreted as a visual representation of the convergence of the initial
conditions of the set.

2.4
Fractals and Synchronization
43
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
Fig. 2.14 Mandelbrot fractal
Inspired in the dynamic controllers found in [6] it is possible to design a dynamic
control law that makes possible to synchronize the attractor of two fractals, and guarantee
that the synchronization error decreases every iteration. Thus, consider the master system
represented by:
Mn+1 = f (Mn)
And the slave:
Sn+1 = f (Sn) + un
with the dynamic control law un = k [f (Mn) −f (Sn)].
Example 2.14 Synchronize the Julia set to the Mandelbrot set:
Mn+1 = M2
n + c
Sn+1 = Sa
n + b + un

44
2
Synchronization of Chaotic Systems
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
Fig. 2.15 Julia fractal
Selecting the parameters a = 2, b = −0.61803 and c = M0 with the dynamic control
law un = 0.5 M2
n −S2
n + M0 + 0.61803 the attractors of both sets evolve as is shown in
Fig. 2.16.
The right column contains the attractors of the master at 3, 6, 9 and 25 iterations, the
left column contains the attractors of the slave at 3, 6, 9 and 25 iterations, As expected the
synchronization is better as the number of iterations increase, the synchronization error
decreases every iteration, causing that the slave resembles the master more accurately in
the second, third and fourth image rather than the ﬁrst one, then it is possible to say that
the convergence of the fractals is achieved, the basin of attraction of the slave closely
resembles the master’s basin of attraction and the bounded values converge as iterations
increase.
Exercise 2.12 Draw the Julia set deﬁned by:
Zn+1 = z5
n + 0.544

2.4
Fractals and Synchronization
45
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
100
300
400
500
600
700
800
900
200
Fig. 2.16 Synchronization of the mandelbrot and julia sets

46
2
Synchronization of Chaotic Systems
Exercise 2.13 Use the next Julia set as master
Mn+1 = M3
n + 0.4
and synchronize it to the slave Julia set:
Sn+1 = S4
n + 0.484
References
1. Layek, G. C. (2015). An introduction to dynamical systems and chaos (vol. 449). New Delhi:
Springer.
2. Argyris, J. H., Faust, G., Haase, M., & Friedrich, R. (2015). An exploration of dynamical systems
and chaos: Completely revised and enlarged (2nd edn.). Berlin: Springer.
3. Devaney, R. L. (2018). A ﬁrst course in chaotic dynamical systems: Theory and experiment. Boca
Raton: CRC Press.
4. Zeitz, M. (1987). The extended Luenberger observer for nonlinear systems. Systems & Control
Letters, 9(2), 149–156.
5. Barnsley, M. F. (2014). Fractals everywhere. Cambridge: Academic Press.
6. Martínez-Guerra, R., Martínez-Fuentes, O., & Montesinos-García, J. J. (2019). Algebraic and
differential methods for nonlinear control theory: Elements of commutative algebra and algebraic
geometry. Berlin: Springer.

3
Stream Cyphers and Block Cyphers
Abstract
This chapter is about stream cyphers and block cyphers based in synchronization using
the Luenberger observer.
3.1
Message and Data Carrier Signals
The purpose of encryption is making certain information accessible to only a desired group
of people by modifying the message, or “hiding” it, so it is not possible to understand it
without permission, the information that is desired to be transmitted is called plaintext,
cleartext or message, the process of modifying the plaintext so it is not understandable is
called encryption, the resulting modiﬁed message from the encryption is called ciphertext
and the process of deciphering the ciphertext is called decryption, all these processes must
depend on an encryption key that is usually a large set of values which can be randomly
generated [1,2]. This relation is exempliﬁed next:
Consider a message S with the key K, the encryption function E is:
E (S, K) = C
The encryption function yields a ciphertext C that has the same size and type of data
that the plaintext, when this ciphertext and the key are the input of the decryption function
D:
D (C, K) = S
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_3
47

48
3
Stream Cyphers and Block Cyphers
The result is the plaintext S, the two functions have the property
D (E (S, K) , K) = S
There are also algorithms that have different keys for encryption and decryption, they
are called asymmetric or public key encryption, but the focus of this book is to be
symmetric key algorithms that are the ones where the same key is used for encryption
and decryption.
Messages can be any type of data; video, audio, images, text or computer ﬁles, there
are many forms of representation of this data, even a single type can have varying and very
different type of representation.
For example an image in jpg format is composed of real numbers describing the
luminance that is a grayscale representation of the image, and the chrominance which
is the difference between the red color to the blue and green; then, there is the RGB
representation that contains the intensity of the colors red, green and blue using only 8
bit integer numbers, another good example is text, that can easily be represented into and
8 bit ASCII variant. hence it is more efﬁcient to work with these representations for the
purpose of encryption.
3.1.1
Decimal and Binary Numbers
All types of data representations can be expressed as binary code, binary only contains two
digits or bits 0 and 1, it is preferred in digital systems as it can be easily expressed with
voltage with a certain level corresponding to 0 and another to 1, this simpliﬁes its usage
in processors and allows to make fairly complex operations even in low powered micro
controllers.
The decimal system is represented by ten digits 0 to 9, each digit determines a quantity,
the decimal system can represent non integer numbers by using a point to separate the
integer part to the non integer, every number can be represented by a sum of base 10
numbers as follows:
Example 3.1 The integer number 65 can be written as a sum of base 10 numbers:
65 =

6 × 102
+

5 × 101
= 60 + 5
Example 3.2 The number 32.01 is represented by the sum of base 10 numbers :
32.01 =

3 × 102
+

2 × 101
+

0 × 10−1
+

1 × 10−2
= 30 + 2 + 0 + 0.01

3.1
Message and Data Carrier Signals
49
Exercise 3.1 Represent the decimal number 256 as a sum of base 10 numbers.
Exercise 3.2 Represent the decimal number 8.456 as a sum of base 10 numbers.
Binary numbers are another way of representing magnitudes, and a much simpler than
decimal since it only needs two digits or bits being them 0 and 1, having only two digits
limits the quantity that can be represented, the maximum decimal number that can be
represented with an binary is given by the next expression:
DecimalMax = 2n −1
Where n is the number of binary bits.
Example 3.3 A 3 bit binary can quantify a decimal up to 7:
23 −1 = 7
Example 3.4 A 8 bit binary can quantify a decimal up to 255:
28 −1 = 255
Exercise 3.3 Determine the maximum decimal that can be represented with 16 binary
bits.
Exercise 3.4 Determine the maximum decimal that can be represented with 32 binary
bits.
The Table 3.1 gives a comparison of decimal and binary numbers:
Binary numbers are useful to comprehend operations that are very common in
cryptography, for example the bitwise XOR logical operation denoted by ⊕:
Deﬁnition 3.1 The bitwise XOR operation between to binary digits is deﬁned in Table 3.2
The property of bitwise XOR that makes it very useful in cryptography is shown in the
next equations:
A ⊕B = C
A ⊕C = B
B ⊕C = A

50
3
Stream Cyphers and Block Cyphers
Table 3.1 Decimal vs binary
numbers
Decimal
Binary
0
0
1
1
2
10
3
11
4
100
5
101
6
110
7
111
8
1000
9
1001
10
1010
11
1011
12
1100
13
1101
14
1110
15
1111
Table 3.2 XOR operation
A B A ⊕B
0
0
0
1
0
1
0
1
1
1
1
0
Table 3.3 Operation one’s
complement
Digit One’s complement
0
1
1
0
Then A ⊕B ⊕A = B. The modulo operation is often used in encryption algorithms, to
calculate it ﬁrst it is necessary to introduce the one’s complement and two’s complement
of a binary number.
Deﬁnition 3.2 The operation one’s complement for a binary number is done by inverting
the bits of the number as shown in Table 3.3
Example 3.5 Obtain the one’s complement for the binary number 1010:
1010 →0101

3.1
Message and Data Carrier Signals
51
Example 3.6 Obtain the one’s complement for the binary number 1001 1001:
10011001 →01100110
Deﬁnition 3.3 The operation two’s complement for a binary number is obtained by
adding 1 to the less signiﬁcant bit of the result of the one’s complement operation.
Example 3.7 Obtain the two’s complement for the binary number 1010: from previous
examples the one’s complements is 0101 then the twos complement is:
0101
+
1
0110
Example 3.8 Obtain the two’s complement for the binary number 1001 1001: the one’s
complement for the expression is 01100110 so:
01100110
+
1
01100111
Example 3.9 Obtain the two’s complement for 0110 and 01100111: the one’s complement
for each number is 1001 and 10011000 respectively, then:
1001
+
1
1010
And:
10011000
+
1
10011001
From the previous example it is possible to see that the operation has the same property
as the bitwise XOR operation, denote two’s complement as TC(·) then:
T C (A) = B
T C (B) = A
T C [T C (A)] = A

52
3
Stream Cyphers and Block Cyphers
These two operations can be used to obtain the modulo 2N operation, the modulo
operation returns the remainder after a division, notice that for to integers A, B, N the
modulo operation behaves as A + B mod 2N = A +

j + 2N
mod 2N, this operation
is also very popular in encryption algorithms. when used with negative values it has the
same property of the bitwise XOR and two’s complement.
Example 3.10 The result of the operation −86 mod 256: the binary representation of 255
and −86 is 1111 1111 and −0101 0110 respectively, then adding:
1111 1111
−0101 0110
1010 1001
Considering 1010 1001 the result of one’s complement and applying two’s comple-
ment:
1010 1001
+
1
1010 1010
Which is the result of the modulo operation 1010 1010 = 170 and −86 mod 256 =
170
Example 3.11 The result of the operation 170 mod −256 : the binary representation of
−255 and 170 is −1111 1111 and 1010 1010 respectively, then by adding:
−1111 1111
1010 1010
−
0101 0101
Considering 0101 0101 the result of one’s complement and applying two’s comple-
ment:
−0101 0101
−
1
−
0101 0110
Which is the original value −0101 0110 = −86. This process is more complex than
the bitwise XOR therefore it needs more computing power, though it is preferred by many
authors.

3.1
Message and Data Carrier Signals
53
3.1.2
Binary to Decimal and Decimal to Binary Conversions
As stated previously many forms of messages are made of real numbers integers or
decimal, but in order to encrypt them it is necessary to make operations to its binary
equivalent and then transform them back into the corresponding type of decimal to make
the ciphertext. The conversion from binary to decimal is a very straightforward process.
the conversion is done by multiplying each binary digit by its weight and then adding the
result, the next examples show the process in a simple way:
Example 3.12 Calculate the decimal equivalent of the binary 1010:
Binary : 1 0 1 0
weight : 23 22 21 20
decimal =

1 × 23
+

0 × 22
+

1 × 21
+

0 × 20
= 8 + 0 + 2 + 0
= 10
Example 3.13 The decimal equivalent of the binary 1010110:
Binary : 1 0 1 0 1 1 0
weight : 26 25 24 23 22 21 20
decimal =

1 × 26
+

0 × 25
+

1 × 24
+

0 × 23
+

1 × 22
+

1 × 21
+

0 × 20
= 64 + 0 + 16 + 0 + 4 + 2 + 0
= 86
Exercise 3.5 Obtain the decimal equivalent of the binary 1101 0110.
Exercise 3.6 Obtain the decimal equivalent of the binary 1101.0110.
Conversion from binary to integer is a little more challenging so two methods are given,
the ﬁrst is the sum of weights, where the decimal number is expressed as a sum of the
largest possible multiples of two, the multiples are then transformed into its equivalent
binary weight, the process is exempliﬁed next:

54
3
Stream Cyphers and Block Cyphers
Example 3.14 The binary equivalent of the decimal 11:
11 = 8 + 2 + 1
= 23 + 21 + 20
=

1 × 23
+

0 × 22
+

1 × 21
+

1 × 20
Binary = 1011
Example 3.15 The binary equivalent of the decimal 23:
23 = 16 + 4 + 2 + 1
= 24 + 22 + 21 + 20
=

1 × 24
+

0 × 23
+

1 × 22
+

1 × 21
+

1 × 20
Binary = 10111
Exercise 3.7 Calculate the binary equivalent of the decimal 33.
Exercise 3.8 Obtain the binary equivalent of the decimal 86.
The other method is a succession of divisions by 2, the integer is divided by 2, the
remainder is the bit and the result is divided in the next iteration, the process is repeated
until the quotient of the division is 0, the most signiﬁcant bit is the last resulting bit from
the division and the least signiﬁcant bit is the ﬁrst, the next example illustrates the process
Example 3.16 Compute the binary equivalent of the decimal 11 with the division succes-
sion:
11
2 = 5 remainder : 1
5
2 = 2 remainder : 1
2
2 = 1 remainder : 0
1
2 = 0 remainder : 1
Binary
=
1011

3.1
Message and Data Carrier Signals
55
Example 3.17 Tthe binary equivalent of the decimal 23 with the division succession:
23
2 = 11 remainder : 1
11
2 = 5 remainder : 1
5
2 = 2 remainder : 1
2
2 = 1 remainder : 0
1
2 = 0 remainder : 1
Binary
=
10111
Exercise 3.9 Compute the binary equivalent of the decimal 33 with the division succes-
sion.
Exercise 3.10 Calculate the binary equivalent of the decimal 86 with the division
succession.
This two methods are the most popular because they are simple and effective, the
conversion of binary to decimal and decimal to binary is widely required when designing
encryption algorithms.
3.1.3
Representation of Plaintext with 8 Integers
For ease of visualization in the book, in the following all messages are made of 8 bit integer
data, the messages are to be restricted to text in 8 bit ASCII or images in RGB format, the
8 bit integer encompasses integer numbers with values ranging from 0 to 255 and allow to
do operations with them with ease and low computing power consumption.
The text messages are structured as a vector of size 1 × n consisting of 8 bit integers,
each element of the vector is a character, an example of this is given next:
Example 3.18 Convert the plaintext “hello” into a 8 bit integer vector:
Plaintext
vector
:
:
h
e
l
l
o
104 101 108 108 111

56
3
Stream Cyphers and Block Cyphers
the corresponding binary code is:
binary :
⎡
⎢⎢⎢⎢⎢⎣
01101000
01100101
01101100
01101100
01101111
⎤
⎥⎥⎥⎥⎥⎦
T
Example 3.19 Convert the plaintext “page9” into a 8 bit integer vector:
Plaintext
vector
:
:
p
a
g
e
9
112 97 103 101 57
the corresponding binary code is:
binary :
⎡
⎢⎢⎢⎢⎢⎣
01110000
01100001
01100111
01100101
00111001
⎤
⎥⎥⎥⎥⎥⎦
T
Exercise 3.11 Convert the plaintext “sun” to a 8 bit integer vector and its binary
equivalent.
Exercise 3.12 Convert the plaintext “Monday” to a 8 bit integer vector and its binary
equivalent.
This representation makes easy to do logic operations with the plaintext and any other set
of values of the same type:
Example 3.20 The result of the bitwise XOR operation between the plaintext “hello” and
the phrase “12345”:
Plaintext
V ector
Phrase
V ector
:
:
:
;
h
e
l
l
o
104 101 108 108 111
1
2
3
4
5
49
50 51 52
53

3.1
Message and Data Carrier Signals
57
the operation is:
⎡
⎢⎢⎢⎢⎢⎣
1101000
1100101
1101100
1101100
1101111
⎤
⎥⎥⎥⎥⎥⎦
T
⊕
⎡
⎢⎢⎢⎢⎢⎣
0110001
0110010
0110011
0110100
0110101
⎤
⎥⎥⎥⎥⎥⎦
T
=
⎡
⎢⎢⎢⎢⎢⎣
1011001
1010111
1011111
1011000
1011010
⎤
⎥⎥⎥⎥⎥⎦
⎡
⎢⎢⎢⎢⎢⎣
104
101
108
108
111
⎤
⎥⎥⎥⎥⎥⎦
T
⊕
⎡
⎢⎢⎢⎢⎢⎣
49
50
51
52
53
⎤
⎥⎥⎥⎥⎥⎦
T
=
⎡
⎢⎢⎢⎢⎢⎣
89
87
95
88
90
⎤
⎥⎥⎥⎥⎥⎦
T
The ASCII representation of the solution is “YW_XZ”.
Note that the plaintext was modiﬁed from its original form to be unreadable, this
is a very basic form of encrypting or hiding a message, so the resulting ciphertext is
“YW_XZ”, in this example the encryption is done by a simple bitwise XOR operation
using the key “12345” as the encryption value, then the cryptographic function is described
by:
E (a, b) = c
E (a, b) = a ⊕b
E ("hello", "12345") = "hello" ⊕"12345"
E ("hello", "12345") = “YW_XZ”
The encryption must have a way of decrypting the message or a decryption function
D(a, b), using the properties of the bitwise XOR allows the decryption function to be:
D (c, b) = c ⊕b
D (“YW_XZ”, "12345") = “YW_XZ” ⊕"12345"
D (“YW_XZ”, "12345") = ”hello

58
3
Stream Cyphers and Block Cyphers
This is shown in the next example:
Example 3.21 Decrypt the ciphertext “YW_XZ” with the key “12345” by doing the
bitwise XOR operation between them:
Ciphertext
V ector
key
V ector
:
:
:
;
Y
W
_
X
Z
104 101 108 108 111
1
2
3
4
5
89 87
95 88
90
The decryption function binary representation is:
⎡
⎢⎢⎢⎢⎢⎣
1011001
1010111
1011111
1011000
1011010
⎤
⎥⎥⎥⎥⎥⎦
T
⊕
⎡
⎢⎢⎢⎢⎢⎣
0110001
0110010
0110011
0110100
0110101
⎤
⎥⎥⎥⎥⎥⎦
T
=
⎡
⎢⎢⎢⎢⎢⎣
1101000
1100101
1101100
1101100
1101111
⎤
⎥⎥⎥⎥⎥⎦
T
The 8 bit integer operation is:
⎡
⎢⎢⎢⎢⎢⎣
89
87
95
88
90
⎤
⎥⎥⎥⎥⎥⎦
T
⊕
⎡
⎢⎢⎢⎢⎢⎣
49
50
51
52
53
⎤
⎥⎥⎥⎥⎥⎦
T
=
⎡
⎢⎢⎢⎢⎢⎣
104
101
108
108
111
⎤
⎥⎥⎥⎥⎥⎦
T
The message is correctly decrypted making the plaintext “hello” readable.
Exercise 3.13 Using the bitwise XOR operation, encrypt the plaintext “page9” with the
key “67890”.
Exercise 3.14 Using the bitwise XOR operation, decrypt the resulting ciphertext from the
previous exercise.
3.1.4
Representation of Plain Images with 8 Bit Integers
Images can also be represented with 8 bit integers, digital images are a set of pixels
arranged to form the image, each pixel contains information regarding intensity of color,
luminance, chrominance or many other values depending on the image format, the contents
and interpretation of the numerical value of the pixel also changes depending on the

3.1
Message and Data Carrier Signals
59
Fig. 3.1 Grayscale image
format, but generally, images can be seen as a matrix of size n × m where each element
of the matrix is a pixel and contains the numerical value of the said pixel corresponding to
the format of the image. Consider the 8 bit integer 4 × 4 matrix:
Im =
⎡
⎢⎢⎢⎣
0
0
64
64
0
0
64
64
128 128 255 255
128 128 255 255
⎤
⎥⎥⎥⎦
To form a grayscale image with the matrix each one of its elements its considered the
intensity of the white with respect to the black, then the value 0 is black and 255 is white,
the resulting grayscale image has 32 pixels and its visual interpretation can be seen in
Fig. 3.1.
Images can also be subjected to operations the same way that text messages, the
difference is that this time the operation is done with another matrix containing the same
type of data and having the same size, to exemplify this consider the 32 pixel grayscale
image in the next example:
Example 3.22 Do a bitwise XOR operation between the grayscale image and the matrix
K:
K =
⎡
⎢⎢⎢⎣
50 50 100 100
50 50 100 100
150 150 200 200
150 150 200 200
⎤
⎥⎥⎥⎦

60
3
Stream Cyphers and Block Cyphers
Fig. 3.2 Grayscale operation
image
The operation is done element wise, then it is composed of 32 different bitwise XOR
operations:
Ci = Im ⊕K
=
⎡
⎢⎢⎢⎣
0
0
64
64
0
0
64
64
128 128 255 255
128 128 255 255
⎤
⎥⎥⎥⎦⊕
⎡
⎢⎢⎢⎣
50
50 100 100
50
50 100 100
150 150 200 200
150 150 200 200
⎤
⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎣
50 50 36 36
50 50 36 36
22 22 55 55
22 22 55 55
⎤
⎥⎥⎥⎦
The resulting image is shown in Fig. 3.2.
The image has been considerably modiﬁed, this is because Images can be encrypted the
same way text messages are with the bitwise XOR operation, the process of hiding images
is very similar, the encryption function receives a plain image and the key, then it returns
a cipher image. There is a decryption process related to the encryption, it is done the same
way as in the text, the bitwise XOR operation is done element wise between the cipher
image and the key, the encryption process is then:
E (Im, K) = Ci
E (Im, K) = Imn,m ⊕Kn,m

3.1
Message and Data Carrier Signals
61
Where Imn.m is the individual m,n pixel of the image and the Kn,m is the corresponding
element of the key, the decryption process is similar:
D (Ci, K) = Cin,m ⊕Kn,m
D (Ci, K) = Imn,m
Once the operation is done the resulting image is the original plain image.
Example 3.23 Decrypt the cipher image of the previous example by doing the bitwise
XOR operation between the cipher image Ci and the Key K:
Im = Ci ⊕K
=
⎡
⎢⎢⎢⎣
50 50 36 36
50 50 36 36
22 22 55 55
22 22 55 55
⎤
⎥⎥⎥⎦⊕
⎡
⎢⎢⎢⎣
50 50 100 100
50 50 100 100
150 150 200 200
150 150 200 200
⎤
⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎣
0
0
64
64
0
0
64
64
128 128 255 255
128 128 255 255
⎤
⎥⎥⎥⎦
The resulting image is shown in Fig. 3.3.
Fig. 3.3 Grayscale image after
the decryption process is
successful

62
3
Stream Cyphers and Block Cyphers
The decryption is successful, note that if the encryption key is changed the decrypted
image is not the plain image:
Example 3.24 Decrypt the cipher image of the previous example by doing the bitwise
XOR operation between the cipher image Ci and the erroneous key K2:
K =
⎡
⎢⎢⎢⎣
200 200 150 150
200 200 150 150
100 100 50 50
100 100 50 50
⎤
⎥⎥⎥⎦
The decryption with the wrong key is then:
Im = Ci ⊕K2
=
⎡
⎢⎢⎢⎣
50 50 36 36
50 50 36 36
22 22 55 55
22 22 55 55
⎤
⎥⎥⎥⎦⊕
⎡
⎢⎢⎢⎣
200 200 150 150
200 200 150 150
100 100 50
50
100 100 50
50
⎤
⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎣
250 250 178 178
250 250 178 178
114 114 5
5
114 114 5
5
⎤
⎥⎥⎥⎦
The decryption is not successful due to the erroneous key and the message remains
hidden as it is shown in Fig. 3.4
What has been presented is the basic idea of encryption, if the key is correct the
ciphertext is correctly decrypted and the plaintext is the accessible to the user, if the key is
not correct the ciphertext is not properly decrypted and the plaintext remains hidden.
Color images have many formats, one of the oldest and most well known is RGB, it is
based on creating three images corresponding to the red, green and blue respectively, when
the images are displayed together a color image is formed, the RGB format is based on the
ability to create a wide range of colors using the three primary colors. A common form
of representing images of size n × m pixels in the RGB format is to create tree matrices
of size n × m, each matrix contains the intensity of a primary color, then the image is
composed of three matrices of size n × m, where an element of the matrix contains the
intensity of its corresponding primary color consisting in the range of 8 bit integer values
from 0 to 255, the corresponding pixel of the color image is made of the combination of
the 3 pixels of the red, green and blue matrices, an intensity of color 0 is displayed as black

3.1
Message and Data Carrier Signals
63
Fig. 3.4 Grayscale image after
the decryption process fails
and a intensity of 255 is displayed as white, the next example shows how the structure of
an RGB image is done:
Example 3.25 Consider the next 8 bit integer matrices of size 2 × 2 corresponding to the
primary color components red R, green G and blue B:
R =

255 255
0
0

, G =

255 0
255 0

, B =

255 0
0
255

They are to combined into an RGB image of 2 × 2 pixels, the image is then presented
as an array of elements of size 2 ×2 ×3 being Im = [R, G, B], the image has four pixels:
Im =

1 2
3 4

Where the pixel one is white with color components R=255, G=255 and B=255. The
second pixel is red with components R=255, G=0 and B=0. The third pixel green with
R=0, G=255 and B=0. The fourth is blue with components R=0, G=0 and B=255. The
visual representation of this image is shown in Fig. 3.5.
The example may not show the full capacity of RGB, but it can be used to efﬁciently
represent large and colorful pictures of various resolutions.
This RGB format is very practical for the purpose of encryption, once again, being
it composed by 8 bit integer data makes very easy to make operations with the color
components, the bitwise XOR once again is one of the favorite functions for encryption,
the structure of the encryption is the same as in the case of the grayscale image, but this

64
3
Stream Cyphers and Block Cyphers
50
100
150
200
250
300
350
400
450
500
50
100
150
200
250
300
350
400
450
500
Fig. 3.5 Color image with RGB pixels: pixel 1 [ 255,255,255], pixel 2 [ 255,0,0], pixel 3 [0, 255,0]
and pixel 4 [ 0 , 0 ,255]
time the encryption key must be larger to provide enough values to modify every pixel of
the plain image.
Example 3.26 The following encryption Key=[20,40,60,80,100,120,140,160,180,200,
220,240] is to be used to encrypt the 4 pixel image of the previous example, the key is
rearranged into three matrices denoted Ki:
K1 =

20 40
60 80

, K2 =

100 120
140 160

, K3 =

180 200
220 240

The encryption is the same, the cryptographic function is:
E (Im, K) = Ci
E (Im, K) = Im ⊕K

3.1
Message and Data Carrier Signals
65
Since the image has three color components, each section of the key denoted by Ki is
used for one of the components:
ER (R, K1) = R ⊕K1
EG (G, K1) = G ⊕K2
EB (B, K1) = B ⊕K3
The bitwise XOR operation is again done element wise, the numeric values are:
CR =

255 255
0
0

⊕

20 40
60 80

,
CR =

235 215
60 80

CG =

255 0
255 0

⊕

100 120
140 160

CG =

155 120
115 160

CB =

255 0
0
255

⊕

180 200
220 240

CB =

75 200
220 15

The cipher image is formed by the combination of the encrypted color components
CIm = [CR, CG, CB], the visual representation of the encrypted image is observed in
Fig. 3.6.
The cipher image does not resemble the same colors as the plain image, although they
bear the same size and structure but different values. It is possible to decrypt cipher image
with the function:
D (Cim, K) = Cim ⊕K
D (Cim, K) = Im

66
3
Stream Cyphers and Block Cyphers
50
100
150
200
250
300
350
400
450
500
50
100
150
200
250
300
350
400
450
500
Fig. 3.6 Image representation with encrypted colors
Example 3.27 Using the decryption function with the key yields:
R =

235 215
60 80

⊕

20 40
60 80

R =

255 255
0
0

G =

155 120
115 160

⊕

100 120
140 160

G =

255 0
255 0

B =

75 200
220 15

⊕

180 200
220 240

B =

255 0
0
255


3.1
Message and Data Carrier Signals
67
50
100
150
200
250
300
350
400
450
500
50
100
150
200
250
300
350
400
450
500
Fig. 3.7 Original color image after the decryption process
The decryption process is successful yielding the original plain image, shown in Fig. 3.7
If the image is decrypted with a wrong key the decryption process will create a different
plain image than the one that was originally used.
Example 3.28 The cipher image is decrypted with the key K = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12], the key is arranged into the matrices:
K1 =

1 2
3 4

, K2 =

5 6
7 8

, K3 =

9 10
11 12

And the decryption process yields the plain image:
R = CR ⊕K1
=

235 215
60 80

⊕

1 2
3 4

=

234 213
63 84


68
3
Stream Cyphers and Block Cyphers
G = CG ⊕K2
=

155 120
115 160

⊕

5 6
7 8

=

158 126
116 168

B = CB ⊕K3
=

75 200
220 15

⊕

9 10
11 12

=

66 194
215 3

With the decrypted cipher image shown in Fig. 3.8
50
100
150
200
250
300
350
400
450
500
50
100
150
200
250
300
350
400
450
500
Fig. 3.8 Plain image after the decryption process fails

3.1
Message and Data Carrier Signals
69
The decryption is unsuccessful and the plain image does not resemble the original
message, this basic form of encryption shows how the modiﬁcation of an image looks
when encryption is done, also illustrates the results of failure to decrypt.
Exercise 3.15 Encrypt a 2 × 2 pixel color image with colors black (0,0,0), yellow
(255,255,0), purple (128,0,128) and orange (255,165,0) using the key K
=
[15, 25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125].
Exercise 3.16 Decrypt the cipher image from the previous exercise.
3.1.5
Data Carrier Signal
Many results in secure communications based on non linear control are stream ciphers,
this encryption method usually needs to convert any message into a stream of values that
are combined with another signal to hide the message, one of the most simple ways of
making a signal that contains a message is to rearrange the ciphertext into a vector Vm, the
values of the elements of the message vector indicate the amplitude that the signal takes at
that given moment. Then create a time vector of the same size Vt, the time vector contains
the moment when each element of the message vector is transmitted, every element of the
time vector contains a numeric value in seconds. An alternative is to ﬁx a time period and
only specify the initial time for the message to be transmitted. The structure of the message
and its corresponding time vector is:
Vm = S0 S1 S2 · · · Sn
Vt = t0 t1 t2 · · · tn
Where S0 is the ﬁrst element of the message, Sn is the last element of the message, t0
is the initial time and tn is the ﬁnal time of the transmission.
Example 3.29 The plaintext “hello” is to be converted into a data carrier signal, since the
message is already in a vector form it is only necessary to associate a time vector:
plaintext : h e l l o
Vm =

104 101 108 108 111

Vt =

1 2 3 4 5

The initial time of the vector is t0 = 1 and the transmission of the message ﬁnishes at
t4 = 5, the resulting signal is shown in Fig. 3.9

70
3
Stream Cyphers and Block Cyphers
0
1
2
3
4
5
6
7
98
100
102
104
106
108
110
112
114
TIme (S)
Message
Data signal
Fig. 3.9 Ciphertext data signal
The received signal is then converted into a vector recovering the original message
“hello”.
Images can be turned into data carrier signals the same way, but with them it is necessary
to transform the R,G and B matrices into the vector Vm, also the transmission time is
considerably larger than the text messages.
Example 3.30 Using the image from Fig. 3.5 the vector is arranged as follows:
Vt =

VR VG VB

Where
VR =

255 255 0 0

VG =

255 0 255 0

VB =

255 0 0 255


3.1
Message and Data Carrier Signals
71
Fig. 3.10 Cipher image signal
The time vector is:
vt =

1 2 3 · · · 12

The message is transmitted the same way, with the data carrier signal commencing at
time t0 = 1 seconds and ending at t11 = 12 seconds (see Fig. 3.10).
The data carrier signal is considerably larger but also, the message contains more
information.
Exercise 3.17 Convert the ciphertext “YW_XZ” into a signal and transmit it with initial
time t0 = 1 with a time period of 0.1 s.
Exercise 3.18 Convert the cipher image of Figs. 3.4, 3.5, and 3.6 into a signal and transmit
it with initial time t0 = 0.2 and period of 0.4 s.
There are other variations of message conversion to signal, another very popular variant
is binary signals that are made of binary values, this method is preferred in many stream

72
3
Stream Cyphers and Block Cyphers
cyphers for its simplicity and resilience to noise, but it has the setback that either the
needed transmission time is multiplied by eight or the signal period is decreased by a
factor of 8, requiring faster data acquisition, this method will be discussed in detail in
following chapters.
3.2
Stream Ciphers and State Observers
Stream ciphers are the most common cipher found in the literature about secure com-
munications based on non-linear control as their implementation with synchronization is
straight forward, since operate with relative low computer complexity and at high speeds
they are ideal for the encryption of large messages, they work by encrypting plaintext
one element at a time, the element size can range from a bit to integers, decimals or any
other type of data, depending on the composition of the plaintext. The most simple form
of stream cipher is called keystream generator or running key generator, the idea is to
combine a plaintext signal with the values of the keystream formed by pseudorandom
numbers, this keystream is formed by an algorithm, usually dependent on the key. The
combination of the plaintext with the keystream is usually done with a bitwise XOR
operation. Let the plaintext bits be p1, p2, . . . , pi and the keystream bits ks1, ks2, . . . , ksi,
the ciphertext for the plaintext is
ci = pi ⊕ksi
The decryption process is similar, the bitwise XOR properties make possible that a ⊕
b = c then c ⊕a = b and c ⊕b = a, by making use of this property, the decryption
needs only to apply bitwise XOR to the known keystream and the ciphertext to recover the
plaintext:
pi = ksi ⊕ci
The image in Fig. 3.11 shows the process.
Other type of very popular stream cipher are the self-synchronizing stream ciphers
or ciphertext auto key (CTAK), the idea of this stream cipher is to increase the security
Fig. 3.11 Representation of the stream cipher process

3.2
Stream Ciphers and State Observers
73
Fig. 3.12 Representation of the ciphertext auto key (CTAK) process
of the common stream cipher by making the current keystream depend on the previous
ciphertext, the encryption and decryption processes are identical to the previous stream
cipher, the only difference lies in the generation of the keystream, that now depends on the
ciphertext and the key (see Fig. 3.12).
A problem of the CTAK is the possibility of error propagation, if an erroneous
ciphertext bit is used in the decryption process it generates an erroneous decryption and,
depending on how the keystream generator works and how is implemented, the error could
propagate to other ciphertext bits decryption, damaging the decrypted data. In both cases
a very important component of the stream cipher is the pseudorandom numbers used as
keystream, given that the random generator is reliable, the algorithm can conﬁdently use it,
but if it has problems, these will carry on the encryption algorithm and make it unreliable.
3.2.1
Pseudorandom Number Generator
An important component for any cipher is a pseudorandom number generator (PRNG),
this generator creates vectors of pseudorandom numbers that are used as input for the
permutation and mixing operations, a simple to implement PRNG is called Blum Blum
Shub [3], it was introduced in 1986 by Lenore Blum, Manuel Blum and Michael Shub, it
is easy to implement and has low computational complexity, it is described by:
rn+1 = r2
n mod pq
Where rn is a pseudorandom number and p and q are large prime numbers,
Example 3.31 Using r0 = 54, p = 11, q = 11 and n = 10 create 10 pseudorandom
numbers with the Blum Blum Shub PRNG (see Table 3.4).
Exercise 3.19 Using r0 = 5, p = 11, q = 19 and n = 10 create 10 pseudorandom
numbers with the Blum Blum Shub PRNG.
Exercise 3.20 Using r0 = 123456, p = 11, q = 19 and n = 10 create 10 pseudorandom
numbers with the Blum Blum Shub PRNG.

74
3
Stream Cyphers and Block Cyphers
Table 3.4 Pseudorandom
numbers creation with the
Blum Blum Shub PRNG
n
rn+1
rn
1
542 mod 121
12
2
122 mod 121
23
3
232 mod 121
45
4
452 mod 121
89
5
892 mod 121
56
6
562 mod 121
111
7
1112 mod 121
100
8
1002 mod 121
78
9
782 mod 121
34
10
342 mod 121
67
The synchronization of two chaotic systems can be used for generating random
numbers by including the chaotic states into the dynamic of the Blum Blum Shub PRNG.
The process is as follows:
1. Form the initial conditions for the chaotic oscillator from the key, every state needs a
different key element which is normalized between 0 and 1, a value that is easily scaled
into the needed range that falls within the chaotic attractor:
x1 (0) = x1 (0) x1 (0)
k1
99999, x2 (0) =
k2
99999, . . . , xn (0) =
kn
99999
2. Generate a long trajectory then obtain as many samples as pseudorandom numbers are
needed, starting at time t0k and period ωk that depend on an element of the key:
t0k = 5 +
k3
99999
ωk =
k4
99999
Check the parity of another element of the key k3 + k4 to determine if the period wk
is in milliseconds or microseconds, the starting t0k time is recommended to remain in
seconds. The samples are then stored into a vector Vc =

Vc1 Vc2 · · · Vcn

.
3. Normalize the vector VC into values between 0 and 1, the new normalized value of Vci
is computed by:
Vci =
Vci −min (Vc)
max (Vc) −min (Vc)

3.2
Stream Ciphers and State Observers
75
Then the vector is transformed into a 16 bit integer vector:
Vc16 = round(65535Vc)
4. Apply prime factorization to an element Vc16i, select the two largest prime numbers and
assign them to p and q, if the element is 0 or 1 use 11 and 19 instead respectively, a key
element k5 determines de number of iterations for the Blum Blum Shub PRNG, ﬁnally
the value Vc16i is used as the starting value r0 for the PRNG and store the resulting
number into the vector Vr.
5. Normalize the vector Vr between 0 and 1:
Vri =
Vri −min (Vr)
max (Vr) −min (Vr)
Example 3.32 A set of 10 pseudorandom numbers is generated with the key Key =
12345 −67891 −01112 −13141 −51617 and the Dufﬁng oscillator:
˙x1 = x2
˙x2 = −ax2 −bx1 −cx3
1 + d cos ωts
y = x1
With the values a = 0.2, b = −1, c = 1, d = 0.3, ω = 1, g = 1/255.
1. The initial conditions are:
x1 (0) = 12345
99999
= 0.123451
x2 (0) = 67891
99999
= 678916
And make the trajectories shown in Fig. 3.13.
2. The value k3 + k4 = 01112 + 12131 = 14253 is odd, then initial time and the period
for the samples are:
t0k = 5 + 01112
99999
= 5.01112 s
ωk = 13141
99999
= 0.13141 µs

76
3
Stream Cyphers and Block Cyphers
0
0.5
1
1.5
2
–2
–1.5
–1
–0.5
–1.5
–1
–0.5
0
X2
X1
0.5
1
1.5
Fig. 3.13 State trajectories of the attractor for the Dufﬁng oscillator
3. The sampled values are:
Vc =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
0.4672
−1.3929
1.0474
1.3020
0.5362
0.7732
0.7294
−0.3233
0.4664
−0.9864
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
T
→Vc =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
0.6557
0.0357
0.8491
0.9340
0.6787
0.7577
0.7431
0.3922
0.6555
0.1712
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
T
→Vc16 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
42974
2340
55648
61209
44481
49658
48701
25705
42957
11219
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
T

3.2
Stream Ciphers and State Observers
77
4. -The prime factors of k5 are 71 × 727 = 51617 the values p=71 and q=727 along Vc16
are the input for the BBS PRNG which is iterated 51617 times making:
Vrn+1 = v2
r0 mod pq
Vr0 = Vc16i
Vr =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
28753
25005
50168
52113
12247
32097
29201
42356
46488
49458
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
T
Exercise 3.21 Obtain 10 pseudorandom numbers with the Van Der Pol oscillator
˙x1 = x2
˙x2 = μ

1 −x2
1

x2 −x1
y = x1
Exercise 3.22 Obtain 10 pseudorandom numbers with the Chua oscillator:
˙x = −y −z
˙y = x + ay
˙z = b + z (x −c)
3.2.2
The Luenberger Observer in a Stream Cipher
When implementing stream ciphers with state observers the chaotic system to be observed
takes the place of the key stream generator and the key stream is either the output or one of
the states, the plaintext is then scaled down to be better hidden and combined with the key
stream state by a sum. The decryption is done by the observer, it reconstructs the states and
with them the output or whatever trajectory was used as key stream, ﬁnally the decryption
is done by subtracting the estimated or reconstructed key stream obtaining the plaintext,

78
3
Stream Cyphers and Block Cyphers
the ﬁrst encryption with a Luenberger observer [4,5] is:
˙x = Ax + f (x) + kgs
y = Cx + gs
˙ˆx = Aˆx + f  ˆx + k y −ˆy
ˆy = C ˆx
ˆs = 1
g

y −ˆy

Where s is the plaintext, 0 < g < 1 is a scaling factor chosen to make the signal as
small as possible and Cx is key stream. It could be confusing to add the gain vector and
the message to the states of the chaotic system, but it is necessary for the proof of stability,
the Lyapunov function is chosen as:
V = eT Pe
The function’s derivative is:
˙V = ˙eT Pe + eT P ˙e
The derivative of the error function is expressed in terms of the states:
˙e = ˙x −˙ˆx
= Ax + f (x) + kgs −Aˆx −f

ˆx

−k

y −ˆy

= A

x −ˆx

+ f (x) −f

ˆx

+ kgs −k

y −ˆy

= Ae + f (x) −f  ˆx + kgs −k Cx + gs −C ˆx
= Ae + f (x) −f  ˆx −kC x −ˆx + kgs −kgs
= Ae + f (x) −f

ˆx

−kCe
When deﬁning φ (e) = f (x) −f

ˆx

with the same assumptions as in the proof of
stability of the Chap.2 Luenberger observer, the error derivative is:
˙e = Ae + φ (e) −kCe

3.2
Stream Ciphers and State Observers
79
The derivative of the Lyapunov function is:
˙V = [Ae + φ (e) −kCe]T Pe + eT P [Ae + φ (e) −kCe]
= eT AT Pe + φ (e)T Pe −(kCe)T Pe + eT PAe + eT Pφ (e) −eT PkCe
= eT AT Pe + φ (e)T Pe + eT PAe + eT Pφ (e) −(kCe)T Pe −eT PkCe
And if the assumptions are fulﬁlled
˙V ≤eT AT Pe + eT PAe + 2αeT Pe + eT e −(KCe)T Pe −eT PKCe
≤eT 
AT P + PA + 2αP + I

e −2eT PKCe
It yields to:
˙V < eT [Q −PKC] e
Showing that the states of the observer converge to the states of the chaotic system, in
consequence the error of the message also converges to zero:
es = s −ˆs
= s −1
g

y −ˆy

= s −1
g

Cx + gs −C ˆx

The asymptotic stability of the error makes possible, after some time, to assume that
x = ˆx making:
es = s −1
g (gs)
= s −s
es = 0
Proving that the error also converges to zero as the states of the observer converge to
the states of the chaotic system, hence the message is recovered.
Example 3.33 Encrypt an image by using the output of the Van der Pol oscillator as key
stream and decrypt with the Luenberger observer. The Van der Pol oscillator with the

80
3
Stream Cyphers and Block Cyphers
embedded message is:
˙x1 = x2 + k1gs
˙x2 = μ

1 −x2
1

x2 −x1 + k2gs
y = x1 + gs
A Luenberger observer for the system has the following state equations:
˙ˆx1 = ˆx2 + k1

y −ˆy

˙ˆx2 = μ

1 −ˆx2
1

ˆx2 −ˆx1 + k2

y −ˆy

y = ˆx1
ˆs = y −ˆy
Using the values μ = 5, g = 1/255, k1 = 3 and k2 = 6 the synchronization goes
as follows. The message is shown in Fig. 3.14. The states convergence is observed in
Fig. 3.14 Original message to be encrypted by the Van der Pol oscillator

3.2
Stream Ciphers and State Observers
81
0
0.5
1
Oscillator
Duffing oscillator convergence
Observer
1.5
–1.5
–1
–0.5
–1
–0.8
–0.6
–0.4
–0.2
0
0.2
0.4
0.6
0.8
1
X2
X1
Oscillator
Observer
Fig. 3.15 Van der Pol oscillator and Luenberger observer convergence for decryption of the
message
Fig. 3.15. The message recovery error is then shown in Fig. 3.16 and the encrypted image
is shown in Fig. 3.17. The decrypted image is shown in Fig. 3.18.
Example 3.34 Encrypt an image by using the output of Colpitts oscillator as key stream
and decrypt with the Luenberger observer. The message is shown in Fig. 3.19. The states
convergence is in Fig. 3.20. The message recovery error is shown in Fig. 3.21 and the
encrypted image is in Fig. 3.22. With the decrypted message shown in Fig. 3.23.
Example 3.35 Use the Rössler chaotic oscillator to encrypt another message. The message
is shown in Fig. 3.24. The states convergence is shown in Fig. 3.25. The message recovery
error is then shown in Fig. 3.26 and the encrypted image is shown in Fig. 3.27. With the
decrypted message observed in Fig. 3.28.
Exercise 3.23 Use the Chua oscillator to encrypt the plain image formed by the color
component matrices:
R =

255 255
0
0

, G =

255 0
255 0

, B =

255 0
0
255


82
3
Stream Cyphers and Block Cyphers
0
–0.3
–0.2
–0.1
0
0.1
0.2
0.3
0.4
0.5
1
2
3
4
5
6
7
8
9
10
Time
Error
Message recovery error
Fig. 3.16 Message recovery error by using the Van der Pol oscillator and the Luenberger observer
The second method for stream cipher encryption is to use as a key stream a state
different than the ones that form the output, the encryption is also done by adding the
plaintext to the key stream, the next equation represent the method:
˙x = Ax + f (x)
y = Cx
ys = C2x + gs
˙ˆx = Aˆx + f

ˆx

+ k

y −ˆy

ˆy = C ˆx
ˆs = 1
g

ys −C2 ˆx

Where ys is ciphertext, the vector C2 is used to select the state to use as key stream and
it must be different that C. The output y is used to synchronize the states, note that this
scheme does not change the proof of stability since the creation and transmission of the
ciphertext is not a disturbance nor an uncertainty.

3.3
Block Ciphers and Observers
83
500
1000
1500
2000
2500
3000
3000
2500
2000
1500
1000
500
3500
4000
Encrypted message
Fig. 3.17 Encrypted message by the output of the Van der Pol oscillator
3.3
Block Ciphers and Observers
Block ciphers are the other major type of cipher that employ symmetric keys, these ciphers
operate by applying an invariant cryptographic function to a set of elements of a plaintext
of ﬁxed size, these sets are named blocks and their size range from 32 bits to 64 bits
usually, hence the name block cipher.
There are many successful examples of these type of ciphers such as AES, DES or RC5
which are quite intricate, for simplicity the block cipher presented in this chapter is made
by some of the operations that compose those algorithms, in particular a permutation and
mixing operation will be done, the remaining operations depend, mostly, on search boxes
thus will not be included.
This time the Synchronization will not be directly involved into the encryption, it will
rather be used as a source for a pseudorandom number generator that creates data required
as input for the permutation and mixing operations.
The most important component of the algorithm is the key, as the security must depend
exclusively on it, also it is used in many of the operations of the algorithm, this chapter
will utilize user deﬁned keys of ﬁxed size, the most easy method is a numeric key divided

84
3
Stream Cyphers and Block Cyphers
500
1000
1500
2000
2500
3000
500
1000
1500
2000
2500
3000
3500
4000
Recovered message
Fig. 3.18 Recovered message by the Luenberger observer after the encryption of the Van der Pol
oscillator
into small key sections denoted kn, n ∈N:
Key = k1 −k2 −k3 −. . . −kn
An example key is:
Key = 12345 −12345 −12345 −. . . −12345
Keys usually contain ASCII values, but for simplicity of representation the keys in this
chapter are restrained to decimal numbers with key sections consisting of 5 digit numbers.
Stream ciphers convert plaintext into ciphertex, this operation is done at the rate of 1
bit at a time.

3.3
Block Ciphers and Observers
85
500
1000
1500
2000
2500
3000
500
1000
1500
2000
2500
3000
Message
Fig. 3.19 Original message to be encrypted by the Colpitts oscillator
3.3.1
Block Cipher
A master system generates a chaotic trajectory based on initial conditions that depend on
a key, the trajectories are used to generate a sequence of pseudorandom numbers that are
the input for a block cipher, for decryption a slave system reconstructs said trajectories
which are then used to reconstruct the random numbers, the set of reconstructed numbers
are used to do the needed operations for the decryption.
The encryption process on the plaintext block is composed of two operations:
1. Mixing: the plaintext block is combined with a set of pseudorandom numbers of the
same size of the block, the operation is made by a simple bitwise XOR operation:
CBi = PBi ⊕rni

86
3
Stream Cyphers and Block Cyphers
0
0
–1
–3
–2
–1
1
1
2
X2
X1
X3
2
3
3
4
–1.5
–1
–0.5
0
0.5
1
1.5
2
2.5
4
Colpitts oscillator convergence
Oscillator
Observer
Fig. 3.20 Colpitts oscillator and Luenberger observer convergence for decryption of the image
Where CB is a partially encrypted plaintext block, PB is the plaintext block and rn is
a pseudorandom number.
2. Permutation: A set of pseudorandom numbers of the size of a plaintext block is ordered
from smallest to largest, then the resulting message from the mixing step is reordered
in the same way, the process is exempliﬁed:
CB
Order =

a b c d e f g h
1 2 3 4 5 6 7 8

PRN
Order =

40 248 244 24 104 36 108 202
1
2
3
4
5
6
7
8

PRN
NewOrder =

24 36 40 104 108 202 244 248
4
6
1
5
7
8
3
2

CT B =

d f a e g h c b
4 6 1 5 7 8 3 2

The ciphertext block is then CT B.

3.3
Block Ciphers and Observers
87
0
0.1
–1
–0.8
–0.6
–0.4
–0.2
0
0.2
0.4
0.6
0.8
1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Time
Error
Message recovery error
Fig. 3.21 Message recovery error by using the Colpitts oscillator and the Luenberger observer
The decryption process needs for a state observer to synchronize to the oscillator
and with the key reconstruct the random numbers, then the encryption process is done
backwards:
1. Reorder the ciphertext block CT B according to the reconstructed pseudorandom
numbers
ˆ
PRN:
CT B =

d f a e g h c b
4 6 1 5 7 8 3 2

ˆ
PRN =

40 248 244 24 104 36 108 202
1
2
3
4
5
6
7
8

ˆ
PRN =

24 36 40 104 108 202 244 248
4 6
1
5
7
8
3
2

ˆ
CB = =

a b c d e f g h
1 2 3 4 5 6 7 8


88
3
Stream Cyphers and Block Cyphers
500
3000
2500
2000
1500
1000
500
1000
1500
2000
2500
3000
Encrypted message
Fig. 3.22 Encrypted message by the output of the Colpitts oscillator
2. With the key reconstruct the values rn and do the bitwise XOR operation to the
reconstructed partially encrypted ciphertext block
ˆ
CB:
PB =
ˆ
CB ⊕rn
Finally recovering the plaintext block:
Example 3.36 The plaintext “blockcipher ” is encrypted with the key Key = 12345 −
67891 −01112 −13141 −51617 and the dufﬁng oscillator:
˙x1 = x2
˙x2 = −ax2 −bx1 −cx3
1 + d cos ωts
y = x1

3.3
Block Ciphers and Observers
89
Fig. 3.23 Recovered message by the Luenberger observer after the encryption of the Colpitts
oscillator
With the values a = 0.2, b = −1, c = 1, d = 0.3, ω = 1, g = 1/255. the
pseudorandom numbers are arranged into to vectors, one for each step:
rn1 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
110
232
46
67
37
35
222
148
140
37
218
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
, rn2 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
230
241
125
125
86
230
94
28
199
99
62
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
The ﬁrst step produces the partially encrypted message that is then reordered by the
second vector producing the ciphertext C”.!2sL/0ç@.

90
3
Stream Cyphers and Block Cyphers
100
600
500
400
300
200
100
200
300
400
500
600
Message
Fig. 3.24 Original message to be encrypted by the Rössler oscillator
The previous message is decrypted with the Luenberger observer.
˙ˆx1 = ˆx2 + k1Ce
˙ˆx2 = −a ˆx2 −b ˆx1 −c ˆx3
1 + d cos ωts + k2Ce
ˆy = ˆx1
The reconstructed random numbers are:
ˆrn1 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
11
43
166
187
165
115
139
76
190
48
175
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
, ˆrn2 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
103
25
34
240
244
147
15
60
90
209
4
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦

3.3
Block Ciphers and Observers
91
X2
X1
X3
5
10
–5
0
5
10
15
20
25
0
–5
–10
–15
–10
–5
0
5
10
15
Rössler Oscillator convergence
Oscillator
Observer
Fig. 3.25 Rössler oscillator and Luenberger observer convergence for decryption on the image
The reordered ciphertext is: “blockcipher ”.
Exercise 3.24 Encrypt and decrypt the message “hello” using the Van der Pol oscillator.
Exercise 3.25 Encrypt and decrypt the message “random” using the Rössler oscillator.

92
3
Stream Cyphers and Block Cyphers
0
–0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
1
2
3
4
5
6
7
8
9
10
Time
Error
Message recovery error
Fig. 3.26 Message recovery error by using the Rössler oscillator and the Luenberger observer

3.3
Block Ciphers and Observers
93
100
600
500
400
300
200
100
200
300
400
500
600
Encrypted message
Fig. 3.27 Encrypted message by the output of the Rössler oscillator

94
3
Stream Cyphers and Block Cyphers
100
600
500
400
300
200
100
200
300
400
500
600
Recovered Message
Fig. 3.28 Recovered message by the Luenberger observer after the encryption of the Rössler
oscillator

References
95
References
1. Schneier, B. (2007). Applied cryptography: Protocols, algorithms, and source code. Hoboken:
Wiley.
2. Rueppel, R. A. (2012). Analysis and design of stream ciphers. Berlin: Springer.
3. Blum, L., Blum, M., & Shub, M. (1986). A simple unpredictable pseudorandom number generator.
SIAM Journal on Computing, 15(2), 364–383.
4. Chen, C. T. (1999). Linear system theory and design. Oxford: Oxford University Press.
5. Khalil, H. (1996). Nonlinear systems. Hoboken: Prentice Hall.

4
Liouvillian Systems and Cryptography
Abstract
In this chapter we show the use of a Liouvillian chaotic system on a master-slave
scheme for secure communications. Two forms of data encryption are presented, the
ﬁrst is a state observer based on the Super-Twisting algorithm, the second is a receiver
designed through the properties of Liouvillian systems, this last receiver does not suffer
from data loss due to synchronization error present on state observer based encryption.
To test the advantages of this encryption, images and text will be used as transmitted
data.
4.1
Introduction
The problem of synchronization in chaotic systems has received a great attention among
scientist in many ﬁelds due to its potential applications [1, 2], one of the most important
applications is secure communications where a predominant technique is chaotic masking
[3–6]; but also chaotic system alone have been used in secure communications [7, 8] and
as random number generator due to its properties [9], also chaotic systems are present
in other areas in the literature [10, 11]. In the last decade, many different approaches
related to chaos synchronization have been applied, where the goal is to design an
observer to achieve synchronization to nonlinear electric circuit oscillators [12]. For the
synchronization problem a chaotic system is considered, under master-slave paradigm,
where the transmitter is the master system and the receiver is the slave system, the objective
is to synchronize the complete response of the slave system to the master system by driving
the slave with a signal provided by the master [13].
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_4
97

98
4
Liouvillian Systems and Cryptography
Using state observers as receivers and message recovery systems has certain problems,
the most important one is that they do not allow the creation of encryption keys from initial
conditions, parameters or gains [14], as they are designed to converge to the transmitter
states regardless of small variations in its values, this makes that the security of the data
depends entirely on the masking provided by the transmitter which, in most cases is not
enough [13]. The other important problem is that they present error in the recovered data,
the magnitude of the error will depend on the observer and its design, but still, it will
be present. A solution for these two problems is given by designing the receiver not
as an observer but as a reconstruction of the states of the transmitter involved in data
transmission, there is a class of systems that allow to do this kind of reconstruction without
the need of state observers nor a full reconstruction of transmitters dynamical equations,
they will be presented in the following sections along with the solution of this problems.
Two approaches for data encryption will be presented, the ﬁrst is a state observer
based on the Super-Twisting algorithm [15], the observer can reconstruct all the states
of the transmitter and also recover the encrypted data, this receiver has both the problems
mentioned above, but it has the advantage that the end user will not require full knowledge
of the transmitters dynamic equations. The second solution is a reconstruction of the states
that are involved in data transmission, this receiver will retain the security features of
the Super-Twisting observer and it will also provide a solution to its lack of security and
accuracy in data reconstruction. The two encryption methods will be tested with image
and text as data, this will allow to present the advantages of the use of Liouvillian systems
in secure communications.
This chapter is organized as follows: in Sect. 4.2 we present the transmitter and the class
of systems that will be used for creating the receivers, in Sect. 4.3 the receivers and their
unique characteristics are given, in Sect. 4.4 we give the numerical results where images
and text are used as transmitted data, in Sect. 4.5 we present an analysis of the security
provided by the algorithm as well as its ability to withstand known and chosen plaintext
attacks, ﬁnally a conclusion and comments are given in Sect. 4.6.
4.2
Transmitter
The next deﬁnitions will be necessary for further understanding the properties of the
transmitter and the development of the receivers:
Deﬁnition 4.1 Algebraic observability condition: A state variable is said to be alge-
braically observable in relation to the inputs and outputs of the system if it satisﬁes a
differential polynomial equation in terms of the inputs, outputs and some of its time
derivatives.

4.2
Transmitter
99
There is a class of chaotic systems that even if they does not fulﬁll the algebraic
observability condition their states can be reconstructed in other ways, hence the following
deﬁnition:
Deﬁnition 4.2 A system is said to be a Liouvillian system if its state variables that do
not fulﬁll the algebraic observability condition, in turn, can be written as an expression in
terms of integrals or exponentials of integrals of the output and some of its time derivatives.
For this encryption scheme the transmitter must be a Liouvillian chaotic system, the
Colpitts oscillator is selected because it is a Liouvillian system, but also it has other
desirable properties for secure communications such as stable and bounded dynamics
which vary greatly depending on its initial conditions, this chaotic dynamic makes the
masking of the transmitted data more effective since it is less likely to be unmasked without
the proper receiver.
The Colpitts oscillator is a chaotic non-linear system that complies with the require-
ments to be a Liouvillian system. it has been used as a source for periodical signals
(sinusoidal signals usually) and thanks to its chaotic behavior at low and high fundamental
frequencies its use on secure communications is more feasible. Its dynamics are given by:
˙x1 = x2 −f (x3)
˙x2 = −x1 −bx2 −x3
(4.1)
˙x3 = x2 −d
y = x2
where:
f (x3) =
⎧
⎨
⎩
−a(x3 + 1)
0
x3 < −1
x3 ≥−1
The Colpitts oscillator based transmitter can be rewritten as follows:
x1 = −˙y −by −

(y −d)
x2 = y
(4.2)
x3 =

(y −d)
Then it is a Liouvillian system. Both transmitters encrypt the messages via chaotic
masking, the ﬁrst transmitter is intended to be used by the Super-Twisting observer and it
masks data by embedding it into the state of the oscillator, this encryption scheme needs

100
4
Liouvillian Systems and Cryptography
that the oscillator be written in a canonical form by means of a change of variable:
n1 = x3
n2 = x2 −d
n3 = γ −x1 −bx2 −x3
And its dynamic equations are:
˙n1 = n2
˙n2 = n3 + s
˙n3 = −2n2 + d + f (n1) −bn3
(4.3)
y = n2
The variable s is the data carrier signal to be masked. The second receiver will not
require the transformation, and the encryption method will also mask the carrier signal
with the state of the transmitter:
˙x1 = x2 −f (x3)
˙x2 = −x1 −bx2 −x3 + s
˙x3 = x2 −d
(4.4)
y = x2
This encryption scheme allows to avoid masking the message with the output of the
system, this is because masking information that way makes the system susceptible to
known plaintext attacks and chosen plaintext attacks.
The data carrier signal s is formed by the plain image or plain text, in the case of RGB
images they will be formed by three matrices of unsigned eight bit integer numbers, these
are integer numbers from 0 to 255, text messages are a single vector made of the same
unsigned integers.
Suppose that the RGB image is of size i × j The easiest way to create the data carrier
signal is to make a vector vint with i × j × 3 elements and ﬁll it with each element of the
matrix, then divide it by 255 to obtain a vector formed by real numbers between 0 and 1,
this is:
v = vint/255

4.3
Receiver
101
The carrier signal is made by deﬁning a starting time ts of transmission and an end time
te and the amplitude of the signal takes the values of the vector and the amplitude will have
period
P = te −ts
3 · i · j
This form of carrier signal is very susceptible to reconstruction error as the slightest
variation in the reconstruction of the signal will cause errors in the ﬁnal recovered image,
so it is not preferred by the authors, instead the integer vector elements are turned into
their binary equivalent producing a new vector vbin of size i × j × 24 composed of 0 and
1, then, the carrier signals amplitude is given by:
s = a (vbin −0.5)
Where a is the amplitude required by the encryption scheme. This allows to register a
negative number as 0 and a positive as 1, thus considerably reducing the effects of state
reconstruction inaccuracy, of course, this comes at the price of having a signal eight times
longer than the previous method. This last method is preferred by the authors for providing
accurate image and text reconstructions.
4.3
Receiver
The design of the receiver will be speciﬁc to each transmitter, both use data masking as
means of encryption, but each one will have its unique characteristics, the ﬁrst one is the
Super-Twisting observer
4.3.1
Super-Twisting Based Receiver
The receiver dynamic is given by the following equations:
.
ˆn1 = ˆn2 + mτ −1kcsign

y −ˆy

.
ˆn2 = ˆn3 + ka

y −ˆy

+ mτ −1 y −ˆy

1
2 sign

y −ˆy

.
ˆn3 = kb

y −ˆy

+ m2τ −2sign

y −ˆy

(4.5)
ˆy = ˆn2
ˆs = ˙n2 −ˆn3

102
4
Liouvillian Systems and Cryptography
Where ka > 0, kb > 0, kc > 0, m > 0 y 0 < τ < 1 are positive constants and ˆs is the
recovered message given by:
ˆs = n3 + s −ˆn3
The message recovery error is:
es = s −ˆs = s −

n3 + s −ˆn3

= −n3 + ˆn3
(4.6)
This error is bounded by the synchronization error:
n3 −ˆn3
 ≤
Cn −C ˆn
 = ∥Ce∥
As the estimated state ˆn converges to the transmitters state n, the reconstructed message
ˆs converges to the message. For proving the convergence of the messages the following
assumptions are needed:
Assumption 4.1 There exists non-negative constants L0f y L1f such that the following
quasi-Lipschitz condition holds:
Δf
 ≤L0f + ∥e∥
L1f +
Aμ

Assumption 4.2 The message is bounded by a positive real constant M:
∥s∥≤M
Assumption 4.3 There is a positive deﬁnite matrix 0 < Q = QT such that the Riccati
equation:
PAμ + AT
μP + PRP + Q = 0
(4.7)
Has solution 0 < P = P T with:
R = Λ−1
f
+ 2
f
 L1f I, 0 < f = T
f
Q = Q0 + 2

L1f +
Aμ
2 I

4.3
Receiver
103
Assumption 4.4 There is a vector
K = mτ −1
⎛
⎜⎝
kc
|e|
1
2
mτ −1
⎞
⎟⎠P −1CT ≥0
where not all its components are zero.
4.3.2
Proof of Stability
The synchronization error is deﬁned as:
e =
⎡
⎢⎣
e1
e2
e3
⎤
⎥⎦=
⎡
⎢⎣
n1 −ˆn1
n2 −ˆn2
1
m

n3 −ˆn3

⎤
⎥⎦
The derivative of the error with an added real constant μ > 0 is:
⎡
⎢⎣
˙e1
˙e2
˙e3
⎤
⎥⎦=
⎡
⎢⎣
e2 + μe1 −μe1 −mτ−1kcsign(y −ˆy)
e3 −ka (e) −mτ−1 |e|
1
2 sign(e) + μe2 −μe2 + s
1
m(n1, n2, n3) −kb
m (e) −m2τ−2sign (e) + μe3 −μe3
⎤
⎥⎦
With (n1, n2, n3) = −2n2 + d + f (n1) −bn3, this last equality can be written as
follows:
.e =
⎡
⎢⎣
−μ 1
0
0 −μ 1
0
0 −μ
⎤
⎥⎦e −
⎛
⎜⎝
0
ka
kb
⎞
⎟⎠

0 1 0

⎡
⎢⎣
e1
e2
e3
⎤
⎥⎦
−mτ −1
⎛
⎜⎝
kc
|e|
1
2
mτ −1
⎞
⎟⎠sign
⎛
⎜⎝

0 1 0

⎡
⎢⎣
e1
e2
e3
⎤
⎥⎦
⎞
⎟⎠+
⎛
⎜⎝
μe1
μe2 + s
Φ(n1,n2,n3)
m
+ μe3
⎞
⎟⎠
The derivative of the error can be written as:
.e = Aμe −k2Ce −k1sign(Ce) + Δf
(4.8)

104
4
Liouvillian Systems and Cryptography
With:
k1 = −mτ −1
⎛
⎜⎝
kc
|e|
1
2
mτ −1
⎞
⎟⎠, k2 =
⎛
⎜⎝
0
ka
kb
⎞
⎟⎠, Δf =
⎛
⎜⎝
μe1
μe2 + s
Φ(n1,n2,n3)
m
+ μe3
⎞
⎟⎠
The gain k2 > 0 is chosen so the effects of the message within the uncertainty Δf
are reduced. The receiver allows for the error es = s −ˆs to remain bounded and for it to
converge to the residual set:
Dε = {es| ∥es∥P ≤¯μ(k)}
Where P is the solution to the Riccati equation, then:
¯μ(k) =
⎛
⎝
ρ(K)
!
Kαp
2 + ρ(K)αQ + Kαp
⎞
⎠
Where:
ρ(K) = 2
f
 L2
0f + 4k2s+!
n−1
f
Kαp = K

λmin

P −1/2CT CP −1/2
αQ = λmin

P −1/2QT QP −1/2
For proving this the next Lyapunov candidate function is proposed:
V (e) = ∥e∥2
P = eT Pe, 0 < P = P T
Its derivative is:
˙V (e) = 2eT PAμe −2eT Pk2Ce −2eT Pk1sign(Ce) + 2eT PΔf
The gains are chosen ka > 0 y kb > 0 and in view of Assumption 4.4
˙V (e) ≤2eT PAμe −2KeT CT sign(Ce) + 2eT PΔf
Using the inequality XT Y + Y T X ≤XT f X + Y T −1
f Y for 0 < f = T
f :
˙V (e) ≤eT (PAμ + AT
μP)e −2KeT CT sign(Ce) + eT P−1Pe + ΔT
f f Δf

4.3
Receiver
105
From Assumption 4.1:
˙V (e) ≤eT (PAμ + AT
μP + PRP + Q)e −eT Qe + L2
0f
+2
f


∥e∥2 
L1f +
Aμ
2
−2eT CT Ksign(Ce)
˙V (e) ≤eT (PAμ + AT
μP + PRP + Q)e −eT Qe
+2
f
 L2
0f −2eT CT Ksign(Ce)
By means of Assumption 4.3:
˙V (e) ≤−eT Qe + 2
f
 L2
0f −2K
n
"
i=1
(Ce)i

˙V (e) ≤−eT Qe −2K
n
"
i=1
(Ce)i
 + ρ(k)
(4.9)
With ρ(k) = 2
f
 L2
0f + 4k¯s
!
n−1
f , then:
˙V (e) ≤−∥e∥Q −2KαP ∥e∥P + ρ(k)
Then:
# n
"
i=1
(Ce)i

$2
≥
n
"
i=1
(Ce)i
2 = ∥Ce∥2 =
CP −1/2P −1/2e

2
≥αP eT Qe
Where αP = λmin

P −1/2CT CP −1/2
, so:
˙V (e) = d
dt ∥e∥2
p ≤−∥e∥2
Q −2Kα ∥e∥P + ρ(k)
It yields to:
˙V (e) = −αQV (e) −ϑ
%
V (e) + β
(4.10)
Having αQ = λmin

P −1/2QT QP −1/2
> 0, ϑ = 2Kαp y β = ρ(k). From
Assumptions 4.1 and 4.3, it is possible to conclude that:

1 −¯μ (k)
V (e)

+
→0

106
4
Liouvillian Systems and Cryptography
Where the function [•]+ is deﬁned as:
[z]+ =
⎧
⎨
⎩
z
0
, z ≥0
, z < 0
So V (e) ≤¯μ(k), then:
V (e) = ∥e∥p = eT Pe ≥eT
2 Pe2
e1 = Cn −C ˆn = −es
eT
1 Pe1 =

−eT
s

P (−es) = eT
s Pes = ∥es∥P
The message estimation error converges to the set Dε since:
∥es∥P = ∥e2∥P ≤¯μ (k)
So the message recovery error converges to ¯μ (k):
∥es∥P ≤¯μ (k)
The synchronization error remains bounded even with the presence of the message
embedded into the state and as consequence the message recovery error remains bounded
showing the main characteristics of this receiver.
⊓⊔
For recovering the message it is necessary to have access to the derivative of the output,
but directly applying a derivative to this kind of signals has detrimental consequences to
the quality of the recovered information as the derivative itself tends to amplify noise, an
alternative to this is to approximate the derivative by means of:
˙n (t) ≈n (t) −n (t −h)
h
The last equation returns the slope of the line between the current state n(t) and a
previous measurement of the state n(t −h) taken h seconds before. This approximation
will not amplify any noise thus providing less error than applying a derivative to signal.
This receiver does not require knowledge of the transmitter dynamical equations, then,
they remain hidden to the end users providing some degree of safety to the data, aside
from the one given by the chaotic masking, but still, this encryption scheme depends
mostly on the chaotic masking, this is because it is not possible to produce encryption
keys that depend on the initial conditions of the transmitter or the gains of the receiver
because, usually, observer states will converge to the transmitters states regardless of
small variations on its initial conditions or gains. Another setback of sliding modes based

4.3
Receiver
107
observers is that chattering does not allow the error to remain close to zero for extended
periods of time, then error will always be present in the reconstruction of the transmitted
message.
The next receiver does not have the problems caused by using observers as receiver,
and it will also retain the characteristic of not providing the end user with full knowledge
of the transmitters dynamical equations.
4.3.3
Reconstruction of the States Based Receiver
The design of this receiver is based on the property that makes a system be Liouvillian
(see Deﬁnition 4.1), this property allows to reconstruct the states of a system without the
need of an state observer, so it is possible to create receivers that will not be affected
by the limitations of observers, and yet they will retain the ability of not using the same
dynamic equations of the transmitter. The message will be masked within the dynamic
equations of the system and recovering it will require to reconstruct the dynamical equation
of the output state, this state can be reconstructed with the output of the transmitter so the
message can be recovered. The receiver is given by:
ˆx1 = ˙y −by −

(y −d))
ˆx2 = y
ˆx3 =

(y −d)
ˆs = ˙y + ˆx1 + b ˆx2 + b ˆx3
The reconstruction of the message requires an accurate reconstruction of the state,
since the system is Liouvillian, the other two states can accurately be reconstructed by
integrating the output and its derivatives, so error will not be present in this reconstruction:
e =
⎡
⎢⎣
x1 −ˆx1
x2 −ˆx2
x3 −ˆx3
⎤
⎥⎦
⎡
⎢⎣
x1 −ˆx1
x2 −ˆx2
x3 −ˆx3
⎤
⎥⎦=
⎡
⎢⎣
 
y −f
&
(y −d)dt
'
dt −
 
y −f
&
(y −d)dt
'
dt
y −y
 (y −d)dt − (y −d)dt
⎤
⎥⎦

108
4
Liouvillian Systems and Cryptography
The synchronization error is zero:
⎡
⎢⎣
x1 −ˆx1
x2 −ˆx2
x3 −ˆx3
⎤
⎥⎦=
⎡
⎢⎣
0
0
0
⎤
⎥⎦
e = 0
Then the message recovery error is deﬁned as:
es = s −ˆs = s −

˙y + ˆx1 + b ˆx2 + b ˆx3

From (4.4):
s = ˙x2 + x1 + bx2 + x3
Considering that e = 0
es = 0
The derivative of the output is approximated by:
˙y (t) ≈y (t) −y (t −h)
h
This receiver is very sensitive to initial conditions, if they are not equal, the message
recovery error will be different to zero making impossible to have access to the encrypted
data, this feature can be used to produce an encryption key formed by the set of initial
condition and parameters that produce chaotic behavior in the transmitter.
The combination of the transmitter and the receiver give better security features to the
transmitted data than the ones provided by state observers, because it is possible to use
encryption keys and the amplitude of the data carrier signal can be made arbitrarily small
and as in the case of the Super-Twisting observer, it does not use the full dynamic of the
transmitter nor the same equations.
4.4
Numerical Simulation
For testing the results given in previous sections image and text are encrypted and
recovered by the observer and the reconstruction based receiver, for this the parameters
of the Super-Twisting observer are:

4.4
Numerical Simulation
109
Parameter Value
k1
10
k2
15
k3
20
k4
25
The parameters of the transmitter and Liouvillian receiver are:
Parameter Value
a
2
b
3
d
0.6
The maximum amplitude of the data carrier signal will be of 3, this value is chosen
so the derivative approximation does not affects the recovery of the data. The transmitted
image is the presented in Fig. 4.1. The encrypted images are shown in Figs. 4.2 and 4.3.
In both cases the encrypted image does not present any data of the plain image, then
the masking is effective, because even if the amplitude of the data carrier signal is almost
Fig. 4.1 Transmitted data

110
4
Liouvillian Systems and Cryptography
Fig. 4.2 Encrypted data by Super-Twisting observer
Fig. 4.3 Encrypted data by reconstruction based receiver

4.4
Numerical Simulation
111
Fig. 4.4 Recovered data by Super-Twisting observer
the same of the states, the plain image is not visible in the cypher image. Although the
masking is equally effective in both transmitters, the quality of the reconstructed images
is completely different, in Figs. 4.4 and 4.5 it is possible to see the clear advantage of the
Liouvillian transmitter.
The recovered image is more accurate in the reconstruction based receiver (Fig. 4.5),
this mainly because the observer is intended to bound the error in the tracking of the
transmitter states, yet the recovered data is still useful and the transmitted image can be
seen but not as clearly as in Fig. 4.4. For text transmission a fragment of the abstract is
used:
Transmitted text:
In this chapter we show the use of a Liouvillian chaotic system on
a master-slave scheme for secure communications. Two forms of
data encryption are presented, the ﬁrst is a Super-Twisting state
observer based on the Super-Twisting algorithm

112
4
Liouvillian Systems and Cryptography
Fig. 4.5 Recovered data by reconstruction based receiver
Recovered text by Super-Twisting observer:
IIn this chapter we show the use of a Liouvillian chaotic system
on a master+slave scheme for secure communications. Two forms
of data encryption are preseeted, the ﬁrst is a Super-Twisting state
observer based onnthe Super-Twistimf‘kfnqhsgl+sgdrdbnmchr‘
Recovered text by reconstruction receiver
In this chapter we show the use of a Liouvillian chaotic system on
a master-slave scheme for secure communications. Two forms of
data encryption are presented, the ﬁrst is a Super-Twisting state
observer based on the Super-Twisting algorithm
As in the image data, the observer produces error in the recovered data in comparison
to the reconstruction based receiver, this last receiver produces an accurate reconstruction
message as it has no error in any of the recovered characters.

4.5
Vulnerability to Cryptanalysis
113
4.5
Vulnerability to Cryptanalysis
Usually chaotic masking is done by combining the output of the transmitter with the
message carrier signal [3,14,16], this type of masking is given by the next equation:
y = Cx + s
Masking data in this way makes the cryptosystem extremely vulnerable to known and
chosen plaintext attacks, Since the signal Cx depends entirely on the key, then, if the key
is the same for each message, Cx will always be the same and only s will change. In a
known plaintext attack, the opponent has access to a number of plaintext s and ciphertext
y pairs, in the case of this masking if the opponent has a single pair, the entire system is
compromised because they will be able to reconstruct Cx:
Cx = y −s
In consequence any another message s1 that is transmitted with the same key will have
the same vector Cx masking s1, the ciphertext of this new message will be:
y1 = Cx + s1
Recovering s1 without the need of the receiver nor the key is simple as the vector Cx is
already known:
s1 = y1 −Cx
Then this common chaotic masking will be vulnerable to known plaintext attacks. In
turn, the proposed masking based on the Liouvillian property is not vulnerable to this type
of attack, as the cipher text or image depends not only on the states but also depends on the
message, so each state vector Cx will be unique to each message, because the encryption
is given by the equation:
˙x = f (x, s)
y = Cx
Making very difﬁcult to implement this type of known plaintext attacks due to Cx not
being the same for each message. To further exemplify the encryption algorithm ability to
withstand known plaintext attacks we will implement a chosen plaintext attack, this type
of attack is far more dangerous than the known plaintext attack. In the chosen plaintext
attack, the attacker is allowed to choose the message that will be transmitted, the messages

114
4
Liouvillian Systems and Cryptography
Fig. 4.6 Chosen image
are designed so they could lead to exposing a weakness in the algorithm, recover another
unknown message or in the worst case to recover the encryption key.
For this example we choose as message a completely black image (formed only by
zeros) with the same size of the image used in the previous sections with the purpose of
recovering the tiger image without the need of the key, this by retrieving the key stream
(Cx) unaffected by the image, consider that the key will be the same for both messages.
The obtained results are shown in Figs. 4.6 and 4.7.
As can be seen in Figs. 4.6 and 4.7, the chosen plaintext attack fails to recover the
encrypted image or any data that could compromise the key, this is caused by the message
itself, as the key stream depends on both the message and the key, then every different
message will produce a different key stream even if the key is not changed, so this allows
to use a single key multiple times, also it is worth to mention that this is not a common
feature in this type of encryption schemes.
4.6
Concluding Remarks
Both encryption methods where able to produce recovered messages, but as expected
the reconstruction based receiver made possible to recover the data without signiﬁcant
error, this last method retained the security feature of the Super-Twisting observer which
is not to give the user of the receiver the same dynamical equations of the transmitter
oscillator, even more it considerably enhanced the security of the transmitted data, this
because the encryption key based on the initial conditions and the parameters of the

References
115
50
350
300
250
200
150
100
50
100
150
200
250
300
350
400
Fig. 4.7 Recovered image by chosen plaintext attack
system, its biggest advantage over most state observers is that it makes possible to use
encryption keys, not leaving the security of the message to relay solely on the chaotic
masking. Another advantage of the reconstruction based receiver is that it is capable of
reconstructing the transmitted data without error, this can be seen in Figs. 4.4 and 4.5, in
this, the image recovered by the Super-Twisting observer presents inaccuracy in the color,
this is caused by the design of the observer, since it is intended to bound the error only,
it will present small differences in the reconstructed signals, then, this error is carried
over to the reconstructed data and produces the effect seen in Fig. 4.4. In comparison
the performance of the reconstruction based receiver is better, as the recovered data is
identical to the transmitted data. It is possible to conclude that the properties that make
a system be Liouvillian can be very convenient in data encryption, as explained, they
present advantages in security and quality of the recovered information plus reducing the
vulnerability to known plaintext attacks.
References
1. Chua, L. O., Kocarev, L., Eckert, K., & Itoh, M. (1992). Experimental chaos synchronization in
Chua’s circuit. International Journal of Bifurcation and Chaos, 2(3), 705–708.
2. Morgül, Ö., & Solak, E. (1996). Observer based synchronization of chaotic systems. Physical
Review E, 54(5), 4803.

116
4
Liouvillian Systems and Cryptography
3. Hassan, M. F. (2014). Observer design for constrained nonlinear systems with application to
secure communication. Journal of the Franklin Institute, 351(2), 1001–1026.
4. Alvarez, G., & Li, S. (2006). Some basic cryptographic requirements for chaos-based cryptosys-
tems. International Journal of Bifurcation and Chaos, 16(8), 2129–2151.
5. Volos, Ch. K., Kyprianidis, I. M., & Stouboulos, I. N. (2013). Image encryption process based
on chaotic synchronization phenomena. Signal Processing, 93(5), 1328–1340.
6. Roohbakhsh, D., & Yaghoobi, M. (2015). Fast adaptive image encryption using chaos by
dynamic state variables selection. International Journal of Computer Applications, 113(12), 28–
32.
7. Schmitz, R. (2001). Use of chaotic dynamical systems in cryptography. Journal of the Franklin
Institute, 338(4), 429–441.
8. Akhavan, A., Samsudin, A., & Akhshani, A. (2011). A symmetric image encryption scheme
based on combination of nonlinear chaotic maps. Journal of the Franklin Institute, 348(8), 1797–
1813.
9. Volos, C. K., Kyprianidis, I. M., Stouboulos, I., & Pham, V. T. (2015). Image encryption scheme
based on non-autonomous chaotic systems. In Computation, cryptography, and network security
(pp. 591–612). Springer International Publishing.
10. Martínez-Guerra, R., Cruz-Victoria, J., Gonzalez-Galan, R., & Aguilar-Lopez, R. (2006). A new
reduced-order observer design for the synchronization of lorenz systems. Chaos, Solitons &
Fractals, 28(2), 511–517.
11. Martínez-Guerra, R., Gómez-Cortés, G. C., & Pérez-Pinacho, C. A. (2015). Synchronization of
integral and fractional order chaotic systems a differential algebraic and differential geometric
approach with selected applications in real-time. Springer.
12. Sobhy, M. I., & Shehata, A. E. R. (2001). Chaotic algorithms for data encryption. In IEEE
International Conference on Acoustics, Speech, and Signal Processing (ICASSP ’01) (Vol. 2,
pp. 997–1000).
13. Dachselt, F., & Schwarz, W. (2001). Chaos and cryptography. IEEE Transactions on Circuits
and Systems I: Fundamental Theory and Applications, 12(48), 1498–1509.
14. Cheng, C. C., Lin, Y. S., & Wu, S. W. (2012). Design of adaptive sliding mode tracking
controllers for chaotic synchronization and application to secure communications. Journal of
the Franklin Institute, 349(8), 2626–2649.
15. Levant, A. (1993). Sliding order and sliding accuracy in sliding mode control. International
Journal of Control, 58(6), 1247–1263.
16. Castro-Ramírez, J., Martínez-Guerra, R., & Cruz-Victoria, J. C. (2015). A new reduced-
order observer for the synchronization of nonlinear chaotic systems: An application to secure
communications. Chaos: An Interdisciplinary Journal of Nonlinear Science, 25(10), 103128.

5
State Observers and Cryptography
Abstract
In this chapter we propose the use of chaotic systems on a master-slave scheme for
secure communications. This cryptosystem allows to use the advantages of block
cyphers in color images, these features permit us to encrypt messages as large as images
without the need of keys bigger than the transmitted data, this is achieved by using the
synchronization of two chaotic oscillators and fractals such as Julia sets. Two different
receivers will be presented; the ﬁrst one is an exponential polynomial observer and the
second is a reconstruction of the states based on the properties of Liouvillian systems,
the latter retaining the same security features but with a more simple implementation
and faster encryption and decryption times.
5.1
Introduction
Synchronization of chaotic systems has received a lot of attention from researchers due
to its potential applications [1] in special there have been many advances in secure
communications [2–4] where the goal is to encrypt data using signals provided by chaotic
oscillators, in this application of synchronization one of the most common solutions is to
design the receiver as a state observer in order to achieve synchronization to a nonlinear
electric circuit and recover the information that was used to encrypt the transmitted data
and with this information recover the message [5, 6]. The proposed encryption algorithm
uses the synchronization of chaotic systems under master-slave paradigm, where the
transmitter is named the master system and the receiver is called the slave system, the
intention of this conﬁguration is to allow the slave to reconstruct the states of the master
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_5
117

118
5
State Observers and Cryptography
system by using a signal provided by the latter, then with this reconstruction, the encrypted
data is recovered.
Various encryption algorithms rely on shufﬂing and diffusing the message data, these
algorithms are quite susceptible to chosen plaintext attacks or known plaintext attacks
regardless of how well the distortion of the original data is done. In recent developments
algorithms that are more resistant to this type of attacks have been introduced, this
characteristic has been achieved by making the shufﬂing and diffusing operations depend
on the key and the transmitted message itself, but in order to accomplish this operation,
they require to provide the user with more information than the key and ciphertext or image
and will also have a slight error caused by the extra data needed to recover the message.
The proposed encryption algorithm will have these security features, but will not require
to give more data to the user, nor will it sacriﬁce a portion of the message to hide this
data, this is achieved through the properties of Liouvillian systems and the use of Julia
sets for reducing the relation between the encrypted data and the key. Two approaches
for data recovery will be presented, the ﬁrst is the exponential polynomial observer
(EPO), this observer can reconstruct all the states of the transmitter and thus recover the
encrypted data. The second receiver is a reconstruction of the states that are involved in
data encryption based on the properties of Liouvillian systems, the reconstruction will
also solve the lack of accuracy in data reconstruction caused by the observer estimation
error. The two encryption methods will be tested with color images as transmitted data,
making possible to present the advantages of the use of Liouvillian systems in secure
communications.
The rest of the chapter is organized as follows. In Sect. 5.2, some deﬁnitions and the
proposed algorithm encryption is introduced. In Sect. 5.3, the method for data recovery is
presented with stability analysis for the exponential polynomial observer as well as the
Liouvillian property of the system is used for message recovery. In Sect. 5.4, numerical
simulation of the proposed methodology is presented in order to analyse the algorithm.
Finally, in Sect. 5.5, some concluding remarks are given.
5.2
Encryption
5.2.1
Generating Pseudo-Random Numbers
The class of systems that will be introduced in the following deﬁnition will the main focus
of this chapter.
Deﬁnition 5.1 A system is called Liouvillian if its state variables can be written as an
expression in terms of integrals or exponentials of integrals of the output and some of its
time derivatives.
Let us consider the following example.

5.2
Encryption
119
Example 5.1 Let the dynamic equations that describe the Colpitts oscillator given by:
˙x1 = x2 −f (x3)
˙x2 = −x1 −bx2 −x3
˙x3 = x2 −d
y = x2
(5.1)
where:
f (x3) =
(
−a (x3 + 1)
x3 < −1
0
x3 ≥−1
The states of the Colpitts oscillator can be written as follows:
x1 = −˙y −by −

(y −d)
x2 = y
x3 =

(y −d)
(5.2)
Showing that is a Liouvillian system.
For secure communications, it is necessary to generate a sequence of numbers, chaotic
oscillators are a good source of pseudorandom numbers, in this case the Colpitts oscillator
will be used because it is a Liouvillian system, but also it has other desirable properties
for encryption like a stable and bounded dynamics, that changes greatly depending on its
initial conditions.
5.2.2
Encryption Algorithm
The encryption process consist in diffusion and shufﬂing of the plain image, this stages
will depend on the key and the message causing that known and chosen plaintext attacks
are difﬁcult to implement. In the description of the algorithm the message will be assumed
to be an RGB color image, this algorithm is not limited to images and can also be applied
to text messages. Consider the RGB image given by P ∈Zm×n×3 composed by three
matrices Pr, Pg and Pb of size m × n.
The key is a set of hexadecimal characters, long enough to obtain the information
required by the encryption process, the key will be composed as is shown below:
Key = K1 −K2 −K3 −K4 −· · · −Kl · · ·

120
5
State Observers and Cryptography
Diﬀusion
Fig. 5.1 Diagram of the encryption process
Each key segment will be identiﬁed as: Ki = ABCD, with 1 ⩽i ⩽l. Every segment
of the key contains information about the process such as initial conditions, parameters,
sample times or gains. Here we give the following steps (Fig. 5.1):
Step 1 Create the initial conditions for the chaotic oscillator with the plain image. By
using a three state oscillator, each state can be used for each one of the RGB matrices that
compose the image. The initial condition for the ﬁrst state is generated as follows:
xo1 =
)m
i=1
)n
j=1 P (i, j, 1)
255mn
(5.3)
Then xo1 ∈(0, 1) and can be used as initial condition for the state x1. The process must
be repeated for the other two states using the remaining matrices.
Step 2 With the ﬁrst sections of the key generate the chaotic oscillators parameters. The
Colpitts oscillator has three parameters, the ﬁrst one can be formed by K1 = ABCD, the
parameter a is:
a = ABCD
FFFF
This will provide a ∈(0, 1), the remaining element of the key acts as scale factor for the
parameter if the oscillator needs it, this step must be repeated for the remaining oscillators
parameters b and d.
Step 3 Use the chaotic oscillator to generate a long trajectory. Once the oscillator
parameters and initial conditions have been obtained, it must generate sufﬁciently long

5.2
Encryption
121
trajectories for them to provide enough random numbers to make vectors for the shufﬂing
and diffusion operations.
Step 4 With the second section of the key K2 obtain numbers from the oscillators state
trajectories. To do this, create a matrix ks based on the transmitter oscillator’s states xn and
a sample time t speciﬁed in the second section of the key, the sample time is obtained by:
t =
ABCD
FFFF

101−E
(5.4)
and the matrix is:
ks =
⎡
⎢⎢⎢⎢⎣
x1 (t)
x2 (t) · · · xn (t)
x1 (2t) x2 (2t) · · · xn (2t)
...
...
...
...
x1 (nt) x2 (nt) · · · xn (nt)
⎤
⎥⎥⎥⎥⎦
(5.5)
Then the matrix ks must be modiﬁed by a non-invertible transformation, so the relation
between the diffusion and shufﬂing stages and the states of the oscillator is reduced due
to the fact that the Julia set is not an injective function, this transformation will be made
through the Julia set [3]:
Zn+1 = Z2
n + b, n ∈[1, α] , b ∈C
(5.6)
b = c + di
c = ABCDE
2FFFFF
d = ABCDE
2FFFFF
i =
√
−1
(5.7)
The key will provide the value of b and the number of iterations of the Julia set α =
ABCDE, choosing b = c + di guarantees that the values provided by the fractal are
always within the attractor. The Julia set requiring complex numbers will make possible
to further modify the numbers given by the Liouvillian system and making very hard to
ﬁnd out which numbers produced the order of shufﬂing and values for diffusion, the initial
condition will be made by the value of xn (tn) and another element of the key:
Z0 =

0.5 −
xn (tn)
ABCDE

+
 xn (tn)
ABCDE

i

122
5
State Observers and Cryptography
Finally the transformation will be the norm of the complex value given by the Julia set:
T (xn) = |Zn|
Then, the matrix ks is transformed into the matrix kst by applying the Julia set
transformation to each one of its elements:
kst = T (ks) =
⎡
⎢⎢⎢⎢⎣
Z1,t1 Z2,t1 · · · Zn,t1
Z1,t2 Z2,t2 · · · Zn,t2
...
...
...
...
Z1,tn Z2,tn · · · Zn,tn
⎤
⎥⎥⎥⎥⎦
(5.8)
The value tn denotes the sample taken from state xn at time n · t.
Step 5 Create the shufﬂing order and the diffusion values from the previously generated
numbers, the diffusion vector Dv is formed from kst:
Dv1 =

Z1,t1 Z2,t1 · · · Zn,t1

Dv2 =

Z1,t2 Z2,t2 · · · Zn,t2

(5.9)
Dv3 =

Z1,tn Z2,tn · · · Zn,tn

And combine it with the plain image by a bitwise XOR operation ⊕to produce the
partially encrypted image Pc1:
Pcr1 = Pr ⊕Dv1
Pcg1 = Pg ⊕Dv2
Pcb1 = Pb ⊕Dv3
(5.10)
Pc1 = P ⊕Dv
(5.11)
With the transformed vector kst create a shufﬂe vector having as many elements as the
message:
Sv1 =

Z1,t1 Z1,t2 · · · Z1,tmn

Sv2 =

Z2,t1 Z2,t2 · · · Z2,tmn

(5.12)
Sv3 =

Z3,t1 Z3,t2 · · · Z3,tmn

Sv = sort (Sv1, Sv2, Sv3) , Sv ∈Rmn
(5.13)

5.3
Data Recovery
123
Sort the elements of the shufﬂe vector and reorder the elements of the partially
encrypted image Pc1 according to the order of the elements of the shufﬂe vector to form
Pc2.
Pc2 = sort (Pc1, Sv)
(5.14)
The encrypted image will be Pc2.
5.3
Data Recovery
To recover the encrypted message it will be necessary to reconstruct the trajectories of
the Liouvillian oscillator, then by using the key it is possible to build the diffusion vector
Dv and the shufﬂe vector Sv, the states of the oscillator will be reconstructed by a state
observer and by a reconstruction of the states that use the properties of Liouvillian systems
and to ﬁnally recover the encrypted image, the cypher image Pc2 is reordered in function
of Sv to produce Pc1 and then the operation XOR is applied with Dv providing the plain
image.
5.3.1
Exponential Polynomial Receiver
The exponential polynomial observer function is to estimate the states of a nonlinear
system, it is similar to a Luenberger observer in the sense that it requires a reconstruction
of the system dynamic and has a similar structure, it has more gain vectors and also has
the characteristic that it will make the synchronization error of the states decrease more
rapidly than an exponential bound, hence the name exponential polynomial. The dynamic
of the observer is given by:
˙ˆx = Aˆx + ψ

ˆx

+
m
"
i=1
Ki

y −C ˆx
2i−1
ˆy = C ˆx
Where ˆx ∈Rn are the states of the observer, y is the output of the transmitter, ψ  ˆx is
the nonlinear part of the transmitter which satisﬁes the Lipschitz condition and Ki ∈Rn,
1 ≤i ≤m are the gain vectors of the observer. The following assumptions will be needed
during the theoretical result of this section:
Assumption 5.1 For a given ε > 0 and A ∈Rn×n there exists a matrix P = P T > 0,
P ∈Rn that is the solution to the algebraic equation:
AT P + PA + L2P 2 + (1 + ε) I = 0

124
5
State Observers and Cryptography
Assumption 5.2 The nonlinear part of the transmitter ψ

ˆx

satisﬁes the condition:
2 ˆxT Pψ ˆx ≤L2 ˆxT P 2 ˆx + ˆxT ˆx
5.3.2
Stability
Proof The dynamic of the synchronization error is ˙e = ˙x −˙ˆx, then:
˙e = Ax + ψ (x) −. . .
· · · −
#
Aˆx + ψ  ˆx +
m
"
i=1
Ki
y −C ˆx2i−1
$
and considering that a single state variable will be used as output, then it is possible to
make:
˙e = A (e) + φ(e) −
m
"
i=1
KiCe2i−1
where φ(e) = ψ (x) −ψ

ˆx

. From Assumption 5.2 the nonlinear part of the error φ(e)
satisﬁes the condition:
2eT Pφ(e) ≤L2eT P 2e + eT e
The following Lyapunov candidate function is proposed:
V = eT Pe
and then, by computing the derivative:
˙V = ˙eT Pe + eT P ˙e
˙V =

A (e) + φ(e) −
m
"
i=1
KiCe2i−1
T
Pe
+ eT P

A (e) + φ (e) −
m
"
i=1
KiCe2i−1

˙V ≤eT 
AT P + PA + L2P 2 + I

e
−2eT P
m
"
i=1
KiCe2i−1
(5.15)

5.3
Data Recovery
125
Considering that our interest lies in observers of order two or more (m ≥2):
2eT P
m
"
i=1
KiCe2i−1 = 2eT PK1Ce + (Ce)2 2eT PK2Ce +
· · · + (Ce)2m−2 2eT PKmCe
Deﬁning M1 = PK1C, M2 = PK2C,· · · , Mm = PKmC ≥0 and since eT Mme are
scalar numbers eT Mme = &eT Mme'T , then:
(Ce)0 eT M1e + (Ce)1 
eT M1e
T
· · ·
+ (Ce)2 eT M2e + (Ce)2 
eT M1e
T
· · ·
(Ce)2m−2 eT Mme + (Ce)2m−2 
eT Mme
T
=
m
"
i=1
(Ce)2i−2 eT 
Mi + MT
i

e
The last equation shows that 2eT P )m
i=1 KiCe2i−1 is deﬁnite positive then, the only
term that remains to be made deﬁnite negative is:
˙V ≤eT 
AT P + PA + L2P 2 + I

e
From the Assumption 5.1: AT P +PA+L2P 2+I ≤−εI, consequently ˙V ≤−ε ∥e∥2.
Consider that V = ∥e∥2 so α ∥e∥2
P ≤V ≤γ ∥e∥2
P , α = λmin(P), γ = λmax(P), then:
d
dt ∥e∥≤−ε
2γ ∥e∥
∥e(t)∥≤
*γ
α ∥e(0)∥exp

−ε
2γ t

By making ξ =
!
γ
α ∥e(0)∥and λ =
ε
2γ t:
∥e(t)∥≤ξexp (−λt)
⊓⊔

126
5
State Observers and Cryptography
This result shows that the transmitters oscillator states can be reconstructed and the
reconstruction error will decrease as time evolves.
5.3.3
Liouvillian System Properties Based Receiver
The design of this receiver is based on the property that makes a system be Liouvillian
(given in Deﬁnition 5.1), this property allows to reconstruct the states of a system without
the need of a state observer, so it is possible to create receivers that will not be affected
by the limitations of observers, and yet they will retain most of their security features, the
receiver dynamic is given by:
ˆx1 =
 
y −f

(y −d)dt

ˆx2 = y
ˆx3 =

(y −d)dt
(5.16)
With this receiver the error in the reconstruction of the key stream is zero:
e =
⎡
⎢⎣
x1 −ˆx1
x2 −ˆx2
x3 −ˆx3
⎤
⎥⎦= 0
(5.17)
=
⎡
⎢⎣
 
y −f
&
(y −d)dt
'
dt −
 
y −f
&
(y −d)dt
'
dt
y −y

(y −d)dt −

(y −d)dt
⎤
⎥⎦
This reconstruction requires that the initial conditions of the output state x2 be known,
this makes the encryption algorithm slightly different, the initial condition of the output is
formed by the ﬁrst section of the key:
x2 (0) =
ABCD
FFFF

E
The remaining initial conditions x1 and x3 will be formed by the plain image the same
way it was done in the case of the observer, with this modiﬁcation the trajectories of the
chaotic oscillator will depend on the image and key, in consequence if the message changes
the order of the shufﬂing and diffusion values will change as well. An important advantage
over the state observer is that there is no error in the reconstruction of the states nor there
is a waiting time for the states of the observer to reach the states of the chaotic oscillator.

5.3
Data Recovery
127
Observers have an error in the reconstruction of the states, if the error is big enough it
could carry over the decryption process, to overcome this the Julia set values are computed
with a ﬁxed precision given by a key element ε that contains information about the number
of decimals used for the fractal, then it is possible to say that if
∥e∥≪ε
The synchronization error will not affect the remaining part of the algorithm, then
from the synchronization error boundary provided by the observers proof of stability the
following condition is obtained:
∥e∥< ξ exp (−λt) < ε
The condition refers that if enough time has passed the exponential boundary will be
smaller than the desired value ε and in consequence so will be the error. The error of the
observer will directly affect the samples taken from the observer ˆksi, then if this sample
error is smaller than the allowed by the Julia set the observer error will not affect the
remaining decryption steps, this leads to the expression:
ksi −ˆksi
 < ε
Where ˆksi is the ith sample retrieved from the observer, these can be expressed as
ˆksi = ksi + ei which is the ith value generated by the oscillator plus the error given
by the observer in that speciﬁc sample, so:
|ksi −ksi −ei| < ε
ξ exp (−λt) < ε
ln
ε
ξ
−1
λ

< t
So the exponential observer guarantees that the error will not affect the data decryption
after 1
λln

ε
ξ
−1
seconds have passed and in the case of the reconstruction based receiver
waiting is not necessary as the error is zero at all time instants. It is also important to
mention that if an observer does not guarantees an error smaller than ε the decrypted data
will not be accurate.

128
5
State Observers and Cryptography
5.4
Numerical Simulation
Experimental results of the proposed encryption scheme are shown in this section using
an RGB color image. The image encryption is based on a Colpitts oscillator that generates
the shufﬂing and diffusion information. In the stage of decryption, the parameters of the
slave (the receiver system) are set to the values given by the key, thanks to the successful
chaotic synchronization obtained between master and slave systems the encrypted data can
be recovered. For the numerical simulation the exponential polynomial observer gains are
computed by means of the inequality PKiC > 0, resulting in k1 = [0.16, 16, 0.8]T and
k2 = [0.91, 2.15, 0]T .
The results obtained by both receivers are presented in Figs. 5.2 to 5.6. The encrypted
image generated with the observer is given by Fig. 5.3. The encrypted image generated by
the Liouvillian reconstruction is given in Fig. 5.4. The observer produces the image shown
in Fig. 5.5. The Liouvillian reconstruction provides the recovered image shown in Fig. 5.6.
Fig. 5.2 Plain image

5.5
Concluding Remarks
129
Fig. 5.3 Encrypted image by observer (a) and its red (b), green (c) and blue (d) histograms
Figures 5.2 and 5.3 show that the message is properly hidden, this is seen in the
histograms as the equal number of pixels with different intensity levels in red, green and
blue. The error in the reconstruction of the states provided by the observer, forces us to
use less precision while computing the diffusion and shufﬂing vectors, slightly reducing
the ability of the algorithm to withstand brute force attacks, in the case of the Liouvillian
reconstruction this is not necessary as there is no error in the reconstruction of the states.
5.5
Concluding Remarks
Using the chaotic nature of the oscillator allowed to produce great variation in the vectors
used for shufﬂing and diffusion depending on the message and by using a state observer
and the Liouvillian properties removed the limitation of having to provide more data than
the key and cipher, this feature greatly enhances the resistance to chosen plaintext or
known plaintext attacks which are one of the biggest threats to this type of algorithm.
Using the Julia set to reduce the relation between the key and the cypher image also
strengthens the security as the values provided by the norm of a complex number can

130
5
State Observers and Cryptography
Fig. 5.4 Encrypted image by the reconstruction (a) and its red (b), green (c) and blue (d) histograms
be formed by various different sets of real and complex parts, so a very large amount of
numbers can generate the same values thus making impossible to determine which one
was used further difﬁculting cryptanalysis. The properties of Liouvillian systems allowed
to use more decimals in the reconstruction of the states of the oscillator, in consequence
using larger keys is feasible. Another important advantage of the Liouvillian systems is
that there is no need to wait for the observer states to converge to the oscillators states,
then the implementation is faster, the vectors can be generated immediately, also, the
implementation of the transmitter is much more simple thus making the whole encryption
and decryption process much faster. It must be remarked that all this beneﬁts are achieved
without sacriﬁcing any of the security features of the observer.

5.5
Concluding Remarks
131
Fig. 5.5 Recovered image by the observer (a) and its red (b), green (c) and blue (d) histograms

132
5
State Observers and Cryptography
Fig. 5.6 Recovered image by the reconstruction (a) and its red (b), green (c) and blue (d) histograms
References
1. Chua, L. O., Kocarev, L., Eckert, K., & Itoh, M. (1992). Experimental chaos synchronization in
Chua’s circuit. International Journal of Bifurcation and Chaos, 2(3), 705–708.
2. Alvarez, G., & Li, S. (2006). Some basic cryptographic requirements for chaos-based cryptosys-
tems. International Journal of Bifurcation and Chaos, 16(8), 2129–2151 (2006).
3. Yong-Ping, Z., & Shu-Tang, L. (2008). Gradient control and synchronization of Julia sets. Chinese
Physics B, 17, 543–549.
4. Hassan, M. F. (2014). Observer design for constrained nonlinear systems with application to
secure communication. Journal of the Franklin Institute, 351(2), 1001–1026.
5. Castro-Ramírez, J., Martínez-Guerra, R., & Cruz-Victoria, J. C. (2015). A new reduced-order
observer for the synchronization of nonlinear chaotic systems: An application to secure commu-
nications. Chaos: An Interdisciplinary Journal of Nonlinear Science, 25(10), 103128.
6. Martínez-Guerra, R., Gómez-Cortés, G. C., & Pérez-Pinacho, C. A. (2015). Synchronization of
integral and fractional order chaotic systems a differential algebraic and differential geometric
approach with selected applications in real-time. Springer.

6
Fractional Systems
Abstract
This chapter focuses on properties, classical results, and applications of Gamma and
Beta functions. The theory presented in this chapter is useful for the development of
fractional calculus theory and the solution of fractional differential equations, presented
in the following chapters.
6.1
Gamma Function
Deﬁnition 6.1 Let f be a piecewise continuous function on every ﬁnite interval in [0, ∞).
If there exist constants M > 0 and α such that
|f (t)| ≤Meαt, ∀t ∈[0, ∞).
(6.1)
Then it is said that f (t) has exponential order α.
Deﬁnition 6.2 Let f (t) be an arbitrary function with exponential order; then the integral
F(s) = L {f (t)} =
 ∞
0
e−stf (t)dt
(6.2)
is called the Laplace transform of f (t).
Remark 6.1 The exponential order α of a function f (t) guarantees the existence of
L {f (t)} for s > α, and the Lerch’s Theorem can justify the uniqueness.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_6
133

134
6
Fractional Systems
Exercise 6.1 Show that f (t) = tn has exponential order α for any α > 0, n ∈N.
According to the previous exercise, consider the integral
I =
 ∞
0
e−sttn−1dt.
It is not difﬁcult to show, with τ = st that
I = 1
sn
 ∞
0
e−ττ n−1dτ = K(n)
sn
where the integral K(n) depends only on n and appears in many theoretical and applied
problems in science and engineering.
Deﬁnition 6.3 The function Γ : (0, ∞) →R given by
Γ (z) =
 ∞
0
tz−1e−tdt
(6.3)
is called gamma function.
Although the function (6.3) is deﬁned for z ∈(0, ∞), this domain can be extended
to a more general set, for example the complex numbers C. The only condition is that
Re(z) ∈R\

Z−∪{0}
since in the zero and in the negative integers, the Gamma function
has simple poles. To show this, note that
Γ (z) =
 1
0
tz−1e−tdt
+
,-
.
(1)
+
 ∞
1
tz−1e−tdt
+
,-
.
(2)
(6.4)
For the integral (1):
 1
0
tz−1e−tdt =
 1
0
∞
"
k=0
(−t)k
k!
tz−1dt =
∞
"
k=0
(−1)k
k!
 1
0
tk+z−1dt =
∞
"
k=0
(−1)k
(k + z)k!
This series is convergent except where one of the terms has a simple pole, i.e., at z =
−k, k ≥0, with residue (−1)k/k!. On the other hand, the integral (2) is an entire function,
so that Γ (z) is a meromorphic function [1].
Example 6.1 Using the deﬁnition of the gamma function, calculate Γ (1).

6.1
Gamma Function
135
Solution
Γ (1) =
 ∞
0
t1−1e−tdt = lim
k→∞
 k
0
e−tdt = lim
k→∞
&
−e−t'k
0 = lim
k→∞

−e−k + 1

= 1
6.1.1
Some Properties of the Gamma Function
Now, we present some properties of the Gamma function.
Theorem 6.1 If x > −1, then
Γ (x + 1) = xΓ (x)
(6.5)
Proof Directly from the deﬁnition and using integration by parts:
Γ (x + 1) =
 ∞
0
txe−tdt
=
lim
z→∞,y→0+
 z
y
txe−tdt
=
lim
z→∞,y→0+

−txe−tz
y +
 z
y
tx−1e−tdt

=
lim
z→∞,y→0+ x
 z
y
tx−1e−tdt
= x
 ∞
0
tx−1e−tdt
= xΓ (x)
⊓⊔
Example 6.2 Calculate Γ (2).
Solution
By the Theorem 6.1 and the Example 6.1, we have
Γ (2) = Γ (1 + 1) = 1Γ (1) = 1
Theorem 6.2 Let n ∈N, then

136
6
Fractional Systems
(n −1)! = Γ (n), ∀n
(6.6)
Proof Using induction over n. Let A be the set of positive integers such that satisfy (6.6),
i.e.,
A = {n ∈N|(n −1)! = Γ (n)}
Firstly, we verify that 1 ∈A. Indeed,
(1 −1)! = 0! = 1 = Γ (1).
Let us prove the induction step. Suppose that n ∈A (induction hypothesis), i.e., (n −
1)! = Γ (n) and prove that n+1 ∈A. By the Theorem 6.1 we have that Γ (n+1) = nΓ (n),
then
Γ (n + 1) = nΓ (n) = n (n −1)! = n! = ((n + 1) −1)!
We have shown that n + 1 ∈A. Given 1 ∈A and for every positive integer n belonging
to the set A, the number n + 1 ∈A. Then, by using the mathematical induction principle
A = N and (6.6) is valid for every natural number n. For more details about mathematical
induction see [2–4].
⊓⊔
Theorem 6.3 (The Gauss Error Integral)
Γ (x) = 2
 ∞
0
z2x−1e−z2dz
(6.7)
Proof Let t = z2, then dt = 2zdz. According to this change of variable, in the integral
(6.3), when t = 0, z = 0 and z = ∞if t = ∞. Then
Γ (x) =
 ∞
0

z2x−1
e−z22zdz
= 2
 ∞
0
z2x−1e−z2dz
= 2
 ∞
0
z2x−1e−z2dz.
⊓⊔

6.1
Gamma Function
137
Theorem 6.4
 π/2
0
cos2x−1 θ sin2x−1 θdθ = Γ (x)Γ (y)
2Γ (x + y)
(6.8)
Proof To prove the expression (6.8), let us consider the following integral:
I =
 ∞
0
 ∞
0
e−τ 2−ν2τ 2x−1ν2y−1dτdν
=
 ∞
0
τ 2x−1e−τ 2dτ
 ∞
0
ν2y−1e−ν2dν
= Γ (x)
2
Γ (y)
2
(6.9)
where Eq.(6.7) was considered. On the other hand, we consider the integral I in polar
coordinates. Let τ = r cos θ and ν = r sin θ, then
I =
 
R
exp

−r2 cos2 θ −r2 sin2 θ

(r cos θ)2x−1 (r sin θ)2y−1 rdrdθ
=
 ∞
0
 π/2
0
e−r2r2x−1 cos2x−1 θr2y−1 sin2x−1 θrdrdθ
=
 ∞
0
e−r2r2(x+y)−1dr
 π/2
0
cos2x−1 θ sin2x−1 θdθ
Now, by using Eq.(6.7) one has that
I = 1
2Γ (x + y)
 π/2
0
cos2x−1 θ sin2x−1 θdθ
(6.10)
Finally from expressions (6.9) and (6.10), Eq. (6.8) is direct. This completes the proof.
⊓⊔
Corollary 6.1
Γ
1
2

= √π
(6.11)

138
6
Fractional Systems
Proof In the expression (6.8), let x = y = 1
2. Then
 π/2
0
dθ =
Γ

1
2

Γ

1
2

2Γ (1)
π
2 = 1
2

Γ
1
2
2
π =

Γ
1
2
2
and the result follows directly.
⊓⊔
Corollary 6.2
 ∞
0
e−t2dt =
√π
2
(6.12)
Proof In Eq. (6.7) with x = 1/2:
Γ
1
2

= 2
 ∞
0
e−t2dt
The proof concludes applying the Corollary 6.1.
⊓⊔
6.2
Beta Function
Deﬁnition 6.4 The beta function is deﬁned as
β(x, y) =
 1
0
tx−1 (1 −t)y−1 dt
(6.13)
Theorem 6.5
β(x, y) = Γ (x)Γ (y)
Γ (x + y)
(6.14)
Proof Let t = cos2 θ. According to this change of variable, the integral (6.13) can be
rewritten as follows:
β(x, y) =
 π/2
0

cos2 θ
x−1 
sin2 θ
y−1
2 cosθ sin θdθ
= 2
 π/2
0
cos2x−1 θ sin2x−1 θdθ
(6.15)

6.2
Beta Function
139
Finally from the Theorem 6.4, the result is immediate.
⊓⊔
Remark 6.2 Another way to prove the previous result is through the Laplace transform.
Consider the following convolution
hx,y(t) = tx−1 ∗ty−1 =
 t
0
(t −τ)y−1 τ x−1dτ
Note that hx,y(1) = β(x, y). Applying the Laplace transform to hx,y(t), one has
Hx,y(s) = L
/
hx,y(t)
0
= Γ (x)
sx
Γ (y)
sy
= Γ (x)Γ (y)
sx+y
On the other hand, note that
L −1
1Γ (x)Γ (y)
sx+y
2
= Γ (x)Γ (y)L −1
1
1
sx+y
2
= Γ (x)Γ (y)
Γ (x + y) tx+y−1 = hx,y(t)
Therefore, if t = 1:
β(x, y) = Γ (x)Γ (y)
Γ (x + y)
According to the axioms of the real numbers, the following result is immediate.
Theorem 6.6
β(x, y) = β(y, x)
(6.16)
Proof By the equality on the Theorem 6.5 and considering that Γ : (0, ∞) →R, we have
β(x, y) = Γ (x)Γ (y)
Γ (x + y) = Γ (y)Γ (x)
Γ (y + x) = β(y, x)
⊓⊔
Theorem 6.7
β(x + 1, y) =
x
x + y β(x, y)
(6.17)
β(x, y + 1) =
y
x + y β(x, y)
(6.18)

140
6
Fractional Systems
Proof For (6.17), directly from Eq. (6.14) and using the Theorem 6.1:
β(x + 1, y) = Γ (x + 1)Γ (y)
Γ (x + y + 1) =
xΓ (x)Γ (y)
(x + y)Γ (x + y) =
x
x + y β(x, y)
The proof of (6.18) is similar and it is left to the reader as an exercise.
⊓⊔
Theorem 6.8 (Legendre Duplication Formula)
Γ (2x) = 22x−1
√π Γ (x)Γ

x + 1
2

(6.19)
Proof Using the deﬁnition of Beta function and its equivalence (6.14):
β(x, x) = Γ (x)Γ (x)
Γ (2x)
=
 1
0
tx−1 (1 −t)x−1 dt
Let t = 1
2(1 + s), then
β(x, x) = 1
2
 1
−1
1
2x−1 (1 −s)x−1
1
2x−1 (1 + s)x−1 ds
=
1
22x−1
 1
−1

1 −s2x−1
ds
=
2
22x−1
 1
0

1 −s2x−1
ds
On the other hand, let ω = s2, then
β(x, x) = 22−2x
 1
0
(1 −ω)x−1 1
2ω−1/2dω
= 2−2x+1
 1
0
(1 −ω)x−1 1
2ω−1/2+1−1dω
= 2−2x+1β

x, 1
2

Therefore
Γ (x)Γ (x)
Γ (2x)
= 2−2x+1 Γ (x)Γ

1
2

Γ

x + 1
2


6.3
Euler’s Number and Its Relation to the Gamma Function
141
Considering that Γ

1
2

= √π, the proof is complete.
⊓⊔
Corollary 6.3 Let x ∈Z+. Then
Γ

x + 1
2

= (2x)!
22xx!
√π
(6.20)
Proof From the duplication formula (6.19), and applying the property (6.5):
Γ

x + 1
2

= Γ (2x)√π2−2x+1
Γ (x)
= 2xΓ (2x)√π
22xxΓ (x)
= Γ (2x + 1)√π
22xΓ (x + 1)
Note that 2x + 1 ∈Z+ because x ∈Z+. Then applying the relation (6.6), the result is
obtained and the proof is complete.
⊓⊔
An interesting property that establish a relationship with the gamma function and the
number π is given in the following result.
Theorem 6.9
Γ (x)Γ (1 −x) =
π
sin(πx)
(6.21)
6.3
Euler’s Number and Its Relation to the Gamma Function
According to the Euler’s number
e−t = lim
n→∞

1 −t
n
n
the Gamma function (6.3) is written as follows:
Γ (x) = lim
n→∞
 n
0

1 −t
n
n
tx−1dt

142
6
Fractional Systems
Let t = ns, then
Γ (x) = lim
n→∞nx
 1
0
(1 −s)nsx−1ds
+
,-
.
β(n+1,x)
On the other hand,
β(n + 1, x) = Γ (n + 1)Γ (x)
Γ (n + x + 1) = n!(x −1)!
(x + n)! =
n!
x(x + 1)(x + 2) . . .(x + n)
so that,
Γ (x) = lim
n→∞
nxn!
x(x + 1)(x + 2) . . . (x + n)
= 1
x lim
n→∞

1
x + 1
 
2
x + 2
 
3
x + 3

. . .

n
x + n

·
2x · 3x . . . (n −1)xnx
1x · 2x . . . (n −2)x(n −1)x
Note that
2x · 3x . . . (n −1)xnx
1x · 2x . . . (n −2)x(n −1)x =
2
1
x 3
2
x 4
3
x
. . .
n −1
n −2
x 
n
n −1
x
=

1 + 1
1
x 
1 + 1
2
x 
1 + 1
3
x
. . .

1 +
1
n −2
x 
1 +
1
n −1
x
and
n
x + n =
x + n
n
−1
=

1 + x
n
−1
Therefore, the gamma function can be rewritten as follows
Γ (x) = 1
x
∞
3
n=1

1 + 1
n
x 
1 + x
n
−1
(6.22)

6.3
Euler’s Number and Its Relation to the Gamma Function
143
Based in the previous deﬁnition of the Gamma function, we proportionate the following
alternative proof for Theorem 6.1.
Γ (z + 1)
Γ (z)
=
1
z+1
4∞
n=1

1 + 1
n
z+1 
1 + z+1
n
−1
1
z
4∞
n=1

1 + 1
n
z 
1 + z
n
−1
=
z
z + 1
limN→∞
4N
n=1

1 + 1
n

limN→∞
4N
n=1(n + z)
limN→∞
4N
n=1(n + z + 1)
where
lim
N→∞
N
3
n=1

1 + 1
n

= lim
N→∞
N
3
n=1
n + 1
n

= lim
N→∞
4N
n=1(n + 1)
4N
n=1 n
= lim
N→∞
2 · 3 · 4 · 5 . . . (N + 1)
1 · 2 · 3 · 4 . . .N
= lim
N→∞
N!(N + 1)
N!
= lim
N→∞(N + 1)
and
limN→∞
4N
n=1(n + z)
limN→∞
4N
n=1(n + z + 1)
= lim
N→∞
(1 + z)(2 + z)(3 + z) . . .(N + z)
(2 + z)(3 + z) . . .(N + z)(N + z + 1)
= lim
N→∞
1 + z
N + z + 1
Therefore
Γ (z + 1)
Γ (z)
=
z
z + 1 lim
N→∞
(N + 1)(z + 1)
N + z + 1
= z lim
N→∞
N + 1
N + z + 1
= z
since limN→∞
N+1
N+z+1 = 1, so that Γ (z + 1) = zΓ (z) as in Theorem 6.1.

144
6
Fractional Systems
Lemma 6.1 Let b > a, m > 0, n > 0. Then
 b
a
(b −x)m−1 (x −a)n−1 dx = (b −a)m+n−1 β(m, n).
(6.23)
Proof Let x = a+y(b−a). Then (b−x)m−1(x −a)n−1 = (b−a)m+n−2(1−y)m−1yn−1,
dx = (b −a)dy, and
(
y = 0,
if
x = a
y = 1,
if
x = b
Therefore
 b
a
(b −x)m−1 (x −a)n−1 dx = (b −a)m+n−1
 1
0
(1 −y)m−1 yn−1dy = β(m, n).
⊓⊔
Lemma 6.2 Let m > −1, p > −1, n > 0. Then
 1
0
xm 1 −xnp dx = 1
nβ
m + 1
n
, p + 1

.
(6.24)
Proof Let y = xn, then dy = nxn−1dx. Hence
 1
0
xm 1 −xnp dx =
 1
0
xm (1 −y)p
dy
nxn−1
= 1
n
 1
0
xm−n+1 (1 −y)p dy
= 1
n
 1
0
y
m+1
n −1 (1 −y)p dy
= 1
nβ
m + 1
n
, p + 1

⊓⊔
6.4
Miscellaneous Examples
To show the application of the previous theory about gamma and beta functions, we now
provide a list of solved exercises.

6.4
Miscellaneous Examples
145
Exercise 6.2 Prove that
 ∞
0
e−axxndx =
1
an+1 Γ (n + 1), for n > −1, a > 0.
Solution
Let ax = u, then
 ∞
0
e−axxndx =
 ∞
0
e−u u
a
n du
a
=
1
an+1
 ∞
0
e−uundu
=
1
an+1 Γ (n + 1)
⊓⊔
Exercise 6.3 Prove that
 ∞
0
xme−xndx = 1
nΓ

m+1
n

, for m > −1, n > 0.
Solution
Let u = xn, then
 ∞
0
xme−xndx =
 ∞
0
um/ne−u du
n u(1−n)/n
= 1
n
 ∞
0
e−uu
m+1
n −1du
= 1
nΓ
m + 1
n

⊓⊔
Exercise 6.4 Prove that
 ∞
a
e2ax−x2dx =
√π
2 ea2.
Solution
Let u = x −a, then u2 = (x −a)2 = x2 −2ax + a2. Based on this change of variable, if
x = a, then u = 0, and for x = ∞, u = ∞. Besides 2udu = 2(x −a)dx and
dx = udu
x −a = x −a
x −a du = du

146
6
Fractional Systems
Therefore, and using the Corollary 6.2:
 ∞
a
e2ax−x2dx =
 ∞
0
ea2−u2du
= ea2  ∞
0
e−u2du
= ea2 √π
2
⊓⊔
Exercise 6.5 Prove that  π/2
0
tann θdθ = 1
2Γ

1+n
2

Γ

1−n
2

, for |n| < 1.
Solution
It is clear that tann θ = cos−n θ sinn θ. Then, by using the Theorem 6.4 with x = 1−n
2
and
y = 1+n
2 :
 π/2
0
tann θdθ =
 π/2
0
cos−n θ sinn θdθ
=
 π/2
0
cos
2

1−n
2

−1 θ sin
2

n+1
2

−1 θdθ
= 1
2
Γ

1+n
2

Γ

1−n
2

Γ (1)
The result is immediate considering that Γ (1) = 1.
⊓⊔
Exercise 6.6 Prove that
 π/2
0
sinn θdθ =
 π/2
0
cosn θdθ =
√π
2
=
Γ

n+1
2

Γ

n+2
2
.
Solution
In Eq. (6.8), if x = 1
2 and y = n+1
2 , then
 π/2
0
sinn θdθ =
Γ

1
2

Γ

n+1
2

2Γ

n+2
2


6.4
Miscellaneous Examples
147
On the other hand, if x = n+1
2
and y = 1
2, then
 π/2
0
cosn θdθ =
Γ

1
2

Γ

n+1
2

2Γ

n+2
2

Finally considering that Γ

1
2

= √π, the result is immediate.
⊓⊔
Exercise 6.7 Solve
 ∞
−∞3x3 
x3 + 1
2 e−x6−2x3dx.
Solution
From the Theorems 6.1 and 6.3, for x = 3
2 we have
Γ
3
2

= 2
 ∞
0
z2e−z2dz = Γ
1
2 + 1

= 1
2Γ
1
2

=
√π
2
On the other hand, let u2 =

x3 + 1
2 = x6 + 2x3 + 1, then
 ∞
−∞
3x2 
x3 + 1
2
e−x6−2x3dx = e
 ∞
−∞
e−u2u2du
= e

2
 ∞
0
e−u2u2du

= e√π
2
Exercise 6.8 Solve the integral I =  π/2
0
√
tan θdθ.
Solution
Firstly, note that
√
tan θ =
*
sin θ
cos θ = (sin θ)1/2 (cos θ)−1/2
then by using the Theorem 6.4 with x = 1
4 and y = 3
4:
I = 1
2
Γ

1
4

Γ

3
4

Γ (1)
= 1
2Γ
1
4

Γ

1 −1
4


148
6
Fractional Systems
Finally, by using the Theorem 6.9 we have
I = 1
2
π
sin
 π
4
 =
√
2
2 π
Exercise 6.9 Solve the integral I =
 1
0
dx
3√
1−x3 .
Solution
The integral can be written as follows
I =
 1
0

1 −x3−1/3
dx
If we make the substitution t = x3, we obtain dt = 3x2dx and x =
3√x. Therefore, by
using the beta function and Eq. (6.21):
I = 1
3
 1
0
(1 −t)−1/3 t−2/3
= 1
3β
2
3, 1
3

= 1
3
Γ

2
3

Γ

1
3

Γ (1)
= 1
3
Γ

1
3

Γ

1 −1
3

Γ (1)
= 1
3
π
sin
 π
3

= 2π
3
√
3
Exercise 6.10 Evaluate  ∞
0
t−3/2 1 −e−t dt.

6.4
Miscellaneous Examples
149
Solution
By using integration by parts and the Gauss error integral:
 ∞
0
t−3/2 1 −e−t dt = −2t−1/2 1 −e−t |∞
0 + 2
 ∞
0
t−1/2e−tdt
= 2
 ∞
0
t1/2−1e−tdt
= 2Γ
1
2

= 2√π
Note that the ﬁrst term of the right-hand side in the integral by part is zero.
Exercise 6.11 Calculate
 1
−1

1+x
1−x
1/2
dx.
Solution
The substitution t = 1
2(1 + x) is useful because dx = 2dt. Further
(
t = 0,
if
x = −1
t = 1,
if
x = 1
Therefore
 1
−1
1 + x
1 −x
1/2
dx =
 1
0

2t
2(1 −t)
1/2
2dt
= 2
 1
0
(1 −t)−1/2t1/2dt
= 2β
1
2, 3
2

= 2
Γ

1
3

Γ

3
2

Γ (2)
By the Theorem 6.1, Γ

3
2

= Γ

1
2 + 1

= 1
2Γ

1
2

, and recalling Example 6.2 we
have that
 1
−1
1 + x
1 −x
1/2
dx =

Γ
1
2
2
= π

150
6
Fractional Systems
Exercise 6.12 Prove that β(n, n + 1) = 1
2
[Γ (n)]2
Γ (2n) , and by using this equality, show that
 π/2
0

1
sin3 θ
−
1
sin2 θ
1/4
cos θdx =

Γ

1
4
2
2√π
.
Solution
Using the equality from the Theorem 6.5,
β(n, n + 1) = Γ (n)Γ (n + 1)
Γ (2n + 1)
= nΓ (n)Γ (n)
2nΓ (2n)
= 1
2
[Γ (n)]2
Γ (2n) .
If n = 1
4, then
β
1
4, 5
4

= 1
2

Γ

1
4
2
Γ

1
2

=

Γ

1
4
2
2√π
.
On the other hand, from the deﬁnition of the beta function
I = β
1
4, 5
4

=
 1
0
(1 −t)1/4t−3/4dt.
With the substitution t = sin θ, we obtain dt = cos θdθ. Then
I =
 π/2
0
(sin θ)−3/4 (1 −sin θ)1/4 cos θdθ =
 π/2
0
1 −sin θ
sin3 θ
1/4
cos θdθ
This concludes the proof.
⊓⊔
Exercise 6.13 Simplify the integral
 1
0

1
x −1
1/4
dx.
Solution
Employing the properties for the gamma and beta function as in the previous examples,
we have
 1
0
 1
x −1
1/4
dx =
 1
0
x−1/4 (1 −x)1/4 dx = β
3
4, 5
4

=
Γ

3
4

Γ

5
4

Γ (2)

6.5
Fractional-Order Differential Equations
151
= Γ
3
4

Γ

1 + 1
4

= 1
4Γ
1
4

Γ
3
4

= 1
4Γ
1
4

Γ

1 −1
4

= 1
4
π
sin
 π
4

=
√
2π
4
Exercise 6.14 Simplify the integral
 1
0

ln 1
x
a−1
dx, a > 0.
Solution
The substitution x = e−t is useful because 1
x = et and t = ln

1
x

, so that

ln1
x
a−1
= ta−1
and dx = −e−tdt. In addition, from the change of variable
(
t →∞,
if
x →0
t = 0,
if
x = 1
Therefore
 1
0

ln1
x
a−1
dx =
 ∞
0
ta−1e−tdt = Γ (a)
6.5
Fractional-Order Differential Equations
In the following, some linear ordinary differential equations of fractional-order will be
solve by means of the Laplace transform method.

152
6
Fractional Systems
6.5.1
Laplace Transform of Fractional-Order Functions
Let us remember the formula to obtain the Laplace transform of a function f (t),
L =
 ∞
0
f (t)e−stdt
which is used to convert the function from the time domain (t) to the frequency domain (s)
[5].
Example 6.3 The Laplace transform of f (t) = ent is
L &ent' =
 ∞
0
ente−stdt
=
 ∞
0
e(n−s)tdt
=
 ∞
0
e−(s−n)tdt
=

−
1
s −ne−(s−n)t
∞
0
= −
1
s −n

e−∞−e0
= −
1
s −n [0 −1]
=
1
s −n
Example 6.4 The Laplace transform of f (t) = Eα,β (ntα) is
L
&
Eα,β

ntα'
=
 ∞
0
Eα,β

ntα
e−stdt
=
 ∞
0
∞
"
k=0
(ntα)k
Γ (αk + β)e−stdt
=
∞
"
k=0
nk
Γ (αk + β)
 ∞
0
tαke−stdt

6.5
Fractional-Order Differential Equations
153
= tβ−1
∞
"
k=0
nk
Γ (αk + β)
 ∞
0
tαke−stdt
=
∞
"
k=0
nk
Γ (αk + β)
 ∞
0
tαk+β−1e−stdt
Consider the following change of variable
x = st
dx = sdt
Then we have
L &Eα,β
ntα' =
∞
"
k=0
nk
Γ (αk + β)
 ∞
0
x
s
αk+β−1
e−x 1
s dx
=
∞
"
k=0
nk
Γ (αk + β)
1
sαk+β
 ∞
0
xαk+β−1e−xdx
=
∞
"
k=0
nk
Γ (αk + β)
1
sαk+β Γ (αk + β)
=
∞
"
k=0
nk
1
sαk+β
= s−β
∞
"
k=0
(ns−α)k
=
s−β
1 −ns−α
= sα−β
sα −n
In the following, some relevant functions and integral operators and their corresponding
Laplace transforms are shown.
Observe the similarities between the Laplace transform of the integer and the fractional-
order functions, remembering that the Mittag-Lefﬂer function is a generalization of the
exponential function. Moreover, the Laplace transform of the differential and integral
operators is shown, as well as the Laplace transform of the convolution between two time
functions.

154
6
Fractional Systems
Table 6.1 Laplace transform
of some basic functions
f (t)
F(s)
f (t)
F(s)
tn
n!
sn+1
Eα(−atα)
sα−1
sα+a
tα
Γ (α+1)
sα+1
tαE1,1+α(−at)
s−α
s+a
e−at
1
s+a
tα−1Eα,α(−atα)
1
sα+a
tne−at
n!
(s+a)n+1 tβ−1Eα,β(−atα) sα−β
sα+a
Table 6.2 Laplace transforms of integral operators
f (t)
F(s)
f (t) ∗g(t) =
 t
0 f (τ)g(t −τ)dτ = g(t) ∗f (t) =
 t
0 g(τ)f (t −τ)dτ
F(s)G(s)
Inf (t)
F(s)
sn
= s−nF(s)
RLIαf (t)
s−αF(s)
6.5.2
Solution of FODE by Means of the Laplace Transform
In this section, a couple of linear fractional-order ordinary differential equations (FODE)
will be solve by means of the Laplace transform, with the aid of the formulas given in
Tables 6.1 and 6.2.
Example 6.5 Consider the following linear homogeneous FODE
RL
0 D1/2
t
f (t) + af (t) = 0,
0D−1/2
t
f (0) = C
Observe the fractional-order initial conditions required for this problem. Applying the
Laplace transform, we have
s1/2F(s) −f −1/2(0) + aF(s) = 0
s1/2F(s) −C + aF(s) = 0

s1/2 + a

F(s) = C
F(s) =
C
s1/2 + a
Finally, applying inverse Laplace transform, we have
f (t) = Ct−1/2E 1
2 , 1
2

−at−1/2

6.5
Fractional-Order Differential Equations
155
Example 6.6 Consider the following linear nonhomogeneous FODE
RL
0 DQ
t f (t) + RL
0 Dq
t f (t) = h(t)
Applying the Laplace transform to this equation, and considering 0 < q < Q < 1, we
have
sQF(s) −f Q−1(0) + sqF(s) −f q−1(0) = H(s)
(sQ + sq)F(s) = C + H(s)
where
C = f Q−1(0) + f q−1(0)
Hence
F(s) = C + H(s)
sQ + sq
In order to ﬁnd a suitable Laplace transform for this function, the following arrangement
is done
F(s) =
C + H(s)
sq(sQ−q + 1)
=
Cs−q
sQ−q + 1 + H(s)
s−q
sQ−q + 1
Consider ﬁrst the left part. Applying the inverse Laplace transform we have
L −1

Cs−q
sQ−q + q

= CtQ−1EQ−q,Q

−tQ−q
For the right part, note that it comprises a convolution
L −1

H(s)
s−q
sQ−q + 1

= L −1 [H(s)] ∗L −1

s−q
sQ −q + 1

= h(t) ∗tQ−1EQ−q,Q

−tQ−q
Therefore
f (t) = CG(t) +
 t
0
G(t −τ)h(τ)dτ

156
6
Fractional Systems
where
G(t) = tQ−1EQ−q,Q

−tQ−q
6.6
Fractional Dynamical System
As it has been mentioned, fractional-order dynamical systems, in contrast with the
integer-order ones, have been studied strongly in the last decades. This is due to the
great amount of applications and physical phenomena whose dynamics present fractional
derivatives and integrals, such as diffusion problems, viscoelasticity, polymeric behaviour,
ﬁnancial systems, biological systems, damped mechanical systems, electric circuits,
electrochemistry, rheology, fractals and heat propagation. Particularly, in control theory
one of the most important contributions has been the development of generalized PID
controllers, as well as other fractional-order controllers such as the CRONE and the
fractional-order sliding mode controller. Nowadays almost every kind of controller has
been extended to its fractional counterpart.
6.6.1
Commensurate Fractional-Order Systems
There exist different deﬁnitions for these kind of systems, e.g. the following, which is
found in [6].
Deﬁnition 6.5 The fractional differential equation
g(x, y(x), Dn1
∗0y(x), Dn2
∗0y(x), . . ., Dnk
∗0y(x)) = 0
with 0 < n1 < n2 < · · · < nk and a certain function g is called commensurate if the
numbers n1, n2, . . . , nk are commensurate, i.e. if the quotients nμ/nν are rational numbers
for all μ, ν ∈{1, 2, . . . , k}.
In this case, the author uses this deﬁnition because it is related to the traditional use of
the concept common in number theory. However, in this book the following deﬁnition will
be used, from [7].
Deﬁnition 6.6 Consider the following model in state space:
Dαx = Ax + Bu
y = Cx

References
157
where x ∈Rn, u ∈Rr and y ∈Rp, α = [α1, α2, . . . , αn]T is the vector of fractional
orders. If α1 = α2 = · · · = αn = α ∈R, the system is called commensurate, otherwise it
is an incommensurate system.
For this text purposes, consider the following class of commensurate fractional-order
nonlinear systems with unknown inputs:
Dαx = g(x, u, f )
y = h(x, u)
where x ∈Rn is the state vector, u ∈Rm is the input (control) vector, f ∈Rq is the
unknown input vector, y ∈Rp is the output vector, α = (α1, . . . , αn), g and h are analytic
functions. Particularly, in this book 0 < α < 1 will be used.
6.6.2
Incommensurate Fractional-Order Systems
As stated in the past subsection, if a fractional-order system is not commensurate, it is
called an incommensurate system. Consider the following.
Deﬁnition 6.7 Consider the following model:
Dαixi = fi(x1, x2, . . . , xn)
where x ∈Rn, 1 ≤i ≤n, i ∈Z+. If αi ̸= αj for at least one value of i, the system is
called incommensurate.
References
1. Kleinz, M., & Osler, T. J. (2000). A child’s garden of fractional derivatives. The College
Mathematics Journal, 31(2), 82–88.
2. Hilfer, R., Butzer, P. L., & Westphal, U. (2010). An introduction to fractional calculus. In
Applications of fractional calculus in physics (pp. 1–85). World Scientiﬁc.
3. Lang, S. (1977). Complex analysis. Reading, MA: Addison-Wesley.
4. Martinez-Guerra, R., Martinez-Fuentes, O., & Montesinos-Garcia, J. J. (2019). Algebraic and
differential methods for nonlinear control theory. In Elements of commutative algebra and
algebraic geometry. Springer.
5. Schiff, J. L. (1999). The Laplace transform. Theory and applications. New York: Springer.
6. Diethelm, K. (2010). The analysis of fractional differential equations: An application-oriented
exposition using differential operators of caputo type. Berlin: Springer.
7. Petrás, I. (2011). Fractional-order nonlinear systems: Modeling, analysis and simulation. Beijing:
Springer.

7
Fractional-Order Liouvillian Systems
and Encryption
Abstract
This chapter introduces a method for the numerical estimation of the fractional
derivative of a signal, a smoothed sliding modes state observer is used to make the
estimation. As application for the estimator a color image encryption algorithm is given,
the algorithm is based on the synchronization of fractional chaotic Liouvillian systems
and its main characteristics are the capability to keep data safe from the most common
types of cryptanalysis and handling large color images while producing no data loss.
7.1
Introduction
Since its introduction by Pecora and Carroll [1], synchronization of chaotic systems
has been extensively studied in various ﬁelds [2–4], in recent years many studies have
emerged from the perspective of fractional calculus [5, 6], using fractional calculus
involves new challenges for its differences with traditional calculus, although chaotic
system synchronization is one of its many applications, fractional calculus has many others
[7–12].
A relevant application to fractional chaotic system synchronization is secure communi-
cations, there have been various advances in secure communications that use fractional
order chaotic systems [13–23] that are mostly stream ciphers, these ciphers employ
many different methods to modify messages, such as logistic maps, DNA coding,
transformations and synchronization like coupled systems synchronization, projective syn-
chronization, observer based synchronization and even delayed systems synchronization.
There are also block ciphers based on synchronization, although most of them consist on
modiﬁcations to widely used algorithms such as AES.
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_7
159

160
7
Fractional-Order Liouvillian Systems and Encryption
Some of the mentioned algorithms rely on state observers to achieve synchronization,
while this is helpful when dealing with uncertainties, they can have estimation error and
if the encrypted data is not handled carefully this error can affect the data reconstruction
and cause data loss. Another interesting feature is that not all of the cited ciphers make
the numbers used for encryption change if the message is changed, this characteristic can
be exploited by an attacker to recover useful data that could ﬁnally lead to breaking the
algorithm.
There have been many advances in control of chaotic systems [24–28], these proposals
could produce good results when applied to secure communications, also interesting
publications in sliding modes for fractional systems [29–31] and state estimation of
fractional systems [32–43] have been made. Most sliding modes based state observers
have the chattering effect, thus making them unsuitable for applications where accuracy
on the reconstruction of a state is of most importance, to contribute to these works, the
authors propose a smoothed sliding modes state observer for estimation of derivatives, this
observer does not produce noticeable chattering and performs very well for the purpose
of data reconstruction without error, thanks to the lack of chattering and its resilience to
uncertainties in the system dynamic.
Fractional Liouvillian systems are a class of nonlinear fractional chaotic systems,
they allow to reconstruct their states without the need of a state estimator, instead the
reconstruction is done by using the output, this characteristic is desirable in secure
communications, as it reduces the complexity of the receiver as well as the time required
to reach synchronization, another remarkable characteristic is that the reconstruction error
is zero at all times. There are no reported uses of this type of systems in the literature
regarding encryption by fractional chaotic systems, therefore this work presents their
usefulness and how to use their more prominent characteristics.
The rest of the chapter is organized as follows: Sect. 7.2 presents preliminaries and
important results, Sect. 7.3 contains the fractional derivative estimation via the smoothed
sliding modes observer, in Sect. 7.4 the encryption algorithm is given, Sect. 7.5 shows the
decryption process, in Sect. 7.6 numerical results are shown, in Sect. 7.7 a security analysis
to test the performance of the algorithm is made and ﬁnally in Sect. 7.8 some conclusions
are made.
7.2
Preliminaries
Before proceeding to the main result and the encryption algorithm, it is necessary to
give some important deﬁnitions and results, this is to allow a better understanding of the
algorithm. The following fractional operators provide the basis for this work:

7.2
Preliminaries
161
Deﬁnition 7.1 The Riemann-Liouville fractional integral of order α > 0, α ∈R is
deﬁned as:
0I α
t f (t) =
1
Γ (α)
 t
0
f (τ) (t −τ)α−1 dτ
where Γ (α) =
 ∞
0
tα−1e−tdt is Euler’s gamma function.
Deﬁnition 7.2 The Caputo fractional derivative of order α > 0 is deﬁned as:
C
0 Dα
t f (t) =
1
Γ (n −α)
 t
0
f (n) (τ) (t −τ)n−α−1 dτ
where n −1 < α < n, f (n) (τ) is the n-th derivative of f (t).
There is a kind of nonlinear systems that does not fulﬁll the fractional algebraic
observability condition, and yet, it is possible to reconstruct their states:
Deﬁnition 7.3 Fractional Liouvillian system: A fractional chaotic system is said to be
Liouvillian if its states can be written as a function of Riemann-Liouville fractional
integrals of its output, exponentials of Riemann-Liouville fractional integrals of the output
and a number of sequential derivatives of its output.
The ability to reconstruct states without relying on state observers nor requiring
derivatives can be used to obtain a reconstruction with minimal or no error, this is a
desirable feature in secure communications.
Lemma 7.1 ([44]) A system has the equilibrium point x = 0 and D ⊂R is a domain that
contains the origin, let V (t, x (t)) : [0, ∞) × D →R be a continuously differentiable
function and locally Lipschitz on x such that:
α1 ∥x (t)∥a
≤V (t, x (t)) ≤α2 ∥x (t)∥ab
C
0 Dβ
t V (t, x (t)) ≤−a3 ∥x (t)∥ab
Where a, b, α1, α2, α3 > 0, t ≥0, x ∈D and 0 ≤β ≤1 are real numbers, then
equilibrium x = 0 is Mittag-Lefﬂer stable and in consequence the system is asymptotically
stable.
Proof Having
C
0 Dβ
t V [t, x (t)] ≤−α3
α2
V [t, x (t)]

162
7
Fractional-Order Liouvillian Systems and Encryption
There is a non negative function F (t) that satisﬁes:
C
0 Dβ
t V [t, x (t)] + F (t) = −α3
α2
V [t, x (t)]
The Laplace transform makes
sβV (s) −V (0) sβ−1 + M (s) = −α3
α2
V (s)
With the positive constant V (0) = V [0, x (0)] and V (s) = L [V (t, x [t])] causes
V (s) = V (0) sβ−1 −M (s)
sβ + α3
α2
If the initial condition is x (0) = 0 then V (0) = 0 and the solution of the system
C
0 Dα
t x (t) = f (t, x) is x = 0, if x (0) ̸= 0 then V (0) > 0 as it is Lipschitz from x, hence
the solution is:
V (t) = V (0) Eβ

−α3
α2
tβ

−M (t)

tβ−1Eβ,β

−α3
α2
tβ

Knowing that tβ−1 and Eβ,β

−α3
α2 tβ
β,β are non negative:
V (t) ≤V (0) Eβ

−α3
α2
tβ

Then
∥x (t)∥≤
V (0)
α1
Eβ

−α3
α2
tβ
1/a
Since V (0)
α1
> 0 for x (0) ̸= 0, making d = V (0)
α1
≥0 where d = 0 if x (0) = 0. The
function V (t, x) is locally Lipschitz with respect to x, then V [0, x (0)] = 0 if x (0) = 0,
also d = V (0)
α1 is Lipschitz with respect to x (0) causing that d (0) = 0, then:
∥x (t)∥≤

dEβ

−α3
α2
tβ
1/a
This implies the Mittag-Lefﬂer stability of the system.

7.3
Fractional Derivative Numerical Estimation
163
7.3
Fractional Derivative Numerical Estimation
Various applications of fractional chaotic systems need the fractional derivatives of a signal
or state, these derivatives should be obtained by methods that does not increase noise,
does not add any other detrimental effects to signal quality, be as less computing power
demanding as possible and maintain good accuracy.
A state observer can be used to estimate fractional derivatives and fulﬁll the mentioned
requirements, consider that the signal S and its α −th derivative C
0 Dα
t S can be represented
by the two state system:
C
0 Dα
t x1 = x2 = S
C
0 Dα
t x2 = C
0 Dα
t S
y = x1
So a state observer can estimate both states, and thus provide an estimate of the
derivative of the input signal S, in order to use this method, the next assumptions must
be satisﬁed:
Assumption 7.1 The signal S is bounded by a positive real number ∥S∥≤Smax, 0 <
Smax < ∞.
Assumption 7.2 The fractional derivative of order α of signal S is bounded by a positive
real number
C
0 Dα
t S
 ≤S′
max, 0 < S′
max < ∞.
Assumption 7.3 There exists solutions P = P T ≥0, Q = QT > 0 to the inequality
(A −KC)T P + P (A −KC) < −Q where λmin (Q) > Π, also PB = ρ1CT , eT PB ≤
pr ∥e∥and k3eT PB ≤Λ ∥e∥+ Π ∥e∥2 with the positive real numbers 0 < ρ1 < ∞,
0 < pr < ∞. 0 < Λ < ∞and 0 < Π < ∞.
Theorem 7.1 The smoothed sliding modes numerical estimator given by:
C
0 Dα
t ˆx1 = ˆx2 + k1Ce
C
0 Dα
t ˆx2 = C
0 Dα
t ˆS = k2Ce + k3 tanh (Ce)
ˆy = ˆx1
Is able to provide an estimate of C
0 Dα
t S if the Assumptions 7.1, 7.2, and 7.3 are satisﬁed.
Proof The estimation error is:
e =

x1 −ˆx1
x2 −ˆx2

=

e1
e2


164
7
Fractional-Order Liouvillian Systems and Encryption
The estimation error has α-th derivative:
C
0 Dα
t e1 = x2 −ˆx2 −k1Ce
C
0 Dα
t e2 = C
0 Dα
t S −k2Ce −k3 tanh (Ce)
The estimation errors αth derivative is rewritten as C
0 Dα
t e = Ae −B(C
0 Dα
t S −
k3 tanh (Ce)) −KCe with A =

0 1
0 0

, B =

0
1

, C =

1 0

and K =

k1
k2

.
The Lyapunov function V = 1
2eT Pe has fractional derivative:
C
0 Dα
t V =

C
0 Dα
t e
T
Pe + eT P

C
0 Dα
t e

+ 2
∞
"
k=0
 (1 + α)
C
0 Dk
t eT 
C
0 Dα−k
t
e

Γ (1 + k) Γ (1 −k + α)
Since the derivative C
0 DW
t e, W = 1, 2, 3, ... exist and is continuous and bounded,
then there is a real number M such that
C
0 DW
t e
 ≤M, for the real non integer
number 0 < α < 1 there is an integer N such that N −1 < α < N, allowing
C
0 Dα−ξ
t
e, ξ = 1, 2, 3, ... to be divided into two parts: C
0 Dα−ξ
t
e, ξ = 1, 2, ..., N −1
and C
0 Dα−ξ
t
e, ξ = N, N + 1, N + 2, ..., The ﬁrst part yields
C
0 D−ξ
t
x
 =
I ξx
 ≤
¯Wmax ∥x∥, 0 < ¯Wmax < ∞and the second part causes that
C
0 Dα−ξ
t
x
 ≤¯WmaxL ∥x∥,
then C
0 Dα−ξ
t
e,
ξ
= N, N + 1, N + 2, ... satisﬁes
C
0 Dα−k
t
x
 ≤
¯Wmax ∥x∥and
C
0 Dα−k
t
x
 ≤
¯W ∥x∥with ¯W = max
/ ¯WmaxL, ¯Wmax
0
. the gamma function has the
boundaries 0 < Lmin < |Γ (1 −α + wk)| , 0 < Lmin < ∞and since
Γ (k)
Γ (k+1) =
1
k
for k = 1, 2, 3, ... the series )∞
k=1
1
Γ (1+k) converges, then there is H > 0 such that
0 < )∞
k=1
1
Γ (1+k) < H, making B1 =
(1+α)M ¯WH
Lmin
allows the Lyapunov function
fractional derivative to be:
C
0 Dα
t V ≤

C
0 Dα
t e
T
Pe + eT P

C
0 Dα
t e

+ 2B1 ∥e∥
C
0 Dα
t V ≤

Ae −B(C
0 Dα
t S −k3 tanh (Ce)) −KCe
T
Pe
+eT P

Ae −B(C
0 Dα
t S −k3 tanh (Ce)) −KCe

+ 2B1 ∥e∥
C
0 Dα
t V ≤eT 
(A −KC)T P + P (A −KC)

e
+2eT P

B(C
0 Dα
t S −k3 tanh (Ce)

+ 2B1 ∥e∥

7.4
Encryption Algorithm
165
Solving the inequality (A −KC)T P + P (A −KC) < −Q by properly selecting the
values of k1 and k2 so it fulﬁlls Assumption 7.1 and by Assumption 7.2:
C
0 Dα
t V ≤−eT Qe + 2eT PB(C
0 Dα
t S −k3 tanh (Ce)) + 2B1 ∥e∥
C
0 Dα
t V ≤−eT Qe + 2eT PB(S′
max −k3 tanh (Ce)) + 2B1 ∥e∥
Knowing that −tanh (x) ≤−sign (x) + 1:
C
0 Dα
t V ≤−eT Qe + 2eT PB(S′
max −k3sign (Ce) + k3) + 2B1 ∥e∥
≤−eT Qe + 2prS′
max ∥e∥−2k3ρ1eT CT sign (Ce) + 2Λ ∥e∥
+2Π ∥e∥2 + 2B1 ∥e∥
Using the Rayleigh-Ritz inequality on the term −eT Qe and considering that −∥Ce∥≤
−ρ2 ∥e∥for a real number ρ2 > 0 makes:
C
0 Dα
t V ≤−λmin (Q) ∥e∥2 + 2prS′
max ∥e∥−2k3ρ1ρ2 ∥e∥+ 2 ∥e∥
+2Π ∥e∥2 + 2B1 ∥e∥
By Assumption 7.3:
C
0 Dα
t V ≤2prS′
max ∥e∥−2k3ρ1ρ2 ∥e∥+ 2 ∥e∥+ 2B1 ∥e∥
≤2 prS′
max +  + B1 −k3ρ1ρ2
 ∥e∥
Choosing the value of k3 so it complies with the bound k3 ≥prS′
max++B1
ρ1ρ2
causes the
fractional derivative to be:
C
0 Dα
t V ≤0
Then from Lemma 7.1 it is possible to conclude that the estimation error is Mittag-
Lefﬂer stable, making possible to accurately estimate the derivative of the signal.
7.4
Encryption Algorithm
The encryption algorithm makes use of the properties of fractional chaotic systems, the
intention is to allow the algorithm to withstand most types of cryptanalysis, this is done
by making the values used for encryption depend on the key and the message, causing that
each different message be encrypted by a different set of values.

166
7
Fractional-Order Liouvillian Systems and Encryption
First a fractional Liouvillian chaotic oscillator is needed, the Chua-Hartley oscillator is
a good example of this type of systems, it is given by:
C
0 Dα
t x1 = ρ
#
x2 + x1 −2x3
1
7
$
C
0 Dα
t x2 = x1 −x2 + x3
C
0 Dα
t x3 = −βx2
y = x2
The states of the oscillator can be expressed as a function of the output and some of its
fractional integrals and derivatives. The second state is already in terms of the output, i.e.
x2 = y, from the dynamic of the third state it is possible to express x3 as an integral of the
output:
x3 = −βI αx2
= −βI αy
The ﬁrst state is obtained from the dynamic of the second state:
C
0 Dα
t x2 = x1 −x2 + x3
C
0 Dα
t y = x1 −y −βI αy
x1 = βI αy + C
0 Dα
t y + y
This allows to represent the states as:
x1 = βI αy + y + C
0 Dα
t y
x2 = y
x3 = −βI αy
This fractional chaotic system is suited for use with the encryption algorithm described
next:
1. The ﬁrst step is to create a key comprised of decimal numbers, grouped in sections of 5
characters each, a section is to be denoted by keyi, i ∈N, an example of the key is:
Key = 12345 −12345 −12345 −... −12345
Key = key1 −key2 −key3 −... −keyn

7.4
Encryption Algorithm
167
The key above is only for exempliﬁcation purposes, all keys must be different and
long enough.
It is possible to encrypt most types of data, but for ease of visualization, from now
on it is assumed that the message is a color RGB image of size m × n pixels, the image
is formed by three matrices of size m × n, each containing natural numbers in the range
of 0–255, the matrices are denoted by R,G and B.
2. In the second step the initial conditions for the oscillator are made, it is necessary to
mention that the initial condition of the output is to be formed by the key, as knowing it
is essential to the reconstruction process of the states, suppose that the initial condition
of the output state is needed to be in the range [0, 1] then it is computed by:
x2 (0) = key1
99999 = 12345
99999
The initial conditions of the other states are computed using the message, it is done
by rearranging the matrices R and G into vectors of size mn denoted Rv and Gv, the
initial condition is then computed by using the key and the new vectors in the next
equation:
x1 (0) =
)mn
a=1 Rva
255mn
, x3 (0) =
)mn
a=1 Gva
255mn
producing real numbers between 0 and 1 that can be easily scaled into any required
range of values.
3. The third step is to create the remaining parameters for the oscillator using the key, the
equation from step 1 is again used for this step, as example, the parameter α is required
to be α ∈[0.9, 1]:
α = 1 −0.1
 key2
99999

= 1 −0.1
12345
99999

The process must be repeated for the remaining oscillator’s parameters, while
considering the required values to achieve chaotic behavior.
4. The carrier data signal (the signal that contains the message denoted by s ) is made
in this step, the signal is crucial in maintaining zero data loss, it must be made so the
algorithm can operate properly, even in the presence of reconstruction error, the image
of size mn is converted into a vector of size 3mn, then each component of the vector is
converted into its binary representation making it a vector s of size 24mn, this vector
contains only 0 and 1 as data, it is preferred by the authors to use amplitudes between
0.5 and 8 for the vector s, the vector must be centered in zero, considering that the vector
has amplitude of 8, it is rescaled by 8 (s −0.5) producing a squared signal where 4 is
interpreted as 1 and −4 is interpreted as 0. A more accurate method for recovering the
values of the data carrier signal is only to consider the sign of the binary signal s, so

168
7
Fractional-Order Liouvillian Systems and Encryption
a positive value is 1 and a negative value is 0, allowing to accurately operate in the
presence of noise.
The signal s must be further altered by a bitwise XOR operation (denoted by ⊕), the
required binary number for the modiﬁcation is obtained with the systems output and the
key:
yd (t) = 10

248 −1
  key4
99999
 ∥y (t)∥
ymax

= 10

248 −1
 12345
99999
 ∥y (t)∥
ymax

ymax is a bound of the output described by ∥y (t)∥≤ymax, yd (t) is then turned into
its binary representation, where the 24 outer bits form a new 24 bit number, putting ﬁrst
the latter 12 bits and last the ﬁrst 12 bits, then the 24 bit is rescaled into the range[0, 255]
and denoted by yr, ﬁnally the data carrier signal is:
g (s, y) = s ⊕yr
To make this step easier to understand, Fig. 7.1 shows the process to create an 8 bit
number by using the 8 outer bits of a 12 bit integer:
The image shows how the ﬁrst four outer bits (colored in red) of the 12 bit integer
take the position of the last outer bits in the 8 bit integer, then the last 4 outer bits of the
12 bit integer (colored in blue) take the position of the ﬁrst four outer integers of the 8
bit integer.
5. Now it is necessary to establish an initial time for the transmission of the message and
the period of the signal, the next equation gives the initial time based on a suggested
desired initial time t1
ti = t1 + 10−3 
key5
99999

= t1 + 10−3
12345
99999

Fig. 7.1 Making an 8 bit integer by using the outer bits

7.5
Decryption
169
The period of the signal is:
ts = 10−3 
key6
99999

= 10−3
12345
99999

Note that the time equations return values in the range [0, 1000] in microseconds,
but it can be adjusted as the user requires.
6. Transmit the data carrier signal using the fractional Liouvillian system to mask it, a
simple yet efﬁcient method is embedding the signal within one of the states, preferably
a state different than the one used for output (choosing a different state has the intention
to make cryptanalysis harder), the transmitter for this particular oscillator is:
C
0 Dα
t x1 = ρ
#
x2 + x1 −2x3
1
7
$
+ g (s, y)
C
0 Dα
t x2 = x1 −x2 + x3
C
0 Dα
t x3 = −βx2
y = x2
Then the output of the oscillator can be used to reconstruct the transmitted data.
7.5
Decryption
The receiver is made using the properties of Liouvillian systems, the structure of such
systems makes easy to recover the message s from the output, the equation for this is
shown next:
ˆx1 = βI αy + y + C
0 Dα
t y
ˆx2 = y
ˆx3 = −βI αy
ˆg (s, y) = C
0 Dα
t

βI αy + y + C
0 Dα
t y

−ρ
#
y + βI αy + y + C
0 Dα
t y −2

βI αy + y + C
0 Dα
t y
3
7
$
ˆs = ˆg (s, y) ⊕yr
The signal ˆg (s, y) is obtained using the parts of the key involved in the encryption
process. Figure 7.2 shows the encryption and decryption process:

170
7
Fractional-Order Liouvillian Systems and Encryption
Fig. 7.2 Encryption and decryption
Ideally the properties of Liouvillian systems allow to reconstruct states without error,
consider the state reconstruction error:
e =
⎡
⎢⎣
x1 −ˆx1
x2 −ˆx2
x3 −ˆx3
⎤
⎥⎦=
⎡
⎢⎣
e1
e2
e3
⎤
⎥⎦
The error for each state is:
e1 = x1 −ˆx1
= x1 −βI αy −y −C
0 Dα
t y
= 0
e2 = x2 −ˆx2
= x2 −y
= 0
e3 = x3 −ˆx3
= x3 + βI αy
= 0
The difference between the data carrier signal and the recovered data carrier signal is
called the message recovery error, it is denoted by es and given by the next expression:
es = g (s, y) −ˆg (s, y)
= g (s, y) −C
0 Dα
t

βI αy + y + C
0 Dα
t y


7.6
Numerical Results
171
−ρ
#
y + βI αy + y + C
0 Dα
t y −2

βI αy + y + C
0 Dα
t y
3
7
$
= 0
If the key is known the value yr can be reconstructed only with the output of the
transmitter, then:
s −ˆs = g (s, y) ⊕yr −ˆg (s, y) ⊕yr = 0
The message recovery error is zero, this is subjected to the quality of the reconstruction
of the states, it also depends on the ability of the fractional derivative estimation method
to produce accurate reconstructions. Once the signal ˆs is obtained it is rearranged into
its original form, then it yields the reconstructed data and achieves the purpose of zero
reconstruction error while providing strong security against cryptanalysis.
7.6
Numerical Results
To test the encryption algorithm a colour image of size 3024 × 4032 pixels is to be used
as message, the image and is RGB histograms can be seen in Fig. 7.3.
The numerical simulation is done using the parameters: α = 0.92, ρ = 12.75, k1 = −4,
k2 = −5, k3 = −10 and β = 100/7, the initial condition for the output state is x2 (0) =
−0.2, the other states are x1 (0) = 0.5 and x3 (0) = −0.5, This values where chosen
because they make the oscillator to have a stable dynamic and a double scroll attractor, the
convergence of the states and the synchronization error are shown in Fig. 7.4.
The initial error is caused by the small time required for the derivative estimator to
reach the value of the derivative, then the slave system synchronizes to the master, the
encryption algorithm produces the encrypted image of Fig. 7.5.
The reconstructed image is presented in Fig. 7.6.
The histograms shows that the encryption algorithm is effective in hiding the informa-
tion, it did not present data loss at all, so it is possible to obtain an accurate reconstruction
of the message. The encryption algorithm is versatile enough to encrypt data different than
RGB images, a text message is presented next as an example of this:
Message: In this chapter the use of Fractional chaotic Liouvillian systems for secure
communications is introduced
Encrypted message: gdagas
Recovered message: In this chapter the use of Fractional chaotic Liouvillian systems for
secure communications is introduced

172
7
Fractional-Order Liouvillian Systems and Encryption
Fig. 7.3 Message and its red, green and blue histograms
The text is accurately reconstructed, although the encryption and decryption process is
slightly different than the image the results are the same.
The decryption process relies on the derivative estimate, so it is important that the
performance of the chosen method is good, in this case the observer produces an estimate
on par with other popular numerical methods, Fig. 7.7 shows the derivative of the output
along with the estimates obtained with the observer and Ninteger.
The reconstruction of the derivative is accurate enough to allow the encryption
algorithm to correctly recover the plain data without loss, the data carrier signal along
the recovered data carrier signal are shown next, for ease of visualization the number 170
is transmitted in its binary representation 10101010:
Figure 7.8 shows that the reconstructed signal does not cause data loss, making an
accurate and fast reconstruction of the plain image or plain text.
The performance of the smoothed state observer must be compared to other control
methods, ﬁrst a Luenberger observer given by:
C
0 Dα
t ˆx1 = ˆx2 + k1Ce
C
0 Dα
t ˆx2 = k2Ce
ˆy = ˆx1

7.6
Numerical Results
173
Fig. 7.4 Convergence of the attractors and error

174
7
Fractional-Order Liouvillian Systems and Encryption
Fig. 7.5 Encrypted message and its red, green and blue histograms
Next a sliding modes state observer described by:
C
0 Dα
t ˆx1 = ˆx2 + k1sign (Ce)
C
0 Dα
t ˆx2 = k2sign (Ce)
ˆy = ˆx1
Producing the results shown in Fig. 7.9.
The Luenberger observer cannot cope with the presence of the message, it fails to esti-
mate the derivative. The sliding modes observer’s chattering causes the reconstruction of
the derivative to be inaccurate, and although it resembles the derivative, the reconstruction
of the states is useless for decryption, it is possible to say that both control laws are not able
to estimate the derivative well enough, making the recovery of the message impossible.
An interesting addition to the analysis of the algorithm is the presence of noise
contaminating the transmitted data, the test is done by adding white noise to the output
of the function g (s, y), note that the proof of stability remains the same, as the addition of
the noise only increases the value of S
′
max depending on the amplitude of the noise. The
test is performed with two different noise amplitudes, one with around 10% the amplitude

7.7
Security Analysis
175
Fig. 7.6 Recovered message and its red, green and blue histograms
of the data carrier signal, and the former with around 25% the amplitude of the data carrier
signal, the results can be seen in Figs. 7.10 and 7.11.
To better illustrate the resilience to noise, the 12 megapixel picture is transmitted under
the effects of noise contamination, giving the result in Fig. 7.12.
The algorithm can still recover the information without loss, since only the sign of
the recovered data carrier signal is employed for the recovery. The encryption algorithm
proved capable of managing various types of data while retaining all its features, also the
state observer is proven to be able to give good estimates of the fractional derivative of a
signal, even in the presence of data contamination by noise.
7.7
Security Analysis
It is necessary to provide an analysis of the algorithm’s sensibility to cryptanalysis, for this
purpose a known and a chosen plaintext attacks are implemented, also the effectivity of
statistical cryptanalysis is tested.
A known plaintext attack is one of the most effective types of cryptanalysis, in it,
the attacker knows pairs of message and encrypted message, these are used along with

176
7
Fractional-Order Liouvillian Systems and Encryption
40
–0.2
–0.1
0
0.1
Derivative
0.2
0.3
0.4
0.5
41
42
43
44
Time (s)
Derivative
Observer
Ninteger
45
Fig. 7.7 Fractional derivative of the output and its estimated value
knowledge of the algorithm details to recover the key or future messages. In a chosen
plaintext attack the attacker has access to the encryption device, the attacker designs
messages that produce speciﬁc encrypted messages that could lead to breaking the
algorithm.
Most of the current encryption algorithms based on fractional chaotic systems do not
fare well against these attacks, a typical example of encryption in these works can be found
in [10], here the encryption scheme can be expressed by the next equation:
C
0 Dα
t x = f (x)
y = Cx + s
Where the message is s and the encrypted message is y, if the attacker chooses a
message such that s = 0 (if data is transmitted as amplitudes of the signal, as most
commonly is, a black RGB image would cause the desired effect), then the recovered
message is y = Cx, as the encryption vector Cx depends only on the key, it never changes
regardless of the message sent, now if a new message s2 is sent, recovering without the key
is simple: s2 = y −Cx = Cx + s2 −Cx, now the attacker can easily intercept messages
and the key wouldn’t even be needed.

7.7
Security Analysis
177
80.2
80.4
80.6
80.8
81
80
–5
–4
–3
–2
–1
0
Message
1
2
3
4
5
6
Time (s)
Data carrier signal
Recovered data carrier signal
Fig. 7.8 Data carrier signal and the recovered data carrier signal
The proposed encryption algorithm cannot be broken by these attacks, as the encryption
vector depends on both, the message and the key, so every different message gets different
values for the encryption, rendering the attack useless, even more, the data carrier signal
is not directly present in the output of the system, nor in its derivatives, so breaking
it is a much more difﬁcult task, to prove this, the mentioned chosen plaintext attack is
implemented using a black image of size 3024 × 4032 pixels to try to recover the image
from Fig. 7.3, the image used for the attack and the result of it can be seen in Fig. 7.13.
The images above suggest that known and chosen plaintext attacks are ineffective, the
attack failed to recover anything resembling the transmitted image in Fig. 7.1, even if it is
of the exact same size and implemented with the same initial transmission time and period
(for this knowledge of parts of the key is needed), then, the goal of creating an encryption
algorithm that can withstand this type of cryptanalysis is achieved.
To further explain the security features, the correlation of two adjacent pixels for the
plain image in Fig. 7.3 and its encrypted message from Fig. 7.4 can be found in Fig. 7.14.
The ﬁgures show that the plain image correlation of pixels is linear, but the correlation
of pixels in the encrypted image is not, the graphics above along the histograms allow to
conclude that the plain data is safe from differential and linear cryptanalysis.
For comparison with other encryption algorithms cited in the references, consider the
one given in [16], the mentioned method proposes to use a Chen oscillator to mask a
data carrier signal, done by embedding it into a state different than the output required

178
7
Fractional-Order Liouvillian Systems and Encryption
5
–0.8
–0.6
–0.4
–0.2
0
0.2
0.4
0.6
10
15
Time (s)
5
–1
–0.5
0
0.5
1
1.5
10
15
Time (s)
Derivative
Derivative
Derivative
Estimate
Derivative
Estimate
Fig. 7.9 Results for Luenberger(up) and Sliding modes (down)

7.7
Security Analysis
179
80.2
80.4
80.6
80.8
81
80
Message
Time (s)
Data carrier signal
Recovered data carrier signal
–5
–4
–3
–2
–1
0
1
2
3
4
5
6
Fig. 7.10 First test for a data carrier signal contaminated by noise
for synchronization, then recover the information by subtracting the proper state from the
slave system, this can be better represented by dynamics of the master system:
C
0 Dα
t x = f (x)
y = C1x
ys = C2x + s
With C1 ̸= C2. The slave dynamics and message recovery is given by:
C
0 Dα
t ˆx = f (ˆx)
ˆy = C1 ˆx
ˆs = ys −C2 ˆx
This encryption scheme is vulnerable to chosen plaintext attacks, the cryptanalysis
procedure is the same that was used previously, this is: consider a ﬁrst message that is
designed so the data carrier signal is equal to zero i.e. s1 = 0, the encrypted message is
ys1 = C2x + s1 = C2x + 0 = C2x, since the values used for the oscillator depend only on

180
7
Fractional-Order Liouvillian Systems and Encryption
Message
80.2
80.4
80.6
80.8
81
80
Time (s)
Data carrier signal
Recovered data carrier signal
–6
–4
–2
0
2
4
6
8
Fig. 7.11 Second test for a data carrier signal contaminated by noise
the key the values of C2 only change if the key changes, then by recovering the encrypted
message ys1 allows to recover any subsequent message, this is:
ysn = C2x + sn
sn = ysn −ys1
sn = C2x + sn −C2x
sn = sn
This shows that it is possible to recover the message without the need of the key. A
chosen plaintext attack is implemented on the algorithm of [16], for this purpose, the
black image makes the data carrier signal be zero, the results when the second message is
a picture can be seen in Fig. 7.15.
The algorithm is unable of maintaining the data safe from the attack, and the second
message is recovered without the key. Another setback of this type of encryption is that
it uses data carrier signals that consist on the scaled down values of the RGB image pixel
values, this method makes the data extremely susceptible to any unknown parameter on
the system such as noise, The following result is obtained when the transmitted message
is the integer set 71,12, 25, 210, 177, 81, 242, 9 scaled down by 100, noise contamination

7.7
Security Analysis
181
500
1000
1500
1500
1000
500
2000
2000
2500
2500
3000
3000
3500
4000
Fig. 7.12 Effects of noise on the recovery of an image
to the message is added in the same way that was done in the previous section, producing
the results shown in Fig. 7.16.
The noise affects the values recovery, the reconstruction of the set of integers is 65, 22,
5, 234, 155, 110, 255, 0 for the ﬁrst test and 41, 32, 45, 255, 94, 67, 255, 20 for the second
one, showing that it creates an inaccurate reconstruction of the message, causing data loss
or a completely wrongful message reconstruction, this is exempliﬁed in Fig. 7.17 by using
the same picture as message:
The compared algorithm is unable to retain accuracy in the presence of noise, and even
the low amplitude noise used in the previous sections causes severe degeneration of the
data. The proposed algorithm is clearly capable to work under such conditions, since a
binary data carrier signal is not as affected by noise as a signal formed by scaled down
values of the message.
Having done these tests it is possible to say that the encryption algorithm offers good
security against most types of cryptanalysis, showing that fractional Liouvillian systems
are useful for secure communications.

182
7
Fractional-Order Liouvillian Systems and Encryption
500
1000
1500
1500
1000
500
2000
2000
2500
2500
3000
3000
3500
4000
500
1000
1500
1500
1000
500
2000
2000
2500
2500
3000
3000
3500
4000
Fig. 7.13 Chosen plain image and resulting image of the attack

7.7
Security Analysis
183
0
0
50
100
50
100
150
150
Pixel value on location (x,y)
Pixel value on location (x+1,y)
200
200
250
250
300
300
0
0
50
100
50
100
150
150
Pixel value on location (x,y)
Pixel value on location (x+1,y)
200
200
250
250
300
300
Fig. 7.14 Correlation of adjacent pixels of the plain image and the encrypted image

184
7
Fractional-Order Liouvillian Systems and Encryption
500
1000
1500
1500
1000
500
2000
2000
2500
2500
3000
3000
3500
4000
Fig. 7.15 Chosen plaintext attack result
7.8
Concluding Remarks
Using fractional Liouvillian systems allowed to create an encryption algorithm able to
resist cryptanalysis and without data loss, the ability to reconstruct states without error by
using only the output is pivotal for achieving this, since the only possible source of error
is the implementation of the derivative.
While it is possible to differentiate the required signals directly, doing it causes the
noise present on the signal to increase, making the algorithm less reliable, so using another
method for estimating the fractional derivative of the signal is necessary, for this task the
smoothed sliding modes observer proved accurate and reliable enough, also it did not
present the problems of traditional sliding modes derivative approximations when applied
to signals with abrupt changes in its trajectory, producing results on par with popular
methods for the estimation of the fractional derivative such as Ninteger.
The algorithm proved the effectiveness of fractional chaotic Liouvillian systems when
employed in stream ciphers, the decryption process is simple and requires less computing
power than most state observers, maintains precision in the reconstruction and gives
security to the transmitted messages. The fractional derivative estimator is speciﬁcally
designed to be as easy to implement and as simple as possible, so it does not affect the
performance of the whole stream cipher, ﬁnally, the proposed binary signal allowed to

7.8
Concluding Remarks
185
Message
–0.5
0
0.5
1
1.5
2
2.5
3
10.2
10
10
10.4
10.6
10.8
11
Time (s)
Data carrier signal
Recovered data carrier signal
Message
–1
0
1
2
3
4
10.2
10.4
10.6
10.8
11
Time (s)
Data carrier signal
Recovered data carrier signal
Fig. 7.16 Noise effects on the scaled data carrier signal

186
7
Fractional-Order Liouvillian Systems and Encryption
Fig. 7.17 Noise effects on the images

References
187
retain the required integrity of the data making possible to combine the data carrier signal
with the values from the cryptographic function g(s, y).
References
1. Pecora, L. M., & Carroll, T. L. (1990). Synchronization in chaotic systems. Physical Review
Letters, 64(8), 821.
2. Pikovsky, A., Rosenblum, M., Kurths, J., & Kurths, J. (2003). Synchronization: a universal
concept in nonlinear sciences (Vol. 12). Cambridge University Press.
3. Boccaletti, S. (2008). The synchronized dynamics of complex systems. Monograph series on
nonlinear science and complexity (Vol. 6, pp. 1–239).
4. Balanov, A., Janson, N., Postnov, D., & Sosnovtseva, O. (2008). Synchronization: from simple
to complex. Springer Science & Business Media.
5. Martínez-Guerra, R., Pérez-Pinacho, C. A., & Gómez-Cortés, G. C. (2015). Synchronization of
integral and fractional order chaotic systems: A differential algebraic and differential geometric
approach with selected applications in real-time. Springer.
6. Li, C., & Chen, G. (2004). Chaos and hyperchaos in the fractional-order Rössler equations.
Physica A: Statistical Mechanics and its Applications, 341, 55–61.
7. Laskin, N. (2000). Fractional market dynamics. Physica A: Statistical Mechanics and Its
Applications, 287(3), 482–492.
8. Hamidian, H., & Beheshti, M. T. (2017). A robust fractional-order PID controller design based
on active queue management for TCP network. International Journal of Systems Science, 49(1),
211–216.
9. Hilfer, R. (Ed.). (2000). Applications of fractional calculus in physics. World Scientiﬁc.
10. Scalas, E., Gorenﬂo, R., & Mainardi, F. (2000). Fractional calculus and continuous-time ﬁnance.
Physica A: Statistical Mechanics and its Applications, 284(1), 376–384.
11. Atanackovic, T. M. (2003). On a distributed derivative model of a viscoelastic body. Comptes
Rendus Mecanique, 331(10), 687–692.
12. Popovic, J. K., Atanackovic, M. T., Pilipovi, A. S., Rapai, M. R., Pilipovi, S., & Atanackovi, T.
M. (2010). A new approach to the compartmental analysis in pharmacokinetics: fractional time
evolution of diclofenac. Journal of Pharmacokinetics and Pharmacodynamics, 37(2), 119–134.
13. N’Doye, I., Darouach, M., & Voos, H. (2013, July). Observer-based approach for fractional-order
chaotic synchronization and communication. In European Control Conference (ECC), 2013 (pp.
4281–4286). IEEE.
14. Luo, C., & Wang, X. (2013). Chaos generated from the fractional-order complex Chen system
and its application to digital secure communication. International Journal of Modern Physics C,
24(04), 1350025.
15. Wu, X., Wang, H., & Lu, H. (2012). Modiﬁed generalized projective synchronization of a new
fractional-order hyperchaotic system and its application to secure communication. Nonlinear
Analysis: Real World Applications, 13(3), 1441–1450.
16. Deng, Y. S., Qin, K. Y., & Shao, S. Q. (2009). Synchronization in coupled fractional order
Chen-system and its application in secure communication. In IEEE International Conference
Communications, Circuits and Systems (pp. 839–841).
17. Kiani-B, A., Fallahi, K., Pariz, N., & Leung, H. (2009). A chaotic secure communication scheme
using fractional chaotic systems based on an extended fractional Kalman ﬁlter. Communications
in Nonlinear Science and Numerical Simulation, 14(3), 863–879.

188
7
Fractional-Order Liouvillian Systems and Encryption
18. Sheu, L. J. (2011). A speech encryption using fractional chaotic systems. Nonlinear Dynamics,
65(1), 103–108.
19. Zhen, W., Xia, H., Ning, L., & Xiao-Na, S. (2012). Image encryption based on a delayed
fractional-order chaotic logistic system. Chinese Physics B, 21(5), 050506.
20. Xu, Y., Wang, H., Li, Y., & Pei, B. (2014). Image encryption based on synchronization of
fractional chaotic systems. Communications in Nonlinear Science and Numerical Simulation,
19(10), 3735–3744.
21. Kassim, S., Hamiche, H., Djennoune, S., & Bettayeb, M. (2017). A novel secure image
transmission scheme based on synchronization of fractional-order discrete-time hyperchaotic
systems. Nonlinear Dynamics, 88(4), 2473–2489.
22. Muthukumar, P., Balasubramaniam, P., & Ratnavelu, K. (2015). Fast projective synchronization
of fractional order chaotic and reverse chaotic systems with its application to an afﬁne cipher
using date of birth (DOB). Nonlinear Dynamics, 80(4), 1883–1897.
23. Zhang, L., Sun, K., Liu, W., & He, S. (2017) A novel color image encryption scheme using
fractional-order hyperchaotic system and DNA sequence operations. Chinese Physics B, 26(10)
100504.
24. Xu, Y., Wang, H., Liu, D., & Huang, H. (2015). Sliding mode control of a class of fractional
chaotic systems in the presence of parameter perturbations. Journal of Vibration and Control,
21(3), 435–448.
25. Liu, D., Xu, W., & Xu, Y. (2013). Noise-induced chaos in the elastic forced oscillators with
real-power damping force. Nonlinear Dynamics, 71(3), 457–467.
26. Xu, Y., Gu, R., Zhang, H., & Li, D. (2012). Chaos in diffusionless Lorenz system with a fractional
order and its control. International Journal of Bifurcation and Chaos, 22(04), 1250088.
27. Xu, Y., Gu, R., & Zhang, H. (2011). Effects of random noise in a dynamical model of love.
Chaos, Solitons & Fractals, 44(7), 490–497.
28. Xu, Y., Mahmoud, G. M., Xu, W., & Lei, Y. (2005). Suppressing chaos of a complex Dufﬁng’s
system using a random phase. Chaos, Solitons & Fractals, 23(1), 265–273.
29. Izaguirre-Espinosa, C., Muñoz-Vázquez, A. J., Sánchez-Orta, A., Parra-Vega, V., & Castillo, P.
(2016). Attitude control of quadrotors based on fractional sliding modes: theory and experiments.
IET Control Theory & Applications, 10(7), 825–832.
30. Aghababa, M. P. (2013). A novel terminal sliding mode controller for a class of non-autonomous
fractional-order systems. Nonlinear Dynamics, 73(1–2), 679–688.
31. Kamal, S., Raman, A., & Bandyopadhyay, B. (2013). Finite-time stabilization of fractional
order uncertain chain of integrator: An integral sliding mode approach. IEEE Transactions on
Automatic Control, 58(6), 1597–1602.
32. Li, C., Wang, J., Lu, J., & Ge, Y. (2014). Observer-based stabilization of a class of fractional
order non-linear systems for 0 < α < 2 case. IET Control Theory & Applications, 8(13), 1238–
1246.
33. Zhong, F., Li, H., & Zhong, S. (2016). State estimation based on fractional order sliding mode
observer method for a class of uncertain fractional-order nonlinear systems. Signal Processing,
127, 168–184.
34. Aghababa, M. P. (2012). Robust stabilization and synchronization of a class of fractional-order
chaotic systems via a novel fractional sliding mode controller. Communications in Nonlinear
Science and Numerical Simulation, 17(6), 2670–2681.
35. Boukal, Y., Darouach, M., Zasadzinski, M., & Radhy, N. E. (2017). Robust H∞observer-based
control of fractional-order systems with gain parametrization. IEEE Transactions on Automatic
Control, 62(11), 5710–5723.

References
189
36. Lin, C., Chen, B., Shi, P., & Yu, J. P. (2018). Necessary and sufﬁcient conditions of observer-
based stabilization for a class of fractional-order descriptor systems. Systems & Control Letters,
112, 31–35.
37. Chen, L., Chen, G., Wu, R., Tenreiro Machado, J. A., Lopes, A. M., & Ge, S. (2018).
Stabilization of uncertain multi-order fractional systems based on the extended state observer.
Asian Journal of Control, 20(3), 1263–1273.
38. N’Doye, I., Salama, K. N., & Laleg-Kirati, T. M. (2018). Robust fractional-order proportional-
integral observer for synchronization of chaotic fractional-order systems. IEEE/CAA Journal of
Automatica Sinica, 6(1), 268.
39. Luo, S., Li, S., Tajaddodianfar, F., & Hu, J. (2018). Observer-based adaptive stabilization of the
fractional-order chaotic MEMS resonator. Nonlinear Dynamics, 92(3), 1079–1089.
40. Yu, W., Li, Y., Wen, G., Yu, X., & Cao, J. (2017). Observer design for tracking consensus
in second-order multi-agent systems: Fractional order less than two. IEEE Transactions on
Automatic Control, 62(2), 894–900.
41. Yang, B., Yu, T., Shu, H., Zhu, D., An, N., Sang, Y., & Jiang, L. (2018). Perturbation observer
based fractional-order sliding-mode controller for MPPT of grid-connected PV inverters: Design
and real-time implementation. Control Engineering Practice, 79, 105–125.
42. Wang, A., Liao, X., & Dong, T. (2018). Fractional-order follower observer design for tracking
consensus in second-order leader multi-agent systems: Periodic sampled-based event-triggered
control. Journal of the Franklin Institute, 355(11), 4618–4628.
43. Coronel-Escamilla, A., Gómez-Aguilar, J. F., Torres, L., Valtierra-Rodriguez, M., & Escobar-
Jiménez, R. F. (2017). Design of a state observer to approximate signals by using the concept of
fractional variable-order derivative. Digital Signal Processing, 69, 127–139.
44. Li, Y., Chen, Y., & Podlubny, I. (2010). Stability of fractional-order nonlinear dynamic systems:
Lyapunov direct method and generalized Mittag-Lefﬂer stability. Computers & Mathematics
with Applications, 59(5), 1810–1821.

8
Fractional-Order Robust State Observers
and Encryption
Abstract
This chapter introduces a new encryption algorithm for color RGB images and text. The
encryption is based on the synchronization of fractional chaotic systems in a topology of
master-slave. The encryption algorithm provides security against common encryption
techniques, including known and chosen plain text attacks.
8.1
Introduction
Fractional calculus has gained attention due to its many possible applications in various
ﬁelds like ﬁnance [1], physics [2], medicine [3], biology [4] and chaotic systems
synchronization [5], this last one was ﬁrst introduced by Pecora and Carroll [6] and since
then, many possible uses to it were found.
One of the most important applications of systems synchronization is secure communi-
cations, it comprises both fractional calculus and synchronization of chaotic systems, there
are several publications on image encryption involving chaotic systems and traditional
calculus [7–24] and most of them with very good results, but only a few can be found
based on fractional calculus [25–32], and in most of these, the safety of the information
is not the top priority and fail to provide security against a variety of cryptanalysis,
in particular many of the mentioned encryption algorithms will not fare well if chosen
plaintext attacks are implemented. In particular references [7] and [32] have interesting
encryption algorithms, that use chaotic systems for encryption, in [7] the algorithm uses
the key to make the initial conditions and some system parameters, causing that the
trajectories from which the encryption values are obtained, vary depending on the key,
then, in consequence, the set of numbers used for encryption will also vary depending on
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_8
191

192
8
Fractional-Order Robust State Observers and Encryption
the key. Another interesting example that uses fractional chaotic systems can be found on
[32], in that work the encryption is done by obtaining pseudorandom numbers from the
states of a fractional chaotic oscillator, and with an equation convert these numbers into a
ﬁtting range of values to mix them with the plain image. Although the mentioned proposals
are good, they fail to provide security against some popular forms of cryptanalysis like
chosen plaintext attacks, so the safety of the information encrypted with them is not
guaranteed.
The intention of this chapter is to provide an encryption algorithm that uses fractional
chaotic systems synchronization while guaranteeing the safety of the information even
if chosen plaintext attacks or known plaintext attacks are implemented, to achieve the
required security features the properties of chaotic fractional systems will be extensively
used and the receiver will be designed as a fractional smoothed sliding modes state
estimator.
This chapter is organized as follows: in Sect. 8.2 concepts about fractional calculus are
given, in Sect. 8.3 the encryption process and the transmitter are presented, in Sect. 8.4
the observer and the decryption process are explained, in Sect. 8.5 numerical results are
shown, in Sect. 8.6 a security analysis of the algorithm is made and ﬁnally in Sect. 8.7
conclusions can be found.
8.2
Preliminaries
To further elaborate on the encryption algorithm and the subsequent decryption it is
necessary to give the following deﬁnitions:
Deﬁnition 8.1 The Riemann-Liouville fractional integral of a function f (t) is:
0I α
t f (t) =
1
Γ (α)
 t
0
f (τ) (t −τ)α−1 dτ
With n−1 < α < n and Γ (•) is the gamma function given by Γ (α) =
 ∞
0
tα−1e−tdt
that converges to the right half of the complex plane.
Deﬁnition 8.2 The Caputo fractional derivative of order α of a function f (t) is described
by:
C
toDα
t f (t) =
1
Γ (n −α)
 t
to
f (n) (τ) (t −τ)n−α−1 dτ
And f (n) (τ) is the n-th derivative, n is positive integer number.

8.3
Encryption Algorithm
193
Lemma 8.1 The Lyapunov function V (x) fulﬁlls the next condition:
a1 ∥x∥≤V (x) ≤a2 ∥x∥
DαV (x) ≤−a3 ∥x∥
With a1, a2, a3 > 0 the system will be Mittag-Lefﬂer stable and in consequence
asymptotically stable.
The encryption algorithm will be based on the synchronization of two fractional chaotic
systems, the synchronization will require that the systems be arranged in a master-slave
conﬁguration, the transmitter will be the master, which is used to encrypt the data,
therefore it will be a fractional chaotic oscillator. The slave will be the receiver, in this case
it is designed as a smoothed sliding modes state observer, its function is to synchronize to
the master and provide an accurate reconstruction of the states of the master system and
with them, reconstruct the message that was encrypted with the master system.
The fractional chaotic oscillator and the state observer will be based on the mentioned
operators, also the state observer’s proof of stability will use Lemma 8.1. In the following
sections a detailed explanation of the encryption and decryption processes are given.
8.3
Encryption Algorithm
The encryption algorithm will encrypt the data carrier signal g (s, y) by combining it with
one of the states of the transmitter oscillator:
Dαx1 = x2
Dαx2 = f (x1, x2) + g (s, y)
y = x1
Where 0 < α < 1, the function f (x1, x2) is also bounded by the Lipschitz condition:
∥f (a) −f (b)∥≤L ∥a −b∥, a, b ∈R, L ∈R+
The output state should be different than the state where g (s, y) was added. For the
description of the encryption algorithm it will be assumed that the data is an RGB image
of size i · j composed by three matrices containing the red, blue and green data of the
image, each matrix is of size i · j and they will be converted into vectors of size (ij)
R ∈Nij, 0 ≤Rij ≤255, G ∈Nij , 0 ≤Gij ≤255 and B ∈Nij, 0 ≤Bij ≤255. The

194
8
Fractional-Order Robust State Observers and Encryption
data carrier signal g (s, y) is bounded by ∥g (s, y)∥≤Smax and Smax > 0 is a positive
real number. The encryption algorithm is the following:
1. Create the encryption key: The key is a set of decimal numbers separated into sections
denoted by Keyn, n = 1, 2, 3, ..., the key must have enough elements for it to supply
the required information for each step of the algorithm, an example of the key is:
Key = 12345 −12345 −12345 −12345 −12345 −...
Key = key1 −key2 −key3 −key4 −key5 −...
The keys should be randomly generated and must be long enough for the key space
to be large so it deters brute force attacks.
2. The elements of the key must be converted to the values that will make the fractional
chaotic oscillator have chaotic behavior, the range of values that will produce chaotic
behavior is to be obtained by computing the Lyapunov exponents, a range of values that
causes chaos will produce a positive lead Lyapunov exponent, the key elements will be
used along the message to create the initial conditions of the oscillator, the key alone
will be used for the remaining parameters of the oscillator, the needed values are to be
transformed to the proper range as shown next:
x1 (0) = Key1
99999
)ij
a=1 Ra
255ij
, x2 (0) = Key2
99999
)ij
a=1 Ga
255ij
The utilization of the vectors R and G of the image is only an example, the choice
of vectors must be randomized according to a key element, The value 99999 is selected
supposing that a range [0, 1] in the state x1 initial value produces a positive lead
Lyapunov exponent, the remaining parameters of the oscillator are computed by:
α = key3
99999
Also considering that the range α ∈[0, 1] for the parameter promotes chaos.
3. Create the data carrier signal: In many cases, data is embedded into a the data carrier
signal simply by scaling down its values and introducing them into the signal, this is the
most easy way to make a data carrier signal, but when working with state observers, and
specially sliding modes, in some instances although the error is not noticeable, it will
cause that, when scaling up for reconstruction, the small error is carried over and also
scaled up, causing data loss and in consequence an erroneous message reconstruction,
for example the set of integer values: 170, 55, 32, 255, 8, 45, 123, 15 is scaled down
multiplying for 0.01 and recovered by a common sliding modes observer (Fig. 8.1).
The recovered values are 187, 63, 41, 230, 0, 55, 101, 5, the inaccurate reconstruction
is caused mostly by the chattering inherent to sliding modes, it is necessary to choose a

8.3
Encryption Algorithm
195
1
1.2
–0.5
0
0.5
1
1.5
2
2.5
3
1.4
1.6
1.8
2
x 105
Recovered Message
Message
Fig. 8.1 Common sliding modes performance
way of embedding the data that does not cause loss even if there is a slight error in the
reconstruction of the signal.
Most data is comprised of 8 bit integer numbers making possible to convert the
message into its binary representation, so the information signal will only contain two
numbers, 1 and 0. The signal will be a squared waveform of a suggested amplitude of
0.5–1 and centered in zero, this way a 1 will be a positive period and a 0 will be a
negative period of the message signal g (s, y), the period P of this signal is given by
the encryption key:
P =
1
3 · i · j

tf + Key3
99999

−

ti + Key4
99999

Where ti and tf are the initial and ﬁnal transmission time respectively. The intention
of creating this kind of signal is to avoid data loss, even if there is noise or any other
unexpected inaccuracies during the transmission. Figure 8.2 provides an example of an
8 bit integer converted into the signals.
The message must be further masked by combining it with a pseudorandom number
obtained from the key and the output, a suggested method is creating a pseudorandom
48 bit number with the systems output by normalizing the output between zero and one,

196
8
Fractional-Order Robust State Observers and Encryption
Fig. 8.2 Signal representation of integer 173
multiply by 248 −1 and then convert it into a 48 bit binary number which is combined
with an element of the key via a bitwise XOR operation. Once the 48 bit binary number
is available take the ﬁrst 12 bits and the last 12 bits of the 48 bit number to create a 24bit
number that is again normalized between 0 and 255 and ﬁnally turned into a binary 8 bit
number yr, this value is combined with the data carrier signal 8 bit number by a bitwise
XOR operation: g(s, y) = s ⊕yr, note that this signal will also be squared with the
same characteristics as the messages, this method is suggested by the authors because
it yields encrypted images with entropy of around 7.9951 with slight variation caused
by the message, key and the systems output, the parts of g (s, y) that do not include
information of the message must be ﬁlled with random numbers. Finally, the message
is transmitted through the output of the system.
The advantage of this encryption scheme is that the message itself is not present
in the output nor it requires a separate channel to transmit its data, more over, the
signals used for masking the message depend on the key and the message itself, making
known and chosen plaintext attacks useless, since each individual combination of key
and message will have a very difﬁdent encryption values due to the chaotic nature of
the oscillator.

8.4
Receiver and Decryption
197
The algorithm can be modiﬁed to be used with compressed image ﬁles like jpg, in
the speciﬁc case of jpg there are several possibilities, the most straightforward would
be to adjust the range of the pseudorandom values used for encryption to the needs
of Y’CrCb that jpg uses and proceed in a similar way with RGB images, another
possibility is to directly work with the segments that form the ﬁle, this will also require
to adjust the values to the proper range, although this could not result as intuitive and
easy as the ﬁrst proposal. It is worth of mention that, if working with compressed ﬁles
is necessary, the compressed image is to be encrypted, as various types of compressed
formats tend to slightly alter the image, then if the RGB image is ﬁrst encrypted and then
compressed, the compression will modify the encrypted message and the decryption
process will not be applied to the same data that was encrypted, hence producing an
erroneous reconstruction. Also the encryption function is designed to work with RGB
images S ∈N, and maps positive eight bit integer numbers to positive eight bit integer
numbers: C (S) : N→N, and so does the decryption algorithm: D[C (S)] : N→N,
most compression methods do not use only positive integer data, for example the JPEG
uses real values: Jpg (S) : N →R so if an image is encrypted and then compressed
Jpg [C (S)] ∈R will produce an erroneous result, because the decryption process is
made to work with positive eight bit integers.
8.4
Receiver and Decryption
The receiver will be a smoothed sliding modes state observer, the intention of proposing
this kind of observer is to reduce to a minimum the effects of chattering that sliding modes
observers have, if chattering is not reduced it could cause data loss if the data signal is
not capable of working under such conditions. The receiver dynamics are described by the
next equation:
Dα ˆx1 = ˆx2 −k1

y −ˆy

−k2
y −ˆy
1/2 tanh(y −ˆy)
Dα ˆx2 = f

ˆx1, ˆx2

−k3

y −ˆy

−k4 tanh

y −ˆy

ˆy = ˆx1
ˆs =

DαDαy −f

ˆx1, ˆx2

⊕yr
The synchronization error between the transmitter and the receiver is:
e = x −ˆx
e =

x1 −ˆx1
x2 −ˆx2


198
8
Fractional-Order Robust State Observers and Encryption
The error’s fractional derivative of order α is:
Dαe =

e2 −k1 (e) −k2 |e|1/2 tanh(e)
f (x) −f

ˆx

+ g (s, y) −k3 (e) −k4 tanh (e)

Dαe = A + Bφ (e) + Bg (s, y) −KaCe −Kb tanh(Ce)
where A =

0 1
0 0

, B =

0
1

, φ (e) = f (x) −f ˆx and the gain vectors are Ka =

k1 k3
t
and kb =

k2 ∥e∥
1
2 k4
T
, the following assumptions will be needed for the
proof of stability.
Assumption 8.1 The next LMI has solutions P = P T > 0 and Q = QT > 0:
(A −KaC)T P + P (A −KaC) ≤−Q
Assumption 8.2 The inequalities eT PKb ≤1
2λmin (Q) ∥e∥2 + ε ∥e∥, eT PB ≤Smax ∥e∥
and eT PB ≤L ∥e∥are true for ε, Smax, L ≥0.
Then, the Lyapunov candidate function and its fractional derivative of order α are:
V = eT Pe
DαV =

Dαe
T Pe + eP T 
Dαe

+2
∞
"
k=0
 (1 + α)
DkeT Dα−ke
Γ (1 + k) Γ (1 −k + α)
Since DKe exist, is continuous and bounded, there is M such that
Dke
 ≤M for k =
1, 2, 3 . . ., α is a real non integer number, then, there is an integer N such that N −1 < α <
N, so Dα−ke can be divided into two parts: Dα−ke, k = 1, 2, ..., N −1 and Dα−ke, k =
N,N +1, N +2, ..., then Dα−ke, k = 1, 2, ..., N −1 yields
D−kx
=
I kx
 ≤¯Kmax ∥x∥,
¯Kmax > 0 and
Dα−kx
 ≤¯KmaxL ∥x∥, then Dα−ke, k = N, N + 1, N + 2, ... satisﬁes
Dα−kx
 ≤¯Kmax ∥x∥, then
Dα−kx
 ≤
¯
Kmax ∥x∥, with ¯K = max
/ ¯KmaxL, ¯Kmax
0
.
The gamma function has the boundaries 0 < Lmin < |Γ (1 −α + k)|, Lmin > 0 and since
Γ (k)
Γ (k+1) = 1
k for k = 1, 2, 3, ... the series )∞
k=1
1
Γ (1+k) converges, then there is H > 0
such that 0 < )∞
k=1
1
Γ (1+k) < H, and the Lyapunov functions fractional derivative is:
DαV ≤

Dαe
T Pe + eT P

Dαe

+ 2B1 ∥e∥

8.4
Receiver and Decryption
199
Where B1 = (1+α)M ¯KH
Lmin
, then from Assumption 8.2.
DαV ≤eT 
(A −KaC)T P + P (A −KaC)

e
+2eT P [Bg (s, y) + Bφ (e) −Kb tanh (Ce)]
+2B1 ∥e∥
≤eT 
(A −KaC)T P + P (A −KaC)

e
+2Smax ∥e∥+ 2L ∥e∥−2eT PKb tanh (Ce)
+2B1 ∥e∥
≤eT 
(A −KaC)T P + P (A −KaC)

e
+2 (Smax + L + B1) ∥e∥−2eT PKb tanh (Ce)
Using the Assumption 8.1,
DαV ≤eT Qe + 2 (Smax + L + B1) ∥e∥
−2eT PKb tanh (Ce)
≤−eT Qe + 2 (Smax + L + B1) ∥e∥
−2eT PKb tanh (Ce)
Since −tanh (x) ≤−sign (x) + 1:
DαV ≤−eT Qe + 2 (Smax + L + B1) ∥e∥
−2eT PKb [sign (Ce) −1]
≤−eT Qe + 2 (Smax + L + B1) ∥e∥
−2eT PKbsign (Ce) + 2eT PKb
≤−eT Qe + 2 (Smax + L + B1) ∥e∥
−2eT PKb
Ce
∥Ce∥+ 2eT PKb
≤−eT Qe + 2 (Smax + L + B1) ∥e∥
−
2
!
λmax

CT C
eT PKbC e
∥e∥+ 2eT PKb

200
8
Fractional-Order Robust State Observers and Encryption
It is known that
!
λmax
CT C = 1, λmin and λmax are the minimum and maximum
eigenvalues of the argument matrix, then Assumption 8.2 yields:
DαV ≤−eT Qe + 2 (Smax + L + B1) ∥e∥
−2λmin (PKbC) ∥e∥
+2
1
2λmin (Q) ∥e∥2 + ε ∥e∥

≤2 [Smax + L + B1 + ε −λmin (PKbC)] ∥e∥
By choosing Kb such that λmin (PKbC) > Smax + L + B1 + ε makes the Lyapunov
functions fractional derivative be:
DαV ≤0
According to lemma 1 the state estimation error is Mittag-Leffer stable, in consequence
it will allow to recover the encrypted message by using the key and arranging the binary
representation of the data into is original form.
The algorithm for decryption will require the key, it is described in following steps:
1. Synchronize the receiver to the transmitter using the key.
2. Combine the key and the transmitters output to obtain the values of yr by applying the
same operations given in the fourth step of the encryption algorithm.
3. Use ˆs = DαDαy −f ˆx1, ˆx2
 ⊕yr on the recovered binary signal to reconstruct the
transmitted data carrier signal.
4. Arrange the recovered binary values in groups of eight numbers, then convert them to 8
bit integer format.
The recovered message accuracy will depend on the observer and the data conversion
into a signal, the authors prefer signals of amplitude 0.5–1 for its ease of visualization and
comparison with the oscillators states, although the observer is capable of working with
far smaller or larger signal amplitudes without data loss.

8.5
Numerical Results
201
8.5
Numerical Results
In order to test the performanceof the observer and the encryption algorithm, a color image
and text will be used as transmitted data. A suited fractional chaotic oscillator would be
the fractional Dufﬁng oscillator described by:
Dαx1 = x2
Dαx2 = x1 −x3
1 −δx2 + γ cos (ωt) + g (s, y)
y = x1
The observer that will act as receiver for this oscillator is:
Dα ˆx1 = ˆx2 −k1

y −ˆy

−k2
y −ˆy
1/2 tanh(y −ˆy)
Dα ˆx2 = ˆx1 −ˆx3
1 −δ ˆx2 + γ cos (ωt)
−k3
y −ˆy −k4 tanh y −ˆy
ˆy = ˆx1
ˆs =
&
DαDαy
−

ˆx1 −ˆx3
1 −δ ˆx2 + γ cos (ωt)

⊕yr
Using the following system parameters α = 0.973, ˆx1 (0) = 1, ˆx2 (0) = −1, δ =
0.6432, ω = 4 and the gains k1 = −8.347, k2 = −2.659, k3 = −3.172, k4 = −4.958, the
next results are obtained when the message is the number 170 (Figs. 8.3, 8.4, and 8.5).
The fractional smoothed sliding modes state observer can accurately recover the
message, even if the derivative is involved in the message reconstruction there will not be
any data loss, because how the message signal is constructed. To test the image encryption
capabilities a 1683 × 2522 pixels color image is used as message, the message along its
RGB histogram can be seen in Fig. 8.6.
The resulting encrypted image along its histograms is presented in Fig. 8.7.
By analyzing the histograms, it is possible to see that the encryption algorithm is
effective, the encrypted image histograms show that statistical based cryptanalysis such
as linear and differential will not be effective, even more the encryption algorithm renders
other types cryptanalysis ineffective, this cryptanalysis techniques being chosen plaintext
attacks and known plaintext attacks, a detailed exposition on this security features and
resistance to the mentioned attacks can be found on the next section along with the proper
tests and a comparison to other state of the art fractional chaotic systems synchronization
based algorithms. The decryption process yields the following results (Fig. 8.8).

202
8
Fractional-Order Robust State Observers and Encryption
7
–0.8
–0.6
–0.4
–0.2
0
0.2
0.4
0.6
7.0002
7.0004
Message
Recovered Message
7.0006
7.0008
7.001
(a)
(b)
x 105
–0.8
–1
–1.20
2
4
6
8
10
–0.6
–0.4
–0.2
0
0.2
Fig. 8.3 (a) Message and recovered message, (b) message recovery error

8.5
Numerical Results
203
0
0
–0.2
0
0.2
0.4
0.6
0.8
1
1.2
2
4
6
8
10
–2
–1.5
–1
–0.5
0
0.5
x1
Recovered x1
1
1.5
2
2.5
20
40
60
80
100
(a)
(b)
Fig. 8.4 (a) x1 and ˆx1, (b) Synchronization error

204
8
Fractional-Order Robust State Observers and Encryption
0
0
–0.2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
2
4
6
8
10
–2
–1.5
–1
–0.5
0
0.5
x2
Recovered x2
1
1.5
2
20
40
60
80
100
(a)
(b)
Fig. 8.5 (a) x2 and ˆx2, (b) Synchronization error

8.5
Numerical Results
205
0
0
0
0.5
1
1
2
3
4
5
1.5
2
2.5
3
3.5
4
4.5
5
x 104
x 104
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
x 104
50
100
150
200
250
0
50
100
150
200
250
0
50
100
150
200
250
Fig. 8.6 Message and its red, green and blue histograms
The message is recovered without error, the image and its RGB histograms are identical
to the transmitted ones, proving that the algorithm can effectively encrypt and decrypt
data without any data loss during the process. The algorithm can also encrypt other types
of data, such as text messages, in this case, the process is similar and faster than the color
image, being different in the creation of initial conditions, to achieve similar results, half of
the message creates one initial condition and the remaining half for the other, the obtained
results are given next:
Text message: This chapter introduces a new encryption algorithm that relies on
fractional order chaotic systems synchronization
The encrypted message is:
Encrypted text message: dfasfdasd
And the recovered text message is:
Recovered text message: This chapter introduces a new encryption algorithm that
relies on fractional order chaotic systems synchronization
The algorithm is capable of encrypting data different than images and maintaining its
performance and accuracy in message reconstruction.

206
8
Fractional-Order Robust State Observers and Encryption
Fig. 8.7 Encrypted message and its red, green and blue histograms
The time computational complexity analysis of the algorithm is obtained according to
[33] and [34], the number of pixels composing the image is denoted by ij. The algorithm
will require the following number of instructions:
The ﬁrst step needs one function for providing the key, considering that the range of
values for chaotic behavior has been previously found. The second step will use 2ij +Npa
instructions if the chaotic oscillator has two states, the value of Npa is the number of
parameters to be obtained through the key (this number can vary depending on the chaotic
oscillator used). The third step will need 24ij+3 instructions for creating the binary signal,
another 21ij the operations done to the signal and ﬁnally 24ij for transmission, yielding
O(ij) = 71ij + 4 + Npa. This result shows that the algorithm has linear time complexity.
The algorithm was implemented using MATLAB for OS X, with a Core i5 at 1.3Ghz
(unable to overclock) and 4GB of DDR3 RAM, the required time varies depending on the
type of data, the text message took 1000µs, the 1683×2522 RGB image needed 10.302s,
the intention of choosing a large color image as message was to show the performance of
the algorithm while working with images similar to the ones that are created by current
cameras and other image sources, in most publications the authors prefer to use very small
greyscale images, even if it is not representative of common image resolutions and sizes,
thus giving a non precise representation of the performance of the proposed algorithms.

8.5
Numerical Results
207
0
0
0
0.5
1
1
2
3
4
5
1.5
2
2.5
3
3.5
4
4.5
5
x 104
x 104
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
x 104
50
100
150
200
250
0
50
100
150
200
250
0
50
100
150
200
250
Fig. 8.8 Recovered message and its red, green and blue histograms
In view of the results it is possible to say that the algorithm works well in conjunction
with the observer, as it made possible to recover the messages without any data loss, the
algorithm proved to be capable of encrypting various types of data of different sizes while
providing each of them with the same security features.
8.5.1
Situations that Lead to Decryption Failure
The primary cause of wrong data recovery is to not fulﬁll the conditions given in the
encryption and decryption sections. The binary signal that is proposed is very important,
in many works in the literature, there is no speciﬁcation on how to handle the data carrier
signal, the easiest way to create a data carrier signal is to simply scale down the 8 bit
integer values and assign to each value a time period, however, when using state observers
error will be present, and if such scaled down integer data carrier signal is used, this error
though small, will lead to an erroneous reconstruction of the transmitted data, also, if this
type of signal is used with the proposed algorithm, the error in the data reconstruction is
not guaranteed to be zero. Another mistake that could result in an erroneous reconstruction
of the data is to select the gains of the observer different than λmin (PKbC) > Smax +L+

208
8
Fractional-Order Robust State Observers and Encryption
B1 + ε, by doing this, the slave system is made unstable, causing the recovered data to be
different than the transmitted one. In the next images the results of incurring in such errors
can be seen.
Figure 8.9 shows the results of wrongful message reconstruction. In the ﬁrst image the
results of using a different data carrier signal can be seen, in the second, the resulting
recovered image of using an unstable state observer is shown. The ﬁrst case is caused
by not using the exact same encrypted values for the bitwise XOR operation causing the
decryption to produce a different result, the second erroneous decryption cause is that the
states of the observer were not bounded, making impossible to properly recover the data
carrier signal.
8.6
Security Analysis
Most of the cited literature regarding encryption by synchronization of fractional chaotic
systems can be affected by two cryptanalysis techniques, these two being chosen plaintext
attacks and generalized synchronization attacks, to exemplify this, the mentioned attacks
are implemented in two algorithms contained in the cited literature, then, these two attacks
are applied to our algorithm showing that they are ineffective.
In a known plaintext attack, the attacker knows a previous pair of message and
encrypted message, then, the attacker uses this information to extract data from a new
encrypted image that could lead to breaking the encryption. The chosen plaintext attack
[35] is similar, but with the difference that the attacker can choose what message to send,
so the attacker has access to a chosen message and is encrypted message, the pair of
messages is used to retrieve information to break the algorithm. In most stream ciphers
that use fractional chaotic system synchronization this attack can recover messages without
needing the key, the encryption method proposed in [25] is representative of this type of
stream ciphers, it can be easily described by the next equations, where the master is:
Dαx(t) = Ax(t) + f (x(t), y(t)) + Bd(t) + Ls(t)
y(t) = Cx(t) + s(t)
x(0) = x(0)
and the slave is:
Dα ˆx(t) = Aˆx(t) + f

ˆx(t), y(t)

+ Bd(t) + L
&
y(t) −ˆy(t)
'
ˆy(t) = C ˆx(t)
ˆx(0) = x(0)
ˆs(t) = y(t) −ˆy(t)

8.6
Security Analysis
209
Fig. 8.9 Improper message
reconstruction

210
8
Fractional-Order Robust State Observers and Encryption
The encrypted message is y and the message is denoted by s, if the attacker chooses a
black image for message, the signal s will be zero, and its encrypted message is y = Cx,
if a new message s2 is transmitted it is easy to recover it simply by s2 = y −Cx =
Cx + s2 −Cx, note that ﬁnding the key is unnecessary.
A chosen plaintext attack can successfully retrieve the values that were used for
encrypting the plain image, this is caused mainly because the encryption values will only
change if the key is changed, so all messages will be encrypted with the same set of values
producing the mentioned vulnerability. In Fig. 8.10 the result of the mentioned plaintext
attack is shown.
Using as chosen message a black image allowed to recover the output of the system
y(t) = Cx(t) without the inﬂuence of the message which is then used to decrypt future
messages. This simple form of chaotic masking is not very effective when the data carrier
signal is considerably different than the signals produced by the oscillators states, or has
different periods and amplitudes that make the extraction of the signal easy.
Another form of encryption that relies on synchronization of fractional chaotic systems
can be found on [32], the proposal found on this reference uses the synchronization of a
Lorenz like system, then it obtains a sequence of pseudorandom numbers from the states
of the system using an equation with ﬁxed values, the image is encrypted by a bitwise
XOR operation with the previously obtained sequence.
The mentioned encryption scheme causes the security of the data to depend solely on
the inability of the attacker to synchronize to the master system, as the key is presumably
used only to create the initial conditions and parameters of the Lorenz system. This is a
considerable ﬂaw as there are many ways to synchronize to the master system without
the need of knowing its exact parameters nor initial conditions, for example the state
observer that is introduced in this chapter can easily reconstruct its states without the exact
parameters making a synchronization attack similar to [36] viable, the master system used
for encryption is given by:
˙ˆx = f1 (x)
y = Cx
And a slight modiﬁcation of the proposed observer can synchronize to it:
˙ˆx = f2
ˆx + K tanh (e)
ˆy = C ˆx
The functions f1 and f2 share the same structure but posses different values, because
f1 will have the key and to the attacker it is unknown, hence f2 has not the exact same
parameters, but as it was proven, the observer can reconstruct the states of the master even
in the presence of disturbances (the message or an unknown key), once both systems have
been synchronized all that remains is to create the encryption values, and as they depend

8.6
Security Analysis
211
Fig. 8.10 Chosen plain image and resulting image of plaintext attack

212
8
Fractional-Order Robust State Observers and Encryption
solely on an equation that does not depend on the key or message, it is easy to compute
them using the same equation, this ﬁnally allows the attacker to access the encrypted data
without the need of the key. There are also other methods that could allow to compute the
value of the key such as parametric estimation, but the proposed one is more practical. The
implementation of the synchronization based cryptanalysis can be seen in Fig. 8.11.
The resulting image from the attack is very similar to the one used as message,
it has a small difference in color in certain regions, this is caused by not using the
exact same parameters, not knowing the key and the small error that the observer had.
The encryption algorithm introduced in this chapter renders both mentioned forms of
cryptanalysis useless, the message itself is not present in the output making the simple
chosen plaintext attack ineffective, most importantly, by making the initial conditions
depend on the message and the key, every signal used to encrypt the data will depend
on the message itself, so each message will have a unique encryption causing that this
type of attacks be useless. The synchronization attack will also be unsuccessful, because
for the use of the bitwise XOR operation that depends on the key, so even if the attacker
can achieve synchronization to the master system, the estimated data carrier signal will
be useless without the key to the attacker. To test this a chosen plaintext attack will be
implemented, a black image of size 1683 × 2522 pixels will be the chosen plaintext, the
goal of the attack will be to recover Fig. 8.6, the chosen plaintext and the result of the
attacks can be seen in Fig. 8.12.
The chosen plaintext attack failed to recover the message from Fig. 8.6, making evident
that the encryption is unaffected by known and chosen plaintext attacks. A synchronization
attack is performed next, the same technique that was used to recover a similar message
from [32] will be applied, to make the attack possible some elements of the key are
supposedly known, the parts of the key regarding the derivative order, and the timing of
the data carrier signal are required so the interpretation of the data is easy to visualize, the
attack produces the results shown in Fig. 8.13.
The attack is also ineffective, even if the observer can synchronize to the states, the
mixing with pseudorandomnumbers depending on the unknown key keeps the information
well hidden, allowing the information to remain safe. The correlation of two adjacent
pixels for the plain image in Fig. 8.6 and its encrypted message in Fig. 8.7 can be seen in
Fig. 8.14.
The graphic reveals that the encryption is effective, as the plain image correlation of
pixel is linear while the correlation of pixels in the encrypted image is not, ﬁnally the
entropy of the encrypted image is 7.9951 which is very close to the ideal number 8,
while not ideal, this indicates that there is not much predictability in the encrypted image,
considering all this the encryption algorithm offers a good level of protection from the
cryptographic techniques applied in this section and, according to the histograms and the
correlation graphic, the proposed algorithm will also provide protection against linear,
differential and other types of statistical cryptanalysis forms.

8.6
Security Analysis
213
Fig. 8.11 Message and resulting image of synchronization attack

214
8
Fractional-Order Robust State Observers and Encryption
Fig. 8.12 Chosen plain image
and resulting image of
plaintext attack

8.6
Security Analysis
215
Fig. 8.13 Message and resulting image of synchronization attack

216
8
Fractional-Order Robust State Observers and Encryption
Fig. 8.14 Correlation of adjacent pixels of the plain image and the encrypted image

References
217
8.7
Concluding Remarks
Using the proposed fractional smoothed sliding modes observer made possible to recover
data without any loss, Figs. 8.3, 8.4, and 8.5 show that the observer is capable of producing
an accurate reconstruction of the states with negligible chattering, attaining this level of
performance is crucial to maintain data recovery without loss, so the observer served its
purpose well.
The algorithm was capable of recovering the messages without error, this can be seen on
Figs. 8.6, 8.7, and 8.8, while having a reasonable execution time and linear time complexity
when working with large color images. As previously stated, the algorithm focus is to
provide security specially against cryptanalysis comprised of chosen plaintext attacks
and known plaintext attacks, but it also posses resistance against linear and differential
cryptanalysis as shown in the security analysis section.
To the best of the authors knowledge, the state of the art encryption algorithms that
depend on fractional order chaotic systems synchronization are susceptible to cryptanaly-
sis, in the security analysis section, it is shown that two of them can be easily broken by
chosen plaintext attacks and synchronization based cryptanalysis, but, this work proved
that it is possible to use fractional chaotic systems in an encryption algorithm while
maintaining good performance in data reconstruction and security against the common
cryptanalysis techniques that were mentioned.
References
1. Laskin, N. (2000). Fractional market dynamics. Physica A: Statistical Mechanics and its
Applications, 287(3), 482–492.
2. Hilfer, R. (Ed.). (2000). Applications of fractional calculus in physics. World Scientiﬁc.
3. Zhou, X. J., Gao, Q., Abdullah, O., & Magin, R. L. (2010). Studies of anomalous diffusion in the
human brain using fractional order calculus. Magnetic Resonance in Medicine, 63(3), 562–569.
4. Freeborn, T. J. (2013). A survey of fractional-order circuit models for biology and biomedicine.
IEEE Journal on Emerging and Selected Topics in Circuits and Systems, 3(3), 416–424.
5. Martínez-Guerra, R., Pérez-Pinacho, C. A., Gómez-Cortés, G. C. (2015). Synchronization of
chaotic Liouvillian systems: an application to Chua’s oscillator. In Synchronization of integral
and fractional order chaotic systems. Springer International Publishing.
6. Pecora, L. M., & Carroll, T. L. (1990). Synchronization in chaotic systems. Physical Review
Letters, 64(8), 821.
7. Abanda, Y., & Tiedeu, A. (2016). Image encryption by chaos mixing. IET Image Processing,
10(10), 742–750.
8. Abd-El-Haﬁz, S. K., Radwan, A. G., Haleem, S. H. A., & Barakat, M. L. (2014). A fractal-based
image encryption system. IET Image Processing, 8(12), 742–752.
9. Kocarev, L., Halle, K. S., Eckert, K., Chua, L. O., & Parlitz, U. (1992). Experimental
demonstration of secure communications via chaotic synchronization. International Journal of
Bifurcation and Chaos, 2(03), 709–713.
10. Liao, T. L., & Tsai, S. H. (2000). Adaptive synchronization of chaotic systems and its application
to secure communications. Chaos, Solitons and Fractals, 11(9), 1387–1396.

218
8
Fractional-Order Robust State Observers and Encryption
11. Liao, T. L., & Huang, N. S. (1999). An observer-based approach for chaotic synchronization
with applications to secure communications. IEEE Transactions on Circuits and Systems I:
Fundamental Theory and Applications, 46(9), 1144–1150.
12. Cuomo, K. M., Oppenheim, A. V., & Strogatz, S. H. (1993). Synchronization of Lorenz-
based chaotic circuits with applications to communications. IEEE Transactions on Circuits and
Systems II: Analog and Digital Signal Processing, 40(10), 626–633.
13. Feki, M. (2003). An adaptive chaos synchronization scheme applied to secure communication.
Chaos, Solitons and Fractals, 18(1), 141–148.
14. Huang, X., Sun, T., Li, Y., & Liang, J. (2014). A color image encryption algorithm based on a
fractional-order hyperchaotic system. Entropy, 17(1), 28–38.
15. Hsiao, H. I., & Lee, J. (2015). Color image encryption using chaotic nonlinear adaptive ﬁlter.
Signal Processing, 117, 281–309.
16. Janakiraman, S., Thenmozhi, K., Rayappan, J. B. B., & Amirtharajan, R. (2018). Lightweight
chaotic image encryption algorithm for real-time embedded system: Implementation and
analysis on 32-bit microcontroller. Microprocessors and Microsystems, 56, 1–12.
17. Xu, L., Gou, X., Li, Z., & Li, J. (2017). A novel chaotic image encryption algorithm using block
scrambling and dynamic index based diffusion. Optics and Lasers in Engineering, 91, 41–52.
18. Sun, S. (2017). Chaotic image encryption scheme using two-by-two deoxyribonucleic acid
complementary rules. Optical Engineering, 56(11), 116117.
19. Teng, L., Wang, X., & Meng, J. (2017). A chaotic color image encryption using integrated bit-
level permutation. Multimedia Tools and Applications, 77(6), 6883–6896.
20. Liu, H., Kadir, A., & Sun, X. (2017). Chaos-based fast colour image encryption scheme with
true random number keys from environmental noise. IET Image Processing, 11(5), 324–332.
21. Liu, L., Miao, S., Hu, H., & Cheng, M. (2016). N-phase logistic chaotic sequence and its
application for image encryption. IET Signal Processing, 10(9), 1096–1104.
22. TDridi, M., Hajjaji, M. A., Bouallegue, B., & Mtibaa, A. (2016). Cryptography of medical
images based on a combination between chaotic and neural network. IET Image Processing,
10(11), 830–839.
23. Abd-El-Haﬁz, S. K., Radwan, A. G., Haleem, S. H. A., & Barakat, M. L. (2014). A fractal-based
image encryption system. IET Image Processing, 8(12), 742–752.
24. Wang, X. Y., & Gu, S. X. (2014). New chaotic encryption algorithm based on chaotic sequence
and plain text. IET Information Security, 8(3), 213–216.
25. N’Doye, I., Darouach, M., & Voos, H. (2013, July). Observer-based approach for fractional-
order chaotic synchronization and communication. In European Control Conference (ECC) (pp.
4281–4286).
26. Luo, C., & Wang, X. (2013). Chaos generated from the fractional-order complex Chen system
and its application to digital secure communication. International Journal of Modern Physics C,
24(04), 1350025.
27. Wu, X., Wang, H., & Lu, H. (2012). Modiﬁed generalized projective synchronization of a new
fractional-order hyperchaotic system and its application to secure communication. Nonlinear
Analysis: Real World Applications, 13(3), 1441–1450.
28. Deng, Y. S., Qin, K. Y., & Shao, S. Q. (2009, July). Synchronization in coupled fractional order
Chen-system and its application in secure communication. In Communications, Circuits and
Systems. ICCCAS 2009 (pp. 839–841).
29. Kiani-B, A., Fallahi, K., Pariz, N., & Leung, H. (2009). A chaotic secure communication scheme
using fractional chaotic systems based on an extended fractional Kalman ﬁlter. Communications
in Nonlinear Science and Numerical Simulation, 14(3), 863–879.
30. Sheu, L. J. (2011). A speech encryption using fractional chaotic systems. Nonlinear Dynamics,
65(1), 103–108.

References
219
31. Zhen, W., Xia, H., Ning, L., & Xiao-Na, S. (2012). Image encryption based on a delayed
fractional-order chaotic logistic system. Chinese Physics B, 21(5), 050506.
32. Xu, Y., Wang, H., Li, Y., & Pei, B. (2014). Image encryption based on synchronization of
fractional chaotic systems. Communications in Nonlinear Science and Numerical Simulation,
19(10), 3735–3744.
33. Goldreich, O. (2008). Computational complexity: A conceptual perspective. Cambridge Univer-
sity Press. 1st edition.
34. Martin, J. C. (1991). Introduction to languages and the theory of computation (Vol. 4). New
York, NY: McGraw-Hill.
35. Alvarez, G., & Li, S. (2006). Some basic cryptographic requirements for chaos-based cryptosys-
tems. International Journal of Bifurcation and Chaos, 16(08), 2129–2151.
36. Yang, T., Yang, L. B., & Yang, C. M. (1998). Breaking chaotic switching using generalized
synchronization: Examples. IEEE Transactions on Circuits and Systems I: Fundamental Theory
and Applications, 45(10), 1062–1067.

9
Secure Communications by Using
Atangana-Baleanu Fractional Derivative
Abstract
In this chapter the authors propose to use fractional-order chaotic systems for data
encryption, the encryption is a hybrid cipher, that takes elements of stream ciphers and
block ciphers, to allow to handle large messages without compromising the security
of the message or severely increasing the need of computational power to process
the encryption algorithm. The cipher relies on the synchronization of chaotic systems
by using state observers, the observer is capable of accurately recovering states and
uncertainties within the fractional-order chaotic system. To test the algorithm and
observer, the messages in this chapter are color images.
9.1
Introduction
Fractional calculus has seen developments in various ﬁelds like ﬁnance [1], physics [2],
Medicine [3] and chaotic systems synchronization, in this last ﬁeld, one of its most
notorious applications are secure communications [4,5], where a fractional-order chaotic
system is used as a pseudorandom number generator, which in turn, serves as input
for an encryption algorithm. The usual method employed for encryption is to mask a
signal containing a message with a fractional-order chaotic oscillator state or output, the
oscillator is named as the master system in synchronization, then the slave system task is to
reconstruct the signal that contains the message and in consequence recover the encrypted
message that the signal contains.
Since the introduction of synchronization by Pecora various methods have been used
for the reconstruction of message signals, the most recurrently present in the literature
are generalized synchronization, reconstruction of states by Liouvillian systems properties
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6_9
221

222
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
and state observers [6], although most of them offer similar results in the precision of the
reconstructed signal, the way in which the message is converted into a signal and how
the signal is encrypted, impacts heavily on the performance of the decryption process,
as in various cases the treatment given to the signal does not allow for any error in its
reconstruction if the message is required to be correctly recovered, then it is of upmost
importance to correctly choose how the master and slave systems are to be synchronized,
and to craft the message signal so it properly ﬁts into the synchronization and allows the
correct recovery of messages.
In the literature there are several works on secure communications using fractional-
order chaotic systems synchronization, in particular the most popular encryption are
stream ciphers that relay on chaotic masking, but in the majority of cases it is not
properly done and many crucial speciﬁcations on the message signal are missing. The
preferred synchronization method are state observers, and the prevalent ones are variants
of the Luenberger observer, this choice of observer limits where the message signal can
be embedded in the master system, and in various ways, contributes to an inaccurate
reconstruction of both the signal and the message.
In this chapter, the authors propose the implementation of a hybrid encryption scheme,
that contains elements of chaotic masking, chaos shift keying and block ciphers that can
guarantee an error free message reconstruction even if the reconstruction of the signal
is not totally accurate and with high tolerance to noise within the message signal. To
achieve the desired result an uncertainty state observer for fractional-order chaotic systems
is proposed as the slave system, the set of pseudorandom numbers is generated through a
fractional-order chaotic oscillator with Mittag-Lefﬂer kernel [7, 8] and a variation of the
Blum Blum Shub generator.
9.2
Preliminaries
The proposed work is based on the following deﬁnitions:
Deﬁnition 9.1 The Riemann-Liouville fractional derivative of a function f (t) is:
RLDα
t f (t) =
1
Γ (n −α)
 t
0
f n (τ)
(t −τ)n−α+1 dτ
With n−1 < α < n and Γ (•) is the gamma function given by Γ (α) =  ∞
0
tα−1e−tdt
that converges to the right half of the complex plane.
Deﬁnition 9.2 The Riemann-Liouville fractional integral of a function f (t) is:
0I α
t f (t) =
1
Γ (α)
 t
0
f (τ) (t −τ)α−1 dτ

9.2
Preliminaries
223
Deﬁnition 9.3 The Caputo fractional derivative of order α of a function f (t) is described
by:
C
toDα
t f (t) =
1
Γ (n −α)
 t
to
f (n) (τ) (t −τ)n−α−1 dτ
And f (n) (τ) is the n-th derivative, n is positive integer number.
Recent developments in deﬁnitions of fractional derivatives correct some of the issues
of the convolution law based fractional-order derivatives, such as Riemman-Liouville and
Caputo, these problems involve mostly singularities, one of this new derivative deﬁnitions
is given next:
Deﬁnition 9.4 For f
∈H 1 (a, b),
a < b and α ∈[0, 1] The Atangana-Baleanu
fractional derivative of order α of a functionf (t) is described by:
ABCDα
t f (t) = W (α)
1 −n
 t
a
f ’ (τ) Eα

−α (t −y)α
1 −α

dτ
Where W (•) with W (0) = W (1) is a normalization function and Eα is the Mittag-
Lefﬂer function deﬁned by:
Eα (z) =
∞
"
n=0
zn
 (nα + 1)
Lemma 9.1 The Atangana-Baleanu Fractional differential equation ABC
0
Dα
t f (t) = u (t)
has a unique solution if the equation fulﬁlls [7]:
f (t) = 1 −α
W (α)u (t) +
α
W (α)  (α)
 t
0
u (τ) (t −τ)α−1 dτ
Lemma 9.2 If a real positive deﬁnite function V [x (t)] exists, and it results to a negative
semi-deﬁnitie fractional function deﬁned by Dα [x (t)] with α ∈(0, 1], then the fractional
system is asymptotically stable [7,9] this is:
a1 ∥x∥≤V (x) ≤a2 ∥x∥
DαV (x) ≤−a3 ∥x∥
With a1, a2, a3 > 0.

224
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
9.3
Encryption Algorithm
The encryption algorithm is similar to chaos shift keying, in the sense that it will employ
a binary data carrier signal g (s, y) to change the value of one of the parameters of the
system, but with the difference that it does not change the attractors shape, it rather just
behaves like an unknown parameter, the dynamic of the transmitter is given next:
ABC
0
Dα
t x1 = Ax + f (x) + CT sc
y = Cx
Where 0 < α < 1, the function f (x) is bounded by the Lipschitz condition:
∥f (w) −f (z)∥≤Γ ∥w −z∥, Γ, w, z ∈R
The set of instructions for creating the data carrier signal and parameters of the system
is presented next, for it, it is assumed that the data is a color image of size ij composed
of three matrices that contain the primary color intensity of the image denoted by R ∈
Ni×j, 0 ≤Rij ≤255 , G ∈Ni×j, 0 ≤Gi×j ≤255 and B ∈Ni×j, 0 ≤Bij ≤255.
1. The key is a set of decimal values separated into smaller sections denoted Keyn, n =
1, 2, 3, . . ., the key must contain enough elements for the subsequent steps
Key = 12345 −12345 −12345 −12345 −12345 −. . .
Key = key1 −key2 −key3 −key4 −key5 −. . .
2. The initial conditions of the oscillator are given by the key and the message, the next
equations describe the process:
x1 (0) = Key1
99999
)ij
a=1 Ra
255ij
, x2 (0) = Key2
99999
)ij
a=1 Ga
255ij
The remaining parameters can be computed by only using the key, for example the
value of α ∈[0, 1] is obtained by:
α = key3
99999
3. The data carrier signal s is made from the message, since the image is formed by 8 bit
integers they have to be converted into its binary representation, then arranged into a
single vector of size 24ij and then subtract 0.5 so that a positive period is a 1 and a

9.3
Encryption Algorithm
225
0
–1.5
–1
0
2
4
6
8
10
173=10101101
–0.5
0.5
1
1.5
Fig. 9.1 Signal representation of the integer number 173
negative is 0, the period of the signal is given by:
P = Key4
99999
For example, Fig. 9.1 shows how to convert the integer 173 into its equivalent binary
signal with a 1 s period.
4. Factorize two key elements in prime numbers, the two largest primes p and q are
the inputs for the pseudo random number generator given by the Blum Blum Shub
algorithm:
rn+1 = r2
n mod (pq)
The number of iterations for the Blum Blum Shub algorithm is given by another
element of the key.
5. The encrypted signal is described by the equation:
sc = s ⊕r
Where ⊕is the bitwise XOR operation.

226
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
By using this algorithm the problem of the encrypted message not depending on the
transmitted message has been addressed, even more, using the binary signal will allow
a certain room for error in the reconstruction while not compromising the integrity of
the data, as it is only needed to be accurate on the sign of the reconstructed data carrier
signal, unlike chaos masking that must have perfect reconstructions to guarantee no data
loss.
9.4
Receiver and Decryption
The receiver will be a sliding modes state observer, this kind of observer can easily deal
with unknown parameters such as the binary data carrier signal, but also the binary signal
can maintain zero data loss in the presence of chattering, making it appropriate for this
task, the observer dynamic is described:
ABC
0
Dα
t ˆx = Aˆx + f ˆx + ka
y −ˆy + kb tanh y −ˆy
ABC
0
Dα
t γ = kc tanh y −ˆy
ˆy = C ˆx
ˆsc = ABC
0
Dα
t y −f

ˆx

The synchronization error is:
e = x −ˆx
The error’s fractional-order derivative of order α is:
ABC
0
Dα
t e = Ae + φ (e) + CT s −KaCe −Kb tanh(Ce)
Where φ (e) = f (x) −f

ˆx

and Cs < Λ is bounded by the positive amplitude of the
binary signal.
Assumption 9.1 The next LMI has solutions P = P T > 0 and Q = QT > 0:
(A −KaC)T P + P (A −KaC) ≤−Q
Assumption 9.2 The message signal and the nonlinear part of the oscillator are bounded:
∥sc∥≤Smax
∥f (x) −f (y)∥≤Φ ∥x −y∥
2xP

CT Smax + Φv

≤Λ ∥x∥

9.4
Receiver and Decryption
227
For a positive real number Smax and Λ, and a vector Φv that contains the bounds Φ for
the non linear part of each state.
A function that fulﬁlls Lemma 9.2 is:
V = eT Pe
ABC
0
Dα
t V =

Dαe
T Pe + eP T 
Dαe

+2
∞
"
k=0
 (1 + α)
DkeT Dα−ke
Γ (1 + k) Γ (1 −k + α)
Knowing that Dnx with n = 1, 2, 3 . . . exists and is continuous and bounded, there is
an N ∈R, N ≥0 such that ∥Dnx∥≤N, for a real non integer α there is an integer U
such that U −1 < α < U, and the derivative Dα−nx is divided into two parts:
Dα−nx, n = 1, 2, . . . , U −1 and Dα−ne, n = U,U +1, U +2, . . . for the ﬁst part Dα−nx
for n = 1, 2, . . . , U −1 there is a real number H > 0 that makes
Dα−nx
=
I α−nx
 ≤
H ∥x∥, the fractional-order nonlinear system can be expressed as Dαx = f (x). The
dynamic of the system is bounded by ∥f (x)∥< J ∥x∥the inequality
Dα−nx
 ≤
HJ ∥x∥is true, for the next part Dα−ne, n = U, U +1, U +2, . . . by a similar process, it is
obtained that
Dα−nx
 ≤Hmax ∥x∥for a real number Hmax > 0, so
Dα−nx
 ≤¯H ∥x∥
with ¯H = max {HJ, Hmax}, with the next inequality 0 < Jmin < |Γ (1 −α + n)|, for a
positive real number Jmin > 0 and since
Γ (n)
Γ (n+1) = 1
n for n = 1, 2, 3, . . ., the expression
)∞
n=1
1
Γ (1+n) converges, so there is a K > 0 that 0 < )∞
n=1
1
Γ (1+n) < K, making the
Lyapunov fractional-order derivative:
ABC
0
Dα
t V ≤

ABC
0
Dα
t e
T
Pe + eT P

ABC
0
Dα
t e

+ 2B ∥e∥
Making B = (1+α)NK ¯H
Jmin
and tanh (x) ≤sign (x) + γ for an appropriate positive real
number γ :
ABC
0
Dα
t V ≤eT 
(A −KaC)T P + P (A −KaC)

e
+2eT P

CT sc + φ (e) −Kbsign (Ce) −Kbγ

+ 2B ∥e∥
By Assumption 9.2:
ABC
0
Dα
t V ≤eT 
(A −KaC)T P + P (A −KaC)

e
+2eT P

CT Smax + Φv

−2eT PKbsign (Ce) −2eT Pkbγ + 2B ∥e∥
≤−eT Qe + 2 ∥e∥−2eT PKbsign (Ce) −2eT Pkbγ + 2B ∥e∥

228
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
The inequality 2eT Pkbγ < ε ∥e∥leads to:
ABC
0
Dα
t V ≤−eT Qe + 2 ( −ε + B) ∥e∥−
2
!
λmax

CT C
eT PKbC e
∥e∥
So:
ABC
0
Dα
t V ≤2 [( −ε + B) −λmin (PKbC)] ∥e∥−2eT Pε
Making Kb such that λmin (PKbC) >  + B −ε yields:
ABC
0
Dα
t V ≤0
With this last result it is possible to conclude that the synchronization error will be
Mittag-Leffer stable, hence it makes possible to reconstruct the states and recover the
message by:
ˆsc = ABC
0
Dα
t y −f

ˆx

Having recovered the estimated data carrier signal, the key is used to reconstruct the
values of the binary signal and the pseudorandom numbers used to encrypt it. The resulting
message is the arranged into the recovered message.
9.5
Numerical Results
Stream ciphers can handle large data much better than block ciphers, to show the
capabilities of the proposed encryption algorithm a simulation will be implemented using
the next fractional-order Rossler oscillator as master system:
ABC
0
Dα
t x1 = −x2 −x3
ABC
0
Dα
t x2 = x1 + ax2 + s
ABC
0
Dα
t x2 = b + x3 (x1 −r)
y = x2
The Rossler fractional-order chaotic oscillator has the kernels deﬁned by:
K1 (x1, t) = −x2 −x3
K2 (x2, t) = x1 + ax2 + s
K3 (x3, t) = b + x3 (x1 −r)

9.5
Numerical Results
229
Using Lemma 9.1, the kernels Ki, i ∈1, 2, 3 lead to the following equation of the
states:
x1 (t) = x1 (0) + 1 −α
W (α)K1 (x1, t) +
α
W (α) Γ (α)
 t
0
(t −y)α−1 K1 (y, x1) dy
x2 (t) = x2 (0) + 1 −α
W (α)K2 (x2, t) +
α
W (α) Γ (α)
 t
0
(t −y)α−1 K2 (y, x2) dy
x3 (t) = x3 (0) + 1 −α
W (α)K3 (x3, t) +
α
W (α) Γ (α)
 t
0
(t −y)α−1 K3 (y, x3) dy
A method for the numerical approximation for the states of a fractional-order system,
using the Atangana-Baleanu derivative is given in [10], the equation for the approximation
of a state depending on its kernel is:
un+1 = u0 + 1 −α
W (α)f [u (tn) , tn]
+
α
W (α)
n
"
s=0
1hαf (us, ts)
Γ (α + 2)
&
(n + 1 −s)α (n −s + 2 + α)
−(n −s)α (n −s + 2 + 2α)
'
−hαf (us−1, ts−1)
Γ (α + 2)
&
(n + 1 −s)α −(n −s)α (n −s + 1 + α)
'2
+Eα
n
Where Eα
n =
α
W(α)Γ (α)
)n
s=0
 ts−1
ts
(y−ts)(y−ts−1)
2
∂2
∂y2 [f (u (y) , y)]y=λy (tn+1 −y)α−1
dy, making the states for the numerical simulation be computed by the next equations:
x1,n+1 = x1,0 + 1 −α
W (α)K1 [x1 (tn) , tn]
+
α
W (α)
n
"
s=0
(
hαK1
x1,s, ts

Γ (α + 2)
&
(n + 1 −s)α (n −s + 2 + α)
−(n −s)α (n −s + 2 + 2α)
'
−hαK1

x1,s−1, ts−1

Γ (α + 2)
&
(n + 1 −s)α −(n −s)α (n −s + 1 + α)
'
5
+Eα
n

230
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
x2,n+1 = x2,0 + 1 −α
W (α)K2 [x2 (tn) , tn]
+
α
W (α)
n
"
s=0
(
hαK2

x2,s, ts

Γ (α + 2)
&
(n + 1 −s)α (n −s + 2 + α)
−(n −s)α (n −s + 2 + 2α)
'
−hαK2
x2,s−1, ts−1

Γ (α + 2)
&
(n + 1 −s)α −(n −s)α (n −s + 1 + α)
'
5
+Eα
n
x3,n+1 = x3,0 + 1 −α
W (α)K3 [x3 (tn) , tn]
+
α
W (α)
n
"
s=0
(
hαK3

x3,s, ts

Γ (α + 2)
&
(n + 1 −s)α (n −s + 2 + α)
−(n −s)α (n −s + 2 + 2α)
'
−hαK3

x3,s−1, ts−1

Γ (α + 2)
&
(n + 1 −s)α −(n −s)α (n −s + 1 + α)
'
5
+Eα
n
The receiver will be the presented sliding modes state observer:
ABC
0
Dα
t ˆx1 = −ˆx2 −ˆx3 + k1e + k2 tanh (e) + γ
ABC
0
Dα
t ˆx2 = ˆx1 + a ˆx2 + k3e + k4 tanh (e) + γ
ABC
0
Dα
t ˆx2 = b + ˆx3

ˆx1 −r

+ k5e + k6 tanh (e) + γ
ABC
0
Dα
t γ =
⎡
⎢⎣
k7
k8
k9
⎤
⎥⎦tanh (e)
y = ˆx2
ˆs = ABC
0
Dα
t y −ˆx1 −a ˆx2
The next parameters will lead to chaotic behavior a = 0.2, b = 0.2, r = 7 and
gains are ka =

−3.485 5.978 −2.866
T
, kb =

6.204 8.715 −3.624
T
and ka =

−7.395 6.925 −3.147
T
, since a stream cipher can handle large data a 12 megapixel

9.6
Security Analysis
231
Fig. 9.2 Original message
(4032×3024) color image is an adequate example. In Fig. 9.2 the results of the encryption
an decryption process are presented along the original message.
The encryption process is adequate, as it is possible to see (Fig. 9.3), there are no traces
of the message image into the encrypted message. The performance of the state observer
can be seen in Figs. 9.4, 9.5, 9.6, 9.7, and 9.8.
The observer can easily reconstruct the message and the states of the transmitter, while
achieving zero data loss, because of the combination of a binary data carrier signal with a
robust state observer, the proposed algorithm made use of the binary signal used in chaos
shift keying, to avoid the data loss that any error in the reconstruction of the states would
cause, using tanh instead of sign, attenuated the sliding modes chattering which would
have led to reconstruction error if the encryption was done by a simple chaotic masking.
9.6
Security Analysis
The current examples of stream ciphers in the literature that use fractional-order chaotic
systems, fail to provide security against cryptanalysis based on chosen plaintext attacks
and known plaintext attacks, the known plaintext attack consists in the attacker knowing
several messages and the corresponding encrypted message, which are used to retrieve
information that will allow to decrypt new encrypted messages by identifying the key or

232
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
500
1000
1500
3000
2500
2000
1500
1000
500
2000
2500
3000
3500
4000
Fig. 9.3 Encrypted message
Fig. 9.4 Recovered message

9.6
Security Analysis
233
0.5
0.4
0.3
0.2
0.1
0
–0.1
–0.2
–0.3
–0.4
–0.5
20
20.002
20.004
20.006
20.008
20.01
Message
Recovered
20.012
Fig. 9.5 The number 173 as message and the recovered signal
–0.2
–0.4
–0.6
–0.8
–1
–1.2
–1.4
–1.6
–1.8
–2
0
0.5
1
1.5
2
2.5
3
0
Fig. 9.6 Message recovery error

234
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
Fig. 9.7 Attractor synchronization
generating a equivalent key, a chosen plaintext attack is similar to the last one, with the
difference that the attacker has access to the encryption device and can send speciﬁcally
designed messages that will yield encrypted messages that contain valuable information to
also recover the key or generate an equivalent key that will allow unauthorized decryption
of further messages.
Stream ciphers used in the literature can be described by the next equation:
ABC
0
Dα
t x = f (x)
y = Cx + s
A practical and very easy way to break this encryption is to use a chosen plaintext
attack, since the revised literature does not specify any way to make the encrypted message
dependent on the message or simply assign the initial condition to ﬁxed key values,
generating an equivalent key can be done by designing a ﬁrst message that causes s = 0,
in a common masking a black image should do it, then the recovered message will be
y = Cx, being Cx the equivalent key, as the states only change if the key changes, it will
always be the same regardless of the message, then, the following messages can easily be
retrieved with the equivalent key: s2 = y −Cx = Cx + s2 −Cx.

9.7
Concluding Remarks
235
Fig. 9.8 Synchronization error
The proposed encryption algorithm avoids this problem by making the encrypted
message dependent on the message, even more, the data carrier signal is not directly
present on the encrypted message, so separating it from the rest of the message would
require knowledge of several elements of the key that were used for the system’s
parameters, to test this a chosen plaintext attack will be implemented. A black 12
megapixels image is used as chosen message with the intention to recover the message
used in the numerical results section, the result of the attack is shown in Fig. 9.9.
The attack clearly is unsuccessful, since the signals used to encrypt the black image
are completely different than the ones used for the original message, the equivalent key
is useless, showing that it is possible to make a safe stream cipher while using fractional-
order chaotic systems.
9.7
Concluding Remarks
The encryption algorithm shows that it is possible to implement a secure stream cipher
while using fractional-order chaotic systems. The sliding modes state observer along with
the binary signal made possible to operate without data loss and removing the chattering

236
9
Secure Communications by Using Atangana-Baleanu Fractional Derivative
500
1000
1500
3000
2500
2000
1500
1000
500
2000
2500
3000
3500
4000
Fig. 9.9 Cryptanalysis result
that sliding modes posses, by correctly using the properties of fractional-order chaotic
systems, the issue of not making the encrypted message depend on the message was
solved, making the proposed stream cipher able to have no data loss and help the data
remain safe.
The current works present on the literature about secure communications on fractional-
order chaotic systems did not allow to safely transmit data while guaranteeing the integrity
of the message, therefore, this result shows an alternative that can solve both problems
while remaining fast and able to manage large quantities of data.
References
1. Laskin, N. (2000). Fractional market dynamics. Physica A: Statistical Mechanics and its
Applications, 287(3–4), 482–492.
2. Hilfer, R. (2000). Applications of fractional calculus in physics. Singapore: World Scientiﬁc.
3. Zhou, X. J., Gao, Q., Abdullah, O., & Magin, R. L. (2010). Studies of anomalous diffusion in the
human brain using fractional order calculus. Magnetic Resonance in Medicine, 63(3), 562–569.
4. Montesinos-Garcia, J. J., & Martinez-Guerra, R. (2019). A numerical estimation of the
fractional-order Liouvillian systems and its application to secure communications. International
Journal of Systems Science, 50(4), 791–806.
5. Montesinos-Garcia, J. J., & Martinez-Guerra, R. (2018). Colour image encryption via fractional
chaotic state estimation. IET Image Processing, 12(10), 1913–1920.

References
237
6. Martinez-Guerra, R., Perez-Pinacho, C. A., & Gomez-Cortes, G. C. (2015). Synchronization
of integral and fractional order chaotic systems. In A differential algebraic and differential
geometric approach. Berlin: Springer.
7. Owolabi, K. M., Gomez-Aguilar, J. F., & Karaagac, B. (2019). Modelling, analysis and
simulations of some chaotic systems using derivative with Mittag–Lefﬂer kernel. Chaos, Solitons
& Fractals, 125, 54-63.
8. Goufo, E. F. D., & Atangana, A. (2019). Modulating chaotic oscillations in autocatalytic reaction
networks using atangana–baleanu operator. In Fractional derivatives with Mittag-Lefﬂer kernel
(pp. 135–158). Cham: Springer.
9. Li, Y., Chen, Y., & Podlubny, I. (2009). Mittag–Lefﬂer stability of fractional order nonlinear
dynamic systems. Automatica, 45(8), 1965–1969.
10. Touﬁk, M., & Atangana, A. (2017). New numerical approximation of fractional derivative
with non-local and non-singular kernel: Application to chaotic models. The European Physical
Journal Plus, 132(10), 444.

Index
A
ASCII, 48
Asymmetric key, 2
Asymptotically stable, 12, 161
Atangana-Baleanu, 223
Autonomous system, 13
B
Basins of attraction, 14
Binary number, 49, 168, 196
Bitwise XOR operation, 6, 56
Block cipher, 6, 83, 159, 222, 228
Block encryption, 5
Blum Blum Shub, 73
C
Chua oscillator, 38, 77
Cipher, 2, 60, 129, 184, 208, 234
Ciphertext, 47, 113, 118
Color image, 69, 118, 201
Colpitts oscillator, 81, 119
Cryptanalysis, 5, 130, 165, 192, 231
Cryptographic, 2, 57, 187, 212
Cryptography, 49
CSK, 1
CTAK, 72
D
Decryption, 2, 47, 127, 160, 192, 222
Dufﬁng oscillator, 13, 75, 201
E
Embedded, 80, 194
Encrypted message, 3, 89, 123, 179, 205
Encryption, 1, 47, 117, 191, 224
Equilibrium point, 9, 161
Euler’s number, 141
Exponential polynomial, 123
F
Fractal dimension, 41
Fractional-order, 151, 217
Fractional-order chaotic system, 221
G
Gamma function, 134, 161, 198, 222
Gauss error integral, 136
Grayscale image, 63
H
Histogram, 129, 171, 201
I
Instability theorem, 28
J
Julia set, 41, 118
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023
R. Martínez-Guerra et al., Encryption and Decryption Algorithms for Plain Text
and Images using Fractional Calculus, Synthesis Lectures on Engineering,
Science, and Technology, https://doi.org/10.1007/978-3-031-20698-6
239

240
Index
K
Key, 3, 74, 98
Keystream, 2, 72
L
Laplace transform, 133, 162
Legendre Duplication Formula, 140
Linearization, 15
Liouvillian system, 98, 99, 118, 181, 221
Lorenz system, 12, 210
Luenberger observer, 30, 90, 123, 172
Lyapunov exponents, 3, 10, 194
Lyapunov’s direct method, 12
M
Mandelbrot set, 41
Masking, 6, 210
Message, 4, 53, 98
N
Non autonomous system, 13
O
Orbit, 3, 10
P
Parametric estimation, 212
Pixel, 42, 58, 129, 177, 201
Plain image, 60, 120, 182, 192
Plaintext, 5, 47, 119, 175, 191
Plaintext attack, 129, 177, 201
PRNG, 73
Pseudorandom number generator, 73, 221
Pseudorandom numbers, 72, 119, 192
R
Random, 3, 10, 85, 97
Receiver, 7, 117, 169, 193, 226
Recovered message, 176, 200
RGB, 48, 128, 171, 197
Rössler chaotic oscillator, 21, 81
S
Secure communications, 1, 30, 72, 117, 171,
191, 236
Security, 72, 171, 191, 231
Security analysis, 160
Security code, 3
Sink, 10
Stability, 12, 78, 118, 162, 198
State observer, 30, 77, 98, 117, 172, 197, 222
Stream cipher, 6, 69, 159, 208, 222
Symmetric key, 2
Symmetric key algorithm, 48
Synchronization, 6, 12, 72, 117, 159, 191, 221
Synchronization error, 123, 171, 197
T
Transmitter, 6, 117, 169, 192, 224
U
Unstable dynamics, 9
V
Van Der Pol oscillator, 19, 77
Vulnerability, 210
X
XOR, 2, 85, 122, 168, 196

