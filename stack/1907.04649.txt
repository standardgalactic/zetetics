1 
 
Quantifying the pathways to life using assembly spaces 
 
Stuart M. Marshall,1 Douglas G. Moore,2 Alastair R. G. Murray,1 Sara I. Walker,2,3* and Leroy 
Cronin1* 
1 School of Chemistry, University of Glasgow, Glasgow, G12 8QQ, UK.  
2 BEYOND Center for Fundamental Concepts in Science, Arizona State University, Tempe, 
AZ, USA 
3 School of Earth and Space Exploration, Arizona State University, Tempe, AZ, USA 
*Corresponding author email: Lee.Cronin@glasgow.ac.uk, sara.i.walker@asu.edu  
 
Abstract 
We have developed the theory of pathway assembly to explore the extrinsic information 
required to distinguish a given object from a random ensemble. To quantify the assembly in an 
agnostic way, we determine the pathway assembly information contained within such an object 
by deconstructing the object into its irreducible parts, and then evaluating the minimum number 
of steps to reconstruct the object. The formalisation of this approach uses an assembly space. 
By finding the minimal number of steps contained in the route by which the objects can be 
assembled within that space, we can compare how much information (ğ¼ğ¼) is gained from 
knowing this pathway assembly index (PA) according to ğ¼ğ¼ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘™ğ‘™ğ‘™ğ‘™ğ‘™ğ‘™ 
|ğ‘ğ‘|
|ğ‘ğ‘ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ|  where, for an end 
product with ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘¥ğ‘¥,  N is the set of objects possible that can be created from the same 
irreducible parts within ğ‘¥ğ‘¥ steps regardless of PA, and NPA is the subset of those objects with 
the precise pathway assembly index ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘¥ğ‘¥.  Applying this theory to objects formed in 1D, 
2D and 3D leads to the identification of objects in the world or wider Universe that have high 
assembly numbers. We propose that objects with high PA will be uniquely identifiable as those 
that must have been produced by biological or technological processes, rather than the 
assembly occurring via unbiased random processes alone, thereby defining a new scale of 
aliveness. We think this approach is needed to help identify the new physical and chemical 
laws needed to understand what life is, by quantifying what life does. 
 
Introduction 
In the thought experiment known as the â€œinfinite monkey theoremâ€, an infinite number of 
monkeys, each having a typewriter, produce strings of text by hitting keys at random (1). Given 
infinite resources, it can be deduced that the monkeys will produce all possible strings, 

2 
 
including the complete works of Shakespeare. However, when constrained to the bounds of the 
physical universe, the likelihood that any particular text is produced by a finite number of 
monkeys drops rapidly with the length of the text (2). This can also be extended to physical 
objects like cars, aeroplanes, and computers, which must be constructed from a finite set of 
objects - just as meaningful text is constructed from a finite set of letters. Even if we were to 
convert nearly all matter in the universe to object constructing monkeys, and give them the age 
of the universe in which to work, the probability that any monkey would construct any 
sufficiently complex physical object is negligible (3). This is an entropic argument â€“ the 
number of possible arrangements of the objects of a given composition increases exponentially 
with the object size. For example, if the number of possible play-sized strings is sufficiently 
large, it would be practically impossible to produce a predetermined Shakespearean string 
without the author. This argument implies information external to the object itself is necessary 
to construct an object if it is of sufficiently high complexity (4,5): in biology the requisite 
information partly comes from DNA, the sequence of which has been acquired through 
progressive rounds of evolution. Although Shakespeareâ€™s works are â€“ in the absence of an 
appropriate constructor (6) (an author) - as likely to be produced as any other string of the same 
length, our knowledge of English, and Shakespeare in particular, allows us to partition the set 
of possible strings to generate information about those strings containing meaning, and to 
construct them. 
 
Biological systems have access to a lot of information - genetically, epigenetically, 
morphologically, and metabolically - and the acquisition of that information occurs via 
evolutionary selection over successive cycles of replication and propagation (7). One way to 
look at such systems is by comparing the self-dissimilarity between different classes of 
complex system, allowing a model free comparison (8).  However, it has also been suggested 
that much of this information is effectively encrypted, with the heritable information being 
encoded with random keys from the environment (9). As such, these random keys are recorded 
as frozen accidents and increase the operative information content, as well as help direct the 
system during the process of evolution, producing objects that can construct other objects (10). 
This is significant since one important characteristic of objects produced autonomously by 
machinery (such as life), which itself is instructed in some way, is their relative complexity as 
compared to objects that require no information for their assembly beyond what chemistry and 
physics alone can provide. This means that for complex objects there is â€˜object-assemblyâ€™ 
information that is generated by an evolutionary system, and is not just the product of laws of 

3 
 
physics and chemistry alone. Biological systems are the only known source of agency in the 
universe (11), and it has been suggested that new physical laws are needed to understand the 
phenomenon of life (12). The challenge is how to explore the complexity of objects generated 
by evolutionary systems without a priori having a model of the system.  
 
Herein, we present the foundations of a new theoretical approach to agnostically quantify the 
amount of potential pathway assembly information contained within an object. This is achieved 
by considering how the object can be deconstructed into its irreducible parts, and then 
evaluating the minimum number of steps necessary to reconstruct the object along any 
pathway. The analysis of pathway assembly is done by the recursive deconstruction of a given 
object using shortest paths, and this can be used to evaluate the effective pathway assembly 
index for that object (13). In developing pathway assembly, we have been motivated to create 
an intrinsic measure of an object forming through random processes, where the only knowledge 
required of the system is the basic building blocks and the permitted ways of joining structures 
together. This allows determining when an extrinsic agent or evolutionary system is necessary 
to construct the object, permitting the search for complexity in the abstract, without any specific 
notions of what we are looking for, thus removing the requirement for an external imposition 
of meaning, see Figure 1. 
 
 
 
Figure 1: The Pathway Assembly process (centre) (13) is compared to implementations of 
Shannon Entropy (14) (left) and Kolmogorov Complexity (15) (right) for blue and white 
blocks. The Pathway Assembly process leads to a measure of structural complexity that 
accounts for the structure of the object and how it could have been constructed, which is in all 
cases computable and unambiguous. 

4 
 
 
The development of the Pathway Assembly (13) index (PA) was motivated by the desire to 
define a biological threshold, such that any object found in abundance with PA above the 
threshold would have required the intervention of one or more biological processes to form 
(16). The Pathway Assembly index (PA) of an object is the length of the shortest pathway to 
construct the object starting from its basic building blocks. It should be noted that this approach 
is entirely classical (17), allowing quantifying pathways through assembly space 
probabilistically as a way to understand what life does. We construct the object using a 
sequence of joining operations, where at each step any structures already created are available 
for use in subsequent steps, see Figure 2. The shortest pathway approach is in some ways 
analogous to Kolmogorov complexity (15), which in the case of strings is the shortest computer 
program that can output a given string. However, Pathway Assembly differs in that we only 
allow joining operations as defined in our model. This restriction is intended to allow the 
Pathway Assembly process to mimic the natural construction of objects through random 
processes, and it also importantly allows the PA of an object to be computable for all finite 
objects (see Theorem 4 in the SI).  
 
 
 
Figure 2: The basic concept of pathway assembly is shown here. Each of the final structures 
can be created from white and blue basic objects in four joining operations, giving a Pathway 
Assembly Index of 4. Pathway (a) shows the creation of a structure that can only be formed in 
four steps by adding one basic object at a time, while pathway (c) represents the maximum 
increase in size per step, by combining the largest object in the pathway with itself at each 
stage. Pathway (b) is an intermediate case.  

5 
 
Given a system where objects interact randomly and with equal probability, it is intuitively 
clear that the likelihood of an object being formed in ğ‘›ğ‘› steps decreases rapidly with ğ‘›ğ‘›. 
However, it is also true that a highly contrived set of biases could guarantee the formation of 
any object. For example, this could occur if we were to model the system such that any 
interactions contributing to the formation of the object were certain to be successful, while 
other interactions were prohibited. For complex objects, such a serendipitous set of biases 
would seem unlikely in the absence of external information about the end products, but physical 
systems generally do have biases in their interactions, and we can explore how these affect the 
likelihood of formation of objects. However, we expect for any perceived â€œconstruction 
processesâ€ that requires a large enough set of highly contrived biases, we can deduce that 
external information is required in the form of a â€œmachineâ€ that is doing the constructing. 
 
Technological processes are bootstrapped to biological ones, and hence, by extension, 
production of technosignatures involves processes that necessarily have a biological origin. 
Examples of biosignatures and technosignatures include chemical products produced by the 
action of complex molecular systems such as networks of enzymes (18), and also objects whose 
creation involved any biological organisms such as technological artefacts (19), complex 
chemicals made in the laboratory (20), and the complete works of Shakespeare. Finding the 
object in some abundance, or a single object with a large number of complex, but precisely 
repeating features, is required in order to distinguish single random occurrences from 
deliberately generated objects. For example, a system which produces long random strings will 
generate many that have high PA, but not in abundance. Finding the same long string more 
than once will tell us that there is a bias in the system towards creating that string, thus 
searching for signatures of life should involve looking for objects with high PA found in 
relatively high abundance.  
 
Formalism 
In this manuscript, we explore the foundations of Pathway Assembly, as well as some of its 
properties and variants. We also describe how Pathway Assembly can be incorporated into a 
new information measure, Pathway Information, and how this can help identify objects, above 
a threshold, that must have been produced by living systems. Finally, we offer some examples 
of the use of pathway assembly in systems of varying dimensionality, and describe some 
potential real-world applications of this approach. The Pathway Assembly process is formally 
defined in the context of an Assembly Space, which comprises an acyclic quiver Î“ (a quiver 

6 
 
being a directed graph that allows multiple edges between pairs of nodes and has no directed 
cycles), where the vertices in the quiver are objects in the space, along with an edge labelling 
map ğœ™ğœ™ which associates each edge with a vertex in the quiver (see Definition 11 in the SI). The 
quiver is associated with a reachability relationship â‰¤ where for vertices ğ‘ğ‘, ğ‘ğ‘ in Î“, ğ‘ğ‘â‰¤ğ‘ğ‘ if 
there is a path from ğ‘ğ‘ to ğ‘ğ‘, in other words it is possible reach ğ‘ğ‘ starting at ğ‘ğ‘ by following a 
sequence of edges along their respective directions. If for an edge ğ‘’ğ‘’ from object ğ‘¥ğ‘¥ to object ğ‘§ğ‘§, 
ğœ™ğœ™(ğ‘’ğ‘’) = ğ‘¦ğ‘¦, then this can be thought of as ğ‘§ğ‘§ being constructed through the combination of ğ‘¥ğ‘¥ and 
ğ‘¦ğ‘¦. We also require that the symmetric operation exists within the space, i.e. there is an edge ğ‘”ğ‘” 
from ğ‘¦ğ‘¦ to ğ‘§ğ‘§ such that ğœ™ğœ™(ğ‘”ğ‘”) = ğ‘¥ğ‘¥. 
 
We define an assembly subspace Î” on an assembly space Î“ to be an assembly space that 
contains a subset of the objects in Î“, maintaining all the relationships between them (see 
Definition 15 in the SI). An assembly subspace is said to be rooted if it contains a nonempty 
subset of the basic objects. This is an important distinction in the definition of the Assembly 
Index below, as it allows us to define the shortest construction pathway for objects using a 
consistent set of basic objects. We define the basis of an Assembly Space Î“ as the set of minimal 
vertices in the space with regard to â‰¤, and refer to those vertices as basic objects, basic vertices, 
or basic elements (see Definition 12 in the SI). We define an assembly map (see Definition 17 
in the SI) as a map from one assembly space Î“ to another Î” that maintains the relationship 
between objects, but may map multiple objects in Î“ to the same object in Î”. One such map that 
is generally applicable is the mapping of each object to its size, see Figure 3. Assembly maps 
can be useful for finding a lower bound to the assembly index (described below, and Definition 
19 in the SI), by mapping to a system that may be more computationally tractable to work in 
than the original system of interest (see Theorem 3 in the SI). 
 

7 
 
 
Figure 3: An assembly space comprised of objects formed by joining together white and blue 
blocks. Some of the morphisms have been omitted for clarity. The dotted region is an assembly 
subspace, and topological ordering of the objects in the subspace represents a minimal 
assembly pathway for any subspace containing the sequence of four blue boxes. 
 
We define the cardinality and augmented cardinality as the number of objects in the assembly 
space, where the augmented cardinality excludes the basic objects (defined separately, as this 
measure is used in the assembly index). We then define an assembly pathway and the assembly 
index. An assembly pathway is a set of all the objects in an assembly space Î“ in some order 
that respects the reachability relationship â‰¤, i.e. a topological order. If we take all the rooted 
assembly subspaces of Î“ that contain some object ğ‘¥ğ‘¥, we then define the assembly index as the 
augmented cardinality of the smallest rooted assembly subspace that contains ğ‘¥ğ‘¥. The subspace 
must be rooted, as otherwise a subspace containing only ğ‘¥ğ‘¥ would meet this criterion. We use 
the augmented cardinality of this subspace, as defined above, as defining the assembly index 
without including basic objects in accord with the physical interpretations that motivated this 
measure; however, the cardinality could instead be used if desired, and the difference in the 
measures for any structures with shared basic objects would be require a constant. The 
assembly index then represents the minimum number of joining operations required to 

8 
 
construct object ğ‘¥ğ‘¥, as illustrated in Figure 2. For a formal definition, see Definition 19 in the 
SI. 
 
When mapping from assembly space Î“ to assembly space Î” through an assembly map f, the 
assembly index of a mapped object in Î” acts as a lower bound for the assembly index of the 
original object in Î“. This can allow us, for example, to map an assembly space to another in 
which finding the assembly index is less computationally intensive in order to calculate a useful 
lower bound, see Theorem 3 in the SI. The assembly index of an object in any rooted assembly 
subspace of Î“ is an upper bound for the assembly index of the object in Î“, see Lemma 6 in the 
SI.  A split-branched space is an assembly space Î“ where for each pair of objects ğ‘¥ğ‘¥, ğ‘¦ğ‘¦ in Î“, ğ‘¥ğ‘¥â‰¤
ğ‘¦ğ‘¦ or ğ‘¦ğ‘¦â‰¤ğ‘¥ğ‘¥ whenever ğ‘‰ğ‘‰(ğ‘¥ğ‘¥â†“) âˆ©ğ‘‰ğ‘‰(ğ‘¦ğ‘¦â†“) â‰ âˆ… (see Definition 14 in the SI). This means that, other 
than basic objects, when combining two different objects neither of them can have an assembly 
pathway that uses objects created in the construction of the other. They may use objects that 
are considered identical (e.g. the same string) but these are separate objects within the space. 
Since we can define an assembly map that maps these identical objects to a new space where 
they map to the same object, the split-branched assembly index for a system is an upper bound 
for the assembly index on that system. 
 
We use the space of integers under addition to explore these assembly maps, where an addition 
chain for an integer is a sequence of integers, starting with 1, with each integer in the sequence 
being the sum of two previous integers, see Figure 4. A minimal addition chain for an integer 
is the shortest addition chain that terminates in that integer, and the size of that addition chain 
is equivalent to the pathway assembly index of the integer (after subtracting 1 to account for 
the single basic object). The objects in this space can be considered as abstract integers, or as 
representing the size of objects in some other assembly space. See the â€œExample Applicationsâ€ 
section below for more information on addition chains. We model the assembly process as a 
weighted decision tree where at each level there is a choice of objects that can be formed. The 
number of choices at each level of the tree is constrained by the number of integers that have 
the assembly index associated with that level. To obtain the assembly indices, we used data for 
all minimal addition chain lengths for integers up to 100,000, as published in the Online 
Encyclopaedia of Integer Sequences (21). 
 

9 
 
 
 
Figure 4: An assembly map that maps an assembly space of white and blue blocks onto 
integers representing the object size.  
 
In the initial case of zero bias, the probability of each step was drawn from a uniform random 
distribution. In subsequent steps, a value ğ‘¥ğ‘¥ was drawn from a uniform random distribution 
between 0 and a value â„, and the probability of the step was assigned a value 10ğ‘¥ğ‘¥, subsequently 
normalised so that all probabilities sum to 1. As â„ increases, so does the bias of the distribution, 
with each increase of ğ‘¥ğ‘¥ by 1 representing a 10-fold increase in likelihood of that choice. We 
then calculated the probability of the most likely pathway to assess the impact of the bias. In 
the case of zero bias, at assembly index 25, the integer generated along the most probable 
pathway will be found has approximately 10âˆ’7 probability of being formed. Increasing the bias 
to the maximum level â„= 5, the integer generated along the most probable pathway at 
assembly index 25 will appear approximately 12% of the time, see Figure 5.  

10 
 
 
 
Figure 5: Left â€“ Minimal addition chains modelled as a decision tree. Right â€“ probability of 
the most likely pathway at different levels of bias. 
 
These probabilities will reduce further when considering greater number of choices, such as in 
situations of higher dimensionality, like strings, grid structures, and graphs (see â€œExample 
Applicationsâ€ section below). In the maximum bias case explored here, where â„= 5, the 
choices with ğ‘¥ğ‘¥= 5 will be 10,000 times more likely than those with ğ‘¥ğ‘¥= 1.  This argument 
demonstrates that using a pathway assembly model will result in a threshold above which it is 
unlikely that any specific object would be found, with the threshold depending on the system 
of objects and joining operations, and the physical limits of the inherent biases present in the 
process. Even in a significantly biased system, such a threshold will exist, and any objects 
found in abundance with PA above the threshold will require some process inducing specificity 
outside of the random (bias) model to form. We consider these additional processes to be 
biological. Exploration of the processes and biases of a specific system can then be used, along 
with experimental data, to determine this threshold.  
 
In addition to using the assembly index to determine this biological threshold, it is useful to 
consider an information measure based on the number of possible structures that can be created 
using assembly pathways, see Figure 6. One way to do this is to consider a bounded set of 
possible structures ğ‘ğ‘, and then the subset of possible structures with a specified pathway 
assembly index, ğ‘ğ‘ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ. The "pathway information" is the amount of uncertainty the pathway 
assembly index reduces beyond what knowledge of only the size or general composition can 
provide. In this case, using the approach of Shannon Information (14), the information provided 
by the Pathway Assembly index, ğ¼ğ¼ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ, is given by: 

11 
 
ğ¼ğ¼ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘™ğ‘™ğ‘™ğ‘™ğ‘™ğ‘™ |ğ‘ğ‘|
|ğ‘ğ‘ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ|  
 
 
Figure 6: Pathway Information. The precise definitions of ğ‘ğ‘ and ğ‘ğ‘ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ will depend on the 
specific implementation. 
 
It should be noted that this information measure provides a way of formalizing information 
over states (size, composition) and over paths (PA) within a common mathematical framework. 
To calculate IPA, there are several possible choices for ğ‘ğ‘, all of which must be finite. In one 
option, for an end product with ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘¥ğ‘¥, N is the set of objects possible that can be created from 
the same irreducible parts within ğ‘¥ğ‘¥ steps regardless of PA, and NPA is the subset of those objects 
with the precise pathway assembly index ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘¥ğ‘¥. This then gives us a measure of the 
information provided by learning the assembly index, within the context of all objects that 
could be created by traversing that distance in the assembly space. The difference in utility 
between the Pathway Assembly index and the pathway information, is that the Assembly Index 
provides a simple threshold based on pathway length, whereas pathway information can 

12 
 
provide an intuition on what the assembly index tells us about the space of possible objects and 
how much additional information is provided by knowing the paths. The information increases 
rapidly with Assembly Index, as the space of objects accessible within a given number of steps 
grows rapidly with the number of steps, see Figure 7.  Pseudo code describing the algorithm to 
calculate the pathway assembly of a given object is described in the SI.  
 
 
Figure 7: Pathway Information vs Pathway Assembly index for strings consisting of 6 x letter 
â€œAâ€ and 6 x letter â€œBâ€. If we have a string with Assembly Index of 9, i.e. it can be constructed 
in 9 steps, the pathway information is much higher than with Assembly Index 8, as the number 
of objects that can be constructed in ğ‘¥ğ‘¥ steps grows much more rapidly than the number of 
objects with ğ‘ƒğ‘ƒğ‘ƒğ‘ƒ= ğ‘¥ğ‘¥. 
 
Example Applications 
In the following sections we describe how the pathway assembly approach can be applied to 
systems of varying dimensionality, see Figure 8. 
 
An addition chain is defined (22) as â€œa finite sequence of positive integers  
1 = ğ‘ğ‘0  â‰¤ ğ‘ğ‘1 â€¦ â‰¤ ğ‘ğ‘ğ‘Ÿğ‘Ÿ =  ğ‘›ğ‘› with the property that for all ğ‘–ğ‘– >  0 there exists ğ‘—ğ‘—, ğ‘˜ğ‘˜ with  
ğ‘ğ‘ğ‘–ğ‘– = ğ‘ğ‘ğ‘—ğ‘— + ğ‘ğ‘ğ‘˜ğ‘˜ ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ ğ‘Ÿğ‘Ÿ â‰¥ ğ‘–ğ‘– >  ğ‘—ğ‘— â‰¥ ğ‘˜ğ‘˜ â‰¥ 0. An optimal addition chain is one with the shortest 
possible length. An example of an optimum addition chain is for ğ‘›ğ‘›= 123 is 
 
{1, 2, 3, 5, 10, 15, 30, 60, 63, 123} 

13 
 
 
An assembly space (Î“, ğ›·ğ›·) for addition chains can be defined where ğ‘‰ğ‘‰(Î“) = â„•\{0} =
{1, 2, 3, â€¦ }, the set of positive integers, and for an edge ğ‘’ğ‘’~[ğ‘§ğ‘§ğ‘§ğ‘§], ğœ™ğœ™(ğ‘’ğ‘’) = ğ‘¦ğ‘¦ if and only if ğ‘¥ğ‘¥+
ğ‘¦ğ‘¦= ğ‘§ğ‘§. In this space, an assembly pathway on a subspace representing the assembly index of 
an integer will be equivalent to an optimum addition chain (subtracting 1 to account for the 
single basic object). Addition chains can provide a useful lower bound for the assembly index 
in other assembly spaces, as we can define an assembly map in an assembly space that maps 
each object to an integer representing the number of basic objects within it (see Figure 3).  
Addition chains can be generalised to vectorial addition chains (23), in which we define a 
vectorial addition chain for an k-dimensional vector of natural numbers ğ‘›ğ‘›âˆˆâ„•ğ‘˜ğ‘˜/{0} (excluding 
the 0 vector) as a sequence of ğ‘ğ‘ğ‘–ğ‘–âˆˆâ„•ğ‘˜ğ‘˜/{0} such that for âˆ’ğ‘˜ğ‘˜+ 1 â‰¤ğ‘–ğ‘–â‰¤0, ğ‘ğ‘ğ‘–ğ‘– are the standard 
basis of unit vectors {(1, 0, . . . , 0), (0, 1, . . . , 0), . . . , (0, 0, . . . , 1)}, and for each ğ‘–ğ‘–> 0 there exists 
ğ‘—ğ‘—, ğ‘˜ğ‘˜ with ğ‘ğ‘ğ‘–ğ‘–= ğ‘ğ‘ğ‘—ğ‘—+ ğ‘ğ‘ğ‘˜ğ‘˜ and ğ‘–ğ‘–> ğ‘—ğ‘—â‰¥ğ‘˜ğ‘˜. An example of a vectorial addition chain for [8,8,10] is 
 
[[1,0,0], [0,1,0], [0,0,1], [1,1,0], [1,1,1], [2,2,2], [4,4,4], [8,8,8], [8,8,9], [8,8,10]] 
 
 
 
Figure 8: Example assembly pathways for systems of varying dimensionality 
 
 

14 
 
We can also define an assembly map from other assembly spaces to vectorial addition chains, 
where each element in a vector represents the count of a type of basic object (e.g. [1, 2, 3] for 
1 red block, 2 blue blocks, 3 green blocks), so this can provide another lower bound. In this 
case, there also exists a trivial assembly map from vectorial addition chains to addition chains, 
by summing the vector, so the assembly index on addition chains is a lower bound for the 
assembly index on vectorial addition chains.  In one-dimensional strings we can define an 
assembly space (Î“, ğœ™ğœ™) of strings, where each ğ‘ ğ‘ âˆˆğ‘‰ğ‘‰(Î“) is a string and if a string ğ‘§ğ‘§ can be 
produced by concatenating strings ğ‘¥ğ‘¥ and ğ‘¦ğ‘¦, then there exists an edge ğ‘’ğ‘’~[ğ‘§ğ‘§ğ‘§ğ‘§] with  ğœ™ğœ™(ğ‘’ğ‘’) = ğ‘¦ğ‘¦, 
if ğ‘§ğ‘§ can be produced by concatenating ğ‘¥ğ‘¥ and ğ‘¦ğ‘¦. There are multiple systems that have string 
representations, including text strings, binary signals and polymers.  
 
 
 
Figure 9: Examples of text assembly pathways for 16-character strings. The first example 
demonstrates the shortest possible assembly index of any such string. The second example has 
a nontrivial assembly pathway, while the third example is a string without any shorter pathway 
than adding one character at a time. This model assumes that text fragments cannot be reversed 
when concatenating. 
 
Two other methods for analysing the complexity / information content of strings are the 
Shannon Information (14) and the Kolmogorov Complexity (15). The Shannon information 
content of a string is based on the probability of occurrence of its characters.  For example, for 
a string â€œABBCCCDDDDâ€, the Shannon entropy (using base 2) is given by 
 
ğ»ğ»= âˆ’
à·
ğ‘ğ‘ğ‘–ğ‘–ğ‘ğ‘ğ‘–ğ‘–
ğ‘–ğ‘–âˆˆ{ğ´ğ´,ğµğµ,ğ¶ğ¶,ğ·ğ·}
 = âˆ’(0.10.1 + 0.20.2 + 0.30.3 + 0.40.4 ) â‰ƒ1.84 
 

15 
 
In the case of strings, the probabilities ğ‘ğ‘ğ‘–ğ‘– for each character ğ‘–ğ‘– represent the likelihood of finding 
it in the string, i.e. the inverse of the count of that character within the string. The Shannon 
information content is defined as the reduction in entropy (uncertainty) on being presented with 
some information, and in the case where we are presented with the string itself (reducing 
entropy to zero) the entropy and information are numerically equal. Unlike Pathway Assembly, 
Shannon information in this implementation does not consider the structure of the string, e.g. 
the information content will be the same for â€œABBCCCDDDDâ€ as for â€œABCDBCDCDDâ€. 
The Kolmogorov Complexity (15) of an object is the length of the shortest program that outputs 
that object, in a given Turing-complete language. Although Kolmogorov Complexity is 
dependent on the language used, it can be shown that the Kolmogorov complexity ğ¶ğ¶ in any 
language ğœ™ğœ™ can be related to the Kolmogorov complexity in a universal language ğ‘ˆğ‘ˆ by  
ğ¶ğ¶ğ‘ˆğ‘ˆ(ğ‘¥ğ‘¥) â‰¤ğ¶ğ¶ğ¶ğ¶(ğ‘¥ğ‘¥) + ğ‘ğ‘ for some constant ğ‘ğ‘ (24). If a string cannot be expressed in a universal 
language by a program shorter than its length, it is considered random. It has been shown that 
the Kolmogorov complexity is not computable, whereas the Pathway Assembly index is 
computable (see Theorem 4 in the SI). 
 
We can extend Pathway Assembly to two dimensions by considering a grid of pixels, or 
coloured boxes, for example a digital image. For simplicity we will consider images with black 
and white basic objects, although this could be simply extended to greyscale images or colour 
images (e.g. greyscale images could have 256 basic objects representing different pixel 
intensities, as in an 8-bit greyscale image). We can define an assembly space with assemblages 
of black and white pixels as objects. In this space, two assemblages ğ‘ğ‘ and ğ‘¥ğ‘¥ are connected by 
an edge ğ‘’ğ‘’ ~ [ğ‘¥ğ‘¥ğ‘¥ğ‘¥] if ğ‘ğ‘ is a substructure of ğ‘¥ğ‘¥. The edge ğ‘’ğ‘’ is labelled as ğœ™ğœ™(ğ‘’ğ‘’) = ğ‘ğ‘ with ğ‘ğ‘ the 
complement of ğ‘ğ‘ in ğ‘¥ğ‘¥. In other words, you can connect ğ‘ğ‘ and ğ‘ğ‘ together to get ğ‘¥ğ‘¥. A choice can 
be made about whether to enforce the preservation of orientation, or whether to consider 
substructures rotated by 90 degrees to be equivalent, and the latter choice can be related to the 
former by way of an assembly map. An illustration of an assembly pathway in this space can 
be seen in Figure 10.  

16 
 
 
 
Figure 10: Illustrative assembly pathway of a two-dimensional image. This does not 
necessarily represent the minimal assembly pathway for this shape. Here, images that are 
rotated are considered equivalent. 
 
The assembly index of an image can be bounded by an assembly map to the one-dimensional 
case, for example by mapping to a numeric list containing a count of the number of black pixels 
in each column. It can also be mapped to the space of addition chains as normal and to a reduced 
representation of the image such as those generated by pooling operations used in convolutional 
neural networks, or quantisation matrices used in jpeg compression. To extend pathway 
assembly to three dimensions we can consider structures created out of cubic building blocks 
as a natural extension of the two-dimensional model. Pathway assembly does not need to be 
applied to objects as a whole, but can be applied to shared motifs or networks found within the 
objects (13), which can in some cases map to the problem of cubic building blocks. Pathway 
assembly, as described here, currently has no simple extension to continuous objects, however 
we can use an  assembly map to define a function that consistently maps similar features to 
larger block structures, and can calculate the assembly index of that structural motif to explore 
whether it is over the biological threshold, if found in some abundance. As in the two-
dimensional case, the assembly index of cubic structures can be bounded by an assembly map 
to the two-dimensional case, the one-dimensional case, or to the case of addition chains. 
 
An undirected graph ğºğº(ğ‘‰ğ‘‰, ğ¸ğ¸) is defined by a set of vertices ğ‘‰ğ‘‰ and a set of edges ğ¸ğ¸âŠ†ğ‘‰ğ‘‰Ã— ğ‘‰ğ‘‰.  
An assembly space for connected graphs (directed or undirected) can be defined where Î“ is the 
space of all connected graphs, with the basis set ğµğµ consisting of a single node. The reachability 
relationship â‰¤ is defined on Î“ such that ğœ™ğœ™([ğºğºğ‘¥ğ‘¥, ğºğºğ‘ğ‘]) = ğºğºğ‘ğ‘ if ğ‘‰ğ‘‰ğ‘¥ğ‘¥= ğ‘‰ğ‘‰ğ‘ğ‘âˆªğ‘‰ğ‘‰ğ‘ğ‘ and ğ¸ğ¸ğ‘¥ğ‘¥= ğ¸ğ¸ğ‘ğ‘âˆªğ¸ğ¸ğ‘ğ‘âˆª
ğ¸ğ¸ğ‘ğ‘ğ‘ğ‘ where ğ¸ğ¸ğ‘ğ‘ğ‘ğ‘âŠ†ğ‘‰ğ‘‰ğ‘ğ‘Ã— ğ‘‰ğ‘‰ğ‘ğ‘ and ğ¸ğ¸ğ‘ğ‘ğ‘ğ‘â‰ âˆ… . In other words, ğºğºğ‘¥ğ‘¥ contains all vertices and edges of 

17 
 
ğºğºğ‘ğ‘ and ğºğºğ‘ğ‘, and also at least one edge between them. Similar spaces can be defined for graphs 
that are not necessarily connected by removing the requirement that ğ¸ğ¸ğ‘ğ‘ğ‘ğ‘â‰ âˆ…. Vertex colours 
can be incorporated by expanding the basis set ğµğµ. A graph assembly space can also be defined 
with edges as the basic objects, instead of vertices. Additional constraints allow for the study 
of spaces of other useful graph structures, for example restriction of vertex degree allows for 
the study of the space of molecular graphs, which are studied in an upcoming paper. As in the 
block structures, the assembly space of graphs can be used to analyse objects that have identical 
network motifs in them while not being identical in other ways. Assembly maps can be defined 
from the space of graphs to the space of addition chains, as a count of the number of vertices, 
and also to vectorial addition chains if the vertices are coloured. 
 
There are various other examples where the pathway assembly approach could be used to 
provide useful analysis of objects. One example is in audio / electromagnetic signals, or music. 
By utilising notes and silences as basic objects, possibly incorporating frequency/pitch, we 
could use pathway assembly to distinguish natural signals such as those from a pulsar, or the 
sound of wind moving through a complex landscape, from sounds such as birdsong or 
structured communications. In such a system, abundance could be considered to be the same 
signal from multiple locations, or from the same location but repeated. We can also consider 
the morphology of apparent geological formations to look for evidence of biological influence 
in the form of duplicated complex patterns. 
 
Pathway assembly can also be used to define a compression algorithm, similar to the widely 
known Lempel-Ziv-Welch (LZW) algorithm (25). In the LZW algorithm, repeated portions of 
text are represented by additional symbols in an expanded character set, and the need for a 
separate dictionary is removed by building the dictionary in such a way that it can be 
reconstructed during decompression. In a pathway assembly-based implementation, we could 
initially calculate an assembly pathway for the string, and then use the additional character set 
to indicate points at which substrings are duplicated or stored for re-use. It is unlikely that such 
a compression algorithm would be commercially useful due to the computational complexity 
of finding a minimal assembly pathway, but analysing compressibility in this way could 
provide further insights around the information content of string-like objects from an assembly 
space perspective.  
 

18 
 
Conclusions 
The pathway assembly model, and pathway information, can be used to explore the possible 
ways an object could have formed from its building blocks through random interactions, and 
we have now built on our initial work (26) by establishing a robust mathematical formalism. 
By doing so, we can define a threshold above which extrinsic information from a biological 
source would have been required to create an observable abundance of an object because it is 
too improbable to have formed in abundance otherwise. The pathway assembly of an object, 
when above the threshold, can be used as an agnostic biosignature, giving a clear indication of 
the influence of information in constructing objects (e.g. via biological processes) without 
knowledge of the system that produced the end product. In other words, it can be used to detect 
biological influence even when we donâ€™t know what we are looking for.  Of interest is the 
ability to search for new types of life forms in the lab, alien life on other worlds, as well as 
identifying the conditions under which the random world embarks on the path towards life, as 
characterised by the emergence of physical systems that produce objects with high pathway 
assembly. As such, pathway assembly information might be enable us to not only look for the 
abiotic to living transition, identifying the emergence of life, but also to identify 
technosignatures associated with intelligent life with even higher pathway assemblies within a 
unified quantitative framework. We therefore feel that the concept of pathway assembly can 
be used to help us explore the universe for structures that must have been produced using an 
information-driven construction process; in fact we could go as far as to suggest that any such 
process requiring information is a biological or technological process.  This also means that 
pathway assembly information provides a new window on the problem of understanding the 
physics of life simply because the physics of information is the physics of life. We believe that 
such an approach might help us reframe the question from philosophy of what life is (27), to a 
physics of what life does. 
 
Acknowledgements 
The authors gratefully acknowledge financial support from the EPSRC (Grant Nos 
EP/R01308X/1, EP/L023652/1, EP/P00153X/1), the ERC (project 670467 SMART-POM), the 
John Templeton Foundation Grant ID 60625 and Grant ID 61184 and the National Aeronautics 
and Space Administration through grant NNX15AL24G S02. We thank Dr. Cole Mathis and 
Prof. Paul Davies for useful discussions. 
 
 

19 
 
Author Contributions 
L.C. conceived of the overall concept and developed the algorithm together with S.M.M. 
A.R.G.M explored the initial mathematical description, and this was expanded and validated 
by D.G.M and S.I.W. L.C. and S. M. M. wrote the manuscript with input from all the authors. 
 
References 
1. 
C. R. S. Banerji, T. Mansour, and S. Severini, A Notion of Graph Likelihood and an 
Infinite Monkey Theorem. J. Phys. A 47, 035101 (2014). 
2. 
C. Adami and T. Labar, â€œFrom Entropy to Information: Biased Typewriters and the 
Origin of Lifeâ€ in From Matter to Life: Information and Causality, G. F. R. Ellis, P. C. 
W. Davies, S. I. Walker, Eds. (Cambridge University Press, Cambridge, 2017), pp. 130-
154. 
3. 
F. Hoyle as Quoted in Hoyle on Evolution. Nature 294, 105 (1981). 
4. 
D. Deutsch, Constructor Theory. Synthese 190, 4331-4359 (2013). 
5. 
C. Marletto, Constructor Theory of Life. J. R. Soc. Interface 12, 20141226 (2015). 
6. 
J. V. Neumann, Theory of Self-Reproducing Automata (University of Illinois Press, 
Champaign IL, 1966). 
7. 
A. Danchin, Bacteria as Computers Making Computers. FEMS Microbiol. Rev. 33, 3-
26 (2009). 
8. 
D. H. Wolpert and W. Macready, Using Self-Dissimilarity to Quantify Complexity. 
Complexity 12, 77-85 (2007). 
9. 
D. Krakauer, Cryptographic Nature. arXiv:1505.01744 (7 May 2015). 
10. 
J. P. Crutchfield and O. GÃ¶rnerup, Objects That Make Objects: The Population 
Dynamics of Structural Complexity. J. R. Soc. Interface 3, 345-349 (2006). 
11. 
S. Kauffman and P. Clayton, On Emergence, Agency, and Organization. Biology & 
Philosophy 21, 501-521 (2006). 
12. 
S. I. Walker and P. C. W. Davies, The Algorithmic Origins of Life. J. R. Soc. Interface 
10, 20120869 (2013). 
13. 
S. M. Marshall, A. R. G. Murray, and L. Cronin, A Probabilistic Framework for 
Identifying Biosignatures Using Pathway Complexity. Phil. Trans. R. Soc. A 375, 
20160342 (2017). 
14. 
C. E. Shannon, A Mathematical Theory of Communication. Bell Syst. Tech. J. 27, 379-
423 (1948). 

20 
 
15. 
A. N. Kolmogorov, Three Approaches to the Quantitative Definition of Information. 
Int. J. Comput. Math. 2, 157-168 (1968). 
16. 
D. H. Lee, J. R. Granja, J. A. Martinez, K. Severin, and M. R. Ghadiri, A Self-
Replicating Peptide. Nature 382, 525-528 (1996). 
17. 
S. PressÃ©, K. Ghosh, J. Lee, K. A. Dill, Principles of Maximum Entropy and Maximum 
Caliber in Statistical Physics. Rev. Mod. Phys., 85, 1115-1141 (2013).  
18. 
H. Kim, H. B. Smith, C. Mathis, J. Raymond, and S. I. Walker, Universal Scaling across 
Biochemical Networks on Earth. Science Advances 5, eaau0149 (2019). 
19. 
C. Grimaldi and G. W. Marcy, Bayesian Approach to Seti. Proc. Natl. Acad. Sci. USA, 
201808578 (2018). 
20. 
S. Steiner, J. Wolf, S. Glatzel, A. Andreou, J. M. Granda, G. Keenan, T. Hinkley, G. 
Aragon-Camarasa, P. J. Kitson, D. Angelone, and L. Cronin, Organic Synthesis in a 
Modular Robotic System Driven by a Chemical Programming Language. Science 363, 
144-152 (2019). 
21. 
D. Wilson and A. Mathys, Sequence A003313, the On-Line Encyclopedia of Integer 
Sequences. https://oeis.org/A003313 accessed June 2019. 
22. 
N. M. Clift, Calculating Optimal Addition Chains. Computing 91, 265-284 (2011). 
23. 
G. J. Chaitin, Information-Theoretic Computational Complexity. IEEE T. Inf. Theory, 
20, 10-15 (1974)  
24. 
J. Olivos, On Vectorial Addition Chains. J. Algorithms 2, 13-21 (1981). 
25. 
T. A. Welch, A Technique for High-Performance Data Compression. Computer 17, 8-
19 (1984). 
26. 
A. R. G. Murray, S. M. Marshall, and L. Cronin, Defining Pathway Assembly and 
Exploring Its Applications. arXiv:1804.06972 (9 April 2018). 
27. 
E. SchrÃ¶dinger, What is Life? The Physical Aspect of the Living Cell (Cambridge 
University Press, Cambridge, 1944). 
 

Supplementary Information: Quantifying the pathways to life 
using assembly spaces 
Stuart M. Marshall,1 Douglas G. Moore,2 Alastair R. G. Murray,1 Sara I. Walker,2,3* and 
Leroy Cronin1* 
1 School of Chemistry, University of Glasgow, Glasgow, G12 8QQ, UK.  
2 BEYOND Center for Fundamental Concepts in Science, Arizona State University, Tempe, 
AZ, USA 
3 School of Earth and Space Exploration, Arizona State University, Tempe, AZ, USA 
*Corresponding author email: Lee.Cronin@glasgow.ac.uk, sara.i.walker@asu.edu  
1. Introduction 
This formalism arose as a means of rigorously describing the â€œsimplestâ€ way of assembling a 
given object by combining basing building blocks. With this in mind, we consider a universe 
of objects and binary relations between them signifying that one can be compose with some 
third object to create the second. Each relation then is associated with that third object. In this 
setting, the concrete rules or laws describing this assembly processes are neglected though 
they are certainly necessary for initially constructing the space. We quickly come to the 
conclusion that a graph formalization is appropriate when we consider this kind of process in 
general, but a more general mathematical structure than the standard concept of a graph is 
necessarily; namely quivers1. As such, the fundamental mathematical structure we define and 
explore herein, referred to as an assembly space, can be described as an acyclic quiver with 
edges labeled with vertices in the quiver which satisfies three simple axioms. With assembly 
spaces defined, we are able to define an assembly index for each object in the space which 
characterizes how directly that object can be assembled. Further, we prove several axioms 
relating to method of bounding the assembly index for a given object and algorithms for 
computing or approximating it. 
To facilitate this exposition, we have broken the text into three sections. First, in Section 2. 
we describe the graph-theoretic prerequisites associated with quivers and morphisms 
(mappings) between them. We proceed then to define assembly spaces, subspaces and maps 
between them, and to prove several lemmas in Section 3. Finally, we define the assembly 
index, prove that it is computable and two methods for bounding it above and below, and 
present algorithms for computing or approximating it in Section 4. 
2. Graph-Theoretic Prerequisites 
We begin by considering a set of objects, possibly infinitely many objects, which can be 
combined in various ways to produce others. If an object ğ‘ğ‘ can be combined with some other 
 
1 Many texts refer to this structure as a multigraph, with the term quiver preferred in 
settings where the edges represent morphism or processes rather than simply relationships. 
Since we view the â€œrelationsâ€ as an active process of combination, we prefer quiver in this 
text. The reader would lose nothing by mentally substituting the terms. 

object to yield an object ğ‘ğ‘, we represent the relationship between ğ‘ğ‘ and ğ‘ğ‘ by drawing a 
directed edge or arrow from ğ‘ğ‘ to ğ‘ğ‘. Altogether, this structure is a quiver, also called a 
multigraph, as we allow for the possibility that there is more than one way to produce ğ‘ğ‘ from 
ğ‘ğ‘; that is, there may be more than one edge from ğ‘ğ‘ to ğ‘ğ‘. 
Definition 1. A quiver ğ›¤ğ›¤ consists of 
1. a set of vertices ğ‘‰ğ‘‰(ğ›¤ğ›¤) 
2. a set of edges ğ¸ğ¸(ğ›¤ğ›¤) 
3. a pair of maps ğ‘ ğ‘ ğ›¤ğ›¤, ğ‘¡ğ‘¡ğ›¤ğ›¤: ğ¸ğ¸(ğ›¤ğ›¤) â†’ğ‘‰ğ‘‰(ğ›¤ğ›¤) 
For an edge ğ‘’ğ‘’âˆˆğ¸ğ¸(ğ›¤ğ›¤), ğ‘ ğ‘ ğ›¤ğ›¤(ğ‘’ğ‘’) is referred to as the source and ğ‘¡ğ‘¡ğ›¤ğ›¤(ğ‘’ğ‘’) the target of the edge, and 
we will often leave off the subscripts when the context is clear, e.g. ğ‘ ğ‘  and ğ‘¡ğ‘¡. We will often 
describe an edge ğ‘’ğ‘’âˆˆğ¸ğ¸(ğ›¤ğ›¤) with ğ‘ ğ‘ (ğ‘’ğ‘’) = ğ‘ğ‘ and ğ‘¡ğ‘¡(ğ‘’ğ‘’) = ğ‘ğ‘ as ğ‘’ğ‘’âˆ¼[ğ‘ğ‘ğ‘ğ‘]. This does not mean that 
ğ‘’ğ‘’ is a unique edge with endpoints ğ‘ğ‘ and ğ‘ğ‘; it is possible that two edges ğ‘’ğ‘’â‰ ğ‘“ğ‘“ have the same 
endpoints ğ‘’ğ‘’âˆ¼ğ‘“ğ‘“âˆ¼[ğ‘ğ‘ğ‘ğ‘]. 
 
From here, we consider paths, that is sequences of edges, which describe the process of 
sequentially combining objects to yield intermediate objects and ultimately some terminal 
object. 
Definition 2. If ğ›¤ğ›¤ is a quiver, a path ğ›¾ğ›¾= ğ‘ğ‘ğ‘›ğ‘›â€¦ ğ‘ğ‘1 in ğ›¤ğ›¤ of length ğ‘›ğ‘›â‰¥1 is a sequence of edges 
such that ğ‘¡ğ‘¡(ğ‘ğ‘ğ‘–ğ‘–) = ğ‘ ğ‘ (ğ‘ğ‘ğ‘–ğ‘–+1) for 1 â‰¤ğ‘–ğ‘–â‰¤ğ‘›ğ‘›âˆ’1. The functions ğ‘ ğ‘  and ğ‘¡ğ‘¡ can be extended to paths 
as ğ‘ ğ‘ (ğ›¾ğ›¾) = ğ‘ ğ‘ (ğ‘ğ‘1) and ğ‘¡ğ‘¡(ğ›¾ğ›¾) = ğ‘¡ğ‘¡(ğ‘ğ‘ğ‘›ğ‘›). We write |ğ›¾ğ›¾| to denote the length, or number of edges, in 
the path. Additionally, for each vertex ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤ there is a zero path, denoted ğ‘’ğ‘’ğ‘¥ğ‘¥, with length 0 
and ğ‘ ğ‘ (ğ‘’ğ‘’ğ‘¥ğ‘¥) = ğ‘¡ğ‘¡(ğ‘’ğ‘’ğ‘¥ğ‘¥) = ğ‘¥ğ‘¥. 
 
A natural point is that combining two objects should never yield something that can be used 
to create either of those objects. Essentially, there are no directed cycles â€“ sequences of edges 
that form a closed cycle â€“ within the quiver. 
Definition 3. A path ğ›¾ğ›¾ in a quiver ğ›¤ğ›¤ is a directed cycle if |ğ›¾ğ›¾| â‰¥1 with ğ‘¡ğ‘¡(ğ›¾ğ›¾) = ğ‘ ğ‘ (ğ›¾ğ›¾). 
Definition 4. A quiver ğ›¤ğ›¤ is acyclic if it has no directed cycles. 
 
We can think of an object ğ‘ğ‘ as being reachable from an object ğ‘ğ‘ if thereâ€™s a path from ğ‘ğ‘ to ğ‘ğ‘, 
and this relationship forms a partial ordering on the quiver if the quiver is acyclic. 
Definition 5. Let ğ›¤ğ›¤ be an acyclic quiver and let ğ‘¥ğ‘¥, ğ‘¦ğ‘¦âˆˆğ‘‰ğ‘‰(ğ›¤ğ›¤). We say ğ‘¦ğ‘¦ is reachable from ğ‘¥ğ‘¥ if 
there exists a path ğ›¾ğ›¾ such that ğ‘ ğ‘ (ğ›¾ğ›¾) = ğ‘¥ğ‘¥ and ğ‘¡ğ‘¡(ğ›¾ğ›¾) = ğ‘¦ğ‘¦, where |ğ›¾ğ›¾| â‰¥0. 
Lemma 1. Let ğ›¤ğ›¤ be an acyclic quiver, and define a binary relation â‰¤ on the vertices of ğ›¤ğ›¤ 
such that ğ‘¥ğ‘¥â‰¤ğ‘¦ğ‘¦ if and only if ğ‘¦ğ‘¦ is reachable from ğ‘¥ğ‘¥. (ğ‘‰ğ‘‰(ğ›¤ğ›¤), â‰¤) is a partially ordered set, and 
â‰¤ is referred to as the reachability relation on ğ›¤ğ›¤. 
Proof. For â‰¤ to be a partial ordering on ğ‘‰ğ‘‰(ğ›¤ğ›¤), we need to show that it is reflexive, transitive 
and antisymmetric. Reflexivity follows directly from the definition of reachability as ğ‘¥ğ‘¥ is 

reachable from itself via the zero path ğ‘’ğ‘’ğ‘¥ğ‘¥. To show transitivity, let ğ‘ğ‘â‰¤ğ‘ğ‘ and ğ‘ğ‘â‰¤ğ‘ğ‘. If ğ‘ğ‘= ğ‘ğ‘ 
or ğ‘ğ‘= ğ‘ğ‘, then weâ€™re done. Otherwise there are paths ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘= ğ‘¢ğ‘¢ğ‘šğ‘šâ€¦ ğ‘¢ğ‘¢1 from ğ‘ğ‘ to ğ‘ğ‘ and ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘=
ğ‘£ğ‘£ğ‘›ğ‘›â€¦ ğ‘£ğ‘£1 from ğ‘ğ‘ to ğ‘ğ‘. The composite path ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘âˆ˜ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘= ğ‘£ğ‘£ğ‘›ğ‘›â€¦ ğ‘£ğ‘£1ğ‘¢ğ‘¢ğ‘›ğ‘›â€¦ ğ‘¢ğ‘¢1 is a path from ğ‘ğ‘ to ğ‘ğ‘; 
thus ğ‘ğ‘ is reachable from ğ‘ğ‘ so that ğ‘ğ‘â‰¤ğ‘ğ‘. Now consider antisymmetry and suppose that ğ‘ğ‘â‰¤ğ‘ğ‘ 
and ğ‘ğ‘â‰¤ğ‘ğ‘. Then there exist paths ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘ and ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘ from ğ‘ğ‘ to ğ‘ğ‘ and ğ‘ğ‘ to ğ‘ğ‘, respectively. Then 
ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘âˆ˜ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘ is a path from ğ‘ğ‘ to itself. Since ğ›¤ğ›¤ is acyclic, this implies that ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘âˆ˜ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘= ğ‘’ğ‘’ğ‘ğ‘, and 
consequently that ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘= ğ›¾ğ›¾ğ‘ğ‘ğ‘ğ‘= ğ‘’ğ‘’ğ‘ğ‘. Thus ğ‘ğ‘= ğ‘ğ‘ and â‰¤ is antisymmetric. 
 
âˆ 
 
The idea of reachability allows us to think of all objects that are reachable from (or above) a 
given object ğ‘¥ğ‘¥, the upper quiver of ğ‘¥ğ‘¥. Similarly, we can think of all objects that can reach ğ‘¥ğ‘¥, 
the lower quiver. 
Definition 6. Let ğ›¤ğ›¤ be an acyclic quiver and let â‰¤ be the reachability relation on it. The 
upper quiver of ğ‘¥ğ‘¥âˆˆğ‘‰ğ‘‰(ğ›¤ğ›¤) is ğ‘¥ğ‘¥â†‘ with vertices ğ‘‰ğ‘‰(ğ‘¥ğ‘¥â†‘) = {ğ‘¦ğ‘¦âˆˆğ‘‰ğ‘‰(ğ›¤ğ›¤) | ğ‘¥ğ‘¥â‰¤ğ‘¦ğ‘¦}, edges ğ¸ğ¸(ğ‘¥ğ‘¥â†‘
) = {ğ‘’ğ‘’âˆˆğ¸ğ¸(ğ›¤ğ›¤) | ğ‘ ğ‘ ğ›¤ğ›¤(ğ‘’ğ‘’), ğ‘¡ğ‘¡ğ›¤ğ›¤(ğ‘’ğ‘’) âˆˆğ‘‰ğ‘‰(ğ‘¥ğ‘¥â†‘)}, ğ‘ ğ‘ ğ‘¥ğ‘¥â†‘= ğ‘ ğ‘ ğ›¤ğ›¤|ğ¸ğ¸(ğ‘¥ğ‘¥â†‘), and ğ‘¡ğ‘¡ğ‘¥ğ‘¥â†‘= ğ‘¡ğ‘¡ğ›¤ğ›¤|ğ¸ğ¸(ğ‘¥ğ‘¥â†‘). The lower 
quiver of ğ‘¥ğ‘¥âˆˆğ‘‰ğ‘‰(ğ›¤ğ›¤) is ğ‘¥ğ‘¥â†“ with vertices ğ‘‰ğ‘‰(ğ‘¥ğ‘¥â†“) = {ğ‘¦ğ‘¦âˆˆğ‘‰ğ‘‰(ğ›¤ğ›¤) | ğ‘¦ğ‘¦â‰¤ğ‘¥ğ‘¥}, edges ğ¸ğ¸(ğ‘¥ğ‘¥â†“) =
{ğ‘’ğ‘’âˆˆğ¸ğ¸(ğ›¤ğ›¤) | ğ‘ ğ‘ ğ›¤ğ›¤(ğ‘’ğ‘’), ğ‘¡ğ‘¡ğ›¤ğ›¤(ğ‘’ğ‘’) âˆˆğ‘‰ğ‘‰(ğ‘¥ğ‘¥â†“)}, ğ‘ ğ‘ ğ‘¥ğ‘¥â†“= ğ‘ ğ‘ ğ›¤ğ›¤|ğ¸ğ¸(ğ‘¥ğ‘¥â†“), and ğ‘¡ğ‘¡ğ‘¥ğ‘¥â†“= ğ‘¡ğ‘¡ğ›¤ğ›¤|ğ¸ğ¸(ğ‘¥ğ‘¥â†“). 
Similarly, the upper quiver of a subset ğ‘„ğ‘„âŠ†ğ‘‰ğ‘‰(ğ›¤ğ›¤) in ğ›¤ğ›¤ is ğ‘„ğ‘„â†‘ with vertices ğ‘‰ğ‘‰(ğ‘„ğ‘„â†‘) = {ğ‘¦ğ‘¦âˆˆ
ğ‘‰ğ‘‰(ğ›¤ğ›¤) | (âˆƒğ‘ğ‘âˆˆğ‘„ğ‘„)ğ‘ğ‘â‰¤ğ‘¦ğ‘¦}, edges ğ¸ğ¸(ğ‘„ğ‘„â†‘) = {ğ‘’ğ‘’âˆˆğ¸ğ¸(ğ›¤ğ›¤) | ğ‘ ğ‘ ğ›¤ğ›¤(ğ‘’ğ‘’), ğ‘¡ğ‘¡ğ›¤ğ›¤(ğ‘’ğ‘’) âˆˆğ‘‰ğ‘‰(ğ‘„ğ‘„â†‘)}, ğ‘ ğ‘ ğ‘„ğ‘„â†‘=
ğ‘ ğ‘ ğ›¤ğ›¤|ğ¸ğ¸(ğ‘„ğ‘„â†‘), and ğ‘¡ğ‘¡ğ‘„ğ‘„â†‘= ğ‘¡ğ‘¡ğ›¤ğ›¤|ğ¸ğ¸(ğ‘„ğ‘„â†‘). The lower set of a subset is defined dually. 
 
Going further, we can consider those objects that cannot be reached as minimal and those that 
cannot reach anything as maximal. An object which can be reached by finitely many objects 
is called finite. 
Definition 7. Let ğ›¤ğ›¤ be an acyclic quiver, â‰¤ be the reachability relation on it and ğ‘¥ğ‘¥ a vertex in 
ğ›¤ğ›¤. Then ğ‘¥ğ‘¥ is said to be maximal in ğ›¤ğ›¤ if, whenever ğ‘¥ğ‘¥â‰¤ğ‘¦ğ‘¦ in ğ›¤ğ›¤, we have ğ‘¥ğ‘¥= ğ‘¦ğ‘¦. Dually, ğ‘¥ğ‘¥ is 
minimal in ğ›¤ğ›¤ if, whenever ğ‘¦ğ‘¦â‰¤ğ‘¥ğ‘¥ in ğ›¤ğ›¤, we have ğ‘¥ğ‘¥= ğ‘¦ğ‘¦. The set of all maximal vertices of ğ›¤ğ›¤ is 
denoted max(ğ›¤ğ›¤) with min(ğ›¤ğ›¤) defined dually. 
Definition 8. A quiver ğ›¤ğ›¤ is said to be ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ if its vertex and edge sets are both finite. 
Similarly, a vertex ğ‘¥ğ‘¥ in a quiver ğ›¤ğ›¤ is said to be finite if ğ‘¥ğ‘¥â†“ in ğ›¤ğ›¤ is a finite quiver. 
 
With this idea of a quiver of objects defined, we can consider asking about subsets of objects 
and relations between them in the context of the quiver as a whole. 
Definition 9. Let ğ›¤ğ›¤ and ğ›¤ğ›¤â€² be quivers. Then ğ›¤ğ›¤â€² is a subquiver of ğ›¤ğ›¤ if ğ‘‰ğ‘‰(ğ›¤ğ›¤â€²) âŠ†ğ‘‰ğ‘‰(ğ›¤ğ›¤), ğ¸ğ¸(ğ›¤ğ›¤â€²) âŠ†
ğ¸ğ¸(ğ›¤ğ›¤), ğ‘ ğ‘ ğ›¤ğ›¤â€² = ğ‘ ğ‘ ğ›¤ğ›¤|ğ¸ğ¸(ğ›¤ğ›¤â€²) and ğ‘¡ğ‘¡ğ›¤ğ›¤â€² = ğ‘¡ğ‘¡ğ›¤ğ›¤|ğ¸ğ¸(ğ›¤ğ›¤â€²). We will denote this relationship as ğ›¤ğ›¤â€² âŠ†ğ›¤ğ›¤. 
Lemma 2. If ğ‘‹ğ‘‹, ğ‘Œğ‘Œ and ğ‘ğ‘ are quivers such that ğ‘‹ğ‘‹âŠ†ğ‘Œğ‘Œ and ğ‘Œğ‘ŒâŠ†ğ‘ğ‘, then ğ‘‹ğ‘‹âŠ†ğ‘ğ‘. That is, the 
binary relation âŠ† on quivers is transitive. 
Proof. Suppose ğ‘‹ğ‘‹, ğ‘Œğ‘Œ and ğ‘ğ‘ are quivers with ğ‘‹ğ‘‹âŠ†ğ‘Œğ‘Œ and ğ‘Œğ‘ŒâŠ†ğ‘ğ‘. Then ğ‘‰ğ‘‰(ğ‘‹ğ‘‹) âŠ†ğ‘‰ğ‘‰(ğ‘Œğ‘Œ) âŠ†ğ‘‰ğ‘‰(ğ‘ğ‘), 
so that ğ‘‰ğ‘‰(ğ‘‹ğ‘‹) âŠ†ğ‘‰ğ‘‰(ğ‘ğ‘). Similarly, ğ¸ğ¸(ğ‘‹ğ‘‹) âŠ†ğ¸ğ¸(ğ‘ğ‘). Next, since ğ‘ ğ‘ ğ‘‹ğ‘‹= ğ‘ ğ‘ ğ‘Œğ‘Œ|ğ¸ğ¸(ğ‘‹ğ‘‹), ğ‘ ğ‘ ğ‘Œğ‘Œ= ğ‘ ğ‘ ğ‘ğ‘|ğ¸ğ¸(ğ‘Œğ‘Œ) and 

ğ¸ğ¸(ğ‘‹ğ‘‹) âŠ†ğ¸ğ¸(ğ‘Œğ‘Œ), ğ‘ ğ‘ ğ‘‹ğ‘‹= ğ‘ ğ‘ ğ‘ğ‘|ğ¸ğ¸(ğ‘‹ğ‘‹). The same argument applies to show that ğ‘¡ğ‘¡ğ‘‹ğ‘‹= ğ‘¡ğ‘¡ğ‘ğ‘|ğ¸ğ¸(ğ‘‹ğ‘‹). Thus ğ‘‹ğ‘‹âŠ†
ğ‘ğ‘, so that âŠ† is transitive. 
 
âˆ 
 
Finally, we will need to consider how to map one quiver to another in a consistent fashion, 
maintaining the basic relational structure of the original quiver. 
Definition 10. Let ğ›¤ğ›¤ and ğ›¤ğ›¤â€² be quivers. A quiver morphism, denoted ğ‘šğ‘š: ğ›¤ğ›¤â†’ğ›¤ğ›¤â€², consists of 
a pair ğ‘šğ‘š= (ğ‘šğ‘šğ‘£ğ‘£, ğ‘šğ‘šğ‘’ğ‘’) of functions ğ‘šğ‘šğ‘£ğ‘£: ğ‘‰ğ‘‰(ğ›¤ğ›¤) â†’ğ‘‰ğ‘‰(ğ›¤ğ›¤â€²) and ğ‘šğ‘šğ‘’ğ‘’: ğ¸ğ¸(ğ›¤ğ›¤) â†’ğ¸ğ¸(ğ›¤ğ›¤â€²) such that ğ‘šğ‘šğ‘£ğ‘£âˆ˜
ğ‘ ğ‘ ğ›¤ğ›¤= ğ‘ ğ‘ ğ›¤ğ›¤â€² âˆ˜ğ‘šğ‘šğ‘’ğ‘’ and ğ‘šğ‘šğ‘£ğ‘£âˆ˜ğ‘¡ğ‘¡ğ›¤ğ›¤= ğ‘¡ğ‘¡ğ›¤ğ›¤â€² âˆ˜ğ‘šğ‘šğ‘’ğ‘’. That is, the following diagrams commute: 
 
3. Assembly Spaces, Subspaces and Maps 
Up to this point, we have focused on the binary idea that one object can be used as a 
structural ingredient of another. However, we need something more if we want to capture the 
idea that two things must be combined in order to assemble another. We do this by labeling 
the edges of the quiver with the object that the source of the edge is combined with to 
produce the target. Further, this labeling has to be consistent. If ğ‘ğ‘ can be combined with ğ‘ğ‘ to 
yield ğ‘ğ‘, then ğ‘ğ‘ can be combined with ğ‘ğ‘ to yield ğ‘ğ‘. Additionally, we require that there exists a 
set of minimal objects â€“ building blocks from which all other objects can be assembled. 
Definition 11. An assembly space is an acyclic quiver ğ›¤ğ›¤ together with an edge-labeling map 
ğœ™ğœ™: ğ¸ğ¸(ğ›¤ğ›¤) â†’ğ‘‰ğ‘‰(ğ›¤ğ›¤) which satisfies the following axioms: 
4. 
min(ğ›¤ğ›¤) is finite and non-empty 
5. 
ğ›¤ğ›¤= min(ğ›¤ğ›¤) â†‘ 
6. 
If ğ‘ğ‘ is an edge from ğ‘¥ğ‘¥ to ğ‘§ğ‘§ in ğ›¤ğ›¤ with ğœ™ğœ™(ğ‘ğ‘) = ğ‘¦ğ‘¦, then there exists an edge ğ‘ğ‘ from ğ‘¦ğ‘¦ to 
ğ‘§ğ‘§ with ğœ™ğœ™(ğ‘ğ‘) = ğ‘¥ğ‘¥. 
Such an assembly space is denoted (ğ›¤ğ›¤, ğœ™ğœ™) or simply ğ›¤ğ›¤ where appropriate. We will continue 
to write ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤ to mean that ğ‘¥ğ‘¥ is a vertex of the quiver. 
Definition 12. The set of minimal vertices of an assembly space ğ›¤ğ›¤ is referred to as the basis 
of ğ›¤ğ›¤ and is denoted ğµğµğ›¤ğ›¤. Elements of the basis are referred to as basic objects, basic vertices or 
basic elements. 
Definition 13. An assembly pathway of an assembly space ğ›¤ğ›¤ is any topological ordering of 
the vertices of ğ›¤ğ›¤ with respect to the reachability relation. 

Definition 14. An assembly space ğ›¤ğ›¤ with reachability relation â‰¤ is said to be split-branched 
if for all ğ‘¥ğ‘¥, ğ‘¦ğ‘¦âˆˆğ›¤ğ›¤, ğ‘¥ğ‘¥â‰¤ğ‘¦ğ‘¦ or ğ‘¦ğ‘¦â‰¤ğ‘¥ğ‘¥ whenever ğ‘‰ğ‘‰(ğ‘¥ğ‘¥â†“) âˆ©ğ‘‰ğ‘‰(ğ‘¦ğ‘¦â†“) â‰ âˆ…. 
Definition 15. Let (ğ›¤ğ›¤, ğœ™ğœ™) and (ğ›¤ğ›¤â€², ğœ“ğœ“) be assembly spaces. Then (ğ›¤ğ›¤â€², ğœ“ğœ“) is an assembly 
subspace of (ğ›¤ğ›¤, ğœ™ğœ™) if ğ›¤ğ›¤â€² is a subquiver of ğ›¤ğ›¤ and ğœ“ğœ“= ğœ™ğœ™|ğ¸ğ¸(ğ›¤ğ›¤â€²). This relationship is denoted as 
(ğ›¤ğ›¤, ğœ™ğœ™) âŠ†(ğ›¤ğ›¤â€², ğœ“ğœ“), or simply ğ›¤ğ›¤âŠ†ğ›¤ğ›¤â€² when there is no ambiguity. 
Definition 16. Let ğ›¤ğ›¤â€² be an assembly subspace of ğ›¤ğ›¤. Then ğ›¤ğ›¤â€² is rooted in ğ›¤ğ›¤ if ğµğµğ›¤ğ›¤â€² âŠ†ğµğµğ›¤ğ›¤ as 
sets. 
Lemma 3. Let ğ‘ˆğ‘ˆ, ğ‘‰ğ‘‰ and ğ‘Šğ‘Š be assembly spaces with ğ‘ˆğ‘ˆâŠ†ğ‘‰ğ‘‰ and ğ‘‰ğ‘‰âŠ†ğ‘Šğ‘Š, then ğ‘ˆğ‘ˆâŠ†ğ‘Šğ‘Š. 
Further, if ğ‘ˆğ‘ˆ is rooted in ğ‘‰ğ‘‰, and ğ‘‰ğ‘‰ is rooted in ğ‘Šğ‘Š, then ğ‘ˆğ‘ˆ is rooted in ğ‘Šğ‘Š. 
Proof. Let (ğ‘ˆğ‘ˆ, ğœ™ğœ™ğ‘ˆğ‘ˆ), (ğ‘‰ğ‘‰, ğœ™ğœ™ğ‘‰ğ‘‰) and (ğ‘Šğ‘Š, ğœ™ğœ™ğ‘Šğ‘Š) be assembly spaces such that (ğ‘ˆğ‘ˆ, ğœ™ğœ™ğ‘ˆğ‘ˆ) âŠ†(ğ‘‰ğ‘‰, ğœ™ğœ™ğ‘‰ğ‘‰) 
and (ğ‘‰ğ‘‰, ğœ™ğœ™ğ‘‰ğ‘‰) âŠ†(ğ‘Šğ‘Š, ğœ™ğœ™ğ‘Šğ‘Š). Since ğ‘ˆğ‘ˆ, ğ‘‰ğ‘‰ and ğ‘Šğ‘Š are quivers, ğ‘ˆğ‘ˆâŠ†ğ‘Šğ‘Š by the transitivity of âŠ† on 
quivers. Further, since ğœ™ğœ™ğ‘ˆğ‘ˆ= ğœ™ğœ™ğ‘‰ğ‘‰|ğ¸ğ¸(ğ‘ˆğ‘ˆ), ğœ™ğœ™ğ‘‰ğ‘‰= ğœ™ğœ™ğ‘Šğ‘Š|ğ¸ğ¸(ğ‘‰ğ‘‰) and ğ¸ğ¸(ğ‘ˆğ‘ˆ) âŠ†ğ¸ğ¸(ğ‘Šğ‘Š), we have ğœ™ğœ™ğ‘ˆğ‘ˆ=
ğœ™ğœ™ğ‘Šğ‘Š|ğ¸ğ¸(ğ‘Šğ‘Š). Thus, (ğ‘ˆğ‘ˆ, ğœ™ğœ™ğ‘ˆğ‘ˆ) âŠ†(ğ‘Šğ‘Š, ğœ™ğœ™ğ‘Šğ‘Š). That is, âŠ† is transitive on assembly spaces. If ğ‘ˆğ‘ˆ is 
rooted in ğ‘‰ğ‘‰ and ğ‘‰ğ‘‰ is rooted in ğ‘Šğ‘Š, then ğµğµğ‘ˆğ‘ˆâŠ†ğµğµğ‘‰ğ‘‰âŠ†ğµğµğ‘Šğ‘Š. That is, ğ‘ˆğ‘ˆ is rooted in ğ‘Šğ‘Š. 
 
âˆ 
Lemma 4. Let (ğ›¤ğ›¤, ğœ™ğœ™) be an assembly space and let ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤. If ğ‘’ğ‘’âˆ¼[ğ‘ğ‘ğ‘ğ‘] is an edge in ğ›¤ğ›¤ with 
ğ‘ğ‘, ğ‘ğ‘âˆˆğ‘¥ğ‘¥â†“, then ğœ™ğœ™(ğ‘’ğ‘’) âˆˆğ‘¥ğ‘¥â†“. 
Proof. Since ğ›¤ğ›¤ is an assembly space, we have ğœ™ğœ™(ğ‘’ğ‘’) â‰¤ğ‘ğ‘ where â‰¤ is the reachability relation 
on ğ›¤ğ›¤. By construction, ğ‘ğ‘â‰¤ğ‘¥ğ‘¥ so that ğœ™ğœ™(ğ‘’ğ‘’) â‰¤ğ‘¥ğ‘¥. Therefore ğœ™ğœ™(ğ‘’ğ‘’) âˆˆğ‘¥ğ‘¥â†“. 
 
âˆ 
Lemma 5. Let (ğ›¤ğ›¤, ğœ™ğœ™) be an assembly space and let ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤. Then (ğ‘¥ğ‘¥â†“, ğœ™ğœ™|ğ‘¥ğ‘¥â†“) is a rooted 
assembly subspace of ğ›¤ğ›¤. 
Proof. We first show that (ğ‘¥ğ‘¥â†“, ğœ™ğœ™|ğ‘¥ğ‘¥â†“) is an assembly space. Since (ğ›¤ğ›¤, ğœ™ğœ™) is an assembly space, 
it is the upper set of its basis ğµğµğ›¤ğ›¤. As such min(ğ‘¥ğ‘¥â†“) is a non-empty subset of ğµğµğ›¤ğ›¤ and ğ‘¥ğ‘¥â†“=
min(ğ‘¥ğ‘¥â†“) â†‘ giving us axiom 1. The remaining axiom follows directly from lemma 4. Whatâ€™s 
more, we already have that min(ğ‘¥ğ‘¥â†“) = ğµğµğ‘¥ğ‘¥â†“âŠ†ğµğµğ›¤ğ›¤, so ğ‘¥ğ‘¥â†“ is rooted in ğ›¤ğ›¤. 
 
âˆ 
Definition 17. Let (ğ›¤ğ›¤, ğœ™ğœ™) and (ğ›¥ğ›¥, ğœ“ğœ“) be assembly spaces. An assembly map is a quiver 
morphism ğ‘“ğ‘“: ğ›¤ğ›¤â†’ğ›¥ğ›¥ such that ğœ“ğœ“âˆ˜ğ‘“ğ‘“ğ‘’ğ‘’= ğ‘“ğ‘“ğ‘£ğ‘£âˆ˜ğœ™ğœ™. That is, the following diagram commutes: 
 
 

Our first theorem provides a basis for the lower bounds developed in the next section. The 
essential point is that the image of an assembly space under an assembly space is an assembly 
space. 
Theorem 1. If ğ‘“ğ‘“: ğ›¤ğ›¤â†’ğ›¥ğ›¥ is an assembly map between assembly spaces (ğ›¤ğ›¤, ğœ™ğœ™) and (ğ›¥ğ›¥, ğœ“ğœ“), 
then (ğ‘“ğ‘“(ğ›¤ğ›¤), ğœ‘ğœ‘) with ğœ‘ğœ‘= ğœ“ğœ“|ğ¸ğ¸(ğ‘“ğ‘“(ğ›¤ğ›¤)) is an assembly subspace of ğ›¥ğ›¥. 
Proof. Since ğ‘“ğ‘“ is a quiver morphism and ğ›¥ğ›¥ is acyclic, ğ‘“ğ‘“(ğ›¤ğ›¤) is an acyclic subquiver of ğ›¥ğ›¥. By 
construction, ğœ‘ğœ‘= ğœ“ğœ“|ğ¸ğ¸(ğ‘“ğ‘“(ğ›¤ğ›¤)). What remains is to prove the three assembly space axioms. Let 
ğ‘“ğ‘“ğ‘£ğ‘£ and ğ‘“ğ‘“ğ‘’ğ‘’ be the vertex and edge maps comprising ğ‘“ğ‘“. 
Axiom 1 We must show that ğ¦ğ¦ğ¦ğ¦ğ¦ğ¦(ğ’‡ğ’‡(ğœğœ)) is finite and non-empty. 
We start by showing that min(ğ‘“ğ‘“(ğ›¤ğ›¤)) â‰ âˆ…. To see this, consider an element ğ‘ğ‘âˆˆ
ğ‘“ğ‘“ğ‘£ğ‘£(min(ğ›¤ğ›¤)), and suppose there exists a path from an element ğ‘¥ğ‘¥âˆˆğ‘“ğ‘“(ğ›¤ğ›¤) to ğ‘ğ‘. Then let ğ‘£ğ‘£âˆˆ
ğ‘“ğ‘“ğ‘£ğ‘£
âˆ’1(ğ‘¥ğ‘¥) and let ğ›¾ğ›¾ be a path from a basic element ğ‘¢ğ‘¢âˆˆmin(ğ›¤ğ›¤) to ğ‘£ğ‘£ â€“ which must exist 
since ğ›¤ğ›¤ is an assembly space. The image of this path is a path in ğ‘“ğ‘“(ğ›¤ğ›¤) from ğ‘“ğ‘“ğ‘£ğ‘£(ğ‘¢ğ‘¢) to ğ‘¥ğ‘¥, 
and consequently a path from ğ‘“ğ‘“ğ‘£ğ‘£(ğ‘¢ğ‘¢) to ğ‘ğ‘. Since ğ‘“ğ‘“ğ‘£ğ‘£(min(ğ›¤ğ›¤)) is finite, we can repeat this 
process beginning with the newly identified element of ğ‘“ğ‘“ğ‘£ğ‘£(min(ğ›¤ğ›¤)) only finitely many 
times before a cycle is formed. However, that cycle must have length zero since ğ›¥ğ›¥ 
contains no cycles of greater length. As such, the final element of ğ‘“ğ‘“ğ‘£ğ‘£(ğ‘¢ğ‘¢) produced is in 
min(ğ‘“ğ‘“(ğ›¤ğ›¤)) since there is nothing below it in ğ‘“ğ‘“(ğ›¤ğ›¤). Thus, min(ğ‘“ğ‘“(ğ›¤ğ›¤)) is non-empty. 
We now show that, min(ğ‘“ğ‘“(ğ›¤ğ›¤)) is in fact finite. In particular, min(ğ‘“ğ‘“(ğ›¤ğ›¤)) is a subset of a 
finite set, namely ğ‘“ğ‘“ğ‘£ğ‘£(min(ğ›¤ğ›¤)), so it too is finite. Let ğ‘¥ğ‘¥âˆˆmin(ğ‘“ğ‘“(ğ›¤ğ›¤)). Then there exists an 
element ğ‘ğ‘âˆˆğ‘“ğ‘“ğ‘£ğ‘£
âˆ’1(ğ‘¥ğ‘¥) and at least one path ğ›¾ğ›¾ from a basic element ğ‘ğ‘âˆˆmin(ğ›¤ğ›¤) to ğ‘ğ‘. The 
image of ğ›¾ğ›¾ under ğ‘“ğ‘“ is a path in ğ‘“ğ‘“(ğ›¤ğ›¤) from ğ‘“ğ‘“ğ‘£ğ‘£(ğ‘ğ‘) to ğ‘¥ğ‘¥. Since ğ‘¥ğ‘¥ is minimal in ğ‘“ğ‘“(ğ›¤ğ›¤), the 
only paths that terminate at ğ‘¥ğ‘¥ are zero paths. Thus ğ‘“ğ‘“ğ‘£ğ‘£(ğ‘ğ‘) = ğ‘¥ğ‘¥. Since ğ‘¥ğ‘¥ was a generic 
element of min(ğ‘“ğ‘“(ğ›¤ğ›¤)), every element of min(ğ‘“ğ‘“(ğ›¤ğ›¤)) is the image of a basic element of ğ›¤ğ›¤. 
That is min(ğ‘“ğ‘“(ğ›¤ğ›¤)) âŠ†ğ‘“ğ‘“ğ‘£ğ‘£(min(ğ›¤ğ›¤)), so itâ€™s finite. 

Axiom 2 Next we prove that ğ’‡ğ’‡(ğœğœ) = ğ¦ğ¦ğ¦ğ¦ğ¦ğ¦(ğ’‡ğ’‡(ğœğœ)) â†‘. Let ğ’™ğ’™ be an element of ğ’‡ğ’‡(ğœğœ). We aim 
to show that there exists a path from a basic element of ğ’‡ğ’‡(ğœğœ) to ğ’™ğ’™. Let ğ’ƒğ’ƒ be an element of 
ğœğœ which maps to ğ’™ğ’™ under application of ğ’‡ğ’‡. Then, since ğœğœ is an assembly space, we know 
there exists at least one path, ğœ¸ğœ¸ from a basic element of ğœğœ, say ğ’‚ğ’‚âˆˆğ¦ğ¦ğ¦ğ¦ğ¦ğ¦(ğœğœ), to ğ’ƒğ’ƒ. The 
image of this path in ğ’‡ğ’‡(ğœğœ) is itself a path from ğ’‡ğ’‡ğ’—ğ’—(ğ’‚ğ’‚) to ğ’™ğ’™, namely ğ’‡ğ’‡ğ’†ğ’†(ğœ¸ğœ¸). If ğ’‡ğ’‡ğ’—ğ’—(ğ’‚ğ’‚) is a 
basic element of ğ’‡ğ’‡(ğœğœ) the we are done. Otherwise, we can use the processes described in 
the proof of Axiom 1 to construct a path from ğ’‡ğ’‡ğ’—ğ’—(ğ’‚ğ’‚) through basic and non-basic 
elements which will ultimately terminate at a basic element. Composing this path with 
ğ’‡ğ’‡ğ’†ğ’†(ğœ¸ğœ¸) then yields a path from a basic element to ğ’™ğ’™. As such, every element of ğ’‡ğ’‡(ğœğœ) is 
above at least one basic element of ğ’‡ğ’‡(ğœğœ), i.e. ğ’‡ğ’‡(ğœğœ) = ğ¦ğ¦ğ¦ğ¦ğ¦ğ¦(ğ’‡ğ’‡(ğœğœ)) â†‘. 
Axiom 3 We now must show that for every edge ğ’‚ğ’‚âˆˆğ‘¬ğ‘¬(ğ’‡ğ’‡(ğœğœ)) with ğ’‚ğ’‚âˆ¼[ğ’›ğ’›ğ’›ğ’›] and 
ğ‹ğ‹(ğ’‚ğ’‚) = ğ’šğ’š, then there exists an edge ğ’ƒğ’ƒâˆˆğ‘¬ğ‘¬(ğ’‡ğ’‡(ğœğœ)) with ğ’ƒğ’ƒâˆ¼[ğ’›ğ’›ğ’›ğ’›] and ğ‹ğ‹(ğ’ƒğ’ƒ) = ğ’™ğ’™. To see 
that this is the case, take ğ’‚ğ’‚ as described. Then there exists an edge ğ’–ğ’–âˆˆğ’‡ğ’‡ğ’†ğ’†
âˆ’ğŸğŸ(ğ’‚ğ’‚) in ğœğœ with 
ğ’–ğ’–âˆ¼[ğ’“ğ’“ğ’“ğ’“], ğ’‡ğ’‡ğ’—ğ’—(ğ’“ğ’“) = ğ’›ğ’›, ğ’‡ğ’‡ğ’—ğ’—(ğ’’ğ’’) = ğ’šğ’š and ğ“ğ“(ğ’–ğ’–) = ğ’‘ğ’‘. Since ğœğœ is an assembly space, there 
exists an edge ğ’—ğ’—âˆˆğ‘¬ğ‘¬(ğœğœ) with ğ’—ğ’—âˆ¼[ğ’“ğ’“ğ’“ğ’“] and ğ“ğ“(ğ’—ğ’—) = ğ’’ğ’’. The commutivity property of 
assembly maps then gives us ğ‹ğ‹(ğ’‡ğ’‡ğ’†ğ’†(ğ’—ğ’—)) = ğ’‡ğ’‡ğ’—ğ’—(ğ“ğ“(ğ’—ğ’—)) = ğ’‡ğ’‡ğ’—ğ’—(ğ’’ğ’’) = ğ’šğ’š. Calling ğ’‡ğ’‡ğ’—ğ’—(ğ’‘ğ’‘) = ğ’™ğ’™ 
we then have an edge in ğ’‡ğ’‡(ğœğœ), namely ğ’‡ğ’‡ğ’†ğ’†(ğ’—ğ’—), which terminates at ğ’›ğ’› and is labeled as ğ’šğ’š. 
This satisfies Axiom 3. 
 
 
âˆ 
7. The Assembly Index 
This final section turns to the definition and computation of the assembly index, a measure of 
how directly an object can be constructed from basic objects. 
Definition 18. The cardinality of an assembly space (ğ›¤ğ›¤, ğœ™ğœ™) is the cardinality of the 
underlying quiverâ€™s vertex set, |ğ‘‰ğ‘‰(ğ›¤ğ›¤)|. The augmented cardinality of the (ğ›¤ğ›¤, ğœ™ğœ™) with basis ğµğµğ›¤ğ›¤ 
is |ğ‘‰ğ‘‰(ğ›¤ğ›¤)\ğµğµğ›¤ğ›¤| = |ğ‘‰ğ‘‰(ğ›¤ğ›¤)| âˆ’|ğµğµğ›¤ğ›¤|. 
Definition 19. The assembly index ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) of a finite object ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤ is the minimal augmented 
cardinality of all rooted assembly subspaces containing ğ‘¥ğ‘¥. This can be written ğ‘ğ‘(ğ‘¥ğ‘¥) when the 
relevant assembly space ğ›¤ğ›¤ is clear from context. 
4.1 Bounds on the Assembly Index 
First of all, we can bound the assembly index of an object from above by computing the 
assembly index of that object in a rooted subspace. Essentially, since assembly subspace 
generally has fewer edges, there are fewer â€œshortcutsâ€ to assembly the giving object. 
Lemma 6. Let ğ‘‹ğ‘‹ be an assembly space and ğ‘Œğ‘Œ a rooted assembly subspace of ğ‘‹ğ‘‹. For every 
finite ğ‘¦ğ‘¦âˆˆğ‘Œğ‘Œ, the assembly index of ğ‘¦ğ‘¦ in ğ‘Œğ‘Œ is greater than or equal to the assembly index of ğ‘¦ğ‘¦ 
in ğ‘‹ğ‘‹. That is, ğ‘ğ‘ğ‘Œğ‘Œ(ğ‘¦ğ‘¦) â‰¥ğ‘ğ‘ğ‘‹ğ‘‹(ğ‘¦ğ‘¦) for all ğ‘¦ğ‘¦âˆˆğ‘Œğ‘Œ. 
Proof. Let ğ‘¦ğ‘¦âˆˆğ‘Œğ‘Œ and suppose ğ‘ğ‘ğ‘Œğ‘Œ(ğ‘¦ğ‘¦) < ğ‘ğ‘ğ‘‹ğ‘‹(ğ‘¦ğ‘¦). Then there exists a rooted assembly subspace 
ğ‘ğ‘âŠ†ğ‘Œğ‘Œ containing ğ‘¦ğ‘¦ such that |ğ‘ğ‘\ğµğµğ‘ğ‘| = ğ‘ğ‘ğ‘Œğ‘Œ(ğ‘¦ğ‘¦). But, by the transitivity of subset inclusion 
(lemma 3) ğ‘ğ‘ is a rooted assembly subspace of ğ‘‹ğ‘‹. But if thatâ€™s the case, there exists a rooted 
assembly subspace of ğ‘‹ğ‘‹ with augmented cardinality less than ğ‘ğ‘ğ‘‹ğ‘‹(ğ‘¦ğ‘¦), namely ğ‘ğ‘; a 

contradiction. 
 
âˆ 
 
Since the lower quiver of an object ğ‘¥ğ‘¥ is a rooted assembly subspace, we know the assembly 
index of the object in ğ‘¥ğ‘¥â†“ bounds the real assembly index of the object from above. However, 
we can do better â€“ ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) = ğ‘ğ‘ğ‘¥ğ‘¥â†“(ğ‘¥ğ‘¥). This is a very powerful result as it allows us any 
computational approaches aiming to compute ğ‘ğ‘(ğ‘¥ğ‘¥) to focus only on the objects below ğ‘¥ğ‘¥. 
Theorem 2. Let ğ›¤ğ›¤ be an assembly space and let ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤ be finite. Then ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) = ğ‘ğ‘ğ‘¥ğ‘¥â†“(ğ‘¥ğ‘¥). 
Proof. Since ğ‘¥ğ‘¥â†“ is finite, we need only consider finite, rooted assembly subspaces of ğ›¤ğ›¤. Let 
ğ›¥ğ›¥âŠ†ğ›¤ğ›¤ be such a subspace containing ğ‘¥ğ‘¥, and suppose that ğ›¥ğ›¥âŠˆğ‘¥ğ‘¥â†“. Let ğ‘¦ğ‘¦âˆˆğ›¥ğ›¥ such that ğ‘¦ğ‘¦âˆ‰
ğ‘¥ğ‘¥â†“, then (ğ›¥ğ›¥\ğ‘¦ğ‘¦â†‘) is a rooted assembly subspace of ğ›¤ğ›¤ containing ğ‘¥ğ‘¥ with augmented 
cardinality strictly less than ğ›¥ğ›¥. As such |ğ›¥ğ›¥\ğµğµğ›¥ğ›¥| â‰ ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥). In other words, if ğ›¥ğ›¥ is not a subspace 
of ğ‘¥ğ‘¥â†“, then it cannot have the augmented cardinality ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥). Thus, by contrapositive if 
|ğ›¥ğ›¥\ğµğµğ›¥ğ›¥| = ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥), then ğ›¥ğ›¥âŠ†ğ‘¥ğ‘¥â†“. Since ğ›¥ğ›¥ is rooted in ğ›¤ğ›¤, it must also be rooted in ğ‘¥ğ‘¥â†“. 
Therefore, if a rooted subspace of ğ›¤ğ›¤ has the minimal augmented cardinality in ğ›¤ğ›¤, it must be a 
rooted assembly subspace of ğ‘¥ğ‘¥â†“. This implies that ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) â‰¥ğ‘ğ‘ğ‘¥ğ‘¥â†“(ğ‘¥ğ‘¥). Additionally, by lemma 
6, ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) â‰¤ğ‘ğ‘ğ‘¥ğ‘¥â†“(ğ‘¥ğ‘¥). Then ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) = ğ‘ğ‘ğ‘¥ğ‘¥â†“(ğ‘¥ğ‘¥). 
 
âˆ 
 
Finally, assembly maps allow us to place lower-bounds on the assembly index â€“ the assembly 
index of the image of an object bounds the objectâ€™s actual assembly index below. In other 
words, we can place lower bounds on the assembly index of an object by mapping the 
assembly space into a simpler space and computing the assembly index there. 
Theorem 3. If ğ‘“ğ‘“: ğ›¤ğ›¤â†’ğ›¥ğ›¥ is an assembly map, then ğ‘ğ‘ğ‘“ğ‘“(ğ›¤ğ›¤)(ğ‘“ğ‘“(ğ‘¥ğ‘¥)) â‰¤ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) for all finite ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤. 
Proof. Let ğ›´ğ›´âŠ†ğ›¤ğ›¤ be an assembly subspace containing ğ‘¥ğ‘¥ with |ğ›´ğ›´\ğµğµğ›´ğ›´| = ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥). The restriction 
of ğ‘“ğ‘“ to ğ›´ğ›´ is an assembly map ğ‘“ğ‘“âˆ—: ğ›´ğ›´â†’ğ‘“ğ‘“(ğ›¤ğ›¤). Then we have 
|ğ›´ğ›´\ğµğµğ›´ğ›´|
â‰¥|ğ‘“ğ‘“âˆ—(ğ›´ğ›´\ğµğµğ›´ğ›´)|
= |ğ‘“ğ‘“âˆ—(ğ›´ğ›´\ğµğµğ›´ğ›´) âˆ©(ğ‘“ğ‘“âˆ—(ğ›´ğ›´)\ğµğµğ‘“ğ‘“âˆ—(ğ›´ğ›´))| + |ğ‘“ğ‘“âˆ—(ğ›´ğ›´\ğµğµğ›´ğ›´) âˆ©ğµğµğ‘“ğ‘“âˆ—(ğ›´ğ›´)|
â‰¥|ğ‘“ğ‘“âˆ—(ğ›´ğ›´\ğµğµğ›´ğ›´) âˆ©(ğ‘“ğ‘“âˆ—(ğ›´ğ›´)\ğµğµğ‘“ğ‘“âˆ—(ğ›´ğ›´))|.
 
As an assembly map, ğ‘“ğ‘“âˆ— maps basis elements of ğ›´ğ›´ onto basis elements of ğ‘“ğ‘“âˆ—(ğ›´ğ›´). So every for 
ğ‘¢ğ‘¢âˆˆğ‘“ğ‘“âˆ—(ğ›´ğ›´)\ğµğµğ‘“ğ‘“âˆ—(ğ›´ğ›´), there exists a ğ‘£ğ‘£âˆˆğ›´ğ›´\ğµğµğ›´ğ›´ such that ğ‘“ğ‘“âˆ—(ğ‘£ğ‘£) = ğ‘¢ğ‘¢. This gives us 
ğ‘ğ‘ğ›¤ğ›¤
= |ğ›´ğ›´\ğµğµğ›´ğ›´|
â‰¥|ğ‘“ğ‘“âˆ—(ğ›´ğ›´\ğµğµğ›´ğ›´) âˆ©(ğ‘“ğ‘“âˆ—(ğ›´ğ›´)\ğµğµğ‘“ğ‘“âˆ—(ğ›´ğ›´))|
= |ğ‘“ğ‘“âˆ—(ğ›´ğ›´)\ğµğµğ‘“ğ‘“âˆ—(ğ›´ğ›´)|
â‰¥ğ‘ğ‘ğ‘“ğ‘“(ğ›¤ğ›¤)(ğ‘“ğ‘“(ğ‘¥ğ‘¥)).
  
 

4.2  Computability and Algorithms 
Theorem 4. If ğ›¤ğ›¤ is an assembly space and ğ‘¥ğ‘¥âˆˆğ›¤ğ›¤ is finite, then ğ‘ğ‘(ğ‘¥ğ‘¥) is computable. 
Proof. As shown in the proof of theorem 2, every rooted assembly subspace with minimal 
augmented cardinality and containing ğ‘¥ğ‘¥ is a minimal rooted assembly subspace of ğ‘¥ğ‘¥â†“. Since 
ğ‘¥ğ‘¥ is finite, ğ‘¥ğ‘¥â†“ is finite, the set of assembly subspace of ğ‘¥ğ‘¥â†“ is finite, and each such subspace 
is finite. Consequently, the basis of each subspace is computable. As such, the set of all 
rooted subspaces is computable. The cardinality of each subspace is computable, so the set of 
cardinalities of all rooted subspaces is computable. Finally, the minimum of a finite set of 
natural numbers is computable. Therefore, ğ‘ğ‘ğ›¤ğ›¤(ğ‘¥ğ‘¥) is computable. 
 
âˆ 
An algorithm for finding the pathway assembly index of an object within an assembly subspace 
is described below. 
The Assembly Index in assembly space Î“ â‰¡(Î“, ğœ™ğœ™) of a target object ğ‘¡ğ‘¡âˆˆÎ“, with basic objects 
ğµğµâŠ†Î“. 
 
Function Main(B, t) 
Global Variable PA // the pathway assembly index 
Set PA = upper bound of assembly index + |B| 
AssemblyIndex(B, t) 
Return PA - |B| 
End Function 
Function AssemblyIndex(S, t) 
 
For each pair of objects s1, s2 âˆˆS 
 
 
If there exists an edge ğ‘’ğ‘’~[ğ‘¡ğ‘¡ğ‘¡ğ‘¡1] with ğœ™ğœ™(ğ‘’ğ‘’) = ğ‘ ğ‘ 2 and PA > |S âˆªt|  
 
 
 
PA = |S âˆªT| 
 
 
Else there exists an edge ğ‘’ğ‘’~[ğ‘¢ğ‘¢ğ‘¢ğ‘¢1] with ğœ™ğœ™(ğ‘’ğ‘’) = ğ‘ ğ‘ 2 for some u âˆˆÎ“ 
 
 
 
AssemblyIndex(Î“, S âˆªu, t) 
 
 
End If 
 
End For 
End Function 
 
We have also defined above the Split-Branched Assembly Index. Calculation of this index can 
be more computationally tractable than the assembly index, as often a lower number of 
pathways will need to be enumerated.  An algorithm to calculate this index is shown below. 
The Split-Branched Assembly Index in assembly space Î“ â‰¡(Î“ , ğœ™ğœ™) of a target object ğ‘¡ğ‘¡âˆˆÎ“ 
with, with basic objects ğµğµâŠ†ğ‘‰ğ‘‰(Î“) 
Function SplitBranchedAssemblyIndex(Î“, B, t, I) 
 
Set PA = upper bound of assembly index for t 
 
For each partition of U into connected sub-objects Î“P = {Î“1 â€¦ Î“n} 
 
 
Set PartitionIndex = 0 
 
 
Partition UP into K = {{Î“11, â€¦ , Î“1i}, àµ›Î“21, â€¦ , Î“2jàµŸ, â€¦ , {Î“m1 â€¦ Î“mk}} 
 
 
Where for each Kn, the Î“nx are identical for all x 
 
 
For each Ki âˆˆK 
 
 
 
If Ki1 âˆˆB 
 
 
 
 
PartitionIndex +=  1 
 
 
 
Else 
 
 
 
 
PartitionIndex +=  SplitBranchedAssemblyIndex(Î“, B, Ki1) 

+ |Ki| âˆ’1 
 
 
End If 
 
End For 
 
 
PA = min (PartitionIndex, PA) 
 
End For 
 
Return PA 
End Function 
References 
1. 
S. M. Marshall, A. R. G. Murray, and L. Cronin, A Probabilistic Framework for 
Identifying Biosignatures Using Pathway Complexity. Phil. Trans. R. Soc. A 375, 
20160342 (2017). 
 
 
 

