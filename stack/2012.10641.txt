arXiv:2012.10641v1  [cs.FL]  19 Dec 2020
UNIVERSITÉ DE ROUEN NORMANDIE
HABILITATION À DIRIGER DES RECHERCHES
Une proposition d’implantation des structures
d’automates, d’expressions et de leurs
algorithmes associés utilisant les catégories
enrichies
Auteur :
Ludovic MIGNOT
Directeur :
Pr. Pascal CARON
Soutenue publiquement le 15 décembre 2020 devant le jury composé de
Pascal CARON
PU
université de Rouen Normandie
Garant
Olivier CARTON
PU
université Paris Diderot
Rapporteur
Thomas COLCOMBET
DR
université Paris Diderot
Rapporteur
Samuele GIRAUDO
MCF HDR
université Gustave Eiffel
Examinateur
Sylvain LOMBARDY
PU
institut polytechnique de Bordeaux
Rapporteur
Jean-Gabriel LUQUE
PU
université de Rouen Normandie
Examinateur
Djelloul ZIADI
PU
université de Rouen Normandie
Examinateur
Groupe de Recherche Rouennais en Informatique Fondamentale
Département d’informatique


iii
UNIVERSITÉ DE ROUEN NORMANDIE
Résumé
U.F.R. Sciences et Techniques
Groupe de Recherche Rouennais en Informatique Fondamentale
Département d’informatique
Habilitation à diriger des recherches
Une proposition d’implantation des structures d’automates, d’expressions et de leurs
algorithmes associés utilisant les catégories enrichies
par Ludovic MIGNOT
Dans ce document, nous proposons une description, via une implantation Haskell, d’une généralisa-
tion de la notion d’expressions rationnelles permettant de factoriser les déﬁnitions et les méthodes de
construction d’automates de mots ou d’arbres sur une seule structure, basée sur des outils de théorie
des catégories enrichies.
Pour cela, nous rappellerons tout d’abord les différentes méthodes, communes et existantes, de
conversion d’expressions en automates, en mettant en lumière les similitudes entre le cas des mots
et celui des arbres.
Nous produirons ensuite une étude originale de l’apport de la théorie des catégories enrichies à
l’implantation des automates, des expressions et des algorithmes associés, en utilisant des concepts
avancés de programmation fonctionnelle, tout en proposant simultanément une implantation Has-
kell des notions de théorie des catégories enrichies et des automates associés.
Nous aboutirons alors à l’ébauche d’une déﬁnition d’expressions généralisées basée sur la notion de
produit tensoriel, laissant entrevoir les perspectives d’un projet de recherche pour lequel je souhaite
être habilité.


v
Table des matières
Résumé
iii
Table des matières
vi
Pseudo-codes
xi
Introduction
1
Préliminaires
3
I
Des expressions rationnelles d’arbres aux automates d’arbres
17
Présentation
19
1
Les constructions Top-Down
23
1.1
L’automate des positions Top-Down . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.2
L’automate des follows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
1.3
Les automates des c-continuations et des termes dérivés
. . . . . . . . . . . . . . . . .
29
1.3.1
Les c-continuations d’arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
1.3.2
L’automate des termes dérivés de Kuske et Meinecke . . . . . . . . . . . . . . .
33
1.3.3
Lien entre termes dérivés et c-continuations
. . . . . . . . . . . . . . . . . . . .
35
1.4
Un automate plus petit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
2
Les constructions Bottom-Up
39
2.1
L’automate des positions Bottom-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.2
L’automate des parents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
2.3
Le quotient et la dérivation Bottom-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
2.3.1
Formules inductives du quotient pour les arbres . . . . . . . . . . . . . . . . . .
46
2.3.2
Formules inductives du quotient pour les opérations sur les langages
. . . . .
48
L’union . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
Le produit de substitution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
Le produit de composition
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
La composition itérée
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
La substitution itérée . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.3.3
Un test d’appartenance purement syntaxique . . . . . . . . . . . . . . . . . . . .
52
2.3.4
Extension aux opérations booléennes
. . . . . . . . . . . . . . . . . . . . . . . .
54
2.3.5
Expressions étendues homogènes
. . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.3.6
Construction d’automate associée
. . . . . . . . . . . . . . . . . . . . . . . . . .
56
3
Conclusion
59
II
Les automates catégoriques
61
4
Présentation
63
5
Les automates de mots
67
5.1
Automates sur une catégorie
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
5.2
Autres types d’automates de mots
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76

vi
5.2.1
Monades et catégories de Kleisli . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
5.2.2
Automates et catégories de Kleisli . . . . . . . . . . . . . . . . . . . . . . . . . .
79
5.2.3
Monade des semimodules libres et automates à multiplicités . . . . . . . . . . .
84
5.2.4
Monade State, transformers, et automates à pile . . . . . . . . . . . . . . . . . .
88
5.3
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
6
Extensions des automates de mots : les automates monoïdaux
97
6.1
Opérade, types gradués et programmation au niveau des types
. . . . . . . . . . . . .
97
6.2
Catégorie monoïdale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
6.3
Retour aux opérades . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
108
6.4
Catégories enrichies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
6.5
Automates généralisés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
6.6
Automates généralisés et monades . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
132
6.7
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
7
Expressions rationnelles
145
7.1
Déﬁnition et implantation des expressions de mots . . . . . . . . . . . . . . . . . . . . .
145
7.2
Constructions d’automates de mots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
147
7.2.1
Induction et monade libre . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
147
7.2.2
Automate de Kleisli des positions
. . . . . . . . . . . . . . . . . . . . . . . . . .
153
Les fonctions de position
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
La linéarisation à l’aide de la monade State . . . . . . . . . . . . . . . . . . . . .
156
La construction de l’automate des positions . . . . . . . . . . . . . . . . . . . . .
157
7.2.3
Dérivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
158
7.3
Expressions enrichies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
162
7.3.1
Déﬁnition et implantation générale
. . . . . . . . . . . . . . . . . . . . . . . . .
162
7.3.2
Constructions d’automates enrichis
. . . . . . . . . . . . . . . . . . . . . . . . .
166
L’automate des positions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
166
L’automate enrichi des dérivées
. . . . . . . . . . . . . . . . . . . . . . . . . . .
170
La construction inductive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
172
7.4
Conclusion et perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
182
Conclusion et perspectives
183
Bibliographie
185
Index
190
III
Annexes
191
A Automates de mots
193
A.1 Automates à multiplicités séquentiels et monade Writer . . . . . . . . . . . . . . . . .
193
A.2 Produits parallèles d’automates de types différents
. . . . . . . . . . . . . . . . . . . .
196
A.3 Utilisation des vecteurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
197

vii
Table des ﬁgures
1
Associativité verticale. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2
Associativité horizontale.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3
L’automate compressé A. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.1
L’automate des positions PE.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
1.2
L’automate des positions PE.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
1.3
L’automate des follows de E.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
1.4
L’automate des c-continuations de E. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
1.5
L’automate des termes dérivés AE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
1.6
L’automate (CE)∼. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
1.7
L’automate (CE)∼F . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
1.8
L’automate V. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
2.1
L’automate compressé de l’expression ( f1(a, a) + g2(b))∗a ·b f3(g4(a), b). . . . . . . . .
41
2.2
L’automate compressé des parents de ( f1(a, a) + g2(b))∗a ·b f3(g4(a), b).
. . . . . . . .
43
2.3
L’automate minimal de L1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.4
L’automate A0.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
2.5
L’automate A1.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
2.6
L’automate A2.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
2.7
L’automate des dérivées Bottom-Up de E. . . . . . . . . . . . . . . . . . . . . . . . . . .
58
5.1
Un reconnaisseur de mots de longueurs modulaires. . . . . . . . . . . . . . . . . . . . .
75
5.2
Un (e famille d’) automate non-déterministe dont la déterminisation atteint la borne. .
81
5.3
Un automate à multiplicités. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
5.4
Un automate à pile déterministe. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
5.5
Un automate à pile non-déterministe.
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
6.1
Un automate alternant reconnaissant les mots contenant tous les symboles de {A, B, C, D, E}.113
6.2
Un automate Bottom-Up non-déterministe. . . . . . . . . . . . . . . . . . . . . . . . . .
143


ix
Liste des tableaux
1.1
Déﬁnition inductive de First.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
1.2
Déﬁnition inductive de Last. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
1.3
Déﬁnition inductive de Follow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
1.4
Déﬁnition inductive des c-continuations.
. . . . . . . . . . . . . . . . . . . . . . . . . .
31
2.1
Déﬁnition inductive de Parent.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.2
Déﬁnition inductive de Null.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52


xi
Pseudo-codes
1
Code Pseudo-Haskell. 1 : Exemple jouet . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
2
Code Pseudo-Haskell. 2 : Catégorie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
3
Code Pseudo-Haskell. 3 : Catégorie des types . . . . . . . . . . . . . . . . . . . . . . . .
67
4
Code Pseudo-Haskell. 4 : Catégorie à un objet . . . . . . . . . . . . . . . . . . . . . . . .
68
5
Code Pseudo-Haskell. 5 : Automate
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
6
Code Pseudo-Haskell. 6 : Foncteur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
7
Code Pseudo-Haskell. 7 : Foncteurs liste et identité . . . . . . . . . . . . . . . . . . . . .
70
8
Code Pseudo-Haskell. 8 : Foncteurs liste et identité . . . . . . . . . . . . . . . . . . . . .
70
9
Code Pseudo-Haskell. 9 : Relation liste et identité
. . . . . . . . . . . . . . . . . . . . .
71
10
Code Pseudo-Haskell. 10 : Adjonction . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
11
Code Pseudo-Haskell. 11 : Adjonction Liste Identité . . . . . . . . . . . . . . . . . . . .
72
12
Code Pseudo-Haskell. 12 : Promotion de δ . . . . . . . . . . . . . . . . . . . . . . . . . .
73
13
Code Pseudo-Haskell. 13 : Conﬁguration associée à un mot . . . . . . . . . . . . . . . .
73
14
Code Pseudo-Haskell. 14 : Poids d’un mot . . . . . . . . . . . . . . . . . . . . . . . . . .
73
15
Code Pseudo-Haskell. 15 : Équivalence de types . . . . . . . . . . . . . . . . . . . . . .
73
16
Code Pseudo-Haskell. 16 : Automates déterministes complets . . . . . . . . . . . . . .
74
17
Code Pseudo-Haskell. 17 : Automates déterministes complets . . . . . . . . . . . . . .
75
18
Code Pseudo-Haskell. 18 : Monade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
19
Code Pseudo-Haskell. 19 : Exemples de monades : Listes et Identité . . . . . . . . . . .
77
20
Code Pseudo-Haskell. 20 : Exemples de monades
. . . . . . . . . . . . . . . . . . . . .
78
21
Code Pseudo-Haskell. 21 : Catégorie de Kleisli . . . . . . . . . . . . . . . . . . . . . . .
78
22
Code Pseudo-Haskell. 22 : Automates classiques comme automates de Kleisli . . . . .
79
23
Code Pseudo-Haskell. 23 : Automates de Kleisli
. . . . . . . . . . . . . . . . . . . . . .
79
24
Code Pseudo-Haskell. 24 : Algorithmes classiques et foncteurs . . . . . . . . . . . . . .
80
25
Code Pseudo-Haskell. 25 : Exemple : déterminisation et mémoïsation . . . . . . . . . .
82
26
Code Pseudo-Haskell. 26 : Automates à multiplicités
. . . . . . . . . . . . . . . . . . .
84
27
Code Pseudo-Haskell. 27 : Les semimodules libres . . . . . . . . . . . . . . . . . . . . .
85
28
Code Pseudo-Haskell. 28 : Automates à multiplicités et conversions classiques
. . . .
86
29
Code Pseudo-Haskell. 29 : Exemple : Automates à multiplicités
. . . . . . . . . . . . .
86
30
Code Pseudo-Haskell. 30 : La monade State . . . . . . . . . . . . . . . . . . . . . . . . .
88
31
Code Pseudo-Haskell. 31 : La monade MaybeState . . . . . . . . . . . . . . . . . . . . .
89
32
Code Pseudo-Haskell. 32 : Exemple : automates à pile déterministe . . . . . . . . . . .
89
33
Code Pseudo-Haskell. 33 : Le combinateur StateT
. . . . . . . . . . . . . . . . . . . . .
92
34
Code Pseudo-Haskell. 34 : Exemple : automates à pile non déterministes . . . . . . . .
93
35
Code Pseudo-Haskell. 35 : Types gradués . . . . . . . . . . . . . . . . . . . . . . . . . .
99
36
Code Pseudo-Haskell. 36 : Exemples de types gradués simples . . . . . . . . . . . . . .
100
37
Code Pseudo-Haskell. 37 : Les listes paramétrées par la graduation des éléments qu’elles
contiennent
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
38
Code Pseudo-Haskell. 38 : Produit tensoriel des types gradués . . . . . . . . . . . . . .
101
39
Code Pseudo-Haskell. 39 : Catégorie produit . . . . . . . . . . . . . . . . . . . . . . . .
102
40
Code Pseudo-Haskell. 40 : Produits tensoriels de la catégorie des types . . . . . . . . .
102
41
Code Pseudo-Haskell. 41 : Catégories monoïdales . . . . . . . . . . . . . . . . . . . . .
104
42
Code Pseudo-Haskell. 42 : Catégories monoïdales des types
. . . . . . . . . . . . . . .
105
43
Code Pseudo-Haskell. 43 : Types gradués et produit tensoriel . . . . . . . . . . . . . . .
105
44
Code Pseudo-Haskell. 44 : Catégorie monoïdale des types gradués
. . . . . . . . . . .
106
45
Code Pseudo-Haskell. 45 : Monoïdes objets et leurs catégories . . . . . . . . . . . . . .
107
46
Code Pseudo-Haskell. 46 : Opérades . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
108
47
Code Pseudo-Haskell. 47 : Opérade libre . . . . . . . . . . . . . . . . . . . . . . . . . . .
109

xii
48
Code Pseudo-Haskell. 48 : Graduation de l’opérade libre . . . . . . . . . . . . . . . . .
109
49
Code Pseudo-Haskell. 49 : L’opérade libre est une opérade . . . . . . . . . . . . . . . .
109
50
Code Pseudo-Haskell. 50 : Opérade libre et monade . . . . . . . . . . . . . . . . . . . .
110
51
Code Pseudo-Haskell. 51 : Adjonction opérade libre et identité . . . . . . . . . . . . . .
110
52
Code Pseudo-Haskell. 52 : Promotion de morphisme . . . . . . . . . . . . . . . . . . . .
111
53
Code Pseudo-Haskell. 53 : Expressions Booléennes . . . . . . . . . . . . . . . . . . . . .
111
54
Code Pseudo-Haskell. 54 : Automates alternants . . . . . . . . . . . . . . . . . . . . . .
112
55
Code Pseudo-Haskell. 55 : Automates alternants . . . . . . . . . . . . . . . . . . . . . .
113
56
Code Pseudo-Haskell. 56 : Automates alternants généralisés . . . . . . . . . . . . . . .
115
57
Code Pseudo-Haskell. 57 : Catégories enrichies . . . . . . . . . . . . . . . . . . . . . . .
117
58
Code Pseudo-Haskell. 58 : Catégories enrichies . . . . . . . . . . . . . . . . . . . . . . .
118
59
Code Pseudo-Haskell. 59 : Catégorie enrichie des fonctions graduées . . . . . . . . . .
119
60
Code Pseudo-Haskell. 60 : Catégorie enrichie des fonctions graduées (duales) . . . . .
120
61
Code Pseudo-Haskell. 61 : Automates généralisés
. . . . . . . . . . . . . . . . . . . . .
121
62
Code Pseudo-Haskell. 62 : Automates sur une catégorie et automates généralisés . . .
121
63
Code Pseudo-Haskell. 63 : Automates d’arbres Bottom-Up . . . . . . . . . . . . . . . .
122
64
Code Pseudo-Haskell. 64 : Promotion du morphisme de transitions . . . . . . . . . . .
123
65
Code Pseudo-Haskell. 65 : Combinaisons morphisme / élément généralisé . . . . . . .
124
66
Code Pseudo-Haskell. 66 : Combinaisons morphisme / élément généralisé . . . . . . .
124
67
Code Pseudo-Haskell. 67 : Calcul particulier du poids dans un RWTA
. . . . . . . . .
125
68
Code Pseudo-Haskell. 68 : Complémentation d’un automate d’arbre déterministe com-
plet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
69
Code Pseudo-Haskell. 69 : Calcul particulier du poids dans un RWTA
. . . . . . . . .
127
70
Code Pseudo-Haskell. 70 : Un automate sur une opérade plus . . . . . . . . . . . . . .
131
71
Code Pseudo-Haskell. 71 : Un automate Top-Down à multiplicités . . . . . . . . . . . .
133
72
Code Pseudo-Haskell. 72 : Les foncteurs enrichis . . . . . . . . . . . . . . . . . . . . . .
134
73
Code Pseudo-Haskell. 73 : Les foncteurs enrichis de la catégorie monoïdale des types
135
74
Code Pseudo-Haskell. 74 : Les foncteurs enrichis de la catégorie enrichies des fonctions
n-aires
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
75
Code Pseudo-Haskell. 75 : Les monades enrichies
. . . . . . . . . . . . . . . . . . . . .
136
76
Code Pseudo-Haskell. 76 : Exemples de monades enrichies . . . . . . . . . . . . . . . .
136
77
Code Pseudo-Haskell. 77 : Conversion fonctions / morphismes
. . . . . . . . . . . . .
137
78
Code Pseudo-Haskell. 78 : Catégorie enrichie de Kleisli associée à une monade enrichie 137
79
Code Pseudo-Haskell. 79 : Équivalence entre automates de mots de Kleisli et auto-
mates généralisés de mots de Kleisli . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
138
80
Code Pseudo-Haskell. 80 : Automates d’arbres Bottom-Up monadiques
. . . . . . . .
139
81
Code Pseudo-Haskell. 81 : Foncteur enrichi de Kleisli et conversions
. . . . . . . . . .
141
82
Code Pseudo-Haskell. 82 : Déterminisation d’un automate (généralisé) de mots . . . .
142
83
Code Pseudo-Haskell. 83 : Déterminisation d’un automate (généralisé) d’arbres . . . .
143
84
Code Pseudo-Haskell. 84 : Opérateurs des expressions de mots
. . . . . . . . . . . . .
145
85
Code Pseudo-Haskell. 85 : Opérateurs customisés
. . . . . . . . . . . . . . . . . . . . .
146
86
Code Pseudo-Haskell. 86 : Expressions de mots . . . . . . . . . . . . . . . . . . . . . . .
146
87
Code Pseudo-Haskell. 87 : Monades et semimodules . . . . . . . . . . . . . . . . . . . .
147
88
Code Pseudo-Haskell. 88 : Concaténation de deux automates de Kleisli . . . . . . . . .
148
89
Code Pseudo-Haskell. 89 : Étoile d’un automate
. . . . . . . . . . . . . . . . . . . . . .
149
90
Code Pseudo-Haskell. 90 : Les foncteurs EndoSum et EndoProd . . . . . . . . . . . . . .
150
91
Code Pseudo-Haskell. 91 : Le foncteur StateType
. . . . . . . . . . . . . . . . . . . . .
151
92
Code Pseudo-Haskell. 92 : La construction inductive associée au mot vide . . . . . . .
151
93
Code Pseudo-Haskell. 93 : La construction inductive associée au vide . . . . . . . . . .
151
94
Code Pseudo-Haskell. 94 : La construction inductive associée à un symbole
. . . . . .
151
95
Code Pseudo-Haskell. 95 : La construction inductive associée à la concaténation . . . .
152
96
Code Pseudo-Haskell. 96 : La construction inductive associée à l’étoile . . . . . . . . .
152
97
Code Pseudo-Haskell. 97 : La construction inductive associée à la somme
. . . . . . .
152
98
Code Pseudo-Haskell. 98 : La construction inductive associée à la multiplication par
un scalaire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
152
99
Code Pseudo-Haskell. 99 : La construction inductive associée à l’intersection . . . . . .
152
100 Code Pseudo-Haskell. 100 : Le calcul inductif des fonctions de position . . . . . . . . .
154
101 Code Pseudo-Haskell. 101 : Le calcul inductif des fonctions de position : le mot vide .
154

xiii
102 Code Pseudo-Haskell. 102 : Le calcul inductif des fonctions de position : le vide . . . .
154
103 Code Pseudo-Haskell. 103 : Le calcul inductif des fonctions de position : les symboles
154
104 Code Pseudo-Haskell. 104 : Le calcul inductif des fonctions de position : la somme . .
155
105 Code Pseudo-Haskell. 105 : Le calcul inductif des fonctions de position : l’étoile . . . .
155
106 Code Pseudo-Haskell. 106 : Le calcul inductif des fonctions de position : la concaténation155
107 Code Pseudo-Haskell. 107 : Le calcul inductif des fonctions de position : les multipli-
cations par des scalaires
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
108 Code Pseudo-Haskell. 108 : La linéarisation à l’aide de la monade State . . . . . . . .
156
109 Code Pseudo-Haskell. 109 : La construction de l’automate des positions
. . . . . . . .
157
110 Code Pseudo-Haskell. 110 : La dérivation monadique . . . . . . . . . . . . . . . . . . .
159
111 Code Pseudo-Haskell. 111 : La dérivation monadique : opérateurs étendus . . . . . . .
160
112 Code Pseudo-Haskell. 112 : La dérivation monadique : opérateurs étendus . . . . . . .
161
113 Code Pseudo-Haskell. 113 : La dérivation monadique : extension aux mots . . . . . . .
161
114 Code Pseudo-Haskell. 114 : La dérivation monadique : construction de l’automate
. .
161
115 Code Pseudo-Haskell. 115 : Les expressions enrichies . . . . . . . . . . . . . . . . . . .
163
116 Code Pseudo-Haskell. 116 : Les expressions de mots et d’arbres depuis les expressions
enrichies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
163
117 Code Pseudo-Haskell. 117 : Les calculs de nullabilité pour les expressions enrichies . .
164
118 Code Pseudo-Haskell. 118 : Poids des symboles de ﬁn de parcours d’une expression
enrichie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
164
119 Code Pseudo-Haskell. 119 : Linéarisation d’une expression enrichie . . . . . . . . . . .
165
120 Code Pseudo-Haskell. 120 : Signatures des fonctions predec . . . . . . . . . . . . . . .
167
121 Code Pseudo-Haskell. 121 : Fonctions predec : cas triviaux . . . . . . . . . . . . . . . .
167
122 Code Pseudo-Haskell. 122 : Fonctions predec : itération et substitution . . . . . . . . .
167
123 Code Pseudo-Haskell. 123 : Fonctions predec : produits tensoriels . . . . . . . . . . . .
168
124 Code Pseudo-Haskell. 124 : L’automate enrichi des positions : cas des arbres . . . . . .
169
125 Code Pseudo-Haskell. 125 : L’automate enrichi des positions : cas des mots
. . . . . .
169
126 Code Pseudo-Haskell. 126 : L’automate enrichi des positions : cas alternatif des mots .
169
127 Code Pseudo-Haskell. 127 : La dérivation d’expressions enrichies : signatures . . . . .
170
128 Code Pseudo-Haskell. 128 : La dérivation d’expressions enrichies : implantation
. . .
170
129 Code Pseudo-Haskell. 129 : La dérivation d’expressions enrichies : construction d’au-
tomates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
171
130 Code Pseudo-Haskell. 130 : La construction inductive : Interprétation des morphismes
en fonctions de Kleisli
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
172
131 Code Pseudo-Haskell. 131 : La construction inductive : l’automate vide . . . . . . . . .
173
132 Code Pseudo-Haskell. 132 : La construction inductive : l’automate associé à une variable173
133 Code Pseudo-Haskell. 133 : La construction inductive : l’itération positive . . . . . . .
174
134 Code Pseudo-Haskell. 134 : La construction inductive : le dédoublement et le regrou-
pement pour la somme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
175
135 Code Pseudo-Haskell. 135 : La construction inductive : le cas de la somme . . . . . . .
176
136 Code Pseudo-Haskell. 136 : La construction inductive : le cas de la substitution . . . .
177
137 Code Pseudo-Haskell. 137 : La construction inductive : extraction d’une transition
d’un produit tensoriel
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
178
138 Code Pseudo-Haskell. 138 : La construction inductive : le cas du produit tensoriel . . .
179
139 Code Pseudo-Haskell. 139 : La construction inductive : le type des états . . . . . . . . .
180
140 Code Pseudo-Haskell. 140 : La construction inductive . . . . . . . . . . . . . . . . . . .
180
141 Code Pseudo-Haskell. 141 : Le constructeur Writer . . . . . . . . . . . . . . . . . . . . .
193
142 Code Pseudo-Haskell. 142 : Monade Writer . . . . . . . . . . . . . . . . . . . . . . . . .
193
143 Code Pseudo-Haskell. 143 : Exemple d’automate séquentiel
. . . . . . . . . . . . . . .
194
144 Code Pseudo-Haskell. 144 : Produit parallèle d’automates
. . . . . . . . . . . . . . . .
196
145 Code Pseudo-Haskell. 145 : Combinaison Booléenne d’automates . . . . . . . . . . . .
197
146 Code Pseudo-Haskell. 146 : KDFAs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
198
147 Code Pseudo-Haskell. 147 : Exemple DFA complets . . . . . . . . . . . . . . . . . . . .
198


1
Introduction
Personne n’ignore qu’il y a deux entrées par où les opinions sont reçues dans l’âme,
qui sont ses deux principales puissances, l’entendement et la volonté.
Blaise Pascal
Les expressions rationnelles sont des objets mathématiques inductifs permettant de représenter d’une
façon concise les langages rationnels, de mots comme d’arbres. Depuis le début de mes recherches,
j’ai travaillé notamment sur de multiples modélisations d’opérations sur les langages par la déﬁni-
tion d’opérateurs permettant de les représenter d’un point de vue syntaxique.
Le sujet de ma thèse de doctorat [64], les opérateurs de multi-tildes-barres [21, 20], m’a permis
d’étendre des constructions d’automates connues (comme la dérivation d’expressions ou la méthode
des positions) à de nouveaux opérateurs en conservant les bases de ces méthodes.
J’ai ensuite participé à ce travail d’extension à de nombreuses reprises par la suite, comme :
— pour des expressions rationnelles permettant de représenter des langages approchés [25],
c’est-à-dire des langages obtenus à partir des mots à une certaine distance (Hamming ou Le-
venshtein par exemple) d’un mot d’un langage initial;
— pour des expressions linéaires permettant de représenter les langages obtenus par hairpin com-
pletion [30], une opération basée sur un mécanisme biochimique de l’ADN;
— pour des expressions à contraintes [26], paramétrées par des prédicats de logique d’ordre 0
(c’est-à-dire des prédicats avec des variables mais sans quantiﬁcateurs).
Les processus mis en œuvre lors de ces travaux, c’est-à-dire généralement déﬁnition d’un nouvel
opérateur, de sa sémantique, puis d’une façon de résoudre le problème d’appartenance d’un mot,
ont mis en lumières de nombreux rapprochements possibles entre ces diverses méthodes.
J’ai participé également à des extensions de ces méthodes sur d’autres structures d’entrées, mettant
une nouvelle fois en lumières les liens entre toutes ces méthodes :
— l’extension des méthodes classiques de construction d’automates aux automates d’arbres de-
puis des expressions d’arbres [69, 7, 72] est une application presque directe des méthodes dé-
ﬁnies sur les mots (déjà remarquée pour des algorithmes classiques comme la déterminisation
par construction de la partie accessible de l’automate des parties [33]);
— la déﬁnition d’une méthode de quotient de langage d’arbres non-nullaires [28] et de dérivation
d’expressions d’arbres basées sur la méthode de Brzozowski [6] est quant à elle une méthode
semblant, à première vue, assez différente de celle des expressions de mots.
En parallèle, j’ai travaillé sur les liens entre opérades et opérateurs de multi-tildes-barres [41, 58] et
également sur la représentation multi-linéaire des PROs libres [55]. Les opérades sont des structures
algébriques permettant de représenter, par exemple, la composition des arbres. Les PROs sont des
catégories monoïdales strictes dont les objets sont les entiers et le produit tensoriel la somme.
À l’aide de la manipulation de ces outils, il m’a paru possible d’essayer de construire des expres-
sions utilisant des notions de théorie des catégories aﬁn de généraliser les expressions d’arbres et
de mots (voire plus) ainsi que différentes méthodes de construction, le préalable étant alors de dé-
ﬁnir une structure compatible d’automates pouvant elle-aussi supporter cette généricité, ou plutôt
polymorphisme. Cette structure devrait en effet pouvoir être assez générique pour uniﬁer automates
déterministes et non-déterministes (pour pouvoir par exemple uniﬁer les méthodes de dérivation et
dérivation partielle), voire d’autres types d’automates connus (alternants, à multiplicités, etc.).
Ce document est ainsi la présentation de la démarche de formalisation de ces notions, qui est un
projet de recherche et un travail original réalisé pour ce document, se découpant en deux parties et
d’une partie préliminaire.

2
D’une façon classique, les préliminaires rappellent les déﬁnitions générales des structures d’auto-
mates et des notions de base sur des structures algébriques. Il s’agit d’un premier pas vers la généra-
lisation catégorique par l’exhibition de parallèles entre différents types d’automates.
La Partie I est un résumé de certains travaux d’extension des méthodes de constructions d’automates
d’arbres auxquels j’ai pu participer; cette partie a pour but de mettre en lumières les différents points
communs entre les constructions d’automates de mots et d’arbres.
Nous aborderons dans cette partie les constructions d’automates d’arbres Top-Down (Chapitre 1)
puis les constructions Bottom-Up (Chapitre 2).
La Partie II est une description formelle d’une méthode de représentation d’expressions généralisées
au niveau des catégories monoïdales. Les notions manipulées tout au long de cette partie sont de
plusieurs ordres. De nombreuses notions de théories des catégories seront présentées en utilisant
des diagrammes commutatifs. Au lieu de rappeler les nombreuses preuves classiques existant au
niveau des automates de mots et d’arbres et de les ré-écrire au niveau des automates catégoriques,
une autre approche sera choisie : aﬁn de conserver une approche pratique, toutes les notions de la
seconde partie seront implantées en Haskell, et le code servira de base à la compréhension et aux
exemples.
Cette seconde partie se découpe de la façon suivante. Dans un premier temps (Chapitre 5), une struc-
ture d’automate de mots sur une catégorie sera implantée d’une façon à uniﬁer différents types d’au-
tomates (déterministes, non-déterministes, etc.), suivant la déﬁnition de Colcombet et Petrisan [32].
Ce chapitre permettra de se familiariser avec les notions de théorie des catégories de base (catégo-
ries, foncteurs, monades, etc.) et leurs liens avec la programmation fonctionnelle, qui seront à la base
de la section suivante. Les différents types d’automates seront décrits comme des cas particuliers de
la construction uniﬁée, et illustrés par des exemples également manipulables dans un interpréteur
Haskell.
Dans un deuxième temps (Chapitre 6), le modèle précédent sera alors étendu en utilisant des caté-
gories enrichies, permettant d’inclure des entrées plus structurées. Comme précédemment, les struc-
tures existantes seront déﬁnies comme des cas particuliers et illustrés par des exemples exécutables.
La dernière partie (Chapitre 7) sera alors une ébauche d’implantation d’expression, ouvrant la voie
vers des perspectives de recherche vers lesquelles je souhaiterais m’orienter pour la suite de ma
carrière et pour lesquelles je demande à être habilité.

3
Préliminaires
Que l’on me donne six heures pour couper un arbre,
j’en passerai quatre à préparer ma hache.
Abraham Lincoln (apocryphe)
Dans cette section, nous rappelons des déﬁnitions mathématiques classiques ainsi que différentes
notations utilisées tout au long de ce document. Certaines constructions rappelées peuvent sembler
alambiquées; mais les abstractions proposées prendront tout leur sens une fois les diverses exten-
sions possibles abordées. Cette section a donc pour but de servir de point de départ aux différentes
généralisations mises en œuvres tout au long de ce document, d’où la concision et le style condensé
de cette partie.
Nous commencerons par rappeler des notations générales, puis présenterons les différentes déﬁni-
tions d’automates que nous manipulerons tout au long du document. La présentation essaiera de
mettre en avant les différents points communs entre ces différentes structures, aﬁn de préparer la
réﬂexion pour la seconde partie de ce document. Cette section rappellera également les différentes
structures d’expressions rationnelles simples 1 sur lesquelles s’appuieront les différentes construc-
tions rappelées dans la première partie de ce document : la proximité des constructions entre mots et
arbres servira de point d’appui, encore une fois, à la réﬂexion de leur uniﬁcation.
Notations générales
Ainsi, commençons par rappeler des déﬁnitions d’ordre général. Dans la suite, on note pour tous
trois ensembles P, Q, et R :
— P →Q l’ensemble des fonctions (totales) de P vers Q;
— P × Q l’ensemble des couples (p, q) avec p dans P et q dans Q;
— P + Q l’ensemble somme isomorphe à P × {0} ∪Q × {1}, égal à P ∪Q si P et Q sont disjoints;
— ◦la composition de fonctions, élément de
(Q →R) × (P →Q) →P →R,
déﬁnie par
( f ◦g)(x) = f(g(x));
— Id la fonction identité, élément de P →P, déﬁnie par
Id(x) = x;
— ⊥l’élément indéﬁni permettant de déﬁnir toute fonction partielle de P vers Q par une fonction
totale de P →Q + {⊥}.
Si ∼est une relation d’équivalence sur P, on notera P∼l’ensemble de ses classes d’équivalence et
[p]∼la classe d’équivalence d’un élément p de P, voire [p] s’il n’y a pas d’ambiguïté.
Les monoïdes, semi-anneaux et semimodules
Dans la seconde partie de ce document, nous manipulerons des notions de théorie des catégories 2
permettant d’abstraire et de généraliser des réﬂexions sur des structures algébriques particulières,
notamment en uniﬁant les réﬂexions sur les structures algébriques associées respectivement aux
1. des structures plus complexes apparaîtront naturellement dans la seconde partie de ce document.
2. monoïde objet de catégorie monoïdale

4
mots et aux arbres. Ainsi, commençons par rappeler les structures algébriques classiquement liées
aux automates de mots.
Un monoïde M est un triplet (M, ·, ε) avec M un ensemble, · une loi de composition interne à M asso-
ciative et unitaire pour l’élément ε de M. Un monoïde est dit commutatif si sa loi de composition l’est
également.
Un morphisme d’un monoïde (M, ·, ε) en un monoïde (M′, ·′, ε′) est une fonction φ de M →M′ satis-
faisant
φ(ε) = ε′,
φ(m1 · m2) = φ(m1) ·′ φ(m2).
Le monoïde libre engendré par un ensemble S est le triplet (S∗, ·, ε) avec :
— S∗l’ensemble des mots écrits sur l’ensemble S,
— · la concaténation des mots,
— ε le mot vide.
Pour ne pas alourdir l’écriture, nous assimilerons dans la suite les symboles de S aux mots de lon-
gueur 1 de S∗lorsqu’il n’y aura pas d’ambiguïté.
Un semianneau est un quintuplet (K, +, ×, 1, 0) tel que (K, +, 0) est un monoïde commutatif, (K, ×, 1)
est un monoïde et × se distribue sur +. Dans la littérature, en fonction des références, l’élément 0
peut aussi être considéré comme un absorbant pour la multiplication.
Un semimodule sur un semianneau (K, +, ×, 1, 0) est un couple (M, :) tel que M = (M, ±, 0) est un
monoïde commutatif et : est une fonction de K × M →M telle que :
— k : (m1 ± m2) = (k : m1) ± (k : m2),
— (k × k′) : m = k : (k′ : m),
— 1 : m = m,
— (k + k′) : m = (k : m) ± (k′ : m).
En fonction du contexte, un axiome supplémentaire peut être inséré :
— 0 : m = k : 0 = 0.
Un morphisme d’un semimodule (M, :) en un semimodule (M′, :′) est un morphisme φ du monoïde
M en M′ satisfaisant
φ(k : m) = k :′ φ(m).
Le semimodule libre sur un semianneau K = (K, +, ×, 1, 0) engendré par un ensemble S est la structure
(K : S, :) déﬁnie comme suit :
— K : S = (K : S, ±, 0) est le monoïde commutatif déﬁni par
— K : S l’ensemble des fonctions de S →K telles que seul un nombre ﬁni d’éléments de S ont
une image non-nulle,
— ( f ± f ′)(x) = f(x) + f ′(x),
— 0(x) = 0.
— (k : f)(x) = k × ( f(x)).
De façons équivalentes, K : S peut être vu comme une somme (ﬁnie, formelle) d’éléments de K × S,
ou comme un sous-ensemble ﬁni de K × S.
Les automates de mots
Intéressons-nous maintenant à la première structure d’automates que nous allons aborder dans ce
document, les automates de mots. Dans cette section, nous verrons comment rapprocher dans leurs
mécanismes d’utilisation les automates déterministes, non-déterministes et à multiplicités. Dans la
seconde partie de ce document, nous aborderons également les automates alternants (et leur géné-
ralisation) ainsi que les automates à pile. Toutes ces structures seront factorisables en une unique
structure polymorphe; pour cela, commençons par mettre en lumière les similitudes de fonctionne-
ment, et plus particulièrement au sein de leurs fonctions de transition.
Un automate non-déterministe est un quintuplet A = (Σ, Q, I, F, δ) avec
— Σ un ensemble, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— I ⊂Q l’ensemble des états initiaux de l’automate,
— F ⊂Q l’ensemble des états ﬁnaux de l’automate,

5
— δ la fonction de transition de l’automate, élément de Q × Σ →2Q.
La fonction δ pourra être assimilée naturellement à l’ensemble de triplets déﬁni par (p, a, q) ∈δ ⇔
q ∈δ(p, a). Cette fonction peut aussi être étendue comme la fonction δ′ de 2Q × Σ∗→2Q par récur-
rence sur les mots de la façon suivante :
δ′(Q′, ε) = Q′,
δ′(Q′, a · w) = δ′(δ′′(Q′, a), w′),
où δ′′ est la fonction de 2Q × Σ →2Q déﬁnie par
δ(Q′, a) =
[
q′∈Q′
δ(q′, a).
Dans la suite, nous assimilerons les fonctions δ, δ′ et δ′′.
Le langage reconnu par un automate A = (Σ, _, I, F, δ) est l’ensemble des mots envoyant un état initial
sur un état ﬁnal, plus formellement déﬁni comme
L(A) = {w ∈Σ∗| δ(I, w) ∩F ̸= ∅}.
Un automate déterministe est un quintuplet A = (Σ, Q, i, F, δ) avec
— Σ un ensemble, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— i ∈Q + {⊥} l’état initial de l’automate,
— F ⊂Q l’ensemble des états ﬁnaux de l’automate,
— δ la fonction de transition de l’automate, élément de Q × Σ →Q + {⊥}.
La fonction δ peut être assimilée naturellement à une fonction de (Q + {⊥}) × Σ∗→Q + {⊥} par
récurrence sur la longueur des mots comme suit :
δ′(p, ε) = p,
δ′(p, a · w) = δ′(δ′′(p, a), w′),
où δ′′ est la fonction de (Q + {⊥}) × Σ →Q + {⊥} déﬁnie par
δ′′(p, a) =
(
⊥
si p = ⊥,
δ(p, a)
sinon.
Dans la suite, comme précédemment, nous assimilerons les fonctions δ, δ′ et δ′′.
Remarque 1: Extension des fonctions de transition
L’extension de la fonction δ, que ce soit dans le cas des automates déterministes comme non-
déterministes, suit le même processus.
La fonction δ′′ peut être vue comme une promotion de la fonction δ de Q × Σ →F(Q) en
une fonction de signature F(Q) × Σ →F(Q) où F est une transformation a de l’ensemble Q et
des fonctions associées : le passage à l’ensemble des parties dans le cas des automates non-
déterministes, l’adjonction d’un élément dans le cas des automates déterministes.
Ensuite, la fonction δ′ peut être vue comme la promotion de la fonction δ′′ de F(Q) × Σ →
F(Q) en une fonction de signature F(Q) × Σ∗→F(Q); remarquons qu’en cas d’application
partielle d’un symbole, δ′′
a est un élément du monoïde (F(Q) →F(Q), ◦, Id). D’une façon
équivalente b, δ′ promeut c δ′′ de fonction de Σ →(F(Q) →F(Q)) en morphisme du monoïde
libre (Σ∗, ·, ε) vers (F(Q) →F(Q), ◦, Id).
Cette extension, que nous retrouverons dans le cas des arbres, sera à la base des constructions
uniﬁées et de la déﬁnition de langage dans la seconde partie de ce document.
a. spoiler alert : c’est un foncteur, et même une monade.
b. à une transformation naturelle près pour être précis.
c. spoiler alert : il s’agit adjonction fonctorielle
Le langage reconnu par un automate déterministe A = (Σ, _, i, F, δ) est l’ensemble
L(A) = {w ∈Σ∗| δ(i, w) ∈F}.

6
Un automate non-déterministe peut être transformé en un automate déterministe en construisant la
partie accessible de l’automate des parties [73]. De plus, nous assimilerons également les automates
déterministes et les automates non-déterministes dont l’ensemble des états initiaux I est vide ou un
singleton, et tel que pour tout mot w, |δ(I, w)| ≤1. Ainsi, ces deux structures admettent des pouvoirs
de représentation identiques.
Si le processus d’extension des fonctions de transition est généralisable (Remarque 1), nous verrons
que c’est également le cas de la déﬁnition des langages, par l’intermédiaire de la notion de poids d’un
mot (poids booléen reﬂétant l’appartenance d’un mot au langage reconnu dans le cas présent). Ce
sera également le cas de la structure générale des automates, en considérant que le comportement
d’un automate (quelque soit son type) est d’envoyer, par l’action d’une entrée, une conﬁguration
initiale sur une conﬁguration qui sera à terme évaluée pour l’obtention d’un poids. Nous verrons
que cette description est valable dans le cas des automates, de mots ou d’arbres, déterministes, non
déterministes, à multiplicités, alternants, et même à pile. Dernière illustration avec la fonction de
transition des automates à multiplicités, déﬁnis comme suit.
Un automate à multiplicités sur un semianneau (K, +, ×, 1, 0) est un quintuplet A = (Σ, Q, I, F, δ) avec
— Σ un ensemble, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— I ∈K : Q la conﬁguration initiale de l’automate,
— F ∈K : Q l’ensemble des états ﬁnaux de l’automate,
— δ la fonction de transition de l’automate, élément de Q × Σ →K : Q.
Comme précédemment, la fonction δ peut être étendue comme une fonction de (K : Q) × Σ∗→(K :
Q) par récurrence sur la longueur des mots comme suit :
δ′( f, ε) = p,
δ′( f, a · w) = δ′(δ′′( f, a), w′),
où δ′′ est la fonction de (K : Q) × Σ →(K : Q) déﬁnie par
δ′′({(k1, q1), . . . , (kn, qn)}, a) = q1 : δ(q1, a) ± · · · ± kn : δ(qn, a).
Dans la suite, nous assimilerons les fonctions δ, δ′ et δ′′.
Le poids d’un mot w dans un automate à multiplicités A = (Σ, _, I, F, δ) sur un semianneau (K, +, ×, 1, 0)
est le scalaire
weightA(w) = k1 × F(q1) + · · · + kn × F(qn)
où
δ(I, w) = {(k1, q1), . . . , (kn, qn)}.
Un automate non-déterministe peut être vu, d’une façon équivalente, comme un automate à multi-
plicité sur le semianneau booléen, et réciproquement.
Les expressions rationnelles
Les expressions rationnelles sont une façon compacte de représenter un ensemble de mots. Dans
cette section, nous présenterons uniquement des expressions rationnelles simples et sans multipli-
cités; cependant, nous manipulerons d’autres types d’expressions dans la seconde partie de ce do-
cument. Nous montrerons ensuite comment transformer une expression rationnelle en un automate
équivalent dans la première partie de ce document en présentant différentes méthodes de construc-
tion dans le cas des expressions d’arbres, généralisations des expressions de mots, dont la proximité
nous permettra de raisonner pour uniﬁer ces deux types d’expressions.
Une expression rationnelle E sur un alphabet Σ est déﬁnie inductivement comme suit :
E = a,
E = ∅,
E = ε,
E = (F + G),
E = (F · G),
E = (F∗),
avec a un symbole de Σ, et F et G deux expressions rationnelles sur Σ. Les parenthèses pourront être
omises en considérant la concaténation prioritaire sur la somme, l’étoile comme l’opération la plus
prioritaire et les opérations binaires associatives à gauche.

7
Le langage dénoté par une expression rationnelle E est l’ensemble L(E) déﬁni inductivement comme suit :
L(a) = {a},
L(∅) = ∅,
L(ε) = {ε},
L(F + G) = L(F) ∪L(G),
L(F · G) = L(F) · L(G),
L(F∗) = (L(F))∗,
avec a un symbole de Σ, F et G deux expressions rationnelles sur Σ, et ∗l’opération déﬁnie pour tout
sous-ensemble L de Σ∗par
L∗=
[
n≥0
Ln,
avec Ln =
(
{ε}
si n = 0,
L · Ln−1
sinon.
Tout langage dénoté par une expression rationnelle est appelé langage rationnel.
Le lien entre expressions rationnelles et automates, c’est-à-dire celui entre langages rationnels et re-
connaissables, s’énonce via le théorème de Kleene [50] : tout langage est reconnaissable par un automate
si et seulement s’il est dénoté par une expression rationnelle. En d’autres termes, les langages ration-
nels sont exactement les langages reconnaissables. Une preuve constructive de ce théorème peut être
faite en considérant des algorithmes de conversion préservant le langage.
Un automate peut être converti en une expression rationnelle équivalente par des méthodes telles
que l’élimination d’états [17], la construction inductive [63], ou la résolution de systèmes en utilisant
le lemme d’Arden [4].
Concernant la transformation inverse, nous présenterons diverses méthodes la réalisant dans la suite
de ce document en nous intéressant aux langages d’arbres, généralisations des automates de mots,
comme présenté dans les sous-sections suivantes.
Les arbres
Les arbres sont une extension plus structurée de la notion de mots; en effet, chaque symbole n’est
plus potentiellement suivi par un mot, mais par une liste d’arbres, dont la longueur est ﬁxé par la
racine (son arité). Nous nous efforcerons, dans la suite de ce document, à illustrer les mécanismes
communs entre les structures de mots et d’arbres pour ﬁnalement proposer des reconnaisseurs fac-
torisés. Pour cela, commençons donc par introduire des déﬁnitions préliminaires.
Un ensemble S est gradué s’il existe une famille (Sk)k∈N d’ensembles disjoints telle que S = S
k∈N Sk.
Une fonction graduée entre deux ensembles gradués S et S est une fonction de S dans S qui envoie,
pour tout entier k, Sk dans Sk.
Un arbre sur un alphabet gradué Σ est soit l’arbre vide ε d’arité 1, soit un couple constitué d’un
symbole f de Σ d’arité k (sa racine) et d’un k-uplet d’arbres (t1, . . . , tk) (ses ﬁls) sur Σ. L’arité d’un
arbre t, notée arit´e(t) est de 1 si t = ε, ∑1≤i≤k arit´e(ti) si t = _(t1, . . . , tk). Un sous-arbre d’un arbre t
est soit t, soit un sous-arbre d’un de ses ﬁls. Nous noterons s ≼t la relation “s est un sous-arbre de
t”. La racine d’un arbre non-vide t est notée racine(t), son ke ﬁls (s’il existe) ke-ﬁls(t), l’ensemble de
ses feuilles (c’est à dire l’ensemble des symboles d’arité 0 présents) feuilles(t).
Les prédécesseurs d’un symbole f dans un arbre t sont les symboles qui apparaissent directement “au-
dessus de lui”, c’est à dire les racines des sous-arbres de t dont un des ﬁls a pour racine f. On note
parent(t, f), pour un arbre t et un symbole f les couples
parent(t, f) = {(g, i) ∈Σl × N | ∃g(s1, . . . , sl) ≼t, racine(si) = f}.
Ces couples relient les prédécesseurs de f et les indices des sous-arbres de t dont f est la racine.
Pour un arbre t = g(t1, . . . , tk) et un symbole f, et selon la déﬁnition de la structure d’un arbre, un
prédécesseur de f dans t est un prédécesseur de f dans un sous-arbre ti de t, ou g si f est la racine
d’un sous-arbre ti de t. Ainsi :
parent(t, f) =
[
i≤n
parent(ti, f) ∪{(g, i) | f ∈racine(ti)}.

8
L’ensemble des arbres d’arité 0 sur l’alphabet gradué Σ, noté Σ∗
0, sera noté Σ∗lorsqu’il n’y aura pas
d’ambiguïté.
Les opérades
Si le monoïde est la structure algébrique de prédilection pour les mots, l’opérade est celle pour les
arbres.
Une opérade [56, 62] est une structure algébrique qui simule la composition des fonctions. Plus for-
mellement, une opérade O = (O, (◦j)j∈N, Id) est constituée d’un ensemble gradué O et d’un élément
remarquable Id dans O1, munis des opérations de composition ◦j déﬁnies pour tout triplet d’entiers
(i, j, k) 3 avec 0 < j ≤k dans Ok × Oi →Ok+i−1 satisfaisant les trois conditions suivantes : pour tous
trois éléments p1 dans Om, p2 dans On et p3 dans Op :
1. pour tout entier 0 < j ≤m :
Id ◦1 p1 = p1 ◦j Id = p1,
2. (associativité verticale, voir Figure 1) pour tous deux entiers 0 < j ≤m et 0 < j′ ≤n :
p1 ◦j (p2 ◦j′ p3) = (p1 ◦j p2) ◦j+j′−1 p3,
3. (associativité horizontale, voir Figure 2) pour tous deux entiers 0 < j′ ≤j ≤m :
(p1 ◦j p2) ◦j′ p3 = (p1 ◦j′ p3) ◦j+p−1 p2.
p1
p3
p2
j
j′
p2 ◦j′ p3
=
p1
p3
p2
j
j′
p1 ◦j p2
j + j′ −1
FIGURE 1 – Associativité verticale.
3. tout couple (i, k) déﬁnit une fonction ◦j sans ambiguïté sur le domaine ni sur le codomaine.

9
p1
p3
p2
j′
j m
n
p1 ◦j p2
j′
m + n −1
=
p1
p3
p2
j′
j
p
p1 ◦j′ p3
j + p −1
FIGURE 2 – Associativité horizontale.
En combinant ces compositions ◦j, il est possible de déﬁnir une composition ◦envoyant Ok × Oi1 ×
· · · × Oik dans Oi1+···+ik : pour tout élément (p, q1, . . . , qk) de Ok × Ok,
p ◦(q1, . . . , qk) = (· · · ((p ◦k qk) ◦k−1 qk−1 · · · ) · · · ) ◦1 q1.
Inversement, la composition ◦permet de déﬁnir les compositions ◦j en complétant la composition
par l’élément neutre de l’opérade : pour tout élément (p, q) de Ok × Oi, pour tout entier 0 < j ≤k :
p ◦j q = p ◦(Id, . . . , Id
|
{z
}
j−1 fois
, q, Id, . . . , Id
|
{z
}
k−j fois
).
Dans la suite de ce document, nous nous intéresserons à plusieurs opérades remarquables. Par
exemple, l’ensemble des fonctions envoyant une puissance cartésienne d’un ensemble dans lui-
même, ou dualement cet ensemble sur une de ses puissances cartésiennes, où la puissance 0 d’un
ensemble est l’ensemble 1 ne possédant qu’un seul élément noté (), sont tous les deux des ensembles
que l’on peut munir d’une structure d’opérade. Notons d’ailleurs qu’un élément x d’un ensemble S
est naturellement équivalent à une fonction x() = x de 1 vers S.
Un morphisme φ d’une opérade O = (O, ◦, Id) en une opérade O = (O, ◦, Id) est une fonction graduée
de O dans O satisfaisant pour tout couple d’arbres (p, q) de Om × O et pour tout entier 0 < j ≤m :
φ(p ◦j q) = φ(p) ◦j φ(q),
φ(Id) = Id.
L’opérade libre générée par un ensemble gradué S est l’opérade (S∗, ◦j, ε) avec :
— S∗l’ensemble gradué des arbres étiquetés par des éléments de S,
— ◦j la composition des arbres,
— ε l’arbre vide.
Pour ne pas alourdir l’écriture, nous assimilerons dans la suite les symboles de S aux arbres de
hauteur 1 de S∗lorsqu’il n’y aura pas d’ambiguïté.
Les automates d’arbres ascendants
Comme pour les mots, il est possible de décrire des reconnaisseurs pour les arbres. Cependant,
contrairement aux mots, les arbres ne sont pas des structures symétriques : si un mot peut se lire d’une
façon similaire de gauche à droite ou de droite à gauche, un arbre n’est pas interprété de la même
façon s’il est lu de bas en haut ou de haut en bas. Cette dissymétrie inhérente se traduit par deux
types de reconnaisseurs dont le fonctionnement diffère 4 : les automates ascendants et les automates
descendants, interprétant les arbres de bas en haut ou de haut en bas.
4. mais que nous pourrons uniformiser par la suite

10
Un automate d’arbres ascendant non-déterministe (ascendant ou Bottom-Up, ici sans variables 5) est un
quadruplet A = (Σ, Q, F, δ) avec :
— Σ un ensemble gradué, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— F ⊂Q l’ensemble des états ﬁnaux de l’automate,
— δ la fonction de transition de l’automate, appartenant à Qn × Σn →2Q.
Comme dans le cas des mots, la fonction δ peut être étendue en une fonction δ′ de signature (2Q)n →
Σ∗
n →2Q d’une façon relativement proche de l’extension de la fonction de transition des automates
de mots :
δ′(Q′, ε) = Q′,
δ′((Q1, . . . , Qn), t ◦j f) = δ′((Q1, . . . , Qj−1, δ′′((Qj, . . . , Qj+arit´e( f )), f), . . . , Qn), t)
où δ′′ est la fonction de (2Q)n × Σn →2Q déﬁnie par
δ′′(Q1, . . . , Qn, f) =
[
(q1,...,qn)∈Q1×···×Qn
δ(q1, . . . , qn, f).
On remarquera que cette extension est équivalente à la suivante, plus classique :
δ′(Q′, ε) = Q′,
δ′((Q1, . . . , Qn), f(t1, . . . , tk)) = δ((δ′((Q1, . . . , Qarit´e(t1)), t1), . . . , δ′((Qn−arit´e(tk)+1, . . . , Qn), tk)), f).
Nous assimilerons naturellement par la suite toutes ces fonctions à la fonction δ et nous les distin-
guerons en fonction de leurs signatures. De même, nous assimilerons la fonction δ à l’ensemble de
triplets déﬁni par
((p1, . . . , pn), f, q) ∈δ ⇔q ∈δ((p1, . . . , pn), f).
Enﬁn, pour un arbre t de Σ∗
0, nous représenterons l’ensemble δ((), t) par δ(t). Ainsi, le langage reconnu
par un automate d’arbres A = (Σ, _, F, δ) est l’ensemble
L(A) = {t ∈Σ∗
0 | δ(t) ∩F ̸= ∅}.
Un automate d’arbres ascendant déterministe est un quadruplet A = (Σ, Q, F, δ) avec :
— Σ un ensemble gradué, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— F ⊂Q l’ensemble des états ﬁnaux de l’automate,
— δ la fonction de transition, élément de Qn × Σn →Q + {⊥}.
Comme dans le cas des automates d’arbres ascendants non-déterministes, la fonction δ peut être éten-
due comme une fonction de (Q + {⊥})n × Σ∗n →(Q + {⊥}), en ne modiﬁant que la formule de la
fonction δ′′, d’une façon similaire à la fonction δ′′ associée aux automates de mots déterministes, ren-
voyant ⊥si une des composantes du n-uplet de départ vaut ⊥. De plus, nous assimilerons naturel-
lement dans la suite de ce document les automates déterministes et les automates non-déterministes
dont la fonction de transition δ vériﬁe pour tout arbre t |δ(t)| ≤1.
Le langage reconnu par un automate déterministe A = (Σ, _, F, δ) est l’ensemble
L(A) = {t ∈Σ∗
0 | δ(t) ∈F}.
Notoirement, un langage est reconnaissable par un automate d’arbres déterministe si et seulement
s’il est reconnaissable par un automate d’arbres (par construction de la partie accessible de l’automate
des parties [33]).
Dans la seconde partie de ce document, l’extension de la fonction de transition sera elle aussi utilisée
dans le cas d’autres types d’automates d’arbres ascendants (déterministes, à multiplicités, sur des
monoïdes multi-opérateurs) et descendants. L’uniﬁcation sera encore une fois basée sur le même
principe : celui de l’envoi d’une conﬁguration initiale sur une conﬁguration évaluée a posteriori. Pour
5. les variables, apparaissant uniquement comme feuilles, seront prises en compte dans la seconde partie de ce document

11
les automates d’arbres ascendants, la conﬁguration initiale sera au départ associée la conﬁguration
constante () 6.
Les morphismes d’automates
Comme pour les structures algébriques présentées précédemment, il est possible de considérer des
fonctions particulières compatibles avec la structure d’automate. Ces morphismes seront utilisés lors
de la présentation de certains algorithmes de transformation d’expression en automate.
Soit φ une fonction graduée entre deux alphabets Σ et Σ′. Cette fonction peut-être étendue en un
morphisme alphabétique (il s’agit alors d’un morphisme d’opérades 7) φ′ de Σ∗vers Σ′∗en posant
φ′( f(t1, . . . , tn)) = φ( f)(φ′(t1), . . . , φ′(tn)).
Par abus, nous assimilerons les fonctions φ et φ′. Par exemple, le morphisme de délinéarisation h en-
voyant un alphabet indicé vers sa version non-indicée est un morphisme alphabétique. Pour un
langage L, on note φ(L) l’ensemble {φ(t) | t ∈L}. L’image par φ d’un automate A = (Σ, Q, QF, δ) est
l’automate φ(A) = (Σ′, Q, QF, δ′) où
δ′ = {(q1, . . . , qn, φ( f), q) | (q1, . . . , qn, f, q) ∈δ}.
Par une induction triviale sur la structure des arbres, on peut montrer que
φ(L(A)) = L(φ(A)).
Un morphisme alphabétique est un cas particulier de morphisme entre deux automates A = (Σ, Q, F, δ)
et B = (Σ′, Q′, F′, δ′), qui est une fonction φ envoyant Σn vers Σ′
n pour tout entier n, Q vers Q′, F vers
F′ et δ vers δ′ telle que
δ′((φ(q1), . . . , φ(qn)), φ( f)) = {φ(q) | q ∈δ((q1, . . . , qn), f)}.
Dans ce cas, on note φ(A) = (φ(Σ), φ(Q), φ(F), φ(δ)).
Deux automates A et B sont dits isomorphes s’il existe deux morphismes φ et φ′ satisfaisant
A = φ′(φ(A)),
B = φ(φ′(B)).
On peut montrer que certains morphismes particuliers préservent le langage d’un automate. Nous
nous intéresserons à deux types de morphismes basés sur des relations d’équivalence, et plus préci-
sément des congruences : leur différence sera, encore une fois, la direction de lecture des transitions.
Soient A = (Σ, Q, F, δ) un automate d’arbre ascendant déterministe et ∼une relation d’équivalence
sur Q + {⊥} telle que pour tous deux éléments équivalents p et p′,
p ∈F ⇔p′ ∈F.
La relation ∼est dite congruence Bottom-Up pour δ si et seulement si pour tous deux états p et p′ de
Q, pour tout symbole f de Σm, pour tout entier n ≤m, pour tout m −1 états q1, . . ., qn−1, qn+1, . . .,
qm de Q,
p ∼p′ ⇒δ(c, f) ∼δ(c′, f),
(1)
où
c = (q1, . . . , qn−1, p, qn+1, . . . , qm),
c′ = (q1, . . . , qn−1, p′, qn+1, . . . , qm),
Deux états Bottom-Up-congruents peuvent être appelés interchangeables [1] et ∼une forward bisimu-
lation [46]. L’automate quotient de A par la congruence ∼est l’automate A∼= (Σ, Q∼, F∼, δ′) avec
δ′(([q1], . . . , [qm]), f) = [δ((q1, . . . , qm), f)].
6. ce ne sera plus le cas lors de la prise en compte des variables, permettant de déﬁnir la conﬁguration initiale depuis une
affectation de conﬁguration aux variables
7. spoiler alert : encore une adjonction fonctorielle.

12
Ce morphisme préserve le langage, c’est-à-dire que L(A) = L(A∼).
Soient A = (Σ, Q, F, δ) un automate d’arbre non-déterministe et ∼une relation d’équivalence sur Q.
La relation ∼est une congruence Top-Down si et seulement si pour tous deux états équivalents p et
p′ de Q, pour toute transition ((q1, . . . , qm), f, p) de δ, il existe ((q′
1, . . . , q′m), f, p′) dans δ satisfaisant
qi ∼q′
i pour 1 ≤i ≤m. Remarquons alors que, pour tous deux états équivalents p et p′ de Q, pour
tout arbre t de Σ∗
0,
p ∈δ(t) ⇔p′ ∈δ(t).
Notons que la réciproque n’est pas vraie. L’automate quotient de A par ∼est l’automate A∼=
(Σ, Q∼, F′, δ′) avec
F′ = {[q] | q ∈F},
δ′(([q1], . . . , [qm]), f) = δ(([q1], . . . , [qm]), f).
Remarquons que L(A) = L(A∼), que si A est déterministe, alors A∼ne l’est pas nécessairement, et
que des états ﬁnaux et non-ﬁnaux peuvent être fusionnés pendant le calcul du quotient.
Les expressions rationnelles d’arbres
Classiquement, les expressions rationnelles d’arbres, comme celles de mots, peuvent être déﬁnies par
induction. Il est également possible de considérer, d’une façon équivalente, une déﬁnition algébrique
depuis les opérades 8.
Ainsi, une expression rationnelle d’arbres sur un alphabet gradué Σ est un arbre d’arité 0 de l’opérade
libre générée par Σ ∪{∅, +} ∪{·a,∗a | a ∈Σ0} où ∅est d’arité 0, + d’arité 2, et où pour tout symbole
a de Σ0, ·a est d’arité 2 et ∗a d’arité 1. Comme dans le cas des expressions rationnelles de mots, ces
expressions seront possiblement parenthésées selon la convention usuelle, à savoir les opérateurs
binaires en notation inﬁxe associatifs à gauche en considérant le parenthésage fonction de l’ordre
considérant la concaténation ·a prioritaire sur la somme +, et l’étoile ∗a comme l’opération la plus
prioritaire.
Pour interpréter inductivement le langage dénoté par une expression rationnelle d’arbres, l’action
des symboles sur les langages doit être explicitée. Ici, pour un symbole f d’arité k et k langages
(L1, . . . , Lk), nous noterons
f(L1, . . . , Lk) = { f(t1, . . . , tk) | (t1, . . . , tk) ∈L1 × · · · × Lk}.
Il faut également ﬁxer une sémantique pour les opérateurs de concaténation et d’étoile. Pour un arbre
t de Σ∗
0, pour deux symboles a et b distincts de Σ0 et un langage L ⊂Σ∗
0, on note t ·a L l’ensemble
déﬁni inductivement par
b ·a L = {b},
a ·a L = L,
f(t1, . . . , tk) ·a L = f(t1 ·a L, . . . , tk ·a L).
Par extension, pour tout langage L′ ⊂Σ∗
0,
L ·a L′ =
[
t∈L
t ·a L′.
L’étoile est alors l’itération inﬁnie de cette opération de substitution. En effet, pour un langage
d’arbres L ⊂Σ∗
0 donné,
L∗a =
[
n∈N
La,n
avec La,n =
(
{a}
si n = 0,
La,n−1 ·a L
sinon.
8. Ce genre de déﬁnition sera utilisée dans la seconde partie de ce document pour déﬁnir, par exemple, des expressions
booléennes.

13
Le langage dénoté par une expression rationnelle d’arbres E sur un alphabet Σ est le sous-langage L(E)
de Σ∗
0 déﬁni inductivement par :
L( f(E1, . . . , En)) = f(L(E1), . . . , L(En)),
L(∅) = ∅,
L(E1 + E2) = L(E1) ∪L(E2),
L(E1 ·a E2) = L(E1) ·a L(E2),
L(E∗a
1 ) = L(E1)∗a
avec f un symbole de Σn, k expressions rationnelles d’arbres E1, . . . , Ek sur Σ et a un symbole de Σ0.
Cette déﬁnition inductive du langage peut être vue, d’une façon équivalente, comme un morphisme
d’opérade, envoyant l’opérade libre des expressions rationnelles sur les fonctions n-aires de Σ∗sur
lui-même : par exemple, serait associée à la somme l’union de langage, ou à un symbole n-aire son
action sur un n-uplet de langages, etc. Nous reviendrons sur cette interprétation dans la seconde
partie de ce document.
Les automates d’arbres compressés
Un des inconvénients de la structure d’automate d’arbres est la profusion de transitions dans le
pire des cas, due au fait que les transitions relient n-uplets d’états à état; cependant, nous verrons
que certaines constructions d’automates d’arbres peuvent tirer proﬁt des structures condensées d’ex-
pressions rationnelles. L’idée de base de la compression est de considérer le produit cartésien d’en-
sembles. Imaginons qu’un automate d’arbres contiennent les 4 transitions binaires ((q1, q1), f, q3),
((q1, q2), f, q3), ((q2, q1), f, q3) et ((q2, q2), f, q3). Sans perdre d’information, ces 4 transitions peuvent
être factorisées en une transition compressée ({q1, q2}, {q1, q2}, f, q3) en utilisant des ensembles d’états
plutôt que des états. Le comportement de cet automate peut être simulé en considérant le produit
cartésien des états d’origine de la transition.
Un automate d’arbres compressé sur un alphabet gradué Σ est un 4-uplet (Σ, Q, QF, δ) où
— Q est un ensemble d’états,
— QF ⊂Q est l’ensemble des états ﬁnaux,
— δ ⊂(2Q)n × Σn × 2Q est l’ensemble des transitions compressées pouvant être vu comme une
fonction de (2Q)k × Σk vers 2Q déﬁnie par
(Q1, . . . , Qk, f, q) ∈δ ⇔q ∈δ(Q1, . . . , Qk, f).
Exemple 1
Considérons l’automate compressé A = (Σ, Q, QF, δ) de la Figure 3. Ses transitions (compressées)
sont
δ = {({1, 2, 5}, {3, 4}, f, 1), ({2, 3, 5}, {4, 6}, f, 2),
({1, 2}, {3}, f, 5), ({6}, g, 4), ({6}, g, 5), (a, 6), (a, 4), (b, 3)}.

14
2
1
5
4
3
6
b
a
a
f
f
g
g
f
FIGURE 3 – L’automate compressé A.
La fonction de transition δ peut être restreinte en une fonction de Qn × Σn vers 2Q pour simuler le
comportement d’un automate (non compressé) en considérant pour un k-uplet (q1, . . . , qk) d’états et
un symbole f de Σk toutes les transitions actives ((Q1, . . . , Qk), f, q), qui sont les transitions où qi est
dans Qi pour i ≤k. Plus formellement, pour tout k états (q1, . . . , qk) de Qk, pour tout symbole f de
Σk,
δ((q1, . . . , qk), f) =
[
(Q1,...,Qk,f ,q)∈δ,
∀i≤k,qi∈Qi
{q}.
(2)
On dira alors qu’un automate compressé est déterministe si pour tout k états (q1, . . . , qk) de Qk, pour
tout symbole f de Σk,
|δ((q1, . . . , qk), f)| ≤1.
L’ensemble de transition δ peut être étendu en une fonction δ de Σ∗
0 vers 2Q en considérant inducti-
vement, pour un arbre f(t1, . . . , tk) les transitions actives ((Q1, . . . , Qk), f, q) une fois l’arbre lu, c’est-
à-dire quand δ(qi) et Qi ont un état commun pour tout i ≤k. Plus formellement, pour tout arbre
t = f(t1, . . . , tk) de Σ∗
0,
δ(t) =
[
(Q1,...,Qk,f ,q)∈δ,
∀i≤k,δ(ti)∩Qi̸=∅
{q}.
Ainsi,
δ( f(t1, . . . , tn)) =
[
c∈δ(t1)×···×δ(tn)
δ(c, f).
(3)
Le langage reconnu par un automate compressé A = (Σ, _, QF, δ) est le sous-ensemble L(A) de Σ∗
déﬁni par
L(A) = {t ∈Σ∗| δ(t) ∩QF ̸= ∅}.
Exemple 2
Considérons l’automate de la Figure 3 et montrons alors que l’arbre t = f( f(b, a), g(a)) appartient à
L(A). Pour cela, calculons δ(t′) pour tout sous-arbre t′ de t. Tout d’abord, par déﬁnition,
δ(a) = {4, 6},
δ(b) = {3}.

15
Puisque la seule transition de δ étiquetée par f contenant 3 dans son premier ensemble d’origine et 4
ou 6 dans son second est la transition ({2, 3, 5}, {4, 6}, f, 2), alors
δ( f(b, a)) = {2}.
Puisque les deux transitions étiquetées par g sont ({6}, g, 4) et ({6}, g, 5),
δ(g(a)) = {4, 5}.
Enﬁn, il y a deux transitions étiquetées par f contenant 2 dans leur première origine et 4 ou 5 dans
leur seconde :
({2, 3, 5},{4, 6}, f, 2),
({1, 2, 5},{3, 4}, f, 1).
Ainsi
δ( f( f(b, a), g(a))) = {1, 2}.
En conclusion, puisque 1 est ﬁnal, t ∈L(A).
Soit φ un morphisme alphabétique entre deux alphabets Σ et Σ′. L’image par φ d’un automate com-
pressé A = (Σ, Q, QF, δ) est l’automate compressé φ(A) = (Σ′, Q, QF, δ′) où
δ′ = {(Q1, . . . , Qn, φ( f), q) | (Q1, . . . , Qn, f, q) ∈δ}.
Par une induction triviale, on peut montrer que
L(φ(A)) = φ(L(A)).
(4)
Les automates d’arbres descendants
Dernière structure d’automates que nous allons considérer dans cette section, les automates descen-
dants, permettant d’interpréter les arbres selon une forme semblant plus naturelle, de la racine aux
feuilles, plus proche de leur déﬁnition inductive.
Un automate d’arbres descendant non-déterministe (descendant ou Top-Down, ici sans variables 9) est un
quadruplet A = (Σ, Q, I, δ) avec :
— Σ un ensemble gradué, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— I ⊂Q l’ensemble des états initiaux de l’automate,
— δ la fonction de transition de l’automate, appartenant à Q × Σn →2Qn.
Comme dans les cas précédents, la fonction δ peut être étendue en une fonction δ′ de signature
2Q × Σn →2Qn d’une façon relativement proche de la précédente :
δ′(Q′, ε) = Q′,
δ′(Q′, f(t1, . . . , tk)) =
[
(q1,...,qn)∈δ′′(Q′,f )
δ′(q1, t1) × · · · × δ′(qn, tn)
où δ′′ est la fonction de 2Q × Σn →2Qn déﬁnie par
δ′′(Q′, f) =
[
q′∈Q′
δ(q′, f).
Un arbre nullaire enverra alors un état dans un ensemble soit vide, soit réduit à un seul élément (en
effet, 2Q0 = 21 = {∅, {()}}).
Nous assimilerons naturellement par la suite toutes ces fonctions à la fonction δ et nous les distin-
guerons en fonction de leurs signatures. De même, nous assimilerons la fonction δ à l’ensemble de
triplets déﬁni par
((p1, . . . , pn), f, q) ∈δ ⇔(p1, . . . , pn) ∈δ(q, f).
9. comme dans le cas des automates ascendants, les variables seront prises en compte dans la seconde partie de ce docu-
ment.

16
Ainsi, le langage reconnu par un automate d’arbres A = (Σ, _, I, δ) est l’ensemble
L(A) = {t ∈Σ∗
0 | δ(I, t) ̸= ∅}.
Un automate d’arbres descendant déterministe est un quadruplet A = (Σ, Q, I, δ) avec :
— Σ un ensemble gradué, l’alphabet de l’automate,
— Q l’ensemble des états de l’automate,
— I ⊂Q l’ensemble des états ﬁnaux de l’automate,
— δ la fonction de transition, élément de Q × Σn →Qn + {⊥}.
Comme dans les cas précédents, la fonction δ peut être étendue en une fonction δ′ de signature
(Q + ⊥) × Σn →Qn + ⊥d’une façon relativement proche de la précédente :
δ′(p, ε) = p,
δ′(p, f(t1, . . . , tk)) =
(
⊥
si δ′′(p, f) = ⊥,
δ′(q1, t1) × · · · × δ′(qn, tn)
si δ′′(p, f) = (q1, . . . , qn),
où δ′′ est la fonction de (Q + ⊥) × Σn →Qn + ⊥déﬁnie par
δ′′(p, f) =
(
⊥
si p = ⊥,
δ(p, f)
sinon.
Un arbre nullaire enverra alors un état soit dans ⊥, soit dans (), unique élément de l’ensemble Q0.
De plus, nous assimilerons naturellement dans la suite de ce document les automates déterministes
et les automates non-déterministes ayant aucun ou un unique état initial et dont la fonction de tran-
sition δ vériﬁe pour tout arbre t |δ(I, t)| ≤1.
Le langage reconnu par un automate déterministe A = (Σ, _, I, δ) est l’ensemble
L(A) = {t ∈Σ∗
0 | δ(I, t) = ()}.
Un des inconvénients des automates descendants est qu’il n’y a pas équivalence entre automates dé-
terministes et non-déterministes 10. Cependant, automates non-déterministes ascendants et descen-
dants sont quant à eux équivalents en terme d’expressivité, la conversion étant directe en considérant
leurs fonctions de transition comme des ensembles de transition. Ainsi, dans la suite de ce document,
les constructions proposées seront déﬁnies à partir d’ensemble de transitions dans la plupart des cas
aﬁn de conserver la généralité d’implantation.
10. prendre par exemple le langage { f (a, b), f (b, a)}.

17
Première partie
Des expressions rationnelles d’arbres
aux automates d’arbres


19
Présentation
Pour sauver un arbre, mangez un castor!
Henri Prades
Dans cette partie, nous nous intéressons à différentes méthodes de conversion entre expressions ra-
tionnelles et automates. Les différentes méthodes présentées ici considèrent des expressions et des
automates d’arbres, et sont essentiellement des extensions de méthodes classiques pour construire
des automates de mots.
Ainsi, les constructions classiques pourront être retrouvées dans la plus grande partie des cas en
considérant la transformation inverse de l’inclusion des automates de mots en automate d’arbres :
toute lettre de mot peut être en effet considérée comme une lettre d’arbre d’arité 1; les états initiaux
peuvent être modélisés comme des transitions par des lettres d’arité 0.
Aﬁn d’aider à la compréhension de ces différentes méthodes, des applications Web sont accessibles,
implantées en Haskell suivant le paradigme de programmation réactive fonctionnelle, utilisant la bi-
bliothèque Reﬂex, puis converties en Javascript. Les constructions d’automates de mots décrites dans
cette partie sont disponibles à cette adresse [67]. Les constructions d’automates d’arbres, exceptée la
méthode Bottom-Up par dérivation, sont disponibles à cette adresse [65]. La méthode de dérivation
Bottom-Up, valables pour les expressions d’arbres étendues, est disponible à cette adresse [66].
Aﬁn de présenter d’une façon simple ces différentes méthodes de conversion, nous suivrons une
méthodologie simple. Nous aborderons tout d’abord dans cette introduction la méthode en la pré-
sentant sur les langages et expressions de mots pour introduire les concepts mis en œuvres, puis nous
formaliserons dans les sections suivantes ces mêmes méthodes et leurs extensions aux expressions et
langages d’arbres.
Une des premières méthodes de construction d’automate depuis une expression rationnelle est la
méthode des positions, due indépendamment à Glushkov [43] et Mc Naughton et Yamada [63]. Cette
méthode consiste à calculer à partir de l’expression cinq fonctions dites de positions, permettant de
déterminer le rôle de chacune des occurrences des symboles dans la construction du langage. Ces
cinq fonctions sont les suivantes :
— Pos calcule les différentes positions de l’expression, à savoir les différentes occurrences des
symboles;
— Null est une fonction indicatrice de la présence du mot vide dans le langage dénoté par l’ex-
pression;
— First est une fonction renvoyant les positions pouvant commencer un mot du langage;
— Last est la fonction duale de First, calculant les positions pouvant terminer les mots du lan-
gage;
— Follow calcule, pour une position x donnée, les positions succédant directement à x dans un
mot du langage.
Une fois ces fonctions calculées, un automate, dit de positions, peut être calculé en considérant les
positions comme des états dont la ﬁnalité est déterminé par les fonctions de positions, et en déﬁnis-
sant les différentes transitions en fonction de la présence des positions dans chacune des fonctions
de positions.
Un automate plus petit peut ensuite être calculé, en remarquant que si certaines positions admettent
les mêmes successeurs, alors les fusionner préserve le langage reconnu par l’automate. Cette équiva-
lence est à la base de la déﬁnition de l’automate des Follows de Ilie et Yu [48] : les états ne sont alors
plus des positions de l’expression, mais des ensembles de positions dites similaires, c’est-à-dire dont
les ensembles Follows sont égaux. Cet automate est ainsi un quotient de l’automate des positions.

20
Une alternative à la prise en compte des positions de l’expression peut être considérée par une opéra-
tion particulière sur les expressions : la dérivation. On peut par exemple se demander s’il existe une
expression E′ dénotant l’ensemble des mots w tels que a · w soit un mot du langage dénoté par une
expression E, pour un symbole a donné. L’expression E′ est alors appelée dérivée de E par rapport à
a. Cette opération, due à Brzozowski [16] et notée d
da , peut être étendue inductivement en l’opération
d
dw par son application successive en considérant chaque lettre constituant un mot w, et en déﬁnis-
sant la dérivation par le mot vide comme étant la fonction identité 11. Cette opération permet tout
d’abord de résoudre le test d’appartenance d’une façon directe : déterminer si un mot w appartient
au langage dénoté par une expression E revient à déterminer si le mot vide appartient au langage
dénoté l’expression
d
dw (E). Mais cette opération permet également de construire un automate déter-
ministe, l’automate des dérivées : l’état initial est l’expression E, les états sont les dérivées de E, les
transitions sont de la forme (F, a, d
da (F)), et la ﬁnalité d’un état F est déterminée par la présence du
mot vide dans L(F). Cependant, rien n’indique ici que l’ensemble des états est ﬁni. Et effectivement,
il existe des expressions dont l’ensemble des dérivées est inﬁni. Cependant, en considérant une rela-
tion d’équivalence particulière sur les expressions au lieu de l’égalité, il est alors possible d’obtenir
un ensemble ﬁni et par conséquent un automate ﬁni déterministe. Il est important de noter que l’au-
tomate peut avoir un nombre exponentiel d’états, par rapport au nombre de symboles de l’expression
de départ et que cette méthode permet de construire un automate depuis une expression rationnelle
étendue, c’est-à-dire où l’intersection et le complémentaire sont des opérateurs autorisés.
Il est également possible de concevoir un automate non-déterministe en utilisant une opération très
proche de la dérivation : la dérivation partielle. Pour cela, il sufﬁt de changer le codomaine de l’opéra-
tion : au lieu de considérer une opération transformant une expression en une autre expression, on
peut considérer une opération transformant une expression en un ensemble d’expressions (ou en-
semble de termes dérivés) dont la somme serait équivalente à la dérivée classique 12. Cette opération
est appelée dérivation partielle (due à Antimirov [2]) et produit alors l’automate des termes dérivés, ou
automate des équations.
Cet automate, dont le nombre d’états est linéaire par rapport au nombre d’états de l’expression
de départ est également un quotient de l’automate des positions. Pour démontrer ce résultat [27],
Champarnaud et Ziadi construisent les c-continuations d’une expression, représentants canoniques
des continuations de Berry et Sethi [9]. Ces expressions, si produites depuis une expression linéarisée
(c’est-à dire où les symboles sont indicés par leur position respective dans l’expression), permettent
de construire un automate isomorphe à l’automate des positions mais dont les états ne sont pas des
positions mais des expressions. Cette particularité permet d’établir alors un lien morphique entre
l’automate des positions et l’automate des termes dérivés, en délinéarisant les états de l’automate.
Dans la suite de cette partie, nous montrerons comment étendre ces méthodes aux expressions et
automates d’arbres. Pour cela, nous considérerons les deux sens classique de lecture des arbres :
l’approche Top-Down (de la racine aux feuilles) et l’approche Bottom-Up (des feuilles à la racine). Ces
approches sont équivalentes lorsque l’on considère des automates non-déterministes. Cependant, en
se restreignant aux automates déterministes, le pouvoir de représentativité de l’approche Top-Down
est moins puissante. Par exemple, le langage { f(a, a), f(b, b)} ne peut être reconnu par un automate
d’arbres Top-Down.
Ainsi, les méthodes de positions pourront être étendues dans les deux sens. Aﬁn d’étendre le cal-
cul des c-dérivées, nous rappellerons la construction de l’automate des termes dérivés de Kuske et
Meinecke [53], aﬁn de montrer que cet automate est bien un quotient de l’automate des positions.
La méthode par dérivation, quant à elle, ne pourra être réalisée qu’en partant des feuilles vers la ra-
cine : au lieu d’éliminer des nœuds de la racine aux feuilles pour obtenir récursivement des n-uplets
de longueur croissante comme le font Kuske et Meinecke pour l’automate des termes dérivés, il est
possible d’éliminer des feuilles puis des nœuds jusqu’à arriver à la racine de l’arbre. L’inconvénient
de cette méthode est que, contrairement aux méthodes Top-Down, l’arité des arbres n’est pas conser-
vée. Une fois une feuille éliminée, l’arbre voit son arité augmenter. Et une fois un nœud (c’est-à-dire
étiqueté par un symbole d’arité différente de 0) éliminé, l’arité peut évoluer à la baisse. De plus, les
expressions classiques ne permettent pas d’exprimer de telles variations d’arité, ni d’exprimer des
11. Nous verrons qu’il s’agit, comme dans le cas de l’extension de la fonction de transition, d’une adjonction fonctorielle.
12. Nous verrons dans la seconde partie qu’il s’agit ici de ce qu’on appelle un morphisme de Kleisli.

21
arbres d’arités non-nulles. Nous commencerons ainsi par déﬁnir de nouveaux opérateurs, puis de
nouvelles formules de quotients permettant d’exprimer ces opérations. Enﬁn, nous présenterons un
algorithme purement syntaxique résolvant le test d’appartenance.


23
1 Les constructions Top-Down
Les constructions Top-Down ont l’avantage de suivre la déﬁnition naturelle des arbres, de la racine
aux feuilles. Cependant, comme nous l’avons déjà rappelé, le déterminisme réduit le pouvoir de
représentativité des automates.
Ainsi, dans cette section, nous nous intéresserons aux méthodes utilisant la notion de position, à la
dérivation partielle, et aux liens (déjà connus dans le cas des mots) entre ces différentes constructions.
La dérivation classique sera quant à elle abordée dans la section suivante, qui traitera des automates
ascendants.
1.1
L’automate des positions Top-Down
Les résultats de cette section sont tirés de [70, 72], écrits avec la collaboration de Nadia Ouali-Sebti et
de Djelloul Ziadi.
Comme rappelé dans la section précédente, la méthode dite de positions est basée sur le calcul de
5 fonctions particulières dans le cas des mots. Ces fonctions permettent de déterminer les positions
commençant ou ﬁnissant un mot, et pouvant succéder à d’autres positions. Il y a également une fonc-
tion particulière indicatrice de la présence du mot vide dans le langage dénoté par l’expression de
départ. Plus formellement, pour une expression (de mots) E linéaire (c’est-à-dire où chaque symbole
n’apparaît qu’une fois) sur un alphabet Σ,
Pos(E) = {a ∈Σ | ∃u, v ∈Σ∗, uav ∈L(E)},
Null(E) = (ε ∈L(E)),
First(E) = {a ∈Σ | ∃u ∈Σ∗, au ∈L(E)},
Last(E) = {a ∈Σ | ∃u ∈Σ∗, ua ∈L(E)},
Follow(a, E) = {b ∈Σ | ∃u, v ∈Σ∗, uabv ∈L(E)}.
Si l’expression n’est pas linéaire, il est possible de la linéariser : aﬁn de distinguer chacune des occur-
rences des symboles, ces derniers peuvent être indicés par leur position respective dans l’expression.
Cette opération est appelée linéarisation, transformant une expression E en sa linéarisée E. Par déﬁ-
nition, une expression linéarisée est linéaire. L’opération inverse de la linéarisation, la délinéarisation,
est le morphisme h obtenu depuis de la fonction associant à chaque symbole indicé fk le symbole f.
Une fois ces fonctions calculées, l’automate des positions peut être construit comme le quintuplet
(Σ, Pos(E), {0}, F, δ), 0 étant un nouvel état, où
F =
(
Last(E) ∪{0}
si Null(E),
Last(E)
sinon,
δ = {(0, x, x) | x ∈First(E)} ∪{(x, y, y) | y ∈Follow(E, x)}.
L’extension au cas des arbres, dans une approche Top-Down, est relativement proche de la méthode
classique. On peut en effet s’intéresser aux liens de succession des différentes positions d’une expres-
sion linéaire, en considérant un arbre depuis sa racine vers ses feuilles. La linéarisation, tout comme
la délinéarisation, se déﬁnissent d’une manière identique dans le cas des expressions d’arbres.
Cependant, les fonctions de position sont légèrement différentes : si la fonction First (première position)
peut être interprétée comme renvoyant la racine d’un arbre, les fonctions Last ou Follow ne peuvent

24
Chapitre 1. Les constructions Top-Down
s’appliquer avec la même sémantique que celle des mots. En effet, un symbole d’arbre d’arité n
n’admet pas qu’un seul successeur, mais un n-uplet : il nous faut donc spéciﬁer un indice entre 1 et n
aﬁn de réaliser la projection de ce n-uplet. De même, un arbre n’admet pas qu’une seule position de
ﬁn, mais un ensemble de feuilles
Ainsi, une fois la linéarisation opérée si nécessaire, les rôles des différents symboles d’une expression
linéaire E sur un alphabet Σ peuvent être explicités via le calcul des fonctions de positions suivantes :
— First(E) est le sous-ensemble des racines des arbres du langage L(E);
— Last(E) est le sous-ensemble des feuilles des arbres du langage L(E);
— pour un symbole f d’arité m et un entier k ≤m, Follow(E, f, k) est le sous-ensemble des
racines des ke ﬁls des sous-arbres de racine f des arbres du langage L(E).
Plus formellement,
First(E) = {racine(t) ∈Σ | t ∈L(E)},
Last(E) =
[
t∈L(E)
feuilles(t),
Follow(E, f, k) = {g ∈Σ | ∃t ∈L(E), ∃s ≼t, racine(s) = f, ke-ﬁls(s) = g}.
Exemple 3
Considérons l’alphabet Σ = Σ0 ∪Σ1 ∪Σ2 déﬁni par
Σ0 = {a, b, c},
Σ1 = { f, h},
Σ2 = {g}.
Considérons l’expression rationnelle E et sa linéarisée déﬁnies par :
E = ( f(a)∗a ·a b + h(b))∗b + g(c, a)∗c ·c ( f(a)∗a ·a b + h(b))∗b,
E = ( f1(a)∗a ·a b + h2(b))∗b + g3(c, a)∗c ·c ( f4(a)∗a ·a b + h5(b))∗b.
Le langage dénoté par E est l’ensemble
L(E) ={b, f1(b), f1( f1(b)), f1(h2(b)), h2(b), h2( f1(b)), h2(h2(b)), . . . ,
g3(b, a), g3(g3(b, a), a), g3( f4(b), a), g3(h5(b), a),
f4( f4(b)), f4(h5(b), h5( f4(b))), h5(h5(b)), . . .}.
Par conséquent,
First(E) = {b, f1, h2, g3, f4, h5},
Last(E) = {a, b},
Follow(E, f1, 1) = {b, f1, h2},
Follow(E, h2, 1) = {b, f1, h2},
Follow(E, g3, 1) = {b, g3, f4, h5},
Follow(E, g3, 2) = {a},
Follow(E, f4, 1) = {b, f4, h5},
Follow(E, h5, 1) = {b, f4, h5}.
Les fonctions de position pour les expressions d’arbres, tout comme celles des expressions de mots,
sont récursivement calculables :
First(0) = ∅,
First( f(_, . . . , _)) = { f},
First(E1 + E2) = First(E1) ∪First(E2),
First(E1∗c) = First(E1) ∪{c},
First(E1 ·c E2) =
(
(First(E1) \ {c}) ∪First(E2)
si c ∈First(E1),
First(E1)
sinon.
TABLE 1.1 – Déﬁnition inductive de First.

1.1. L’automate des positions Top-Down
25
Last(0) = ∅,
Last( f(E1, . . . , En)) =
(
{ f}
si n = 0,
S
j≤n Last(Ej)
sinon,
Last(E1 + E2) = Last(E1) ∪Last(E2),
Last(E1∗c) = Last(E1) ∪{c},
Last(E1 ·c E2) =
(
(Last(E1) \ {c}) ∪Last(E2)
si c ∈Last(E1),
Last(E1)
sinon.
TABLE 1.2 – Déﬁnition inductive de Last.
Follow(0, f, k) = ∅,
Follow(g(E1, . . . , En), f, k) =
(
First(Ek)
si f = g,
S
j≤n Follow(Ej, f, k)
sinon,
Follow(E1 + E2, f, k) = Follow(E1, f, k) ∪Follow(E2, f, k),
Follow(E1 ·c E2, f, k) =





(Follow(E1, f, k) \ {c}) ∪First(E2)
si c ∈Follow(E1, f, k),
Follow(E1, f, k) ∪Follow(E2, f, k)
si c ∈Last(E1),
Follow(E1, f, k)
sinon,
Follow(E∗c
1 , f, k) =
(
Follow(E1, f, k) ∪First(E1)
si c ∈Follow(E1, f, k),
Follow(E1, f, k)
sinon.
TABLE 1.3 – Déﬁnition inductive de Follow.
À partir de ces fonctions de position, il est très aisé de déﬁnir un automate reconnaissant le langage
dénoté par une expression rationnelle. Il sufﬁt pour cela de construire les transitions à partir des
fonctions First et Follow comme une application directe de leurs déﬁnitions respectives. Les points de
départ et d’arrivée des transitions étant relatifs à la fois aux symboles et à l’indice des ﬁls considérés,
il sufﬁt de considérer des couples états-entiers leur correspondant (nous noterons les entiers comme
des exposants pour diminuer le nombre de parenthèses nécessaires). L’adjonction d’un état terminal
unique, étiqueté par l’élément ε ne pouvant appartenir à l’alphabet, est utilisé pour recueillir les
transitions étiquetées par les symboles de racine.
Plus formellement, la méthode se décrit comme suit.
Déﬁnition 1
L’automate des positions PE d’une expression linéarisée E est l’automate (Q, Σ, F, δ) déﬁni par
Q = { f k | f ∈Σm, 1 ≤k ≤m} ∪{ε},
F = {ε},
δ = {((g1, . . . , gn), g, f k) | f ∈Σm, k ≤m, g ∈Σn ∩Follow(E, f, k)}
∪{(( f 1, . . . , f m), f, ε) | f ∈Σm ∩First(E)}.
Cet automate reconnaît le langage dénoté par l’expression de départ et possède un nombre d’états
égal à la somme des arités de chacune de ses positions, plus un pour l’état initial/ﬁnal 1 ε.
1. en fonction du sens de lecture, ascendant ou descendant

26
Chapitre 1. Les constructions Top-Down
Cette construction peut être étendue à toute expression non nécessairement linéaire en utilisant les
opérations de linéarisation et de délinéarisation. En effet, l’automate des positions PE associé à une ex-
pression (non linéaire) E est obtenu en remplaçant toute transition ((g1, . . . , gn), g, f k) de l’automate
PE par ((g1, . . . , gn), h(g), f k).
Exemple 4
Considérons les deux expressions de l’Exemple 3 :
E = ( f(a)∗a ·a b + h(b))∗b + g(c, a)∗c ·c ( f(a)∗a ·a b + h(b))∗b,
E = ( f1(a)∗a ·a b + h2(b))∗b + g3(c, a)∗c ·c ( f4(a)∗a ·a b + h5(b))∗b.
L’automate des positions PE est représenté Figure 1.1. Les ensembles d’états sont
Q = {ε, f 1
1 , h1
2, g1
3, g2
3, f 1
4, h1
5},
F = {ε}.
L’ensemble des transitions est constitué des transitions suivantes :
( f 1
1, f1, ε)
( f 1
1, f1, f 1
1 )
( f 1
1, f1, h1
2)
(h1
2, h2, ε)
(h1
2, h2, f 1
1 )
(h1
2, h2, h1
2)
((g1
3, g2
3), g3, g1
3)
((g1
3, g2
3), g3, ε)
( f 1
4 , f4, ε)
( f 1
4, f4, g1
3)
( f 1
4, f4, f 1
4 )
( f 1
4, f4, h1
5)
(h1
5, h5, ε)
(h1
5, h5, g1
3)
(h1
5, h5, f 1
4 )
(h1
5, h5, h1
5)
(a, g2
3)
(b, ε)
(b, f 1
1 )
(b, h1
2)
(b, g1
3)
(b, f 1
4 )
(b, h1
5)
Le nombre d’états est |Q| = 7 et le nombre de transitions est |δ| = 23. L’automate des positions PE,
obtenu en délinéarisant les étiquettes de PE est représenté Figure 1.2.
ε
f 1
1
h1
2
g1
3
g2
3
h1
5
f 1
4
b
b
b
b
a
b
b
f1
f1
h2
h2
h2
f1
h5
h5
h5
h5
f4
f4
f4
f4
g3
g3
FIGURE 1.1 – L’automate
des positions PE.
ε
f 1
1
h1
2
g1
3
g2
3
h1
5
f 1
4
b
b
b
b
a
b
b
f
f
h
h
h
f
h
h
h
h
f
f
f
f
g
g
FIGURE 1.2 – L’automate
des positions PE.

1.2. L’automate des follows
27
1.2
L’automate des follows
Les résultats de cette section sont tirés de [70, 72], écrits avec la collaboration de Nadia Ouali-Sebti et
de Djelloul Ziadi.
Dans la section précédente, nous avons montré comment construire l’automate des positions d’une
expression donnée, chaque état correspondant à une position. Cependant, il est possible que certaines
positions partagent des mêmes propriétés, telles que d’avoir des ensembles Follow égaux. Ainsi, Ilie
et Yu [48] ont proposé une relation d’équivalence sur les positions qui est également une congruence
pour la fonction de transition de l’automate des positions. Il s’agit de la congruence des Follow, déﬁnie
de la façon suivante pour tout couple de position ( f, g) d’une expression linéaire E :
f ∼F g ⇔Follow( f, E) = Follow(g, E).
Cette congruence permet ainsi de calculer un automate quotient de celui des positions, qui est ainsi
plus petit en nombre d’états. Pour cela, la congruence est étendue en considérant que l’ensemble
Follow associé à l’état initial de l’automate de Glushkov est l’ensemble First.
Pour construire l’automate des Follow d’une expression d’arbres, nous suivrons donc le même prin-
cipe. Pour commencer, il sufﬁt de déﬁnir un automate où les états ne sont plus les couples positions-
entiers de l’automate des positions, mais des ensembles de ces couples f k partageant les mêmes
ensembles de successeurs, en considérant que les successeurs de l’état ε sont l’ensemble des racines,
l’ensemble First(E).
Déﬁnition 2
L’automate des Follows d’une expression linéaire E sur un alphabet Σ est l’automate d’arbres FE =
(Q, Σ, First(E), δ) déﬁni par
Q = {First(E)} ∪{Follow(E, f, k) | f ∈Σm ∧1 ≤k ≤m},
δ = {(Follow(E, f, 1), . . ., Follow(E, f, m), f, S) | S ∈Q ∧f ∈S ∩Σm}.
L’automate des Follow d’une expression E est par déﬁnition même plus petit que l’automate des
positions de E, puisque l’on peut considérer la surjection envoyant les couples positions-entiers vers
leurs ensembles Follow. Aﬁn de montrer que cet automate reconnaît L(E), on peut montrer que FE
est un quotient de PE selon une congruence Top-Down particulière, la relation ∼F, déﬁnie pour tous
deux états f k et gl de Q par
f k ∼F gl ⇔Follow(E, f, k) = Follow(E, g, l).
Cette relation est une congruence très particulière. Il s’agit en effet d’une relation de similarité, c’est-
à-dire une relation d’équivalence ∼sur Q telle que pour tous deux états équivalents q et q′ dans
Q, la transition ((q1, . . . , qn), f, q) est dans δ si et seulement si la transition ((q1, . . . , qn), f, q′) l’est
également. En d’autres termes, deux états similaires admettent exactement les mêmes prédécesseurs
pour chacun des symboles, y compris les symboles nullaires. Toute relation de similarité ∼pour un
automate A est trivialement une congruence Top-Down et ainsi,
L(A) = L(A∼).
Cette relation de similarité est la plus large pour PE. De plus, l’appliquer produit l’automate des
follows.
Proposition 1
Le quotient de l’automate des positions d’une expression linéaire E par ∼F est isomorphe à l’auto-
mate des Follow de E.
Cela permet ainsi de montrer aisément la correction de la construction.
Théorème 1
L’automate des Follow d’une expression linéaire E reconnaît L(E).

28
Chapitre 1. Les constructions Top-Down
Cette construction peut être étendue à des expressions non nécessairement linéaires comme suit.
L’automate des follows FE associé à une expression E est obtenu en remplaçant chaque transition
((Follow(E, f, 1), . . ., Follow(E, f, m)), f, S)
de FE par sa version délinéarisée, c’est-à-dire par
((Follow(E, f, 1), . . ., Follow(E, f, m)), h( f), S).
Corollaire 1
L’automate des follows d’une expression E reconnaît L(E).
Exemple 5
L’automate des follows FE associée à l’expression
E = ( f(a)∗a ·a b + h(b))∗b + g(c, a)∗c ·c ( f(a)∗a ·a b + h(b))∗b
de l’Exemple 3 est représenté Figure 1.3. Rappelons que les ensembles Follow vériﬁent les égalités
suivantes :
Follow(E, f1, 1) = Follow(E, h2, 1),
Follow(E, f4, 1) = Follow(E, h5, 1).
Ainsi, l’automate des Follow de E est isomorphe à l’automate obtenu en fusionnant les états f 1
1 avec
h1
2 et f 1
4 avec h1
5 de l’automate des positions de E. Les ensembles d’états sont
Q = {{a}, {b, f1, h2}, {b, f1, h2, g3, f4, h5}, {b, g3, f4, h5}, {b, f4, h5}},
F = {{b, f1, h2, g3, f4, h5}}.
L’ensemble des transitions est constitué des transitions
({b, f1, h2}, f, {b, f1, h2, g3, f4, h5})
({b, f1, h2}, f, {b, f1, h2})
({b, f1, h2}, h, {b, f1, h2, g3, f4, h5})
({b, f1, h2}, h, {b, f1, h2})
(({b, g3, f4, h5}, g2
3), g, {b, g3, f4, h5})
(({b, g3, f4, h5}, g2
3), g, {b, f1, h2, g3, f4, h5})
({b, f4, h5}, f, {b, f1, h2, g3, f4, h5})
({b, f4, h5}, f, {b, g3, f4, h5})
({b, f4, h5}, f, {b, f4, h5})
({b, f4, h5}, h, {b, f1, h2, g3, f4, h5})
({b, f4, h5}, h, {b, g3, f4, h5})
({b, f4, h5}, h, {b, f4, h5})
(a, {a})
(b, {b, f1, h2, g3, f4, h5})
(b, {b, f1, h2})
(b, {b, g3, f4, h5})
(b, {b, f4, h5})
Le nombre d’états est |Q| = 5 et le nombre de transitions est |δ| = 17.

1.3. Les automates des c-continuations et des termes dérivés
29
{b, f1, f4, g3, h2, h5}
{b, f1, h2}
{b, f4, g3, h5}
{a}
{b, f4, h5}
b
b
b
a
b
f, h
f, h
f, h
f, h
f, h
g
g
FIGURE 1.3 – L’automate des follows de E.
1.3
Les automates des c-continuations et des termes dérivés
Les résultats de cette section sont tirés de [69, 68, 70, 72], écrits en collaboration avec Nadia Ouali-
Sebti et Djelloul Ziadi.
L’automate des c-continuations (pour continuations canoniques) est un automate isomorphe à l’au-
tomate des positions dû à Champarnaud et Ziadi [27]. Cet automate permet également de faire le
lien entre les méthodes de positions et les méthodes de dérivation. En effet, il ne s’agit plus là de dé-
terminer les successeurs directs de positions, mais de calculer, par des formules relativement proches
de la dérivation, une expression dénotant le langage des mots suivants une position donnée dans un
mot du langage.
Pour cela, Champarnaud et Ziadi s’inspirent du calcul des continuations de Berry et Sethi [9], et
montrent comment calculer un représentant unique (canonique) de ces continuations; en effet, les
continuations d’une position donnée ne sont pas toutes égales, mais équivalentes, modulo l’associa-
tivité, la commutativité et l’idempotence de la somme.
Ainsi, la c-continuation ca(E) d’une expression linéaire E par rapport à une position a de E se calcule
inductivement comme suit :
ca(a) = ε,
ca(F + G) =
(
ca(F)
si a est une position de F,
ca(G)
sinon,
ca(F∗) = ca(F) · F∗,
ca(F · G) =
(
ca(F) · G
si a est une position de F,
ca(G)
sinon.
Une fois ces continuations calculées, il sufﬁt alors de construire l’automate des c-continuations de
la façon suivante : les états sont des couples (positions, c-continuations) dont la ﬁnalité dépend de
la présence du mot vide dans le langage dénoté par la c-continuations, et les transitions sont de la
forme ((_, E1), a, (a, ca(E))) si a appartient à First(E1).
Le point fort de cette méthode est qu’elle permet de construire un autre automate, l’automate des
termes dérivés, par un quotient très simple et ainsi de faire le lien entre les méthodes de position et
celles de dérivation.
L’automate des termes dérivés est un automate construit à partir de l’opération de dérivation par-
tielle, due à Antimirov [2]. La dérivée partielle d’une expression E par rapport à un symbole a est un

30
Chapitre 1. Les constructions Top-Down
ensemble δ
δa (E) d’expressions dont la somme S vériﬁe la propriété suivante :
L(S) = {w | aw ∈L(E)}.
Cette opération se déﬁnit inductivement comme suit :
δ
δa (0) = ∅,
δ
δa (ε) = ∅,
δ
δa (b) =
(
{ε}
si a = b,
∅
sinon,
,
δ
δa (F + G) = δ
δa (F) ∪δ
δa (G),
δ
δa (F · G) =
( δ
δa (F) · G ∪δ
δa (G)
si Null(F),
δ
δa (F) · G
sinon,
δ
δa (F∗) = δ
δa (F) · F∗,
où
{F1, . . . , Fn} · G = {F1 · G, . . . , Fn · G}.
Cette opération s’étend par linéarité sur les ensembles d’expressions :
δ
δa ({E1, . . . , En}) = δ
δa (E1) ∪· · · ∪δ
δa (En),
et inductivement sur les mots :
δ
δε (E) = {E},
δ
δaw = δ
δw ◦δ
δa
.
Chaque expression contenue dans une dérivée partielle est appelée terme dérivé. De plus, le cardi-
nal de l’ensemble des termes dérivés est nécessairement inférieur à (n + 1), où n est le nombre des
occurrences des symboles de l’expression.
Une fois ces termes dérivés calculés, l’automate des termes dérivés est construit ainsi : les états sont
les termes dérivés, dont la ﬁnalité dépend de la présence du mot vide dans les langages que ces
termes dénotent, et les transitions sont de la forme (E1, a, E2) où E2 est un terme dérivé de E1 par
rapport à a.
L’inconvénient de cette construction est qu’elle est coûteuse en temps : en effet, en considérant n le
nombre de symboles d’une expression et m la taille de son arbre syntaxique, la construction de l’auto-
mate des termes dérivés admet une complexité de l’ordre de n3 × m2. L’utilisation des c-continuations
permet de réduire cette complexité.
Pour cela, une fois l’automate des c-continuations calculé, il sufﬁt de considérer l’équivalence d’états
∼déﬁnie par
(_, E1) ∼(_, E2) ⇔h(E1) = h(E2)
qui est ainsi une congruence et de calculer le quotient. Cela permet d’atteindre alors une complexité
de construction quadratique par rapport à la taille de l’arbre syntaxique de l’expression. Cette mé-
thode a même été améliorée pour atteindre une complexité dépendant de la taille de l’automate de
sortie (méthode output sensitive) [49].
Aﬁn d’étendre ces résultats aux expressions d’arbres, nous procéderons de la façon suivante. Tout
d’abord, nous expliciterons les formules des c-continuations ainsi que l’automate des c-continuations.
Ensuite, nous présenterons l’automate des termes dérivés de Kuske et Meinecke. Enﬁn, nous illus-
trerons le lien morphique entre les deux.
1.3.1
Les c-continuations d’arbres
N. B. : Dans cette section, nous considérons le quotient 0 ·c E = 0. Une expression sans occurrence de
0 ou réduite à 0 est dite réduite.
Les formules inductives de calculs des c-continuations d’une expression linéaire d’arbres sont rela-
tivement proches de celles de mots. La seule différence est que, comme dans le cas du calcul des
Follow, l’arité de la position doit être prise en compte en ajoutant un indice indiquant le sous-arbre

1.3. Les automates des c-continuations et des termes dérivés
31
choisi. Ainsi, pour E une expression linéaire non-nulle, f un symbole m-aire (m ̸= 0) de E et k un
indice entre 1 et m, la c-continuation de E par rapport à f k se calcule inductivement comme suit :
Cf k(g(E1, . . . , Em)) =
(
Ek
si f = g,
Cf k(Ej)
si f ∈ΣEj,
Cf k(E1 + E2) =
(
Cf k(E1)
si f ∈ΣE1,
Cf k(E2)
si f ∈ΣE2,
Cf k(E1 ·c E2) =





Cf k(E1) ·c E2
si f ∈ΣE1,
Cf k(E2)
si f ∈ΣE2 et c ∈Last(E1),
0
sinon,
Cf k(E1∗c) = Cf k(E1) ·c E1∗c.
TABLE 1.4 – Déﬁnition inductive des c-continuations.
N. B. :Pour la suite de cette section, dans un souci d’harmonisation nous poserons Cε(E) = E.
Une fois les c-continuations calculées, il sufﬁt de les combiner en suivant le même principe que dans
le cas des mots aﬁn de construire un automate.
Déﬁnition 3
Soit E ̸= 0 une expression rationnelle linéaire sur un alphabet Σ. L’automate des c-continuations de
E est l’automate CE = (Q, Σ, {contε}, δ) déﬁni par
Q = {cont f k | f ∈Σm, 1 ≤k ≤m} ∪{contε},
δ = {(Cg, g, contx) | g ∈Σm, m ≥1, g ∈First(Cx(E))}
∪{(c, contx) | c ∈L(Cx(E)) ∩Σ0}
où pour toute position g d’arité m, pour tout indice j entre 1 et m,
Cg = (contg1, . . . , contgm),
contgj = (gj, Cgj(E)).
Enﬁn, l’automate des c-continuations d’une expression E non linéaire est obtenue en appliquant le
morphisme alphabétique h sur CE.
Exemple 6
Soient
E = ( f(a)∗a ·a b + h(b))∗b + g(c, a)∗c ·c ( f(a)∗a ·a b + h(b))∗b,
E = ( f1(a)∗a ·a b + h2(b))∗b + g3(c, a)∗c ·c ( f4(a)∗a ·a b + h5(b))∗b
les expressions déﬁnies dans l’Exemple 3. Posons alors :
F1 = ( f1(a)∗a ·a b + h2(b))∗b,
F2 = g3(c, a)∗c,
F3 = ( f4(a)∗a ·a b + h5(b))∗b.
Ainsi,
E = F1 + F2 ·c F3.
Les c-continuations de E sont les suivantes :
Cf 1
1 (E) = ((a ·a f1(a)∗a) ·a b) ·b F1,

32
Chapitre 1. Les constructions Top-Down
Ch1
2(E) = b ·b F1,
Cg1
3(E) = (c ·c F2) ·c F3,
Cg2
3(E) = (a ·c F2) ·c F3,
Cf 1
4 (E) = ((a ·a f4(a)∗a) ·a b) ·b F3,
Ch1
5(E) = b ·b F3.
L’ensemble des états de l’automate CE est
Q = {contε, contf 1
1 , conth1
2, contg1
3, contg2
3, contf 1
4 , conth1
5}.
Les transitions de δ sont
(a, contg2
3),
(b, contf 1
1 ),
(b, contg1
3),
(b, contε),
(b, conth1
2),
(b, conth1
5),
(b, cont f 1
4 ),
(cont f 1
4 , f, contg1
3),
(contf 1
4 , f, contf 1
4 ),
(contf 1
4 , f, conth1
5),
(contf 1
1 , f, conth1
2),
(contf 1
1 , f, contε),
(contf 1
1 , f, contf 1
1 ),
(contf 1
4 , f, contε),
((contg1
3, contg2
3), g, contε),
(conth1
5, h, contε),
((contg1
3, contg2
3), g, contg1
3),
(conth1
2, h, conth1
2),
(conth1
2, h, contε),
(conth1
2, h, contf 1
1 ),
(conth1
5, h, conth1
5),
(conth1
5, h, contf 1
4 ),
(conth1
5, h, contg1
3).
Le nombre d’états est |Q| = 7 et le nombre de transitions est |δ| = 23. L’automate des c-continuations
de E est représenté Figure 1.4.
contε
contf 1
1
conth1
2
contg1
3
contg2
3
conth1
5
contf 1
4
b
b
b
b
a
b
b
f1
f1
h2
h2
h2
f1
h5
h5
h5
h5
f4
f4
f4
f4
g3
g3
FIGURE 1.4 – L’automate des c-continuations de E.

1.3. Les automates des c-continuations et des termes dérivés
33
Cet automate est isomorphe à l’automate des positions de E. Pour le montrer, il sufﬁt de considérer
le lien suivant entre les fonctions de positions et les c-continuations :
Follow(E, f, k) = First(Cf k(E)).
Il s’ensuit alors que
Théorème 2
L’automate CE reconnaît L(E).
Montrons alors comment quotienter cet automate aﬁn de calculer un équivalent à l’automate des
termes dérivés. Pour cela, commençons par rappeler la déﬁnition de cet automate, proposée par
Kuske et Meinecke.
1.3.2
L’automate des termes dérivés de Kuske et Meinecke
Dans [53], Kuske et Meinecke étendent la notion de dérivation partielle des expressions de mots
([2]) à la dérivation partielle d’expressions d’arbres dans le but de calculer depuis une expression E
un automate d’arbre reconnaissant L(E). Cependant, de par la présence de symboles non unaires,
les dérivées partielles ne sont plus des ensembles d’expressions, mais des ensembles de n-uplets
d’expressions. Ainsi, la dérivée partielle d’une expression E par un symbole non nullaire f d’arité k
est l’ensemble de k-uplets f −1(E) déﬁni inductivement comme suit :
f −1(0) = ∅
f −1(F + G) = f −1(F) ∪f −1(G)
f −1(F∗c) = f −1(F) ·c F∗c
f −1(g(E1, . . . , En)) =
(
{(E1, . . . , En)}
si f = g,
∅
sinon,
f −1(F ·c G) =
(
f −1(F) ·c G
si c /∈L(F),
f −1(F) ·c G ∪f −1(G)
sinon,
où pour tout n-uplet d’expressions N = (E1, . . . , En), pour tout ensemble S de n-uplets d’expres-
sions :
N ·c F = (E1 ·c F, . . . , En ·c F),
S ·c F = {N ·c F | N ∈S}.
La fonction f −1 s’étend pour tout ensemble S d’expressions rationnelles par
f −1(S) =
[
E∈S
f −1(E).
Aﬁn de déterminer l’ensemble des termes dérivés, il n’est pas nécessaire de prendre en compte la
structure des arbres pour déterminer les dérivations successives. En effet, après avoir calculé un k-
uplet d’expressions, il n’est pas nécessaire de dériver le k-uplet, mais chaque expression. L’opération
de dérivation est par essence indépendante du contexte. Ainsi, il sufﬁt de répéter la dérivation par
des symboles, ce qui revient à oublier la structure d’opérade de l’ensemble des arbres en oubliant la
graduation de l’alphabet. On se ramène ainsi à une dérivation d’expressions d’arbres par des mots.
Par conséquent, la dérivée partielle d’une expression E par rapport à un mot w de Σ∗
≥1 ici considéré
comme le monoïde libre, est l’ensemble d’expressions dénoté par ∂w(E) inductivement déﬁni par :
∂w(E) =





{E}
si w = ε,
Set( f −1(∂u(E)))
si w = u f, f ∈Σ≥1, u ∈Σ∗
≥1, f −1(∂u(E)) ̸= ∅,
{0}
si w = u f, f ∈Σ≥1, u ∈Σ∗
≥1, f −1(∂u(E)) = ∅,

34
Chapitre 1. Les constructions Top-Down
où pour tout k-uplets d’expressions (E1, . . . , Ek), pour tout ensemble S de k-uplets d’expressions,
Set(S) =
[
c∈S
Set(c),
Set((E1, . . . , En)) = {E1, . . . , En}.
Une fois les termes dérivés calculés, il ne reste plus qu’à les utiliser pour construire l’automate recher-
ché. Ainsi, l’automate des termes dérivés d’une expression E est l’automate AE = (Q, Σ, QT, δ) déﬁni
par :
Q =
[
w∈Σ∗
≥1
∂w(E),
QT = {E},
δ = {((G1, . . . , Gm), f, F) | F ∈Q, f ∈Σm, m ≥1, (G1, . . . , Gm) ∈f −1(F)}
∪{(c, F) | F ∈Q, c ∈(L(F) ∩Σ0)}.
Exemple 7
Soit E = F + G ·c F l’expression rationnelle de l’Exemple 3 avec
F = ( f(a)∗a ·a b + h(b))∗b,
G = g(c, a)∗c.
Les dérivées partielles de E sont les ensembles
∂h(E) = {b ·b F},
∂f (E) = {((a ·a f(a)∗a) ·a b) ·b F},
∂f f (E) = {((a ·a f(a)∗a) ·a b) ·b F},
∂f h(E) = {b ·b F},
∂g(E) = {(a ·c G) ·c F, (c ·c G) ·c F},
∂h f (E) = {((a ·a f(a)∗a) ·a b) ·b F},
∂gh(E) = {b ·b F},
∂hh(E) = {((a ·a f(a)∗a) ·a b) ·b F},
∂g f (E) = {((a ·a f(a)∗a) ·a b) ·b F},
∂gg(E) = {(a ·c G) ·c F, (c ·c G) ·c F}.
Les éléments de l’ensemble des états Q sont alors les états suivants :
q0 = E,
q1 = ((a ·a f(a)∗a) ·a b) ·b F,
q2 = b ·b F,
q3 = (c ·c G) ·c F,
q4 = (a ·c G) ·c F.
Le seul état ﬁnal est q0. Les transitions sont :
(b, q0)
(b, q1)
(b, q3)
(b, q2)
(a, q4)
(q1, f, q0)
(q1, f, q1)
(q1, f, q2)
(q4, f, q1)
(q0, h, q2)
(q2, h, q1)
(q2, h, q2)
(q4, h, q2)
(q3, q4, g, q0)
(q3, q4, g, q4).
Le nombre d’états est |Q| = 5 est le nombre de transitions est 15. L’automate des termes dérivés de
E est représenté Figure 1.5.

1.3. Les automates des c-continuations et des termes dérivés
35
q0
q3
q4
q2
q1
b
b
a
b
b
h
h
h
h
f
f
f
f
g
g
FIGURE 1.5 – L’automate des termes dérivés AE.
1.3.3
Lien entre termes dérivés et c-continuations
Aﬁn d’étendre la méthode de conversion de l’automate des c-continuations en automate des termes
dérivés, on peut tout simplement étendre la congruence classique, c’est-à-dire la congruence Top-
Down ∼suivante déﬁnie pour tout deux états ( f k, Cf k(E)) et (gp, Cgp(E)) par
( f k, Cf k(E)) ∼(gp, Cgp(E)) ⇔h(Cf k(E)) = h(Cgp(E)).
Avec cette congruence, l’automate quotient (CE)∼est isomorphe à l’automate des termes dérivés AE.
Exemple 8
Considérons les c-continuations de l’Exemple 6. Par déﬁnition de la relation ∼sur les états de l’au-
tomate E (Figure 1.4),
h(Cf 1
1 (E)) = h(Cf 1
4 (E)),
h(Ch1
2(E)) = h(Ch1
5(E)).
L’automate (CE)∼, isomorphe à AE, est représenté Figure 1.6. Le nombre d’états est |Q| = 5 et le
nombre de transitions est |δ| = 15.
{h(Cε(E))}
{h(Cg1
3(E))}
{h(Cg2
3(E))}
{h(Ch1
2(E))}
{h(C f 1
1 (E))}
b
b
a
b
b
h
h
h
h
f
f
f
f
g
g
FIGURE 1.6 – L’automate (CE)∼.

36
Chapitre 1. Les constructions Top-Down
Enﬁn, en utilisant cette congruence, mais également en utilisant des algorithmes classiques (tels que
l’algorithme de minimisation d’automates acycliques de mots de Revuz [74]), des structures avan-
cées (telles que la ZPC de Ziadi et. al [77]) et des encodages d’expressions (compression de pseudo-
continuations de [49]), nous avons montré, avec Djelloul Ziadi et Nadia Ouali-Sebti [68], que l’auto-
mate des termes dérivés pouvaient être calculé en temps et en espace de l’ordre de n × m, où n est le
nombre de termes dérivés de E et m la taille de l’arbre syntaxique de E.
1.4
Un automate plus petit
Les résultats de cette section sont tirés de [72], écrit avec la collaboration de Nadia Ouali-Sebti et de
Djelloul Ziadi.
Dans les sections précédentes, nous avons vu que l’automate des Follow et l’automate des termes
dérivés étaient des quotients distincts de l’automate des positions par les relations ∼F et ∼.
Ces deux relations étant distinctes, on peut les combiner pour avoir une relation plus grossière aﬁn
d’obtenir un automate encore plus réduit.
C’est ce que proposent dans [40] García et al., où ils donnent un nouvel algorithme pour obtenir un
automate depuis une expression. Leur méthode est basée sur le calcul d’une relation ≡V, jonction
des relations ∼F et ∼.
Appliquons alors la méthode aux automates d’arbres directement. L’idée est d’étendre tout d’abord
la relation ∼F aux c-continuations comme suit :
Cf k(E) ∼F Cgp(E) ⇔Follow(Cf k(E), f, k) = Follow(Cgp(E), p).
Une fois cela fait, il ne reste plus qu’à combiner les relations ∼F et ∼en une relation ≡V :
Cf k(E) ≡V Cgp(E) ⇔
(
(∃Chl(E) ∼F Cf k(E) | Chl(E) ∼Cgp(E))
∨(∃Chl(E) ∼F Cgp(E) | Chl(E) ∼Cf k(E))
et à calculer le quotient de l’automate des c-continuations par cette nouvelle relation.
Plus formellement, l’automate réduit V, associé à une expression E, est l’automate (Q, Σ, {[E]≡V}, δ)
déﬁni par
Q = {contEq f k | f ∈ΣEm, 1 ≤k ≤m} ∪{[E]≡V}
δ = {(Cg, h(g), contEqx) | g ∈ΣEm, m ≥1, g ∈First(Cx(E))}
∪{(contEqx, c) | c ∈L(Cx(E)) ∩Σ0}
où
contEqgj = [Cgj(E)]≡V,
Cg = (contEqg1, . . . , contEqgm).
En tant que conséquence directe, on peut montrer que l’automate V est plus petit que l’automate des
follows ou que l’automate des termes dérivés. En effet, si deux continuations admettent les mêmes
ensembles de Follows, ils sont fusionnés dans l’automate des follows et ainsi dans V. Par conséquent,
deux états distincts de V admettent des ensemble de Follows différents.
D’une façon similaire, si deux états distincts de l’automate des continuations sont égaux une fois
délinéarisés, ces états sont fusionnés dans V. Ainsi, deux états ∼-équivalents dans l’automate des
c-continuations sont fusionnés dans l’automate des termes dérivés tout comme dans V. Par consé-
quent, deux états ∼-équivalents ne peuvent apparaître dans des états distincts de V.
Finalement, remarquons que les expressions fusionnées admettent les mêmes prédécesseurs une fois
délinéarisées, puisque ∼F est une relation de similarité, et que ∼préserve la structure syntaxique
des expressions et ainsi les résultats de dérivation.

1.4. Un automate plus petit
37
Par conséquent, on peut en déduire les liens morphiques entre l’automate V, l’automate des termes
dérivés et l’automate des follows, le premier étant un quotient des suivants.
Exemple 9
Considérons l’expression de l’Exemple 3 :
E = ( f(a)∗a ·a b + h(b))∗b + g(c, a)∗c ·c ( f(a)∗a ·a b + h(b))∗b,
E = ( f1(a)∗a ·a b + h2(b))∗b + g3(c, a)∗c ·c ( f4(a)∗a ·a b + h5(b))∗b.
Pour rappel, les c-continuations de E sont les suivantes :
Cf 1
1 (E) = ((a ·a f1(a)∗a) ·a b) ·b ( f1(a)∗a ·a b + h2(b))∗b,
Ch1
2(E) = b ·b ( f1(a)∗a ·a b + h2(b))∗b,
Cg1
3(E) = (c ·c g3(c, a)∗c) ·c ( f4(a)∗a ·a b + h5(b))∗b,
Cg2
3(E) = ((a ·c g3(c, a))∗c) ·c ( f4(a)∗a ·a b + h5(b))∗b,
Cf 1
4 (E) = ((a ·a f4(a)∗a) ·a b) ·b ( f4(a)∗a ·a b + h5(b))∗b,
Ch1
5(E) = b ·b ( f4(a)∗a ·a b + h5(b))∗b.
Par application de ∼F, on obtient :
Cf 1
1 (E) ∼F Ch1
2(E),
Cf 1
4 (E) ∼F Ch1
5(E).
Les états Cg1
3(E) et Cg2
3(E) sont indépendants.
Le nombre des états est |Q| = 5 et le nombre de transitions est |δ| = 15. L’automate quotient par ∼F,
isomorphe à l’automate des Follow, est représenté Figure 1.7.
De plus,
h(Cf 1
1 (E)) = h(Cf 1
4 (E)),
h(Ch1
2(E)) = h(Ch1
5(E)).
Ainsi,
Cf 1
1 (E) ≡Ch1
2(E) ≡Ch1
4(E) ≡Ch1
5(E).
L’automate réduit de E est représenté Figure 1.8. Le nombre d’états est |Q| = 4 et le nombre de
transitions est |δ| = 14.

38
Chapitre 1. Les constructions Top-Down
{Cε(E)}
{C f 1
1 (E), Ch1
2(E)}
{Cg1
3(E)}
{Cg2
3(E)}
{C f 1
4 (E), Ch1
5(E)}
b
b
b
a
b
f, h
f, h
f, h
f, h
f, h
g
g
FIGURE 1.7 – L’automate (CE)∼F .
{Cε1(E)}
{Cg1
3(E)}
{Cg2
3(E)}
{C f 1
1 (E), Ch1
2(E), C f 1
4 (E), Ch1
5(E)}
b
b
a
b
f, h
f, h
f, h
g
g
FIGURE 1.8 – L’automate V.

39
2 Les constructions Bottom-Up
Les méthodes de construction Bottom-Up permettent de réaliser une distinction plus ﬁne en termes
de propriétés que celles relatives aux automates descendants; l’approche Bottom-Up permet en effet
de considérer les automates déterministes comme reconnaisseurs de tout langage rationnel d’arbres,
ce qui permet d’étendre les études possibles sur les langages et expressions d’arbres.
Par exemple, en étendant la caractérisation des automates de Glushkov de Caron et Ziadi [24], il
serait ensuite possible de s’intéresser à des propriétés de langages (telle que la 1-non-ambiguïté d’un
langage [15]) ou à des optimisations de mises à jour d’expressions et d’automates [12].
Cela permet également de considérer d’autres méthodes de construction d’automates, tel que la mé-
thode de dérivation de Brzozowski [16]. Avant d’aborder cette méthode par dérivation, commençons
par présenter les méthodes ascendantes de construction d’automates d’arbres.
2.1
L’automate des positions Bottom-Up
Les résultats de cette section sont tirés de [7, 8], écrits avec la collaboration de Samira Attou et de
Djelloul Ziadi.
Comme dans le cas de l’approche Top-Down, il est possible de déﬁnir une méthode de construction
Bottom-Up d’automates basée sur la construction de l’automate des positions. Il sufﬁt de considérer
alors les parents des différents symboles pouvant apparaître dans les arbres du langage au lieu des
ﬁls pour le calcul des transitions.
N.B. : Dans ce qui suit, nous ne considérons que des expressions dont les sous-expressions de la
forme E1 ·c E2 satisfont toutes le fait que c apparaisse dans E1.
Comme rappelé dans la Section 1.1, la construction de l’automate des positions est basée sur le calcul
de fonctions de positions. La seule différence ici avec la version Top-Down est l’utilisation non plus
de la fonction Follow, mais d’une fonction déterminant l’ensemble des parents possibles d’un sym-
bole. De plus, aﬁn de conserver une sémantique Bottom-Up, nous renommerons Racine la fonction
First.
Soient E une expression linéaire sur un alphabet gradué Σ et f un symbole de Σk. L’ensemble Racine(E),
sous-ensemble de Σ, contient les racines des arbres de L(E), c’est-à-dire
Racine(E) = {racine(t) | t ∈L(E)}.
(2.1)
L’ensemble Parent(E, f), sous-ensemble de Σ × N, contient le couple (g, i) s’il existe un arbre dans
L(E) avec un nœud étiqueté par g dont le i-ième ﬁls est un nœud étiqueté par f :
Parent(E, f) =
[
t∈L(E)
parent(t, f).
(2.2)
Exemple 10
Considérons l’alphabet gradué déﬁni par Σ2 = { f}, Σ1 = {g}, et Σ0 = {a, b}. Soient E et E les
expressions déﬁnies par
E = ( f(a, a) + g(b))∗a ·b f(g(a), b),
E = ( f1(a, a) + g2(b))∗a ·b f3(g4(a), b).

40
Chapitre 2. Les constructions Bottom-Up
Ainsi,
Racine(E) = {a, f1, g2},
Parent(E, f1) = {( f1, 1), ( f1, 2)},
Parent(E, a) = {( f1, 1), ( f1, 2), (g4, 1)},
Parent(E, g2) = {( f1, 1), ( f1, 2)},
Parent(E, b) = {( f3, 2)},
Parent(E, f3) = {(g2, 1)},
Parent(E, g4) = {( f3, 1)}.
La fonction Racine se calcule d’une façon similaire à la fonction First (voir Table 1.1). La fonction
Parent se calcule comme suit :
Parent(g(E1, . . . , En), f) =
[
i≤n
Parent(Ei, f) ∪{(g, i) | f ∈Racine(Ei)},
Parent(E1 + E2, f) = Parent(E1, f) ∪Parent(E2, f),
Parent(E1 ·c E2, f) = (Parent(E1, f) | f ̸= c) ∪Parent(E2, f)
∪(Parent(E1, c) | f ∈Racine(E2))
Parent(E∗c
1 , f) = Parent(E1, f) ∪(Parent(E1, c) | f ∈Racine(E1)),
TABLE 2.1 – Déﬁnition inductive de Parent.
Une fois ces fonctions calculées, il est alors possible de déﬁnir un automate reconnaissant le langage
dénoté par l’expression de départ. Pour cela, on construit un automate dont les états sont les positions
de l’expression (y compris les positions d’arité 0), les états correspondant aux racines étant ﬁnaux,
puis les transitions sont déterminées à l’aide de la fonction Parent.
Déﬁnition 4
L’automate des positions Bottom-Up PE d’une expression linéaire E sur un alphabet Σ est l’automate
(Σ, Pos(E), Racine(E), δ) déﬁni par
(( f1, . . . , fn), g, h) ∈δ ⇔h = g ∧∀i ≤n, (g, i) ∈Parent(E, fi).
Remarquons qu’en conséquence de la linéarité de E, PE est nécessairement déterministe.
Exemple 11
L’automate des positions Bottom-Up (Pos(E), Pos(E), Racine(E), δ) de l’expression E déﬁnie dans l’
Exemple 10 est déﬁnie comme suit :
Pos(E) = {a, b, f1, g2, f3, g4},
Racine(E) = {a, f1, g2},
δ = {(a, a), (b, b), ((a, a), f1, f1), ((a, f1), f1, f1), ((a, g2), f1, f1), (( f1, a), f1, f1),
(( f1, f1), f1, f1), (( f1, g2), f1, f1), ((g2, a), f1, f1), ((g2, f1), f1, f1),
((g2, g2), f1, f1), ( f3, g2, g2), ((b, g4), f3, f3), (a, g4, g4)}.
L’automate des positions Bottom-Up d’une expression (non nécessairement linéaire) E est obtenu en
calculant tout d’abord l’automate des positions Bottom-Up de son expression linéarisée E et ensuite
en appliquant le morphisme de délinéarisation h.
Un des avantages de cette méthode est qu’elle permet d’utiliser la structure des expressions ration-
nelles aﬁn de calculer un automate compressé de façon directe. En effet, les expressions rationnelles
factorisent naturellement la structure de transitions d’un automate des positions.

2.2. L’automate des parents
41
Déﬁnition 5
L’automate compressé des positions Bottom-Up C(E) d’une expression linéaire E est l’automate
(Σ, Pos(E), Racine(E), δ) déﬁni par
δ = {(Q1, . . . , Qk, f, { f}) | Qi = {g | ( f, i) ∈Parent(E, g)}}.
Exemple 12
Considérons l’expression E déﬁnie dans l’Exemple 10. L’automate compressé de E est représenté
Figure 2.1.
f1
g2
f3
b
g4
a
a
b
g2
g4
f1
f3
FIGURE 2.1 – L’automate compressé de l’expression ( f1(a, a) + g2(b))∗a ·b f3(g4(a), b).
L’automate des positions compressé d’une expression non nécessairement linéaire E est obtenu en
calculant tout d’abord l’automate des positions compressé de sa linéarisée E puis en appliquant le
morphisme de délinéarisation h.
2.2
L’automate des parents
Les résultats de cette section sont tirés de [7, 8], écrits avec la collaboration de Samira Attou et de
Djelloul Ziadi.
Dans cette section, nous allons déﬁnir l’automate des parents associé à une expression. Cet automate
est l’extension du cas classique de l’automate (de mots) des Follows [48] déjà présenté dans le cas
des automates Top-Down dans la Section 1.2.
Aﬁn de faciliter l’écriture des déﬁnitions, nous allons inclure le calcul de la fonction Racine dans celui
de la fonction Parent en ajoutant un symbole unaire $ qui n’est pas dans Σ tout en haut de l’arbre
syntaxique d’une expression, c’est-à-dire considérer une expression $(E) à la place de l’expression E.
En effet,
f ∈Racine(E) ⇔($, 1) ∈Parent($(E), f).
(2.3)
Autrement dit, les deux conditions suivantes sont équivalentes :
1. f est un état ﬁnal de l’automate des positions Bottom-Up,
2. ($, 1) est dans Parent($(E), f).
À l’aide de cette formule étendue, on peut alors calculer très simplement un automate plus petit que
l’automate des positions, comme suit.
Déﬁnition 6
L’automate des parents d’une expression linéaire E sur un alphabet gradué Σ est l’automate FE =
(Σ, Q, F, δ) déﬁni par
Q = {Parent($(E), f) | f ∈Σ},
F = {q ∈Q | $ ∈q},

42
Chapitre 2. Les constructions Bottom-Up
((Parent($(E), f1), . . . , Parent($(E), fn)), h, Parent($(E), g)) ∈δ
⇔h = g ∧∀i ≤n, (g, i) ∈Parent(E, fi).
En conséquence de la linéarité de E, PE est nécessairement déterministe.
Comme dans le cas de l’automate des Follows, nous allons montrer que l’automate des parents est
un quotient de l’automate (Bottom-Up) des positions. Pour cela, nous commençons par déﬁnir une
congruence basée sur la fonction Parent.
Déﬁnition 7
La congruence des parents associée à une expression linéaire E sur un alphabet Σ est la congruence
∼déﬁnie pour toutes deux positions p et p′ par
p ∼p′ ⇔Parent($(E), p) = Parent($(E), p′).
D’une façon équivalente, la congruence des parents est le noyau de la fonction envoyant un symbole
p sur Parent($(E), p). On pourra vériﬁer simplement que la congruence des parents d’une expression
linéaire E est une congruence Bottom-Up pour la fonction de transition de l’automate des positions
Bottom-Up de E. De plus, l’automate des parents associé à une expression linéaire E est isomorphe
au quotient de l’automate des positions Bottom-Up de E par la congruence des parents. Ainsi, l’au-
tomate des parents d’une expression linéaire E reconnaît L(E).
En appliquant le morphisme de délinéarisation h sur FE, on obtient l’automate des parents de l’ex-
pression E, automate qui reconnaît L(E).
Exemple 13
L’automate des parents (Pos(E), Pos(E)∼, Racine(E)∼, δ) de l’expression E déﬁnie dans l’Exemple 10
est obtenu en fusionnant les états f1 et g2 de PE, c’est à dire :
Pos(E) = {[a], [b], { f1, g2}, [ f3], [g4]},
Racine(E) = {[a], [ f1]},
δ = {(a, [a]), (b, [b]), (([a], [a]), f1, [ f1]), (([a], [ f1]), f1, [ f1]), (([ f1], a), f1, [ f1]),
(([ f1], [ f1]), f1, [ f1]), ([ f3], g2, [g2]), (([b], [g4]), f3, [ f3]), ([a], g4, [g4])}.
Comme dans le cas de l’automate des positions, l’approche Bottom-Up permet de bénéﬁcier facile-
ment de la structure des expressions pour factoriser les transitions dans un automate compressé. Il est
ainsi possible de calculer un automate compressé plus petit que l’automate compressé des positions,
comme suit.
Déﬁnition 8
L’automate compressé des parents CF(E) d’une expression linéaire E est l’automate déﬁni par le
quintuplet (Σ, Pos(E), Racine(E), δ) où
δ = {(Q1, . . . , Qk, f, {Parent($(E), f)}) | Qi = {Parent($(E), g) | ( f, i) ∈Parent($(E), g)}}.
En conséquence de l’Équation (2), la déﬁnition d’une congruence Bottom-Up pour A est exactement
la même que celle de l’Équation (1), en étendant la déﬁnition de la congruence aux ensembles de
cardinalité inférieures à 0 comme suit :
∅∼∅,
∅̸∼{_},
{p} ∼{q} ⇔p ∼q.
Ainsi, le quotient d’un automate compressé déterministe A = (Σ, Q, F, δ) par une congruence Bottom-
Up ∼est l’automate compressé A∼= (Σ, Q∼, F∼, δ′) où
δ′((Q1, . . . , Qm), f) = {φ(q) | q ∈δ((q1, . . . , qm), f) ∧∀i ≤m, [qi] ∈Qi}.

2.3. Le quotient et la dérivation Bottom-Up
43
On pourra alors vériﬁer que l’automate compressé des parents est un quotient de l’automate des
positions compressé par la congruence des parents. Ainsi, l’automate compressé des parents et l’au-
tomate des parents d’une expression linéaire E reconnaissent L(E).
En appliquant le morphisme de délinéarisation h sur CF E, on obtient l’automate compressé des
parents d’une expression E quelconque, automate reconnaissant L(E).
Exemple 14
Considérons l’expression E déﬁnie dans l’Exemple 10. L’automate compressé des parents de E est
représenté Figure 2.2.
{ f1, g2}
[ f3]
[b]
[g4]
[a]
a
b
g2
g4
f1
f3
FIGURE 2.2 – L’automate compressé des parents de ( f1(a, a) + g2(b))∗a ·b f3(g4(a), b).
2.3
Le quotient et la dérivation Bottom-Up
Les résultats de cette section sont tirés de [28] et de [6], écrits avec la collaboration de Samira Attou,
de Jean-Marc Champarnaud, de Nadia Ouali-Sebti et de Djelloul Ziadi.
Dans cette section, nous allons nous intéresser à une nouvelle forme de quotient de langages, le quo-
tient Bottom-Up. Remarquons qu’ici, nous n’allons pas produire un automate ﬁni reconnaissant le
langage dénoté par l’expression de départ. En effet, rien n’assure que le nombre de dérivées pro-
duites est ﬁni. Cependant, nous allons pouvoir simuler la construction d’une sous-partie ﬁnie de
cet automate, ce qui permettra d’en déduire un algorithme purement syntaxique de test d’apparte-
nance. Nous verrons également une construction inductive permettant, lorsqu’un point ﬁxe existe,
de construire un automate équivalent à celui des dérivées dans le cas des mots. Enﬁn, une des parti-
cularités de cette méthode est qu’elle est compatible avec tous les opérateurs booléens, y compris le
complémentaire.
La méthode de dérivation est la suivante. Au lieu de retirer les symboles depuis la racine, comme
dans le cas de la dérivation partielle présentée dans la Section 1.3.2, nous allons retirer les symboles
depuis les feuilles. Un nœud pourra alors être retiré une fois tous ses ﬁls éliminés. Cela implique
alors de considérer les arbres de différentes arités, et non plus seulement les arbres d’arité nulle.
Ainsi, dans la suite de cette section, nous considérerons des arbres k-aires, c’est-à-dire des arbres
auxquels il y aura k feuilles manquantes. Par exemple, alors que f(a, g(a, b)) est d’arité nulle, l’arbre
f(ε, g(a, b)) est unaire et f(ε, g(ε, ε)) ternaire. Pour rappel, pour un entier k donné, nous noterons Σ∗
k
l’ensemble des arbres k-aires sur un alphabet gradué Σ.
La composition des arbres peut être facilement étendue à la composition d’ensembles d’arbres de
même arité, c’est-à-dire à la composition d’un langage d’arbres k-aires S avec une liste de k arbres
l = (t1, . . . , tk) en posant
S ◦l =
[
t∈S
{t ◦l}.
Cependant, cette extension est assez contraignante en termes de construction : le même ordre est
utilisé en termes de composition d’arbres. Par exemple, lorsque S = { f(ε, ε), g(ε, ε)}, même si f(ε, ε) ◦
(a, b) = f(a, b) et g(ε, ε) ◦(b, a) = g(b, a), il n’existe pas de liste l telle que S ◦l = { f(a, b), g(b, a)}.
De même, il n’existe pas de liste depuis laquelle obtenir l’ensemble {h(a), h(b)} depuis l’ensemble
{h(ε)} par composition. Cette restriction réduit l’expressivité des formules dans la suite de cette

44
Chapitre 2. Les constructions Bottom-Up
étude. Une façon de résoudre cela est d’étendre la notation en indexant les ε, et en considérant alors
l’ordre des indices lors de la composition.
Plus concrètement, le symbole ε d’un arbre k-aire peut être remplacé par k occurrences de symboles
distincts εx1, . . ., εxk, où x1, . . ., xk sont k entiers de N \ {0}. Ainsi, pour un arbre k-aire t, nous noterons
Indε(t) l’ensemble {x1, . . . , xk} de ses ε-indices. Ce sous-ensemble ﬁni et naturellement ordonné de
N contient les indices xl des symboles εxl apparaissant dans t.
Déﬁnition 9
Un arbre k-aire t avec l’ensemble R de ses ε-indices est déﬁni inductivement comme suit
— t = εj avec j un entier; dans ce cas, k = 1 et R = {j};
— t = f(t1, . . . , tl) avec f un symbole de Σl et pour 1 ≤j ≤l, tj est un nj-aire arbre d’ε-indices
Rj, tel que 1 ≤j ≤j′ ≤l, Rj ∩Rj′ = ∅; dans ce cas, k = ∑1≤j≤l nj et R = S
1≤j≤l Rj.
Ainsi, la composition t ◦(t′
1, . . . , t′
k) substitue t′
l à εxl dans t, où Indε(t) = {x1, . . . , xk}. Remarquons
que tout arbre k-aire satisfait Card(Indε(t)) = k, et que les occurrences ne sont pas nécessairement
indexées par leur ordre d’apparence dans t ni de 1 à l.
Par exemple, soit
t = f(ε5, g(ε3, ε8)).
Alors
t ◦(a, b, a) = f(b, g(a, a)).
Dans cet exemple,
Indε(t) = {x1 = 3, x2 = 5, x3 = 8}
et ainsi ε3 (resp. ε5, ε8) est substitué par a (resp. b, a). Remarquons alors que l’arbre vide n’est plus un
élément identité, puisque son action peut modiﬁer l’indexation.
Par conséquent, la composition ◦est redéﬁnie inductivement comme suit : pour tout arbre m-aire
t = f(t1, . . . , tn) avec Indε(t) = {x1, . . . , xm}, pour tout m arbres t′
1, . . ., t′m avec des ensembles d’ε-
indices distincts deux à deux, on pose :
ε1 ◦(t′
1) = t′
1,
t ◦(t′
1, . . . , t′
m) = f((tj ◦(t′
k)xk∈Indε(tj))
1≤j≤n).
(2.4)
Un langage d’arbre L est dit homogène si tous les arbres qu’il contient sont de même arité et possèdent
le même ensemble d’ε-indices, et k-homogène s’il est homogène et que les arbres qu’il contient sont
d’arité k. Dans ce cas, on note Indε(L) cet ensemble.
L’ensemble des langages d’arbres sur un alphabet gradué Σ est noté L(Σ), et l’ensemble des lan-
gages k-homogènes par L(Σ)k pour tout entier k ≥0. Remarquons que l’union de deux langages
k-homogènes de mêmes ε-indices R est un langage k-homogène de mêmes ε-indices.
La composition ◦est étendue en une opération de L(Σ)k × (L(Σ))k vers L(Σ) : pour tout langage
L de L(Σ)k, pour tout k langages L1, . . ., Lk de L(Σ) tels que Indε(Li) ∩Indε(Lj) = ∅pour tout
1 ≤i < j ≤k,
L ◦(L1, . . . , Lk) = {t ◦(t1, . . . , tk) | t ∈L, ti ∈Li, i ≤k}.
Remarquons que si Lj est lj-homogène pour tout entier 1 ≤j ≤k, alors L ◦(L1, . . . , Lk) est ∑1≤j≤k lj-
homogène. Cette composition peut être itérée pour produire de nouveaux ensembles. Considérons
un langage 1-homogène L d’ ε-index {x} et un entier n. La composition itérée n◦est récursivement
déﬁnie par
L0◦= {εx},
Ln+1◦= Ln◦∪Ln◦◦L.
D’une façon similaire à l’étoile de Kleene obtenue depuis la concaténation dans le cas des mots, la
composition peut être répétée un nombre arbitraire de fois sur des langages unaires, déﬁnissant alors
une nouvelle opération. La fermeture de composition de L est le langage L⊛= S
k≥0 Lk◦. Remarquons
que L⊛est 1-homogène d’ε-index {x}.
Exemple 15
Considérons les ensembles S1 = { f(a, b)} et S2 = { f(ε1, b)}. Alors :
S∗a
1 = {a, f(a, b), f( f(a, b), b), . . .},

2.3. Le quotient et la dérivation Bottom-Up
45
S⊛
2 = {ε1, f(ε1, b), f( f(ε1, b), b), . . .}.
Le quotient Bottom-Up d’un langage d’arbres par rapport à un arbre est une opération qui sup-
prime des nœuds internes des arbres. La partie restante est habituellement appelée contexte dans
la littérature [33]; ici nous parlerons d’arbres k-aires, puisque nous considérons le paramètre k. Par
conséquent, nous réinterpréterons des résultats classiques en utilisant cette notion de quotient. Ainsi,
le quotient est l’opération duale de la composition : le quotient d’un arbre t par un arbre t′ est l’opé-
ration produisant l’ensemble t′−1(t) des arbres t′′ contenant une occurrence d’ε1 et tel que la substi-
tution de ε1 par t′ dans t′′ produit t. En conséquence directe, puisque ε1 peut apparaître dans t, la
production de t′′ nécessite une réindexation des ε-indices. Dans la suite, nous les incrémenterons.
Exemple 16
Soit t = f(g(b, b), ε1, h(g(b, b))) un arbre sur Σ, où b ∈Σ0, h ∈Σ1, g ∈Σ2 et f ∈Σ3. Soit t′ = g(b, b).
Alors
t′−1(t) = { f(ε1, ε2, h(g(b, b))), f(g(b, b), ε2, h(ε1))}.
En effet, pour tout t′′ de t′−1(t),
t′′ ◦(t′, ε1) = t.
Formalisons alors cette notion de quotient : Soient t un arbre k-aire de Σ∗et t′ un arbre k′-aire de Σ∗
tels que Indε(t′) ⊂Indε(t). Soient
R = Indε(t),
R′ = Indε(t′),
R′′ = {(xz)1≤z≤k′−k} = R \ R′.
Le quotient de t par rapport à t′ est le langage d’arbre k −k′ + 1-homogène t′−1(t) contenant tous les
arbres t′′ satisfaisant les deux conditions suivantes :
t = t′′ ◦(t′, (εxz)1≤z≤k−k′),
Indε(t′′) = {1, (xz + 1)1≤z≤k′−k}
(2.5)
Par conséquent,
ε−1
j (εl) =
(
ε1
si j = l,
∅
sinon,
(2.6)
t−1(t′) = {ε1} ⇔t = t′.
(2.7)
Déﬁnition 10
Soit Σ un alphabet gradué. Soit L un langage d’arbre de L(Σ) et t un arbre de Σ∗. Le quotient
Bottom-Up de L par t est le langage d’arbre
t−1(L) =
[
t′∈L
t−1(t′).
En conséquence directe de l’Équation (2.7), l’appartenance d’un arbre à un langage d’arbre peut être
redéﬁni en termes de quotient.
Proposition 2
Soit L un langage sur un alphabet gradué Σ et t un arbre de Σ∗. Alors
t ∈L ⇔ε1 ∈t−1(L).
Ces notions permettent de déﬁnir un automate d’arbre isomorphe à l’automate déterministe minimal
associé à un langage. Soit L un langage d’arbre de L(Σ)0. L’automate Bottom-Up quotient de L est

46
Chapitre 2. Les constructions Bottom-Up
l’automate AL = (Σ, Q, F, δ) déﬁni par
Q = {t−1(L) | t ∈TΣ},
F = {L′ ∈Q | ε1 ∈L′},
δ(t−1
1 (L), . . . , t−1
k (L), f) = { f(t1, . . . , tk)−1(L)}.
Il peut être montré qu’il n’existe pas d’automate déterministe plus petit reconnaissant L(voir l’auto-
mate des contextes de [18]).
2.3.1
Formules inductives du quotient pour les arbres
Pour déﬁnir inductivement le quotient d’un arbre par un autre arbre, il faut bien évidemment prendre
en compte la notion d’ε-indices : en effet, quotienter un arbre revient à remplacer un sous-arbre par
une occurrence d’ε1. Cependant, si ce symbole apparaît dans l’arbre de départ, l’objet obtenu ne
correspond plus à la déﬁnition d’un arbre, puisque tous les indices d’ε doivent être distincts, selon
la Déﬁnition 9. Une des solutions les plus simples est alors d’incrémenter tous les indices des ε de
l’arbre de départ.
Ainsi, pour un arbre k-aire t et un entier z donnés, nous noterons Incε(z, t) la substitution de tout
symbole εx par εx+z dans t, étendu linéairement sur un langage d’arbre L comme
Incε(z, L) = {Incε(z, t) | t ∈L}.
Trivialement, il s’ensuit que
(Incε(1, t)) ◦((εj)j∈Indε(t)) = t.
(2.8)
La déﬁnition du quotient d’un arbre par un autre arbre (Déﬁnition 10), n’est pas une formule in-
ductive. Par déﬁnition, il faut donc considérer les deux parties de l’induction : le quotient par un
arbre vide, puis le quotient par un symbole composé avec d’autres arbres. Le quotient Bottom-Up
d’un arbre par rapport à un symbole composé peut être inductivement déﬁni comme suit : puisque
le quotient est l’opération duale de la composition, calculer le quotient d’un arbre t par rapport à
un arbre t′ correspond à la substitution d’une occurrence de t′ dans t par ε1 et à l’incrémentation
des ε-indices. Dans ce cas, on remarquera que le quotient par un symbole f d’arité k correspond au
quotient par l’arbre f(ε1, . . . , εk).
Exemple 17
Considérons l’arbre t = f(h(a), ε1, a) avec f un symbole ternaire, h unaire et a 0-aire. Ainsi
a−1(t) = { f(h(ε1), ε2, a), f(h(a), ε2, ε1)},
a−1(a−1(t)) = { f(h(ε2), ε3, ε1), f(h(ε1), ε3, ε2)}.
Proposition 3
Soient Σ un alphabet gradué, k un entier et α un symbole de Σk. Alors :
α−1(εx) = ∅,
α−1( f(t1, . . . , tn)) =
[
1≤j≤n
f(t′
1, . . . , t′
j−1, α−1(tj), t′
j+1, . . . , t′
n)
∪{ε1 | f = α ∧(t1, . . . , tn) = (ε1, . . . , εn)},
avec x un entier dans N, f un symbole de Σn, t1, . . . , tn n arbres de Σ∗et ∀1 ≤z ≤n, t′z = Incε(1, tz).
Selon la déﬁnition du quotient (Équation (2.5) et Déﬁnition 10), quotienter par un ε indicé revient à
modiﬁer les ε-indices, que ce soit pour un arbre comme pour un langage.
Exemple 18
Considérons l’arbre t = f(h(a), ε2, ε5) avec f un symbole ternaire, h unaire et a 0-aire. Alors ε−1
5 (t) =
{ f(h(a), ε3, ε1)}.

2.3. Le quotient et la dérivation Bottom-Up
47
Proposition 4
Soit Σ un alphabet gradué. Soit L un langage k-homogène avec Indε(L) = {j1, . . . , jk}. Soit j un entier.
Alors :
ε−1
j (L) =
(
L ◦(εj1+1, . . . , εjz−1+1, ε1, εjz+1+1, . . . , εjk+1)
si j = jz ∈Indε(L),
∅
sinon.
Pour terminer, quotienter un arbre t par un arbre f(t1, . . . , tk) d’arité 0 peut se décrire inductivement
comme suit : tout d’abord, le quotient Uk de t par tk produit un ensemble d’arbres tels que la substi-
tution de ε1 par tk produit t. Puis le quotient Uk−1 de Uk par tk−1 produit un ensemble d’arbres tels
que la substitution d’ε2 par tk−1 puis d’ε1 par tk produit t. Par application successive, le quotient U1
de U2 par t1 produit un ensemble d’arbres tels que la substitution d’εk par tk, . . ., puis de ε1 par t1
produit t. Finalement, le quotient V de U1 par f (équivalent au quotient par f(ε1, . . . , εk)) est calculé,
produisant un ensemble d’arbres tels que la substitution d’ε1 par f(ε1, . . . , εk) produit un arbre tel
que la substitution de εk par tk, . . ., puis de ε1 par t1 produit t; par déﬁnition, V = f(t1, . . . , tk)−1(t).
Remarquons que la présence d’ε-indices implique leur réindexation : (I) si t contient une occurrence
d’un arbre vide (c’est-à-dire d’un sous-arbre εj pour un entier j), alors ces indices doivent être incré-
mentés k + 1 fois par 1, soit par ses k + 1 opérations de quotients; par conséquent, pour quotienter
par f(t1, . . . , tk), si une occurrence de εj est présente dans t, alors l’ensemble V obtenu par quotient de
U1 par f contient des arbres avec une occurrence de εj+k+1, à ré-indexer en εj+1 ; (II) si f(t1, . . . , tk)
contient un arbre vide, εj dans tl par exemple, alors l’ensemble Ul+1, contenant les arbres vides
(ε1, . . . , εk−l) (si t contient des occurrences de (tl+1, . . . , tk)) et l’arbre vide εj+k−l, ne peut pas être
quotienté par tl : si tl est présent dans t, alors ses ε-indices ont été incrémentés, et alors Incε(k −l, tl)
doit être considéré pour quotienter Ul+1.
Exemple 19
Considérons l’arbre t = f(h(a), ε1, g(a, b)) avec f un symbole ternaire, g binaire, h unaire, a et b
0-aires. Alors :
b−1(t) = { f(h(a), ε2, g(a, ε1))},
a−1(b−1(t)) = { f(h(ε1), ε3, g(a, ε2)), f(h(a), ε3, g(ε1, ε2))},
g(a, b)−1(t) = g−1(a−1(b−1(t)))
= { f(h(a), ε2, ε1)}.
Plus formellement, le quotient est déﬁni inductivement comme suit.
Proposition 5
Soit Σ un alphabet gradué. Soit t = f(t1, . . . , tk) un arbre l-aire de Σ∗avec f un symbole de Σk et
(t1, . . . , tk) k arbres de Σ∗différents de (ε1, . . . , εk). Soit u un arbre de Σ∗avec Indε(u) = {x1, . . . , xn}.
Soient
{y1, . . . , yn−l} = Indε(u) \ Indε(t)
et ∀1 ≤j ≤k, t′
j = Incε(k −j, tj). Alors :
t−1(u) = ( f −1(t′
1
−1(· · · (t′
k
−1(u)) · · · )) ◦(ε1, (εyz+1)1≤z≤n−l).
L’indexation des ε joue un rôle fondamental pendant les calculs : elle est nécessaire pour considérer
la non-commutativité de l’opérade libre des arbres (c’est-à-dire que f(a, b) ̸= f(b, a)).
Exemple 20
Considérons l’arbre t = g(h(a), b). Alors :
b−1(t) = {g(h(a), ε1)},
a−1(t) = {g(h(ε1), b)},

48
Chapitre 2. Les constructions Bottom-Up
a−1(b−1(t)) = {g(h(ε1), ε2)},
b−1(a−1(t)) = {g(h(ε2), ε1)},
h(a)−1(b−1(t)) = h−1(g(h(ε1), ε2)) ◦(ε1, ε2)
= {g(ε1, ε3) ◦(ε1, ε2)}
= {g(ε1, ε2)},
h(b)−1(a−1(t)) = g(h−1(h(ε2)), ε2)
= ∅,
g(h(a), b)−1(t) = g−1(h(a)−1(b−1(t))))
= g−1(g(ε1, ε2))
= {ε1}.
Ainsi,
{ε1} = g(h(a), b)−1((g(h(a), b))
̸= g(h(b), a)−1((g(h(a), b))) = ∅.
2.3.2
Formules inductives du quotient pour les opérations sur les langages
L’union
En conséquence directe de la Déﬁnition 10, la formule inductive de l’union est la suivante.
Lemme 1
Soit Σ un alphabet gradué. Soient t un arbre de Σ∗, et L1 et L2 deux langages sur Σ. Alors :
t−1(L1 ∪L2) = t−1(L1) ∪t−1(L2).
Ainsi, puisque l’union est distributive sur la composition, en conséquence directe du Lemme 1 de la
Proposition 5, le résultat suivant est vériﬁé.
Corollaire 2
Soit Σ un alphabet gradué. Soit t = f(t1, . . . , tk) un arbre l-aire tel que f est dans Σk et (t1, . . . , tk)
est un k-uplet d’arbres dans Σ∗distinct de (ε1, . . . , εk). Soit L un langage k-homogène sur Σ avec
Indε(L) = {x1, . . . , xk}. Soient {y1, . . . , yn−l} = Indε(L) \ Indε(t) et ∀1 ≤j ≤k, t′
j = Incε(k −j, tj).
Alors :
t−1(L) = ( f −1(t′
1
−1(· · · (t′
k
−1(L)) · · · )) ◦(ε1, (εyz+1)1≤z≤n−l).
Selon le Corollaire 2, il sufﬁt alors de montrer comment calculer inductivement le quotient d’un
langage par rapport à un symbole de Σ.
Le produit de substitution
N.B. : Dans la suite de cette partie, aﬁn de préserver l’homogénéité, nous considérons que l’opération
de substitution L1 ·a L2 pour un symbole nullaire a n’est déﬁnie que si L1 est homogène et si L2 est
0-homogène.
Calculer le b-produit revient à remplacer toutes les occurrences d’un symbole 0-aire b dans un arbre
t par un langage L. Ainsi, quotienter t par un symbole α est réalisé en suivant les conditions sui-
vantes : (1) les occurrences d’α devant être effacées par le quotient dans t ·b L peuvent apparaître
dans L. Cependant, calculer directement t ·b α−1(L) peut produire un langage contenant des arbres
avec plusieurs occurrences d’ε1. Ainsi, il faut tout d’abord effacer une occurrence de b dans t en cal-
culant b−1(t), puis considérer la substitution des autres occurrences de b par L dans t, puis composer

2.3. Le quotient et la dérivation Bottom-Up
49
cette nouvelle occurrence d’ε1 dans b−1(t) avec le quotient de L, soit
(b−1(t) ·b L) ◦1 α−1(L),
où ◦1 est la composition partielle déﬁnie par
L ◦1 L′ = L ◦(L′, (εl)j2≤l≤jk)
avec Indε(L) = {j1, . . . , jk}; (2) lorsque α ̸= b, les occurrences d’α retirées lors du quotient de t ·b L
peuvent apparaître également dans t. Dans ce cas, une occurrence d’α doit être substituée par ε1, et
les occurrences de b dans t toujours remplacées par L, soit α−1(t) ·b L.
Exemple 21
Considérons l’arbre t = f(h(a), ε1, g(a, b)) ·a b = f(h(b), ε1, g(b, b)) avec f un symbole ternaire, g
binaire, h unaire, a et b 0-aires. Alors :
b−1(t) = b−1( f(h(a), ε1, g(a, b))) ·a {b}
∪(a−1( f(h(a), ε1, g(a, b))) ·a {b}) ◦ε1
= { f(h(a), ε2, g(a, ε1))} ·a {b}
∪({ f(h(ε1), ε2, g(a, b)), f(h(a), ε2, g(ε1, b))} ·a {b}) ◦ε1
= { f(h(b), ε2, g(b, ε1)), f(h(ε1), ε2, g(b, b)), f(h(b), ε2, g(ε1, b))}.
Récapitulons ainsi dans le lemme suivant.
Lemme 2
Soit Σ un alphabet gradué. Soient t un arbre k-aire de Σ∗et L un langage 0-homogène. Soient α un
symbole de Σ et bun symbole de Σ0. Alors :
α−1(t ·b L) =





(b−1(t) ·b L) ◦1 b−1(L)
si α = b,
α−1(t) ·b L ∪(b−1(t) ·b L) ◦1 α−1(L)
si α ∈Σ0 \ {b},
α−1(t) ·b L
sinon.
Ainsi, en conséquence direct du lemme précédent, puisque
L ·b L′ =
[
t∈L
t ·b L′,
Proposition 6
Soit Σ un alphabet gradué. Soient L1 un langage k-homogène, L2 un langage 0-homogène, α un
symbole de Σ et b un symbole de Σ0. Alors :
α−1(L1 ·b L2) =





(b−1(L1) ·b L2) ◦1 b−1(L2)
si α = b,
α−1(L1) ·b L2 ∪(b−1(L1) ·b L2) ◦1 α−1(L2)
si α ∈Σ0 \ {b},
α−1(L1) ·b L2
sinon.
Le produit de composition
Composer un arbre k-aire t, qui satisfait Indε(t) = {x1, . . . , xk}, avec k arbres t1, . . . , tk est l’action
d’accrocher ces arbres à t aux positions où les symboles εx1, . . . , εxk apparaissent. Ainsi, l’arbre obtenu
t′ peut être vu comme un arbre avec une partie supérieure contenant t et des parties inférieures
contenant exactement les arbres t1, . . . , tk. Par conséquent, si α apparaît dans un arbre inférieur tj, cet
arbre doit être quotienté par α alors que les autres parties se voient toutes ε-incrémentées. De plus,
si n arbres de t1, . . . , tk sont égaux à ε1, . . . , εn, par exemple tp1, . . . , tpn, et si t′ = α(εxp1, . . . , εxpn)

50
Chapitre 2. Les constructions Bottom-Up
apparaît dans t, alors t′ doit être substitué par ε1 et les autres parties inférieures tj avec j ̸= pm,
m ∈{1, . . . , n} ε-incrémentées, puisque l’opération inverse produit t.
Exemple 22
Considérons l’arbre t = f(h(a), h(ε4), ε2) ◦(a, ε1) = f(h(a), h(ε1), a) avec f un symbole ternaire, h
unaire et a 0-aire. Alors :
h−1(t) = h(ε4)−1(t) ◦(ε1, a)
= { f(h(a), ε1, ε3)} ◦(ε1, a)
= { f(h(a), ε1, a)}
Lemme 3
Soit Σ un alphabet gradué. Soient t un arbre k-aire avec Indε(t) = {j1, . . . , jk} et t1, . . . , tk k arbres.
Soit αun symbole de Σn. Alors :
α−1(t ◦(t1, . . . , tk)) =
[
1≤j≤k
t ◦((Incε(1, tl))1≤l≤j−1, α−1(tj), (Incε(1, tl))j+1≤l≤k)
∪





α((εjpl )1≤l≤n)−1(t) ◦(ε1, (Incε(1, tl))1≤l≤k|∀j,l̸=pj)
si ∀1 ≤l ≤n, ∃1 ≤pl ≤k, tpl = εl,
∅
sinon.
Ainsi, puisque L ◦(L1, . . . , Lk) = S
t∈L,(t1,...,tk)∈L1×···×Lk t ◦(t1, . . . , tk),
Proposition 7
Soit Σ un alphabet gradué. Soient L un langage k-homogène avec Indε(L) = {j1, . . . , jk}, α un sym-
bole de Σn et L1, . . . , Lk k langages. Alors :
α−1(L ◦(L1, . . . , Lk)) =
[
1≤j≤k
L ◦((Incε(1, Ll))1≤l≤j, α−1(Lj), (Incε(1, Ll))j+1≤l≤k)
∪





α((εjpl )1≤l≤n)−1(L) ◦(ε1, (Incε(1, Ll))1≤l≤k|∀z,l̸=pz))
si ∀1 ≤l ≤n, ∃1 ≤pl ≤k, εl ∈Lpl
∅
sinon.
La composition itérée
La composition itérée ne peut être quotientée que par un symbole α d’arité n = 0 ou n = 1 unique-
ment, puisque tout langage obtenu par composition itérée est 1-homogène.
Si n = 1, puisque L⊛est obtenue par l’application de la composition un nombre arbitraire de fois,
alors quotienter par α revient à quotienter un arbre t de L par α puis le raccrocher au langage obtenu
par une application d’un nombre arbitraire de composition, c’est-à-dire L⊛. D’une façon équivalente,
l’occurrence d’α à effacer apparaît dans une partie inférieure d’un arbre. Cependant, lorsque n = 0,
l’occurrence d’α à effacer peut apparaître à n’importe quel niveau : elle peut être localisée dans une
partie supérieure de L⊛tout comme dans une partie inférieure de L⊛, par exemple lorsque l’arbre
t à quotienter appartient à L⊛◦{t′} ◦L⊛avec t′ un arbre de L dans lequel apparaît une occurrence
d’α. Dans ce cas, t′ doit être quotienté par α, créant alors une occurrence de ε1, ce qui force l’ancien
unique indice ε de L⊛à être incrémenté, en conformité avec la déﬁnition du quotient.
Exemple 23
Considérons le langage
L = ( f(h(a), ε1, a))⊛

2.3. Le quotient et la dérivation Bottom-Up
51
= {ε1, f(h(a), ε1, a), f(h(a), f(h(a), ε1, a), a), . . .}
avec f un symbole ternaire, h unaire et a 0-aire. Alors :
a−1(L) = ( f(h(a), ε1, a)⊛◦a−1( f(h(a), ε1, a))) ◦(ε1, f(h(a), ε2, a)⊛)
= ( f(h(a), ε1, a)⊛◦{ f(h(ε1), ε2, a), f(h(a), ε2, ε1))})
◦(ε1, f(h(a), ε2, a)⊛)
= ( f(h(a), ε1, a)⊛
◦{ f(h(ε1), f(h(a), ε2, a)⊛, a), f(h(a), f(h(a), ε2, a)⊛, ε1)})
= { f(h(ε1), ε2, a), f(h(a), ε2, ε1), f(h(ε1), f(h(a), ε2, a), a),
f(h(a), f(h(a), ε2, a), ε1), f(h(a), f(h(ε1), ε2, a), a),
f(h(a), f(h(a), ε2, ε1), a), . . .}
Ainsi :
Proposition 8
Soit Σ un alphabet gradué. Soit L un langage 1-homogène. Soit α un symbole de Σ. Alors :
α−1(L⊛) =
(
(L⊛◦(α−1(L))) ◦(ε1, Incε(1, L⊛))
si α ∈Σ0,
(L⊛◦(α−1(L)))
sinon.
La substitution itérée
N.B. : Dans la suite de cette partie, aﬁn de préserver l’homogénéité, nous considérons que l’opération
de substitution itérée L∗a pour un symbole nullaire a n’est déﬁnie que si L est 0-homogène.
Dans le cas de la substitution itérée, deux cas sont à considérer lors du quotient par α : lorsque b = α,
alors une occurrence de b dans un arbre de L doit être transformée en ε1, alors que les autres peuvent
encore être substituées par L. Mais lorsque α ̸= b, alors la situation est plus complexe. Comme dans le
second cas de la composition itérée, l’occurrence d’α à retirer peut apparaître n’importe où : elle peut
être localisée sous une partie supérieure de L∗b une fois substituée depuis une occurrence de b, mais
également sous une partie inférieure de L∗b, si elle contient aussi une occurrence de b. Cela peut se
produire lorsque l’arbre t à quotienter appartient à L∗b ·b {t′} ·b L∗b où t′ est un arbre de L contenant
α. Dans ce cas, L doit tout d’abord être quotienté par b pour créer une nouvelle occurrence de ε1, où
le quotient α−1(L) sera alors raccroché. Puis un b-produit est ajouté, puisque toute occurrence de b
peut toujours être substituée par L∗b.
Exemple 24
Considérons le langage
L = ( f(h(a), b, a))∗a
= {a, f(h(a), b, a), f(h( f(h(a), b, a)), b, a), f(h(a), b, f(h(a), b, a)), . . .}
avec f un symbole ternaire, h unaire, a et b 0-aires. Alors :
b−1(L) = (a−1( f(h(a), b, a)))
⊛◦b−1( f(h(a), b, a)) ·a ( f(h(a), b, a))∗a
= { f(h(ε1), b, a), f(h(a), b, ε1)}⊛◦{ f(h(a), ε1, a)} ·a ( f(h(a), b, a))∗a
= { f(h(a), ε1, a), f(h( f(h(a), ε1, a)), b, a), f(h( f(h(a), b, a)), ε1, a), . . .}
Par conséquent :
Proposition 9
Soit Σ un alphabet gradué. Soit L un langage 0-homogène. Soient α un symbole de Σ et b un symbole
de Σ0. Alors :
α−1(L∗b) =
(
(b−1(L))⊛·b L∗b
si α = b,
((b−1(L))⊛◦(α−1(L))) ·b L∗b
sinon.

52
Chapitre 2. Les constructions Bottom-Up
2.3.3
Un test d’appartenance purement syntaxique
Un langage rationnel peut être associé à au moins une combinaison d’opérations rationnelles, comme
dans le cas des expressions rationnelles. Nous appellerons cette combinaison arbre syntaxique d’un
langage. Les formules de la section précédente permettent de réaliser le test d’appartenance sur un
arbre syntaxique d’un langage puisque, selon la Proposition 2, il sufﬁt de tester si ε1 est dans t−1(L)
pour décider de l’appartenance de t à L. Montrons alors comment calculer le booléen Null(L) =
(ε1 ∈L) récursivement.
Null(∅) = Faux,
Null({t}) =
(
Vrai
si t = ε1,
Faux
sinon,
Null(L ∪L′) = Null(L) ∨Null(L′),
Null(L ·a L′) = Null(L),
Null(L∗a) = Faux,
Null(L⊛) = Vrai,
Null(L ◦(L1, . . . , Lk) =
(
Null(L) ∧Null(L1)
si k = 1
Faux
sinon.
TABLE 2.2 – Déﬁnition inductive de Null.
En conséquence directe,
Théorème 3
Pour tout arbre syntaxique d’un langage L, l’appartenance d’un arbre t à L peut être décidé en utili-
sant les formules de quotient.
Exemple 25
Considérons l’alphabet Σ avec Σ0 = {a, b}, Σ1 = {h} et Σ2 = { f}. Calculons alors les quotients du
langage
L1 = h⊛◦L2
avec
L2 = (h(a) + f(b, b))∗b.
Tout d’abord, considérons les langages
L3 = ( f(ε1, b) + f(b, ε1))⊛,
L′
3 = ( f(ε2, b) + f(b, ε2))⊛.
Alors :
b−1(L3) = (L3 ◦( f(ε1, ε2) + f(ε2, ε1))) ◦(ε1, L′
3)
= L3 ◦( f(ε1, L′
3) + f(L′
3, ε1))
= L4,
f −1(L4) = L3 ◦( f −1 f(ε1, L′
3) + f −1 f(L′
3, ε1))
= L3.
Considérons maintenant L2 = (h(a) + f(b, b))∗b. Alors :
a−1(L2) = (L3 ◦h(ε1)) ·b L2,
h(a)−1(L2) = L3 ·b L2,
b−1(L2) = L3 ·b L2,

2.3. Le quotient et la dérivation Bottom-Up
53
b−1(b−1(L2)) = (b−1(L3) ·b L2) ◦1 (b−1(L2))
= (L4 ·b L2) ◦1 (L3 ·b L2)
= (L4 ◦1 L3) ·b L2
= (L3 ◦( f(L3, L′
3) + f(L′
3, L3))) ·b L2,
f(b, b)−1(L2) = L3 ·b L2,
a−1(a−1(L2)) = a−1((L3 ◦h(ε1))) ·b L2 ∪(b−1(L3 ◦h(ε1)) ·b L2) ◦1 a−1(L2)
= (L4 ◦h(ε2)) ·b L2) ◦1 a−1(L2)
= (L4 ◦h(a−1(L2))) ·b L2
= L5,
f(a, a)−1(L2) = f −1(L5)
= ∅.
Finalement, considérons L1 = h⊛◦L2.
a−1(L1) = h⊛◦a−1(L2)
= h⊛◦((L3 ◦h(ε1)) ·b L2)
= X1,
h(a)−1(L1) = h⊛◦h(a)−1(L2)
= h⊛◦(L3 ·b L2)
= X2,
b−1(L1) = h⊛◦b−1(L2)
= h⊛◦(L3 ·b L2)
= X2,
h(b)−1(L1) = h−1(X2)
= h−1h⊛
= h⊛
= X3,
h(h(b))−1(L1) = h−1h⊛
= h⊛
= X3,
f(b, b)−1(L1) = h⊛◦f(b, b)−1(L2)
= h⊛◦(L3 ·b L2)
= X2.
Remarquons également que
f(a, a)−1(L1) = h⊛◦( f(a, a)−1(L2)) = ∅.
Ainsi, l’automate quotient de L1 est représenté Figure 2.3, avec
Null(X2) = Null(X3)
= Vrai,
Null(X1) = Faux.

54
Chapitre 2. Les constructions Bottom-Up
X1
X2
X3
a
b
h
h
h
f
FIGURE 2.3 – L’automate minimal de L1.
2.3.4
Extension aux opérations booléennes
Il est possible d’étendre la formule de quotient à toutes les opérations booléennes. En effet, l’union
de langage n’est pas la seule opération compatible. Le complémentaire l’est également. Cependant,
l’opération que nous allons considérer n’est pas le complémentaire universel. Nous allons considérer
une version restreinte, le complémentaire gradué, restreint aux langages homogènes.
Par exemple, pour un langage k-homogène L donné, on note ¬L l’ensemble
{t ∈Σ∗
k | t /∈L, Indε(t) = Indε(L)}.
(2.9)
En restreignant d’une façon similaire l’union à des paires de langages ayant les mêmes ε-indices, on
peut redéﬁnir les opérations booléennes classiques comme combinaisons d’unions et de complémen-
taires (par exemple la différence symétrique).
Le quotient d’un langage complémenté se calcule selon la formule classique suivante.
Proposition 10
Soient L un langage homogène sur un alphabet Σ et t ∈Σ∗. Ainsi
t−1(¬L) = ¬(t−1(L)).
Ainsi, en conséquence du quotient d’une union,
Corollaire 3
Soient (L1, . . . , Lk) des langages k′-homogènes de mêmes ε-indices et op une opération booléenne.
Alors pour tout arbre t de Σ∗
t−1(op(L1, . . . , Lk)) = op(t−1(L1), . . . , t−1(Lk)).
2.3.5
Expressions étendues homogènes
L’intégration des opérateurs (homogènes) booléens dans les expressions d’arbres nécessite une légère
modiﬁcation syntaxique. Supposons par exemple le test d’appartenance de l’arbre vide εj dans le
complémentaire d’un langage vide. Sa présence dépend en fait des ε-indices choisis dans la déﬁnition
de l’ensemble vide.
Aﬁn de lever toute ambiguïté, nous indexerons les occurrences de l’ensemble vide par l’ensemble
des ε-indices nécessaire à la déﬁnition de son homogénéité.
Ainsi, une expression étendue homogène E sur un alphabet Σ est déﬁnie inductivement comme suit
E = f(E1, . . . , En),
E = εj,
E = ∅I,
E = op(E1, . . . , En),
E = E′ ◦(E1, . . . , En),
E = E⊛
1 ,
E = E1 ·a E2,
E = E∗a
1 ,
(2.10)
où f est un symbole de Σn, (E′, E1, . . . , En) sont (n + 1) expressions sur Σ, j est un entier positif, I
est un ensemble d’entiers, op est un opérateur booléen n-aire et a est un symbole de Σ0. L’expression
∅∅sera aussi notée ∅.

2.3. Le quotient et la dérivation Bottom-Up
55
La déﬁnition syntaxique précédente n’assure pas que l’expression permette de dénoter un langage
homogène. Il faut s’assurer en effet qu’elle soit valide, c’est-à-dire que les ε-indices des expressions la
composant soient inter-compatibles. Par exemple, dans une composition E ◦(E1, . . . , En), il faut que :
— E soit valide,
— il doit y avoir exactement n ε-indices différents apparaissant dans E,
— les ensembles d’ε-indices des expressions E1, . . . , En doivent être deux à deux disjoints.
Dans le cas d’un opérateur booléen, ses opérandes doivent être valides et avoir les mêmes ε-indices.
Enﬁn, les opérateurs classiques (d’expressions d’arbres) doivent satisfaire les propriétés d’homogé-
néité décrites dans les sections précédentes.
Ainsi, le langage L(E) dénoté par une expression valide E d’ ε-indices I est déﬁni inductivement
comme suit
L( f(E1, . . . , En)) = f(L(E1), . . . , L(En)),
L(εj) = {εj},
L(op(E1, . . . , En)) = op′(L(E1), . . . , L(En)),
L(∅I) = ∅,
L(E′ ◦(E1, . . . , En)) = L(E′) ◦(L(E1), . . . L(En)),
L(E⊛
1 ) = (L(E1))⊛,
L(E1 ·a E2) = L(E1) ·a L(E2),
L(E∗a
1 ) = (L(E1))∗a,
où f est un symbole de Σn, (E′, E1, . . . , En) sont (n + 1) expressions d’arbres sur Σ, j est un entier
positif, op est un opérateur booléen n-aire, op′ est l’opération booléenne n-aire sur des langages
homogènes d’ε-indices I associée à op et a est un symbole de Σ0.
Il sufﬁt alors de transcrire au niveau des expressions les formules de quotient aﬁn d’obtenir les for-
mules de dérivation d’expression.
La dérivation d’une expression E valide par εj, notée dεj(E) est obtenue en incrémentant les ε-indices
de E par 1 excepté εj, remplacé par ε1.
La dérivation d’une expression E valide, dont les ε-indices sont {1, . . . , n}, par un symbole α de Σn
est l’expression inductivement calculée comme suit :
dα(∅I) = ∅{1}∪{i+1|i>n,i∈I},
dα(ε1) = ∅{1},
dα(α(ε1, . . . , εn)) = ε1,
dα( f(E1, . . . , Em)) = ∑
1≤j≤n
f(E′
1, . . . , E′
j−1, dα(tj), E′
j+1, . . . , E′
m),
dα(op(E1, . . . , Ek)) = op(dα(E1), . . . , dα(Ek)),
dα(E1 ·b E2) =





(db(E1) ·b E2) ◦1 db(E2)
if α = b,
dα(E1) ·b E2 + (db(E1) ·b E2) ◦1 dα(E2)
if α ∈Σ0 \ {b},
dα(E1) ·b E2
otherwise,
dα(E ◦(E1, . . . , Ek)) = ∑
1≤j≤k
E ◦((Incε(1, El))1≤l≤j, dα(Ej), (Incε(1, El))j+1≤l≤k)
+







dα((εjpl )
1≤l≤n)(E) ◦(ε1, (Incε(1, El))1≤l≤k|∀z,l̸=pz)
if ∀1 ≤l ≤n, ∃1 ≤pl ≤k, εl ∈L(Epl)
∅Indε(E◦(E1,...,Ek))\{1,...,n}
otherwise,
dα(E⊛) =
(
(E⊛◦(dα(E))) ◦(ε1, Incε(1, E⊛))
if α ∈Σ0,
(E⊛◦(dα(E)))
otherwise,
dα(E∗b) =
(
(db(E))⊛·b E∗b
if α = b,
((db(E))⊛◦(dα(E))) ·b E∗b
otherwise,
où dα(εj1,...,εjn)(E) = dα(dεj1+n−1(· · · dεjn−1+1(dεjn(E)) · · · )), où pour tout entier i l’expression E′
i vaut
Incε(1, Ei), et où ◦1 est la composition partielle E ◦1 E′ = E ◦(E′, (εl)j2≤l≤jk) avec Indε(E) = {j1, . . . , jk}.

56
Chapitre 2. Les constructions Bottom-Up
La dérivation par un arbre t = f(t1, . . . , tn) de Σ∗tel que Indε(t) ⊆Indε(E). est l’expression déﬁnie
par
dt(E) = (d f (dt′
1(· · · (dt′
k(E)) · · · )) ◦(ε1, (εyz+1)1≤z≤n−l)),
où {y1, . . . , yn−l} = Indε(E) \ Indε(t) et ∀1 ≤j ≤k, t′
j = Incε(k −j, tj).
La dérivation par un arbre est une implantation du calcul du quotient : en effet, la dérivée d’une
expression valide E par rapport à un arbre t dénote t−1(L(E)).
Exemple 26
Considérons l’alphabet gradué déﬁnit par Σ2 = { f}, Σ1 = {g} et Σ0 = {a, b, c} et soit E l’expression
déﬁnie par
E = E1 ·a E2,
avec E1 = ¬(g(a)∗a) et E2 = f( f(a, a), a). Montrons comment calculer la dérivée de E par t =
f( f(a, a), a). Tout d’abord, calculons la dérivée de E2 par t :
da(E2) = f( f(ε1, a) + f(a, ε1), a) + f( f(a, a), ε1),
da(da(E2)) = f( f(ε2, ε1) + f(ε1, ε2), a) + f( f(ε2, a) + f(a, ε2), ε1)
+ f( f(ε1, a) + f(a, ε1), ε2),
da(da(da(E2))) = f( f(ε3, ε2) + f(ε2, ε3), ε1) + f( f(ε3, ε1) + f(ε1, ε3), ε2)
+ f( f(ε2, ε1) + f(ε1, ε2), ε3),
d f (a,a)(da(E2)) = d f (ε1,ε2)(da(da(da(E2)))) ◦(ε1, ε2)
= (∅1,4 + ∅1,4 + f(∅1 + ε1, ε4)) ◦(ε1, ε2) = f(ε1, ε2),
dt(E2) = d f (ε1,ε2)(d f (a,a)(da(E2))) = ε1.
Par soucis de concision, posons
E′ = ¬(g(ε1)⊛) ·a E2,
E′′ = ¬(∅{1,2}) ·a E2.
Ainsi :
da(E) = E′ ◦da(E2),
d f (a,a)(da(E)) = E′′ ◦( f(ε1, a), ε4) ◦(ε1, Incε(1, da(E2))) + E′ ◦d f (a,a)(da(E2)),
dt(E) = E′.
2.3.6
Construction d’automate associée
Montrons alors comment construire à partir d’une expression E avec Indε(E) = ∅un automate à
partir d’un processus itératif.
Pour une expression E valide sur un alphabet Σ, calculons tout d’abord l’ensemble
D0(E) = {da(E) | a ∈Σ0}.
Depuis cet ensemble, considérons l’automate A0 = (Σ, D0(E), F0, δ0) où
F0 = {E′ ∈D0(E) | ε1 ∈L(E′)},
δ0 = {(a, da(E)) | a ∈Σ0}.
À partir de cette étape, on peut choisir une fonction tree0 associant toute expression E′ de D0(E) avec
un arbre t tel que
tree0(E′) = t ⇒dt(E) = E′,

2.3. Le quotient et la dérivation Bottom-Up
57
en choisissant pour toute expression E′ de D0(E) un symbole a ∈Σ0 tel que (a, E′) ∈δ0. Depuis cette
base d’induction, considérons l’ensemble de transitions δn déﬁni inductivement comme suit
δn = {((E′
1, . . . , E′
m), f, dt(E)) |t = f(treen−1(E′
1), . . . , treen−1(E′
m)),
f ∈Σm,
E′
1, . . . , E′
m ∈Dn−1(E)}.
(2.11)
Considérons également l’ensemble Dn(E) = Dn−1(E) ∪π3(δn), où π3 est la projection classique
π3(X) = {z | (_, _, z) ∈X}. Clairement, il est encore possible de choisir une fonction treen associant
à toute expression E′ de Dn(E) un arbre t rel que
treen(E′) = t ⇒dt(E) = E′,
en choisissant une transition ((E′
1, . . . , E′m), f, E′) in δn pour toute expression E′ de Dn(E) \ (Dn−1(E))
et en déﬁnissant t comme f(treen−1(E′
1), . . . , treen−1(E′
k)). Puis, en considérant l’ensemble
Fn = {E′ ∈Dn(E) | ε1 ∈L(E′)},
(2.12)
on peut déﬁnir l’automate An = (Σ, Dn(E), Fn, δn). Finalement, soit A(E) le point ﬁxe, s’il existe, de
cette construction (en fonction du choix des fonctions tree∗), appelé automate des dérivées Bottom-Up
de E.
Cette construction produit par déﬁnition un automate déterministe. De plus, la validité de la construc-
tion ne dépend pas des choix des fonctions tree∗. Enﬁn, l’automate des dérivées Bottom-Up d’une
expression E reconnaît L(E).
On peut remarquer que lorsque Σn = ∅pour tout n ≥2, les règles ACI de la somme (associativité,
commutativité et idempotence) sufﬁsent à la démonstration de l’existence du point ﬁxe, d’une façon
similaire à celle de la construction de l’automate (de mots) de Brzozowski [16]. Cependant, ce n’est
pas garanti dans le cas général.
Exemple 27
Considérons les quatre expressions déﬁnies dans l’Exemple 26, c’est-à-dire
E = E1 ·a E2,
E1 = ¬(g(a)∗a),
E2 = f( f(a, a), a),
E′ = ¬(g(ε1)⊛) ·a E2.
Montrons comment calculer l’automate associé à E. Tout d’abord, calculons A0 = (Σ, D0(E), F0, δ0) :
par déﬁnition, D0(E) = {da(E), db(E), dc(E)}. Ainsi,
da(E) = E′ ◦da(E2),
db(E) = dc(E) = ¬(∅{1}) ·a E2,
D0(E) = {da(E), db(E)},
F0 = {db(E)},
δ0 = {(a, da(E)), (b, db(E)), (c, db(E))}.
L’automate A0 est représenté Figure 2.4.
da(E)
db(E)
a
b, c
FIGURE 2.4 – L’automate A0.
Choisissons alors une fonction tree0 : tree0(da(E)) = a, tree0(db(E)) = b. Montrons alors comment
calculer A1 = (Σ, D1(E), F1, δ1). Selon l’Équation (2.11), il sufﬁt de calculer les dérivées de E par les
arbres de l’ensemble { f(a, a), f(a, b), f(b, a), f(b, b), g(a), g(b)} :
d f (a,a)(E) = E′ ◦f(ε1, a),
d f (b,b)(E) = dg(b)(E) = db(E),
d f (a,b)(E) = d f (b,a)(E) = dg(a)(E) = ∅{1}.
Cela produit un nouvel état, E′ ◦f(ε1, a), associé à f(a, a) par la fonction tree1, et trois nouvelles
transitions :
δ1 = δ0 ∪{(da(E), da(E), f, d f (a,a)(E)), (db(E), db(E), f, db(E)), (db(E), g, db(E))}.

58
Chapitre 2. Les constructions Bottom-Up
L’automate A1 est représenté Figure 2.5, où l’état-puits ∅1 et ses transitions sont absentes.
da(E)
d f (a,a)(E)
db(E)
a
b, c
g
f
2
1
f
1
2
FIGURE 2.5 – L’automate A1.
L’automate A2 est calculé depuis les dérivées par les arbres de l’ensemble
{ f( f(a, a), f(a, a)), f( f(a, a), a), f( f(a, a), b), f(a, f(a, a)), f(b, f(a, a)), g( f(a, a))} :
d f ( f (a,a),a)(E) = d f ( f (a,a),f (a,a))(E) = E′ et les quatre autres sont égales à ∅{1}. Cela produit ainsi
un nouvel état, E′, associé à t = f( f(a, a), a) par la fonction tree2, et une nouvelle transition : δ2 =
δ1 ∪{(d f (a,a)(E), da(E), f, dt(E))}. L’automate A2 est représenté Figure 2.6.
da(E)
d f (a,a)(E)
d f ( f (a,a),a)(E)
db(E)
a
b, c
g
f
2
1
f
1
2
f
2
1
FIGURE 2.6 – L’automate A2.
L’automate A3 est obtenu en calculant les dérivées par les arbres de l’ensemble { f(t, t), f(t, a), f(t, b), . . .}.
Il y a seulement quatre calculs retournant des expressions différentes de ∅{1} : d f (t,t)(E) = d f (t,b)(E) =
d f (b,t)(E) = db(E) et dg(t)(E) = dt(E), produisant les transitions suivantes :
δ3 = δ2 ∪{(dt(E), dt(E), f, db(E)), (dt(E), db(E), f, db(E)), (db(E), dt(E), f, db(E)), (dt(E), g, dt(E))},
calculs ne produisant pas de nouveaux états. Ainsi la construction s’arrête et l’automate des dérivées
de E est A3, représenté Figure 2.7.
da(E)
d f (a,a)(E)
d f ( f (a,a),a)(E)
db(E)
a
b, c
g
g
f
1
2
f
2
1
f
2
1
f
2
1
f
1
2
f
1
2
FIGURE 2.7 – L’automate des dérivées Bottom-Up de E.

59
3 Conclusion
Dans cette section, nous avons rappelé diverses constructions d’automates classiques de la théorie
des automates en les appliquant sur les expressions d’arbres aﬁn de construire des automates ascen-
dants comme descendants.
Ces constructions semblent n’être que des adaptations (quelques fois plus techniques) des algo-
rithmes connus sur des éléments plus structurés que les mots (les arbres). Cette remarque peut être
également faite au niveau même des automates de mots, en considérant les différentes techniques
déployées pour construire des automates déterministes, non-déterministes ou à multiplicités depuis
une expression par dérivation par exemple. Ainsi, une question naturelle se pose : quel pourrait être
le degré d’abstraction nécessaire pour uniﬁer les constructions sur les arbres et les mots, mais aussi
en termes de propriétés ou de type d’automates?
Nous essaierons ainsi de proposer un projet de recherche dans ce sens dans la partie suivante. Tout
d’abord, nous montrerons comment décrire des automates de mots à l’aide de théorie des catégories
aﬁn d’uniﬁer les différents types d’automates de mots (déterministes, non-déterministes, à multipli-
cités, alternants, etc.). Puis dans un second temps, nous nous intéresserons à la théorie des catégories
enrichies aﬁn d’essayer de proposer une structure permettant d’uniﬁer les automates de mots et
d’arbres. Enﬁn, nous proposerons une structure adaptée pour les expressions rationnelles, et éten-
drons les méthodes de construction précédentes sur celles-ci. Toutes ces structures seront implantées
en Haskell aﬁn de fournir des outils pratiques de manipulation de ces notions.


61
Deuxième partie
Les automates catégoriques


63
4 Présentation
Aucune généralisation n’est totalement vraie, même pas celle-ci.
Oliver Wendell Holmes
Dans les sections précédentes, on a pu voir les similitudes entre les constructions classiques d’au-
tomates depuis une expression rationnelle de mots avec celles concernant les arbres. Il a ainsi été
possible de réutiliser la notion de position et de successeur, soit ascendant (parents) soit descendant
(ﬁls), pour construire un automate d’arbres. La notion de dérivation est également réutilisable (dans
le cas de la dérivation partielle descendante) sur les expressions pour décrire d’une façon presque
directe la fonction de transition d’un automate descendant. La similitude entre la dérivation et la
fonction de transition d’un automate se renforce d’autant plus lors de leurs extensions respectives de
l’action d’un symbole à celle d’une structure composite (arbres ou mots). Comme nous l’avons sug-
géré, ces extensions sont directement représentables par des notions de théorie des catégories (plus
précisément des adjonctions).
Ces observations laissent présager une factorisation possible de ces méthodes aﬁn de construire in-
distinctement des automates d’arbres, de mots, voire d’autres structures par des méthodes uniﬁées,
en utilisant des outils de théorie des catégories, permettant de manipuler et de composer les mor-
phismes entre différents objets. C’est ainsi le but du projet de recherche proposé dans la suite de ce
document.
Nous allons essayer de mettre en place, via des outils de théorie des catégories, une description uni-
ﬁée, dans un premier temps, des automates de mots (déterministes, non-déterministes, à multiplici-
tés, etc.). L’approche suggérée dans la suite, à savoir manipuler des outils de théorie des catégories,
n’est pas nouvelle. En effet, de nombreux auteurs ont déjà proposé des descriptions catégoriques des
automates (voir par exemple l’utilisation des catégories pour réaliser de l’apprentissage par auto-
mates dans [76], basée sur une description algébrique des automates de [3]; voir également [45] pour
une déﬁnition des automates d’arbres selon la même description; voir ﬁnalement [10] pour une ap-
proche uniﬁcatrice des méthodes algébriques et coalgébriques). Dans la suite, nous proposerons une
déﬁnition d’automates similaire à celle de Colcombet et Petrisan [32], construisant des automates à
partir de morphismes de catégories.
Nous montrerons ensuite comment généraliser cette structure aﬁn d’englober également les auto-
mates d’arbres ascendants ou descendants en utilisant des éléments de théorie des catégories en-
richies. Cette deuxième extension pourra mettre en lumière la compatibilité avec l’approche fonc-
torielle de Colcombet et Petrisan : si un automate de mot peut être décrit comme un foncteur, les
automates enrichis seront descriptibles en termes de foncteurs enrichis.
Enﬁn, nous proposerons également une structure commune pour les expressions, basées sur des
produits tensoriels, permettant de factoriser expressions d’arbres et de mots.
Toutes ces notions seront implantées en Haskell, langage de programmation fonctionnelle à évalua-
tion paresseuse (voir par exemple [52] pour un bon survol des notions de base de la programmation
Haskell). Des notions de théorie des catégories ont déjà été implantées dans des modules de ce lan-
gage (voir par exemple [44] pour une implantation des automates utilisant la théorie des catégories
pour l’apprentissage par automates). L’utilisation de la théorie des catégories est à la base même de
ce langage, où les notions de foncteurs ou de monades sont fondamentales. Ce lien entre théorie des
catégories et programmation est une thématique de recherche très active, que ce soit en Haskell (voir
par exemple le lien entre catégories enrichies et accesseurs d’enregistrement décrit dans [31]) mais
également dans d’autres langages de programmation, comme en Python (voir par exemple l’utili-
sation des catégories monoïdales en traitement automatique du langage naturel avec l’implantation

64
Chapitre 4. Présentation
décrite dans [38]). Des implantations d’automates utilisant des outils de théorie des catégories ont
egalement été proposées []
Cependant, nous n’utiliserons généralement pas de modules pré-existants pour l’implantation des
outils de théorie des catégories. À la place, dans un souci de compréhension, nous construirons tout
au long de ce document les modules que nous utiliserons aﬁn d’illustrer les notions théoriques par
leurs implantations, mais également pour décrire les différents mécanismes de programmation fonc-
tionnelle avancée mis en œuvre dans ce document au fur et à mesure de leur utilisation. Les modules
ainsi implantés ne seront pas nécessairement optimisés; nous soulignerons alors lors des différentes
réalisations les améliorations possibles de l’utilisation de modules plus standards et avancés. Enﬁn,
nous transcrirons l’implantation dans ce document par l’intermédiaire de codes Pseudo-Haskell.
Qu’est-ce qu’un code Pseudo-Haskell?
On entend dans la suite de ce document par code Pseudo-Haskell un morceau de code écrit en utilisant
la syntaxe du langage Haskell, mais simpliﬁé dans sa notation pour le rendre accessible à des non-
initiés 1. Ainsi, les codes présentés dans ce document ne sont pas directement compilables 2.
La compilation et l’utilisation des sources peut se faire en utilisant stack. Une fois installé et mis à jour,
cet outils permet la compilation automatique des différents modules, et le chargement des modules
sufﬁsants à l’interprétation du code. Il permet également de générer et de consulter la documentation
de ce projet.
Les conventions de notations utilisées par la suite sont les suivantes :
— une fonction anonyme se note \x -> val où x est un paramètre et val le résultat;
— une fonction de la forme \x1 -> ...\xn -> val peut être notée \x1 ...xn -> val;
— une fonction nommée f = \x1 ...xn -> val peut être écrite f x1 xn = val;
— une expression de la forme let x = y in z est du sucre syntaxique pour la fonction déﬁnie
comme (\x -> z) y;
— un commentaire est précédé par --;
— l’opérateur $ est un opérateur d’évaluation (c’est-à-dire que f $ x = f x) associatif à droite
et de priorité la plus faible possible;
— dans un ﬁltrage de motif, le symbole _ est un joker;
— le type d’une expression est indiqué par les symboles ::;
— le type noté () est le type contenant l’unique élément ();
— un type algébrique de données est introduit par le mot clé data suivi par le nom du construc-
teur de types et les types dont il dépend; ses valeurs sont déﬁnies par une énumération (sym-
bole |) de constructions produits toutes introduites par un constructeur de valeur, suivi des
types des valeurs contenues; entre accolades peut alors apparaître le nom d’une fonction de
projection;
— une fonction, un constructeur de valeur ou un constructeur de type binaire dont le nom est un
mot (suite de caractères alphabétiques) est préﬁxe, et inﬁxe si écrit entre backticks (caractère `);
— une fonction, un constructeur de valeur ou un constructeur de type binaire autre (par exemple
la fonction +) est inﬁxe, et préﬁxe si écrit entre parenthèses;
— le constructeur de types de liste, unaire et noté [], peut être utilisé en position misﬁxe (le type
[] a pourra être noté [a]);
— le constructeur (->) est le constructeur binaire du type des fonctions;
— une classe de types est une relation entre plusieurs types permettant de décrire l’existence
de fonctions (ad-hoc) polymorphes, concrétisée par la déclaration d’instances; une super-classe
peut-être déﬁnie en précédant la déclaration par le symbole =>; une méthode (c’est-à-dire une
fonction d’une classe) peut avoir une déﬁnition par défaut et dans ce cas son corps apparaît
dans la déﬁnition de la classe;
— une classe peut apparaître comme une contrainte (condition nécessaire sur un type) dans une
signature de type, précédant cette signature est étant suivie par =>;
— les propriétés mathématiques classiques (par exemple l’associativité de la loi de composition
d’un semigroupe) non testées au niveau des types ne seront pas nécessairement explicitement
1. Par exemple, moins de contraintes explicitées, pas de pragmas déclarés, pas de forall explicites, moins de déclarations de
modules, etc.
2. La version non-simpliﬁée, c’est-à-dire tout le code source, dont ces codes sont tirés l’est.

Chapitre 4. Présentation
65
rappelées 3 ; ainsi, il est possible de construire des valeurs ne vériﬁant pas les propriétés ma-
thématiques nécessaires pour assurer la validité des constructions;
— chaque partie de pseudo-code est tirée d’un ﬁchier dont le nom est précédé par le mot-clé
module; les fonctions de ce module sont utilisables soit par la compilation d’un programme
les utilisant, mais aussi via l’interpréteur ghci. Pour cela, il sufﬁt d’utiliser la commande stack
ghci src/<chemin du fichier>;
— toute extension à ces conventions sera décrite en commentaires.
Différents exemples seront donnés tout au long du document. Pour les exécuter, il est possible :
— soit d’utiliser l’interpréteur ghci en tapant dans un terminal ouvert depuis le dossier source
la commande précédente stack ghci src/<chemin du fichier>;
— soit d’exécuter le programme principal listant les exemples, après compilation pour bénéﬁcier
d’optimisations, en tapant stack build (pour la compilation) puis stack exec Main pour
l’exécution du programme principal.
Toutes les fonctions Haskell (de base ou de modules non développés pour ce document) utilisées
dans ce document ne sont pas nécessairement explicitées; cependant, toutes sont accessibles sur le
site Hoogle. Les fonctions développées dans le cadre de ce document sont toutes commentées; la
documentation, que l’on peut générer et consulter via la commande stack haddock --open depuis
la racine des sources est un complément essentiel de la lecture de ce document.
Code Pseudo-Haskell. 1: Exemple jouet
-- Type des Booléens
data Bool = True | False
-- Classe des types dont l'égalité est décidable
class Eq a where
-- l'égalité
(==) :: a -> a -> Bool
-- la différence
(/=) :: a -> a -> Bool
a /= b = not $ a == b
-- L'égalité des Booléens est décidable
instance Eq Bool where
True
== True
= True
False == False
= True
_
== _
= False
-- Description des ordres
data Ordering = LT | EQ | GT
-- Classe des types ordonnés
class Eq a => Ord a where
compare :: a -> a -> Ordering
-- Les Booléens sont ordonnés
instance Ord Bool where
False `compare` True
= LT
True
`compare` False = GT
_
`compare` _
= EQ
-- Le constructeur de type neutre, et la définition
-- de la fonction runIdentity de signature Identity a -> a.
-- Identity a est isomorphe à a.
data Identity a = Identity {runIdentity :: a}
-- S'il y a une égalité décidable pour un type a,
-- l'égalité est décidable pour le type Identity a
instance Eq a => Eq (Identity a) where
x == y = runIdentity x == runIdentity y
-- Les classes des semigroupes et des monoïdes
class Semigroup a where
-- l'opération du semigroupe (doit être associative)
(<>) :: a -> a -> a
3. voir conclusion Chapitre 7.4

66
Chapitre 4. Présentation
class Semigroup a => Monoid a where
-- élément neutre du monoïde
mempty :: a
-- Une liste d'éléments de type a est
-- * soit la liste vide []
-- * soit un élément suivi d'une liste (constructeur binaire (:)).
data [a] = [] | a : [a]
-- Une liste est un monoïde; plus précisément,
-- il s'agit du monoïde libre.
instance Semigroup [a] where
[]
<> ys = ys
(x : xs) <> ys = x : (xs <> ys)
instance Monoid [a] where
mempty = []

67
5 Les automates de mots
Dans cette section, nous allons nous intéresser à la notion d’automates de mots. Pour cela, nous allons
étudier les différentes façons de combiner les transitions d’automates (déterministes, non détermi-
nistes, à multiplicités, etc.) en les interprétant à la lueur de la théorie des catégories, théorie de la
composition par excellence. Nous allons donc nous intéresser aux points communs de chacune des
compositions possibles, aﬁn de factoriser des opérations communes à ces machines dont les fonc-
tionnements semblent pourtant différents.
Nous commencerons donc par rappeler la déﬁnition de catégorie, puis nous montrerons comment
déﬁnir la notion d’automates sur une catégorie. L’utilisation de cette structure nous permettra de
factoriser les structures d’automates de mots (déterministes, non déterministes, à multiplicités, etc.).
Nous verrons également que plusieurs algorithmes classiques (déterminisation, complétion, et autres
conversions) sont des applications d’une même transformation.
Tout au long de cette partie, nous manipulerons des concepts avancés de programmation fonction-
nelle mettant en œuvre des concepts de théorie des catégories; nous nous efforcerons alors de donner
des exemples concrets de construction, aﬁn d’illustrer le plus possible ces notions.
5.1
Automates sur une catégorie
Une catégorie C est constituée
— d’une classe ObjC, les objets de C ;
— d’un ensemble HomC(A, B) de morphismes pour tous deux objets A et B de C ;
— d’une fonction ◦C de composition de HomC(B, C) × HomC(A, B) →HomC(A, C) pour tous
trois objets A, B et C de C
satisfaisant les conditions suivantes :
— la composition est associative;
— il existe pour tout objet A un élément idA, neutre pour la composition : pour tous deux mor-
phismes f de HomC(A, B) et g de HomC(B, A),
f ◦C idA = f,
idA ◦C g = g.
En absence d’ambiguïté, on notera idA par id, HomC par Hom et ◦C par ◦.
Code Pseudo-Haskell. 2: Catégorie
-- module Category.CategoryGen
-- Une catégorie est un constructeur de types binaire :
-- * dont on sait composer les valeurs
-- * qui contient un élément pointé pour chaque type
class CategoryGen cat where
-- le morphisme identité
id
:: cat a a
-- la composition de morphisme
(.) :: cat b c -> cat a b -> cat a c
Code Pseudo-Haskell. 3: Catégorie des types
-- module Category.CategoryGen
-- Le constructeur du type des fonctions est une catégorie
instance CategoryGen (->) where

68
Chapitre 5. Les automates de mots
-- le morphisme identité est la fonction identité
id :: a -> a
id x = x
-- la composition est la composition usuelle des fonctions
(.) :: (a -> b) -> (c -> a) -> c -> b
(.) f g x = f $ g x
Remarque 2: Monoïde comme catégorie
On peut interpréter la notion de catégorie comme une extension de la notion de monoïde.
En effet, une catégorie avec un unique objet est équivalente à un monoïde, les éléments du
monoïde étant les morphismes de la catégorie, se composant associativement et ayant néces-
sairement un élément neutre.
Code Pseudo-Haskell. 4: Catégorie à un objet
-- module Category.CategoryGen
-- Type des catégories avec un unique objet.
data MonoCat cat a = MonoCat {runCat :: cat a a}
-- Une catégorie avec un seul objet est un semigroupe
instance CategoryGen cat => Semigroup (MonoCat cat a) where
(<>) :: MonoCat cat a -> MonoCat cat a -> MonoCat cat a
MonoCat m1 <> MonoCat m2 = MonoCat $ m2 . m1
-- Une catégorie avec un seul objet est un monoïde
instance CategoryGen cat => Monoid (MonoCat cat a) where
mempty :: MonoCat cat a
mempty = MonoCat id
La structure d’automate peut-être alors réinterprétée, d’une façon équivalente à [32], à l’aide de ces
notions. Pour cela, il sufﬁt de décrire :
— une conﬁguration initiale;
— une fonction de transition associant à un symbole une modiﬁcation de conﬁguration;
— une transformation ﬁnale des conﬁgurations.
Une fois une catégorie choisie, il sufﬁt alors de choisir un objet Q de celle-ci pour représenter les
conﬁgurations, un objet V pour représenter les poids et un morphisme de Hom(Q, V) pour interpréter
une conﬁguration. Cependant, il faut remarquer que la catégorie choisie n’est pas nécessairement
celle des ensembles. Ainsi, Q n’est pas nécessairement un ensemble et la conﬁguration initiale ne peut
alors pas être déﬁni comme un élément de Q. Il sufﬁt alors de déﬁnir la conﬁguration initiale comme
un morphisme de Hom(I, Q) avec I un objet de la catégorie ambiante. Le cas d’une conﬁguration
initiale choisie dans un ensemble pourra être retrouvée par l’isomorphisme classique entre () →Q
et Q.
Déﬁnition 11
Un automate sur une catégorie C est déﬁni par :
— un alphabet Σ;
— par trois objets : I l’ objet initial, Q l’objet état et V l’objet ﬁnal;
— un morphisme initial de Hom(I, Q);
— une fonction de transition δ de Σ →Hom(Q, Q);
— un morphisme ﬁnal de Hom(Q, V).
Code Pseudo-Haskell. 5: Automate
-- module Automata.Automaton
-- Le type de données des automates avec
-- * cat une catégorie
-- * init l'objet initial
-- * symbols l'alphabet

5.1. Automates sur une catégorie
69
-- * state l'objet état
-- * value l'objet final.
data Automaton cat init symbols state value = Auto {
-- le morphisme initial
initial :: cat init state,
-- la fonction de transition
delta
:: symbols -> cat state state,
-- le morphisme d'évaluation
final
:: cat state value
}
Remarquons alors que l’extension de la fonction de transition des symboles aux mots relève alors de
la composition des morphismes de la catégorie ambiante. Par exemple, le morphisme correspondant
à un mot de deux symboles a · b serait la composition δ(b) ◦δ(a). Cette extension d’une fonction
depuis symboles en une fonction depuis des mots repose sur une construction fondamentale de la
théorie des catégories : l’adjonction fonctorielle.
Un foncteur F entre deux catégories C et C′ envoie
— tout objet A de C sur un objet F(A) de C′,
— tout morphisme f de HomC(A, B) vers un morphisme F( f) contenu dans HomC′(F(A), F(B))
en compatibilité avec
— la composition : pour tous deux morphismes f et g de C,
F( f ◦C g) = F( f) ◦C′ F(g);
— le morphisme identité :
F(idC) = idC′.
Remarque 3: Foncteur identité
Le plus simple des foncteurs est le foncteur 1, foncteur identité envoyant tout objet sur lui-
même et tout morphisme sur lui-même.
Remarque 4: Composition de foncteurs
La composition de deux foncteurs F d’une catégorie C′ vers une catégorie C′′ et G d’une caté-
gorie C vers C′, notée FG, envoyant un objet A vers F(G(A)) et un morphisme f vers F(G( f))
est elle aussi un foncteur.
Code Pseudo-Haskell. 6: Foncteur
-- module Category.FunctorGen
-- Soient f un constructeur unaire de types, et cat et cat'
-- deux catégories. Ainsi, f est un foncteur de cat vers cat'
-- s'il existe une fonction envoyant les morphismes de
-- cat vers ceux de cat'.
class (CategoryGen cat, CategoryGen cat') => FunctorGen f cat cat' where
fmap :: cat a b -> cat' (f a) (f b)
Remarque 5: Classe de types des foncteurs
En Haskell, la classe de types des foncteurs, Functor, ne permet que de manipuler la catégorie
des types et est déﬁnie par la fonction
fmap:: (a -> b) -> f a -> f b
La classe FunctorGen déﬁnie précédemment est plus ﬂexible en permettant de déﬁnir des
foncteurs pour d’autres catégories (par exemple des sous-catégories de la catégorie des types).
Deux des foncteurs les plus simples à décrire sont les (endo) foncteurs identité et des listes sur la
catégorie des types.

70
Chapitre 5. Les automates de mots
Code Pseudo-Haskell. 7: Foncteurs liste et identité
-- module Category.OfStructures.CategoryOfTypes
-- Endofoncteur des listes
instance FunctorGen [] (->) (->) where
fmap :: (a -> b) -> [a] -> [b]
fmap _ []
= []
fmap f (x : xs) = f x : fmap f xs
-- Endofoncteur identité
instance FunctorGen Identity (->) (->) where
fmap :: (a -> b) -> Identity a -> Identity b
fmap f (Identity a) = Identity $ f a
Remarque 6: Types Algébriques de Données Généralisés
Les types algébriques de données déﬁnis précédemment peuvent être généralisés en Gene-
ralized Algebraic Data Types (GADTs), permettant d’ajouter des informations supplémentaires
sur les types pour renforcer le moteur d’inférence de typage. Par exemple, des contraintes
peuvent être ajoutées dans la déﬁnition du type de données.
Dans ce cas, la syntaxe utilisée sera la suivante : comme précédemment, le mot clé data suivi
du nom T du type et de ses paramètres a1 ...an. Pour différencier la syntaxe avec les ADT
classiques, le symbole = est remplacé par le mot clé where. Suivent ensuite les constructeurs
de valeurs, sous la syntaxe suivante : nom du constructeur, puis son type, type d’une fonc-
tion dont les entrées sont les champs du constructeur de valeur, pouvant être nommés (pour
déﬁnir simultanément des fonctions de projection), et dont la sortie est le type de données
déﬁni.
Par exemple, la déﬁnition suivante
data Expr a where
IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
Sum :: Expr Int -> Expr Int -> Expr Int
Neg :: Expr Bool -> Expr Bool
And :: Expr Bool -> Expr Bool -> Expr Bool
Val :: a -> Expr a
permet de déﬁnir facilement des expressions typées, dont les opérateurs ne sont compatibles
qu’avec une sous-partie des valeurs inductivement déﬁnies, compatibilité testée à la compi-
lation. Ainsi, les termes suivants sont bien formées :
true = Val True
one = Val 1
two = Sum one one
false = Neg true
one' = IfThenElse true one two
mais pas celui-ci :
bad = IfThenElse one one one
Les deux constructeurs de types [] et Identity permettent également déﬁnir des foncteurs entre la
catégorie des types et celle des monoïdes.
Code Pseudo-Haskell. 8: Foncteurs liste et identité
-- module Category.OfStructures.CategoryOfMonoids
-- Définition du type des morphismes de monoïdes, dont les valeurs
-- sont définies par constructeur de valeurs MonoidMorph
-- contenant une fonction entre deux monoïdes a et b,
-- et définition de la fonction de projection runMorph
data MonoidMorph a b where
MonoidMorph ::
(Monoid a, Monoid b) => {runMorph :: a -> b} -> MonoidMorph a b
-- Définition de la catégorie des monoïdes
instance CategoryGen MonoidMorph where
id = MonoidMorph id
f . g = MonoidMorph $ runMorph f . runMorph g

5.1. Automates sur une catégorie
71
-- Le constructeur [] est un foncteur
-- de la catégorie des types vers celle
-- des monoïdes
instance FunctorGen [] (->) MonoidMorph where
fmap = MonoidMorph . fmap
-- Tout endofoncteur de la catégorie des types est un foncteur de
-- la catégorie des monoïdes vers la catégorie des types.
-- Est inclus le constructeur Identity
instance FunctorGen f (->) (->) => FunctorGen f MonoidMorph (->) where
fmap = fmap . runMorph
Il existe un lien particulier entre le foncteur des listes et le foncteur identité. Toute fonction envoyant
un type sur un monoïde peut être étendue en un morphisme de monoïde entre le monoïde libre (dont
l’ensemble sous-jacent est celui des listes) et ce monoïde; et cette extension peut être inversée.
Code Pseudo-Haskell. 9: Relation liste et identité
-- Promotion d'une fonction en morphisme de monoïde
promoteFunToMorph :: Monoid b => (a -> b) -> MonoidMorph [a] b
promoteFunToMorph f = MonoidMorph $ foldMap f
where
-- Fonction utilitaire, déjà définie en Haskell
-- [voir Data.Foldable]
foldMap :: Monoid b => (a -> b) -> [a] -> b
foldMap _ []
= mempty
foldMap f (x : xs) = f x <> foldMap f xs
-- Destitution d'un morphisme en une fonction
lowerMorphToFun :: MonoidMorph [a] b -> a -> b
lowerMorphToFun (MonoidMorph f) = f . return
where
-- Fonction utilitaire, déjà définie en Haskell
-- dans le module de base Prelude
return :: a -> [a]
return a = [a]
C’est cette relation particulière entre foncteurs qui est appelée adjonction. Plus formellement, soient
F un foncteur entre deux catégories C et C′ et G un foncteur entre C′ et C. Ces deux foncteurs sont dits
adjoints si pour tous deux objets A de C et B de C′ les ensembles HomC(A, G(B)) et HomC′(F(A), B)
sont isomorphes. L’isomorphisme d’ensemble n’est pas la seule façon de décrire une adjonction entre
foncteurs. On peut également étudier le lien entre les compositions de ces foncteurs (c’est-à-dire les
(endo) foncteurs FG et GF) et les foncteurs identités. Pour cela, il sufﬁt d’étudier les morphismes
entre ces foncteurs, appelés transformations naturelles.
Soient F et G deux foncteurs entre deux catégories C et C′. Une transformation naturelle de F en G est
une famille α de morphisme de C′ indexée par les objets de C faisant commuter le diagramme suivant
pour tout morphisme h de C :
F(A)
G(A)
F(B)
G(B).
αA
F(h)
G(h)
αB
Remarque 7: Transformation naturelle
En Pseudo-Haskell, une transformation naturelle de f en g est une fonction polymorphe t de
type (f a -> g a) satisfaisant l’équation
t . fmap h = fmap h . t
pour tout morphisme h.

72
Chapitre 5. Les automates de mots
Une adjonction peut alors être déﬁnie à l’aide des transformations naturelles. Soient F un foncteur
entre deux catégories C et C′ et G un foncteur entre C′ et C. Ces deux foncteurs sont dits adjoints s’il
existe deux transformations naturelles
— ǫ entre FG et 1
— η entre 1 et GF
satisfaisant pour tous deux objets X de C′ et Y de C
idF(Y) = ǫF(Y) ◦F(ηY),
idG(X) = G(ǫX) ◦ηG(X).
Code Pseudo-Haskell. 10: Adjonction
-- module Category.AdjunctionGen
-- Adjonction entre les foncteurs f et g, respectivement
-- foncteurs de cat vers cat' et de cat' vers cat
class (FunctorGen f cat cat', FunctorGen g cat' cat)
=> AdjunctionGen f g cat cat' where
-- Transformation η de l'adjonction
unit ::
cat a (g (f a))
-- Transformation ǫ de l'adjonction
counit ::
cat' (f (g a)) a
-- Isomorphisme de l'adjonction
promote :: cat a (g b) -> cat' (f a) b
promote f = counit . fmap f
-- Inverse de la fonction promote
lower :: cat' (f a) b -> cat a (g b)
lower h = fmap h . unit
Remarque 8: Classe de types et code par défaut
Dans le Pseudo-Code 10, les promotions et destitutions de morphismes se déduisent directe-
ment de l’unité et de la co-unité de l’adjonction. Ainsi, nous ne donnerons dans la suite, pour
la déﬁnition des adjonctions que nous allons utiliser, que la déﬁnition des morphismes unité
et co-unité de l’adjonction.
Code Pseudo-Haskell. 11: Adjonction Liste Identité
-- module Category.OfStructures.CategoryOfMonoids
-- Définition de l'adjonction Liste - Identité
instance AdjunctionGen [] Identity (->) MonoidMorph where
unit :: a -> Identity [a]
unit = Identity . return
counit ::
MonoidMorph [Identity a] a
counit = MonoidMorph $ foldMap runIdentity
-- Fonction auxiliaire pour éviter les appels aux constructeurs de
-- types et aux fonctions de projection
promoteFun
:: CategoryGen cat => (b -> cat a a) -> [b] -> cat a a
promoteFun f = runCat . (runMorph $ promote $ Identity . MonoCat . f)
Cette dernière fonction, promoteFun, découlant directement d’une adjonction, est la fonction idéale
pour promouvoir la fonction de transition δ d’un automate considérant des symboles en entrée en
une fonction considérant des mots.

5.1. Automates sur une catégorie
73
Code Pseudo-Haskell. 12: Promotion de δ
-- module Automata.Automaton
-- Fonction de transition depuis les mots associée
-- à un automate
delta'
:: CategoryGen cat
=> Automaton cat init symbols state value
-> [symbols]
-> cat state state
delta' = promoteFun . delta
Avec le formalisme choisi dans cette section, la conﬁguration initiale de l’automate est un mor-
phisme. La fonction delta’ permet alors de calculer la conﬁguration obtenue après la lecture d’un
mot, par sa simple composition avec le morphisme initial.
Code Pseudo-Haskell. 13: Conﬁguration associée à un mot
-- module Automata.Automaton
-- Calcul de la configuration associée à un mot pour un automate donné
getConfig
:: CategoryGen cat
=> Automaton cat init symbols state value
-> [symbols]
-> cat init state
getConfig auto w = delta' auto w . initial auto
Le poids d’un mot est alors la composition de la conﬁguration atteinte et du morphisme ﬁnal.
Code Pseudo-Haskell. 14: Poids d’un mot
-- module Automata.Automaton
-- Poids d'un mot
weight
:: CategoryGen cat
=> Automaton cat init symbols state value
-> [symbols]
-> cat init value
weight auto w = final auto . getConfig auto w
Pour améliorer la lisibilité, déﬁnissons une classe de conversion de types.
Code Pseudo-Haskell. 15: Équivalence de types
-- module Tools.TypeEq
-- Classes de conversion de types
class Castable a b where
-- Première conversion
cast :: a -> b
-- Seconde conversion
castInv :: b -> a
-- module Automata.Automaton
-- Poids d'un mot comme élément d'un type équivalent au
-- type cat init value
weightValue
:: (CategoryGen cat, Castable (cat init value) value')
=> Automaton cat init symbols state value
-> [symbols]
-> value'
weightValue auto = cast . weight auto

74
Chapitre 5. Les automates de mots
-- Synonyme dans le cas d'un poids booléen.
recognizes
:: (Castable (cat init value) Bool, CategoryGen cat)
=> Automaton cat init symbols state value
-> [symbols]
-> Bool
recognizes = weightValue
Le type des automates les plus simples à implanter est alors le type des automates déterministes
complets. Ci-dessous sa déﬁnition, ainsi que des fonctions utilitaires de construction, mais également
les algorithmes classiques de complémentation et de combinaison booléenne binaire.
Code Pseudo-Haskell. 16: Automates déterministes complets
-- module Automata.DFAComp
-- Synonyme de type pour la lisibilité
type DFAComp symbol state = Automaton (->) () symbol state Bool
-- Fonction de construction usuelle d'un automate déterministe complet
-- depuis :
-- * un état initial
-- * une fonction associant à un symbole et à un état un unique état
-- * une fonction associant à un état sa finalité
pack
:: state
-> (symbol -> state -> state)
-> (state -> Bool)
-> DFAComp symbol state
pack = Auto . const
where
-- fonction usuelle déjà définie en Haskell
-- dans le module de base Prelude
const x _ = x
-- Équivalence classique entre les types (() -> a) et a,
-- permettant l'utilisation de la fonction recognizes
-- avec les automates déterministes complets,
-- en castant les morphismes de type () -> Bool
-- en éléments de type Bool
instance Castable (() -> a) a where
cast f = f ()
castInv a () = a
-- Complémenter un DFA complet, c'est inverser la finalité des états
-- de celui-ci.
complement :: DFAComp symbol state -> DFAComp symbol state
complement (Auto i d f) = Auto i d (not . f)
where
-- fonction usuelle déjà définie en Haskell
-- dans le module de base Prelude
not True = False
not False = True
-- Combinaison binaire de DFAs complets en fonction d'une
-- fonction booléenne donnée.
booleanBinaryCombination
:: (Bool -> Bool -> Bool)
-> DFAComp symbols state
-> DFAComp symbols state'
-> DFAComp symbols (state, state')
booleanBinaryCombination g (Auto i1 d1 f1) (Auto i2 d2 f2) = Auto i d f
where
-- la configuration initiale est le couple des configurations initiales
i () = (i1 (), i2 ())
-- la fonction de transition est obtenue par un parcours
-- des automates en parallèle
d a (p, q) = (d1 a p, d2 a q)
-- la finalité est obtenue en appliquant la fonction

5.1. Automates sur une catégorie
75
-- booléenne donnée en paramètre
f (p, q) = g (f1 p) (f2 q)
-- Union de deux DFAs complets,
-- en utilisant la disjonction booléenne (||).
(<+>)
:: DFAComp symbols state
-> DFAComp symbols state'
-> DFAComp symbols (state, state')
(<+>) = booleanBinaryCombination (||)
-- Intersection de deux DFAs complets,
-- en utilisant la conjonction booléenne (&&).
(<&>)
:: DFAComp symbols state
-> DFAComp symbols state'
-> DFAComp symbols (state, state')
(<&>) = booleanBinaryCombination (&&)
Aﬁn de concrétiser l’utilisation de ces fonctions, considérons la construction d’automate suivante
basée sur les automates de la famille déﬁnie Figure 5.1, où les transitions étiquetées par le symbole _
représentent des transitions déﬁnies quel que soit le symbole de l’alphabet considéré : un automate
déterministe de cette famille reconnaît les mots qui ont une longueur congrue à un entier ﬁxé. Le
Pseudo-Code 17 1 illustre comment combiner (d’une façon Booléenne) différents automates de cette
famille.
0
1
2
· · ·
n −2
n −1
_
_
_
_
FIGURE 5.1 – Un reconnaisseur de mots de longueurs modulaires.
Code Pseudo-Haskell. 17: Automates déterministes complets
-- module HDRExample.DFAComp
-- Fonction de transition définissant les transitions de la forme
-- (p, _, (p + 1) % n)
deltaMod :: Integral state => state -> symbol -> state -> state
deltaMod n _ p = (p + 1) `mod` n
-- a1 reconnait les mots de longueurs paires
-- a2 reconnait les mots de longueurs multiples de 4
-- a3 reconnait les mots de longueurs multiples de 8
a1, a2, a3 :: DFAComp symbol Int
a1 = pack 0 (deltaMod 2) (== 0)
a2 = pack 0 (deltaMod 4) (== 0)
a3 = pack 0 (deltaMod 8) (== 0)
-- a4 reconnait les mots de longueurs paires non multiples
-- de 4 ou multiples de 8
a4 :: DFAComp symbols ((Int, Int), Int)
a4 = a1 <&> complement a2 <+> a3
-- Fonction d'affichage de test pour un mot donné
1. Le
module
exemple
peut
être
chargé
dans
l’interpréteur
ghci
par
la
commande
stack ghci
src/HDRExample/DFAComp.hs.

76
Chapitre 5. Les automates de mots
-- Par exemple,
-- test "aa"
-- > a4 recognizes "aa": True
-- test "aaaa"
-- > a4 recognizes "aaaa": False
-- test "aaaaaaaa"
-- > a4 recognizes "aaaaaaaa": True
test :: Show symbols => [symbols] -> IO ()
test w =
putStrLn $
mconcat ["a4 recognizes ", show w, ": ", show (a4 `recognizes` w)]
On peut ainsi représenter les automates complets déterministes en utilisant la catégorie des types,
dont les objets sont les types et les morphismes les fonctions. Dans la section suivante, on va s’inté-
resser aux autre types d’automates classiques, que l’on va pouvoir représenter via d’autres catégories
connues.
5.2
Autres types d’automates de mots
En choisissant d’autres catégories, il est possible de représenter une très grande variété d’automates
très différents les uns des autres : déterministes (non nécessairement complets), non déterministes,
à multiplicités, alternants, etc. Ces différents types d’automates ont cependant des similarités dans
leurs fonctionnements : tout comme les automates déterministes complets, le rôle d’un symbole est
de transformer une conﬁguration en une autre : un ensemble d’états en un ensemble d’états pour
un automate non déterministe, une combinaison linéaire d’états en une combinaison linéaire d’états
pour un automate à multiplicités, etc.; cependant, cette transformation s’exprime par l’action d’un
symbole sur un état. Dans de tels automates, la fonction de transition est alors exprimée comme une
fonction du type symbol -> state -> m state, où m est un constructeur de types unaire. Une suc-
cession d’action par les symboles (cas de l’action par les mots) nécessite alors le fait que les fonctions
du type state -> m state puissent alors se composer. Cette composition est possible dans le cas de
foncteurs particuliers : les monades.
5.2.1
Monades et catégories de Kleisli
Formellement, une monade sur une catégorie C est un endofoncteur T de C tel qu’il existe deux trans-
formations naturelles
— η (return 2 en Haskell) entre 1 et T,
— µ (join en Haskell) entre TT et T,
faisant commuter les deux diagrammes suivants :
TTT(X)
TT(X)
TT(X)
T(X),
T(µX)
µT(X)
µX
µX
T(X)
TT(X)
TT(X)
T(X).
ηT(X)
T(ηX)
IdT(X)
µX
µX
Code Pseudo-Haskell. 18: Monade
-- module Category.MonadGen
-- Soit m un endofoncteur sur une catégorie cat.
-- m est une monade s'il existe deux fonctions permettant:
-- * de promouvoir une valeur en son type monadique (return)
-- * de supprimer un niveau monadique dans les types de valeur (join)
class FunctorGen m cat cat => MonadGen m cat where
-- Promotion monadique.
return :: cat a (m a)
-- Suppression d'un niveau monadique.
2. déjà mentionnée dans le cas des listes

5.2. Autres types d’automates de mots
77
join :: cat (m (m a)) (m a)
Remarque 9: Monades en Haskell
La classe de types Monad existe dans les modules de base Haskell. Classiquement, cette classe
est déﬁnie par la fonction return comme ci-avant, et par la fonction bind (noté également
par l’opérateur (»=)) de signature (m a -> (a -> m b) -> m b), sémantiquement déﬁnie
comme
m_a >>= f = join $ fmap f m_a
L’opérateur (=«), de signature ((a -> m b) -> m a -> m b), lui est équivalent, ne chan-
geant que par la position des paramètres. Dans l’implantation fournie, il est déﬁni pour toute
monade de la façon suivante :
(=<<) :: cat a (m b) -> cat (m a) (m b)
(=<<) f =
join . fmap f
Comme pour les foncteurs, deux des monades les plus simples à déﬁnir sont la monade des Listes et
la monade Identité.
Code Pseudo-Haskell. 19: Exemples de monades : Listes et Identité
-- module Category.OfStructures.CategoryOfTypes
-- L'endofoncteur des listes est une monade.
instance MonadGen [] (->) where
return x = [x]
join [] = []
join (xs : xss) = xs <> join xss
-- L'endofoncteur Identité est une monade.
instance MonadGen Identity (->) where
return = Identity
join (Identity x) = x
Remarque 10: La monade IO
Une monade très utile en Haskell est la monade IO, la monade des effets de bords. Elle permet
en effet de marquer sans ambiguïté les valeurs associées à des expressions impures, pouvant
mettre en péril la transparence référentielle. Cette information permet alors au compilateur
d’effectuer des optimisations en déterminant d’une façon plus simple les expressions dont
l’interprétation peut déclencher des actions.
Ainsi, une expression permettant de lire une chaîne de caractères depuis l’entrée standard
serait de type IO String, une valeur entière générée aléatoirement de type IO Int, et un
programme de type IO ().
Remarque 11: Composition de monades
Contrairement aux foncteurs, la composition de deux monades (en tant que foncteur) n’est pas
nécessairement une monade (voir [51] pour le cas surprenant des ensembles d’ensembles).
D’autres foncteurs remarquables sont également des monades; c’est le cas pour le constructeur Maybe
(constructeur de type présent dans les modules de base d’Haskell, correspondant à l’ajout d’un élé-
ment au type) ou pour les constructeurs d’ensembles ﬁnis.
Remarque 12: Les ensembles en Haskell
Le langage Haskell possède de nombreuses implantations des ensembles mathématiques,

78
Chapitre 5. Les automates de mots
ﬁnis ou non. Dans la suite, nous considérerons le constructeur de types HashSet, permet-
tant de construire des ensembles ﬁnis efﬁcaces en termes de recherche en utilisant des fonc-
tions de hachage. Ce constructeur est disponible dans le module Data.HashSet du package
unordered-containers. Ce module, appelé Set par la suite, contient de nombreuses fonc-
tions utilitaires, telles que map (l’application d’une fonction sur les éléments d’un ensemble,
déﬁnition d’un foncteur), singleton (renvoyant un ensemble de cardinalité 1 à partir d’une
valeur) ou fold (méthode de la classe Foldable combinant les valeurs d’un ensemble si elles
sont d’un type monoïdal).
Code Pseudo-Haskell. 20: Exemples de monades
-- module Category.OfStructures.CategoryOfTypes
-- Type de données ajoutant une valeur particulière à un type,
-- défini dans les modules de base d'Haskell.
data Maybe a = Nothing | Just a
-- Le constructeur Maybe est un foncteur.
instance FunctorGen Maybe (->) (->) where
fmap _ Nothing
= Nothing
fmap f (Just x) = Just $ f x
-- Le foncteur Maybe est une monade.
instance MonadGen Maybe (->) where
return = Just
join Nothing
= Nothing
join (Just x)
= x
-- Le constructeur HashSet est un foncteur.
instance FunctorGen HashSet (->) (->) where
fmap = Set.map
-- Le foncteur HashSet est une monade.
instance MonadGen HashSet (->) where
return = Set.singleton
join
= fold
Un des grands intérêts des monades (en programmation fonctionnelle notamment) est qu’elles per-
mettent de composer très facilement les morphismes du type a -> m b. En effet, cette combinaison
est décrite par une catégorie associée à toute monade, la catégorie de Kleisli.
Formellement, la catégorie de Kleisli associée à une monade (T, µ, η) sur une catégorie C est la catégorie
CT dont :
— les objets sont les objets de C,
— les morphismes entre deux objets A et B sont les morphismes de C entre A et T(B),
— la composition de deux morphismes f de Hom(B, T(C)) et g de Hom(A, T(B)) est déﬁnie par
f ◦CT g = µ ◦C T( f) ◦C g;
— l’identité est déﬁnie par la transformation naturelle η :
idA = ηA.
Code Pseudo-Haskell. 21: Catégorie de Kleisli
-- module Category.Kleisli
-- Type des morphismes de Kleisli, définissant:
-- * le constructeur de types Kleisli;
-- * la fonction de projection runKleisli.
data KleisliCat m cat a b = Kleisli {runKleisli :: cat a (m b)}
-- Le constructeur de types KleisliCat m cat, constructeur binaire,

5.2. Autres types d’automates de mots
79
-- est une catégorie.
instance MonadGen m cat => CategoryGen (KleisliCat m cat) where
id = Kleisli return
(Kleisli f) . (Kleisli g) = Kleisli ((=<<) f . g)
Remarque 13: Composition de Kleisli
La fonction utilisée pour composer les morphismes de la catégorie de Kleisli, la fonction as-
sociant à deux morphismes f et g l’expression ((=«) f.g), est habituellement notée (<=<) et
appelée ﬁsh operator ou composition de Kleisli. On pourra la retrouver dans la déﬁnition de la
classe MonadGen du module Category.MonadGen.
5.2.2
Automates et catégories de Kleisli
Les catégories de Kleisli permettent de déﬁnir les automates classiques comme des cas particuliers
du type des automates. Considérons par exemple un automate du type Automaton (KleisliCat
Maybe (->)) () symbol state (). Un tel automate est déﬁni (voir Code 5) par trois éléments :
— le morphisme initial de la forme Kleisli i où i est du type () -> Maybe state, iso-
morphe au type Maybe state; la conﬁguration initiale d’un tel automate est alors un élément
de type Maybe state, c’est-à-dire soit un état p de type state (Just p), soit rien (Nothing);
— la fonction delta associant à chaque symbole un morphisme Kleisli d_a où d_a est du type
state -> Maybe state, c’est-à-dire une fonction partielle entre state et state; ainsi delta
associe à un symbole et à un état soit un état p de type state (Just p), soit rien (Nothing);
— le morphisme final de la forme Kleisli f où f est une fonction de type state -> Maybe (),
c’est-à-dire associant à chaque état une valeur d’un type, Maybe (), à deux valeurs, et donc
isomorphe aux Booléens : soit Nothing (False), soit Just () (True).
Un tel automate est alors un automate déterministe non complet. D’une façon similaire, la catégorie
de Kleisli de la monade des ensembles permet de représenter les automates non déterministes.
Code Pseudo-Haskell. 22: Automates classiques comme automates de Kleisli
-- module Automata.KleisliAutomata
-- Un DFA non complet est un automate sur la catégorie de Kleisli
-- associée à la monade Maybe.
type DFA symbol state =
Automaton (KleisliCat Maybe (->)) () symbol state ()
-- Un NFA est un automate sur la catégorie de Kleisli
-- associée à la monade des ensembles.
type NFA symbols state =
Automaton (KleisliCat HashSet (->)) () symbols state ()
Par ce formalisme, certaines fonctions peuvent être factorisées entre tous les automates sur des caté-
gories de Kleisli, quelle que soit la monade associée. C’est le cas des deux fonctions suivantes. NB : La
fonction convert utilisée dans la fonction applyFunctorest une méthode de la classe KleisliFunAux
du module Category.Kleisli permettant de déﬁnir des foncteurs entre catégories de Kleisli issues
de monades pouvant être distinctes; les instances de cette classe utilisées par la suite sont disponibles
dans le module Category.OfStructures.CategoryOfTypes.
Code Pseudo-Haskell. 23: Automates de Kleisli
-- module Automata.KleisliAutomata
-- Fonction de construction d'un automate de Kleisli
-- quelle que soit la monade associée pour des foncteurs
-- de la catégorie des types.
packKleisli
:: (Castable (m valeur) valeur')
=> m state
-> (symbols -> state -> m state)

80
Chapitre 5. Les automates de mots
-> (state -> valeur')
-> Automaton (KleisliCat m (->)) init symbols state valeur
packKleisli i d f =
Auto (Kleisli (const i)) (Kleisli . d) (Kleisli (castInv . f))
-- Application d'un foncteur f entre les catégories de Kleisli associées
-- à deux monades m et h; permet de convertir les configurations
--
de la forme (m state) en (h (f state)) tout en conservant l'état
-- initial inchangé.
applyFunctor
:: (KleisliFunAux cat f m h
, FunctorGen f (KleisliCat m cat) (KleisliCat h cat)
, MonadGen m cat
, MonadGen h cat
)
=> Automaton (KleisliCat m cat) init symbols state valeur
-> Automaton (KleisliCat h cat) init symbols (f state) (f valeur)
applyFunctor (Auto (Kleisli i) d f) =
Auto (Kleisli $ convert . i) (fmap . d) (fmap f)
L’introduction des fonctions techniques (dont la déﬁnition est rappelée ici de façon incomplète)
applyFunctor et convert se justiﬁe par le fait que leurs déﬁnitions renferment, d’une façon surpre-
nante, des algorithmes classiques de manipulation d’automates. Plus précisément, leur utilisation
permet de rapprocher syntaxiquement des algorithmes classiques de conversion d’automates.
Code Pseudo-Haskell. 24: Algorithmes classiques et foncteurs
-- module Automata.KleisliAutomata
-- Conversion d'un NFA en un DFA complet,
-- passant d'une façon intermédiaire par un automate
-- dont les états sont de types (Identity (HashSet a)).
determinise
:: (Eq state, Hashable state)
=> NFA symbol state
-> DFAComp symbol (HashSet state)
determinise = removeIdDFA . castFinality . applyFunctor
-- Conversion d'un DFA en un DFA complet,
-- passant d'une façon intermédiaire par un automate
-- dont les états sont de types (Identity (Maybe a)).
complete :: DFA symbol state -> DFAComp symbol (Maybe state)
complete = removeIdDFA . castFinality . applyFunctor
-- Conversion d'un NFA en un DFA
-- dont les états sont de types (Maybe (HashSet a)).
nfaToDFA
:: (Hashable state, Eq state)
=> NFA symbol state
-> DFA symbol (HashSet state)
nfaToDFA = convertFinalityWith (Kleisli castInv) . applyFunctor
Dans les trois cas précédents, l’algorithme appliqué est le même : il s’agit d’une transformation fonc-
torielle de conﬁguration de la forme m state en h (f state) :
— pour la déterminisation (complète), transformation de morphismes de la forme state ->
HashSet state en state -> Identity (HashSet state);
— pour la complétion, transformation de morphismes de la forme state -> Maybe state en
state -> Identity (Maybe state);
— pour la déterminisation, transformation de morphismes de la forme state -> HashSet state
en state -> Maybe (HashSet state).
Dans les deux premiers cas, la monade Identity, induisant un isomorphisme de types, peut être
éliminée : c’est le rôle de la fonction removeIdDFA, du module Automata.DFAComp, transformant un
automate sur la catégorie de Kleisli associée à la monade Identity en un automate sur la catégorie
des types.

5.2. Autres types d’automates de mots
81
Les algorithmes implantés dans le code source ne sont pas tous explicitement rappelés dans cette sec-
tion de façon exhaustive, tout comme les différents types d’automates. Par exemple, les automates
alternants 3 (dont les conﬁgurations sont exprimées par des expressions booléennes, formées elles-
mêmes par un type monadique) peuvent être convertis en automate non-déterministe (les conﬁgu-
rations sont des ensembles de clauses conjonctives) ou en automate déterministe complet (les conﬁ-
gurations sont des expressions) par une application de cette même fonction applyFunctor suivies de
conversion mineures de types.
Concluons cette sous-section par l’implantation d’un cas concret classique. Intéressons-nous à la fa-
mille d’automates de la Figure 5.2, connue pour être une famille d’automates dont la déterminisation
atteint la borne exponentielle classique.
0
1
2
· · ·
n −2
n −1
a
a
b
a
b
a
a
b
a
b
FIGURE 5.2 – Un (e famille d’) automate non-déterministe dont la déterminisation at-
teint la borne.
Les propriétés d’évaluation paresseuse d’Haskell, couplées à la mémoïsation (simple à mettre en
œuvre en utilisant le module Data.Function.Memoizedu package memoize) permettent de construire
virtuellement l’automate déterminisé pour de grandes valeurs entières. En effet, seule la partie utile
(car utilisée) de l’automate sera réellement interprétée. Pour illustrer cela, nous allons considérer le
Pseudo-Code suivant 4. Le code est reporté ici à titre d’information, le point important étant l’exé-
cution de la fonction test sur des valeurs croissantes. La fonction memoizeAndTraceAuto utilisée
ici est implantée dans le module Automata.KleisliAutomata et permet de mémoïser les calculs de
transitions d’un automate.
Remarque 14: La classe de type Applicative
La classe de types Applicative du module de base Haskell Control.Applicative, utilisée
dans le pseudo-code suivant, est une sous-classe de Functor et une super-classe de Monad,
permettant de promouvoir des fonctions de toute arité au niveau d’un foncteur. Elle permet
de déﬁnir notamment les transformations suivantes :
— (<*>) :: f (a -> b) -> f a -> f b permettant d’évaluer une fonction contenue
dans un conteneur fonctoriel;
— liftA2 :: (a -> b -> c) -> f a -> f b -> f c
permettant de promouvoir une
fonction binaire au niveau fonctoriel.
Remarque 15: La notation do
En Haskell, les monades permettent de déﬁnir du sucre syntaxique permettant, par exemple,
de simuler l’exécution séquentielle d’actions ou d’expressions enchaînées.
Ainsi, un terme t de type m a, où m est une monade, peut s’écrire sous la forme
t = do
val1
...
valn
3. Nous reviendrons sur ces automates en utilisant des opérades.
4. L’exemple peut être lancé dans l’interpréteur ghci par la commande stack ghci src/HDRExample/KleisliAuto.hs.

82
Chapitre 5. Les automates de mots
où valn est de type m a et où tout autre terme vali est soit
— de type m b,
— de la forme let x = val,
— de la forme x <- val où val est de type m b.
La transformation en code “normal” s’effectue de la façon suivante :
— un bloc do à une seule valeur val est transformé en val;
— un bloc do de la forme
t = do
let x = val
val2
...
valn
est transformé en
t = let x = val in
do
val2
...
valn
— un bloc do de la forme
t = do
x <- val
val2
...
valn
est transformé en
t = val >>= \x ->
do
val2
...
valn
— un bloc do de la forme
t = do
val1
val2
...
valn
est transformé en
t = val1 >>= \_ ->
do
val2
...
valn
Code Pseudo-Haskell. 25: Exemple : déterminisation et mémoïsation
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TemplateHaskell
#-}
module HDRExample.KleisliAuto where
import
Automata.Automaton
import
Automata.AutomatonTransition
import
Automata.KleisliAutomata
import
Category.Kleisli
import
Control.Monad
import
Data.Function.Memoize
import
Data.Hashable
import
Data.HashSet
( HashSet )
import qualified Data.HashSet
as Set
import
Tools.ToString
-- Déclaration d'un alphabet à deux lettres
data Symbol = A | B
deriving (Show, Read, Enum, Bounded)
-- Instanciation automatique de la mémoïsation
-- par programmation générique

5.2. Autres types d’automates de mots
83
deriveMemoizable ''Symbol
-- Instanciation de la mémoïsation des
-- ensembles via leurs représentations
-- en String
instance (Show a, Read a, Eq a, Hashable a)
=> Memoizable (HashSet a) where
memoize f = memoize (f . read) . show
-- Fonction utilitaire pour la définition
-- de la fonction de transition :
-- incrémentation modulaire
deltaMod :: (Hashable a, Integral a) => a -> a -> HashSet a
deltaMod n p = Set.singleton $ (p + 1) `mod` n
-- Fonction utilitaire pour la définition
-- de la fonction de transition :
-- identité sur les entiers différents de 0
deltaIdPos :: (Eq a, Num a, Hashable a) => a -> HashSet a
deltaIdPos 0 = Set.empty
deltaIdPos p = Set.singleton p
-- Automate atteignant la borne exponentielle de
-- la déterminisation : ici, auto n est
-- un NFA à n états dont le déterminisé atteint la
-- borne de 2n états
auto :: (Hashable a, Integral a) => a -> NFA Symbol a
auto n = packKleisli (Set.fromList [0 .. n - 1]) transFun (== 0)
where
transFun A = deltaMod n
transFun B = deltaIdPos
-- Déterminisé de l'automate calculé par auto n,
-- ayant 2n états.
autoDet
:: (Hashable state, Integral state)
=> state -> DFA Symbol (HashSet state)
autoDet = nfaToDFA . auto
-- Déterminisé de l'automate calculé par auto n,
-- avec une fonction de transition mémoïsée :
-- en mémoire, partie accessible de l'automate des parties
-- utilisée. Affiche un calcul des transitions lors de
-- son (seul et unique) calcul, le mémoïse ensuite.
autoDetMemo
:: (Read state, Show state, Hashable state, Integral state)
=> state
-> DFA Symbol (HashSet state)
autoDetMemo n = memoizeAndTraceAuto $ autoDet n
-- Affichage du calcul de certaines configurations,
-- traçant les uniques calculs des transitions avant leur mémoïsation.
-- Le calcul étant paresseux, de grandes valeurs peuvent être utilisées.
-- Plus précisément, test n b construit les DFA autoDet n et autoDetMemo n
-- ayant tous deux 2n états, puis détermine les configurations
-- associées aux mots An et AnBAn;
-- si b est True, calcule en plus l'ensemble
-- des états accessibles de l'automates, forçant l'évaluation et
-- interprétant les résultats pour un nombre exponentiel de cas.
--
-- Lors de la première utilisation d'une transition étiquetée par x
-- depuis un état ys de l'automate déterminisé s'affiche la chaine
-- (x, fromList states)
-- où states est la liste d'états correspondant à l'ensemble ys.
-- Lors d'une utilisation ultérieure, le calcul ayant été mémoïsé,
-- le calcul intermédiaire n'a plus lieu et rien n'est alors
-- inscrit.
--
-- Par exemple, test 40 False affichera les configurations atteintes
-- par les mots A40 et A40BA40 dans les automates ("virtuels")
-- autoDet 40 et autoDetMemo 40 (ayant 240 états),

84
Chapitre 5. Les automates de mots
-- en ne construisant "réellement" que les états utiles pour le parcours de
-- ces mots.
-- De plus, test 40 True réalisera les mêmes calculs, puis affichera
-- la liste (de longueur exponentielle) des états accessibles de l'automate.
test :: Int -> Bool -> IO ()
test n b = do
-- w = An
let w
= replicate n A
-- w2 = AnBAn
let w2 = w <> [B] <> w
-- DFA avec 2n états
let a1 = autoDet n
-- DFA avec 2n états, mémoïsé
let a2 = autoDetMemo n
-- application de print_config aux couples de paramètres
-- ((aut, n), word) pour (aut, n) dans [(a1, 1), (a2, 2)] et word dans [w, w2]
sequence_ $ print_config <$> [(a1, 1), (a2, 2)] <*> [w, w2]
-- affichage conditionnel des états accessibles
-- (2n états à afficher)
when b $ putStrLn $ toString $ accessibleStates a2
where
-- fonction d'affichage d'une configuration d'un automate
-- associée à un mot
print_config (aut, n) word = do
putStrLn
$
"Configuration associated with "
<> show word
<> " in a"
<> show n
<> ":"
putStrLn $ toString $ (runKleisli $ getConfig aut word) ()
Les automates Booléens ne sont pas les seuls concernés par cette description monadique. Nous allons
voir dans la sous-section suivante comment modéliser d’autres types d’automates en conservant le
même formalisme.
5.2.3
Monade des semimodules libres et automates à multiplicités
Les automates à multiplicités, eux-aussi, peuvent être déﬁnis à partir d’une monade : celle des semi-
modules libres sur un semianneau. NB : dans la suite, nous allons déﬁnir la notion de semimodule
par son implantation Haskell; l’implantation des semianneaux provient du module Data.Semiring
du package semirings, dont les fonctions seront préﬁxées par S. lors de leurs utilisations.
Code Pseudo-Haskell. 26: Automates à multiplicités
-- module Algebra.Structures.Semimodule
-- Un semimodule sur un semianneau est un monoide muni
-- d'une action du semianneau telle que
-- * action k (m1 <> m2) = action k m1 <> action k m2
-- * action (k S.* k') m = action k (action k' m)
-- * action S.one m = m
-- * action (k1 S.+ k2) m = action k1 m <> action k2 m
class (Semiring k, Monoid m) => Semimodule k m where
action :: k -> m -> m
actionR :: m -> k -> m
-- Tout seminanneau est un semimodule sur lui-même.
instance (Monoid k, Semiring k) => Semimodule k k where
action = (S.*)
actionR = action
Les structures algébriques dites libres sont souvent associées à des adjonctions fonctorielles donnant
elles-mêmes lieu à des monades. Dans le cas des semimodules, le semimodule libre sur un ensemble
m sur un semianneau k est l’ensemble des combinaisons linéaires ﬁnies d’éléments de m à coefﬁcients
dans k. En d’autres termes, une combinaison linéaire est une fonction partielle de m vers k dont

5.2. Autres types d’automates de mots
85
une partie ﬁnie de m est le domaine. Dans la suite, nous utiliserons pour les représenter une table
associative.
Remarque 16: Les tables associatives en Haskell
Le
langage
Haskell
possède
de
nombreuses
implantations
des
tables
associatives.
Dans la suite, nous utiliserons le constructeur binaire de types HashMap du module
Data.HashMap.Strict du package unordered-containers. Les fonctions seront précédées
par Map. lors de leur utilisation, telles que :
— unionWith réalisant l’union de deux tables en combinant leurs valeurs avec la fonction
passée en paramètre le cas échéant,
— empty renvoyant une table associative vide,
— singleton associant une unique clé avec une unique valeur,
— map appliquant la fonction passée en paramètre à toutes les valeurs de la table,
— insertWith insérant un couple (clé, valeur) dans une table en combinant avec l’an-
cienne valeur le cas échéant,
— foldlWithKey’ combinant tous les couples (clé, valeur) de la table sur un accumula-
teur.
Code Pseudo-Haskell. 27: Les semimodules libres
-- module Algebra.Structures.Semimodule
-- Type du semimodule libre sur le type m sur le semianneau k
-- définissant:
-- * le constructeur de valeur Free
-- * la fonction de projection getMap pour obtenir la HashMap
--
sous-jacente.
data FreeSemimodule k m where
Free :: Semiring k => {getMap :: HashMap m k} -> FreeSemimodule k m
-- Le type FreeSemimodule k m est un semimodule.
instance Semigroup (FreeSemimodule k m) where
Free s1 <> Free s2 = Free $ Map.unionWith plus s1 s2
instance Semiring k => Monoid (FreeSemimodule k m) where
mempty = Free Map.empty
instance Semiring k => Semimodule k (FreeSemimodule k m) where
-- il suffit de multiplier tous les coefficients des éléments
-- et de retirer ceux qui s'annulent
action k m = Free $ Map.foldlWithKey' aux Map.empty $ getMap m
where
aux acc k_ v =
let val = k S.* v in
if val == zero then acc else Map.insert k_ val acc
actionR m k = Free $ Map.foldlWithKey' aux Map.empty $ getMap m
where
aux acc k_ v =
let val = v S.* k in
if val == zero then acc else Map.insert k_ val acc
-- Le constructeur FreeSemimodule k est un foncteur.
instance FunctorGen (FreeSemimodule k) (->) (->) where
fmap f (Free m) = Free $ Map.foldlWithKey' aux Map.empty m
where aux acc k v = Map.insertWith plus (f k) v acc
-- Le foncteur FreeSemimodule k est une monade.
instance Semiring k => MonadGen (FreeSemimodule k) (->) where
return a = Free $ Map.singleton a one
join (Free m) =
Free $ Map.foldlWithKey' aux Map.empty m
where
aux acc (Free _m) v =
Map.unionWith (+) acc $ Map.map (S.* v) _m

86
Chapitre 5. Les automates de mots
L’utilisation de cette monade permet de manipuler des automates de Kleisli dont les conﬁgurations
sont des combinaisons linéaires d’états, c’est-à-dire les automates à multiplicités, tout en conser-
vant les fonctions déjà factorisées, telles que la construction (packKleisli) ou l’application foncto-
rielle (applyFunctor). Remarquons également l’égalité syntaxique des fonctions de conversion réci-
proques entre automates non-déterministes et à multiplicités Booléennes, ainsi que la grande proxi-
mité avec les algorithmes précédents de conversions d’automates Booléens (Code 24).
Code Pseudo-Haskell. 28: Automates à multiplicités et conversions classiques
-- module Automata.KleisliAutomata
-- Type des automates à multiplicités
type WFA semiring symbol state
= Automaton
(KleisliCat (FreeSemimodule semiring) (->)) () symbol state ()
-- Conversion classique d'un WFA à poids booléens en un NFA.
booleanWFAToNFA :: WFA Bool symbol state -> NFA symbol state
booleanWFAToNFA = castFinality . removeIdFromState . applyFunctor
-- Conversion classique d'un NFA en un WFA à poids booléens.
nfaToBooleanWFA :: NFA symbol state -> WFA Bool symbol state
nfaToBooleanWFA = castFinality . removeIdFromState . applyFunctor
Les automates à multiplicités peuvent alors être utilisés comme suit 5. Le Pseudo-Code 29 montre
comment déﬁnir l’automate de la Figure 5.3.
P
2
5
Q
3
2
R
5
3a
5a −b
2a + 4b
−a
4a
3b
5b
FIGURE 5.3 – Un automate à multiplicités.
Code Pseudo-Haskell. 29: Exemple : Automates à multiplicités
{-# LANGUAGE DeriveGeneric #-}
module HDRExample.KleisliWeightedAuto where
import
Algebra.Structures.Semimodule
import
Automata.Automaton
( getConfig
, weightValue
)
import
Automata.KleisliAutomata
import
Category.Kleisli
import
Data.Hashable
( Hashable )
import qualified Data.HashMap.Strict
as Map
import
Data.List
( intercalate )
import
Data.Maybe
( fromMaybe )
5. L’exemple
peut
être
lancé
dans
l’interpréteur
ghci
par
la
commande
stack ghci
src/HDRExample/KleisliWeightedAuto.hs

5.2. Autres types d’automates de mots
87
import
GHC.Generics
( Generic )
import
Text.Read
( readMaybe )
-- Déclaration d'un alphabet à trois lettres
data Symbol = A | B | C
-- instanciation automatique des classes
-- * Show: conversion en String
-- * Read: conversion depuis String
-- * Eq: implantation de l'égalité
-- * Generic: représentation canonique utilisée pour
--
la génération automatique d'une fonction de
--
hachage (voir plus loin)
deriving (Show, Read, Eq, Generic)
-- instanciation automatique d'une fonction de
-- hachage
instance Hashable Symbol
-- Lecture d'une liste de symboles depuis une
-- String de la forme "X1X2 · · · " avec Xn
-- un caractère parmi 'A', 'B' ou 'C'
stringToSymbol :: String -> Maybe [Symbol]
stringToSymbol = mapM (readMaybe . return)
-- Conversion d'une liste de Symbol en une String
symbolListToString :: [Symbol] -> String
symbolListToString [] = "$\varepsilon$"
symbolListToString xs = concatMap show xs
-- Types des états de l'automate
data State = P | Q | R
deriving (Show, Eq, Generic)
instance Hashable State
-- Multiplicité de l'automate
type Weight = Int
-- Exemples de combinaisons linéaires
f1, f2, f3 :: FreeSemimodule Weight State
-- f1 = 2 P + 3 Q + 5 R
f1 = fromList [(P, 2), (Q, 3), (R, 5)]
-- f2 = 4 P - R
f2 = fromList [(P, 4), (R, -1)]
-- f3 = 3 Q + 5 R
f3 = fromList [(Q, 3), (R, 5)]
-- Fonction de transition de l'automate
delta :: Symbol -> State -> FreeSemimodule Weight State
delta A P = f1
delta B P = f2
delta A Q = f2
delta B R = f3
delta _ _ = fromList []
-- Poids de finalité
fin :: State -> Weight
fin P = 5
fin Q = 2
fin _ = 0
-- Configuration initiale
start :: FreeSemimodule Weight State
start = f1
-- Construction de l'automate
auto :: WFA Weight Symbol State
auto = packKleisli start delta fin
-- Conversion d'une combinaison linéaire en String
prettyPrint :: FreeSemimodule Weight State -> String

88
Chapitre 5. Les automates de mots
prettyPrint (Free m) =
intercalate " + "
$ fmap (\(k, v) -> mconcat [show v, " ", show k])
$ Map.toList m
-- Affichage de la configuration et du poids
-- associé à un mot entré sous la forme "X1X2 · · · "
-- avec Xn un caractère parmi 'A', 'B' ou 'C';
-- si autre entrée, remplace l'entrée par le mot vide
exWFA :: String -> IO ()
exWFA xs = do
let w = fromMaybe [] $ stringToSymbol xs
putStrLn $ mconcat
[ "configuration associated with "
, symbolListToString w
, ": "
, prettyPrint (runKleisli (getConfig auto w) ())
]
putStrLn $ mconcat
[ "weight of "
, symbolListToString w
, ": "
, show (weightValue auto w :: Weight)
]
D’autres monades bien connues car fréquemment utilisées en programmation fonctionnelle per-
mettent également de modéliser des automates à multiplicités, telle que la monade Writer permet-
tant de modéliser des automates séquentiels à multiplicités, ne nécessitant alors qu’une structure de
monoïde et non de semianneau (voir la Section A.1 en annexe).
5.2.4
Monade State, transformers, et automates à pile
Les monades, les catégories de Kleisli associées et leur utilisation dans la déﬁnition d’automates sur
des catégories permettent également de traverser la hiérarchie de Chomsky. Par exemple, l’utilisation
de la monade State et de ses transformers permet de représenter les automates à pile par la déﬁnition
d’une pile contextuelle.
Remarque 17: Monades et transformers
Comme indiqué dans la Remarque 11, les monades ne se composent généralement pas. Évi-
demment, certains couples particuliers de monades se composent. Les transformers de mo-
nades permettent de construire de nouvelles monades en en combinant deux autres. Le cas
des transformers associés à la monade State du module Control.Monad.State.Lazy du pa-
ckage mtl est présenté dans la suite de cette sous-section.
La monade State est une monade permettant de simuler des calculs dépendants de l’accès à une va-
riable globale (au sens de la programmation impérative) ou de sa modiﬁcation, tout en conservant un
aspect fonctionnel pur. Il s’agit, simplement et surprenamment, du type des fonctions polymorphes
s -> (a, s) 6.
Code Pseudo-Haskell. 30: La monade State
-- module HDRExample.PushDownAutomata
-- Le type State s a ne contient qu'un unique champ,
-- une fonction du type s -> (a, s)
newtype State s a = State {runState :: s -> (a, s)}
-- Le type State s est un foncteur.
instance FunctorGen (State s) (->) (->) where
fmap f (State g) = State $ \s -> let (a, s') = g s in (f a, s')
6. En réalité, à un isomorphisme près.

5.2. Autres types d’automates de mots
89
-- Le foncteur State s est une monade.
instance MonadGen (State s) (->) where
return a = State $ \s -> (a, s)
join (State f) = State $ \s -> let (State g, s') = f s in g s'
Cette monade permet de modéliser simplement la dépendance à la pile du calcul de la fonction de
transition d’un automate à pile déterministe; une telle fonction de transition est de la forme Σ →
Q →Γ →(Γ∗, Q), où Σ est l’alphabet des symboles, Q l’ensemble des états et Γ l’alphabet de pile.
Le calcul d’une transition dépend ainsi d’un symbole d’entrée, d’un état et du sommet de la pile,
puis change l’état et remplace le sommet de la pile par un nouveau mot de pile, possiblement vide.
L’état de la pile peut être ainsi enregistré via la monade State. Cependant, la fonction de transition
est partielle : elle n’est pas déﬁnie si la pile est vide. Cela peut être résolu en combinant les monades
State et Maybe.
Code Pseudo-Haskell. 31: La monade MaybeState
-- module HDRExample.PushDownAutomata
-- Il est possible de combiner la monade State et la monade Maybe
-- pour former le constructeur MaybeState, qui ne contient qu'une
-- fonction du type s -> Maybe (a, s)
newtype MaybeState s a = MaybeState {runMaybeState :: s -> Maybe (a, s)}
-- Le type MaybeState s est un foncteur.
instance FunctorGen (MaybeState s) (->) (->) where
fmap f (MaybeState g) = MaybeState $ (\(a, s') -> M.return (f a, s')) <=< g
-- Le foncteur MaybeState s est une monade.
instance MonadGen (MaybeState s) (->) where
return a = MaybeState $ \s -> M.return (a, s)
join (MaybeState f) = MaybeState $ (\(MaybeState g, s') -> g s') <=< f
L’exemple suivant 7 contient la déﬁnition des automates à pile déterministes comme automates sur la
catégorie de Kleisli de la monade MaybeState (Stack stackSymbol), où Stack stackSymbol est un
type de pile polymorphe. Le Pseudo-Code 32 montre comment implanter l’automate à pile détermi-
niste de la Figure 5.4, reconnaissant les mots de la forme anbn+1 par pile vide, avec pour alphabet de
pile le type unitaire (). Pour cela, les transitions sont étiquetées par des triplets de la forme (s, x, f)
avec s un symbole de sommet de pile, x un symbole de l’alphabet et f une action de remplacement
parmi :
— push w remplaçant le sommet de pile par un mot w de symbole de pile;
— pop retirant le symbole de sommet de pile;
— id laissant le sommet de pile inchangé.
0
1
2
(),b,pop
(), a,push()
(), a,id
(),b,pop
(), a + b,id
FIGURE 5.4 – Un automate à pile déterministe.
Code Pseudo-Haskell. 32: Exemple : automates à pile déterministe
{-# LANGUAGE FlexibleContexts
#-}
{-# LANGUAGE LambdaCase
#-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE TupleSections
#-}
{-# LANGUAGE TypeFamilies
#-}
{-# LANGUAGE UndecidableInstances
#-}
module HDRExample.PushDownAutomata where
7. qui peut être lancé dans l’interpréteur ghci par la commande stack ghci src/HDRExample/PushDownAutomata.hs

90
Chapitre 5. Les automates de mots
import
Automata.Automaton
import
Category.FunctorGen
as F
import
Category.Kleisli
import
Category.MonadGen
as M
import
Category.OfStructures.CategoryOfTypes
( )
import
Data.Maybe
import
Text.Read
------------------- Fonctions utilitaires générales ------------------------
-- Fonction utilitaire de composition d'une fonction unaire
-- avec une fonction binaire, simplifiant la syntaxe
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.:) = (.) . (.)
------------------- Définition d'un type de données pour les piles ---------
-- Une pile est soit vide, soit un couple (élément, pile).
data Stack a = Stack [a]
deriving (Show)
-- Teste si une pile est vide.
isEmpty :: Stack a -> Bool
isEmpty (Stack s) = null s
-- Remplace le premier élément d'une pile par une liste (un mot) d'éléments.
-- Ne change rien pour une pile vide.
replaceHeadBy :: [a] -> Stack a -> Stack a
replaceHeadBy _
(Stack []
) = Stack []
replaceHeadBy ys (Stack (_ : as)) = Stack (ys <> as)
-- Crée une pile avec un unique élément.
stackSingleton :: a -> Stack a
stackSingleton a = Stack [a]
------- Fonctions utilitaires pour la construction d'automates à pile
-----
-- Transforme un couple (état, symbole initial de pile) en un morphisme
-- de la catégorie de Kleisli associée à la monade
-- (MaybeState (Stack stackSymbol)).
-- Permet de définir la configuration initiale d'un automate à pile
-- déterministe.
startK
:: state
-> stackSymbol
-> KleisliCat (MaybeState (Stack stackSymbol)) (->) () state
startK = Kleisli .: start
where start i z () = MaybeState $ const $ Just (i, stackSingleton z)
-- Transforme une fonction envoyant un triplet (symbol, state, stackSymbol)
-- sur un couple (mot de stackSymbol, state) en une fonction envoyant un
-- symbol sur un endomorphisme de la catégorie de Kleisli associée à
-- la monade (MaybeState (Stack stackSymbol)).
-- Permet de définir la fonction de transition d'un automate à pile
-- déterministe.
makeKTrans
:: (symbol -> state -> stackSymbol -> ([stackSymbol], state))
-> symbol
-> KleisliCat (MaybeState (Stack stackSymbol)) (->) state state
makeKTrans = Kleisli .: makeTrans
where
makeTrans trans x p = MaybeState $ \case
Stack [] -> Nothing
stack@(Stack (a : _)) ->
let (bs, q) = trans x p a in Just (q, replaceHeadBy bs stack)
-- Transforme un prédicat sur les états (finalité) en un morphisme
-- de la catégorie de Kleisli associée à la monade
-- (MaybeState (Stack stackSymbol)).
-- Permet de définir la fonction de finalité d'un automate à pile

5.2. Autres types d’automates de mots
91
-- déterministe.
makeKFinality
:: (state -> Bool)
-> KleisliCat (MaybeState (Stack stackSymbol)) (->) state ()
makeKFinality = Kleisli . makeFinality
where
makeFinality f p = MaybeState $ \s -> if f p then Just ((), s) else Nothing
--------------------------- Automates à pile -----------------------------
-- Synonyme de type pour les automates à pile déterministes
type PDA stackSymbol symbol state
= Automaton
(KleisliCat (MaybeState (Stack stackSymbol)) (->))
()
symbol
state
()
-- Construction d'un automate à pile
makePDA
:: state
-> stackSymbol
-> (symbol -> state -> stackSymbol -> ([stackSymbol], state))
-> (state -> Bool)
-> PDA stackSymbol symbol state
makePDA i z trans finality =
Auto (startK i z) (makeKTrans trans) (makeKFinality finality)
-- Reconnaissance par pile vide
emptyStackReco :: PDA stackSymbol symbol state -> [symbol] -> Bool
emptyStackReco aut w =
case (runMaybeState $ (runKleisli $ getConfig aut w) ()) (Stack []) of
Nothing
-> False
Just (_, stack) -> isEmpty stack
----------------- Utilisation des automates à pile déterministes------------
-- alphabet binaire des symboles
data Symbol = A | B
deriving (Show, Read, Eq)
-- Fonction utilitaire de conversion depuis une String
stringToSymbol :: String -> Maybe [Symbol]
stringToSymbol = mapM (readMaybe . return)
-- Fonction utilitaire de conversion vers une String
symbolListToString :: [Symbol] -> String
symbolListToString [] = "$\varepsilon$"
symbolListToString xs = concatMap show xs
-- Exemple d'automate reconnaissant, par pile vide,
-- les mots de la forme AnBn+1.
auto :: PDA () Symbol Word
auto = makePDA 0 () aux (const True)
where
-- par A, depuis 0, on arrive en 0 et on remplace le sommet de pile
-- () par le mot ()() (push ())
aux A 0 () = ([(), ()], 0)
-- par B, depuis 0 ou 1, on arrive en 1 et on remplace le sommet de pile
-- () par le mot vide (pop)
aux B 0 () = ([], 1)
aux B 1 () = ([], 1)
-- pour les autres transitions, on va en 2 sans changer la pile
aux _ _ _
= ([()], 2)
-- Affiche la configuration associée et le résultat du
-- test d'appartenance d'un mot w au langage reconnu par pile vide
-- par l'automate auto, mot écrit depuis
-- une String composée de caractères 'A' ou 'B'; remplace w par le mot
-- vide en cas d'échec de lecture.

92
Chapitre 5. Les automates de mots
test :: String -> IO ()
test w = do
let s = fromMaybe [] $ stringToSymbol w
putStrLn $ mconcat
[ "configuration associated with "
, symbolListToString s
, ":"
, show ((runMaybeState $ (runKleisli $ getConfig auto s) ()) (Stack []))
]
putStrLn $ mconcat
[symbolListToString s, " is recognized ? ", show (emptyStackReco auto s)]
Remarquons alors que dans sa déﬁnition (Code 31), la monade MaybeState n’utilise aucune spéci-
ﬁcité de la monade Maybe : seules sont utilisées les fonctions return et (<=<), déﬁnies pour toutes
les monades. On peut alors remplacer la monade Maybe par toute autre monade. Ainsi, d’un point
de vue théorique, il est possible de combiner toute monade avec la monade State en utilisant le
transformer StateT qui suit.
Code Pseudo-Haskell. 33: Le combinateur StateT
-- module HDRExample.PushDownAutomata where
-- Transformer associé à la monade State et au constructeur de type m,
-- contenant une unique fonction du type s -> m (a, s)
newtype StateT m s a = StateT {runStateT :: s -> m (a, s)}
-- Si m est une monade, le constructeur de type StateT m s est un foncteur
instance MonadGen m (->) => FunctorGen (StateT m s) (->) (->) where
type FunctorConstraint (StateT m s) (->) (->) a
= ( FunctorConstraint m (->) (->) (a, s)
, FunctorConstraint m (->) (->) (m (a, s))
, FunctorConstraint m (->) (->) (StateT m s a, s)
)
fmap f (StateT g) = StateT $ (\(a, s') -> M.return (f a, s')) <=< g
-- Si m est une monade, le foncteur StateT m s est une monade
instance MonadGen m (->) => MonadGen (StateT m s) (->) where
return a = StateT $ \s -> M.return (a, s)
join (StateT f) = StateT $ (\(StateT g, s') -> g s') <=< f
L’utilisation de ce transformer permet alors d’utiliser des monades différentes de Maybe pour simu-
ler des automates à piles d’autres sortes, telles que les non-déterministes. NB : le problème de la
partialité de la fonction de transition d’un automate à pile en cas de pile vide peut être résolu par
l’utilisation de la classe de types MonadPlus, classe de la bibliothèque standard Haskell, rappelée
dans l’exemple suivant avant son utilisation.
Le Pseudo-Code 34 suivant montre comment implanter l’automate à pile non-déterministe de la
Figure 5.5 reconnaissant par pile vide le langage constitué des mots de la forme anbn+1 ou anb2n+1.

5.2. Autres types d’automates de mots
93
0
1
2
3
(), a,push()
(), a,push()()
(),b, pop
(), a,push()
(),b, pop
(), a,push()()
(),b, pop
(),b, pop
FIGURE 5.5 – Un automate à pile non-déterministe.
Code Pseudo-Haskell. 34: Exemple : automates à pile non déterministes
-- module HDRExample.PushDownAutomata [suite]
------- Utilitaires pour la construction d'automates de Kleisli à pile
-----
startKT
:: (_)
=> m state
-> stackSymbol
-> KleisliCat (StateT m (Stack stackSymbol)) (->) () state
startKT = Kleisli .: start
where start is z () = StateT $ const $ fmap (, stackSingleton z) is
-- Classe des monades "combinables" et ayant une configuration vide.
-- Utile pour généraliser l'absence de transition en cas de pile vide.
-- Classe présente dans la bibliothèque standard Haskell.
class MonadGen m (->) => MonadPlus m where
-- configuration vide
mzero :: m a
-- combinaison de configurations
mplus :: m a -> m a -> m a
instance MonadPlus Maybe where
mzero = Nothing
mplus Nothing x = x
mplus x
_ = x
instance MonadPlus [] where
mzero = []
mplus = (<>)
makeKTransT
:: (MonadPlus m, _)
=> (symbol -> state -> stackSymbol -> m ([stackSymbol], state))
-> symbol
-> KleisliCat (StateT m (Stack stackSymbol)) (->) state state
makeKTransT = Kleisli .: makeTrans
where

94
Chapitre 5. Les automates de mots
makeTrans trans x p = StateT $ \case
Stack [] -> mzero
stack@(Stack (a :
_)) ->
fmap (\(bs, q) -> (q, replaceHeadBy bs stack)) $ trans x p a
makeKTFinality
:: (MonadPlus m, _)
=> (state -> Bool)
-> KleisliCat (StateT m (Stack stackSymbol)) (->) state ()
makeKTFinality = Kleisli . makeFinality
where
makeFinality f p = StateT $ \s -> if f p then return ((), s) else mzero
------------------- Automates de Kleisli à pile -----------------------------
-- Exemple d'automate de Kleisli à pile: les automates
-- à pile non déterministes à l'aide de la monade des listes.
type NonDetPDA stackSymbol symbol state
= Automaton
(KleisliCat (StateT [] (Stack stackSymbol)) (->))
()
symbol
state
()
-- Construction d'un automate à pile non déterministe
makeNDetPDA
:: [state]
-> stackSymbol
-> (symbol -> state -> stackSymbol -> [([stackSymbol], state)])
-> (state -> Bool)
-> NonDetPDA stackSymbol symbol state
makeNDetPDA is z trans finality =
Auto (startKT is z) (makeKTransT trans) (makeKTFinality finality)
-- Reconnaissance par pile vide
emptyStackNDetReco :: NonDetPDA stackSymbol symbol state -> [symbol] -> Bool
emptyStackNDetReco aut w = any (\(_, stack) -> isEmpty stack)
$ (runStateT $ (runKleisli $ getConfig aut w) ()) (Stack [])
-------------- Utilisation des automates à pile non déterministes-------------
-- Automate reconnaissant, par pile vide, les mots
-- de la forme AnBn+1 ou de la forme
-- AnB2n+1.
auto2 :: NonDetPDA () Symbol Word
auto2 = makeNDetPDA [0] () aux (== 0)
where
aux A 0 () = [([(), ()], 1), ([(), (), ()], 2)]
aux B 0 () = [([], 3)]
aux A 1 () = [([(), ()], 1)]
aux B 1 () = [([], 3)]
aux A 2 () = [([(), (), ()], 2)]
aux B 2 () = [([], 3)]
aux B 3 () = [([], 3)]
aux _ _ _
= []
-- Affiche la configuration associée et le résultat du
-- test d'appartenance d'un mot w au langage reconnu par pile vide
-- par l'automate auto2, mot écrit depuis
-- une String composée de caractères 'A' ou 'B'; remplace w par le mot
-- vide en cas d'échec de lecture.
test2 :: String -> IO ()
test2 w = do
let s = fromMaybe [] $ stringToSymbol w
putStrLn $ mconcat
[ "configurations associated with "
, symbolListToString s
, ":"
, show ((runStateT $ (runKleisli $ getConfig auto2 s) ()) (Stack []))
]

5.3. Conclusion
95
putStrLn $ mconcat
[ symbolListToString s
, " is recognized ? "
, show (emptyStackNDetReco auto2 s)
]
5.3
Conclusion
Dans cette section, nous avons vu comment construire des automates de mots les plus classiques de
la littérature (déterministes, non déterministes, à poids, à pile) en utilisant des notions de théorie des
catégories, et plus particulièrement les monades.
L’ajout d’un contexte, tel qu’une pile, a ainsi pu être modélisé via l’utilisation de la monade State et
de ses transformers. Remarquons alors (1) on peut utiliser toute autre monade à la place de celle des
listes dans les automates à pile de Kleisli; (2) qu’une pile n’est pas le seul type de données qui peut
servir de contexte : il n’y a pas de limites d’utilisation; ainsi, par l’adjonction d’une liste bi-inﬁnie, ou
de deux piles, il est alors possible de simuler une machine de Turing.
Nous avons également montré comment déﬁnir de nouveaux types d’automates, tels que les auto-
mates alternants généralisés, en modiﬁant très légèrement les monades sous-jacentes d’automates
classiques de la littérature, comme les automates alternants.
Dans les sections suivantes, nous allons voir comment une généralisation de la notion de catégorie
(les catégories enrichies) permet de représenter des automates sur d’autres structures que les mots, en
prenant l’exemple des arbres, tout en conservant le pouvoir de factorisation offert par la notion de
monade. Pour cela, nous redéﬁnirons la notion d’opérade, structure algébrique permettant de repré-
senter la composition des arbres, et nous étudierons son point commun avec la notion de monoïde.
Nous reviendrons ensuite sur cette notion pour représenter les expressions rationnelles.


97
6 Extensions des automates de mots :
les automates monoïdaux
Dans cette section, nous allons nous intéresser à l’extension des automates de mots sur d’autres struc-
tures, tels que les arbres. Pour cela, nous allons étudier une généralisation de la notion de monoïde,
les monoïdes-objets, en comparant la structure de monoïde à celle d’opérade; cette notion nous per-
mettra de généraliser tout d’abord des combinaisons classiques de la théorie des automates de mots,
comme l’union ou la somme d’automates.
Une fois cela fait, nous utiliserons également cette généralisation des monoïdes pour construire des
catégories dites enrichies, où les morphismes n’existent plus nécessairement en tant qu’éléments d’en-
sembles; ces catégories permettront de déﬁnir des automates où les structures d’entrées ne sont plus
nécessairement des mots. Nous étudierons également la notion de monade enrichie aﬁn d’expliciter
et de retrouver différents types d’automates comme cas particuliers de la construction proposée.
Pour illustrer ces constructions, nous nous intéresserons aux cas particuliers permettant de retrouver
les automates de mots et d’arbres, en tant que synonymes (ou spécialisations) des notions que nous
aurons déﬁnies.
6.1
Opérade, types gradués et programmation au niveau des types
Comme rappelé dans les préliminaires (page 8), une opérade est une structure algébrique permettant
de représenter la composition des arbres. Cette structure est composée, comme peut l’être d’une fa-
çon différente un monoïde, d’un ensemble de valeurs, muni d’une opération ◦associative (ici vertica-
lement et horizontalement), et d’un élément neutre. La seule différence avec le produit d’un monoïde
est que la composition d’une opérade n’est pas une opération binaire : si le produit d’un monoïde
combine deux valeurs, la composition d’une opérade combine une valeur d’arité k avec k valeurs
d’arité (n1, . . . , nk) pour former un arbre d’arité n1 + · · · + nk.
Cependant, une autre interprétation possible des opérations de combinaison peut permettre de re-
grouper ces deux opérations distinctes. Le produit d’un monoïde sur un ensemble E, de signature
E × E →E peut être vu non pas comme une combinaison de deux valeurs de E, mais comme une
fonction envoyant une construction basée sur E sur E lui-même. Dans le cas des monoïdes, la construc-
tion sous-jacente est le produit cartésien d’ensembles.
Dans le cas des opérades, quelle pourrait être la construction sur l’ensemble? Remarquons alors
que la composition ◦peut se décomposer en deux sous-opérations : tout d’abord, elle produit un
couple de valeurs de la forme (e, (e1, . . . , ek)) où e est un élément de E d’arité k, et où (e1, . . . , ek)
sont k éléments de E d’arité (n1, . . . , nk); ensuite elle combine ces valeurs en un élément de E d’arité
n1 + · · · + nk.
La construction intermédiaire, la formation du couple, peut être vue comme une opération binaire,
mais sur les types! Dans le cas des opérades, il sufﬁt de produire une construction intermédiaire asso-
ciant à deux ensembles gradués F et G l’ensemble gradué des couples de la forme c = ( f, (g1, . . . , gk)),
où f est un élément d’arité k de F, (g1, . . . , gk) sont k éléments de G d’arité (n1, . . . , nk), et où c a pour
arité (par déﬁnition) n1 + · · · + nk. Cette opération est appelée produit tensoriel, noté classiquement
⊗.
Ci-après se trouve une implantation de la notion de type gradué et du produit tensoriel associé
en Haskell. Aﬁn de représenter la graduation des éléments au niveau des types, il peut être utile
d’utiliser la programmation au niveau des types et une représentation des entiers au niveau des

98
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
types; Ainsi, cela permettra de vériﬁer les futures compositions d’éléments à la compilation même
(vériﬁcation par le moteur d’inférence de types).
Remarque 18: Programmation au niveau des types et représentation des entiers
La programmation au niveau des types est une technique de programmation permettant de
promouvoir des informations sur des valeurs au niveau des types, basé sur la théorie des
types [61, 75]. Le langage Haskell est un très bon support pour implanter ces notions [60]
(voir également une présentation de cette notion en Idris dans [13], autre langage de pro-
grammation fonctionnelle très proche d’Haskell).
Par exemple, on peut imaginer créer deux types numériques Pair et Impair, et une fonction
de multiplication de signature possible
— Pair -> Pair -> Pair;
— Impair -> Impair -> Impair;
— Impair -> Pair -> Pair;
— Pair -> Impair -> Pair;
Une telle fonction est dite type-dépendante : son type de sortie dépend du type d’entrée. En
Haskell, il est possible d’implanter cela à l’aide des classes de types, mais aussi de familles de
types (permettant de réaliser des fonctions au niveau des types). Par exemple, la fonction de
multiplication peut être implantée comme suit :
{-# LANGUAGE TypeFamilies
#-}
{-# LANGUAGE MultiParamTypeClasses
#-}
-- Définition des types pour les entiers
newtype Pair = Pair Word
newtype Impair = Impair Word
-- Fonction de conversion vers les entiers positifs
class ToWord a where
toWord :: a -> Word
instance ToWord Pair where
toWord (Pair x) = 2 * x
instance ToWord Impair where
toWord (Impair x) = 2 * x + 1
-- Conversion en String
instance Show Pair where
show = show . toWord
instance Show Impair where
show = show . toWord
-- Famille de types permettant de calculer
-- le type de retour de la fonction de multiplication
-- en fonction des entrées
type family Combi a b where
Combi Impair Impair = Impair
Combi _ _ = Pair
-- Déclaration de la classe de types pour
-- implanter la fonction de multiplication
-- dont le type de retour dépend du type
-- des entrées
class Mult a b where
mult :: a -> b -> Combi a b
-- Instances permettant de distinguer les différents
-- cas de calculs
instance Mult Pair Pair where
mult (Pair x) (Pair y) = Pair $ 2 * x * y
instance Mult Pair Impair where
mult (Pair x) (Impair y) = Pair $ x * (2 * y + 1)
instance Mult Impair Pair where
mult (Impair y) (Pair x) = Pair $ x * (2 * y + 1)

6.1. Opérade, types gradués et programmation au niveau des types
99
instance Mult Impair Impair where
mult (Impair x) (Impair y) = Impair $ 2 * x * y + x + y
-- cas incorrect détecté par le moteur d'inférence
-- wrong :: Impair
-- wrong = mult (Pair 2) (Pair 3)
-- Affichage de quelques résultats où
-- * Pair 2
= 4
-- * Impair 2 = 5
-- * Pair 3
= 6
-- * Impair 3 = 7
main :: IO ()
main = do
print $ mult (Pair 2) (Pair 3)
-- = 24
print $ mult (Pair 2) (Impair 3)
-- = 28
print $ mult (Impair 2) (Pair 3)
-- = 30
print $ mult (Impair 2) (Impair 3) -- = 35
Une autre application simple est par exemple de typer des listes en fonction de leurs lon-
gueurs; ainsi, une liste de type longueur n a concaténée à une liste de type longueur m pro-
duit une liste de type longueur (n + m). Remarquons alors que la fonction de concaténation
est type-dépendante : le type de sortie longueur (n + m) dépend des types en entrée. Que
devrait être alors le résultat de la concaténation avec une liste vide?
Cette remarque soulève le problème de la représentation des entiers au niveau des types; le
plus simple est alors d’utiliser l’arithmétique de Peano : un entier au niveau des types et soit
0, soit un successeur de 0. Cette représentation, appelée par la suite Nat, est implantée dans
le module Type.Natural des sources de ce projet. Y sont également implantées les preuves
(au sens de l’isomorphisme Curry-Howard) de l’égalité entre les types n, n + 0 et 0 + n, de
l’associativité de la somme, etc b. Dans la suite, pour lever les ambiguïtés, un entier n sera noté
Nat_n pour sa représentation au niveau des types.
a. Ces listes, dont la longueur est connue à la compilation, sont implantées dans le module Tools.Vector.
b. Ces fonctions sont utilisées dans le code source pour lever les ambiguïtés induites par des égalités de types que
le moteur d’inférence ne peut déduire seul (voir par exemple le module Algebra.Structures.Operad); l’utilisation
de ces fonctions sera cependant effacé des pseudo-codes de ce document, pour ne pas alourdir le propos.
Remarque 19: Types et genres
Si Nat_1, String ou Maybe sont des types, ils ne sont pas comparables : ils ne sont pas du
même genre (appelé kind en Haskell). Attention : il y a nécessairement une hiérarchie au
niveau des types; pour les mêmes raisons que l’ensemble des ensembles n’existe pas, il n’y a
pas de types des types. Ici :
— String est un ensemble de valeurs : en Haskell, il a pour genre *, le genre des types
contenant des valeurs;
— Maybe a pour genre * -> *, le type des constructeurs de type unaire : il attend un type
de genre * pour renvoyer un type de genre *; par exemple Maybe String a pour genre
*;
— Nat_1 est (ici) de genre Nat; Nat_1 est bien un type, mais inhabité. Il en va de même
pour les types listes de Nat, tels que [Nat_1, Nat_2,Nat_1,Nat_4], qui est un type du
genre [Nat].
Malheureusement, il n’y a pas (pour le moment) de type de genre en Haskell, contrairement
aux univers d’Agda.
Code Pseudo-Haskell. 35: Types gradués
-- module Graded.Graded
-- Un type est gradué s'il est instance de la classe suivante.
class Graded a where
-- Pour tout entier n, il existe un type de données pour les

100
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
-- valeurs d'arité n de a
data Graduation a (n :: Nat)
-- Fonction de conversion entre les données graduées
-- et les données non graduées de a
fromGrad :: Graduation a n -> a
-- Fonction transformant un élément de a en sa version graduée
toGrad :: a -> Graduation a n
-- Fonction permettant de récupérer à l'exécution la graduation
-- d'un élément de type gradué
graduation' :: Graduation a (n :: Nat) -> Natural n
graduation' _ = singleton
Deux des constructions les plus simples de types gradués sont le type (), qui ne contient qu’un
élément d’arité (arbitrairement choisie pour le moment) 1, et le type Identity a où a est un type
gradué.
Code Pseudo-Haskell. 36: Exemples de types gradués simples
-- module Graded.Graded
-- Graduation pour le type ()
instance Graded () where
-- Il n'y a qu'une seule valeur graduée associée au type ()
-- la valeur GradUn
d'arité 1
data Graduation () n where
GradUn ::Graduation () Nat_1
-- Conversion de () à Graduation () Nat_1
toGrad () = GradUn
-- Conversion de Graduation () Nat_1 à ()
fromGrad GradUn = ()
-- Si a est un type gradué, alors Identity a est gradué
instance Graded a => Graded (Identity a) where
-- Les éléments d'arité n de Identity a sont de la forme
-- GradId x, où x est un élément d'arité x de a;
-- définition simultanée de la fonction de projection
-- runId permettant d'extraire l'élément gradué
data Graduation (Identity a) n where
GradId ::{runId :: Graduation a n} -> Graduation (Identity a) n
-- Conversions
fromGrad (GradId x) = Identity $ fromGrad x
toGrad (Identity x) = GradId $ toGrad x
Un produit tensoriel de types gradués est alors la construction d’un couple c composé d’un élément
gradué e et d’une liste dont les contraintes sont les suivantes :
— sa longueur est l’arité de e;
— les éléments qu’elle contient déterminent l’arité du couple, qui est égale à leur somme.
Pour réaliser cela au niveau des types, il sufﬁt de créer le type des listes contenant des éléments d’un
type gradué, type paramétré par l’arité des éléments qu’elles contiennent! NB : Pour réaliser cela,
nous utiliserons les fonctions et preuves (au sens de l’isomorphisme Curry-Howard) contenues dans
le module Type.NaturalList des sources de ce projet.
Code Pseudo-Haskell. 37: Les listes paramétrées par la graduation des éléments qu’elles
contiennent
-- module Graded.GradedVector
-- Type des listes paramétrées par la graduation des éléments
-- qu'elles contiennent; ici ms est une liste (au niveau des types)

6.1. Opérade, types gradués et programmation au niveau des types
101
-- de Nat
data GradVect (ms :: [Nat]) a where
-- la liste vide est paramétrée par la liste vide
GradVNil ::GradVect
[]
a
-- une liste non vide est constituée d'un élément d'arité
-- n1, d'une liste dont les arités sont une liste ms,
-- et le paramètre d'une telle liste est l'ajout
-- de n1 en tête de ms
GradVCons :: Graduation a n1 -> GradVect ms a -> GradVect (n1 : ms) a
Ainsi, une liste de type GradVect [Nat_1, Nat_4, Nat_2] a sera une liste contenant trois valeurs,
d’arité respective 1, 4 et 2. De même, si une liste est de type GradVect ms (), alors la liste ms est une
liste ne contenant que des occurrences d’arité Nat_1, soit la valeur GradUn.
Remarque 20: Le type GradVect
Le type GradVect est implanté dans le module Graded.GradedVector. Ce module contient
de nombreuses fonctions utilitaires utilisées par la suite, telles que la fonction mapVect appli-
quant une fonction graduée sur tous les éléments, ou replicateGrad permettant de créer un
vecteur de longueur ﬁxé en répétant le même élément.
L’utilisation de ces listes permet alors de déﬁnir simplement le produit tensoriel de types gradués,
qui est lui-même gradué. NB : Dans la suite sont utilisées des familles de types, assimilables à des
fonctions sur les types; ainsi :
— Length ms, du module Type.List renvoie le Nat correspondant à la longueur d’une liste (au
niveau des types) ms;
— First a et Second a, du module Category.CategoryGen sont des fonctions de projections
pour les couples de types;
— SumNat ms, du module Type.Natural,renvoie l’entier qui est la somme des Nat contenue dans
une liste ms.
Code Pseudo-Haskell. 38: Produit tensoriel des types gradués
-- Category.OfGraded.TensorProductOfGraded
-- Le produit tensoriel d'un type a = (b, c) est composé
-- d'un élément gradué de type b (= First a) dont l'arité est
-- la longueur de la liste paramétrant le second composant,
-- qui est une liste d'éléments gradués de c (= Second a);
-- les arités des éléments qu'elle contient sont contenues dans ms
data TensorProd a where
TensorProd ::
Graduation (First a) (Length ms)
-> GradVect ms (Second a)
-> TensorProd a
-- Un produit tensoriel de type gradué est gradué
instance Graded (TensorProd a) where
-- Un produit tensoriel a pour graduation
-- la somme des arités de sa seconde composante
data Graduation (TensorProd a) arite where
GradTensor ::
Graduation (First a) (Length ms)
-> GradVect ms (Second a)
-> Graduation (TensorProd a) (SumNat ms)
-- Fonctions de conversion
toGrad (TensorProd x xs) = GradTensor x xs
fromGrad (GradTensor x xs) = TensorProd x xs
La notion de produit tensoriel n’est pas spéciﬁque aux types gradués. En effet, cette notion a un sens
beaucoup plus général en théorie des catégories, et est une opération fondamentale dans la déﬁnition
des catégories monoïdales.

102
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
6.2
Catégorie monoïdale
Nous avons vu comment construire un nouveau type gradué comme un produit tensoriel de deux
types gradués. Mais cette construction permet également de construire des fonctions entre produits
tensoriels. Par exemple, si A, B, C et D sont des types gradués, et si f et g sont des fonctions graduées
(c’est-à-dire des fonctions préservant l’arité des éléments) respectivement de A vers B et de C vers D,
alors il est possible de construire une fonction graduée f⊗g de A⊗C vers B⊗D : si (a, (c_1, ...,
c_k)) est un élément de A⊗C, son image par f⊗g est (f a, (g c_1, ..., g c_k)).
Cette construction, envoyant alors des objets sur des objets et des fonctions sur des fonctions, est bel
et bien un foncteur, depuis une catégorie produit, déﬁnie comme suit.
Le produit de deux catégories C et D est la catégorie C × D dont :
— les objets sont les couples (C, D) d’objets C de C et D de D ;
— les morphismes depuis un objet (C1, D1) vers un objet (C2, D2) sont les couples ( f, g) de mor-
phismes f entre C1 et C2 et g entre D1 et D2 ;
— la composition de deux morphismes ( f, g) et ( f ′, g′) est le morphisme ( f ′ ◦C f, g′ ◦D g);
— le morphisme identité pour un objet (C, D) est le morphisme (IdC, IdD).
Code Pseudo-Haskell. 39: Catégorie produit
-- module Category.CategoryGen
-- Type de données pour une catégorie produit
data ProdCat cat cat' a b = Prod (cat (First a) (First b)) (cat' (Second a) (Second b))
-- La construction ProdCat est une catégorie.
instance (CategoryGen cat, CategoryGen cat') => CategoryGen (ProdCat cat cat') where
id = Prod id id
Prod f1 g1 . Prod f2 g2 = Prod (f1 . f2) (g1 . g2)
Cette construction de produit binaire peut être étendue sans difﬁculté à un produit d’une arité arbi-
traire.
Un produit tensoriel sur une catégorie C est un foncteur de C × C vers C 1. Cette construction de pro-
duit tensoriel binaire peut être étendue, elle aussi, sans difﬁculté à un produit tensoriel d’une arité
arbitraire.
Des constructions classiques de la théorie des ensembles, tels que le produit cartésien ou la somme
disjointe, sont des produits tensoriels pour la catégorie des types, comme l’illustre le code suivant.
Code Pseudo-Haskell. 40: Produits tensoriels de la catégorie des types
-- Category.OfStructures.CategoryOfTypes
-- Type de données pour le produit cartésien de types
data Prod a = Product {runProduct :: (First a, Second a)}
-- Le produit cartésien est un produit tensoriel.
instance FunctorGen Prod (ProdCat (->) (->)) (->) where
fmap (Prod f g) (Product (x, y)) = Product (f x, g y)
-- Type de données pour la somme disjointe de types
data Sum a = Fst (First a) | Snd (Second a)
-- Type isomorphe au type des catégories (pour éviter
-- un conflit des définitions de foncteurs)
newtype SumTypeCat a b = SumTypeCat {runSum :: a -> b}
deriving CategoryGen
-- La somme disjointe est un produit tensoriel.
instance FunctorGen Sum (ProdCat SumTypeCat SumTypeCat) SumTypeCat where
fmap (Prod (SumTypeCat f) (SumTypeCat g)) = SumTypeCat $ \case
1. aussi appelé bifoncteur sur C.

6.2. Catégorie monoïdale
103
Fst a -> Fst $ f a
Snd b -> Snd $ g b
Remarque 21: Produits tensoriels et constructions d’automates
Un foncteur depuis une catégorie produit ProdCat cat cat’ vers une catégorie cat” permet
de combiner deux automates respectivement sur les catégories cat et cat’ en un automate
sur la catégorie cat”.
Cette
transformation
est
implantée
par
la
fonction
functorProduct
du
module
Automata.Automaton :
-- Automata.Automaton
-- Transforme deux automates en un automate réalisant le
-- parcours parallèle de ces deux automates, dans la catégorie
-- produit.
parallelProduct
:: Automaton cat init symbols state value
-> Automaton cat' init' symbols state' value'
-> Automaton
(ProdCat cat cat')
(init, init')
symbols
(state, state')
(value, value')
parallelProduct (Auto i d f) (Auto i' d' f') =
Auto (Prod i i') (\a -> Prod (d a) (d' a)) (Prod f f')
-- Applique un foncteur sur un automate.
functorAut
:: (FunctorGen f cat1 cat2)
=> Automaton cat1 a2 symbols a1 b
-> Automaton cat2 (f a2) symbols (f a1) (f b)
functorAut (Auto i d f) = Auto (F.fmap i) (F.fmap . d) (F.fmap f)
-- Applique un foncteur depuis une catégorie produit
-- sur le produit de deux automates
-- donnés en paramètres
functorProduct
:: (FunctorGen bifunc (ProdCat cat cat') cat'')
=> Automaton cat init symbols state value
-> Automaton cat' init' symbols state' value'
-> Automaton
cat''
(bifunc (init, init'))
symbols
(bifunc (state, state'))
(bifunc (value, value'))
functorProduct a1 a2 = functorAut $ parallelProduct a1 a2
Si le produit parallèle d’automates peut être utilisé pour déﬁnir des automates exotiques
(voir par exemple la Section A.2 pour un produit entre un automate alternant et un au-
tomate à multiplicités), on peut également l’utiliser pour retrouver des algorithmes bien
connus. Les foncteurs Prod et Sum étant également des bifoncteurs pour certaines catégories de
Kleisli (voir les implantations dans les modules Category.OfStructures.CategoryOfTypes
et Algebra.Structures.Semimodule), la fonction functorProduct rend possible, dans le
cadre des automates de Kleisli associés aux monades de la catégorie des types, la factorisation
de transformations associées au produit cartésien et à la somme disjointe en deux fonctions du
module Automata.KleisliAutomata, les fonctions binaryTransformationByProductWith
(créant l’automate produit par functorProduct puis utilisant des transformations natu-
relles des catégories monoïdales pour réduire la conﬁguration initiale et la fonction para-
mètre pour calculer la sortie) et binaryTransformationBySum (créant l’automate somme par
functorProduct puis réduisant la sortie par la fonction paramètre).
Sans rentrer dans les détails très techniques, les transformations suivent les algorithmes clas-
siques. Ainsi,
— l’intersection de deux automates non-déterministes, l’intersection de deux automates

104
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
déterministes et le produit de Hadamard de deux automates à multiplicités sont im-
plantés identiquement dans le module Automata.KleisliAutomata comme
-- module Automata.KleisliAutomata
intersectionNFA = binaryTransformationByProductWith (const $ const ())
productWFA = binaryTransformationByProductWith (const $ const ())
intersectionDFA = binaryTransformationByProductWith (const $ const ())
— l’union de deux automates non-déterministes et la somme de deux automates à mul-
tiplicités sont implantés identiquement dans le module Automata.KleisliAutomata
comme
-- module Automata.KleisliAutomata
unionNFA a1 a2 =
reduceInitialSum (<>) $ reduceFinalSum id id $ binaryTransformationBySum a1 a2
sumWFA a1 a2 =
reduceInitialSum (<>) $ reduceFinalSum id id $ binaryTransformationBySum a1 a2
La fonction binaryTransformationBySum est également utilisée pour calculer la concaténa-
tion de deux automates non-déterministes a. Pour la version générale de la notion de combi-
naison Booléenne d’automates, voir le Pseudo-Code 145 en annexe.
a. Nous nous y intéresserons plus tard lorsque nous aborderons la construction inductive des automates depuis
une expression rationnelle.
Au même titre qu’une opération ensembliste, un produit tensoriel peut vériﬁer des propriétés remar-
quables. Si une opération associative et unifère fonde un monoïde, un produit tensoriel naturellement
associatif et unifère fonde une catégorie monoïdale.
Une catégorie monoïdale est un quintuplet (C, ⊗, I, α, λ, ρ) où
— C est une catégorie;
— ⊗est un produit tensoriel sur C ;
— I, l’unité, est un objet de C ;
— α, l’associateur, est un isomorphisme naturel entre deux produits tensoriels ternaires, dont
chaque composant αA,B,C est un morphisme de (A ⊗B) ⊗C vers A ⊗(B ⊗C);
— λ, l’identité gauche, est un isomorphisme naturel dont chaque composant λA est un morphisme
de I ⊗A vers A;
— ρ, l’identité droite, est un isomorphisme naturel dont chaque composant ρA est un morphisme
de A ⊗I vers A.
Code Pseudo-Haskell. 41: Catégories monoïdales
-- module Category.MonoidalCategory
-- Classe de type des catégories monoïdales.
class Bifunctor tensor cat => Monoidal cat tensor where
-- Unité de la catégorie monoïdale
type Unit cat tensor :: *
-- Associateurs
alpha :: cat (tensor (tensor (a, b), c)) (tensor (a, tensor (b, c)))
alphaInv :: cat (tensor (a, tensor (b, c))) (tensor (tensor (a, b), c))
-- Identités gauches
lambda :: cat (tensor (Unit cat tensor, a)) a
lambdaInv :: cat a (tensor (Unit cat tensor, a))
-- Identités droites
rho :: cat (tensor (a, Unit cat tensor)) a
rhoInv :: cat a (tensor (a, Unit cat tensor))
Le produit cartésien ou la somme disjointe permettent de déﬁnir une catégorie monoïdale sur la
catégorie des types. Si l’unité pour le produit cartésien est le type () à un seul élément, l’unité pour

6.2. Catégorie monoïdale
105
la somme disjointe est le type vide sans aucun élément, appelé Void en Haskell.
Remarque 22: Le type Void
Le type Void est un type inhabité, correspondant à la constante fausse dans l’isomorphisme
Curry-Howard. L’application de l’ex falso sequitur quodlibet est la fonction absurd de signature
Void -> a, déﬁnie pour tout type a.
Code Pseudo-Haskell. 42: Catégories monoïdales des types
-- module Category.OfStructures.CategoryOfTypes
-- La catégorie monoïdale associée au produit cartésien
instance Monoidal (->) Prod where
type Unit (->) Prod = ()
alpha (Product (Product (a, b), c)) = Product (a, Product (b, c))
alphaInv (Product (a, Product (b, c))) = Product (Product (a, b), c)
lambda (Product ((), a)) = a
lambdaInv a = Product ((), a)
rho (Product (a, ())) = a
rhoInv a = Product (a, ())
-- La catégorie monoïdale associée à la somme disjointe
instance Monoidal SumTypeCat Sum where
type Unit SumTypeCat Sum = Void
alpha = SumTypeCat $ \case
Fst (Snd b) -> Snd $ Fst b
Fst (Fst a) -> Fst a
Snd c
-> Snd $ Snd c
alphaInv = SumTypeCat $ \case
Snd (Fst b) -> Fst $ Snd b
Fst a
-> Fst $ Fst a
Snd (Snd c) -> Snd c
lambda = SumTypeCat $ \case
Snd a -> a
Fst v -> absurd v
lambdaInv = SumTypeCat Snd
rho
= SumTypeCat $ \case
Fst a -> a
Snd v -> absurd v
rhoInv = SumTypeCat Fst
Le produit tensoriel de types gradués s’exprime également comme un foncteur. Pour cela, il faut
d’abord déﬁnir la catégorie de départ sur laquelle déﬁnir un bifoncteur. Cette catégorie est la catégo-
rie des types gradués, dont les morphismes sont les fonctions préservant l’arité.
Code Pseudo-Haskell. 43: Types gradués et produit tensoriel
-- module module Category.OfGraded.CategoryOfGraded
-- Type de données pour les fonctions préservant la graduation,
-- et définition de la fonction de projection
-- applyMorph
data GradedMorph a b where
GradedMorph ::
(Graded a, Graded b)
=> {applyMorph ::
forall n . Singleton n => Graduation a n -> Graduation b n}
-> GradedMorph a b
-- Les fonctions préservant la graduation forment une
-- catégorie

106
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
instance CategoryGen GradedMorph where
GradedMorph f . GradedMorph g = GradedMorph $ f . g
id = GradedMorph id
-- Le produit tensoriel de type gradué est un bifoncteur
instance FunctorGen TensorProd (ProdCat GradedMorph GradedMorph) GradedMorph where
fmap (Prod (GradedMorph f) (GradedMorph g)) =
GradedMorph $ \(GradTensor x ys) -> GradTensor (f x) (mapVect g ys)
Ce produit tensoriel est :
— associatif : pour un élément a d’arité k, pour un vecteur b de k éléments b1, . . . , bk d’arités res-
pectives n1, . . . , nk, pour un vecteur c de n1 + · · · + nk éléments c1,1, . . . , c1,n1, . . . , ck,1, . . . , ck,nk,
l’associateur envoie l’élément ((a, b), c) sur l’élément
(a, (b1, (c1,1, . . . , c1,n1), . . . , bk, (ck,1, . . . , ck,nk)));
(6.1)
la transformation des deux vecteurs b et c en un vecteur de k produits tensoriels est implantée
par la méthode carve de la classe Carve du module Graded.GradedCoupleVector (voir la
Remarque 23);
— unifère, en notant ∗l’élément d’arité 1 d’un ensemble à un élément :
— l’associateur gauche envoie un élément de la forme (∗, (x)) sur x ;
— l’associateur droit envoie un élément de la forme (x, (∗, . . . , ∗)) sur x.
Remarque 23: Fonctions type-dépendantes et méthodes
Les fonctions type-dépendantes peuvent être implantées en Haskell par le biais des classes de
types et des familles de types.
Il sufﬁt pour cela de déﬁnir les fonctions sur l’ensemble des types possibles, par induction sur
la forme des types.
C’est le cas par exemple de la méthode carve du module Graded.GradedCoupleVector per-
mettant de recombiner les éléments d’un produit tensoriel. Pour cela sont déﬁnies des familles
de types permettant d’exprimer le type de la sortie en fonction des types d’entrée.
Le moteur d’inférence n’étant pas capable d’induire les équivalences de type non triviales, il
peut être nécessaire de coder des preuves d’équivalence et des implications de contraintes.
C’est le cas de la fonction carveProof du module Graded.GradedCoupleVector, permettant
de justiﬁer que la fonction carve est applicable pour toutes listes de Nat vériﬁant des condi-
tions minimales, à savoir que la longueur du vecteur c doit être la somme des arités des
éléments du vecteur b de l’équation (6.1).
Le produit tensoriel précédent permet ainsi de déﬁnir une catégorie monoïdale sur les types gradués.
Code Pseudo-Haskell. 44: Catégorie monoïdale des types gradués
-- module module Category.OfGraded.CategoryOfGraded
-- La catégorie monoïdale des types gradués
instance Monoidal GradedMorph TensorProd where
type Unit GradedMorph TensorProd = ()
alpha = GradedMorph $ \(GradTensor (GradTensor a bs) cs) ->
GradTensor a
(mapVect (\(GradCouple b c) -> GradTensor b c) $ carve bs cs)
lambda = GradedMorph $ \(GradTensor GradUn (GradVCons y GradVNil)) -> y
lambdaInv =
GradedMorph $ \y ->
GradTensor GradUn (GradVCons y GradVNil)
rho = GradedMorph $ \(GradTensor x _) -> x
rhoInv = GradedMorph $ \x ->
GradTensor x $ replicateGrad (graduation' x) GradUn

6.2. Catégorie monoïdale
107
Une fois ﬁxé, un produit tensoriel permet également de mettre en lumière certains objets particuliers
des catégories monoïdales. En effet, certains objets admettent une stabilité par rapport à un produit
tensoriel; c’est le cas par exemple des monoïdes dans la catégorie monoïdale des types en considé-
rant le produit cartésien comme produit tensoriel : la loi de composition interne d’un monoïde sur
un ensemble sous-jacent M permet d’envoyer M × M sur M; son élément neutre, équivalent à un
morphisme de {∗} (l’ensemble à un élément) vers M, permet d’établir une propriété d’identité à par-
tir des morphismes et du produit tensoriel. Pour résumer, il est possible de généraliser les monoïdes
au sein de toutes catégories monoïdales; ces objets particuliers sont les monoïdes objets, à la base de
descriptions surprenantes de structures algébriques.
Un monoïde objet d’une catégorie monoïdale (C, ⊗, I, α, λ, ρ) est un triplet (M, µ, η) avec :
— M un objet de C,
— µ un morphisme de M ⊗M vers M,
— η un morphisme de I vers M
faisant commuter les diagrammes suivants :
M ⊗M ⊗M
M ⊗(M ⊗M)
M ⊗M
M ⊗M
M,
αM,M,M
µ ⊗IdM
IdM ⊗µ
µ
µ
I ⊗M
M ⊗M
M ⊗I
M.
η ⊗IdM
λM
µ
IdM ⊗η
ρM
Code Pseudo-Haskell. 45: Monoïdes objets et leurs catégories
-- module Category.MonoidalCategory
-- Classe de types des monoïdes objets d'une catégorie monoïdale
class (Monoidal cat tensor) => MonoidObject m cat tensor where
mu :: cat (tensor (m, m)) m
eta :: cat (Unit cat tensor) m
-- Type de données des morphismes de monoïdes objets,
-- et définition de la fonction de projection
-- runMonoidObjectMorph
data MonoidObjectMorph cat tensor m m' where
MonoidObjectMorph ::(MonoidObject m cat tensor, MonoidObject m' cat tensor)
=> {runMonoidObjectMorph :: cat m m'} -> MonoidObjectMorph cat tensor m m'
-- Les morphismes de monoïdes objets forment une catégorie
instance Monoidal cat tensor => CategoryGen (MonoidObjectMorph cat tensor) where
id = MonoidObjectMorph id
MonoidObjectMorph f . MonoidObjectMorph g = MonoidObjectMorph $ f . g
Si les monoïdes objets de la catégorie monoïdale des types munis du produit cartésien sont les mo-
noïdes classiques, d’autres structures peuvent être déﬁnies par le biais des monoïdes objets.
Par exemple, le principe d’Eckmann-Hilton [37] permet de montrer que les monoïdes objets de la
catégorie monoïdale des monoïdes, construite avec le produit direct de monoïde en produit tensoriel,
sont les monoïdes commutatifs. En effet, pour (M, ·, ε) un monoïde et (M, ·′, ε′), c’est-à-dire ·′ un
morphisme de monoïde de (M × M, ⊙, (ε, ε)) dans (M, ·, ε) et ε′ un élément neutre pour ·′ 2, on a :
(x, x′) ⊙(y, y′) = (x · y, x′ · y′)
(Déﬁnition ⊙)
(·′)((x, x′) ⊙(y, y′)) = (·′)(x, x′) · (·′)(y, y′)
(·′ morphisme de monoïde)
= (x ·′ x′) · (y ·′ y′)
(Réécriture inﬁxe)
Ainsi
(·′)((x · y, x′ · y′)) = (x · y) ·′ (x′ · y′),
2. Formellement, ε′ est un morphisme du monoïde ({()},_, ()) à un élément dans M, assimilable à un élément de M.

108
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
c’est-à-dire
(x · y) ·′ (x′ · y′) = (x ·′ x′) · (y ·′ y′).
Avec ceci, on peut montrer que
— ε = ε′ :
ε = ε · ε = (ε ·′ ε′) · (ε′ ·′ ε)
= (ε · ε′) ·′ (ε′ · ε) = ε′ ·′ ε′ = ε′;
— · = ·′ et · commute :
x · y = (ε′ ·′ x) · (y ·′ ε′) = (ε′ · y) ·′ (x · ε′)
= (ε · y) ·′ (x · ε)
= y ·′ x
= (y · ε) ·′ (ε · x)
= (y ·′ ε) · (ε ·′ x)
= (y ·′ ε′) · (ε′ ·′ x) = y · x.
— · est associative :
(x · y) · z = (x · y) · (ε · z)
= (x · ε) · (y · z) = x · (y · z).
D’où (M, ·, ε) est un monoïde commutatif. D’autres structures peuvent être déﬁnies à l’aide de mo-
noïdes objets :
— les semi-anneaux sont les monoïdes objets de la catégorie des monoïdes commutatifs;
— les semi-algèbres sur un semi-anneau sont les monoïdes objets de la catégorie des semi-modules
(sur le semi-anneau ambiant);
— les catégories monoïdales 3 sont les monoïdes objets de la catégorie des (petites 4) catégories.
Y compris les monades :
All told, a monad in [a category] C is just a monoid in the category of endofunctors of C, with
product ⊗replaced by composition of endofunctors and unit set by the identity endofunctor.
(Saunders MacLane, Categories for the Working Mathematician [59])
6.3
Retour aux opérades
Quant aux opérades, ce sont les monoïdes objets de la catégorie des types gradués. On peut donc les
implanter ainsi.
Code Pseudo-Haskell. 46: Opérades
-- module Algebra.Structures.Operad
-- Synonyme de type pour définir une opérade
type Operad a = MonoidObject a GradedMorph TensorProd
-- Synonyme de type pour les morphismes d'opérades
type OperadMorphism o o' = MonoidObjectMorph GradedMorph TensorProd o o'
-- Définition de la composition d'une opérade en fonction
-- du morphisme mu du monoïde objet
operadComposition
:: ( Operad a
, Graded a
)
=> Graduation a (Length ns)
-> GradVect ns a
-> Graduation a (SumNat ns)
operadComposition a as = applyMorph mu (GradTensor a as)
-- Définition de l'élément neutre de l'opérade à partir
3. strictes pour être précis, c’est-à-dire où les isomorphismes naturels sont des identités.
4. distinction permettant d’éviter le paradoxe de Russel.

6.3. Retour aux opérades
109
-- du morphisme eta du monoïde objet
operadUnit :: Operad a => Graduation a Nat_1
operadUnit = applyMorph eta GradUn
Un exemple d’opérade non-triviale est l’opérade des fonctions n-aires sur un type donné munie de la
composition de fonctions, implantée dans le module Algebra.Functions.GradedFunctions5 sous
le type général MultiFun. On peut également s’intéresser la construction de l’opérade libre depuis
un type gradué.
Code Pseudo-Haskell. 47: Opérade libre
-- module Algebra.Structures.Operad
-- L'opérade libre sur le type gradué a est constitué soit de l'élément
-- neutre Eps, soit d'une composition Op d'un élément de a d'arité n et
-- d'un vecteur de n éléments de l'opérade libre.
data FreeOperad a where
Eps :: FreeOperad a
Op :: Graduation a (Length arites) -> GradVect arites (FreeOperad a) -> FreeOperad a
Ce type peut être gradué comme suit.
Code Pseudo-Haskell. 48: Graduation de l’opérade libre
-- module Algebra.Structures.Operad
-- L'opérade libre sur a
est un type gradué .
instance Graded a => Graded (FreeOperad a) where
-- Valeurs du type gradué :
data Graduation (FreeOperad a) n where
-- GradEps, d'arité 1
GradEps ::Graduation (FreeOperad a) Nat_1
-- GradOp, composition d'un élément de a d'arité n
-- et d'un vecteur de n éléments gradués de l'opérade libre;
-- la graduation est alors la somme de celles des éléments
-- du vecteur
GradOp ::
Graduation a (Length as)
-> GradVect as (FreeOperad a)
-> Graduation (FreeOperad a) (SumNat as)
-- Fonctions de conversion
fromGrad GradEps
= Eps
fromGrad (GradOp a as) = Op a as
toGrad Eps
= GradEps
toGrad (Op a as) =
GradOp a as
Montrons alors que l’opérade libre est une opérade. Pour cela, déﬁnissons la fonction de composition.
NB : Cette fonction utilise la méthode type-dépendante carve (voir Remarque 23) et la fonction
mapVect (voir Remarque 20).
Code Pseudo-Haskell. 49: L’opérade libre est une opérade
-- module Algebra.Structures.Operad
-- Composition d'un élément de l'opérade libre
-- d'arité n et d'un vecteur de n éléments gradués
-- pour produire un élément de l'opérade libre
-- ayant pour arité la somme de celles des éléments
-- du vecteur
compo
:: Graded a
5. Comme tous les modules développés pour ce document, la documentation est accessible via la commande stack
haddock -open.

110
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
=> Graduation (FreeOperad a) (Length ns)
-> GradVect ns (FreeOperad a)
-> Graduation (FreeOperad a) (SumNat ns)
compo GradEps (GradVCons f GradVNil) = f
compo (GradOp f fs) gs =
GradOp f
$ mapVect (\(GradCouple b ps) -> compo b ps)
$ carve fs gs
-- L'opérade libre est une opérade, c'est-à-dire un monoïde
-- objet de la catégorie des types gradués.
instance Graded a =>
MonoidObject (FreeOperad a) GradedMorph TensorProd where
mu
= GradedMorph $ \(GradTensor f xs) -> compo f xs
eta = GradedMorph $ \GradUn -> GradEps
Au même titre que le foncteur List est une monade de la catégorie des types, on peut montrer que
le constructeur d’opérade libre est une monade de la catégorie des types gradués.
Code Pseudo-Haskell. 50: Opérade libre et monade
-- module Algebra.Structures.Operad
-- L'opérade libre est un endofoncteur de la catégorie des types gradués.
instance FunctorGen FreeOperad GradedMorph GradedMorph where
fmap g@(GradedMorph f) = GradedMorph $ \case
GradEps
-> GradEps
(GradOp x xs) -> GradOp (f x) $ mapVect (applyMorph $ fmap g) xs
-- Le foncteur opérade libre est une monade de
-- la catégorie des types gradués.
instance MonadGen FreeOperad GradedMorph where
return = GradedMorph runId . unit
join
= GradedMorph $ \case
GradEps
-> GradEps
GradOp x xs -> operadComposition x $ mapVect (applyMorph join) xs
Au même titre qu’il existe une adjonction entre les foncteurs List et Identité dans la catégorie des
types et celle des monoïdes, on peut déﬁnir une adjonction entre l’opérade libre et le foncteur Identité
dans la catégorie des types gradués et celle des opérades.
Code Pseudo-Haskell. 51: Adjonction opérade libre et identité
-- module Category.OfGraded.CategoryOfGraded
-- Le constructeur Identité est un foncteur de la catégorie des Opérades
-- vers celle des types gradués
instance FunctorGen Identity (MonoidObjectMorph GradedMorph TensorProd) GradedMorph where
fmap (MonoidObjectMorph (GradedMorph f)) =
GradedMorph $ \(GradId x) -> GradId $ f x
-- module Algebra.Structures.Operad
-- Le constructeur d'opérade libre est un foncteur de la catégorie des
-- types gradués vers celle des opérades
instance FunctorGen FreeOperad GradedMorph (MonoidObjectMorph GradedMorph TensorProd) where
fmap = MonoidObjectMorph . fmap
-- Adjonction opérade libre / identité
instance AdjunctionGen FreeOperad Identity
GradedMorph (MonoidObjectMorph GradedMorph TensorProd) where
-- Unité de l'adjonction, envoyant un élément a d'arité n

6.3. Retour aux opérades
111
-- sur la composition de a avec un vecteur de longueur n
-- contenant n fois la valeur GradEps
unit = GradedMorph $ \a ->
GradId $ GradOp a $ replicateGrad (graduation' a) GradEps
-- Co-unité de l'adjonction, envoyant un élément de l'opérade
-- libre construite sur une opérade a vers a
counit = MonoidObjectMorph $ GradedMorph aux'
where
aux'
:: (Operad a, Graded a)
=> Graduation (FreeOperad (Identity a)) n
-> Graduation a n
aux' GradEps = applyMorph eta GradUn
aux' (GradOp (GradId a) as) =
applyMorph mu $ GradTensor a $ mapVect aux' as
Cette déﬁnition monadique permet de promouvoir automatiquement toute fonction graduée entre
un type gradué et une opérade en morphisme d’opérade.
Code Pseudo-Haskell. 52: Promotion de morphisme
-- module Category.OfGraded.CategoryOfGraded
-- Promotion fonction graduée vers morphisme d'opérade
promoteToOperadMorphism
:: (Operad b, Graded b, Graded a)
=> (Graduation a n -> Graduation b n)
-> OperadMorphism (FreeOperad a) b
promoteToOperadMorphism f = promote $ GradedMorph $ GradId . f
-- Promotion d'une fonction graduée entre un type gradué et
-- une opérade en fonction graduée.
promoteFunToOperad
:: (Operad o, Graded o, Graded a)
=> (Graduation a n -> Graduation o n)
-> Graduation (FreeOperad a) m
-> Graduation o m
promoteFunToOperad f =
applyMorph $ runMonoidObjectMorph $ promoteToOperadMorphism f
Comme indiqué dans le début de la section, nous utiliserons les opérades pour représenter les arbres,
entrées des automates d’arbres. Mais les arbres et les opérades peuvent également être utilisés pour
modéliser des expressions comme éléments d’arité nulle, telles que les expressions Booléennes, for-
mées par des opérateurs de négation, conjonction et disjonction, ainsi que des variables et des Boo-
léens.
Code Pseudo-Haskell. 53: Expressions Booléennes
-- module Algebra.Structures.BoolExpr
-- Définition du type des symboles pouvant apparaître dans
-- une expression Booléenne.
data Op a = BoolOp Bool | NotOp | AndOp | OrOp | VarOp a
-- Définition de la graduation des symboles et fonctions
-- de conversion
instance Graded (Op a) where
data Graduation (Op a) n where
Var ::a -> Graduation (Op a) Nat_0
Bool ::Bool -> Graduation (Op a) Nat_0
Not ::Graduation (Op a) Nat_1
And ::Graduation (Op a) Nat_2
Or ::Graduation (Op a) Nat_2
fromGrad (Var
v) = VarOp v
fromGrad (Bool b) = BoolOp b

112
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
fromGrad Not
= NotOp
fromGrad And
= AndOp
fromGrad Or
= OrOp
toGrad (VarOp
b) = Var b
toGrad (BoolOp b) = Bool b
toGrad NotOp
= Not
toGrad AndOp
= And
toGrad OrOp
= Or
-- Une expression booléenne est un élément de l'opérade libre
-- construite depuis les symboles et d'arité 0.
data BoolExpr a =
BoolExpr {runBoolExpr :: Graduation (FreeOperad (Op a)) Nat_0}
-- Si f est une fonction graduée envoyant les symboles gradués
-- sur des fonctions n-aires sur un type b, alors il est possible
-- d'envoyer une expression Booléenne (élément d'arité 0 de l'opérade
-- libre) sur un élément de b (élément d'arité 0 de l'opérade
-- des fonctions).
-- NB: Graduation (MultiFun b b) n est le type des fonctions
-- n-aires sur b implanté dans le module
-- Algebra.Functions.GradedFunctions
promoteOpFunToBoolExpr
:: (Graduation (Op a) n -> Graduation (MultiFun b b) n)
-> BoolExpr a
-> b
promoteOpFunToBoolExpr f = runGradFun . promoteFunToOperad f . runBoolExpr
-- Conversion d'un élément d'arité 0 de l'opérade libre sur
-- le type Op appliqué aux Booléens
-- en un Booléen, par utilisation de la fonction promoteOpFunToBoolExpr :
-- il suffit d'associer à chaque opérateur une fonction booléenne;
-- le calcul est ensuite une conséquence de la composition de
-- l'opérade des fonctions Booléennes n-aires.
-- NB: Graduation (MultiFun Bool Bool) n est le type des fonctions
-- Booléennes n-aires.
instance Castable (Graduation (FreeOperad (Op Bool)) Nat_0) Bool where
cast = runGradFun . promoteFunToOperad evalOpToBoolFun
where
evalOpToBoolFun
:: Graduation (Op Bool) n -> Graduation (MultiFun Bool Bool) n
evalOpToBoolFun (Var
b) = GradFun b
evalOpToBoolFun (Bool b) = GradFun b
evalOpToBoolFun Not
= GradFun not
evalOpToBoolFun And
= GradFun (&&)
evalOpToBoolFun Or
= GradFun (||)
castInv = freeOpReturn . Bool
-- Extension au type BoolExpr
instance Castable (BoolExpr Bool) Bool where
cast
= cast . runBoolExpr
castInv = BoolExpr . castInv
Dans le module Algebra.Structures.BoolExpr, on pourra retrouver les déﬁnitions des types de
classes montrant que le constructeur BoolExpr est un endofoncteur, et même une monade de la
catégorie des types. Cela implique donc que ce type déﬁnit une catégorie de Kleisli, mais aussi
un automate de Kleisli qui lui est associé; dans ce cas, on obtient les automates alternants, dont
les conﬁgurations sont des expressions Booléennes d’états. On retrouve alors les algorithmes clas-
siques (conversion en automate non-déterministe en utilisant des formes clausales (voir le module
Algebra.Structures.FND),conversion en automate déterministe) dont la proximité syntaxique (voire
l’identité) est à remarquer (voir Code 24).
Code Pseudo-Haskell. 54: Automates alternants
-- module Automata.KleisliAutomata
type AFA symbol state
= Automaton (KleisliCat BoolExpr (->)) () symbol state Bool

6.3. Retour aux opérades
113
-- Conversion d'un AFA en un DFA complet
afaToDfaComp :: AFA symbol state -> DFAComp symbol (BoolExpr state)
afaToDfaComp = removeIdDFA . castFinality . applyFunctor
-- Conversion d'un AFA en un NFA.
afaToNfa :: AFA symbol state -> NFA symbol (ClauseC state)
afaToNfa =
convertFinalityWith (Kleisli $ \x -> castInv (cast x :: Bool))
. applyFunctor
Pour faciliter l’écriture des expressions booléennes, les fonctions suivantes sont déﬁnies dans le mo-
dule Algebra.Structures.BoolExpr :
— packVar : promotion d’une variable en expression Booléenne atomique;
— packBool : promotion d’un Booléen en expression Booléenne atomique;
— (<~>) : négation d’une expression booléenne;
— (<&&>) : conjonction de deux expressions booléennes;
— (<||>) : disjonction de deux expressions booléennes.
L’exemple du Pseudo-Code 55 montre comment implanter l’automate alternant de la Figure 6.1 re-
connaissant l’ensemble des mots contenant toutes les lettres d’un alphabet donné ({A, B, C, D, E});
cet exemple est exécutable via la commande stack ghci src/HDRExample/AFA.hs.
A
B
C
D
E
0
∧
A
B, C, D, E
B
A, C, D, E
C
A, B, D, E
D
A, B, C, E
E
A, B, C, D
A, B, C, D, E
FIGURE 6.1 – Un automate alternant reconnaissant les mots contenant tous les sym-
boles de {A, B, C, D, E}.
Code Pseudo-Haskell. 55: Automates alternants
{-# LANGUAGE DeriveGeneric #-}
module HDRExample.AFA where
import
Algebra.Structures.BoolExpr
import
Algebra.Structures.FND
import
Automata.Automaton
( recognizes )
import
Automata.AutomatonTransition
import
Automata.KleisliAutomata
import
Data.Hashable
import
Data.List
import
Data.Maybe
import
GHC.Generics
( Generic )
-- Description de l'alphabet via un type énuméré
data Symbol = A | B | C | D | E
deriving (Bounded, Enum, Show, Eq, Generic)
instance Hashable Symbol
-- Synonyme de type pour les états de l'automate

114
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
type State = Maybe Symbol
-- AFA reconnaissant les mots qui contiennent tous les
-- symboles de l'alphabet:
-- * les symboles sont de type Symbol
-- * chaque état est soit un symbole, soit un état ajouté (Nothing)
a :: AFA Symbol State
a = packKleisli initial delta final
where
-- la combinaison initiale est la conjonction des états
-- associés aux symboles
initial = foldr1 (<&&>) $ fmap (packVar . Just) [A ..]
-- Les chemins "reconnus" depuis chaque état associé à un symbole "X"
-- sont les mots contenant au moins une occurrence de "X";
-- une fois ce symbole lu, l'état associé à "X" est envoyé sur
-- l'état Nothing
delta x (Just y) | x == y
= packVar Nothing
| otherwise = packVar $ Just y
delta _ Nothing = packVar Nothing
-- le seul état final est l'état Nothing
final = isNothing
-- Transformation de l'AFA a en un NFA, dont les états sont les clauses
-- conjonctives issues des configurations possibles de l'automate a.
-- Cet automate est un NFA minimal (voir la Remarque suivante)
b :: NFA Symbol (ClauseC State)
b = afaToNfa a
-- Affichage des nombres d'états et de transitions des automates a et b,
-- et de résultats de tests d'appartenance pour des mots construits
-- depuis l'alphabet fixé.
testAFA :: IO ()
testAFA = do
-- affichage des nombres d'états et de transitions de a
putStrLn $ "États de a : " ++ show (length $ accessibleStates a)
putStrLn $ "\nTransitions de a : " ++ show (length $ getTransitions a)
-- affichage des nombres d'états et de transitions de b
putStrLn $ "\nÉtats de b : " ++ show (length $ accessibleStates b)
putStrLn $ "\nTransitions de b : " ++ show (length $ getTransitions b)
-- permuts est la liste des mots où chaque symbole apparait
-- une et une seule fois
let permuts = permutations [A ..]
-- teste si tous les mots de permuts sont reconnus
-- (doit afficher True deux fois)
print $ all (recognizes a) permuts
print $ all (recognizes b) permuts
-- permuts' est la liste des mots de longueur au plus (n - 1)
-- où chaque symbole apparait au plus une fois,
-- avec n est le nombre de symboles
let permuts' = subsequences [A ..] \\ permuts
-- teste si un mot de permuts' est reconnu
-- (doit afficher False deux fois)
print $ any (recognizes a) permuts'
print $ any (recognizes b) permuts'
Remarque 24: Automates minimaux
Le problème du calcul d’un automate non-déterministe minimal est un problème difﬁcile. Ce-
pendant, des méthodes existent pour déﬁnir une borne minimale du nombre d’états que tout
automate non-déterministe reconnaissant un langage donné doit vériﬁer. Par exemple [11,
42], il peut être montré que pour tout langage rationnel L tel qu’il existe un ensemble de n
couples de mots {(xi, yi) | 1 ≤i ≤n} satisfaisant :
— xiwi ∈L pour 1 ≤i ≤n,
— xiwj /∈L ou xjwi /∈L pour 1 ≤i, j ≤n,
tout automate non-déterministe reconnaissant L a au moins n états. Le langage reconnu par

6.3. Retour aux opérades
115
l’automate alternant de l’exemple précédent (voir Pseudo-Code 55), sur un alphabet que nous
noterons Σ, est un bon support pour cette propriété. Ainsi, à chaque sous-ensemble P de l’al-
phabet Σ on peut associer le couple (xP, wP) où x est le plus petit mot (au sens lexicogra-
phique) constitué des lettres de Σ \ P et où w est le plus petit mot constitué des lettres de P.
Par déﬁnition, xPwP est dans L. Pour deux sous-ensembles distincts P et P′ de Σ, notons (sans
perte de généralités) un élément a de P \ P′. Le symbole a n’apparaît ni dans xP ni dans wP′.
Ainsi, xPwP′ n’est pas dans L. Tout automate non-déterministe reconnaissant le langage L a
par conséquent au moins 2n états, où n est la taille de l’alphabet. L’automate alternant déﬁni
dans ce même exemple a, quant à lui, n + 1 états.
Telles que déﬁnies dans le Pseudo-Code 53, les expressions booléennes sont généralisables. Au lieu
d’utiliser des opérateurs Booléens (c’est-à-dire des opérateurs associés à des fonctions Booléennes),
rien ne nous empêche d’utiliser des opérateurs associés à des fonctions sur d’autres types. Ces ex-
pressions généralisées sont implantées dans le module Algebra.Structures.GenExpr, permettant
de construire, similairement aux expressions booléennes, des expressions en tant qu’opérade libre
dont les symboles sont soit des variables (via un constructeur packVar), soit des opérateurs représen-
tant des fonctions sur un type ﬁxé (via un constructeur packFunction). Par exemple, en considérant
un type de symboles State et des termes p, q, r, s de type State, on peut déﬁnir l’expression
q
p2+q2+r2+s2
4
, qui une fois évaluée par une fonction d’interprétation associant aux termes p, q, r,
s des nombres, calcule la moyenne quadratique de ces valeurs. Pour les mêmes raisons que celles
énoncées précédemment pour les expressions booléennes, les expressions généralisées, une fois le
type des valeurs ﬁxées, forment une monade.
L’exemple suivant (Pseudo-Code 56) montre l’utilisation des automates de Kleisli leur étant associés,
à savoir des automates alternants généralisés, où les conﬁgurations d’états sont des expressions gé-
néralisées sur un type t, et où le poids d’un mot est un élément de type t; plus particulièrement dans
l’exemple, on associe à un mot la moyenne quadratique du nombre d’occurrences de ses voyelles.
Pour cela, il sufﬁt de construire un automate alternant avec :
— pour états les voyelles minuscules a, e, i, o, u, y;
— des transitions envoyant un état x par une lettre y sur l’expression généralisée 1 + x si x = y,
x sinon;
— comme poids ﬁnal 0 pour tout état;
— comme conﬁguration initiale l’expression
s
a2 + e2 + i2 + o2 + u2 + y2
Ind(a) + · · · + Ind(y)
où Ind(n) renvoie 0 si n = 0, 1 sinon.
Code Pseudo-Haskell. 56: Automates alternants généralisés
module HDRExample.GenAFA where
import
Algebra.Structures.GenExpr
import
Automata.Automaton
import
Automata.KleisliAutomata
import
Data.Text.ICU.Char
import qualified Data.Text
as T
import
Data.Text.ICU.Char
import
Data.Text.ICU.Normalize
import
Tools.Vector
import
Type.Natural
type Symbol = Char
type State = Char
-- fonction auxiliaire de composition d'une fonction
-- unaire avec une fonction binaire
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.:) = (.) . (.)

116
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
-- automate calculant la moyenne quadratique des occurrences
-- de caractères donnés dans une liste d'un mot
-- en ne tenant compte que de ceux présents
auto :: String -> GenAFA Double Symbol State
auto symbols = packKleisli (initial_a symbols) delta_a final_a
where
-- si symbols' = [x1, ..., xn], alors
-- initial_a symbols' = ((x1^2+...+xn^2)/(Ind(x1)+...+ Ind(xn))))^(1/2)
-- où Ind(y1) vaut 0 si y vaut 0, 1 sinon.
initial_a symbols' =
packFunction one "^(1/2)" sqrt $ mkSingle $
packFunction two "/" (/) $ mkTwo
(foldr1 (packFunction two "+" (+) .: mkTwo) $
fmap (packFunction one "^2" (** 2) . mkSingle . packVar) symbols'
)
(foldr1 (packFunction two "+" (+) .: mkTwo) $ fmap
( packFunction one "Ind" (\x -> if x == 0 then 0 else 1)
. mkSingle
. packVar
)
symbols'
)
-- chaque état agit comme un compteur pour chaque lettre
-- s'incrémentant de 1 lors de la lecture de la "bonne" lettre
delta_a c p | c == p
= packFunction one "1+" (1 +) $ mkSingle $ packVar c
| otherwise = packVar p
-- la valeur "initiale" du compteur est 0
final_a _ = 0 :: Double
-- fonction utilitaire effaçant les accents des caractères
removeAccents :: String -> String
removeAccents =
T.unpack . T.filter (not . property Diacritic) . normalize NFD . T.pack
-- fonction associant à une chaine de caractères la moyenne quadratique
-- de ses voyelles, où une voyelle est une lettre égale à un caractère
-- de la chaine "aeiouy" après retrait d'un éventuel accent et unification
-- de casse, en utilisant l'automate auto
quadraticMeanOfVowels :: String -> Double
quadraticMeanOfVowels =
weightValue (auto "aeiouy") . fmap toLower . removeAccents
Remarque 25: Le type Vector
Le type Vector n a, où n est un Natural (Pseudo-Code 18) et a un type, représente les
vecteurs de longueur n d’éléments de a. Contrairement au type GradVect ms a du Pseudo-
Code 37, les éléments contenus ne sont pas gradués. Le type Vector est implanté dans le
module Tools.Vector.
Les opérades permettent donc de générer très facilement des types d’arbres par l’utilisation par
exemple, des opérades libres et des adjonctions associées. Mais en tant que monoïdes objets, les opé-
rades permettent également de combiner des morphismes (tels que des fonctions graduées) d’une
autre façon que les compositions usuelles des catégories.
L’introduction de ces compositions, permettant de combiner autre chose que des morphismes conte-
nus dans un ensemble, est à la base d’une généralisation de la structure de catégories : les catégories
enrichies.
6.4
Catégories enrichies
Une catégorie est déﬁnie, en partie, par sa composition, qui est une fonction permettant de combiner
deux morphismes. Cette opération est par essence une opération binaire, c’est-à-dire une opération
déﬁnissable à partir du produit cartésien de deux ensembles; en effet, pour rappel, la composition ◦
d’une catégorie C est une opération de signature HomC(B, C) × HomC(A, B) →HomC(A, C).

6.4. Catégories enrichies
117
De plus, le produit cartésien est une instance de produit tensoriel (voir Pseudo-Code 40). Une géné-
ralisation possible de la notion de catégorie peut alors être déﬁnie en considérant non plus le produit
cartésien comme support de la composition, mais n’importe quel produit tensoriel d’une catégorie
monoïdale. Ainsi, les objets à combiner ne sont plus des ensembles (structure algébrique des mor-
phismes), mais des objets d’une catégorie monoïdale. De plus, le morphisme identité associé à un
objet ne peut plus être un élément d’un ensemble de morphismes; cependant, comme un élément
d’un ensemble X peut être vu comme un morphisme de l’ensemble à un élément (élément neutre
du produit cartésien) vers X, cette notion peut elle aussi être étendue. C’est ainsi qu’est déﬁnie une
catégorie enrichie.
Une catégorie enrichie C sur une catégorie monoïdale M = (M, ⊗, I, α, λ, ρ) est déﬁnie par :
— une classe ObjC, les objets de C,
— pour tous deux objets A et B de C, un objet HomC(A, B) de M, le morphisme-objet entre A et B,
— pour tout objet A de C, un morphisme idA de HomM(I, HomC(A, A)), le morphisme identité
de A,
— pour tous trois objets A, B et C de C, un morphisme de composition ◦A,B,C déﬁni comme un
morphisme de HomM(HomC(B, C) ⊗HomC(A, B), HomC(A, C))
faisant commuter les diagrammes suivants, étendant respectivement l’associativité et l’unitarité de
la composition :
HomC(C, D) ⊗HomC(B,C) ⊗HomC(A, B)
HomC(B, D) ⊗HomC(A, B)
HomC(A, D)
HomC(C, D) ⊗(HomC(B,C) ⊗HomC(A, B))
HomC(C,D) ⊗HomC(A,C),
◦B,C,D ⊗idHomC (A,B)
αHomC (C,D),HomC (B,C),HomC (A,B)
◦A,B,D
idHomC (C,D) ⊗◦A,B,C
◦A,C,D
I ⊗HomC(A, B)
HomC(B, B) ⊗HomC(A, B)
HomC(A, B),
λHomC (A,B)
idB ⊗idHomC (A,B)
◦A,B,B
HomC(A, B) ⊗I
HomC(A, B) ⊗HomC(A, A)
HomC(A, B).
ρHomC (A,B)
idHomC (A,B) ⊗idA
◦A,A,B
Code Pseudo-Haskell. 57: Catégories enrichies
-- Enriched.Category.EnrichedCategory
-- classe de type des catégories enrichies sur
-- une catégorie monoïdale catMon
class Monoidal catMon tensor
=> EnrichedCategory enrichedCat catMon tensor where
-- l'identité pour un objet a est un morphisme de catMon
-- entre l'unité de la catégorie monoïdale
-- et le morphisme-objet enrichedCat a a
id :: catMon (Unit catMon tensor) (enrichedCat a a)

118
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
-- la composition associée aux objets a, b et c
-- est un morphisme de catMon entre le produit tensoriel des
-- morphismes-objets enrichedCat b c et enrichedCat a b vers
-- le morphisme-objet enrichedCat a c
(.) :: catMon (tensor (enrichedCat b c, enrichedCat a b)) (enrichedCat a c)
Remarquons que toute catégorie est équivalente à une catégorie enrichie sur la catégorie monoïdale
des types.
Code Pseudo-Haskell. 58: Catégories enrichies
-- Category.OfStructures.CategoryOfTypes
-- définition d'un nouveau type de données
-- isomorphe à un type cat a b pour définir la
-- notion de catégorie enrichie sur la catégorie
-- des types (pour éviter une ambiguïté du
-- moteur d'inférence)
data EnrichedTypeCat cat a b = EnrichedTypeCat (cat a b)
-- Fonction de projection pour récupérer le morphisme
-- sous-jacent
runEnrichedCat :: EnrichedTypeCat cat a b
-> cat a b
runEnrichedCat (EnrichedTypeCat f) = f
-- si cat a b est convertible en c (et inversement),
-- c'est aussi le cas pour EnrichedTypeCat (cat a b)
instance Castable (cat a b) c =>
Castable (EnrichedTypeCat cat a b) c where
cast (EnrichedTypeCat f) = cast f
castInv x = EnrichedTypeCat $ castInv x
-- si cat est une catégorie, c'est aussi
-- le cas pour EnrichedTypeCat cat
instance CategoryGen cat => CategoryGen (EnrichedTypeCat cat) where
id = EnrichedTypeCat id
EnrichedTypeCat f . EnrichedTypeCat g = EnrichedTypeCat $ f . g
-- si cat est une catégorie, elle est équivalente à la
-- catégorie enrichie sur la catégorie des types
-- définie comme suit
instance CategoryGen cat
=> EnrichedCategory (EnrichedTypeCat cat) (->) Prod where
-- l'identité pour un objet a est la fonction
-- envoyant () sur l'identité (de cat) sur a
id () = id
-- la composition associée à trois objets a, b et c
-- est une fonction envoyant un produit de morphismes
-- sur leur composition
(.) (Product (EnrichedTypeCat f, EnrichedTypeCat g)) =
EnrichedTypeCat $ f . g
On peut également s’intéresser à la déﬁnition d’une catégorie enrichie sur la catégorie monoïdale
des types gradués (déﬁnie dans le Pseudo-Code 44). Une telle structure est ainsi déﬁnie, selon la
déﬁnition classique de catégorie enrichie, par :
— une classe d’objets;
— pour deux objets A et B, d’un type gradué paramétré par A et B;
— pour tout objet A, une fonction graduée (c’est-à-dire un morphisme de la catégorie des types
graduées) de l’ensemble à 1 élément vers le type gradué associé à A et A, qui équivaut à un
choix d’un élément unaire du type gradué associé à A et A;
— pour tous trois objets A, B et C, une composition envoyant le produit tensoriel du type gradué
associé à B et C par celui associé à A et B sur le type gradué associé à A et C, c’est-à-dire une
fonction graduée envoyant un élément d’arité n du type gradué associé à B et C et n éléments
d’arité k1, . . . , kn du type gradué associé à A et B sur un élément d’arité k1 + · · · + kn du type
gradué associé à A et C

6.4. Catégories enrichies
119
et respectant les diagrammes de cohérence des catégories enrichies, à savoir l’associativité et l’unita-
rité de la composition déﬁnies page 117. Par exemple, en considérant
— pour objets les types,
— pour morphismes-objets les types de fonctions (non nécessairement unaires) entre deux types
A et B, à savoir les fonctions de S
n An →B,
— pour identité la fonction identité (d’arité 1) (ou d’une façon équivalente la fonction graduée
envoyant l’unique élément d’arité 1 de 1 vers la fonction identité),
— pour composition la composition de fonctions n-aires, composant une fonction d’arité n avec
n fonctions (vue comme une fonction depuis le produit tensoriel des types gradués),
on obtient une catégorie enrichie sur la catégorie des types gradués. Notons qu’il est possible de
déﬁnir une catégorie duale sur les fonctions de B →An ; cette dualité sera utilisée pour distinguer
les automates Bottom-Up des Top-Down.
NB : Le Pseudo-Code suivant présente très partiellement l’implantation des fonctions n-aires réalisée
en Haskell pour ce document. Notamment, il occulte la déﬁnition de la fonction compo de signature
Graduation (MultiFun b c) (Length arites) -> GradVect arites (MultiFun a b)
-> Graduation (MultiFun a c) (SumNat arites), permettant de composer des fonctions n-aires,
dont la technicité (fonction type-dépendante implantée par classe de types) n’a pas d’intérêt ici.
Code Pseudo-Haskell. 59: Catégorie enrichie des fonctions graduées
-- Algebra.Functions.GradedFunctions
-- Familles de types (c'est-à-dire ensemble de types ici
-- inductivement défini) représentant les fonctions
-- graduées curryfiées de a^n vers b
type family NFun n a b where
-- le type des fonctions de a^0 vers b
-- est b (case de base)
NFun 'Z _ b = b
-- étape d'induction
NFun ('S n) a b = a -> NFun n a b
-- Type de données des fonctions n-aires de a^n vers b
data MultiFun (a :: Type) (b :: Type) where
MultiFun :: NFun arite a b -> MultiFun a b
-- Les fonctions n-aires sont graduées par leur arité
instance Graded (MultiFun a b) where
-- définition du type gradué, et de la fonction
-- de projection runGradFun
data Graduation (MultiFun a b) n where
GradFun ::{runGradFun :: NFun n a b} -> Graduation (MultiFun a b) n
-- Fonctions de conversion
toGrad (MultiFun f) = GradFun f
fromGrad (GradFun f) = MultiFun f
-- Les fonctions graduées forment une catégorie enrichie
-- sur les types gradués
instance EnrichedCategory MultiFun GradedMorph TensorProd where
-- l'identité est le morphisme envoyant GradUn,
-- seul élément (d'arité 1) du type gradué associé
-- à (), sur la fonction identité
id
= GradedMorph $ \GradUn -> GradFun id
-- la composition est la composition usuelle de fonction n-aires
(.) = GradedMorph $ \(GradTensor f gs) -> compo f gs
Remarque 26: Curryﬁcation des fonctions n-aires
Aﬁn de simpliﬁer la curryﬁcation des fonctions n-aires, processus type-dépendant par es-
sence, nous utiliserons le type Vector du module Tools.Vector (Remarque 25), représen-
tant des listes dont la longueur est connue. La curryﬁcation et son inverse, la décurryﬁca-
tion, permettant de transformer une fonction n-aire en une fonction unaire sur un vecteur de
longueur n (et inversement), seront utilisées sous le nom de convertToVectMultiFun et de
convertFromVectMultiFun dans la suite de ce document. Ces fonctions sont implantées dans

120
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
le module Algebra.Functions.GradedFunctions.
On peut également s’intéresser à la catégorie des fonctions duales de type B →An.
NB : Aﬁn de conserver le même produit tensoriel et ainsi la même catégorie monoïdale, on encodera
les fonctions entre b et an sous le nom DualFunN a b.
Code Pseudo-Haskell. 60: Catégorie enrichie des fonctions graduées (duales)
-- Algebra.Functions.GradedFunctionsTopDown
-- Type de données des fonctions duales de B -> A^n.
data DualFunN a b where
DualFunN :: (b -> Vector n a) -> DualFunN a b
-- Les fonctions duales sont graduées par la longueur
-- du vecteur de sortie.
instance Graded (DualFunN a b) where
-- Type gradué associé
data Graduation (DualFunN a b) n where
DualGradFun ::(b -> Vector n a) -> Graduation (DualFunN a b) n
-- Fonction de conversion
toGrad (DualFunN f) = DualGradFun f
fromGrad (DualGradFun f) = DualFunN f
-- Les fonctions duales forment une catégorie enrichie
-- sur la catégorie monoïdale des types gradués.
instance EnrichedCategory DualFunN GradedMorph TensorProd where
-- l'identité est la fonction envoyant GradUn (seul élément
-- du type gradué associé à () et d'arité 1) à la fonction
-- envoyant un élément sur le vecteur à un élément le
-- contenant
id
= GradedMorph $ \GradUn -> DualGradFun mkSingle
-- La composition d'une fonction f de a vers b^n
-- et de n fonctions duales de b vers c^{k_i} pour
-- 0 < i < (n + 1) se décompose comme suit:
-- * calcul du vecteur image obtenu par f
-- * application du vecteur de n fonctions de type
--
b -> c^{k_i}sur ce vecteur image
-- * concaténation des vecteurs résultats
--
-- Ces deux dernières étapes sont réalisées dans la fonction
-- applique définie ci-dessous.
(.) = GradedMorph $ \(GradTensor f gs) -> compo f gs
where
compo (DualGradFun f) gs = DualGradFun $ applique gs . f
applique
:: GradVect ms (DualFunN b c)
-> Vector (Length ms) c
-> Vector (SumNat ms) b
applique GradVNil VNil = VNil
applique (GradVCons (DualGradFun g) gs) (VCons x xs) =
vConcat (g x) $ applique gs xs
6.5
Automates généralisés
La notion d’automate peut alors être généralisée en celle d’automate généralisé, c’est-à-dire un auto-
mate sur une catégorie enrichie par une catégorie monoïdale. D’une façon similaire à celle de l’ex-
tension de la notion de morphisme identité dans une catégorie enrichie, les morphismes déﬁnissant
la conﬁguration initiale ou le morphisme vers l’objet ﬁnal ne sont plus des éléments pris dans un en-
semble; ainsi, la même méthode de déﬁnition sera utilisée : nous n’utiliserons plus des morphismes,
mais des morphismes de la catégorie monoïdale depuis l’unité vers un morphisme-objet. De tels mor-
phismes, de l’unité de la catégorie monoïdale vers un objet quelconque, sont appelés classiquement
des éléments généralisés.

6.5. Automates généralisés
121
Déﬁnition 12
Un automate généralisé sur une catégorie C enrichie sur une catégorie monoïdale M = (M, ⊗, I, α, λ, ρ)
est déﬁni par
— un objet alphabet Σ de M;
— par trois objets de C : S l’ objet initial, Q l’objet état et V l’objet ﬁnal;
— un morphisme initial de HomM(I, HomC(S, Q));
— un morphisme de transition δ de HomM(Σ, HomC(Q, Q));
— un morphisme ﬁnal de HomM(I, HomC(Q, V)).
Code Pseudo-Haskell. 61: Automates généralisés
-- AutomataGen.AutomatonGen
-- Type de données des automates généralisés sur une catégorie
-- enrichedCat enrichie sur la catégorie monoïdale catMon:
-- * init l'objet initial
-- * symbols l'objet alphabet
-- * state l'objet état
-- * value l'objet final
data AutomatonGen enrichedCat catMon tensor init symbols state value where
Auto ::EnrichedCategory enrichedCat catMon tensor => {
-- le morphisme initial
initial :: catMon (Unit catMon tensor) (enrichedCat init state),
-- le morphisme de transition
delta
:: catMon symbols (enrichedCat state state),
-- le morphisme final
final
:: catMon (Unit catMon tensor) (enrichedCat state value)
} -> AutomatonGen enrichedCat catMon tensor init symbols state value
On peut alors utiliser les catégories enrichies que nous avons déﬁnies, celles basées sur la catégorie
des types munie du produit cartésien (Pseudo-code 58) et celles basées sur les fonctions graduées
(Pseudo-code 59 et Pseudo-code 60) pour déﬁnir des automates. Tout d’abord, remarquons que les
automates généralisés sur une catégorie enrichie C sur la catégorie monoïdale des types munie du
produit cartésien sont équivalents aux automates sur une catégorie, puisque C est équivalente à une
catégorie (Pseudo-code 58). L’isomorphisme est présenté dans le code suivant.
Code Pseudo-Haskell. 62: Automates sur une catégorie et automates généralisés
-- AutomataGen.WordAutomata.WordAut
-- imports nommés de modules pour aider à la distinction
import
Automata.Automaton
as A
import
AutomataGen.AutomatonGen
as AG
-- Synonyme de type pour les automates généralisés sur une
-- catégorie enrichie sur la catégorie des types munie
-- du produit cartésien
type WordAut enrichedCat init symbols state value
= AutomatonGen enrichedCat (->) Prod init symbols state value
-- Transformation d'un automate sur une catégorie en un automate généralisé
convertFromClassicalAutomaton
:: CategoryGen cat
=> Automaton cat init symbols state value
-> WordAut (EnrichedTypeCat cat) init symbols state value
convertFromClassicalAutomaton (A.Auto i d f) = AG.Auto
(const $ EnrichedTypeCat i)
(EnrichedTypeCat . d)
(const $ EnrichedTypeCat f)
-- Transformation d'un automate généralisé en un automate sur une catégorie
convertToClassicalAutomaton
:: WordAut (EnrichedTypeCat cat) init symbols state value
-> Automaton cat init symbols state value
convertToClassicalAutomaton (AG.Auto i d f) = A.Auto
(runEnrichedCat $ i ())

122
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
(runEnrichedCat . d)
(runEnrichedCat $ f ())
-- Synonyme pour le calcul du poids depuis une liste de symboles (un mot).
-- NB: utilise le constructeur List du module
-- 'Category.OfStructures.CategoryOfTypes' existant pour définir
-- l'adjonction entre les catégories (->) et
-- 'MonoidObjectMorph (->) Prod' (équivalente à la catégorie des monoïdes)
wordWeight
:: (EnrichedCategory enrichedCat (->) Prod, _)
=> WordAut enrichedCat init symbols state value
-> [symbols]
-> enrichedCat init value
wordWeight auto = weight auto . List
Dans le cas d’un automate généralisé sur la catégorie enrichie des fonctions n-aires, la structure d’au-
tomate est déﬁni par :
— un alphabet Σ, qui est un type gradué;
— une fonction graduée initiale de l’ensemble gradué à un élément (d’arité 1) vers les fonctions
n-aires de S (l’objet initial) vers Q (l’objet état) (l’ensemble des fonctions de la forme Sn →Q);
d’une façon équivalente, il s’agit d’une fonction de S vers Q;
— une fonction de transition graduée de Σ vers les fonctions n-aires de Q vers Q (l’ensemble des
fonctions de la forme Qn →Q); plus précisément, la fonction de transition envoie un symbole
n-aire de Σ sur une fonction de Qn →Q;
— une fonction graduée terminale de l’ensemble gradué à un élément (d’arité 1) vers les fonc-
tions n-aires de Q vers V (l’objet ﬁnal) (l’ensemble des fonctions de la forme Qn →V); d’une
façon équivalente, il s’agit d’une fonction de Q vers V.
Il s’agit alors de Root-Weighted Tree Automata (RWTA) séquentiels et complets [71], réalisant des reco-
gnizable step functions [34, 35]. Plus particulièrement, lorsque V est l’ensemble Booléen, il s’agit alors
d’un automate d’arbre (Bottom-Up) déterministe complet, comme déﬁni page 10. La seule différence
est la présence de la fonction initiale; son rôle est d’étendre la capacité de reconnaissance des auto-
mates d’arbres. Au lieu de ne ﬁxer un poids qu’à des automates nullaires, la fonction initiale permet
de considérer un arbre n-aire, de boucher les arbres vides par des occurrences de variables, éléments
d’un ensemble S, et de lui ﬁxer ensuite un poids. On retombe alors sur la déﬁnition initiale en ﬁxant
l’ensemble des variables à l’ensemble vide (Void en Haskell, voir Remarque 42).
Code Pseudo-Haskell. 63: Automates d’arbres Bottom-Up
-- AutomataGen.TreeAutomata.TreeAut
-- Un automate d'arbres (général) est un automate généralisé sur une
-- catégorie enrichie sur la catégorie monoïdale des fonctions graduées
type TreeAut enrichedCat var symbols state value
= AutomatonGen enrichedCat GradedMorph TensorProd var symbols state value
-- AutomataGen.TreeAutomata.BottomUp.BottomUpCompDet
-- Synonyme pour le type des RWTA séquentiels à variable
type SeqRWTAWithVar weight var symbols state
= TreeAut MultiFun var symbols state weight
-- Synonyme pour le type des automates d'arbres Bottom-Up déterministe
-- complet avec variables
type BottomUpCompDFTAWithVar var symbols state
= SeqRWTAWithVar Bool var symbols state
-- Synonyme pour le type des automates d'arbres Bottom-Up déterministe
-- complet sans variables
type BottomUpCompDFTA symbols state = BottomUpCompDFTAWithVar Void symbols state
-- Construit un RWTA séquentiel avec variables
packRWTA
:: (var -> state)
-> GradedMorph symbols (MultiFun state state)
-> (state -> weight)

6.5. Automates généralisés
123
-> SeqRWTAWithVar weight var symbols state
packRWTA i transMorph finalWeights =
Auto (gradedMorphFromFun i) transMorph (gradedMorphFromFun finalWeights)
-- Construit un automate d'arbres avec variables
packVar
:: (var -> state)
-> GradedMorph symbols (MultiFun state state)
-> (state -> Bool)
-> BottomUpCompDFTAWithVar var symbols state
packVar = packRWTA
-- Construit un automate d'arbres sans variable
pack
:: GradedMorph symbols (MultiFun state state)
-> (state -> Bool)
-> BottomUpCompDFTA symbols state
pack = packVar absurd
Remarque 27: Cas des automates d’arbres Top-Down déterministes complets
D’une façon duale, les automates d’arbres Top-Down déterministes complets peuvent
être déﬁnis comme des automates généralisés sur la catégorie enrichie des fonc-
tions entre A et Bn (Pseudo-Code 60). Ces automates sont implantés dans le module
AutomataGen.TreeAutomata.TopDown.TopDownCompDet.
Pour calculer le poids d’un mot ou d’un arbre (ou d’un élément d’une autre structure algébrique), il
faut commencer par étendre le domaine du morphisme de transition. Dans le cas des automates sur
des catégories (non enrichies), la promotion de la fonction δ (Pseudo-Code 12) utilisait l’adjonction
entre les foncteurs Liste (monoïde libre) et Identité (oubli). Ce raisonnement est encore valable ici, en
notant la remarque suivante.
Remarque 28: Catégorie enrichie à un objet et monoïde objet
Au même titre qu’une catégorie à un seul objet est équivalente à un monoïde (Pseudo-Code 4),
une catégorie enrichie avec un seul objet est un monoïde objet.
-- Enriched.Category.EnrichedCategory
instance EnrichedCategory enrichedCat catMon tensor
=> MonoidObject (enrichedCat a a) catMon tensor where
mu
= (.)
eta = id
S’il est possible de transformer fonctoriellement l’objet alphabet Σ en monoïde objet libre Free(Σ),
c’est-à-dire si le constructeur de type Identité est un foncteur de la catégorie des monoïdes objets
(Pseudo-Code 45) de M vers M et que ce foncteur admette un adjoint à gauche Free, il sufﬁt d’utiliser
cette adjonction pour promouvoir δ en morphisme de monoïde objet de Free(Σ), le monoïde objet
libre, vers le monoïde objet déﬁni par HomC(Q, Q). Cela est réalisable en utilisant la même fonction
de promotion, promote, du Pseudo-Code 10.
Code Pseudo-Haskell. 64: Promotion du morphisme de transitions
-- AutomataGen.AutomatonGen
delta'
:: ( AdjunctionGen f Identity catMon (MonoidObjectMorph catMon tensor)
, EnrichedCategory enrichedCat catMon tensor
)
=> AutomatonGen enrichedCat catMon tensor init symbols state value
-> MonoidObjectMorph catMon tensor (f symbols) (enrichedCat state state)
delta' auto = promote $ packId . delta auto

124
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
Ainsi, dans le cas des automates d’arbres, c’est l’adjonction du Pseudo-code 51, entre fonctions gra-
duées et morphismes d’opérades qui sera utilisée, permettant de déterminer l’action d’un arbre de-
puis la combinaison de chacun de ses symboles gradués.
On pourra remarquer que la seule différence avec la promotion de la fonction de transition des
mots du Pseudo-Code 12 est le morphisme packId utile pour effacer la présence du constructeur
Identity : mis à part ce détail technique mineur, les fonctions sont syntaxiquement les mêmes.
Cette proximité syntaxique n’est plus tout à fait la même pour les fonctions getConfig et weight des
Pseudo-Codes 13 et 14, bien que l’idée de base soit la même :
— pour getConfig, il sufﬁt de combiner le morphisme initial de I vers HomC(S, Q) et le mor-
phisme de transition de Σ vers HomC(Q, Q) en un morphisme de Σ vers HomC(S, Q);
— pour weight, il sufﬁt de combiner le morphisme obtenu par getConfig de Σ vers HomC(S, Q)
et le morphisme ﬁnal de I vers HomC(Q, V) en un morphisme de Σ vers HomC(S, V).
Ces combinaisons sont déﬁnissables en toute généralité au niveau des catégories enrichies. Dans le
cas de getConfig, il sufﬁt :
— d’utiliser l’inverse de l’identité droite ρ−1
Σ , morphisme de Σ vers Σ ⊗I ;
— de calculer le produit tensoriel entre le morphisme initial et celui de transition pour former un
morphisme de Σ ⊗I vers HomC(Q, Q) ⊗HomC(S, Q) et de le combiner à l’aide de la composi-
tion de la catégorie, elle-même morphisme de HomC(Q, Q) ⊗HomC(S, Q) vers HomC(S, Q);
— de composer ces deux morphismes par la composition de la catégorie monoïdale.
Cette opération, combinaison d’un élément généralisé et d’un morphisme pour former un nouvel
élément généralisé, est déﬁnie dans le module Enriched.Category.EnrichedCategory sous le nom
de prepend (et append pour son équivalent de combinaison par un élément généralisé à droite). NB :
Pour la distinguer de celle de la catégorie enrichie, la composition de la catégorie monoïdale sera
préﬁxée par Cat. dans le Pseudo-code suivant.
Code Pseudo-Haskell. 65: Combinaisons morphisme / élément généralisé
-- Enriched.Category.EnrichedCategory
-- Combinaison d'un élément généralisé et d'un morphisme
prepend
:: EnrichedCategory enrichedCat catMon tensor
=> catMon (Unit catMon tensor) (enrichedCat x y)
-> catMon t (enrichedCat y z)
-> catMon t (enrichedCat x z)
prepend i_m t_m = ((.) Cat.. fmap (Prod t_m i_m)) Cat.. rhoInv
-- Combinaison d'un morphisme et d'un élément généralisé
append
:: EnrichedCategory enrichedCat catMon tensor
=> catMon t (enrichedCat x y)
-> catMon (Unit catMon tensor) (enrichedCat y z)
-> catMon t (enrichedCat x z)
append t_m i_m = ((.) Cat.. fmap (Prod i_m t_m)) Cat.. lambdaInv
Ces deux opérations permettent alors de calculer le poids comme un morphisme entre l’objet libre
(pouvant contenir les structures à pondérer) et l’objet ﬁnal.
Code Pseudo-Haskell. 66: Combinaisons morphisme / élément généralisé
-- AutomataGen.AutomatonGen
getConfig
:: ( EnrichedCategory enrichedCat catMon tensor
, AdjunctionGen f Identity catMon (MonoidObjectMorph catMon tensor)
, MonoidObject (f symbols) catMon tensor
)
=> AutomatonGen enrichedCat catMon tensor init symbols state value
-> catMon (f symbols) (enrichedCat init state)
getConfig auto = prepend (initial auto) $ runMonoidObjectMorph (delta' auto)
weight

6.5. Automates généralisés
125
:: ( EnrichedCategory enrichedCat catMon tensor
, AdjunctionGen f Identity catMon (MonoidObjectMorph catMon tensor)
, MonoidObject (f symbols) catMon tensor
)
=> AutomatonGen enrichedCat catMon tensor init symbols state value
-> catMon (f symbols) (enrichedCat init value)
weight auto = append (getConfig auto) $ final auto
Aﬁn de faciliter l’utilisation de ces fonctions, on peut les spécialiser (en termes de signature) dans
le cas particulier des arbres, par exemple. NB : Dans le pseudo-code suivant est utilisée la fonction
packCast du module Enriched.Category.EnrichedCategory permettant d’appliquer une conver-
sion de type (classe de types Castable déﬁnie précédemment) au niveau d’une catégorie monoï-
dale, en déﬁnissant un morphisme du type catMon (enrichedCat a b) (enrichedCat a c) depuis
deux types b et c satisfaisant la contrainte Castable b c.
Code Pseudo-Haskell. 67: Calcul particulier du poids dans un RWTA
-- AutomataGen.TreeAutomata.BottomUp.BottomUpCompDet
-- Le poids associé à un arbre n-aire est une fonction
-- n-aire envoyant n variables sur un poids.
weightAsScalarWithVar
:: SeqRWTAWithVar weight var symbols state
-> Graduation (FreeOperad symbols) n
-> NFun n var weight
weightAsScalarWithVar = runGradFun .: weightAsScalarWithVar'
where
weightAsScalarWithVar'
:: SeqRWTAWithVar weight var symbols state
-> Graduation (FreeOperad symbols) n
-> Graduation (MultiFun var weight) n
weightAsScalarWithVar' auto' = applyMorph (packCast Cat.. weight auto')
-- Le poids associé à un arbre nullaire est une fonction
-- 0-aire envoyant 0 variable sur un poids, c'est-à-dire un poids.
weightAsScalar
:: SeqRWTAWithVar weight var symbols state
-> Graduation (FreeOperad symbols) Nat_0
-> weight
weightAsScalar = weightAsScalarWithVar
-- Synonyme pour les automates Booléens.
recognizesWithVar
:: BottomUpCompDFTAWithVar var symbols state
-> Graduation (FreeOperad symbols) n
-> NFun n var Bool
recognizesWithVar = weightAsScalarWithVar
-- Synonyme pour les automates Booléens.
recognizes
:: BottomUpCompDFTAWithVar var symbols state
-> Graduation (FreeOperad symbols) Nat_0
-> Bool
recognizes = weightAsScalar
Une autre utilisation de la fonction append est la modiﬁcation possible des éléments généralisés ini-
tiaux et ﬁnaux. Ainsi, la complémentation d’un automate d’arbres déterministe complet est aussi
simple que dans le cas des automates sur la catégorie des types : il sufﬁt d’inverser le poids de sortie.
Code Pseudo-Haskell. 68: Complémentation d’un automate d’arbre déterministe complet
-- AutomataGen.TreeAutomata.BottomUp.BottomUpCompDet
complement
:: BottomUpCompDFTAWithVar var symbols state
-> BottomUpCompDFTAWithVar var symbols state

126
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
complement auto =
auto { final = append (final auto) (gradedMorphFromFun not) }
Remarque 29: Le type gradué Symbol a
Aﬁn de simpliﬁer la déﬁnition d’exemples, nous utiliserons dans la suite de ce document le
type Symbol a, déﬁni dans le module Tools.GradSymbolet permettant de déﬁnir simplement
des symboles gradués depuis n’importe quel type. Sont également fournis des constructeurs
de symboles et d’arbres, comme illustrés ci-dessous :
-- Tools.GradSymbol
-- Un symbole est déterminé par un Natural (son arité)
-- et par une valeur de type a.
data Symbol a where
Symbol :: Natural n -> a -> Symbol a
-- Le type Symbol a est gradué
instance Graded (Symbol a) where
-- Type support de la graduation
data Graduation (Symbol a) n = GradSymb (Natural n) a
-- Fonctions de conversion
toGrad (Symbol nat a_) = GradSymb n a_
fromGrad (GradSymb n a_) = Symbol n a_
-- Construit un symbole nullaire
zerothSymbol :: a -> Graduation (Symbol a) 'Z
zerothSymbol = GradSymb singleton
-- Construit un symbole unaire
unarySymbol :: a -> Graduation (Symbol a) Nat_1
unarySymbol = GradSymb one
-- Construit un symbole binaire
binarySymbol :: a -> Graduation (Symbol a) Nat_2
binarySymbol = GradSymb two
-- Construit un arbre nullaire
tree0 :: Graduation a Nat_0 -> Graduation (FreeOperad a) 'Z
tree0 s = GradOp s GradVNil
-- Ajoute en racine d'un arbre un élément d'arité 1,
-- préservant l'arité
tree1
:: Graded a
=> Graduation a Nat_1
-> Graduation (FreeOperad a) n
-> Graduation (FreeOperad a) n
tree1 s tree = GradOp s $ mkSingle tree
-- Ajoute une racine d'arité 2 au sommet de deux arbres,
-- sommant les arités
tree2
:: Graded a
=> Graduation a Nat_2
-> Graduation (FreeOperad a) n1
-> Graduation (FreeOperad a) n2
-> Graduation (FreeOperad a) (n1 + n2)
tree2 s tree tree' = GradOp s $ mkTwo tree tree'
Sont également fournies des fonctions utilitaires, comme le prédicat binaire eqSymb permet-
tant de tester si deux symboles sont égaux.
L’exemple suivant (Pseudo-Code 69) 6, s’appuyant sur les notations précédentes, montre comment
déﬁnir le type des arbres dont les nœuds sont des chaînes de caractères, et comment les interpréter
comme arbre syntaxique d’opérations arithmétiques modulaires simples via un automate d’arbres.
6. Code exécutable dans l’interpréteur ghci via la commande stack ghci src/HDRExample/HDRExampleBUCompDet.hs

6.5. Automates généralisés
127
Pour cela, une fois un entier n ﬁxé (pour la congruence modulaire), il sufﬁt de déﬁnir un automate
d’arbres (Bottom-Up) avec
— un état Just k pour chaque entier k entre 0 et n −1 et l’état Nothing;
— une transition nullaire envoyant chaque chaîne numérique représentant un entier m sur Just(m
mod n), et les autres chaînes sur Nothing;
— des transitions pour chaque opération arithmétique choisie, dont les arités correspondent;
— des transitions vers Nothing dans les autres cas;
— comme poids ﬁnal associé à chaque état lui-même si l’on souhaite évaluer l’expression, ou
bien un Booléen dans le choix de la reconnaissance (par exemple, un test de parité);
— un poids initial arbitrairement choisi pour les variables, le cas échéant.
Code Pseudo-Haskell. 69: Calcul particulier du poids dans un RWTA
-- HDRExample.HDRExampleBUCompDet
-- Composition d'une fonction unaire et d'une fonction binaire
(.:) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
(.:) = (.) . (.)
-- Symbole unaire défini par la chaine "-"
minusString :: Graduation (Symbol String) Nat_1
minusString = unarySymbol "-"
sumString, binMinusString, prodString :: Graduation (Symbol String) Nat_2
-- Symbole binaire défini par la chaine "+"
sumString = binarySymbol "+"
-- Symbole binaire défini par la chaine "-"
binMinusString = binarySymbol "-"
-- Symbole binaire défini par la chaine "*"
prodString = binarySymbol "*"
-- Définition des types des états de l'automate.
-- L'état Nothing permet de gérer les erreurs,
-- par exemple les échecs de conversion
-- des chaines en entier.
type State = Maybe Int
-- Fonction de transition de l'automate;
-- la définition principale est celle de la fonction aux'.
-- Interprète des chaines de caractères en fonctions arithmétiques
-- modulaires, où la borne est donnée en paramètre.
delta_ :: Int -> GradedMorph (Symbol String) (MultiFun State State)
delta_ n = GradedMorph aux
where
aux x = aux' (graduation' x) x
-- Fonction associant à des symboles
-- des fonctions n-aires sur les états
aux'
:: Natural n
-> Graduation (Symbol String) n
-> Graduation (MultiFun State State) n
-- Pour un symbole d'arité 0, tentative de conversion
-- de la chaine en entier puis calcul modulaire.
aux' Zero (GradSymb _ s) = GradFun $ (`mod` n) <$> readMaybe s
-- Pour le symbole d'arité 1 minusString, tentative d'inversion du signe
-- de l'état puis calcul modulaire.
aux' (Succ Zero) x
| eqSymb x minusString = GradFun $ fmap ((`mod` n) . negate)
aux' (Succ (Succ Zero)) x
-- Pour le symbole d'arité 2 sumString,
-- tentative de somme des deux états
-- puis calcul modulaire.
| eqSymb x sumString = GradFun $ liftA2 $ (`mod` n) .: (+)
-- Pour le symbole d'arité 2 sumString,
-- tentative de soustraction des deux états
-- puis calcul modulaire.
| eqSymb x binMinusString = GradFun $ liftA2 $ (`mod` n) .: (-)
-- Pour le symbole d'arité 2 prodString,
-- tentative de soustraction des deux états
-- puis calcul modulaire.

128
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
| eqSymb x prodString = GradFun $ liftA2 $ (`mod` n) .: (*)
-- Dans tous les autres cas, quelque soit l'arité,
-- renvoie de Nothing.
aux' m _ = convertFromVectMultiFun m $ const Nothing
-- Définition du type de variables;
-- ici arbitrairement 3 variables.
data Vars = X1 | X2 | X3
-- Fonction d'initialisation des variables
initFun :: Vars -> State
initFun X1 = Just 65
initFun X2 = Just 9
initFun X3 = Nothing
-- Fonction de poids: chaque état a pour
-- poids lui même
finalWeight :: State -> Maybe Int
finalWeight = id
-- Fonction de finalité:
-- un état est final s'il est pair
isFinal :: State -> Bool
isFinal = maybe False even
-- Définition d'un RWTA où le poids est Just p si
-- l'arbre est l'arbre syntaxique d'une expression arithmétique
-- valide, Nothing sinon.
rwta :: Int -> SeqRWTAWithVar (Maybe Int) Vars (Symbol String) State
rwta n = packRWTA initFun (delta_ n) finalWeight
-- Définition d'un automate (sans variable) reconnaissant un arbre s'il
-- est l'arbre syntaxique d'une expression arithmétique
-- valide dont le résultat est pair.
auto :: Int -> BottomUpCompDFTA (Symbol String) State
auto n = pack (delta_ n) isFinal
-- Définition d'un automate reconnaissant un arbre s'il
-- est l'arbre syntaxique d'une expression arithmétique
-- valide dont le résultat est pair.
autoVar :: Int -> BottomUpCompDFTAWithVar Vars (Symbol String) State
autoVar n = packVar initFun (delta_ n) isFinal
-- Arbre syntaxique nullaire de l'expression valide -(513 + 838) * 37
t :: Graduation (FreeOperad (Symbol String)) Nat_0
t =
tree2
prodString
( tree1 minusString
$ tree2 sumString (tree0 $ zerothSymbol "513")
$ tree0
$ zerothSymbol "838"
)
$ tree0
$ zerothSymbol "37"
-- Arbre syntaxique nullaire de l'expression invalide -(KO + 838) * 37
t_KO :: Graduation (FreeOperad (Symbol String)) 'Z
t_KO =
tree2
prodString
( tree1 minusString
$ tree2 sumString (tree0 $ zerothSymbol "KO")
$ tree0
$ zerothSymbol "838"
)
$ tree0
$ zerothSymbol "37"
-- Arbre syntaxique binaire de l'expression -(Eps + Eps) * 37
t' :: Graduation (FreeOperad (Symbol String)) Nat_2

6.5. Automates généralisés
129
t' =
tree2 prodString (tree1 minusString $ tree2 sumString GradEps GradEps)
$ tree0
$ zerothSymbol "37"
-- Affichage du résultat du calcul des poids
testDFTA :: IO ()
testDFTA = do
putStrLn $ mconcat ["t_KO = ", show t_KO]
putStrLn $ mconcat ["t
= ", show t]
putStrLn $ mconcat ["t'
= ", show t']
putStrLn $ mconcat ["X1 -> ", show (initFun X1)]
putStrLn $ mconcat ["X2 -> ", show (initFun X2)]
putStrLn $ mconcat ["X3 -> ", show (initFun X3)]
let n = 19
putStrLn "\nPonderations of t_KO"
print $ auto n `recognizes` t_KO
print $ autoVar n `recognizes` t_KO
print $ rwta n `weightAsScalar` t_KO
print $ complement (auto n) `recognizes` t_KO
putStrLn "\nPonderations of t"
print $ auto n `recognizes` t
print $ autoVar n `recognizes` t
print $ rwta n `weightAsScalar` t
print $ complement (auto n) `recognizes` t
putStrLn "\nPonderations of t'(X1, X2)"
print $ recognizesWithVar (autoVar n) t' X1 X2
print $ weightAsScalarWithVar (rwta n) t' X1 X2
print $ recognizesWithVar (complement $ autoVar n) t' X1 X2
putStrLn "\nPonderations of t'(X2, X2)"
print $ recognizesWithVar (autoVar n) t' X2 X2
print $ weightAsScalarWithVar (rwta n) t' X2 X2
print $ recognizesWithVar (complement $ autoVar n) t' X2 X2
putStrLn "\nPonderations of t'(X1, X3)"
print $ recognizesWithVar (autoVar n) t' X1 X3
print $ weightAsScalarWithVar (rwta n) t' X1 X3
print $ recognizesWithVar (complement $ autoVar n) t' X1 X3
L’exemple précédent présente une méthode d’analyse d’arbre où les étapes intermédiaires sont re-
présentés pas les états de l’automate. Ainsi, si le calcul ne s’effectue plus d’une façon modulaire, le
nombre d’états nécessaire est arbitrairement grand. Comme dans le cas des automates de mots, il
est possible de pondérer des arbres via des structures algébriques externes aux états de l’automate,
mais encodées à l’intérieur même des morphismes des catégories enrichies. Si les structures utili-
sées étaient le semi-anneau et le semi-module dans le cas des mots, celles utilisées dans le cas des
arbres peuvent être déﬁnies à partir d’opérades particulières pour former des structures algébriques
appelées monoïdes multi-opérateurs dans la littérature (voir par exemple [39]).
Remarque 30: Monoïde multi-opérateurs
Classiquement, un monoïde multi-opérateurs est un monoïde commutatif (M, ⊕, 0) muni d’un
sous-ensemble de S
n Mn →M, ses opérateurs.
Les opérateurs d’un monoïde multi-opérateurs peuvent être utilisés pour pondérer les transitions
d’un automate d’arbre (Bottom-Up), une transition étiquetée par un symbole n-aire étant pondérée
par un opérateur n-aire.
Pour représenter cela, nous considérerons, pour deux types A et B et une opérade O munie d’une
somme graduée, les fonctions envoyant An sur les fonctions (partielles) de B vers les éléments n-aires
de O; un monoïde multi-opérateurs sera donc le cas où l’opérade choisie est celle des fonctions sur un
monoïde, la somme de deux fonctions de même arité étant déﬁnie comme la somme de leurs images.

130
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
Remarque 31: Opérade plus des fonctions sur un monoïde
Une opérade munie d’une somme graduée est appelée opérade plus dans la suite
de
ce
document.
La
classe
de
type
correspondante
est
déﬁnie
dans
le
module
Algebra.Structures.Operad comme suit :
class Operad o => OperadPlus o where
(<++>) :: Graduation o n -> Graduation o n -> Graduation o n
Si m est un type monoïdal, les fonctions n-aires sur m, pour un n ﬁxé, forment un monoïde,
implanté dans le module Algebra.Functions.GradedFunctions comme suit :
instance (Semigroup b, Singleton n)
=> Semigroup (Graduation (MultiFun a b) n) where
-- L'image d'une somme de fonctions est la somme de leurs images
x <> y = convertFromVectMultiFun
$ \xs -> convertToVectMultiFun x xs <> convertToVectMultiFun y xs
instance (Monoid b, Singleton n)
=> Monoid (Graduation (MultiFun a b) n) where
-- La fonction élément neutre est la fonction renvoyant
-- l'élément neutre du monoïde, quelles que soient les
-- entrées
mempty = convertFromVectMultiFun $ const mempty
instance Semigroup m => OperadPlus (MultiFun m m) where
-- La somme de l'opérade plus des fonctions sur un semigroupe
-- est la somme définie ci-avant
(<++>) = (<>)
Les automates d’arbres pondérés par des fonctions d’opérades plus sont déﬁnis sur la catégorie en-
richie dont les morphismes-objets sont constitués des fonctions envoyant un vecteur de n états sur
une combinaison de couple (élément n-aire de l’opérade, état). Cette catégorie enrichie, étendant la
notion de transduction (envoyant un symbole n-aire sur une combinaison de valeurs n-aires) est
implantée dans le module Algebra.Functions.GradedTransduction.
Remarque 32: Les automates pondérés par des opérades
De
tels
automates
permettent,
par
exemple,
d’associer
à
un
arbre
nullaire
sa
hauteur
ou
sa
largeur
(alphabétique).
Si
un
arbre
n’est
pas
nullaire,
son
poids
est
alors
une
fonction.
On
retrouvera
ces
automates
implantés
dans
le
module
AutomataGen.TreeAutomata.BottomUp.BottomUpMultiOpMon,
contenant
des
construc-
teurs usuels (packVar) et des fonctions utilitaires pour convertir les morphismes poids en
scalaire (scalarWeight, cas des arbres nullaires) ou fonctions (weightWithVarAsFun, cas
général).
L’exemple suivant (Pseudo-Code 70) 7 montre comment déﬁnir un automate d’arbre associant à un
arbre sur le type Char la multiplication de sa hauteur par sa largeur alphabétique 8 ; les variables
acceptées sont des chaînes de caractères, considérées alors comme des arbres de hauteur 1 mais de
largeur alphabétique correspondant à leur longueur. Un tel automate peut être déﬁni comme suit :
— trois états : un pour la largeur (Just WidthState), un pour la hauteur (Just HeightState),
un pour les combinaisons indésirables de transitions (Nothing);
— pour chaque symbole nullaire, une transition vers les états pour le calcul de la largeur et de la
hauteur avec un poids de 1;
— pour les symboles non-nullaires d’arité k, une transition envoyant les vecteurs uniformes
de valeurs (Just WidthState) sur (Just WidthState) (resp. (Just HeightState) sur (Just
HeightState)) de poids la fonction associant à k valeurs leur somme augmentée de 1 (resp. la
fonction associant à k valeurs leur maximum augmenté de 1);
— en poids ﬁnal la fonction identité;
— en conﬁguration initiale pour les variables (chaînes de caractères) les fonctions constantes
renvoyant leurs longueurs (pour l’état largeur) ou 1 (pour la hauteur).
7. exécutable via la commande stack ghci src/HDRExample/BUMultiOpMonoid.hs
8. nombre de ses nœuds et feuilles

6.5. Automates généralisés
131
Code Pseudo-Haskell. 70: Un automate sur une opérade plus
-- HDRExample.BUMultiOpMonoid
-- Définition des états de l'automate, pour calculer
-- la hauteur et la largeur
data StateType = HeightState | WidthState
-- L'automate a trois états: un pour calculer la hauteur
-- (Just HeightState), un pour la largeur (Just WidthState),
-- un pour les transitions non définies (Nothing).
type State = Maybe StateType
-- Le support est le monoïde multiplicatif des entiers
type Val = Product Int
-- Les variables sont des chaines de caractères
type Variables = String
-- Les symboles de l'arbres sont des caractères gradués.
type Inputs = Symbol Char
-- Fonction de transition associant à un symbole n-aire une transformation
-- d'un vecteur de longueur n en une combinaison
-- (fonction n-aire, état de l'automate)
delta_ :: GradedMorph Inputs (Transduction (MultiFun Val Val) State State)
delta_ = GradedMorph aux
where
aux x = aux' (graduation' x) x
aux'
:: Natural n
-> Graduation Inputs n
-> Graduation (Transduction (MultiFun Val Val) State State) n
-- Pour les feuilles (arité 0), les éléments de l'opérade sont
-- des entiers.
aux' Zero _ = GradTrans $ const $ fromList
[(Just HeightState, GradFun 1), (Just WidthState, GradFun 1)]
-- Dans le cas des symboles (n + 1)-aires, cela dépend du contenu du
-- vecteur d'états.
aux' n@(Succ _) _ = GradTrans $ \vs -> if
-- si tous les états sont HeighState, on utilise la fonction
-- classique du calcul de la hauteur (maximum des paramètres
-- + 1)
| all (== Just HeightState) vs -> fromList
[(Just HeightState, convertFromVectMultiFun n $ (1 +) . maximum)]
-- si tous les états sont WidthState, on utilise la fonction
-- classique du calcul de la largeur (somme des paramètres
-- + 1)
| all (== Just WidthState) vs -> fromList
[(Just WidthState, convertFromVectMultiFun n $ (1 +) . sum)]
-- sinon on se déplace dans l'état puits avec un poids neutre
| otherwise -> fromList
[(Nothing, convertFromVectMultiFun n $ const mempty)]
-- La fonction de finalité laisse la fonction poids inchangée.
finalWeight :: State -> Graduation (MultiFun Val Val) Nat_1
finalWeight _ = GradFun id
-- On associe aux variables des fonctions de poids constantes,
-- 1 pour la hauteur, la longueur pour la largeur.
initialWeight
:: Variables -> HashMap State (Graduation (MultiFun Val Val) Nat_1)
initialWeight s = Map.fromList
[ (Just HeightState, GradFun $ const 1)
, (Just WidthState , GradFun $ const $ genericLength s)
]
-- Construction de l'automate
auto :: BottomUpMultiOpMonWithVar Variables (MultiFun Val Val) Inputs State
auto = TA.packVar initialWeight delta_ finalWeight
-- a1 = g(a, f(b))

132
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
-- h = 3
-- w = 4
a1 :: Graduation (FreeOperad Inputs) Nat_0
a1 = tree2 g (tree0 a) (tree1 f (tree0 b))
-- a2 = g(g(a, f(b)), h(g(a, f(b))))
-- h = 5
-- w = 10
a2 :: Graduation (FreeOperad Inputs) Nat_0
a2 = tree2 g a1 (tree1 h a1)
-- a3 = g(g(g(a, f(b)), h(g(a, f(b)))), GradEps)
-- h = 6
-- w (s) = 11 + |s|
a3 :: Graduation (FreeOperad Inputs) Nat_1
a3 = tree2 g a2 GradEps
-- Affichage des résultats pour les trois arbres définis ci-avant
testBUMOM :: IO ()
testBUMOM = do
print (cast $ scalarWeight auto a1 :: Int) -- affiche 12
print (cast $ scalarWeight auto a2 :: Int) -- affiche 50
let test = "operade plus"
print (cast $ weightWithVarAsFun auto a3 test 0 :: Int) -- affiche 138
6.6
Automates généralisés et monades
La déﬁnition de catégories enrichies ad hoc n’est pas la seule façon de construire des automates de la
littérature classique en utilisant des notions catégoriques.
Comme dans le cas des automates de mots, il est certain que les monades ont un intérêt particulier de
par leur pouvoir d’abstraction. Le cas des automates d’arbres Top-Down est particulièrement intéres-
sant et remarquable de par le fait que le non-déterminisme, contrairement au cas des mots (et au cas
des automates d’arbres Bottom-Up que nous traiterons plus tard), permet d’augmenter le pouvoir
de représentation en termes de langage. Il est en effet bien connu qu’il existe des langages recon-
naissables par automates Top-Down non déterministes qui ne le sont pas par automates Top-Down
déterministes. De plus, les fonctions de transitions des automates Top-Down non-déterministes, des
fonctions graduées envoyant un symbole n-aire sur un morphisme de Q (l’objet état) vers 2(Qn), ne
peuvent pas être vu comme des morphismes d’une catégorie enrichie type Kleisli, qui seraient plutôt
basés sur un morphisme de Q (l’objet état) vers (2Q)n.
La représentation de ces automates se sufﬁt ainsi de l’extension du type DualFunN a b des fonctions
entre a et Vector n b (vecteurs de longueurs n sur b) (Pseudo-Code 60) en DualFunNF f a b des
fonctions entre a et f (Vector n b), le cas initial des automates Top-Down déterministes étant iso-
morphe au cas où t est le foncteur identité. Ce type est implanté dans le module Algebra.Functions
.GradedFunctionsTopDown, où on retrouvera également sa déﬁnition en tant que catégorie enrichie
sur la catégorie monoïdale des types gradués lorsque f est une monade de la catégorie des types
(HashSet, Maybe, FreeSemimodule k, Identity, etc.). Son utilisation permet alors de déﬁnir des au-
tomates Top-Down classiques avec ou sans variables (implantés comme des cas particuliers d’auto-
mates généralisés dans le module AutomataGen.TreeAutomata.TopDown.TopDownMonadicAutomata),
en retrouvant, comme dans le cas des mots, le non-déterminisme par la monade HashSet, le déter-
minisme non-complet par la monade Maybe, des multiplicités dans un semi-anneau par la monade
FreeSemimodule k, ou le déterminisme complet par la monade Identity.
L’exemple suivant (Pseudo-Code 71), dont la déﬁnition par le constructeur d’automate packVar né-
cessite
— une fonction associant à chaque état une combinaison linéaire de variables;
— une fonction graduée de transition associant à chaque symbole gradué n-aire une fonction
associant un état à une combinaison linéaire de vecteur de longueur n;
— une combinaison linéaire d’état pour conﬁguration initiale,

6.6. Automates généralisés et monades
133
présente l’utilisation d’un automate Top-Down à multiplicités permettant de calculer le nombre d’oc-
currences d’un arbre (non nécessairement nullaire) dans un arbre nullaire donné. Plus particulière-
ment ici, le nombre d’occurrences d’un arbre t dans un arbre nullaire t′ est calculé par l’automate
déﬁni comme suit :
— les états sont les sous-arbres (nullaires) de t′ ;
— pour tout état de la forme f(t1, . . . , tk), il y a une transition depuis cet état vers les états
(t1, . . . , tk) par le symbole f ;
— chaque état a pour poids initial son nombre d’occurrences dans t′ ;
— tout état a un poids ﬁnal de 1.
Cet exemple est exécutable via la commande stack ghci src/HDRExample/HDRTDWFTA.hs.
Code Pseudo-Haskell. 71: Un automate Top-Down à multiplicités
-- HDRExample.HDRTDWFTA
-- Symboles de l'alphabet gradué
type Inputs = Symbol Char
-- États de l'automate
type State = Graduation (FreeOperad Inputs) Nat_0
-- Morphisme de transition
delta_ :: GradedMorph Inputs (DualFunNF (FreeSemimodule Int) State State)
delta_ = GradedMorph $
-- Par la lettre f1,
\f1 -> DualGradFunF $
-- depuis l'état f2(t1, ..., tk) avec ts = (t1, ..., tk)
\(GradOp f2 ts) ->
-- si f1 = f2
if eqSymb f1 f2
-- la destination est le vecteur ts pour un poids de 1
then monome (toVector ts) 1
-- sinon pas de destination
else empty
-- Les états initiaux sont les sous-arbres nullaires de l'arbre
-- paramètre, avec une multiplicité correspondant aux occurrences.
inits :: State -> (FreeSemimodule Int) State
inits = fromListWith (+) . aux
where
aux :: State -> [(State, Int)]
aux t'@(GradOp f_ ts) = (t', 1) : foldMap aux (toVector ts)
-- On considère le singleton () pour variables.
-- Chaque état est envoyé sur () avec un poids de 1.
finals :: State -> FreeSemimodule Int ()
finals _ = monome () 1
-- Définition de l'automate
auto :: State -> TopDownWFTAWithVar () Int Inputs State
auto t = packVar finals (inits t) delta_
-- a1 = g(a, f(b))
a1 :: Graduation (FreeOperad Inputs) Nat_0
a1 = tree2 g (tree0 a) (tree1 f (tree0 b))
-- a2 = g(g(a, f(b)), h(g(a, f(b))))
a2 :: Graduation (FreeOperad Inputs) Nat_0
a2 = tree2 g a1 (tree1 h a1)
-- a3 = g(g(g(a, f(b)), h(g(a, f(b)))), g(a, f(b)))
a3 :: Graduation (FreeOperad Inputs) Nat_0
a3 = tree2 g a2 a1
-- a4 = g(Eps, f(Eps))
a4 :: Graduation (FreeOperad Inputs) Nat_2
a4 = tree2 g GradEps (tree1 f GradEps)
-- a5 = g(Eps, Eps)

134
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
a5 :: Graduation (FreeOperad Inputs) Nat_2
a5 = tree2 g GradEps GradEps
testTDWFTA :: IO ()
testTDWFTA = do
-- affichage de la multiplicité de a3 dans a3 : 1
print (weightWithVarAsScalar (auto a3) a3 :: Int)
-- affichage de la multiplicité de a4 dans a3 : 3
print (weightWithVarAsScalar (auto a3) a4 :: Int)
-- affichage de la multiplicité de a5 dans a3 : 5
print (weightWithVarAsScalar (auto a3) a5 :: Int)
Le cas des automates d’arbres Bottom-Up non-déterministes est quant à lui un bon candidat pour la
représentation de catégories enrichies type Kleisli. En effet, l’extension de la fonction de transition δ
présentée page 9 transforme la fonction de transition de signature Qn × Σn →2Q en (2Q)n × Σn →
2Q, transformation relativement proche de la promotion monadique. On peut ainsi s’intéresser à
la déﬁnition d’une catégorie enrichie dont les morphismes-objets entre deux objets a et b sont les
morphismes-objets entre les objets a et m b d’une catégorie enrichie. Pour cela, commençons par
étendre la notion de foncteur à celle de foncteur enrichi.
Un foncteur enrichi F entre deux catégories C et D enrichies sur la même catégorie monoïdale M =
(M, ⊗, I, α, λ, ρ) est déﬁni par :
— une association de chaque objet A de C à un objet F(A) de D,
— un morphisme FA,B de HomM(HomC(A, B), HomD(F(A), F(B)))
tels que les diagrammes suivants commutent :
HomC(B,C) ⊗HomC(A, B)
HomC(A,C)
HomD(F(B),F(C)) ⊗HomD(F(A),F(B))
HomD(F(A),F(C)),
◦C,(A,B,C)
FB,C ⊗FA,B
F(A, C)
◦C,(F(A),F(B),F(C))
HomC(A, A)
HomD(F(A),F(A))
I.
FA,A
IdA
IdF(A)
En Haskell, il ne s’agira que d’un morphisme d’une catégorie monoïdale entre deux morphismes-
objets 9.
Code Pseudo-Haskell. 72: Les foncteurs enrichis
-- Enriched.Category.EnrichedFunctor
-- Un constructeur de types f peut être un foncteur entre deux catégories
-- enrichies enrichedCat et enrichedCat' sur une catégorie monoïdale
-- catMon si est définie la fonction fmap ci-dessous.
class (EnrichedCategory enrichedCat catMon tensor,
EnrichedCategory enrichedCat' catMon tensor)
=> EnrichedFunctor f enrichedCat enrichedCat' catMon tensor where
-- Promotion fonctorielle : existence d'un morphisme dans catMon
-- envoyant tout morphisme-objet enrichedCat a b sur
-- (enrichedCat' (f a) (f b)).
-- Cette promotion doit être compatible avec l'identité
-- et l'associativité de la composition.
fmap :: catMon (enrichedCat a b) (enrichedCat' (f a) (f b))
9. pour une bonne compatibilité, il faudrait vériﬁer les propriétés fondamentales des catégories enrichies.

6.6. Automates généralisés et monades
135
Par exemple, on peut montrer que tout foncteur est équivalent à un foncteur enrichi sur la catégorie
monoïdale des types.
Code Pseudo-Haskell. 73: Les foncteurs enrichis de la catégorie monoïdale des types
-- Category.OfStructures.CategoryOfTypes
instance (FunctorGen f cat cat', CategoryGen cat, CategoryGen cat')
=> EnrichedFunctor f (EnrichedTypeCat cat) (EnrichedTypeCat cat') (->) Prod where
fmap = EnrichedTypeCat . fmap . runEnrichedCat
Le cas des fonctions n-aires est également intéressant : le rôle d’un endofoncteur f enrichi sur la ca-
tégorie enrichie de ces fonctions serait alors de promouvoir une fonction de an -> b en une fonction
de (f a)n -> f b. Pour cela, nous nous restreindrons dans ce document au cas où f est une mo-
nade 10. Ainsi, toute monade m de la catégorie des types permet de déﬁnir un endofoncteur sur la
catégorie enrichie des fonctions n-aires. Pour cela, il sufﬁt de montrer comment envoyer un vecteur
de n termes de type m a sur un terme m b pour une fonction donnée envoyant un vecteur de n termes
de type a sur un terme de type b.
Code Pseudo-Haskell. 74: Les foncteurs enrichis de la catégorie enrichies des fonctions n-
aires
-- Tools.Vector
-- Définition du type de données des vecteurs de longueur n
data Vector n a where
-- VNil est le vecteur de longueur 0
VNil
:: Vector 'Z a
-- VCons concatène un élément de type a et
-- un vecteur de longueur n pour former
-- un vecteur de longueur n
VCons :: a -> Vector n a -> Vector ('S n) a
-- Promotion monadique d'une fonction vectorielle
promoteFunctVectFun
:: MonadGen m (->)
=> (Vector n a -> b)
-> Vector n (m a)
-> m b
promoteFunctVectFun f VNil = return $ f VNil
promoteFunctVectFun f (VCons mx mxs) =
M.bind (\x -> promoteFunctVectFun (f . VCons x) mxs) mx
-- Algebra.Functions.GradedFunctions
-- Si m est une monade de la catégorie des types, m est
-- un endofoncteur enrichi sur la catégorie des fonctions
-- n-aires
instance MonadGen m (->)
=> EnrichedFunctor m MultiFun MultiFun GradedMorph TensorProd where
fmap = GradedMorph promoteGradMultiFun
where
promoteGradMultiFun f =
convertFromVectMultiFun $ promoteFunctVectFun $ convertToVectMultiFun f
L’enrichissement des monades peut se faire grâce à la notion d’élément généralisé; si les monades
sont déﬁnies par deux morphismes return et join de la catégorie sur laquelle elles existent, une
monade enrichie est déﬁnie par deux éléments généralisés ayant le même rôle (à savoir la promotion
monadique et la réduction de niveau monadique) 11, éléments à partir desquels les outils mona-
diques classiques peuvent être déﬁnis. NB : Dans le pseudo-code suivant, et plus généralement
dans le cadre des catégories enrichies, deux compositions coexistent : celle des catégories (plus
10. On pourrait également s’intéresser aux foncteurs applicatifs (foncteurs monoïdaux particuliers) de la bibliothèque de
base Haskell; mais la manipulation de ces foncteurs pour promouvoir des fonctions n-aires peut rendre son utilisation com-
plexe.
11. comme pour l’enrichissement des foncteurs, pour une bonne compatibilité, il faudrait vériﬁer les propriétés fondamen-
tales des catégories enrichies, comme par exemple déﬁnies dans [36] (chapitre 2, V-monads).

136
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
précisément celle de la catégorie monoïdale), fonction composant deux morphismes, et celle de la
catégorie enrichie, morphisme de la catégorie monoïdale. Pour lever les ambiguïtés, la composi-
tion de la catégorie enrichie sera préﬁxée par EC. et celle de la catégorie monoïdale par Cat.. Il en
sera de même pour l’identité le cas échéant.
Code Pseudo-Haskell. 75: Les monades enrichies
-- Enriched.Category.EnrichedMonad
-- Une monade enrichie est un endofoncteur enrichi particulier.
class (EnrichedFunctor m enrichedCat enrichedCat catMon tensor)
=> EnrichedMonad m enrichedCat catMon tensor where
-- Élément généralisé "choisissant" dans un morphisme-objet
-- une "transformation" promouvant une valeur au niveau
-- monadique
return :: catMon (Unit catMon tensor) (enrichedCat a (m a))
-- Élément généralisé "choisissant" dans un morphisme-objet
-- une "transformation" réduisant une valeur d'un niveau
-- monadique
join :: catMon (Unit catMon tensor) (enrichedCat (m (m a)) (m a))
-- Promotion monadique d'un morphisme objet
bind
:: ( EnrichedFunctor f enrichedCat enrichedCat catMon tensor
, EnrichedMonad f enrichedCat catMon tensor
)
=> catMon (enrichedCat a (f b)) (enrichedCat (f a) (f b))
bind = append fmap join
-- Composition de Kleisli enrichie.
(<=<)
:: (EnrichedMonad m enrichedCat catMon tensor, Bifunctor tensor catMon)
=> catMon
(tensor (enrichedCat b (m c), enrichedCat a (m b)))
(enrichedCat a (m c))
(<=<) = (EC..) Cat.. combine bind Cat.id
where
combine
:: (Bifunctor tensor catMon, _)
=> catMon (enrichedCat b (m c)) (enrichedCat (m b) (m c))
-> catMon (enrichedCat a (m b)) (enrichedCat a (m b))
-> catMon
(tensor (enrichedCat b (m c), enrichedCat a (m b)))
(tensor (enrichedCat (m b) (m c), enrichedCat a (m b)))
combine m1 m2 = F.fmap (Cat.Prod m1 m2)
Par exemple,
— toute monade déﬁnit une monade enrichie sur la catégorie monoïdale des types;
— toute monade sur la catégorie des types déﬁnit une monade enrichie sur la catégorie enrichie
des fonctions n-aires.
Code Pseudo-Haskell. 76: Exemples de monades enrichies
-- Category.OfStructures.CategoryOfTypes
instance MonadGen m cat
=> EnrichedMonad m (EnrichedTypeCat cat) (->) Prod where
return () = EnrichedTypeCat return
join () = EnrichedTypeCat join
-- Algebra.Functions.GradedFunctions
instance MGen.MonadGen m (->)
=> EnrichedMonad m MultiFun GradedMorph TensorProd where
return = GradedMorph $ \GradUn -> GradFun return
join
= GradedMorph $ \GradUn -> GradFun join

6.6. Automates généralisés et monades
137
Aﬁn de pouvoir déﬁnir la catégorie enrichie de Kleisli associée à une monade, il nous faut créer le
type des morphismes-objets de cette catégorie, à savoir des morphismes-objets entre des objets a et m
b. Cependant, puisque nous manipulerons ces morphismes-objets à travers des morphismes d’une
catégorie monoïdale, qui ne sont pas nécessairement des fonctions, il nous faut trouver un moyen
de promouvoir les constructeurs de types et les fonctions de projection au niveau de la catégorie
monoïdale. Ainsi, nous nous restreindrons alors aux catégories monoïdales catMon satisfaisant les
trois propriétés suivantes :
— le constructeur de type Identity est un foncteur depuis la catégorie des types vers la caté-
gorie catMon, permettant d’envoyer toute fonction (y compris les constructeurs de types) de
signature a -> b sur un morphisme de catMon (Identity a) (Identity b);
— le constructeur de type Identity est une monade de la catégorie catMon, permettant d’exhiber
le morphisme return, de signature catMon a (Identity a);
— le constructeur de type Identity est une comonade 12 de la catégorie catMon, permettant d’ex-
hiber le morphisme extract, de signature catMon (Identity a) a.
Si les deux dernières propriétés permettent de transformer un morphisme de signature catMon
(Identity a) (Identity b) en catMon a b, l’ajout de la première permet de transformer toute
fonction de signature a -> b en un morphisme catMon a b :
Code Pseudo-Haskell. 77: Conversion fonctions / morphismes
-- Category.MonadGen
-- Élimination du constructeur de types Identity dans un morphisme
-- d'une catégorie
removeId
:: (MonadGen Identity cat, CoMonadGen Identity cat, CategoryGen cat)
=> cat (Identity a) (Identity b)
-> cat a b
removeId f = extract . f . return
-- Promotion d'une fonction en un morphisme
catPromote
:: ( FunctorGen Identity (->) cat
, MonadGen Identity cat
, CoMonadGen Identity cat
)
=> (a -> b)
-> cat a b
catPromote = removeId . fmap
-- Compose une fonction promue à un morphisme
catApply
:: ( FunctorGen Identity (->) cat
, CategoryGen cat
, MonadGen Identity cat
, CoMonadGen Identity cat
)
=> (b -> c)
-> cat a b
-> cat a c
catApply f m = catPromote f . m
À l’aide de ces outils, on peut alors déﬁnir un constructeur de types pour les morphismes-objets de
la catégorie enrichie de Kleisli associée à une monade enrichie. Comme dans le cas des catégories
de Kleisli (voir Pseudo-Code 21), les éléments déﬁnissant la classe, à savoir les valeurs id et (.),
seront obtenus par la combinaison du constructeur de types Kleisli avec (respectivement) return
et (<=<).
Code Pseudo-Haskell. 78: Catégorie enrichie de Kleisli associée à une monade enrichie
-- Enriched.Category.Kleisli
-- Définition du constructeur de type KleisliEnrichedCat, contenant une
12. monade de la catégorie duale, caractérisée notamment par la fonction extract de signature duale de return

138
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
-- valeur de type enrichedCat a (m b), et de la fonction de projection
-- runKleisli renvoyant cette valeur.
data KleisliEnrichedCat m enrichedCat catMon tensor a b where
Kleisli ::
{runKleisli :: enrichedCat a (m b)}
-> KleisliEnrichedCat m enrichedCat catMon
tensor a b
-- Promotion du constructeur de type au niveau de la catégorie monoïdale.
packKleisli ::
(FunctorGen Identity (->) catMon, MonadGen Identity catMon, CoMonadGen Identity catMon)
=> catMon (enrichedCat a (m b)) (KleisliEnrichedCat m enrichedCat catMon tensor a b)
packKleisli = catPromote Kleisli
-- Promotion de la fonction de projection de type au niveau
-- de la catégorie monoïdale.
unpackKleisli ::
(FunctorGen Identity (->) catMon
, MonadGen Identity catMon
, CoMonadGen Identity catMon
)
=>
catMon (KleisliEnrichedCat m enrichedCat catMon tensor a b) (enrichedCat a (m b))
unpackKleisli = catPromote runKleisli
-- Promotion de la fonction de projection de type au niveau
-- des produits tensoriels de la catégorie monoïdale.
unpackProdKleisli ::
( FunctorGen Identity (->) catMon
, MonadGen Identity catMon
, CoMonadGen Identity catMon
, Bifunctor tensor catMon)
=> catMon
(tensor
(KleisliEnrichedCat m enrichedCat catMon tensor b c
, KleisliEnrichedCat m enrichedCat catMon tensor a b))
(tensor (enrichedCat b (m c), enrichedCat a (m b)))
unpackProdKleisli = fmap $ Prod unpackKleisli unpackKleisli
-- Définition de la catégorie enrichie de Kleisli associée
-- à la monade enrichie m
instance
( FunctorGen Identity (->) catMon
, MonadGen Identity catMon
, EnrichedMonad m enrichedCat catMon tensor
, CoMonadGen Identity catMon
, Monoidal catMon tensor
)
=> EnrichedCategory (KleisliEnrichedCat m enrichedCat catMon tensor) catMon tensor
where
id
= catApply Kleisli return
(.) = packKleisli Cat.. (<=<) Cat.. unpackProdKleisli
Dans le cas des automates de mots généralisés, on peut encore montrer que les automates généralisés
de Kleisli sont équivalents aux automates (catégoriques) de Kleisli.
Code Pseudo-Haskell. 79: Équivalence entre automates de mots de Kleisli et automates
généralisés de mots de Kleisli
-- AutomataGen.WordAutomata.WordAut
convertToClassicalKleisliAutomaton
:: WordAut
(KleisliEnrichedCat m (EnrichedTypeCat cat) (->) Prod)
init
symbols
state
value
-> Automaton (KleisliCat m cat) init symbols state value
convertToClassicalKleisliAutomaton (AG.Auto i d f) = A.Auto

6.6. Automates généralisés et monades
139
(Kleisli $ runEnrichedCat $ runKleisli $ i ())
(Kleisli . runEnrichedCat . runKleisli . d)
(Kleisli $ runEnrichedCat $ runKleisli $ f ())
convertFromClassicalKleisliAutomaton
:: (MonadGen m cat)
=> Automaton (KleisliCat m cat) init symbols state value
-> WordAut
(KleisliEnrichedCat m (EnrichedTypeCat cat) (->) Prod)
init
symbols
state
value
convertFromClassicalKleisliAutomaton (A.Auto i d f) = AG.Auto
(\() -> KECat.Kleisli $ EnrichedTypeCat $ KCat.runKleisli i)
(KECat.Kleisli . EnrichedTypeCat . KCat.runKleisli . d)
(\() -> KECat.Kleisli $ EnrichedTypeCat $ KCat.runKleisli f)
Pour les automates d’arbres Bottom-Up, il sufﬁt également de considérer des synonymes de types
pour retrouver les automates monadiques classiques (déterministes non complets, non-déterministes,
etc.)
Code Pseudo-Haskell. 80: Automates d’arbres Bottom-Up monadiques
-- AutomataGen.TreeAutomata.BottomUp.KleisliTreeAutomata
type KleisliBottomUpTreeAutWithVar m var symbols state
= TreeAut
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
var
symbols
state
()
type KleisliBottomUpTreeAut m symbols state
= KleisliBottomUpTreeAutWithVar m Void symbols state
type BottomUpWFTAWithVar var k symbols state
= KleisliBottomUpTreeAutWithVar (FreeSemimodule k) var symbols state
type BottomUpWFTA k symbols state
= KleisliBottomUpTreeAut (FreeSemimodule k) symbols state
type BottomUpNFTAWithVar var symbols state
= KleisliBottomUpTreeAutWithVar HashSet var symbols state
type BottomUpNFTA symbols state = KleisliBottomUpTreeAut HashSet symbols state
type BottomUpDFTAWithVar symbols state var
= KleisliBottomUpTreeAutWithVar Maybe var symbols state
type BottomUpDFTA symbols state = KleisliBottomUpTreeAut Maybe symbols state
-- Construction d'un automate d'arbres Bottom-Up de Kleisli
-- avec variables.
packVar
:: ( Graded symbols
, Castable (m weight) k
, EnrichedMonad m MultiFun GradedMorph TensorProd
)
=> (var -> m state)
-> GradedMorph symbols (MultiFun state (m state))
-> (state -> k)
-> TreeAut
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
var
symbols
state
weight
packVar i delta_ finalWeights = Auto i_ transit end
where
i_
= packKleisli . gradedMorphFromFun i

140
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
transit = packKleisli . delta_
end
= packKleisli . gradedMorphFromFun (castInv . finalWeights)
-- Construction d'un automate d'arbres Bottom-Up de Kleisli
-- sans variable.
pack
:: ( Graded symbols
, Castable (m weight) k
, EnrichedMonad m MultiFun GradedMorph TensorProd
)
=> GradedMorph symbols (MultiFun state (m state))
-> (state -> k)
-> TreeAut
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
Void
symbols
state
weight
pack = packVar absurd
-- Fonction auxiliaire pour calculer le poids associé
-- à un arbre non nécessairement nullaire
weightWithVar
:: (Graded symbols, EnrichedMonad m MultiFun GradedMorph TensorProd)
=> TreeAut
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
var
symbols
state
weight
-> Graduation (FreeOperad symbols) n
-> NFun n var (m weight)
weightWithVar auto = runGradFun . applyMorph (unpackKleisli Cat.. weight auto)
-- Fonction auxiliaire pour calculer le poids associé
-- à un arbre nullaire
weightAsScalar
:: ( Graded symbols
, Castable (m ()) k
, EnrichedMonad m MultiFun GradedMorph TensorProd
, _
)
=> TreeAut
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
Void
symbols
state
()
-> Graduation (FreeOperad symbols) Nat_0
-> k
weightAsScalar auto =
runGradFun . applyMorph (EC.packCast Cat.. unpackKleisli Cat.. weight auto)
-- Fonction auxiliaire pour calculer le poids associé
-- à un arbre nullaire dans le cas Booléeen
recognizes
:: ( Graded symbols
, Castable (m ()) Bool
, EnrichedMonad m MultiFun GradedMorph TensorProd
)
=> TreeAut
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
Void
symbols
state
()
-> Graduation (FreeOperad symbols) Nat_0
-> Bool
recognizes = weightAsScalar

6.6. Automates généralisés et monades
141
Pour conclure cette partie sur les automates généralisés, remarquons que pour toute catégorie enri-
chie de Kleisli, il existe un foncteur enrichi envoyant cette catégorie enrichie sur la catégorie dont
elle est issue. En effet, comme dans le cas des catégories de Kleisli, il est possible d’envoyer un
morphisme-objet entre a et b de la catégorie enrichie de Kleisli (c’est-à-dire un morphisme-objet entre
a et m b de la catégorie enrichie de départ) sur le morphisme-objet entre m a et m b, en appliquant la
fonction bind. Ce foncteur enrichi, appelé classiquement foncteur de Kleisli, permet d’implanter d’une
façon unique les algorithmes de déterminisation ou de complétion, et cela indépendamment de la
catégorie enrichie : dans tous les cas, on envoie un automate généralisé de Kleisli sur un automate
généralisé.
Code Pseudo-Haskell. 81: Foncteur enrichi de Kleisli et conversions
-- Enriched.Category.Kleisli
instance
(EnrichedCategory enrichedCat catMon tensor
, EnrichedMonad m enrichedCat catMon tensor
, MonadGen Identity catMon
, CoMonadGen Identity catMon
, FunctorGen Identity (->) catMon)
=> EnrichedFunctor m (KleisliEnrichedCat m enrichedCat catMon tensor) enrichedCat catMon tensor
where
fmap = bind . unpackKleisli
-- AutomataGen.AutomatonGen
-- Conversion générale entre automates généralisés.
-- Retire un niveau de structure monadique dans la catégorie
-- enrichie et ajoute ce niveau aux configurations de l'automate.
unKleisli
:: EnrichedMonad m enrichedCat catMon tensor
=> AutomatonGen
(KleisliEnrichedCat m enrichedCat catMon tensor)
catMon
tensor
init
symbols
state
value
-> AutomatonGen
enrichedCat
catMon
tensor
init
symbols
(m state)
(m value)
unKleisli (Auto i d f) = Auto i' d' f'
where
i' = unpackKleisli . i
d' = fmap . d
f' = fmap . f
-- Identique à unKleisli, avec une modification
-- du poids de sortie
unKleisliWithCast
:: ( EnrichedMonad m enrichedCat catMon tensor
, Castable (m value) value'
)
=> AutomatonGen
(KleisliEnrichedCat m enrichedCat catMon tensor)
catMon
tensor
init
symbols
state
value
-> AutomatonGen enrichedCat catMon tensor init symbols (m state) value'
unKleisliWithCast a = Auto i d f'

142
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
where
Auto i d f = unKleisli a
f'
= packCast . f
-- AutomataGen.WordAutomata.WordAut
determinise
:: (Hashable state, Eq state)
=> WordAut
(KleisliEnrichedCat HashSet (EnrichedTypeCat (->)) (->) Prod)
init
symbols
state
()
-> WordAut (EnrichedTypeCat (->)) init symbols (HashSet state) Bool
determinise = unKleisliWithCast
complete
:: WordAut
(KleisliEnrichedCat Maybe (EnrichedTypeCat (->)) (->) Prod)
init
symbols
state
()
-> WordAut (EnrichedTypeCat (->)) init symbols (Maybe state) Bool
complete = unKleisliWithCast
-- AutomataGen.TreeAutomata.BottomUp.KleisliTreeAutomata
determinise
:: (Hashable state, Eq state, Graded symbols)
=> BottomUpNFTA symbols state
-> BottomUpCompDFTA symbols (HashSet state)
determinise = unKleisliWithCast
complete
:: (Graded symbols)
=> BottomUpDFTA symbols state
-> BottomUpCompDFTA symbols (Maybe state)
complete = unKleisliWithCast
Remarque 33: Les fonctions unKleisli et applyFunctor
La fonction de conversion applyFunctor déﬁnie pour les conversions des automates est en
quelque sorte plus générale dans son rôle que la fonction unKleisli; la première permet
de transformer des catégories de Kleisli, la seconde de déKleisliﬁer une catégorie enrichie de
Kleisli.
Les deux exemples suivants illustrent l’utilisation de la même fonction unKleisli pour déterminiser
des automates de mots et d’arbres. Ils sont exécutables via les commandes
stack ghci src/HDRExample/ExampleWordGenDet.hs
et stack ghci src/HDRExample/ExampleBUNTA.hs.
Le Pseudo-Code 82 montre comment déterminiser l’automate déﬁni au Pseudo-Code 17, en utilisant
les automates généralisés : l’automate classique est converti en automate généralisé, il est ensuite
déterminisé par la fonction determinise (synonyme de la fonction unKleisliWithCast) déﬁnie au
Pseudo-Code 81, puis le résultat est reconverti en automate classique. Les transitions de ce dernier
automate sont alors afﬁchées.
Code Pseudo-Haskell. 82: Déterminisation d’un automate (généralisé) de mots
-- HDRExample.ExampleWordGenDet
import Automata.DFAComp
as DFA
import Automata.KleisliAutomata
as NFA
import AutomataGen.WordAutomata.WordAut as WA
import HDRExample.KleisliAuto
as KA

6.6. Automates généralisés et monades
143
-- automate du Pseudo-Code 17
k_auto :: NFA KA.Symbol Int
k_auto = KA.auto 3
-- conversion en automate non déterministe généralisé
w_auto :: WA.NonDetWordAut KA.Symbol Int
w_auto = WA.convertFromClassicalKleisliAutomaton k_auto
-- déterminisation (en tant qu'automate généralisé)
-- appelant le synonyme de unKleisli
w_auto2 :: WA.CompDetWordAut KA.Symbol (HashSet Int)
w_auto2 = WA.determinise w_auto
-- conversion en un automate classique
k_auto2 :: DFAComp KA.Symbol (HashSet Int)
k_auto2 = WA.convertToClassicalAutomaton w_auto2
-- Affichage des états et des transitions
-- des automates k_auto
-- et de son déterminisé (obtenu en passant
-- par les automates généralisés)
testWordAutGen :: IO ()
testWordAutGen = do
putStrLn "k_auto transitions: \n\t"
let trans = NFA.getTransitions k_auto
putStrLn $ toString trans
putStrLn "k_auto2=Det(k_auto) transitions: \n\t"
let trans2 = DFA.getTransitions k_auto2
putStrLn $ toString trans2
Le Pseudo-Code 83 montre comment déﬁnir et déterminiser l’automate de la Figure 6.2 en appliquant
un synonyme de la même fonction polymorphe unKleisliWithCast.
1
2
a, b
f
f
h
g
FIGURE 6.2 – Un automate Bottom-Up non-déterministe.
Code Pseudo-Haskell. 83: Déterminisation d’un automate (généralisé) d’arbres
-- HDRExample.ExampleBUNTA
-- synonyme de type
type State = Int
-- fonction de transition
delta_ :: GradedMorph (Symbol Char) (MultiFun State (HashSet State))
delta_ = GradedMorph aux
where
aux x = aux' (graduation' x) x
aux'
:: Natural n
-> Graduation (Symbol Char) n
-> Graduation (MultiFun State (HashSet State)) n
aux' Zero x | eqSymb x a = GradFun $ singleton 1
| eqSymb x b = GradFun $ singleton 1
aux' (Succ Zero) x
| eqSymb x f = GradFun $ \case
1 -> fromList [1, 2]
_ -> empty

144
Chapitre 6. Extensions des automates de mots : les automates monoïdaux
| eqSymb x h = GradFun $ \case
2 -> fromList [2]
_ -> empty
aux' (Succ (Succ Zero)) x
| eqSymb x g = GradFun $ \x_ y_ -> case (x_, y_) of
(1, 1) -> singleton 1
_
-> empty
aux' n _ = convertFromVectMultiFun n $ const Set.empty
-- états finaux
isFinal :: Int -> Bool
isFinal 2 = True
isFinal _ = False
-- définition de l'automate non déterministe
auto :: BottomUpNFTA (Symbol Char) State
auto = TA.pack delta_ isFinal
-- déterminisation par la fonction (synonyme de)
-- unKleisli
auto2 :: BottomUpDFTA (Symbol Char) (HashSet State)
auto2 = convertDet $ determinise auto
-- affichage des états et des transitions de l'automate
-- et de son déterminisé
testBUNTA :: IO ()
testBUNTA = do
let arities = GCons a $ GCons b $ GCons h $ GCons f $ GCons g GNil
putStrLn "Auto: "
let (states, trans) =
accessibleStatesAndTransitionsForWithInit Set.empty arities auto
putStrLn $ "Transitions: " ++ toString trans
putStrLn $ "States: " ++ toString states
putStrLn "Det(Auto):"
let (states2, trans2) =
accessibleStatesAndTransitionsForWithInit Set.empty arities auto2
putStrLn $ "Transitions: " ++ toString trans2
putStrLn $ "States: " ++ toString states2
6.7
Conclusion
Dans cette section, nous avons montré comment uniﬁer les notions d’automates de mots et d’arbres
via l’utilisation des catégories enrichies, tout en conservant les possibilités d’agilité structurelle des
catégories de Kleisli de la section précédente. Pour cela, nous avons manipulé les catégories enrichies
des types et des types gradués.
Bien évidemment, il est possible de déﬁnir d’autres types en entrée des automates généralisés : on
pourrait s’intéresser aux automates de mots commutatifs, ou aux automates de PROs [55] (graphes
particuliers, généralisation des arbres). Il sufﬁrait pour cela de changer la catégorie monoïdale sous-
jacente des catégories enrichies à considérer : quelle serait par exemple la structure algébrique sous-
jacente des monoïdes-objets d’une catégorie monoïdale sur les types bi-gradués?
La section suivante pose la question de l’extension de cette généralisation aux expressions; notam-
ment, nous allons voir comment factoriser les structures d’expressions de mots et d’expressions
d’arbres, ces structures n’utilisant pas, à première vue, des opérateurs de même nature. Ainsi, nous
répondrons à la question suivante. Est-il possible, une fois une catégorie monoïdale ﬁxée, d’en dé-
duire un jeu d’opérateurs permettant de représenter le fonctionnement des automates généralisés
associés?

145
7 Expressions rationnelles
Dans cette section, nous allons nous intéresser à la façon de décrire des expressions aﬁn de généraliser
la construction classique d’automates aux automates catégoriques. Nous réaliserons cette générali-
sation en procédant en deux étapes.
Tout d’abord, nous allons montrer comment généraliser les constructions aux automates de Kleisli
déﬁnis dans les sections 5.1 et 5.2, c’est-à-dire non enrichie. Pour cela, nous nous appuierons sur un
type classique d’expressions à multiplicités (mais étendu à de nouveaux opérateurs) et nous éten-
drons d’une façon directe les constructions classiques de calcul de positions, de calcul de dérivées ou
de calcul inductif en montrant comment factoriser les calculs au niveau monadique.
Nous montrerons ensuite, par un type d’expression nouveau, comment déﬁnir des expressions enri-
chies permettant de généraliser expressions de mots et d’arbres, et étendrons quelques constructions
classiques sur celui-ci.
Nous conclurons alors ce document sur les pistes possibles offertes par cette déﬁnition.
7.1
Déﬁnition et implantation des expressions de mots
Nous avons vu dans les chapitres précédents différentes modélisations des automates réalisées via
différentes monades. Aﬁn de préserver la diversité des cas présentés, nous allons construire un type
d’expressions assez général pour modéliser des opérations de natures variées, par exemple en autori-
sant toute fonction, non nécessairement unaire, pour combiner des poids, comme lors de la déﬁnition
des automates alternants généralisés.
Ainsi, dans cette section, nous considérerons des expressions déﬁnies, une fois un semi-anneau ﬁxé,
inductivement comme :
1. l’ensemble vide, associant à tout mot un poids nul,
2. un caractère, associant à celui et uniquement à celui-ci un poids unitaire,
3. le mot vide, associant à celui et uniquement à celui-ci un poids unitaire,
4. un opérateur n-aire appliqué sur n expressions,
où les opérateurs considérés seront les suivants :
1. la concaténation binaire,
2. l’étoile unaire,
3. la somme binaire,
4. les multiplications unaires gauche et droite par un scalaire,
5. la négation unaire et l’intersection binaire, pour les semi-anneaux Booléens,
6. un opérateur générique de fonctions n-aires (par exemple pour construire des automates al-
ternants généralisés utilisés dans le Pseudo-Code 56).
Aﬁn de faciliter l’implantation, les particularités des opérateurs génériques seront déﬁnies à l’aide
d’une famille de types dépendant de l’arité de l’opérateur et du type de poids.
Code Pseudo-Haskell. 84: Opérateurs des expressions de mots
-- Expressions.WordExp.Operator
-- Famille de types permettant de définir un opérateur
-- générique en fonction de son arité.

146
Chapitre 7. Expressions rationnelles
-- Un opérateur d'arité 1 est défini par un Booléen
-- spécifiant si l'opérateur est post-fixe, ainsi que
-- d'une fonction unaire.
-- Un opérateur d'arité 2 est défini par un Booléen
-- indiquant si l'opérateur est infixe, un second Booléen
-- indiquant si l'opérateur est associatif à gauche ou
-- à droite, un entier pour indice de priorité,
-- ainsi que d'une fonction binaire.
-- Pour les autres arités, seule la fonction est donnée.
type family InfoOp n a where
InfoOp Nat_1 a = (Bool, Fun Nat_1 a)
InfoOp Nat_2 a = (Bool, Bool, Int, Fun Nat_2 a)
InfoOp n a = Fun n a
-- Type des opérateurs utilisés dans une expression.
-- Oper a n est un opérateur n-aire sur une expression
-- dont les poids sont de types a.
data Oper a n
where
-- Opérateur générique défini à partir
Function ::
String -- d'une chaîne pour sa description,
-> Natural n -- d'une arité,
-> InfoOp n a -- d'une information (définie ci-avant)
-> Oper a n
-- Concaténation, binaire
Concat ::Oper a Nat_2
-- Étoile d'itération, unaire
Star ::Oper a Nat_1
-- Somme, binaire
Plus ::Oper a Nat_2
-- Multiplication à gauche par un scalaire, unaire
MultL ::a -> Oper a Nat_1
-- Multiplication à droite par un scalaire, unaire
MultR ::a -> Oper a Nat_1
-- Complémentation Booléenne, unaire
Not ::Oper Bool Nat_1
-- Intersection Booléenne, binaire
Inter ::Oper Bool Nat_2
Les opérateurs génériques permettent ainsi de déﬁnir simplement des opérateurs d’expressions gé-
nériques, comme le montre le Pseudo-Code suivant.
Code Pseudo-Haskell. 85: Opérateurs customisés
-- Expressions.WordExp.Operator
-- Opérateur binaire d'implication Booléenne
implOper :: Oper Bool Nat_2
implOper = Function "->" two (True, False, 4, GradFun (<=))
-- Opérateur unaire d'exponentiation par un entier
powerOper :: (Fractional a, Integral b, Show b) => b -> Oper a Nat_1
powerOper n = Function ("^" ++ show n) one (True, GradFun (^^ n))
-- Opérateur binaire de calcul de moyenne
meanOper :: (Fractional a) => Oper a Nat_2
meanOper =
Function "moyenne" two (False, False, 0, GradFun (\x y -> (x + y) / 2))
À l’aide de ces opérateurs, les expressions sont déﬁnies comme suit.
Code Pseudo-Haskell. 86: Expressions de mots
-- Expressions.WordExp.Expression
-- Type de données (GADT) des expressions
data Expression weight character where
Epsilon :: Expression weight character

7.2. Constructions d’automates de mots
147
Empty :: Expression weight character
Symbol :: character -> Expression weight character
Operator ::
Oper weight n
-> Vector n (Expression weight character)
-> Expression weight character
7.2
Constructions d’automates de mots
Montrons alors comment factoriser certaines méthodes de construction d’automates connues pour
obtenir à partir des expressions déﬁnies dans le Pseudo-Code 86 des automates de Kleisli. Plus pré-
cisément, nous allons montrer comment des mêmes expressions permettent d’obtenir des automates
de Kleisli sur différentes monades, permettant ainsi d’interpréter une même expression de différentes
façons possibles, à l’aide du polymorphisme et de la programmation au niveau des types (à l’aide
des GADTs).
Nous considérerons trois méthodes classiques de construction. La première, la méthode par induc-
tion, ne sera présentée que pour construire des automates non-déterministes ou à multiplicités, aﬁn
de présenter la notion de monade libre que l’on utilisera dans la section suivante. La deuxième, la
méthode par positions, sera restreinte aux opérateurs compatibles avec la notion de position (les ex-
pressions simples ou les multiplications par scalaires). Enﬁn, la dernière, la dérivation, sera la plus
générale possible, aﬁn d’essayer de tirer proﬁt des propriétés de la monade ambiante.
Remarque 34: Les semianneaux étoilés
Il est important de noter que l’étoile de Kleene, lorsqu’elle s’applique sur des langages pondé-
rés (ou séries), doit être accompagnée d’une opération similaire sur le semianneau des poids.
Ainsi, dans la suite, nous considérerons le module Haskell Data.Star du package semirings,
déﬁnissant les semianneaux étoilés comme des semianneaux munis d’une opération unaire ∗
satisfaisant l’équation suivante (voir [29, 57] pour d’autres déﬁnitions), pour tout élément x
du semianneau :
x∗= 1 + x∗× x = 1 + x × x∗.
7.2.1
Induction et monade libre
La première méthode que nous allons décrire est la construction inductive : nous montrerons dans
la suite comment factoriser cette construction aﬁn d’obtenir, uniquement par un processus de ty-
page, des automates de Kleisli distincts (des automates non-déterministes ou à multiplicités) tout en
conservant les bénéﬁces du polymorphisme pour les cas généraux.
Remarquons que cette méthode inductive peut être interprétée à la façon d’un morphisme d’opé-
rades, en considérant l’arbre syntaxique d’une expression. En effet l’idée de la construction est de :
— générer à partir de chaque atome (c’est-à-dire une feuille de l’arbre, ici le mot vide, les sym-
boles ou l’ensemble vide) un automate reconnaissant unitairement cet atome;
— associer à chaque opérateur n-aire une fonction n-aire sur l’ensemble des automates.
Les fonctions de somme et d’intersection Booléenne ont déjà été décrites dans la Remarque 21 pour
les automates non-déterministes et à multiplicités.
La concaténation de deux automates de Kleisli peut également être factorisée en considérant que les
monades d’ensemble et de semimodule libre, une fois appliquées, forment des semi-modules pour
les types des poids de sorties des automates associés :
— tout ensemble est un semimodule Booléen (Pseudo-Code 87);
— tout K-semimodule libre est (par essence) un K-semimodule (voir Pseudo-Code 27).
Code Pseudo-Haskell. 87: Monades et semimodules
-- Algebra.Structures.Semimodule
-- Les Booléens agissent sur les ensembles

148
Chapitre 7. Expressions rationnelles
instance (Hashable a, Eq a) => Semimodule Bool (HashSet a) where
-- True agit comme l'identité
action True
e = e
-- False annule l'ensemble et le vide
action False _ = Set.empty
actionR = flip action
Ainsi, la concaténation de deux automates se construit comme suit :
1. réalisation de la somme de deux automates en ne conservant comme conﬁguration initiale
que celle du premier automate;
2. modiﬁcation des morphismes de transitions en ajoutant comme destination aux états p du
premier automate la conﬁguration initiale du second après avoir fait agir dessus le poids de
ﬁnalité de p;
3. action, sur les poids de sortie des états du premier automate, du poids du mot vide du second
automate.
Code Pseudo-Haskell. 88: Concaténation de deux automates de Kleisli
-- Automata.InductionAutomatonFromExp
concatGen
:: ( MonadGen m (->)
, Hashable state
, Eq state
, Eq state'
, Hashable state'
, Castable (m ()) weight
, Semimodule weight (m ())
, Semimodule weight (m (Sum (state, state')))
, Semigroup (m (Sum (state, state')))
, Castable (KleisliCat m (->) () ()) weight
)
=> Automaton (KleisliCat m (->)) () symbols state ()
-> Automaton (KleisliCat m (->)) () symbols state' ()
-> Automaton (KleisliCat m (->)) () symbols (Sum (state, state')) ()
concatGen a1@(Auto _ _ (Kleisli f1)) a2@(Auto _ _ (Kleisli f2)) = Auto i d' f'
where
-- réalisation de la somme des deux automates
Auto i d _ = reduceInitialSum const $ binaryTransformationBySum a1 a2
-- poids du mots vide dans a2
epsilonWeight2 = weightValue a2 []
-- nouveau poids de finalité pour les états de a1
f'
= Kleisli $ \case
Fst p -> f1 p `actionR` epsilonWeight2
Snd q -> f2 q
-- nouvelle transition pour les états de a1 :
-- est ajoutée la configuration initiale de a2
-- après action du poids de finalité de l'état
-- de départ
d' a = Kleisli $ \case
p@(Fst p_) ->
runKleisli (d a) p
<> ((cast (f1 p_) :: weight) `action` fmap
Snd
(runKleisli initsByA ())
)
q -> runKleisli (d a) q
where initsByA = getConfig a2 [a]
L’étoile se construit d’une façon similaire :
1. ajout d’un état supplémentaire d’un poids ﬁnal unitaire, qui devient conﬁguration initiale
après avoir fait agir dessus le poids du mot vide passé à l’étoile du semi-anneau étoilé; ses
successeurs sont constitués par les successeurs de l’ancienne conﬁguration initiale;

7.2. Constructions d’automates de mots
149
2. modiﬁcation des morphismes de transitions en ajoutant comme destination aux états p de
l’automate initial la conﬁguration initiale de cet automate après avoir fait agir dessus le poids
de ﬁnalité de p;
3. action, sur les poids de sortie des états de l’automate initial, du poids étoilé du mot vide de
cet automate.
Code Pseudo-Haskell. 89: Étoile d’un automate
-- Automata.InductionAutomatonFromExp
starGen
:: ( Eq state
, Hashable state
, Castable (m ()) weight
, Star weight
, MonadGen m (->)
, Semigroup (m (Maybe state))
, Semimodule weight (m (Maybe state))
, Castable (KleisliCat m (->) () ()) weight
)
=> Automaton (KleisliCat m (->)) () symbols state ()
-> Automaton (KleisliCat m (->)) () symbols (Maybe state) ()
starGen aut@(Auto _ d (Kleisli f)) = Auto
-- ajout d'un nouvel état constituant la configuration
-- initiale de l'automate
(Kleisli $ const $ action (star epsWeight) $ return Nothing)
(Kleisli . d')
(Kleisli finality)
where
-- les successeurs de la nouvelle configuration initiale
-- sont constitués par les successeurs de l'ancienne
-- configuration initiale
d' a = maybe (initsBy a) succOf
where
-- sont ajoutés aux successeurs d'un état p de l'automate initial
-- les successeurs de l'ancienne configuration initiale
-- après action du poids final de p
succOf p = ((cast (f p) :: weight) `action` initsBy a)
<> fmap Just (runKleisli (d a) p)
-- successeurs de l'ancienne configuration initiale
initsBy a = fmap Just $ runKleisli (getConfig aut [a]) ()
-- poids du mot vide dans l'automate initial
epsWeight = weightValue aut []
-- finalité (unitaire) de l'état ajouté
finality Nothing
= castInv (one :: weight)
-- finalité des "anciens" états, obtenus par action (à droite)
-- du poids étoilé du mot vide
finality (Just p) = actionR (f p) $ star epsWeight
La multiplication par un scalaire à gauche (resp. à droite) correspond à l’action à gauche (resp. à
droite) de ce scalaire sur la conﬁguration initiale (resp. sur les poids de sortie des états). L’intersec-
tion, déjà mentionnée précédemment, est réalisée à l’aide du produit tensoriel des types (c’est-à-dire
le produit cartésien, Pseudo-Code 40) dans le cas des automates non-déterministes comme dans celui
des automates à multiplicités. Enﬁn, le complémentaire d’un automate non-déterministe est obtenu
en appliquant l’algorithme classique de déterminisation (passage à l’automate des parties), en inver-
sant la ﬁnalité des états, puis en convertissant l’automate déterministe complet obtenu en automate
non-déterministe. Dans le cas des automates à multiplicités Booléennes, on utilisera des conversions
avec les automates non-déterministes.
Intéressons-nous alors plus précisément à la conversion entre une expression et un automate. Pour
une expression ﬁxée, quelle serait la signature d’une fonction de conversion entre cette expression et
un automate? Plus particulièrement, quel serait l’ensemble des états de l’automate produit?
Une façon de faire serait de choisir un type entier par exemple, puis de renuméroter à chaque étape
les états de l’automate obtenu. Une autre façon de faire est de remarquer que pour chaque opération
de la construction inductive, un foncteur est appliqué sur les états :
— le foncteur (appelé EndoSum dans la suite) associant à un type a le type Sum(a, a) (Pseudo-
Code 90) pour la somme,

150
Chapitre 7. Expressions rationnelles
— le foncteur Maybe pour l’étoile,
— le foncteur d’ensemble pour le complémentaire,
— le foncteur (appelé EndoProd dans la suite) associant à un type a le type Prod(a, a) (Pseudo-
Code 90) pour le produit.
Code Pseudo-Haskell. 90: Les foncteurs EndoSum et EndoProd
-- Automata.InductionAutomatonFromExp
data EndoSum a = EndoSum {runEndoSum :: Sum (a, a)}
deriving Eq
data EndoProd a = EndoProd {runEndoProd :: Prod (a, a)}
deriving Eq
instance FunctorGen EndoSum (->) (->) where
fmap f (EndoSum (Fst a)) = EndoSum $ Fst $ f a
fmap f (EndoSum (Snd a)) = EndoSum $ Snd $ f a
instance FunctorGen EndoProd (->) (->) where
fmap f (EndoProd (Product (a, b))) = EndoProd (Product (f a, f b))
En d’autres termes, les états d’un automate construit par la méthode inductive ont pour type un
élément des combinaisons possibles d’applications de ces foncteurs; si on interprète les foncteurs
comme des symboles, le type obtenu ressemble au monoïde libre engendré par ces symboles. En
effet, il s’agit d’une structure libre, et même d’un monoïde (objet) libre : une monade libre.
Remarque 35: Les monades libres
Dans la catégorie des types, la monade libre associée à un (endo-) foncteur F correspond à un
constructeur de types envoyant un type a sur un type isomorphe à ∑n=0Fn(a). Le fait que F
soit un foncteur est sufﬁsant pour produire une monade, comme le montre le code suivant.
-- Automata.InductionAutomatonFromExp
-- Type de données des monades libres
data FreeMonad f a = Free (f (FreeMonad f a)) | Pure a
-- Si f est un foncteur de la catégorie des types,
-- FreeMonad f l'est aussi
instance FunctorGen f (->) (->) => FunctorGen (FreeMonad f) (->) (->) where
fmap f (Pure x) = Pure $ f x
fmap f (Free g) = Free $ fmap (fmap f) g
-- Si f est un foncteur de la catégorie des types,
-- FreeMonad f est une monade de la catégorie des types.
instance (FunctorGen f (->) (->)) => MonadGen (FreeMonad f) (->) where
return = Pure
join (Pure a) = a
join (Free g) = Free $ fmap join g
Certaines monades connues sont des monades libres. Par exemple, en considérant le foncteur
constant déﬁni comme
data Const a = Const
on peut montrer que la monade Maybe est (isomorphe à) la monade libre associé à Const.
Une monade libre peut également être isomorphe à une structure de données. Par exemple,
on peut montrer que la monade libre associée au foncteur EndoProd déﬁni précédemment
correspond aux arbres binaires valués uniquement aux feuilles.
Cependant, ce n’est pas parce qu’une monade, une fois appliquée, produit un type isomorphe
à une application d’une monade libre qu’elle est elle-même libre. Par exemple, considérons le
foncteur (qui est même une monade)
data Writer s a =
Writer {runWriter :: (a, s)}
On peut remarquer que les types FreeMonad (Writer s) () et [s] sont isomorphes. Cepen-
dant, la monade liste n’est pas une monade libre a.
a. comme expliqué dans la documentation du module Control.Monad.Free du package Free.

7.2. Constructions d’automates de mots
151
Considérons alors le foncteur StateType déﬁni comme suit :
Code Pseudo-Haskell. 91: Le foncteur StateType
-- Automata.InductionAutomatonFromExp
data StateType a
= MaybeState (Maybe a)
| SetState (HashSet a)
| SumState (EndoSum a)
| ProdState (EndoProd a)
deriving Eq
instance FunctorGen StateType (->) (->) where
type FunctorConstraint StateType (->) (->) val = (Hashable val, Eq val)
fmap f (MaybeState m_a
) = MaybeState $ fmap f m_a
fmap f (SetState
as
) = SetState $ fmap f as
fmap f (SumState
(EndoSum (Fst a))) = SumState $ EndoSum $ Fst $ f a
fmap f (SumState
(EndoSum (Snd a))) = SumState $ EndoSum $ Snd $ f a
fmap f (ProdState
aa
) = ProdState $ fmap f aa
La transformation d’une expression en un automate dont les états sont construits à partir de la mo-
nade libre FreeMonad StateType ne nécessite plus que quelques fonctions auxiliaires (déﬁnies dans
le module Automata.InductionAutomatonFromExp) permettant de transformer les états des auto-
mates construits :
— packEndoAut (resp. packEndoProdAut) est une fonction permettant de convertir les états d’un
automate du type Sum(a, a) en EndoSum a (resp. Prod(a, a) en EndoProd a) en utilisant
l’isomorphisme naturel;
— packCombiFA est une fonction permettant d’injecter un automate dont les états sont de type f
(FreeMonad StateType a) (pour f un foncteur parmi Maybe, HashSet, EndoProd ou EndoSum)
dans un automate dont les états sont de type FreeMonad StateType a.
La construction inductive peut alors s’exprimer comme suit :
— l’automate associé au mot vide a pour conﬁguration initiale l’état Pure False, qui a un poids
de ﬁnalité unitaire; il n’y a pas de transitions;
Code Pseudo-Haskell. 92: La construction inductive associée au mot vide
inductiveGen Epsilon = Just $ packKleisli
(return $ Pure False)
(const $ const mempty)
finality
where
finality (Pure False) = one
finality _
= zero
— l’automate associé au vide n’a pas de transitions et tous ses états ont un poids de ﬁnalité nul;
Code Pseudo-Haskell. 93: La construction inductive associée au vide
inductiveGen Empty =
Just $ packKleisli mempty (const $ const mempty) (const zero)
— l’automate associé à un symbole a a (au moins) 2 états du type FreeMonad StateType Bool :
un état Pure False, initial et un état Pure True, seul état de ﬁnalité non-nulle, unitaire; il ne
possède qu’une unique transition, envoyant Pure False sur Pure True;
Code Pseudo-Haskell. 94: La construction inductive associée à un symbole
inductiveGen (Symbol a) = Just
$ packKleisli (return $ Pure False) delta_ finality
where
delta_ b (Pure False) | b == a = return $ Pure True
delta_ _ _
= mempty
finality (Pure True) = one @weight
finality _
= zero
— la concaténation s’effectue via les fonctions concatGen, packCombiFA et packEndoProdAut

152
Chapitre 7. Expressions rationnelles
Code Pseudo-Haskell. 95: La construction inductive associée à la concaténation
inductiveGen (Operator Concat (VCons e1 (VCons e2 VNil))) = liftA2
((packCombiFA . packEndoAut) .: concatGen)
(inductiveGen e1)
(inductiveGen e2)
— l’étoile s’effectue via les fonctions starGen et packCombiFA
Code Pseudo-Haskell. 96: La construction inductive associée à l’étoile
inductiveGen (Operator Star (VCons e VNil)) =
fmap (packCombiFA . starGen) $ inductiveGen e
— la somme s’effectue via les fonctions packCombiFA et packEndoAut
Code Pseudo-Haskell. 97: La construction inductive associée à la somme
inductiveGen (Operator Plus (VCons e1 (VCons e2 VNil))) = liftA2
sumGenInd
(inductiveGen e1)
(inductiveGen e2)
where
sumGenInd =
(packCombiFA . packEndoAut)
.: (
(reduceInitialSum (<>) . reduceFinalSum id id)
.: binaryTransformationBySum
)
— les opérateurs de multiplication par un scalaire x ne sont que des applications d’action sur les
conﬁgurations initiales ou les poids de ﬁnalité
Code Pseudo-Haskell. 98: La construction inductive associée à la multiplication par
un scalaire
inductiveGen (Operator (MultL x) (VCons e VNil)) = fmap change $ inductiveGen e
where change (Auto (Kleisli i) d f) = Auto (Kleisli $ action x . i) d f
inductiveGen (Operator (MultR x) (VCons e VNil)) = fmap change $ inductiveGen e
where change (Auto i d (Kleisli f)) = Auto i d (Kleisli $ flip actionR x . f)
— l’intersection s’effectue via les fonctions packCombiFA et packEndoProdAut
Code Pseudo-Haskell. 99: La construction inductive associée à l’intersection
inductiveGen (Operator Inter (VCons e1 (VCons e2 VNil))) = liftA2
intersectionGen
(inductiveGen e1)
(inductiveGen e2)
where
intersectionGen = (packCombiFA . packEndoProdAut)
.: binaryTransformationByProductWith (const $ const ())
— l’opération de complémentaire est une application directe des mécanismes explicités précé-
demment, et le cas des fonctions génériques est écarté (seul cas renvoyant Nothing).
Pour essayer cette construction, des exemples sont fournis dans les sources, implantés dans le mo-
dule HDRExample.WordExpInductive, contenant les fonctions suivantes :
— printRandomBoolAutomaton tire une expression rationnelle Booléenne au hasard, avec dix
opérateurs, sur les symboles a, b ou c; cette expression est ensuite convertie en un automate
non-déterministe, et s’afﬁche alors sa représentation Dot 1 ;
— printRandomAutomatonWithMult tire une expression rationnelle au hasard, avec dix opéra-
teurs parmi les opérateurs simples (i.e. somme, étoile et concaténation) et les multiplications
par un scalaire compris entre 1 et 10, sur les symboles a, b ou c; cette expression est ensuite
convertie en un automate à multiplicités entières 2, et s’afﬁche alors sa représentation Dot;
1. Format de description de graphes, dont la représentation graphique peut-être obtenu par Graphviz, ou en ligne comme
ici.
2. ici est utilisé un semianneau étoilé pour les entiers, déﬁni dans le module Expressions.WordExp.Expression

7.2. Constructions d’automates de mots
153
— printRandomAutomata tire une expression rationnelle au hasard, avec dix opérateurs parmi
les opérateurs simples (i.e. somme, étoile et concaténation) uniquement, sur les symboles a, b
ou c; cette expression est ensuite convertie en deux automates (non-déterministe et à multi-
plicités entières), et s’afﬁchent alors leurs représentations Dot;
— printAutomatonWithMult lit une expression rationnelle sur l’entrée standard, sur les sym-
boles a, b ou c utilisant la syntaxe suivante :
— + pour la somme;
— . pour la concaténation;
— * pour l’étoile;
— [x]: et :[x] pour les multiplications par le scalaire x;
cette expression est ensuite convertie en un automate à multiplicités entières, et s’afﬁche alors
sa représentation Dot;
— printBoolAutomaton lit une expression rationnelle sur l’entrée standard, sur les symboles a,
b ou c utilisant la syntaxe suivante :
— + pour la somme;
— . pour la concaténation;
— * pour l’étoile;
— ~ pour le complémentaire;
— & pour l’intersection;
cette expression est ensuite convertie en un automate non déterministe, et s’afﬁche alors sa
représentation Dot;
Pour l’utiliser, une fois la commande stack ghci src/HDRExample/WordExpInductive.hs lancée,
il sufﬁt de taper par exemple printAutomatonFrom puis (a+b+c)*.c.(a+b)&~(c*.(a+b+c)) pour
représenter l’automate inductif associé à l’expression (a + b + c)∗c(a + b) ∩¬(c∗(a + b + c)).
7.2.2
Automate de Kleisli des positions
La deuxième méthode décrite dans ce document est la méthode des positions. Comme dans le cas
classique, nous ne l’appliquerons qu’à des expressions avec des opérateurs simples (somme, conca-
ténation et étoile de Kleene) ou des multiplications par scalaire, les autres opérateurs n’étant pas
nécessairement compatibles avec la notion de position. Pour cela, montrons comment une géné-
ralisation simple et directe des formules connues [23, 29] permet de construire des automates de
Kleisli des positions pour (au moins) les monades d’ensembles (HashSet), de semimodules libres
(FreeSemimodule), d’expressions Booléennes (BoolExpr) ou d’expressions généralisées (GenExpr).
Comme dans le cas précédent de la construction inductive, remarquons que ces monades sont des
semimodules pour certains types de valeurs pouvant pondérer les expressions, les ensembles et les
semimodules libres ayant été traités précédemment. Trivialement,
— les expressions Booléennes forment un semimodule Booléen;
— plus généralement, les expressions généralisées sur un type a forment un semimodule sur a,
si a est un semianneau.
La construction classique de l’automate des positions est composée de trois composantes que nous
utiliserons également ici :
— la déﬁnition des fonctions de position;
— la linéarisation;
— l’utilisation des fonctions de position sur une expression linéarisée pour construire l’automate
des positions.
Les fonctions de position
Les fonctions de position sur une monade m, présentées dans la partie précédente pour le cas Booléen,
peuvent alors être déﬁnies de la façon suivante pour une expression e avec des poids de type p et
des symboles de types c :
— Null e est de type p, et est interprété comme le poids du mot vide;
— Pos e est l’ensemble des symboles apparaissant dans l’expression (i.e. HashSet c);
— First e est un conteneur monadique (i.e. de type m c) des symboles commençant les mots de
l’expression;
— Last e est une fonction associant à chaque symbole un poids de type p, correspondant au
poids de ﬁnalité du symbole;

154
Chapitre 7. Expressions rationnelles
— Follow e est une fonction associant à chaque symbole un conteneur monadique (i.e. de type
m c) des symboles pouvant lui succéder.
Ces cinq fonctions, calculées par de la fonction glushkovPosGen du Pseudo-Code 100, s’expriment
inductivement comme suit.
Code Pseudo-Haskell. 100: Le calcul inductif des fonctions de position
-- Expressions.WordExp.GlushkovFunctions
-- Renvoie un quintuplet des fonctions de Glushkov:
-- (Null, Pos, First, Last, Follow)
glushkovPosGen
:: ( Star weight
, Eq c
, Hashable c
, Semimodule weight (m c)
, MonadGen m (->)
)
=> Expression weight c
-> Maybe (weight, HashSet c, m c, c -> weight, c -> m c)
Le mot vide est un des cas de base :
— le poids du mot vide y est unitaire;
— il n’y a ni position ni position initiale;
— les positions y ont un poids de ﬁnalité nul;
— les positions n’y ont pas de successeur.
Code Pseudo-Haskell. 101: Le calcul inductif des fonctions de position : le mot vide
glushkovPosGen Epsilon = Just (one, mempty, mempty, const zero, const mempty)
Le cas du vide lui est relativement proche :
— le poids du mot vide y est nul;
— il n’y a ni position ni position initiale;
— les positions y ont un poids de ﬁnalité nul;
— les positions n’y ont pas de successeur.
Code Pseudo-Haskell. 102: Le calcul inductif des fonctions de position : le vide
glushkovPosGen Empty = Just (zero, mempty, mempty, const zero, const mempty)
Enﬁn, le cas des symboles est le dernier des cas de bases :
— le poids du mot vide y est nul;
— il n’y a qu’une position, qui est la seule initiale;
— le poids de ﬁnalité de cette position, unitaire, est le seul non-nul;
— les positions n’y ont pas de successeur.
Code Pseudo-Haskell. 103: Le calcul inductif des fonctions de position : les symboles
glushkovPosGen (Symbol c) = Just
( zero
, return c
, return c
, \x -> if x == c then one else zero
, const mempty
)
Le cas de la somme de deux expressions e1 et e2 est relativement simple :
— le poids du mot vide y correspond à la somme de ceux dans les deux expressions e1 et e2;
— les positions sont celles apparaissant dans e1 ou e2;
— les positions initiales sont la somme (monoïdale) des positions initiales 3 des deux expressions
e1 ou e2;
3. les conteneurs monadiques étant par hypothèse des semimodules, ils sont également des monoïdes

7.2. Constructions d’automates de mots
155
— le poids de ﬁnalité des symboles sont les sommes (dans le semianneau des poids) des poids
correspondant dans les deux expressions e1 et e2;
— les successeurs des positions s’obtiennent comme somme (des conteneurs monadiques) de
ceux de e1 et e2.
Code Pseudo-Haskell. 104: Le calcul inductif des fonctions de position : la somme
glushkovPosGen (Operator Plus (VCons e1 (VCons e2 VNil))) = do
(null1, pos1, first1, last1, fol1) <- glushkovPosGen e1
(null2, pos2, first2, last2, fol2) <- glushkovPosGen e2
return
( null1 `plus` null2
, pos1 <> pos2
, first1 <> first2
, \c -> last1 c `plus` last2 c
, \c -> fol1 c <> fol2 c
)
Le cas de l’étoile d’une expression e utilise le fait que les conteneurs monadiques considérés sont des
semimodules :
— le poids du mot vide y correspond à l’étoile de celui de e;
— les positions sont celles apparaissant dans e;
— les positions initiales sont celles de e, après avoir fait agir le poids étoilé du mot vide;
— le poids de ﬁnalité des symboles sont ceux de e, après avoir multiplié par le poids étoilé du
mot vide à droite;
— les successeurs des positions s’obtiennent comme somme (des conteneurs monadiques) de
ceux de e avec les positions initiales de e, après avoir fait agir le poids de ﬁnalité de la position
ambiante multiplié par le poids étoilé de l’étoile.
Code Pseudo-Haskell. 105: Le calcul inductif des fonctions de position : l’étoile
glushkovPosGen (Operator Star (VCons e1 VNil)) = do
(null1, pos1, first1, last1, fol1) <- glushkovPosGen e1
let starEpsWeight = star null1
return
( starEpsWeight
, pos1
, starEpsWeight `action` first1
, \c -> last1 c `times` starEpsWeight
, \c -> fol1 c <> ((last1 c `times` starEpsWeight) `action` first1)
)
Le cas de la concaténation de deux expressions e1 et e2 utilise également le fait que les conteneurs
monadiques considérés sont des semimodules :
— le poids du mot vide y correspond au produit de ceux de e1 et e2;
— les positions sont celles apparaissant dans e1 et e2;
— les positions initiales sont celles de e1, ainsi que celle de e2 après avoir fait agir le poids du
mot vide dans e1;
— le poids de ﬁnalité des symboles sont ceux de e2, ainsi que ceux de e1 après avoir multiplié
par le poids du mot vide de e2 à droite;
— les successeurs d’une position c s’obtiennent comme somme (des conteneurs monadiques) de
ceux de e1 avec ceux de e2, mais aussi comme les éléments initiaux de e2 après avoir fait agir
le poids ﬁnal de c dans e1.
Code Pseudo-Haskell. 106: Le calcul inductif des fonctions de position : la concaténation
glushkovPosGen (Operator Concat (VCons e1 (VCons e2 VNil))) = do
(null1, pos1, first1, last1, fol1) <- glushkovPosGen e1
(null2, pos2, first2, last2, fol2) <- glushkovPosGen e2
return
( null1 `times` null2
, pos1 <> pos2
, first1 <> (null1 `action` first2)
, \c -> last1 c `times` null2 `plus` last2 c
, \c -> fol1 c <> (last1 c `action` first2) <> fol2 c

156
Chapitre 7. Expressions rationnelles
)
Les cas des multiplications par scalaire ne sont que des actions à gauche ou à droite :
Code Pseudo-Haskell. 107: Le calcul inductif des fonctions de position : les multiplications
par des scalaires
glushkovPosGen (Operator (MultL x) (VCons e1 VNil)) = do
(null1, pos1, first1, last1, fol1) <- glushkovPosGen e1
return (x `times` null1, pos1, x `action` first1, last1, fol1)
glushkovPosGen (Operator (MultR x) (VCons e1 VNil)) = do
(null1, pos1, first1, last1, fol1) <- glushkovPosGen e1
return (null1 `times` x, pos1, first1, \c -> last1 c `times` x, fol1)
Les autres cas (complémentaire, intersection ou fonctions génériques) renvoient la valeur Nothing.
La linéarisation à l’aide de la monade State
Comme dans le cas des expressions classiques, il sufﬁt de parcourir l’expression et d’indicer d’une
façon croissante les symboles rencontrés. Pour cela, nous utiliserons le type simple suivant :
data Position index c = Pos index c
L’opération de linéarisation est une parfaite candidate à l’utilisation de la monade State (déﬁnie
dans le Pseudo-Code 30).
Remarque 36: La monade State du package mtl
Dans la suite, pour alléger le code, nous utiliserons l’implantation de la monade State du
module Control.Monad.State.Lazy du package mtl, et plus particulièrement les fonctions
suivantes :
— state :: (s -> (a, s)) -> State s a
équivalent du constructeur de valeurs
State de l’implantation précédente;
— evalState :: State s a -> s -> a permettant d’évaluer la fonction interne à l’aide
d’une valeur.
En effet, pour linéariser, il sufﬁt de déﬁnir une fonction prenant en paramètre l’expression à linéariser
et l’indice de départ, et renvoyant l’expression linéarisée, ainsi que le successeur de l’indice maximal
atteint, nécessaire pour linéariser le reste de l’expression lors des cas inductifs. L’utilisation de la
monade State permet de simpliﬁer la syntaxe en réalisant la transmission de l’indice ambiant d’une
façon naturelle.
Code Pseudo-Haskell. 108: La linéarisation à l’aide de la monade State
-- Expressions.WordExp.GlushkovFunctions
-- Fonction de linéarisation prenant en paramètre l'indice de départ
-- et l'expression à linéariser. La fonction construit tout d'abord une
-- fonction auxiliaire (monade State) via la fonction linearize',
-- puis l'évalue à l'aide de l'indice.
linearizeFrom
:: (Enum index) => index -> Expression a c -> Expression a (Position index c)
linearizeFrom start expr = evalState (linearize' expr) start
where
-- Construit une fonction de linéarisation d'expressions
-- à l'aide de la monade State.
linearize'
:: (Enum index)
=> Expression a c
-> State index (Expression a (Position index c))
-- Pour le mot vide et l'expression vide,
-- l'expression et l'indice sont inchangés.

7.2. Constructions d’automates de mots
157
linearize' Epsilon
= return Epsilon
linearize' Empty
= return Empty
-- Pour le cas d'un symbole, on renvoie le couple composé
-- du symbole indicé par l'indice courant, ainsi que le
-- successeur de cet indice (qui le remplace en tant
--
qu'indice courant)
linearize' (Symbol c
) = state $ \n -> (Symbol (Pos n c), succ n)
-- Dans le cas d'un opérateur, il suffit de linéariser le vecteur
-- de ces opérandes à l'aide de la fonction linearizeOnVect
-- définie ci-après
linearize' (Operator op es) = fmap (Operator op) (linearizeOnVect es)
-- Construit une fonction de linéarisation de vecteur
-- d'expressions à l'aide de la monade State.
linearizeOnVect
:: (Enum index)
=> Vector n (Expression a c)
-> State index (Vector n (Expression a (Position index c)))
-- Si le vecteur est vide, pas de modification
linearizeOnVect VNil = return VNil
-- Sinon, on linéarise la première expression (ce qui modifie
-- l'indice courant), et on recommence avec le reste du vecteur
linearizeOnVect (VCons e es) =
liftA2 VCons (linearize' e) (linearizeOnVect es)
-- Fonction utilitaire pour linéariser une expression à partir de 1
linearize :: (Enum index) => Expression a c -> Expression a (Position index c)
linearize = linearizeFrom (toEnum 1)
La construction de l’automate des positions
Une fois une expression linéarisée, la construction de l’automate (monadique) des positions se fait
de la façon (classique) suivante, à l’aide des fonctions de positions :
— les états sont obtenus par le calcul de Pos, en y ajoutant un état initial supplémentaire;
— les poids ﬁnaux des états sont donnés par le calcul de Last et de Null;
— les successeurs sont déﬁnis par le calcul de Follow et First.
Code Pseudo-Haskell. 109: La construction de l’automate des positions
-- Automata.KleisliAutomata
-- type des états de l'automate des positions
data GlushkovState index c = Init | P (Position index c)
-- Construit l'automate des positions de l'expression e,
-- et renvoie également la liste des symboles désindicés
-- apparaissant dans l'expression de départ
glushkovWithPos
:: (Eq c
, Hashable c
, Star weight
, Semimodule weight (m (Position Word c))
, MonadGen m (->)
, Castable (m weight') weight)
=> Expression weight c
-> Maybe (Automaton (KleisliCat m (->)) () c (GlushkovState Word c) weight', [c])
glushkovWithPos e = do
-- linéarisation de e
let e' = linearize e
-- calcul des fonctions de positions
(null_, pos_, first_, last_, follow_) <- glushkovPosGen e'
let
-- fonction permettant de filtrer les positions
--
d'un conteneur monadique
-- égales à un symbole donné une fois désindicées
pos_of a =
bind (\c'@(Pos _ c) -> if a /= c then mempty else return c')
-- calcul de la fonction de transition
-- à partir de First et Follow
delta_ p Init
= fmap P $ pos_of p first_
delta_ q (P p) = fmap P $ pos_of q $ follow_ p

158
Chapitre 7. Expressions rationnelles
-- poids de finalité des états, à partir de
-- Null et Last
final_ Init
= null_
final_ (P p) = last_ p
-- alphabet des symboles présents
sigma = Set.toList $ Set.map (\(GF.Pos _ c) -> c) pos_
in return (packKleisli (M.return Init) delta_ final_, sigma)
Pour essayer cette construction, des exemples sont fournis dans les sources, dans le module Haskell
HDRExample.WordExpGlushkov contenant les fonctions suivantes :
— printRandomBoolAutomaton, printRandomAutomatonWithMult, printAutomatonWithMult et
printBoolAutomaton ont le même rôle que les fonctions homonymes du module précédent
HDRExample.WordExpInductive;
— les fonctions performValidityTestWithMult et performRandomValidityTestWithMult cons-
truisent trois automates (un automate à poids par la méthode inductive et deux automates des
positions, à multiplicités et alternant généralisé) depuis une expression (tirée aléatoirement
le cas échéant), puis génèrent des mots aléatoires de longueur comprises entre 0 et 10 et en
nombre ﬁxé lors de l’appel pour comparer les résultats de calcul des poids,
— la fonction performValidityTestWithMultTrace réalise un test équivalent sur deux auto-
mates des positions (à multiplicités et alternant généralisé) sur des mots aléatoires sont le
nombre est ﬁxé à l’appel en utilisant une construction mémoïsée et traçant les constructions
des deux automates au fur et à mesure, permettant de ne construire que la partie utile (c’est-
à-dire utilisée) de l’automate.
Pour utiliser ce module, une fois la commande stack ghci src/HDRExample/WordExpGlushkov.hs
lancée, il sufﬁt de taper par exemple performValidityTestWithMultTrace 250 puis l’expression
à multiplicités ([5]:a*+b*:[3]).c*:[2].(a+b+c)* pour tester la validité des constructions depuis
l’expression (5a∗+ b∗3) · c∗2 · (a + b + c)∗sur 250 mots tirés aléatoirement.
7.2.3
Dérivation
La dernière construction que nous allons aborder dans cette section est la méthode par dérivation,
qui est sans doute la plus ﬂexible. Pour cela, nous allons nous appuyer sur les méthodes classiques de
dérivation (de Brzozowski [16] et d’Antimirov [2]), mais également sur les extensions de la dérivation
classique aux expressions étendues [22] ainsi que sur la notion de support de dérivation [19]. De plus,
nous allons ne considérer que des semianneaux étoilés pour la pondération.
L’idée est la suivante : si la dérivation partielle d’Antimirov étend la dérivation de Brzozowski en
utilisant des ensembles, on peut essayer de généraliser en utilisant d’autres conteneurs monadiques
ayant de “bonnes propriétés” (pas nécessairement les mêmes pour tous les conteneurs d’ailleurs).
Parmi ces propriétés, on pourra remarquer le fait de pouvoir “contracter” un conteneur monadique
d’expressions en une expression (c’est le rôle principal des supports de dérivation de [19]) : par
exemple, un ensemble d’expressions peut être interprété, lors de la dérivation partielle, comme une
somme d’expressions. Cette transformation va nous permettre d’augmenter le nombre des poten-
tiels opérateurs utilisables dans les expressions tout en conservant la possibilité de construire un
automate.
Nous allons alors nous intéresser à cinq monades pour lesquelles nous allons pouvoir dériver les
expressions précédentes sous leur forme non-restreinte, y compris pour les opérateurs de fonctions
génériques; et comme suite logique, nous en déduirons la construction d’automate associée, qui est
la même que dans les dérivations classiques : les états sont des expressions, les transitions obtenues
par dérivation, et la ﬁnalité par le poids du mot vide.
Remarquons que la ﬁnitude de ces automates n’est pas garantie; cependant, grâce à l’évaluation
paresseuse, cela ne posera pas de problèmes et seule la partie utile de l’automate sera construite.
Ces cinq monades seront les suivantes :
— la monade Identité pour la dérivation de Brzozowski;
— la monade des ensembles pour la dérivation d’Antimirov;
— la monade des semi-modules libres pour la dérivation partielle pondérée (en utilisant les for-
mules de [57]);

7.2. Constructions d’automates de mots
159
— la monade des expressions Booléennes pour construire des automates alternants;
— la monade des expressions généralisées pour construire des automates alternants généralisés.
Les propriétés sufﬁsantes partagées par ces conteneurs contiennent les suivantes :
— une fois appliqués, ces conteneurs sont des éléments d’un monoïde;
— une fois appliqués, ces conteneurs sont des semimodules pour le semianneau étoilé des poids,
mais aussi sur celui des expressions 4.
Ainsi, la dérivation monadique pour les atomes, pour les expressions à opérateurs simples ou pour
les multiplications par scalaire se décrit comme suit. On reconnaîtra les formules classiques [2, 57],
où le calcul inductif du poids du mot vide est nécessaire.
Code Pseudo-Haskell. 110: La dérivation monadique
-- Expressions.WordExp.Expression
-- Calcul du poids du mot vide dans l'expression.
nullable :: Star a => Expression a c -> a
nullable Epsilon
= one
nullable Empty
= zero
nullable (Symbol _) = zero
nullable (Operator (Function _ n info) es) =
convertToVectMultiFun (getFun n info) $ fmap nullable es
nullable (Operator Concat (VCons e1 (VCons e2 VNil))) =
nullable e1 `times` nullable e2
nullable (Operator Star (VCons e VNil)) = star $ nullable e
nullable (Operator Plus (VCons e1 (VCons e2 VNil))) =
nullable e1 `plus` nullable e2
nullable (Operator (MultL x) (VCons e VNil)) = x `times` nullable e
nullable (Operator (MultR x) (VCons e VNil)) = nullable e `times` x
nullable (Operator Not
(VCons e VNil)) = not $ nullable e
nullable (Operator Inter (VCons e1 (VCons e2 VNil))) =
nullable e1 && nullable e2
-- Expressions.WordExp.Derivation
-- Dérivation monadique d'une expression par un symbole
derive :: c -> Expression a c -> m (Expression a c)
-- la dérivation du vide ou du mot vide
-- renvoie l'élément neutre du monoïde
-- quel que soit le symbole
derive _ Epsilon = mempty
derive _ Empty
= mempty
-- la dérivation d'un symbole renvoie
-- la promotion monadique (return) du
-- mot vide lorsqu'il y a correspondance,
-- l'élément neutre du monoïde sinon
derive c (Symbol c') | c == c'
= return epsilon
| otherwise = mempty
-- la dérivation d'une somme est la somme
-- monoïdale des dérivations
derive c (Operator Plus (VCons e1 (VCons e2 VNil))) =
derive c e1 <> derive c e2
-- la dérivation d'une concaténation d'expressions e1 et e2
-- est la somme monoïdale entre
-- * la dérivation de e1 après action droite de e2
-- * la dérivation de e2 après action gauche du poids
--
du mot vide dans e1
derive c (Operator Concat (VCons e1 (VCons e2 VNil))) =
(derive c e1 `actionR` e2) <> (nullable e1 `action` derive c e2)
-- la dérivation d'une étoile d'une expression, notée e*
-- est la dérivation de e, sur laquelle on fait agir
-- e* à droite, puis le poids étoilé du mot vide dans e
-- à gauche
derive c estar@(Operator Star (VCons e VNil)) =
4. à quelques isomorphismes près

160
Chapitre 7. Expressions rationnelles
star (nullable e) `action` (derive c e `actionR` estar)
-- la dérivation par un scalaire est l'action de ce scalaire
-- sur la dérivation
derive c (Operator (MultL x) (VCons e VNil)) = x `action` derive c e
derive c (Operator (MultR x) (VCons e VNil)) = derive c e `actionR` x
Les opérateurs restants, ceux d’intersection et de complémentaire Booléens, ainsi que les fonctions
génériques, peuvent être implantés d’au moins deux façons différentes :
— le conteneur monadique peut supporter une opération encodant une ou la totalité de ces opé-
rations;
— dans le cas contraire, on peut convertir le conteneur en une expression, puis dériver cette
dernière.
Ainsi, on peut déﬁnir une classe de types pour modéliser cette propriété, avec des opérations déﬁ-
nies par défaut dans le cas où l’opération ne peut être implantée autrement que par conversion du
conteneur en expression :
Code Pseudo-Haskell. 111: La dérivation monadique : opérateurs étendus
-- Expressions.WordExp.Derivation
-- Définition d'une conversion d'un conteneur monadique
-- en expression
class Convertible a c m where
convertTo :: m (Expression a c) -> Expression a c
-- Définition des transormations associées aux opérateurs
-- étendus pour la dérivation monadique d'une expression
-- de type Expression a c sur la monade m
class Derivable a c m where
-- complémentaire d'un conteneur monadique
negation :: m (Expression Bool c) ->
m (Expression Bool c)
default negation ::
Convertible a c m =>
m (Expression a c) ->
m (Expression a c)
negation = return . neg . convertTo
-- intersection de deux supports monadiques
intersection ::
m (Expression Bool c)
-> m (Expression Bool c)
-> m (Expression Bool c)
default intersection ::
(Convertible a c m) =>
m (Expression a c) ->
m (Expression a c) ->
m (Expression a c)
intersection es1 es2 = return $ inter' (convertTo es1) (convertTo es2)
-- Application d'une fonction générique n-aire
-- sur un vecteur de n expressions
functionExpr ::
String
-> Natural n
-> InfoOp n a
-> Vector n (m (Expression a c)) -> m (Expression a c)
default functionExpr ::
(Convertible a c m) =>
String ->
Natural n ->
InfoOp n a ->
Vector n (m (Expression a c)) ->
m (Expression a c)
functionExpr s n op = return . fun s n op . fmap convertTo

7.2. Constructions d’automates de mots
161
Certaines monades peuvent “améliorer” le traitement de ces opérations en intégrant des transforma-
tions associées; par exemple :
— la monade BoolExpr peut intégrer les opérateurs d’intersection et de complémentaire en as-
sociant leur équivalent au sein des expressions Booléennes, (<~>) et (<&&>)
— la monade GenExpr peut intégrer les opérateurs d’intersection, de complémentaire et de fonc-
tions génériques en utilisant le constructeur packFunction;
— les autres monades (ensemble, semimodule libre et identité) utilisent les formules par défaut
déﬁnies précédemment.
Une fois ces opérations déﬁnies, la dérivation d’une expression de type Expression a c sur une
monade m est complétée par les cas suivants :
Code Pseudo-Haskell. 112: La dérivation monadique : opérateurs étendus
-- Expressions.WordExp.Derivation
-- la dérivation du complémentaire d'une expression
-- est le complémentaire de la dérivation
derive c (Operator Not (VCons e VNil)) = negation $ derive c e
-- la dérivation de l'intersection de deux expressions
-- est l'intersection des dérivations
derive c (Operator Inter (VCons e1 (VCons e2 VNil))) =
intersection (derive c e1) $ derive c e2
-- la dérivation d'une fonction générique n-aire
-- appliquée sur un vecteur de n expressions
-- est l'application (monadique) de cette fonction
-- sur le vecteur des dérivations
derive c (Operator (Function s n info) es) =
functionExpr s n info $ fmap (derive c) es
L’extension de la dérivation par un symbole à la dérivation par rapport à un mot, c’est-à-dire un
élément du monoïde libre, se fait d’une façon similaire à l’extension de la fonction de transition d’un
automate d’un symbole à un mot (Pseudo-code 12) : grâce à une adjonction fonctorielle.
Code Pseudo-Haskell. 113: La dérivation monadique : extension aux mots
-- Expressions.WordExp.Derivation
deriveByWord :: [c] -> Expression a c -> m (Expression a c)
deriveByWord = runKleisli . promoteFun (Kleisli . derive)
La construction de l’automate associée à la dérivation peut alors se décrire en appliquant la méthode
classique.
Code Pseudo-Haskell. 114: La dérivation monadique : construction de l’automate
-- Automata.KleisliAutomata
-- Construction de l'automate associé à une dérivation, dont les états
-- sont des expressions :
-- * la configuration initiale correspond à l'expression de départ
-- * le morphisme de transition est la dérivation
-- * la pondération d'un état correspond au poids du mot vide dans
--
celui-ci.
derivationAutomaton ::
Expression a c ->
Automaton (KleisliCat m (->)) () c (Expression a c) a'
derivationAutomaton e = packKleisli (return e) derive nullable
Pour essayer cette construction, des exemples sont fournis dans les sources dans le module
HDRExample.WordExpDerivation, contenant les fonctions suivantes :

162
Chapitre 7. Expressions rationnelles
— printRandomBoolAutomaton, printRandomAutomatonWithMult, printAutomatonWithMult et
printBoolAutomaton ont le même rôle que les fonctions homonymes du module précédent
HDRExample.WordExpInductive;
— les fonctions performValidityTestWithMult et performRandomValidityTestWithMult cons-
truisent trois automates (un automate à poids par la méthode inductive, un automate à poids
obtenu par dérivation et un automates des positions alternant généralisé) depuis une expres-
sion (tirée aléatoirement le cas échéant), puis génèrent des mots aléatoires de longueur com-
prises entre 0 et 10 et en nombre ﬁxé lors de l’appel pour comparer les résultats de calcul des
poids,
— la fonction performValidityTestWithMultTrace réalise un test équivalent sur trois auto-
mates (deux automates, un à multiplicités et l’autre alternant généralisé, construits par dé-
rivation, et un automate des positions alternant généralisé) en utilisant une construction mé-
moïsée et traçant les constructions des deux automates au fur et à mesure, permettant de ne
construire que la partie utile (c’est-à-dire utilisée) de l’automate.
Pour l’utiliser, une fois la commande stack ghci src/HDRExample/WordExpDerivation.hs lancée,
il sufﬁt de taper par exemple performValidityTestWithMultTrace 250 puis l’expression à multipli-
cités ([5]:a*+b*:[3]).c*:[2].(a+b+c)* pour tester la validité des constructions depuis l’expres-
sion 5a∗+ b∗3 · c∗2 · (a + b + c)∗en comparant les poids de 250 mots tirés aléatoirement.
7.3
Expressions enrichies
Le cas des expressions rationnelles de mots peut servir de modèle à un type de données permettant
de généraliser la représentation au niveau des catégories enrichies; cette méthode nous permettra de
fournir un type polymorphe permettant de factoriser les expressions de mots et d’arbres, ainsi que
différentes méthodes de construction d’automates.
Pour cela, nous allons tout d’abord montrer comment déﬁnir des expressions simples (plus res-
treintes que dans la section précédente, c’est-à-dire avec moins d’opérateurs) et comment factoriser
certaines informations sur ce type.
Nous montrerons ensuite comment transformer une telle expression en un automate enrichi selon
trois méthodes : par la méthode des positions, par dérivation et par induction. Chacune de ces mé-
thodes permettra de calculer un automate enrichi de Kleisli (en toute généralité) aﬁn de conserver la
démarche précédente d’uniﬁcation de construction.
7.3.1
Déﬁnition et implantation générale
Pour qu’une expression puisse représenter le mécanisme décrit par un automate enrichi, elle doit
pouvoir être paramétrée par ce qui caractérise la base d’une catégorie enrichie : un produit tensoriel.
En effet, il faut pouvoir exprimer à travers les paramètres du type de données la différence entre une
expression de mots et une expression d’arbres.
Ainsi, nous utiliserons les produits tensoriels pour décrire les atomes des expressions précédemment
liés aux symboles. Cependant, un produit tensoriel étant un bifoncteur, il doit s’exprimer à partir
d’un couple d’objets (au niveau des catégories). Si le premier est l’objet alphabet, le second sera
alors, comme utilisé dans les automates enrichis, l’objet initial; on pourra ainsi l’utiliser comme une
généralisation des variables des expressions d’arbres classiques de la littérature.
Mais plus que cela, cet objet initial va permettre également de déﬁnir les opérations de concaténation
et d’itération, à partir de la substitution de variables.
Le type des expressions enrichies est ainsi paramétré par trois types :
— un type pour les symboles;
— un type pour les variables;
— un produit tensoriel.

7.3. Expressions enrichies
163
Code Pseudo-Haskell. 115: Les expressions enrichies
-- Expressions.EnrichedExp.EnrichedExp
data Expression tensor var symbols
= Empty
| Var var
| Tensor (tensor (symbols, var))
| Sum (Expression tensor var symbols) (Expression tensor var symbols)
| Sub var (Expression tensor var symbols) (Expression tensor var symbols)
| Star var (Expression tensor var symbols)
Ce type peut être spécialisé pour retrouver les expressions classiques.
Code Pseudo-Haskell. 116: Les expressions de mots et d’arbres depuis les expressions en-
richies
-- Expressions.EnrichedExp.WordExp
-- Les expressions de mots sont obtenus en utilisant le produit
-- tensoriel de la catégories des types (le produit cartésien)
-- et en utilisant une unique variable, ()
type WordExp symbols = Expression Prod () symbols
-- Expressions.EnrichedExp.TreeExp
-- Les expressions d'arbres sont obtenus en utilisant le produit
-- tensoriel de la catégories des types gradués
type TreeExp symbols var = Expression TensorProd var symbols
Les variables ont, comme nous venons de l’annoncer, un rôle à jouer au niveau de l’objet initial des
automates. Autrement dit, les variables vont apparaître “au début” de la lecture. Ainsi, en considé-
rant une combinaison de deux expressions, la sémantique de l’opération de substitution ne sera pas
exactement la sémantique usuelle : une expression de la forme E1 ·v E2 réalisera la substitution de la
variable v dans les “parcours” de E2 par un “parcours” de E1. Par exemple, en termes de représen-
tation, on pourrait imaginer les arbres représentés orientés horizontalement, les feuilles à gauche et
les racines à droite.
Remarque 37: Substitution des expressions enrichies et arbres
Remarquons que “la direction” de l’opération de concaténation pour les expressions de mots
et celle de substitution pour les expressions d’arbres ne sont pas les mêmes. Il sufﬁt alors de
considérer une fonction de construction alternative pour rétablir l’ordre classique des expres-
sions d’arbres par exemple.
-- Expressions.EnrichedExp.TreeExp
concatVar
:: var -> TreeExp symbols var -> TreeExp symbols var -> TreeExp symbols var
concatVar v = flip $ Sub v
where
-- flip est une fonction de base prédéfinie en Haskell
flip f x y = f y x
Autre différence, ce ne sont pas les symboles nullaires qui paramètrent le produit de substi-
tution ou l’étoile. Le pouvoir de représentation n’est pas changé, puisqu’il sufﬁt de remplacer
un symbole nullaire par une variable, voire d’inclure ces symboles nullaires dans le type des
variables en utilisant un type somme par exemple.
Le module Expressions.EnrichedExp.EnrichedExp contient également la déﬁnition de plusieurs
fonctions outils permettant de manipuler les expressions en toute généralité, basées sur des proprié-
tés partagées quel que soit le produit tensoriel considéré, telles que les réductions ACI (Associa-
tivité — Commutativité — Idempotence) de la somme (reduceACISum), le calcul des multiplicités
de la décomposition d’une expression somme (getWeightedSum) ou le renversé d’une expression
(reverseExp). C’est aussi le cas des fonctions qui ne tiennent pas compte des atomes symboliques
(c’est-à-dire les atomes utilisant les produits tensoriels).

164
Chapitre 7. Expressions rationnelles
Parmi ces fonctions, les généralisations de la fonction déterminant le poids du mot vide dans une ex-
pression (utilisée dans les méthodes de construction par position et par dérivation). Même si nous ne
l’avons pas encore explicité, le mot vide est bien présent en tant que sous-expression des expressions
enrichies spécialisées aux mots : il s’agit de la variable (). La fonction nullable (Pseudo-Code 110)
peut être étendue comme suit, où les seules différences proviennent de la modiﬁcation de la conca-
ténation en substitution, nécessitant de promouvoir cette substitution au niveau monadique, via la
fonction (=«).
Code Pseudo-Haskell. 117: Les calculs de nullabilité pour les expressions enrichies
-- Expressions.EnrichedExp.EnrichedExp
-- Poids d'une variable lors d'un "parcours" dans l'expression
-- (en fonction de l'interprétation du produit tensoriel)
nullableVar ::
(Eq var, Star weight) =>
var ->
Expression tensor var symbols ->
weight
nullableVar _ (Tensor _) = zero
nullableVar _ Empty
= zero
nullableVar v (Var v') | v == v'
= one
| otherwise = zero
nullableVar v (Sum e1 e2) = nullableVar v e1 `plus` nullableVar v e2
nullableVar v (Sub v' e1 e2)
| v == v' = nullableVar v e1 `times` nullableVar v e2
| otherwise = nullableVar v e2 `plus` (nullableVar v e1 `times` nullableVar v' e2)
nullableVar v (Star v' e)
| v == v'
= star $ nullableVar v e
| otherwise = nullableVar v e `times` star (nullableVar v e)
-- Calcul d'un conteneur monadique contenant les variables
-- apparaissant lors d'un parcours de l'expression
-- (en fonction de l'interprétation du produit tensoriel)
variables
:: ( Eq var
, MonadGen m (->)
, Monoid (m var)
, Star weight
, Semimodule weight (m var)
)
=> Expression tensor var symbols
-> m var
variables Empty
= mempty
variables (Var
v
) = return v
variables (Tensor _
) = mempty
variables (Sum e1 e2
) = variables e1 <> variables e2
variables (Sub v e1 e2) = substIfEq =<< variables e2
where
substIfEq v' | v == v'
= variables e1
| otherwise = return v'
variables (Star v e) =
(M.return v <> variables e) `actionR` (star $ nullableVar v e)
D’autres fonctions nécessitent de considérer les spéciﬁcités des produits tensoriels pour être calculés
(par exemple via la déﬁnition de classe de types). C’est le cas de la génération aléatoire d’expressions
(randomExpression), mais aussi des factorisations/généralisations des fonctions de position Last
(pour les mots) et Racine ou de la linéarisation 5.
Code Pseudo-Haskell.118: Poids des symboles de ﬁn de parcours d’une expression enrichie
-- Expressions.EnrichedExp.EnrichedExp
-- Classe de types permettant d'abstraire l'extraction (monadique)
-- de symbole d'un produit tensoriel
class ExtractFinal tensor where
5. utilisant la monade State (voir Remarque 36)

7.3. Expressions enrichies
165
extractFinal :: tensor(symbols, var) -> m symbols
extractFinalWeight ::
(Eq symbols, Semiring weight) =>
tensor(symbols, var) -> symbols -> weight
-- Calcul d'un conteneur monadique des symboles "terminant un parcours"
-- de l'expression (en fonction de l'interprétation du produit tensoriel)
final
::( Eq var
, Eq symbols
, Monoid (m symbols)
, Semimodule weight (m symbols)
, Star weight
)
=> Expression tensor var symbols
-> m symbols
final Empty
= mempty
final (Var
_ ) = mempty
final (Tensor t ) = extractFinal t
final (Sum e1 e2) = final e1 <> final e2
final (Sub v e1 e2) =
(final e1 `actionR` (nullableVar v e2)) <> final
e2
final (Star v e) = final e `actionR` star (nullableVar v e)
-- Calcul du "poids final" d'un symbole
-- de l'expression (en fonction de l'interprétation du produit tensoriel)
finalWeight
:: (Eq var, Eq symbols, ExtractFinal tensor, Star weight)
=> symbols
-> Expression tensor var symbols
-> weight
finalWeight _ Empty
= zero
finalWeight _ (Var
_ ) = zero
finalWeight f (Tensor t ) = extractFinalWeight t f
finalWeight s (Sum e1 e2) = finalWeight s e1 `plus` finalWeight s e2
finalWeight s (Sub v e1 e2) =
(finalWeight s e1 `times` nullableVar v e2) `plus` finalWeight s e2
finalWeight s (Star v e) = finalWeight s e `times` star (nullableVar v e)
-- Expressions.EnrichedExp.WordExp
instance ExtractFinal Prod where
extractFinal (Product (f, _)) = return f
extractFinalWeight (Product (f, _)) g | f == g
= one
| otherwise = zero
-- Expressions.EnrichedExp.TreeExp
instance ExtractFinal TensorProd where
extractFinal (TensorProd f _) = return $ fromGrad f
extractFinalWeight (TensorProd f _) g | fromGrad f == g = one
| otherwise
= zero
Code Pseudo-Haskell. 119: Linéarisation d’une expression enrichie
-- Expressions.EnrichedExp.EnrichedExp
-- Classe de type permettant d'abstraire la linéarisation d'un produit tensoriel
class TensorLin tensor where
tensorLin ::
Enum index =>
tensor (symbols, var) ->
State index (tensor (Position index symbols, var))
-- Linéarisation d'une expression, pour un produit
-- tensoriel "linéarisable".
linearize

166
Chapitre 7. Expressions rationnelles
:: (Enum index, TensorLin tensor)
=> index
-> Expression tensor var symbols
-> Expression tensor var (Position index symbols)
linearize start expr = evalState (linearize' expr) start
where
linearize'
:: (Enum index, TensorLin tensor)
=> Expression tensor var symbols
-> State index (Expression tensor var (Position index symbols))
linearize' Empty
= return Empty
linearize' (Var
v ) = return $ Var v
linearize' (Tensor t ) = fmap Tensor $ tensorLin t
linearize' (Sum e1 e2
) = liftA2 Sum (linearize' e1) (linearize' e2)
linearize' (Sub v e1 e2) = liftA2 (Sub v) (linearize' e1) (linearize' e2)
linearize' (Star v e) = fmap Star v $ linearize' e
-- Expressions.EnrichedExp.WordExp
instance TensorLin Prod where
tensorLin (Product (f, v)) =
state $ \n -> (Product (Pos n f, v), succ n)
-- Expressions.EnrichedExp.TreeExp
instance TensorLin TensorProd where
tensorLin (TensorProd f vs) =
state $ \n -> (TensorProd (GradPos n f) vs, succ n)
Remarquons qu’ici tous les symboles sont indicés, y compris les symboles nullaires dans le cas des
expressions d’arbres. Seules les variables ne sont pas indicées.
7.3.2
Constructions d’automates enrichis
Les fonctions précédentes décrites ne sont pas sufﬁsantes pour construire des automates enrichis
depuis une expression enrichie. Ainsi, en fonction des méthodes de construction, nous allons ajouter
d’autres outils aﬁn de ﬁnaliser le calcul de l’automate associé.
L’automate des positions
L’automate des positions que nous allons décrire s’inspire de la version de Laugerotte et al. [54] pour
les arbres, permettant de construire un automate Top-Down en calculant pour chacune des posi-
tions un vecteur de prédécesseurs (c’est-à-dire un vecteur de successeurs si l’expression est lue de
droite à gauche) 6. Si la version proposée n’est pas factorisée pour les arbres et les mots, la proximité
syntaxique des fonctions mises en œuvre la laisse entrevoir 7.
L’idée est la suivante : nous allons construire un automate enrichi
— où la conﬁguration initiale est obtenue à partir des variables,
— où le poids ﬁnal est obtenu par les fonctions final et variables précédentes,
— où les transitions sont obtenues à partir de la fonction de calculs des prédécesseurs (variables
ou symboles).
Ainsi, avant de décrire la construction de l’automate, commençons par expliciter le calcul des prédé-
cesseurs.
Si un prédécesseur d’un symbole est un atome (un symbole ou l’unique variable ()) pour les mots,
un prédécesseur d’un symbole n-aire dans une expression d’arbres est un vecteur de longueur n
d’atomes. De plus, pour conserver la généricité de la construction, la fonction renverra un conteneur
monadique de ces combinaisons d’atomes.
Ainsi,
6. la
version
classique,
utilisant
la
fonction
follow,
est
implantée
pour
les
mots
dans
le
module
Expressions.EnrichedExp.WordExp, en conservant l’extension aux monades
7. Cette factorisation sera discutée dans les perspectives.

7.3. Expressions enrichies
167
Code Pseudo-Haskell. 120: Signatures des fonctions predec
-- Expressions.EnrichedExp.WordExp
-- Calcul d'un conteneur monadique des prédécesseurs d'un
-- symbole d'une expression de mots
predec
:: ( Semigroup (m (Either () symbols))
, Eq symbols
, MonadGen m (->)
, Semigroup (m ())
, Star weight
, Semimodule weight (m symbols)
, Semimodule weight (m ())
, Semimodule weight (m (Either () symbols))
)
=> symbols
-> WordExp symbols
-> m (Either () symbols)
-- Expressions.EnrichedExp.TreeExp
-- Calcul d'un conteneur monadique des prédécesseurs d'un
-- symbole n-aire d'une expression d'arbres
predec
:: ( Graded symbols
, Singleton n
, Eq var
, Eq symbols
, MonadGen m (->)
, Monoid (m (Vector n (Either var symbols)))
, Semigroup (m var)
, Semimodule weight (m symbols)
, Semimodule weight (m var)
, Semimodule weight (m (Either var symbols))
, Star weight
)
=> Graduation symbols n
-> TreeExp symbols var
-> m (Vector n (Either var symbols))
Le cas du vide, des variables et de la somme sont classiques, identiques et triviaux dans chacun des
cas :
Code Pseudo-Haskell. 121: Fonctions predec : cas triviaux
-- Expressions.EnrichedExp.WordExp
-- Expressions.EnrichedExp.TreeExp
predec _ Empty
= mempty
predec _ (Var _) = mempty
predec g (Sum e1 e2
) = predec g e1 <> predec g e2
Le cas de la substitution et de l’itération est un peu plus complexe. Pour une expression E1 ·v E2, les
prédécesseurs d’un symbole c sont les prédécesseurs de c dans E1 et les prédécesseurs de c dans E2,
conteneur dans lequel on substitue les occurrences de la variable v par les éléments ﬁnaux (symboles
et variables) de E1. L’opération de substitution d’occurrences est légèrement différent entre les mots
et les arbres, de par la présence d’une “couche” de vecteurs supplémentaires. Le cas de l’itération est
similaire.
Code Pseudo-Haskell. 122: Fonctions predec : itération et substitution
-- Expressions.EnrichedExp.WordExp
-- Substitution de la variable () par une combinaison monadique de
-- symboles et variables dans une combinaison monadique
substitute
:: (MonadGen m (->))

168
Chapitre 7. Expressions rationnelles
=> ()
-> m (Either () symbols)
-> m (Either () symbols)
-> m (Either () symbols)
substitute _ toAdd = (=<<) aux
where
aux (Left _) = toAdd
aux other
= return other
-- Expressions.EnrichedExp.TreeExp
-- Substitution d'une variable par une combinaison monadique de
-- vecteurs de symboles et variables dans une combinaison monadique
-- de vecteurs
substitute
:: (Eq var, MonadGen m (->))
=> var
-> m (Either var symbols)
-> m (Vector n (Either var symbols))
-> m (Vector n (Either var symbols))
substitute v toAdd = (=<<) aux
where
aux vect = mSequence $ fmap aux' vect
aux' (Left v') | v == v' = toAdd
aux' other
= return other
-- Expressions.EnrichedExp.WordExp
-- Expressions.EnrichedExp.TreeExp
predec g (Sub v e1 e2) = predec g e1 <> substitute
v
(fmap Right (final e1) <> fmap Left (variables e1))
(predec g e2)
predec g (Star v e) = substitute
v
(
(
fmap Right (final e)
<> fmap Left (return v <> variables e)
)
`actionR` star (nullableVar v e :: weight)
)
(predec g e)
Les cas des symboles sont quant à eux par essence même différents, de par la présence des produits
tensoriels.
Code Pseudo-Haskell. 123: Fonctions predec : produits tensoriels
-- Expressions.EnrichedExp.WordExp
predec g (Tensor (Product (f, ()))) | f == g
= return $ Left ()
| otherwise = mempty
-- Expressions.EnrichedExp.TreeExp
predec g (Tensor (TensorProd f vs))
| f == g = return $ fmap Left $ toUngradedVector vs
| otherwise = mempty
L’automate des positions s’obtient alors directement dans le cas des arbres, selon la construction
classique 8 :
8. Remarquons que dans le code source proposé, la factorisation ne peut se faire aussi directement au niveau monadique
pour des problèmes (techniques) de factorisation de contraintes quantiﬁées

7.3. Expressions enrichies
169
Code Pseudo-Haskell. 124: L’automate enrichi des positions : cas des arbres
-- Expressions.EnrichedExp.TreeExp
treePosition e_ = packVar
(either return (const mempty))
(fmap Right (final e) <> fmap Left (variables e))
(GradedMorph $ \x -> DualGradFunF $ \case
Right (Pos n g) | fromGrad x == g -> predec (GradPos n x) e
_ -> mempty
)
where e = linearize 1 e_
Dans le cas des mots, pour conserver l’utilisation de la fonction predec sans autres calculs, il sufﬁt
de retourner l’expression avant linéarisation :
Code Pseudo-Haskell. 125: L’automate enrichi des positions : cas des mots
-- Expressions.EnrichedExp.WordExp
predecPositionFA e = packKleisli
(fmap Right (final e') <> fmap Left (variables e))
(\x -> \case
Right (Pos n g) | x == g -> predec (Pos n g) e'
_
-> mempty
)
(\case
Left () -> one
_
-> zero
)
where e' = linearize 1 $ reverseExp e
Il est aussi possible de calculer un automate sans renverser l’expression, mais en “renversant” la
fonction predec :
Code Pseudo-Haskell. 126: L’automate enrichi des positions : cas alternatif des mots
-- Expressions.EnrichedExp.WordExp
predecPositionFA' e = packKleisli
(
succsOf (Left ())
<> ((nullableVar () e' :: weight) `action` return (Left ()))
)
(\x -> \case
p@(Right p'@(Pos _ p'')) | p'' == x ->
((finalWeight p' e' :: weight) `action` return (Left ())) <> succsOf p
_ -> mempty
)
(\case
Left () -> one
_
-> zero
)
where
e' = linearize 1 e
symbolPrecList =
fmap (\p -> (p, predec p e')) $ Set.toList $ getSymbols e'
succsOf p = foldMap (aux p) symbolPrecList
aux p (q, predsOfQ) =
(\q' -> if q' == p then return (Right q) else mempty) =<< predsOfQ
Le module HDRExample.HDRExampleEnrichedPosition contient des exemples de constructions. Une
fois stack ghci src/HDRExample/HDRExampleEnrichedPosition.hs lancé dans le terminal, il est
possible d’utiliser les fonctions suivantes :
— la fonction printWordPositionAut attend la saisie d’une expression rationnelle de mots (sai-
sie via les opérateurs +, * et ., et les symboles a, b et c) avant d’appliquer les constructions de
l’automate des positions non-déterministe et à multiplicités sur cette expression avant d’afﬁ-
cher le résultat au format dot;

170
Chapitre 7. Expressions rationnelles
— la fonction printTreePositionAut calcule une expression d’arbre aléatoire ne reconnaissant
que des arbres nullaires, ayant pour symboles nullaires a, b et c, unaires f et h, binaires g et
pour variables (), puis afﬁche son automate des positions non-déterministes au format Dot.
L’automate enrichi des dérivées
Comme dans le cas précédent de la construction par la méthode des positions, la dérivation, même
si elle n’est pas factorisée au niveau des expressions enrichies, est syntaxiquement proche entre les
spécialisations des expressions enrichies (mots et arbres). Ainsi, montrons comment calculer des au-
tomates enrichis (en conservant la généralisation monadique) en utilisant la dérivation. Remarquons
que comme dans le cas précédent, pour conserver la proximité syntaxique entre dérivation (Top-
Down, adaptée de [53] et étendue aux monades) des arbres et des mots, nous appliquerons la déri-
vation des mots par la droite, et inverserons l’expression lors de la construction.
Code Pseudo-Haskell. 127: La dérivation d’expressions enrichies : signatures
-- Expressions.EnrichedExp.WordExp
enrichedDerivation
:: ( Eq symbols
, Semimodule weight (m (WordExp symbols))
, MonadGen m (->)
, Star weight
)
=> symbols
-> WordExp symbols
-> m (WordExp symbols)
-- Expressions.EnrichedExp.TreeExp
enrichedDerivation
:: ( Eq symbols
, Graded symbols
, Eq var
, Semimodule weight (m (Vector n (TreeExp symbols var)))
, MonadGen m (->)
, Star weight
)
=> Graduation symbols n
-> TreeExp symbols var
-> m (Vector n (TreeExp symbols var))
D’une façon équivalente au calcul des prédécesseurs (Pseudo-Code 120), le calcul inductif est, mutatis
mutandis, le même entre les deux implantations (arbres et mots), situation proche d’une factorisation
au niveau des expressions enrichies.
Code Pseudo-Haskell. 128: La dérivation d’expressions enrichies : implantation
-- Expressions.EnrichedExp.WordExp
-- Expressions.EnrichedExp.TreeExp
-- Les cas de l'expression vide, d'une variable et de la somme
-- sont identiques.
enrichedDerivation _ Empty
= mempty
enrichedDerivation _ (Var _) = mempty
enrichedDerivation f (Sum e1 e2) =
enrichedDerivation f e1 <> enrichedDerivation f e2
-- La substitution et l'itération nécessitent une fonction auxiliaire dont
-- le rôle est de concaténer (produit de substitution) une expression
-- à un conteneur monadique
-- Expressions.EnrichedExp.WordExp
concatExpr
:: (FunctorGen f (->) cat')
=> var
-> Expression tensor var symbols

7.3. Expressions enrichies
171
-> cat'
(f (Expression tensor var symbols))
(f (Expression tensor var symbols))
concatExpr v e1 = fmap (Sub v e1)
-- Expressions.EnrichedExp.TreeExp
concatExpr
:: (FunctorGen f (->) cat')
=> var
-> Expression tensor var symbols
-> cat'
(f (Vector n (Expression tensor var symbols)))
(f (Vector n (Expression tensor var symbols)))
concatExpr v e1 = fmap (fmap (Sub v e1))
-- Expressions.EnrichedExp.WordExp
-- Expressions.EnrichedExp.TreeExp
-- La substitution et l'itération sont identiques,
-- entre mots et arbres, modulo l'utilisation de
-- la fonction concatExpr
enrichedDerivation f (Sub v e1 e2) =
((nullableVar v e2 :: weight) `action` enrichedDerivation f e1)
<> concatExpr v e1 (enrichedDerivation f e2)
enrichedDerivation f e'@(Star v e) =
(star (nullableVar v e) :: weight)
`action` concatExpr v e' (enrichedDerivation f e)
-- Le cas des produits tensoriels est le seul spécifique,
-- dépendant totalement du produit tensoriel.
-- Expressions.EnrichedExp.WordExp
enrichedDerivation y (Tensor (Product (x, v)))
-- ci dessous, v == (), et ainsi
-- Var v == epsilon
| x == y
= return $ Var v
| otherwise = mempty
-- Expressions.EnrichedExp.TreeExp
enrichedDerivation f (Tensor (TensorProd g vars))
| f == g = return (fmap Var (toUngradedVector vars) )
| otherwise = mempty
Les automates monadiques enrichis des dérivées 9 sont ainsi calculés à partir de cette dérivation,
mais aussi des fonctions variables ou nullableVar (Pseudo-Code 117).
Code Pseudo-Haskell. 129: La dérivation d’expressions enrichies : construction d’auto-
mates
-- Expressions.EnrichedExp.WordExp
-- Automate (enrichi, monadique, de mots) des dérivées
rightDerivationAutomaton e =
packKleisli
-- l'état initial est construit depuis l'expression inversée
(return $ reverseExp e)
-- le morphisme de transition est calculé depuis la dérivation
enrichedDerivation
-- la finalité est la traversabilité
(nullableVar ())
-- Expressions.EnrichedExp.TreeExp
-- Automate (enrichi, monadique, d'arbres) des dérivées
treeDerivation e = packVar
-- les états finaux sont les variables finales
9. Comme dans le cas de la méthode des positions, le code source fourni n’est pas factorisé, même si relativement iden-
tique, entre monades pour le cas des arbres, dû à un problème d’expression de contraintes.

172
Chapitre 7. Expressions rationnelles
variables
-- l'état initial est l'expression
(return e)
-- le morphisme de transition est construit depuis
-- la dérivation enrichie
(GradedMorph $ \x -> DualGradFunF $ enrichedDerivation x)
Même si ces constructions ne sont pas factorisées, dû à des contraintes techniques, leur proximité
syntaxique est encore une fois à remarquer, laissant présager d’une amélioration dans la suite de ce
projet.
Le module HDRExample.HDRExampleEnrichedDerivation contient des exemples de constructions.
Une fois stack ghci src/HDRExample/HDRExampleEnrichedDerivation.hs lancé dans le terminal,
il est possible d’utiliser les fonctions suivantes :
— la fonction printWordDerivationAut attend la saisie d’une expression rationnelle de mots
(saisie via les opérateurs +, * et ., et les symboles a, b et c) avant d’appliquer les construc-
tions de l’automate des dérivées non-déterministe et à multiplicités sur cette expression avant
d’afﬁcher le résultat au format Dot;
— la fonction printTreeDerivationAut calcule une expression d’arbre aléatoire ne reconnais-
sant que des arbres nullaires, ayant pour symboles nullaires a, b et c, unaires f et h, binaires g
et pour variables (), puis afﬁche son automate des dérivées non-déterministe au format Dot.
La construction inductive
La dernière méthode de construction que nous allons décrire dans ce document est la méthode in-
ductive, déjà décrite dans la Section 7.2.1 pour le cas des mots. Cette fois, la construction sera facto-
risée au niveau des expressions enrichies pour construire des automates de mots ou des automates
d’arbres Bottom-Up; en effet, les classes de types seront sufﬁsantes aﬁn d’exprimer les différences
entre les différents enrichissements des catégories. Si la construction enrichie s’inspire de la version
précédente sur les mots (notamment en utilisant une technique similaire à la construction de la mo-
nade libre), les algorithmes mis en place seront légèrement différents aﬁn de faciliter l’écriture au
niveau des expressions enrichies.
Nous commencerons tout d’abord à expliquer comment réaliser les opérations encodées par les opé-
rateurs et les atomes d’expressions en automates enrichis, puis nous déclarerons un type général
permettant d’encoder (à la manière des monades libres). Pour cela, nous présenterons des proprié-
tés communes à certaines catégories enrichies permettant de construire d’une façon similaire des
automates enrichis, tout en conservant la généralisation monadique obtenue précédemment aﬁn de
construire depuis une même expression des automates non-déterministes, à multiplicités, etc.
Les deux constructions les plus simples sont le cas de l’expression vide et de l’atome variable. Pour
ces deux constructions, il sufﬁra de considérer des catégories monoïdales pour lesquelles les mor-
phismes entre l’unité (monoïdale) et les objets morphismes de la catégorie enrichie (c’est-à-dire les
éléments généralisés) sont isomorphes avec une catégorie de Kleisli.
Code Pseudo-Haskell. 130: La construction inductive : Interprétation des morphismes en
fonctions de Kleisli
-- AutomataGen.Inductive
-- Classe de types permettant d'expliciter le lien entre
-- morphismes (de la catégorie monoïdale) et morphisme
-- de Kleisli
class AsFunction enrichedCat catMon tensor where
-- Famille de types permettant d'"extraire" la monade
type ExtractM enrichedCat catMon tensor :: * -> *
-- Transformation d'un morphisme depuis l'unité monoïdale
-- en une fonction de Kleisli
toFun ::
catMon (Unit catMon tensor) (enrichedCat a b)
-> a -> ExtractM enrichedCat catMon tensor b

7.3. Expressions enrichies
173
-- Transformation d'une fonction de Kleisli en morphisme
-- depuis l'unité monoïdale
fromFun ::
(a -> ExtractM enrichedCat catMon tensor b)
-> catMon (Unit catMon tensor) (enrichedCat a b)
-- Injection d'une fonction constante dans un morphisme
constCatMon :: ExtractM enrichedCat catMon tensor b -> catMon x (enrichedCat a b)
-- Définition pour la catégorie enrichie de Kleisli des types
-- associée à une monade enrichie m
instance AsFunction (KleisliEnrichedCat m (EnrichedTypeCat (->)) (->) Prod) (->) Prod where
type ExtractM (KleisliEnrichedCat m (EnrichedTypeCat (->)) (->) Prod) (->) Prod = m
toFun c = runEnrichedCat $ runKleisli $ c ()
fromFun c () = Kleisli $ EnrichedTypeCat c
constCatMon mb _ = Kleisli $ EnrichedTypeCat $ const mb
-- Définition pour la catégorie enrichie de Kleisli des types gradués
-- associée à une monade enrichie m
instance AsFunction
(KleisliEnrichedCat m MultiFun GradedMorph TensorProd) GradedMorph TensorProd
where
type ExtractM (KleisliEnrichedCat m MultiFun GradedMorph TensorProd) GradedMorph TensorProd = m
toFun (GradedMorph c) = runGradFun $ runGradK $ c GradUn
fromFun c = GradedMorph $ \GradUn -> GradKleisli $ GradFun c
constCatMon mb =
GradedMorph $
\x -> GradKleisli $ convertFromVectMultiFun (graduation' x) (const mb)
À l’aide de cette classe de types, la construction de l’automate enrichi ne reconnaissant rien est
simple : tous les morphismes sont obtenus depuis la constante nulle.
Code Pseudo-Haskell. 131: La construction inductive : l’automate vide
-- AutomataGen.Inductive
autoEmpty
:: ( EnrichedCategory enrichedCat catMon tensor
, Monoid (ExtractM enrichedCat catMon tensor state)
, AsFunction enrichedCat catMon tensor
, Semiring altValue
, Castable (ExtractM enrichedCat catMon tensor value) altValue
)
=> AutomatonGen enrichedCat catMon tensor init symbols state value
autoEmpty =
Auto
-- le morphisme initial est obtenu depuis la constante nulle
(constCatMon mempty)
-- le morphisme de transitions est obtenu depuis la constante nulle
(constCatMon mempty)
-- le morphisme initial est obtenu depuis le poids nul
(constCatMon $ castInv (zero :: altValue))
L’automate associé à une variable var n’a pas de transition (c’est à dire que son morphisme de tran-
sition est obtenu depuis la constante nulle), sa conﬁguration initiale est la promotion monadique des
variables, et son morphisme de ﬁnalité est obtenu depuis la fonction associant l’unité à la variable
var, la constante nulle aux autres.
Code Pseudo-Haskell. 132: La construction inductive : l’automate associé à une variable
-- AutomataGen.Inductive
fromVar

174
Chapitre 7. Expressions rationnelles
:: ( Eq var
, EnrichedCategory enrichedCat catMon tensor
, MonadGen (ExtractM enrichedCat catMon tensor) (->)
, AsFunction enrichedCat catMon tensor
, Castable (ExtractM enrichedCat catMon tensor value) altValue
, Semiring altValue
, Monoid (ExtractM enrichedCat catMon tensor var)
)
=> var
-> AutomatonGen enrichedCat catMon tensor var symbols var value
fromVar v = Auto
-- le morphisme initial est basé sur la promotion monadique
-- des variables
(fromFun return)
-- le morphisme de transition est obtenu depuis la constante nulle
(constCatMon mempty)
-- le morphisme de finalité est obtenu en transformant en élément
-- généralisé la fonction associant à v le poids unité,
-- le poids nul aux autres variables
(fromFun $ \v' -> if v == v'
then castInv (one :: altValue)
else castInv (zero :: altValue)
)
Le cas de l’itération se sufﬁt également de la classe de types déﬁnie précédemment. Cependant,
contrairement à la méthode inductive précédente sur les mots, nous décomposerons ici l’opération
d’itération des expressions en deux étapes : l’itération non-nulle suivie de l’ajout de variable. L’itéra-
tion positive par une variable v s’obtient alors d’une façon classique :
— le morphisme initial s’obtient en combinant l’ancien morphisme initial avec le poids étoilé de
v le cas échéant;
— le morphisme de transitions se compose de l’ancien dans lequel est ajoutée à toute “destina-
tion” la “conﬁguration initiale” après action du poids de ﬁnalité de cette destination;
— le morphisme de ﬁnalité est l’ancien morphisme combiné avec l’action du poids étoilé de v.
Aﬁn de combiner morphismes et éléments généralisés, nous utiliserons une nouvelle fois la fonction
append du module Enriched.Category.EnrichedCategory (Pseudo-Code 65).
Code Pseudo-Haskell. 133: La construction inductive : l’itération positive
-- AutomataGen.Inductive
autoPositiveStar
::( Semiring altValue
, AsFunction enrichedCat catMon tensor
, Castable (ExtractM enrichedCat catMon tensor value) altValue
, Semimodule altValue (ExtractM enrichedCat catMon tensor state)
, Semimodule altValue (ExtractM enrichedCat catMon tensor value)
, MonadGen (ExtractM enrichedCat catMon tensor) (->)
)
=> init
-> AutomatonGen enrichedCat catMon tensor init symbols state value
-> AutomatonGen enrichedCat catMon tensor init symbols state value
autoPositiveStar var (Auto i d f) = Auto initPositiveStar
deltaPositiveStar
finalPositiveStar
where
-- poids de la variable var dans l'automate de départ
epsWeight
= toFun (append i f) var
-- fonction de Kleisli associée au morphisme initial
i'
= toFun i
-- fonction de Kleisli associée au morphisme final
f'
= toFun f
-- le nouveau morphisme initial s'obtient en convertissant
-- en élément généralisé la fonction faisant agir
-- le poids étoilé de la variable var sur l'ancienne configuration
-- initiale le cas échéant
initPositiveStar = fromFun $ \var' -> if var == var'
then (star $ cast epsWeight :: altValue) `action` i' var

7.3. Expressions enrichies
175
else i' var'
-- le nouveau morphisme final s'obtient en transformant en élément
-- généralisé la fonction faisant agir le poids étoilé de la variable
-- sur le poids de finalité de chaque état
finalPositiveStar = fromFun
$ \p -> f' p `actionR` (star $ cast epsWeight :: altValue)
-- le nouveau morphisme de transition s'obtient en combinant l'ancien
-- morphisme de transition avec l'élément généralisé obtenu depuis la
-- fonction ajoutant à chaque état-destination p la configuration
-- initiale associée à la variable var après action du poids de p
deltaPositiveStar = append d $ fromFun $ \p ->
return p <> ((cast $ f' p :: altValue) `action` i' var)
La somme de deux automates enrichis se sufﬁt quant à elle de l’adjonction de deux classes de types
permettant
— de simuler au niveau des catégories monoïdales le dédoublement de l’entrée d’un automate
(par un morphisme qu’on pourrait presque qualiﬁé de diagonal) par le foncteur Prod (Pseudo-
Code 40),
— d’utiliser le foncteur Sum (Pseudo-Code 40) au sein d’une catégorie enrichie pour combiner les
résultats obtenus par le dédoublement précédent.
Code Pseudo-Haskell. 134: La construction inductive : le dédoublement et le regroupement
pour la somme
-- AutomataGen.Inductive
-- Définition d'un morphisme presque "diagonal"
class Diagonalizable catMon where
diag :: catMon x (Prod(x, x))
-- Cas de la catégorie monoïdale des types
instance Diagonalizable (->) where
diag x = Product (x, x)
-- Déclaration des couples d'éléments gradués (valable pour
-- des éléments de mêmes graduation uniquement), nécessaire
-- à la définition de Diagonalizable pour les morphismes
-- gradués
instance (Graded (First a), Graded (Second a)) => Graded (Prod a) where
fromGrad (GradProd x1 x2) = Product (fromGrad x1, fromGrad x2)
toGrad (Product (x1, x2)) = GradProd (toGrad x1) (toGrad x2)
data Graduation (Prod a) n =
GradProd (Graduation (First a) n) (Graduation (Second a) n)
-- La nouvelle graduation permet de définir Prod comme foncteur
-- depuis la catégorie produit des types gradués
instance FunctorGen Prod (ProdCat GradedMorph GradedMorph) GradedMorph where
fmap (Prod (GradedMorph f) (GradedMorph g)) =
GradedMorph $ \(GradProd x y) -> GradProd (f x) (g y)
-- Cas de la catégorie monoïdale des types gradués
instance Diagonalizable GradedMorph where
diag = GradedMorph $ \x -> GradProd x x
-- Extension de la fonction 'Data.Either.either' au
-- niveau monoïdal, envoyant un produit de morphismes
-- sur une somme
class AsEither catMon enrichedCat where
eitherFromProd ::
catMon
(Prod (enrichedCat a c, enrichedCat b c))
(enrichedCat (Sum (a, b)) c)
-- Définition pour la catégorie enrichie de Kleisli des types
-- associée à une monade enrichie m
instance

176
Chapitre 7. Expressions rationnelles
AsEither (->) (KleisliEnrichedCat m (EnrichedTypeCat (->)) (->) Prod)
where
eitherFromProd (Product (Kleisli f1, Kleisli f2)) =
let f1' = runEnrichedCat f1
f2' = runEnrichedCat f2
in
Kleisli $ EnrichedTypeCat $ packSumFunctions f1' f2'
-- Définition pour la catégorie enrichie de Kleisli des types gradués
-- associée à une monade enrichie m
instance
AsEither
GradedMorph (KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
where
eitherFromProd =
GradedMorph $
\(GradProd (GradKleisli f1) (GradKleisli f2)) ->
GradKleisli $ GradFun $
convertFromVectMultiFun' (graduation' f1) (aux f1 f2)
where
aux (GradFun f1) (GradFun f2) VNil = f1 <> f2
aux f1 f2 ys@(VCons _ _) = case vectToSum ys of
Nothing
-> mempty
Just (Fst xs) -> convertToVectMultiFun f1 xs
Just (Snd xs) -> convertToVectMultiFun f2 xs
-- fonction issue du module Tools.Vector
-- transformant un vecteur d'éléments Sum(a, b)
-- en
-- * un vecteur de b si tous les éléments sont de type b
-- * un vecteur de a si tous les éléments sont de type a
-- * Nothing sinon
vectToSum
:: Vector ( 'S n) (Sum (a, b))
-> Maybe (Sum (Vector ( 'S n) a, Vector ( 'S n) b))
vectToSum (VCons (Fst x) xs) = case xs of
VNil
-> Just $ Fst $ VCons x VNil
VCons _ _ -> case vectToSum xs of
Just (Fst xs_) -> Just $ Fst $ VCons x xs_
_
-> Nothing
vectToSum (VCons (Snd x) xs) = case xs of
VNil
-> Just $ Snd $ VCons x VNil
VCons _ _ -> case vectToSum xs of
Just (Snd xs_) -> Just $ Snd $ VCons x xs_
_
-> Nothing
À l’aide de ces outils, la somme de deux automates enrichis se décrit, d’une façon relativement clas-
sique, comme suit :
— le nouveau morphisme initial est la somme des morphismes initiaux interprétés comme fonc-
tions de Kleisli;
— le nouveau morphisme de transition s’obtient en dupliquant l’entrée par le morphisme dia-
gonal, en appliquant à chacune de ces composantes le morphisme de transitions des anciens
automates, puis en combinant le résultat par le morphisme eitherFromProd, chacun de ces
morphismes la catégorie monoïdale pouvant être concaténé par la composition de la catégo-
rie;
— le nouveau morphisme ﬁnal est obtenu en appliquant le premier morphisme sur les états du
premier automate, le second morphisme aux états du second automate.
Code Pseudo-Haskell. 135: La construction inductive : le cas de la somme
-- AutomataGen.Inductive
autoSum
:: ( FunctorGen (ExtractM enrichedCat catMon tensor) (->) (->)
, AsFunction enrichedCat catMon tensor
, Semigroup (ExtractM enrichedCat catMon tensor (Sum (state, state')))
, Diagonalizable catMon
, AsEither catMon enrichedCat

7.3. Expressions enrichies
177
, Bifunctor Prod catMon
, MonadGen (ExtractM enrichedCat catMon tensor) (->)
)
=> AutomatonGen enrichedCat catMon tensor init symbols state value
-> AutomatonGen enrichedCat catMon tensor init symbols state' value
-> AutomatonGen
enrichedCat
catMon
tensor
init
symbols
(Sum (state, state'))
value
autoSum (Auto i1 d1 f1) (Auto i2 d2 f2) = Auto initSum deltaSum finalSum
where
-- fonctions de Kleisli associées aux morphismes initiaux
i1' = toFun i1
i2' = toFun i2
-- fonctions de Kleisli associées aux morphismes finaux
f1' = toFun f1
f2' = toFun f2
-- promotions des morphismes de transitions au niveau
-- du foncteur Sum
d1' = append d1 $ fromFun (return . Fst)
d2' = append d2 $ fromFun (return . Snd)
-- le nouveau morphisme initial est la combinaison des deux anciens
initSum =
fromFun $ \var -> fmap Fst (i1' var) <> fmap Snd (i2' var)
-- le nouveau morphisme final s'obtient en combinant les deux anciens
finalSum = fromFun $ packSumFunctions f1' f2'
-- le nouveau morphisme de transitions s'obtient par composition
-- du morphisme diagonal, des promotions des deux anciens morphismes de
-- transition, puis en combinant les résultats
deltaSum = eitherFromProd . fmap (Prod d1' d2') . diag
-- Category.OfStructures.CategoryOfTypes
-- Injection de deux fonctions dans une 'Sum'
packSumFunctions :: (a -> c) -> (b -> c) -> Sum (a, b) -> c
packSumFunctions f _ (Fst a) = f a
packSumFunctions _ g (Snd b) = g b
La substitution par une variable var se fait également d’une façon classique, en ajoutant des transi-
tions entre les deux automates de la façon suivante :
— le morphisme initial est identique à la somme pour les variables différentes de var, sinon
correspond à la combinaison de la conﬁguration initiale associée à var du premier automate
combinée à celle du second, après action du poids de la variable var dans le premier automate;
— le morphisme de transition s’obtient tout d’abord en construisant le même morphisme que la
somme, puis en ajoutant aux états destinations des transitions du premier automate la conﬁ-
guration initiale associée à var du second automate, après action du poids ﬁnal de l’état dans
le premier automate;
— le morphisme ﬁnal s’obtient en ne conservant que celui du second automate.
Code Pseudo-Haskell. 136: La construction inductive : le cas de la substitution
-- AutomataGen.Inductive
autoCat
:: ( Eq init
, Diagonalizable catMon
, AsEither catMon enrichedCat
, Bifunctor Prod catMon
, EnrichedCategory enrichedCat catMon tensor
, AsFunction enrichedCat catMon tensor
, MonadGen (ExtractM enrichedCat catMon tensor) (->)
, Castable (ExtractM enrichedCat catMon tensor value) altValue
, Semimodule altValue (ExtractM enrichedCat catMon tensor value)
, Semimodule

178
Chapitre 7. Expressions rationnelles
altValue
(ExtractM enrichedCat catMon tensor (Sum (state, state')))
)
=> init
-> AutomatonGen enrichedCat catMon tensor init symbols state value
-> AutomatonGen enrichedCat catMon tensor init symbols state' value
-> AutomatonGen
enrichedCat
catMon
tensor
init
symbols
(Sum (state, state'))
value
autoCat var (Auto i1 d1 f1) (Auto i2 d2 f2) = Auto
initConcat
(append deltaSum (fromFun aux))
finalConcat
where
-- promotions des morphismes de transitions au niveau
-- du foncteur Sum
d1'
= append d1 $ fromFun (return . Fst)
d2'
= append d2 $ fromFun (return . Snd)
-- identique à la construction de la somme
deltaSum = eitherFromProd . fmap (Prod d1' d2') . diag
-- ajout de l'action des poids finaux sur les états
-- destinations de transitions
aux q'@(Fst q) =
return q' <> ((cast (f1' q) :: altValue) `action` fmap Snd (i'2 var))
aux q' = return q'
-- poids de var dans le premier automate
emptyWeight1 = toFun (append i1 f1) var
-- fonctions de Kleisli associées aux morphismes initiaux
i'1
= toFun i1
i'2
= toFun i2
-- fonctions de Kleisli associées aux morphismes finaux
f1'
= toFun f1
f2'
= toFun f2
-- nouveau morphisme initial, calculé en fonction
-- de la variable considérée pour la configuration
-- initiale
initConcat
= fromFun $ \var' -> if var == var'
then fmap Fst (i'1 var)
<> action (cast emptyWeight1 :: altValue) (fmap Snd (i'2 var))
else fmap Fst (i'1 var') <> fmap Snd (i'2 var')
-- nouveu morphisme final, obtenu depuis le morphisme final
-- du second automate
finalConcat = fromFun $ packSumFunctions (const mempty) f2'
Le cas restant est le cas le plus spéciﬁque, puisqu’il repose sur le produit tensoriel entre symboles
et variables : l’idée générale est de construire un automate dont les états sont des variables et des
symboles, de considérer les variables comme conﬁgurations initiales, les symboles comme des conﬁ-
gurations ﬁnales (unitaires), et d’ajouter une transition entre les variables et symboles dont le produit
tensoriel est composé (en toute généralité). Pour représenter cette spéciﬁcité, nous allons décrire une
type de classes permettant de transformer un produit tensoriel en un morphisme (de la catégorie
monoïdale), ce qui nous servira de transition.
Code Pseudo-Haskell. 137: La construction inductive : extraction d’une transition d’un pro-
duit tensoriel
-- AutomataGen.Inductive
-- Classe de type représentant la conversion d'un produit tensoriel
-- en un morphisme, utilisé pour décrire une transition
class AddTrans enrichedCat catMon tensor where
toTrans :: tensor(a, b) -> catMon a (enrichedCat b a)

7.3. Expressions enrichies
179
-- Cas de la catégorie monoïdale des types
instance AddTrans (KleisliEnrichedCat m (EnrichedTypeCat (->)) (->) Prod) (->) Prod where
toTrans prod@(Product (x, _)) y =
Kleisli $ EnrichedTypeCat $ \v' ->
if Product (y, v') == prod then return x else mempty
-- Cas de la catégorie monoïdale des types gradués
instance
AddTrans (KleisliEnrichedCat m MultiFun GradedMorph TensorProd)
GradedMorph TensorProd
where
toTrans (TensorProd x ys) = GradedMorph $ \y ->
GradKleisli $ convertFromVectMultiFun (graduation' y) $ \ys' ->
if fromGrad x == fromGrad y && vectEq ys' (toUngradedVector ys)
then return (fromGrad x)
else mempty
La considération de cette unique transition pour construire l’automate intervient comme suit.
Code Pseudo-Haskell. 138: La construction inductive : le cas du produit tensoriel
-- AutomataGen.Inductive
fromTensor
:: ( Castable (ExtractM enrichedCat catMon tensor value) altValue
, Semiring altValue
, AddTrans enrichedCat catMon tensor
, Eq var
, Eq symbols
, EnrichedCategory enrichedCat catMon tensor
, MonadGen (ExtractM enrichedCat catMon tensor) (->)
, AsFunction enrichedCat catMon tensor
, Bifunctor Prod catMon
, Monoid (ExtractM enrichedCat catMon tensor (Sum (var, symbols)))
, AsEither catMon enrichedCat
, Diagonalizable catMon
)
=> tensor (symbols, var)
-> AutomatonGen
enrichedCat
catMon
tensor
var
symbols
(Sum (var, symbols))
value
fromTensor tensor = Auto
-- configuration initiale associée à chaque variable
(fromFun $ return . Fst)
-- transition obtenu depuis l'extraction tensorielle
(eitherFromProd
. fmap
(Prod
( append (toTrans tensor) $ fromFun (return . Snd) )
(constCatMon mempty)
)
. diag
)
-- morphisme de finalité:
-- seuls les symboles ont un poids non-nul, unitaire
(fromFun$ \case
Snd _ -> castInv (one :: altValue)
_
-> castInv (zero :: altValue)
)
Le passage au calcul de l’automate depuis une expression enrichie nécessite la prise en compte du
problème soulevé lors de la déﬁnition de la méthode inductive sur les expressions de mots : ne

180
Chapitre 7. Expressions rationnelles
connaissant pas à l’avance le nombre d’opérations ni leur nature à appliquer inductivement, com-
ment exprimer le type des états de l’automate? Nous appliquerons ici une méthode équivalente à
la construction de la monade libre engendré par un foncteur, mais sans déclarer tous les outils pour
simpliﬁer. Tout d’abord, remarquons que
— l’automate vide est construit sur n’importe quel type d’états;
— l’automate associé à une variable a pour états des variables;
— l’itération positive ne modiﬁe pas les états de l’automate;
— l’automate associé à un produit tensoriel a pour état des symboles et des variables, via le
constructeur de types Sum;
— la somme et la substitution ajoutent un niveau de foncteur somme au niveau du type des états
(passant de state et state’ à Sum(state, state’)).
Ainsi, les états d’un automate inductif sont obtenus par application successive du foncteur Sum de-
puis les types var et symbols, représentable par le type suivant :
Code Pseudo-Haskell. 139: La construction inductive : le type des états
-- AutomataGen.Inductive
-- Les états sont:
data StateType var symbols
-- soit des variables
= Var var
-- soit des sommes variables et symboles
| Sum (Sum (var, symbols))
-- soit des sommes récursives de ce type
| SumRec (Sum(StateType var symbols, StateType var symbols))
En plus de la déﬁnition de ce type, le module AutomataGen.Inductive contient la déﬁnition de
fonctions utilitaires permettant de projeter les constructions précédentes :
— varToStateTypetransforme un automate dont les états sont de types var en un automate dont
les états sont de type StateType var symbols;
— sumVarSymbToStateTypetransforme un automate dont les états sont de types Sum(var, symbols)
en un automate dont les états sont de type StateType var symbols;
— sumToStateType transforme un automate dont les états sont de types Sum(StateType var
symbols, StateType var symbols) en un automate dont les états sont de type StateType
var symbols
par des processus similaires à ceux mis en œuvre par la technique de la monade libre précédente. À
l’aide de ces outils, la construction de l’automate enrichi associé à une expression enrichie se déclare
sans surprise comme suit.
Code Pseudo-Haskell. 140: La construction inductive
-- AutomataGen.Inductive
fromExpr
:: ( Eq symbols
, Eq var
, AsFunction enrichedCat catMon tensor
, Semiring altValue
, Semimodule
altValue
(ExtractM enrichedCat catMon tensor (StateType var symbols))
, Star altValue
, Monoid
( ExtractM
enrichedCat
catMon
tensor
(Sum (StateType var symbols, StateType var symbols))
)
, Diagonalizable catMon
, AsEither catMon enrichedCat
, FunctorGen (ExtractM enrichedCat catMon tensor) (->) (->)
, FunctorGen Prod (ProdCat catMon catMon) catMon

7.3. Expressions enrichies
181
, Monoid (ExtractM enrichedCat catMon tensor var)
, Monoid (ExtractM enrichedCat catMon tensor (Sum (var, symbols)))
, MonadGen (ExtractM enrichedCat catMon tensor) (->)
, EnrichedCategory enrichedCat catMon tensor
, Castable (ExtractM enrichedCat catMon tensor value) altValue
, Semimodule altValue (ExtractM enrichedCat catMon tensor value)
, Semimodule
altValue
( ExtractM
enrichedCat
catMon
tensor
(Sum (StateType var symbols, StateType var symbols))
)
, AddTrans enrichedCat catMon tensor
)
=> Expression tensor var symbols
-> AutomatonGen
enrichedCat
catMon
tensor
var
symbols
(StateType var symbols)
value
fromExpr Empty
= varToStateType autoEmpty
fromExpr (Var v) = varToStateType $ fromVar v
fromExpr (Tensor t) = sumVarSymbToStateType $ fromTensor t
fromExpr (Sum e1 e2) =
sumToStateType $ autoSum (fromExpr e1) (fromExpr e2)
fromExpr (Sub v e1 e2) =
sumToStateType $ autoCat v (fromExpr e1) (fromExpr e2)
fromExpr (Star v e) = sumToStateType $ autoSum
(autoPositiveStar v $ fromExpr e)
(fromExpr (Var v))
Le module HDRExample.HDRExampleEnrichedInductivecontient des exemples de constructions. Une
fois stack ghci src/HDRExample/HDRExampleEnrichedInductive.hs lancé dans le terminal, il est
possible d’utiliser les fonctions suivantes :
— la fonction printInductiveAut attend la saisie d’une expression rationnelle de mots (saisie
via les opérateurs +, * et ., et les symboles a, b et c) avant d’appliquer les constructions de
l’automate inductif non-déterministe et à multiplicités sur cette expression avant d’afﬁcher le
résultat au format dot;
— la fonction printInductiveTreeAut calcule une expression d’arbre aléatoire ne reconnaissant
que des arbres nullaires, ayant pour symboles nullaires a, b et c, unaires f et h, binaires g et
pour variables (), puis afﬁche son automate Bottom-Up inductif non-déterministe au format
dot.
Aﬁn de tester la validité des constructions, le module HDRExample.HDRExampleEnrichedTests pro-
pose deux fonctions permettant de comparer les résultats des différentes méthodes. Ainsi, une fois
stack ghci src/HDRExample/HDRExampleEnrichedTests.hs lancé dans le terminal, il est possible
d’utiliser les fonctions suivantes :
— la fonction testWordConstructions génère une (courte) expression rationnelle aléatoire, puis
construit un automate à multiplicités (non enrichi) selon la méthode proposée à la Section 7.2.1,
et 8 automates enrichis (Glushkov enrichi à multiplicités, inductif enrichi à multiplicités, deux
Glushkov inversés à multiplicités, enrichi à multiplicités des dérivées gauches et droites, en-
richi alternant généralisé des dérivées gauches et droites) puis compare les résultats de ces
automates pour 100 mots aléatoires;
— la fonction testTreeConstructionsgénère une (courte) expression enrichie aléatoire d’arbres,
puis construit les automates Top-Down à multiplicités par dérivation et par la méthode des
positions, ainsi que l’automate Bottom-Up inductif à multiplicités associé à cette expression,
puis compare les résultats de ces automates pour 100 arbres aléatoires.

182
Chapitre 7. Expressions rationnelles
7.4
Conclusion et perspectives
Dans cette partie, nous avons proposé une ébauche de déﬁnition d’expressions rationnelles pouvant
utiliser les différentes notions présentées dans les parties précédentes. Même si l’implantation propo-
sée n’est pas optimale, elle permet d’entrevoir le potentiel de factorisation, mais aussi de permettre
de déﬁnir des machines à l’aide de monades bien connues de la communauté de la programmation
fonctionnelle.
Cette proposition de structure permet également de soulever le rôle des variables dans les automates
d’arbres et de proposer une utilisation de celles-ci dans d’autres structures monoïdales; par exemple,
il est possible de déﬁnir des expressions de mots sur un autre ensemble de variables que l’ensemble
1. Dans ce cas, le rôle d’une variable pourrait être, par exemple, de “sélectionner” une machine
particulière d’un réseau de machines.
Le choix du produit tensoriel est également important et peut permettre de changer avec ﬁnesse le
comportement des expressions. On pourrait imaginer qu’en fonction du choix du produit tensoriel,
il soit possible d’obtenir des expressions commutatives par exemple.
Nous avons pu également constater que l’implantation proposée ne permet pas une factorisation
totale des constructions, bien que leur très forte proximité syntaxique ne laisse pas de doute sur la
possibilité d’y arriver. Pour cela, il peut être intéressant de redéﬁnir les fonctions de construction,
que ce soit les fonctions de position ou la dérivation non plus comme des fonctions (c’est-à-dire
des morphismes de la catégorie des types) mais comme des morphismes d’autres catégories monoï-
dales enrichissant la catégorie enrichie ambiante. Par exemple, on pourrait imaginer une signature
de la forme catMon symbols (enrichedCat expression expression) pour un morphisme de déri-
vation. Le problème de la déﬁnition d’une construction inductive se pose alors : comment déﬁnir un
tel morphisme par induction sur la structure d’expression rationnelle, déﬁnie comme une structure
de données, et ainsi “vivant” dans la catégorie des types. Une piste serait alors de s’intéresser à la
notion d’opérade dans d’autres catégories que la catégorie des types : l’idée serait de donner les cas
de bases sur les constructeurs de types, ou sur les opérateurs formant la base de l’opérade isomorphe
aux expressions, puis étendre ces cas (par induction “automatique”) par un mécanisme semblable à
promoteFunToOperad.
La dérivation Bottom-Up d’expression d’arbres, quant à elle, pourrait s’étendre en prenant en compte
une dérivation par un vecteur de variables; la dérivation serait alors paramétrée également par la
déﬁnition du produit tensoriel.
Une autre piste serait de s’intéresser à une extension de la notion d’Arrows [47] (voir également [5]
pour les liens possibles avec l’enrichissement) sur les catégories enrichies, ce qui semblerait être
relativement proche des classes de types utilisées pour la construction de l’automate généralisé par
induction.

183
Conclusion et perspectives de
recherche
Une sortie, c’est une entrée qu’on prend dans l’autre sens.
Boris Vian
Nous avons ainsi montré comment implanter d’une façon relativement factorisée les notions d’auto-
mates d’arbres et de mots en les généralisant au niveau des catégories enrichies. Nous avons égale-
ment proposé une ébauche de déﬁnition concernant les expressions rationnelles.
Ces propositions de représentation laissent entrevoir de futures extensions à d’autres monoïdes ob-
jets de catégories monoïdales aﬁn de généraliser les éléments de bases à pondérer. On pourrait éga-
lement se poser la question de l’extension de la pondération non plus à des éléments, mais à des
éléments généralisés.
Concernant l’implantation, nous avons indiqué plusieurs fois que celle-ci n’avait pas été produite
dans un but d’utilisation intensive. Il s’agit avant tout d’une preuve de concept qui doit être alors
remise à plat depuis sa base aﬁn de tirer proﬁt au maximum des outils déjà disponibles dans la
communauté Haskell. Par exemple, le genre Nat utilisé pour représenter les entiers au niveau des
types (pour paramétrer la longueur des vecteurs ou l’arité des éléments gradués par exemple) est
une construction simpliste pouvant être optimisée (il existe d’ailleurs de très bons modules pour
cela dans la communauté Haskell). Un autre exemple d’optimisation possible est la résolution d’une
grande perte d’efﬁcacité étant due à la notion de preuve au niveau des types (comme les preuves
d’égalité de types de genre Nat, telles que la preuve récursive de la commutativité de la somme).
Les types sont “oubliés” après la compilation, et il faut alors utiliser des mécanismes, parfois lourds,
pour les récupérer aﬁn de s’assurer que tout est correct en terme d’équivalence de types pour réaliser
une programmation au niveau des types correcte. Cependant, la correction n’est nécessaire que pour
guider le compilateur dans l’inférence d’égalité (au sens fort) de types. En d’autres termes, on peut
se passer d’un grand nombre de ces morceaux de code à l’exécution car ces calculs ne servent qu’à
indiquer au compilateur qu’il peut réaliser des opérations prévues sur des types sur d’autres types
en toute sécurité.
Une fois ces modiﬁcations faites, c’est-à-dire une fois avoir mis en place un mécanisme permettant de
réaliser des tests forts au niveau du typage tout en étant capable de les “désactiver”, on pourrait ren-
forcer encore plus la sécurité du code en encodant au niveau des types les propriétés mathématiques
des structures algébriques mises en œuvre. Ainsi, un monoïde ne se satisferait plus d’une fonction
binaire et d’un élément particulier, mais on pourrait lui ajouter une preuve de l’associativité et de
l’unitarité de la fonction sous-jacente. On pourrait alors restreindre les éléments contenus dans le
constructeur MonoidMorph aux morphismes de monoïdes.
Une autre modiﬁcation importante pour l’implantation pourrait être le fait de généraliser la classe de
types des catégories à d’autres genres (c’est-à-dire d’autres “types de types”) que le genre * d’Has-
kell. On pourrait ainsi déﬁnir une catégorie dont les objets seraient des types du genre Nat, support
qui serait nécessaire à encoder proprement la notion de PRO [55], puis peut-être les reconnaisseurs
associés.


185
Bibliographie
[1]
Jirí ADÁMEK et Vera TRNKOVÁ. Automata and Algebras in Categories. Mathematics and its Ap-
plications. Springer Netherlands, 1990. ISBN : 9780792300106 (cf. p. 11).
[2]
Valentin M. ANTIMIROV. « Partial Derivatives of Regular Expressions and Finite Automaton
Constructions ». In : Theor. Comput. Sci. 155.2 (1996), p. 291-319. DOI : 10.1016/0304-3975(95)00182-4.
URL : https://doi.org/10.1016/0304-3975(95)00182-4 (cf. p. 20, 29, 33, 158, 159).
[3]
Michael A ARBIB et Ernest G MANES. « Adjoint machines, state-behavior machines, and dua-
lity ». In : Journal of Pure and Applied Algebra 6.3 (1975), p. 313-344 (cf. p. 63).
[4]
Dean N. ARDEN. « Delayed-logic and ﬁnite-state machines ». In : 2nd Annual Symposium on
Switching Circuit Theory and Logical Design, Detroit, Michigan, USA, October 17-20, 1961. IEEE
Computer Society, 1961, p. 133-151. DOI : 10.1109/FOCS.1961.13. URL : https://doi.org/10.1109/FOCS.1961
(cf. p. 7).
[5]
Robert ATKEY. « What is a Categorical Model of Arrows? » In : Electron. Notes Theor. Comput.
Sci. 229.5 (2011), p. 19-37 (cf. p. 182).
[6]
Samira ATTOU, Ludovic MIGNOT et Djelloul ZIADI. « Extended tree expressions and their de-
rivatives ». In : NCMA. Österreichische Computer Gesellschaft, 2019, p. 47-62 (cf. p. 1, 43).
[7]
Samira ATTOU, Ludovic MIGNOT et Djelloul ZIADI. « The Bottom-Up Position Tree Automaton
and Its Compact Version ». In : Implementation and Application of Automata - 23rd International
Conference, CIAA 2018, Charlottetown, PE, Canada, July 30 - August 2, 2018, Proceedings. Sous la
dir. de Cezar CÂMPEANU. T. 10977. Lecture Notes in Computer Science. Springer, 2018, p. 59-
70. DOI : 10.1007/978-3-319-94812-6\_6. URL : https://doi.org/10.1007/978-3-319-94812-6\_6
(cf. p. 1, 39, 41).
[8]
Samira ATTOU, Ludovic MIGNOT et Djelloul ZIADI. « The Bottom-Up Position Tree Automa-
ton, the Father Automaton and their Compact Versions ». In : IJFCS () (cf. p. 39, 41).
[9]
Gérard BERRY et Ravi SETHI. « From Regular Expressions to Deterministic Automata ». In :
Theor. Comput. Sci. 48.3 (1986), p. 117-126 (cf. p. 20, 29).
[10]
Nick BEZHANISHVILI et al. « Minimisation in Logical Form ». In : CoRR abs/2005.11551 (2020).
arXiv : 2005.11551. URL : https://arxiv.org/abs/2005.11551 (cf. p. 63).
[11]
Jean-Camille BIRGET. « Intersection and Union of Regular Languages and State Complexity ».
In : Inf. Process. Lett. 43.4 (1992), p. 185-190. DOI : 10.1016/0020- 0190(92)90198- 5. URL :
https://doi.org/10.1016/0020-0190(92)90198-5 (cf. p. 114).
[12]
Béatrice BOUCHOU et al. « Conservative Extensions of Regular Languages ». In : SCCC. IEEE
Computer Society, 2004, p. 99-109 (cf. p. 39).
[13]
Edwin BRADY. Type-Driven Development with Idris. Manning Publications, 2017. ISBN : 9781617293023
(cf. p. 98).
[14]
Martin BRANDENBURG. « Tensor categorical foundations of algebraic geometry ». In : arXiv
preprint arXiv :1410.1716 (2014) (cf. p. 195).
[15]
Anne BRÜGGEMANN-KLEIN et Derick WOOD. « One-Unambiguous Regular Languages ». In :
Inf. Comput. 140.2 (1998), p. 229-253 (cf. p. 39).
[16]
Janusz A. BRZOZOWSKI. « Derivatives of Regular Expressions ». In : J. ACM 11.4 (1964), p. 481-
494 (cf. p. 20, 39, 57, 158).
[17]
Janusz A. BRZOZOWSKI et Edward J. MCCLUSKEY. « Signal Flow Graph Techniques for Se-
quential Circuit State Diagrams ». In : IEEE Trans. Electronic Computers 12.2 (1963), p. 67-76.
DOI : 10.1109/PGEC.1963.263416. URL : https://doi.org/10.1109/PGEC.1963.263416
(cf. p. 7).
[18]
Julien CARME et al. « Residual Finite Tree Automata ». In : DLT 2003. 2003, p. 171-182. DOI :
10.1007/3-540-45007-6_13. URL : http://dx.doi.org/10.1007/3-540-45007-6_13
(cf. p. 46).

186
Bibliographie
[19]
Pascal CARON, Jean-Marc CHAMPARNAUD et Ludovic MIGNOT. « A general framework for the
derivation of regular expressions ». In : RAIRO - Theor. Inf. and Applic. 48.3 (2014), p. 281-305.
DOI : 10.1051/ita/2014010. URL : https://doi.org/10.1051/ita/2014010 (cf. p. 158).
[20]
Pascal CARON, Jean-Marc CHAMPARNAUD et Ludovic MIGNOT. « Acyclic automata and small
expressions using multi-tilde-bar operators ». In : Theor. Comput. Sci. 411.38-39 (2010), p. 3423-
3435. DOI : 10.1016/j.tcs.2010.05.023. URL : https://doi.org/10.1016/j.tcs.2010.05.023
(cf. p. 1).
[21]
Pascal CARON, Jean-Marc CHAMPARNAUD et Ludovic MIGNOT. « Multi-tilde-bar expressions
and their automata ». In : Acta Inf. 49.6 (2012), p. 413-436. DOI : 10.1007/s00236-012-0167-x.
URL : https://doi.org/10.1007/s00236-012-0167-x (cf. p. 1).
[22]
Pascal CARON, Jean-Marc CHAMPARNAUD et Ludovic MIGNOT. « Partial Derivatives of an
Extended Regular Expression ». In : Language and Automata Theory and Applications - 5th In-
ternational Conference, LATA 2011, Tarragona, Spain, May 26-31, 2011. Proceedings. Sous la dir.
d’Adrian-Horia DEDIU, Shunsuke INENAGA et Carlos MARTÍN-VIDE. T. 6638. Lecture Notes
in Computer Science. Springer, 2011, p. 179-191. DOI : 10.1007/978-3-642-21254-3_13. URL :
https://doi.org/10.1007/978-3-642-21254-3_13 (cf. p. 158).
[23]
Pascal CARON et Marianne FLOURET. « Glushkov Construction for Series : The Non Commu-
tative Case ». In : Int. J. Comput. Math. 80.4 (2003), p. 457-472 (cf. p. 153).
[24]
Pascal CARON et Djelloul ZIADI. « Characterization of Glushkov automata ». In : Theor. Comput.
Sci. 233.1-2 (2000), p. 75-90 (cf. p. 39).
[25]
Jean-Marc CHAMPARNAUD, Hadrien JEANNE et Ludovic MIGNOT. « Derivatives of Approxi-
mate Regular Expressions ». In : Discrete Mathematics & Theoretical Computer Science 15.2 (2013),
p. 95-120. URL : http://dmtcs.episciences.org/598 (cf. p. 1).
[26]
Jean-Marc CHAMPARNAUD, Ludovic MIGNOT et Florent NICART. « Constrained Expressions
and their Derivatives ». In : Fundam. Inform. 149.3 (2016), p. 311-361. DOI : 10.3233/FI-2016-1451.
URL : https://doi.org/10.3233/FI-2016-1451 (cf. p. 1).
[27]
Jean-Marc CHAMPARNAUD et Djelloul ZIADI. « Canonical derivatives, partial derivatives and
ﬁnite automaton constructions ». In : Theor. Comput. Sci. 289.1 (2002), p. 137-163 (cf. p. 20, 29).
[28]
Jean-Marc CHAMPARNAUD et al. « Bottom-Up Quotients for Tree Languages ». In : J. Autom.
Lang. Comb. 22.4 (2017), p. 243-269. DOI : 10.25596/jalc-2017-243. URL : https://doi.org/10.25596/jalc-2017
(cf. p. 1, 43).
[29]
Jean-Marc CHAMPARNAUD et al. « From Regular Weighted Expressions To Finite Automata ».
In : Int. J. Found. Comput. Sci. 15.5 (2004), p. 687-700 (cf. p. 147, 153).
[30]
Jean-Marc CHAMPARNAUD et al. « Two-Sided Derivatives for Regular Expressions and for
Hairpin Expressions ». In : Language and Automata Theory and Applications - 7th International
Conference, LATA 2013, Bilbao, Spain, April 2-5, 2013. Proceedings. Sous la dir. d’Adrian-Horia
DEDIU, Carlos MARTÍN-VIDE et Bianca TRUTHE. T. 7810. Lecture Notes in Computer Science.
Springer, 2013, p. 202-213. DOI : 10.1007/978-3-642-37064-9_19. URL : https://doi.org/10.1007/978-3-642-3
(cf. p. 1).
[31]
Bryce CLARKE et al. Profunctor optics, a categorical update. 2020. arXiv : 2001.07488 [cs.PL]
(cf. p. 63).
[32]
Thomas COLCOMBET et Daniela PETRISAN. « Automata and minimization ». In : SIGLOG News
4.2 (2017), p. 4-27 (cf. p. 2, 63, 68).
[33]
Hubert COMON et al. Tree Automata Techniques and Applications. Available on : http://www.grappa.univ-lille3.fr
release October, 12th 2007. 2007 (cf. p. 1, 10, 45).
[34]
Manfred DROSTE et Paul GASTIN. « Weighted automata and weighted logics ». In : Theor. Com-
put. Sci. 380.1-2 (2007), p. 69-86. DOI : 10.1016/j.tcs.2007.02.055. URL : https://doi.org/10.1016/j.tcs.2007
(cf. p. 122).
[35]
Manfred DROSTE et Heiko VOGLER. « Weighted tree automata and weighted logics ». In : Theor.
Comput. Sci. 366.3 (2006), p. 228-247. URL : https://doi.org/10.1016/j.tcs.2006.08.025
(cf. p. 122).
[36]
Eduardo J DUBUC. Kan extensions in enriched category theory. T. 145. Springer, 2006 (cf. p. 135).
[37]
Beno ECKMANN et Peter J HILTON. « Group-like structures in general categories ». In : Mathe-
matische Annalen 145.3 (1962), p. 227-255 (cf. p. 107).
[38]
Giovanni de FELICE, Alexis TOUMI et Bob COECKE. DisCoPy : Monoidal Categories in Python.
2020. arXiv : 2005.02975 [math.CT] (cf. p. 64).
[39]
Zoltán FÜLÖP, Andreas MALETTI et Heiko VOGLER. « A Kleene Theorem for Weighted Tree
Automata over Distributive Multioperator Monoids ». In : Theory Comput. Syst. 44.3 (2009),

Bibliographie
187
p. 455-499. DOI : 10.1007/s00224-007-9091-9. URL : https://doi.org/10.1007/s00224-007-9091-9
(cf. p. 129).
[40]
Pedro GARCÍA et al. « From regular expressions to smaller NFAs ». In : Theor. Comput. Sci.
412.41 (2011), p. 5802-5807 (cf. p. 36).
[41]
Samuele GIRAUDO et al. « Operads, quasiorders, and regular languages ». In : Advances in Ap-
plied Mathematics 75 (2016), p. 56-93 (cf. p. 1).
[42]
Ian GLAISTER et Jeffrey SHALLIT. « A Lower Bound Technique for the Size of Nondeterministic
Finite Automata ». In : Inf. Process. Lett. 59.2 (1996), p. 75-77. DOI : 10.1016/0020-0190(96)00095-6.
URL : https://doi.org/10.1016/0020-0190(96)00095-6 (cf. p. 114).
[43]
V. M. GLUSHKOV. « The abstract theory of automata ». In : Russian Mathematical Surveys 16
(1961), p. 1-53 (cf. p. 19).
[44]
Gerco van HEERDT, Matteo SAMMARTINO et Alexandra SILVA. « Optimizing Automata Lear-
ning via Monads ». In : CoRR abs/1704.08055(2017). arXiv : 1704.08055. URL : http://arxiv.org/abs/1704.08
(cf. p. 63).
[45]
Gerco van HEERDT et al. « A Categorical Framework for Learning Generalised Tree Auto-
mata ». In : CoRR abs/2001.05786 (2020) (cf. p. 63).
[46]
Johanna HÖGBERG, Andreas MALETTI et Jonathan MAY. « Backward and forward bisimulation
minimization of tree automata ». In : Theor. Comput. Sci. 410.37 (2009), p. 3539-3552 (cf. p. 11).
[47]
John HUGHES. « Generalising monads to arrows ». In : Sci. Comput. Program. 37.1-3 (2000), p. 67-
111 (cf. p. 182).
[48]
Lucian ILIE et Sheng YU. « Follow automata ». In : Inf. Comput. 186.1 (2003), p. 140-162 (cf. p. 19,
27, 41).
[49]
Ahmed KHORSI, Faissal OUARDI et Djelloul ZIADI. « Fast equation automaton computation ».
In : J. Discrete Algorithms 6.3 (2008), p. 433-448 (cf. p. 30, 36).
[50]
Stephen KLEENE. « Representation of events in nerve nets and ﬁnite automata ». In : Automata
Studies Ann. Math. Studies 34 (1956). Princeton U. Press, p. 3-41 (cf. p. 7).
[51]
Bartek KLIN et Julian SALAMANCA. « Iterated Covariant Powerset is not a Monad ». In : Electr.
Notes Theor. Comput. Sci. 341 (2018), p. 261-276 (cf. p. 77).
[52]
Will KURT. Get Programming with Haskell. Manning Publications, 2018. ISBN : 9781617293764
(cf. p. 63).
[53]
Dietrich KUSKE et Ingmar MEINECKE. « Construction of tree automata from regular expres-
sions ». In : RAIRO - Theor. Inf. and Applic. 45.3 (2011), p. 347-370. DOI : 10.1051/ita/2011107.
URL : https://doi.org/10.1051/ita/2011107 (cf. p. 20, 33, 170).
[54]
Éric LAUGEROTTE, Nadia Ouali SEBTI et Djelloul ZIADI. « From Regular Tree Expression to
Position Tree Automaton ». In : Language and Automata Theory and Applications - 7th Interna-
tional Conference, LATA 2013, Bilbao, Spain, April 2-5, 2013. Proceedings. Sous la dir. d’Adrian-
Horia DEDIU, Carlos MARTÍN-VIDE et Bianca TRUTHE. T. 7810. Lecture Notes in Compu-
ter Science. Springer, 2013, p. 395-406. DOI : 10 . 1007 / 978 - 3 - 642 - 37064 - 9 _ 35. URL :
https://doi.org/10.1007/978-3-642-37064-9_35 (cf. p. 166).
[55]
Éric LAUGEROTTE et al. « Multilinear representations of free pros ». In : Linear and Multilinear
Algebra 0.0 (2019), p. 1-45. DOI : 10.1080/03081087.2019.1566430.eprint : https://doi.org/10.1080/0308108
URL : https://doi.org/10.1080/03081087.2019.1566430 (cf. p. 1, 144, 183).
[56]
Michel LAZARD. « Lois de groupes et analyseurs ». In : Annales Scientiﬁques de l’Ecole Normale
Supérieure. T. 3. 72. 1955, p. 299-400 (cf. p. 8).
[57]
Sylvain LOMBARDY et Jacques SAKAROVITCH. « Derivatives of rational expressions with mul-
tiplicity ». In : Theor. Comput. Sci. 332.1-3 (2005), p. 141-177 (cf. p. 147, 158, 159).
[58]
Jean-Gabriel LUQUE, Ludovic MIGNOT et Florent NICART. « Some Combinatorial Operators in
Language Theory ». In : Journal of Automata, Languages and Combinatorics 18.1 (2013), p. 27-52
(cf. p. 1).
[59]
Saunders MACLANE. Categories for the Working Mathematician. Graduate Texts in Mathematics,
Vol. 5. New York : Springer-Verlag, 1971, p. ix+262 (cf. p. 108, 195).
[60]
Sandy MAGUIRE. Thinking with Types. Leanpub, 2019 (cf. p. 98).
[61]
Per MARTIN-LÖF. Intuitionistic type theory. T. 1. Studies in proof theory. Bibliopolis, 1984. ISBN :
978-88-7088-228-5 (cf. p. 98).
[62]
Jon Peter MAY. The geometry of iterated loop spaces. T. 271. Springer, 2006 (cf. p. 8).
[63]
Robert MCNAUGHTON et Hisao YAMADA. « Regular Expressions and State Graphs for Auto-
mata ». In : IRE Trans. Electronic Computers 9.1 (1960), p. 39-47. DOI : 10.1109/TEC.1960.5221603.
URL : https://doi.org/10.1109/TEC.1960.5221603 (cf. p. 7, 19).

188
Bibliographie
[64]
Ludovic MIGNOT. « Des Codes Barres pour les Langages Rationnels. (Bar Codes for Regular
Languages) ». Thèse de doct. University of Rouen, France, 2010. URL : https://tel.archives-ouvertes.fr/tel-0
(cf. p. 1).
[65]
Ludovic MIGNOT. Tree Automata Constructions. 2020. URL : http://ludovicmignot.free.fr/programmes/treeAut
(visité le 31/05/2020) (cf. p. 19).
[66]
Ludovic MIGNOT. Tree Automata Constructions. 2020. URL : http://ludovicmignot.free.fr/programmes/BottomU
(visité le 31/05/2020) (cf. p. 19).
[67]
Ludovic MIGNOT. Word Automata Constructions. 2020. URL : http://ludovicmignot.free.fr/programmes/WordAu
(visité le 31/05/2020) (cf. p. 19).
[68]
Ludovic MIGNOT, Nadia Ouali SEBTI et Djelloul ZIADI. « An Effcient Algorithm for the Construc-
tion of the Equation Tree Automaton ». In : Int. J. Found. Comput. Sci. () (cf. p. 29, 36).
[69]
Ludovic MIGNOT, Nadia Ouali SEBTI et Djelloul ZIADI. « An Efﬁcient Algorithm for the Equa-
tion Tree Automaton via the k-C-Continuations ». In : Language, Life, Limits - 10th Conference
on Computability in Europe, CiE 2014, Budapest, Hungary, June 23-27, 2014. Proceedings. Sous la
dir. d’Arnold BECKMANN, Erzsébet CSUHAJ-VARJÚ et Klaus MEER. T. 8493. Lecture Notes in
Computer Science. Springer, 2014, p. 303-313. DOI : 10.1007/978-3-319-08019-2_31. URL :
https://doi.org/10.1007/978-3-319-08019-2_31 (cf. p. 1, 29).
[70]
Ludovic MIGNOT, Nadia Ouali SEBTI et Djelloul ZIADI. « $k$-Position, Follow, Equation and
$k$-C-Continuation Tree Automata Constructions ». In : Proceedings 14th International Confe-
rence on Automata and Formal Languages, AFL 2014, Szeged, Hungary, May 27-29, 2014. Sous la dir.
de Zoltán ÉSIK et Zoltán FÜLÖP. T. 151. EPTCS. 2014, p. 327-341. DOI : 10.4204/EPTCS.151.23.
URL : https://doi.org/10.4204/EPTCS.151.23 (cf. p. 23, 27, 29).
[71]
Ludovic MIGNOT, Nadia Ouali SEBTI et Djelloul ZIADI. « Root-Weighted Tree Automata and
their Applications to Tree Kernels ». In : CoRR abs/1501.03895 (2015). arXiv : 1501.03895. URL :
http://arxiv.org/abs/1501.03895 (cf. p. 122).
[72]
Ludovic MIGNOT, Nadia Ouali SEBTI et Djelloul ZIADI. « Tree Automata Constructions from
Regular Expressions : a Comparative Study ». In : Fundam. Inform. 155 (2017), p. 1-26 (cf. p. 1,
23, 27, 29, 36).
[73]
Michael O. RABIN et Dana S. SCOTT. « Finite Automata and Their Decision Problems ». In :
IBM Journal of Research and Development 3.2 (1959), p. 114-125. DOI : 10.1147/rd.32.0114. URL :
https://doi.org/10.1147/rd.32.0114 (cf. p. 6).
[74]
Dominique REVUZ. « Minimization of acyclic deterministic automata in linear time ». In : Theor.
Comput. Sci. 92.1 (1992), p. 181-189 (cf. p. 36).
[75]
The UNIVALENT FOUNDATIONS PROGRAM. Homotopy Type Theory : Univalent Foundations of
Mathematics. Institute for Advanced Study : https://homotopytypetheory.org/book, 2013
(cf. p. 98).
[76]
Henning URBAT et Lutz SCHRÖDER. « Automata Learning : An Algebraic Approach ». In :
CoRR abs/1911.00874 (2019). arXiv : 1911.00874. URL : http://arxiv.org/abs/1911.00874
(cf. p. 63).
[77]
Djelloul ZIADI, Jean-Luc PONTY et Jean-Marc CHAMPARNAUD. « Passage d’une expression
rationnelle a un automate ﬁni non deterministe ». In : Bulletin of the Belgian Mathematical Society
- Simon Stevin 4 (1997), p. 177-203 (cf. p. 36).

189
Index
associativité
horizontale, 8
verticale, 8
automate
d’arbres
compressé, 13
des dérivées Bottom-Up, 57
de mots
déterministe, 5
non-déterministe, 4
à multiplicités, 6
des c-continuations, 31
des termes dérivés, 34
généralisé, 121
quotient
congruence Bottom-Up, 11
congruence Top-Down, 12
réduit, 36
Bottom-Up quotient, 45
catégorie, 67
automate sur une, 68
composition, 67
de Kleisli, 78
enrichie, 117
monoïdale, 104
morphismes, 67
objets, 67
produit, 102
composition
de fonctions, 3
congruence
Bottom-Up, 11
des parents, 42
Top-Down, 12
Construction d’automates
automate des parents, 41
compressé, 42
automate des positions Bottom-Up, 40
compressé, 41
Automates des Follows, 27
Automates des positions, 25
contexte, 45
dérivée partielle, 33
ensemble
des couples, 3
des fonctions, 3
des parents d’un arbre, 39
des racines d’un arbre, 39
gradué, 7
sommes, 3
expression
d’arbres
homogène étendue, 54
expression rationnelle, 6
d’arbres, 12
foncteur, 69
adjonction, 69
par isomorphisme, 71
par transformation naturelle, 72
de Kleisli, 141
enrichi, 134
fonction
graduée, 7
identité, 3
noyau d’une, 42
image d’un automate par un morphisme, 11
isomorphisme d’automates, 11
langage
dénoté par une expression rationnelle
d’arbres, 13
de mots, 7
rationnel, 7
reconnu par un automate
d’arbres, 10
de mots, 5
déterministe d’arbres, 10
déterministe de mots, 5
langage d’arbres
homogène, 44
monade, 76
libre, 150
monoïde, 4
commutatif, 4
libre, 4
multi-opérateurs, 129
monoïde objet, 107
morphisme
de monoïde, 4
de semimodule, 4
morphisme alphabétique, 11
morphisme d’automates, 11
morphisme de délinéarisation, 11

190
INDEX
opérade, 8
libre, 9
morphisme d’, 9
plus, 130
opération
délinéarisation, 23
linéarisation, 23
poids
d’un mot
dans un automate, 6
produit tensoriel
d’ensembles gradués, 97
quotient
d’un automate
compressé, 42
relation
similarité, 27
semianneau, 4
étoilé, 147
semimodule, 4
libre, 4
théorème
de Kleene, 7
transformation naturelle, 71
élément
généralisé, 120
indéﬁni, 3

191
Troisième partie
Annexes


193
A Automates de mots
Dans ce chapitre sont regroupés des exemples supplémentaires d’utilisation des différentes notions
présentées dans ce document n’ayant pas nécessairement leur place dans le ﬁl conducteur de la
discussion.
Nous y trouverons des extensions de constructions simplistes (k-DFAs), des généralisations d’algo-
rithmes (combinaisons booléennes quelconques de DFAs), des utilisations exotiques (produit paral-
lèle d’automates) ou des réinterprétations de constructions débouchant sur des extensions de mo-
délisations à la fois des implantations des automates mais également de construction classiques en
Haskell (automates séquentiels et monade Writer).
A.1
Automates à multiplicités séquentiels et monade Writer
Nous avons vu dans la Section 5.2.3 comment encoder les automates à multiplicités comme des
automates de Kleisli de la monade associée à la construction des semimodules libres. Ces automates
nécessitent la déﬁnition de la somme et du produit des semianneaux; le produit lors d’un parcours
pour combiner les poids des transitions successives pendant la traversée sur un chemin, et la somme
pour combiner les poids des différents chemins.
Les automates pour lesquels il n’existe au plus qu’un chemin par mot sont dits séquentiels, l’équi-
valent du qualiﬁcatif déterministe pour des poids non Booléens. Remarquons que si un automate est
séquentiel, la somme du semianneau n’est plus nécessaire; un monoïde est alors sufﬁsant. Ainsi, en
lieu d’un semimodule libre dont les éléments sont déﬁnis comme des sommes (formelles) de couples,
un produit cartésien est sufﬁsant.
Pour réaliser cela, il est possible d’utiliser le constructeur de type Writer du module
Control.Monad.Writer du package mtl, dont la déﬁnition est la suivante 1.
Code Pseudo-Haskell. 141: Le constructeur Writer
-- Constructeur binaire de types Writer
data Writer w a = Writer {runWriter :: (a, w)}
-- Fonctions permettant de récupérer la seconde composante du couple
-- contenu dans un Writer w a
execWriter :: Writer w a -> w
execWriter m = snd (runWriter m)
-- Permet de transformer une valeur de type w
-- en un élément pondérant un Writer
tell :: w -> Writer w ()
tell w = Writer ((), w)
Ce constructeur de type binaire, une fois complété par un type monoïdal, permet de déﬁnir une
monade.
Code Pseudo-Haskell. 142: Monade Writer
-- module HDRExample.WriterAutParProd
-- Le constructeur Writer w est un foncteur de
-- la catégorie des types
1. en réalité, à un isomorphisme près.

194
Annexe A. Automates de mots
instance FunctorGen (Writer w) (->) (->) where
fmap f (Writer (a, w)) = Writer (f a, w)
-- Le foncteur Writer w est une monade si w est un monoïde
instance Monoid w => MonadGen (Writer w) (->) where
join (Writer (Writer (a, w), w'))
= Writer (a, w <> w')
return a = Writer (a, mempty)
Un automate de Kleisli associé à cette monade est exactement un automate séquentiel. L’exemple
suivant construit un automate séquentiel à partir d’un prédicat test sur des symboles; plus précisé-
ment, il associe à un mot w, mot sur un type Symbol, le couple (c, w’) où
— c est l’entier de Symbols de w satisfaisant le prédicat test;
— w’ est le sous-mot de w constitué des Symbols satisfaisant test.
Pour cela, il sufﬁt d’utiliser comme structure de pondération le monoïde déﬁni comme le produit
tensoriel des monoïdes suivants : le monoïde additif des entiers (utilisant le constructeur de type
unaire Sum en Haskell) et le monoïde libre des Symbols (les listes en Haskell).
Remarque 38: Couple de monoïdes
En Haskell, un couple de monoïde est automatiquement une instance de la classe de types
monoïde.
instance (Semigroup w, Semigroup w') => Semigroup (w, w')
(x, y) <> (x, y') = (x <> y, x' <> y')
instance (Monoid w, Monoid w') => Monoid (w, w')
mempty = (mempty, mempty)
Remarquons que cette implantation correspond exactement au produit tensoriel direct de mo-
noïdes.
Code Pseudo-Haskell. 143: Exemple d’automate séquentiel
-- module HDRExample.WriterAutParProd
-- Définition de l'équivalence des valeurs ((), w) et w
instance Monoid n => Castable (Writer n ()) n where
cast
= execWriter
castInv = tell
-- Synonyme pour le type des états de l'automate (un seul état)
type StateAuto = ()
-- Automate comptant le nombre de symboles d'un mot w vérifiant le prédicat
-- donné en paramètre et renvoyant le sous mot de w formé des symboles
-- vérifiant le prédicat
autoCount
:: (Symbol -> Bool)
-> Automaton
(KleisliCat (Writer (Sum Int, [Symbol])) (->))
()
Symbol
StateAuto
()
autoCount test = packKleisli initial_b delta_b final_b
where
-- l'état initial est l'(unique) état () avec pour poids le couple
-- (0, [])
initial_b = writer ((), (Sum 0, []))
-- Après lecture de x, si ce symbole vérifie le prédicat,
-- on ajoute 1 et on concatène x;
-- sinon, on ajoute 0 et on concatène la chaine vide
delta_b x () | test x
= Writer ((), (Sum 1, [x]))
| otherwise = Writer ((), (Sum 0, []))
final_b :: () -> (Sum Int, [Symbol])
-- Le poids final de l'état () est neutre.
final_b () = (Sum 0, [])

A.1. Automates à multiplicités séquentiels et monade Writer
195
Tout comme la monade State (voir Section 5.2.4), la monade Writer admet des transformers, per-
mettant de combiner toute monade avec elle. Le type WriterT m w a, pour m une monade et w un
monoïde, est isomorphe au type m(a, w). Naturellement, on peut alors y associer des automates
de Kleisli. Remarquons alors qu’en choisissant la monade des listes, les valeurs sont des listes de
couples, relativement proches de la structure de semimodules libres; malheureusement, il n’est pas
possible en Haskell d’exprimer la monade des semimodules libres depuis un transformer de la mo-
nade Writer, la déﬁnition de base des monades y étant restreintes (d’où notre extension de départ).
Cependant, cette proximité soulève des questions intéressantes, prenant un sens concret en termes
catégoriques. Remarquons donc que :
— la monade Writer est isomorphe à un produit tensoriel, celui de la catégorie des types (le
produit cartésien) entre un monoïde et un type;
— la monade FreeSemimodule est isomorphe à un produit tensoriel, celui des monoïdes commu-
tatifs, entre un semianneau et un monoïde commutatif.
Remarque 39: Le produit tensoriel de monoïdes commutatifs
Le produit de deux monoïdes commutatifs M = (M, +, 0) et M′ = (M′, +′, 0′), est le mo-
noïde dont l’ensemble sous-jacent est l’ensemble des sommes formelles commutatives d’élé-
ments de M × M′, quotientée par la plus petite congruence générée par les trois équations
suivantes :
(x, z) ⊕(x, t) = (x, z +′ t),
(x, z) ⊕(y, z) = (x + y, z),
(0, z) = (0, 0′) = (x, 0′).
Dans les deux cas, une des composantes est un monoïde objet :
— pour la monade Writer, un monoïde est un monoïde objet de la catégorie des types;
— pour la monade FreeSemimodule, un semianneau est un monoïde objet de la catégorie des
monoïdes commutatifs (la multiplication du monoïde objet est la multiplication du semian-
neau).
Le produit tensoriel par un monoïde objet permet de généraliser la notion de module d’un semian-
neau. Un M-module [14, 59], pour un monoïde objet M = (M, µ, ν) d’une catégorie monoïdale
(C, ⊗, I, α, λ, ρ) est un couple (A, 7→) avec A un objet de C et 7→un morphisme de HomC(M ⊗A, A)
faisant commuter les diagrammes suivants :
M ⊗M ⊗A
M ⊗(M ⊗A)
M ⊗A
M ⊗A
A,
αM,M,A
µ ⊗IdA
IdM⊗7→
7→
7→
(A.1)
I ⊗A
M ⊗A
A.
λA
ν ⊗IdA
7→
(A.2)
Pour deux M-modules (A, 7→) et (A′, 7→′), un morphisme de module est un morphisme f de C faisant
commuter les diagrammes suivants :
M ⊗A
A
M ⊗A′
A′.
7→
IdM ⊗f
f
7→′
(A.3)
De plus, le foncteur envoyant le M-module (A, 7→) depuis la catégorie Mod(M) des M-modules sur
A dans la catégorie C, c’est-à-dire le foncteur d’oubli Forget, admet un adjoint à gauche FreeM [59]
envoyant un objet X de C sur le M-module (M ⊗X, (µ ⊗IdX) ◦α−1
M,M,X), le M-module libre généré par
X ; autrement dit,
HomC(X, A) ∼HomMod(M)(FreeM(X), (A, 7→)).
(A.4)

196
Annexe A. Automates de mots
Cette adjonction peut être déﬁnie par l’unité ηX = (ν ⊗IdX) ◦λ−1
X
envoyant X sur M ⊗X et la
co-unité ε(FreeM(A)) =7→envoyant (M ⊗A, (µ ⊗IdA) ◦α−1
M,M,A) sur (A, 7→). En effet, 7→est un mor-
phisme de module car satisfait l’Équation (A.3) :
M ⊗(M ⊗A)
M ⊗A
M ⊗A
A,
(µ ⊗IdA) ◦α−1
M,M,A
IdM⊗7→
7→
7→
en conséquence de la forme modiﬁée suivante de l’Équation (A.1) :
M ⊗M ⊗A
M ⊗(M ⊗A)
M ⊗A
M ⊗A
A.
µ ⊗IdA
α−1
M,M,A
IdM⊗7→
7→
7→
En conséquences directes,
— les automates à multiplicités peuvent être exprimés comme automates de Kleisli sur les mo-
nades des modules libres, généralisant la monade des semimodules libres;
— la monade Writer pourrait être généralisée autrement que par les transformers, en déﬁnissant
un type monadique
data WriterTens tensor w a = Writer {runWriter :: tensor (a, w)}
où tensor est un produit tensoriel d’une catégorie monoïdale et m un monoïde objet de cette
même catégorie monoïdale;
— la monade State pourrait être généralisée similairement.
Un exemple d’utilité d’une monade à base de module serait le cas d’une fonctionnalité de logs (uti-
lisation possible de la monade Writer) arborescents générés facilement à partir des opérades, les
monoïdes objets de la catégorie monoïdale des types gradués (voir Pseudo-Code 46 et Section 6.3).
A.2
Produits parallèles d’automates de types différents
Le produit parallèle d’automate est utilisé pour calculer, par exemple, l’union ou l’intersection de
deux automates déterministes (voir Remarque 21). Dans sa déﬁnition, rien n’empêche de combiner
deux automates de types différents. Par exemple, le code suivant montre comment combiner un
automate alternant (construit similairement à celui du Psudo-Code 55) et un automate séquentiel à
multiplicités (celui du Pseudo-Code 143) en un automate utilisant les deux parallèlement.
Code Pseudo-Haskell. 144: Produit parallèle d’automates
-- module HDRExample.WriterAutParProd
-- Synonymes de types
type Symbol = Char
type State = Maybe Char
-- Automate reconnaissant les mots contenant tous les symboles
-- d'une liste donnée en paramètre
autoForAll :: [Symbol] -> AFA Symbol State
autoForAll l = packKleisli (initial_a l) delta_a final_a
where
initial_a = foldr1 (<&&>) . fmap (packVar . Just)
delta_a x (Just y) | x == y
= packVar Nothing
| otherwise = packVar $ Just y
delta_a _ Nothing = packVar Nothing
final_a = isNothing
-- fonction de retrait des accents
removeAccents :: String -> String
removeAccents =

A.3. Utilisation des vecteurs
197
T.unpack . T.filter (not . property Diacritic) . normalize NFD . T.pack
-- teste si un caractère est une voyelle
isVowel :: Char -> Bool
isVowel c = fmap toLower (removeAccents [c]) `isInfixOf` "aeiouy"
-- instance facilitant l'extraction des poids de sortie de
-- l'automate autoForAll
instance (Castable (cat a c) e, Castable (cat' b d) f)
=> Castable (ProdCat cat cat' (a, b) (c, d)) (e, f) where
cast (Prod f g) = (cast f, cast g)
castInv (e, f) = Prod (castInv e) (castInv f)
-- Ouvre un fichier texte, puis pour chacun de ses mots (suite
-- de caractères suivies d'un séparateur d'espacement),
-- affiche ce mot et la chaine de ses voyelles
-- si les deux conditions suivantes sont respectées:
-- * le mot contient toutes les lettres de la chaine symbols,
-- * son nombre de voyelles est paire
testAFAFromFile :: String -> String -> IO ()
testAFAFromFile file symbols =
let auto = autoForAll symbols `parallelProduct` autoCount isVowel
aux w = do
let (reco, (p, res)) =
auto `weightValue` w :: (Bool, (Sum Int, String))
when (reco && getSum p `mod` 2 == 0)
(putStrLn $ mconcat ["- ", w, ": ", res])
in
do
f <- readFile file
let ws = words f
mapM_ aux ws
Cet exemple peut être utilisé pour ﬁltrer les mots contenus dans le ﬁchier file contenant toutes
les occurrences des lettres d’une chaîne chaine et un nombre pair de voyelles en lançant l’exé-
cutable déﬁni dans le ﬁchier MainParProd.hs par la commande stack exec AnnexeExAFA file
chaine. Ainsi, la commande stack exec AnnexeExAFA liste_francais.txt abcd afﬁchera la liste
des mots contenus dans le ﬁchier liste_francais.txt (à peu près 22000 mots) contenant les quatre
lettres a, b, c, d et ayant un nombre pair de voyelles.
A.3
Utilisation des vecteurs
Les vecteurs, c’est-à-dire les listes de longueur ﬁxée, peuvent être utilisés pour représenter des construc-
tions classiques, algorithmiques ou structurelles, de la théorie des automates. Par exemple, il est
possible d’exprimer la combinaison générale booléenne d’automates déterministes, sans utiliser des
combinaisons des opérations d’union, d’intersection ou de complémentaire (voir Remarque 21).
Code Pseudo-Haskell. 145: Combinaison Booléenne d’automates
-- module Automata.DFAComp
-- Soit f une fonction Booléenne n-aire et a1, ..., an
-- n DFAs.
-- boolCombi n f a1 ... an calcule la combinaison booléenne
-- associée à f des automates a1 ... an.
boolCombiOfCompDFA
:: Natural ( 'S n)
-> NFun ( 'S n) Bool Bool
-> DFAComp symbol state
-> NFun
n
(DFAComp symbol state)
(DFAComp symbol (Vector ( 'S n) state))
boolCombiOfCompDFA (Succ n) f aut = convertFromVectMultiFun' n $ \as ->
let autos = VCons aut as
in
pack

198
Annexe A. Automates de mots
(fmap (\(Auto i _ _) -> i ()) autos)
(\a ps -> combine (fmap (`delta` a) autos) ps)
(convertToVectMultiFun (packFun (Succ n) f) . combine (fmap final autos))
Ces mêmes vecteurs permettent de déﬁnir des représentations des k-DFAs, des automates détermi-
nistes ayant k états initiaux.
Code Pseudo-Haskell. 146: KDFAs
-- module Automata.DFAComp
toKDFA
:: Vector k state -> DFAComp symbol state -> DFAComp symbol (Vector k state)
toKDFA initial (Auto _ d f) =
pack initial (\a ps -> fmap (d a) ps) (or . fmap f)
Les constructions précédentes sont manipulables comme suit.
Code Pseudo-Haskell. 147: Exemple DFA complets
-- module HDRExample.DFAComp2
-- fonction auxiliaire de composition d'une fonction unaire
--
avec une fonction binaire.
(.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
(.:) = (.) . (.)
-- Fonction de transition modulaire; si p est une valeur
-- numérique entière, envoie p sur (p + 1) modulo n
deltaMod :: Integral state => state -> symbol -> state -> state
deltaMod n _ p = (p + 1) `mod` n
-- a1 reconnait les mots de longueurs multiples de 3
-- a2 reconnait les mots de longueurs multiples de 7
-- a3 reconnait les mots de longueurs multiples de 11
a1, a2, a3 :: DFAComp symbol Int
a1 = pack 0 (deltaMod 3) (== 0)
a2 = pack 0 (deltaMod 7) (== 0)
a3 = pack 0 (deltaMod 11) (== 0)
-- a4 reconnait les mots reconnus à la fois par
-- a1, a2 et a3
a4 :: DFAComp symbol (Vector Nat_3 Int)
a4 = boolCombiOfCompDFA three ((&&) .: (&&)) a1 a2 a3
-- a4 reconnait les mots reconnus par a1, a2
-- ou a3
a5 :: DFAComp symbol (Vector Nat_3 Int)
a5 = boolCombiOfCompDFA three ((||) .: (||)) a1 a2 a3
-- a6 correspond à l'automate a3 dans lequel les états 2 et 5 sont
-- initiaux
a6 :: DFAComp symbol (Vector Nat_2 Int)
a6 = toKDFA (2 <+> mkSingle 5) a3
-- Teste si le mot w est reconnu par les automates a1, ..., a6
test :: Show symbols => [symbols] -> IO ()
test w = do
putStrLn $ mconcat ["a1 recognizes ", show w, ": ", show (a1 `recognizes` w)]
putStrLn $ mconcat ["a2 recognizes ", show w, ": ", show (a2 `recognizes` w)]
putStrLn $ mconcat ["a3 recognizes ", show w, ": ", show (a3 `recognizes` w)]
putStrLn $ mconcat ["a4 recognizes ", show w, ": ", show (a4 `recognizes` w)]
putStrLn $ mconcat ["a5 recognizes ", show w, ": ", show (a5 `recognizes` w)]
putStrLn $ mconcat ["a6 recognizes ", show w, ": ", show (a6 `recognizes` w)]

