´Ecole doctorale IAEM Lorraine
Towards a compiler toolchain for
quantum programs
TH`ESE
pr´esent´ee et soutenue publiquement le 13 Janvier 2023
pour l’obtention du
Doctorat de l’Universit´e de Lorraine
(mention informatique)
par
Agust´ın Pablo Borgna
Composition du jury
Rapporteurs :
Bob Coecke
Quantinuum
Michael Mislove
Tulane University
Examinateurs :
Natacha Portier
ENS Lyon
Claudia Faggian
CNRS
Invit´e :
Miriam Backens
University of Birmingham
Encadrants :
Simon Perdrix
INRIA
Benoˆıt Valiron
CentraleSup´elec, Universit´e Paris-Saclay
Laboratoire Lorrain de Recherche en Informatique et ses Applications — UMR 7503
Laboratoire M´ethodes Formelles — UMR 9023

Mis en page avec la classe thesul.

Contents
Introduction
v
Chapter 1
Of Qubits and Quantum Machines
1
1.1
Quantum computation . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1.1
Hilbert spaces . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1.2
Pure quantum states . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.3
Quantum operators . . . . . . . . . . . . . . . . . . . . . . . .
2
1.1.4
Quantum measurement
. . . . . . . . . . . . . . . . . . . . .
4
1.1.5
Mixed quantum systems . . . . . . . . . . . . . . . . . . . . .
4
1.2
Quantum circuits . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.2.1
Single-qubit gates . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.2.2
Multi-qubit gates . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.3
Initialisation and measurement of qubits . . . . . . . . . . . .
8
1.2.4
Circuit interpretation
. . . . . . . . . . . . . . . . . . . . . .
8
1.2.5
Hybrid quantum-classical circuits . . . . . . . . . . . . . . . .
9
1.2.6
Universal gate sets . . . . . . . . . . . . . . . . . . . . . . . .
10
1.3
Quantum lambda calculi . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.4
Circuit-description languages
. . . . . . . . . . . . . . . . . . . . . .
12
Chapter 2
The ZX Calculus
2.1
The pure ZX calculus . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
i

Contents
2.2
Grounded ZX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
2.3
Semantics of the ZX and ZX⏚calculi . . . . . . . . . . . . . . . . . .
19
2.4
The Scalable ZX calculus . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.4.1
Flattening SZX diagrams
. . . . . . . . . . . . . . . . . . . .
24
2.5
SZX diagram families and list instantiation . . . . . . . . . . . . . . .
24
Chapter 3
Compiling high-level quantum programs into SZX diagrams
3.1
The λD calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
3.2
Operational Semantics of the λD calculus . . . . . . . . . . . . . . . .
35
3.3
Encoding programs as diagram families . . . . . . . . . . . . . . . . .
38
3.3.1
Parameter evaluation . . . . . . . . . . . . . . . . . . . . . . .
38
3.3.2
Diagram encoding
. . . . . . . . . . . . . . . . . . . . . . . .
44
3.4
Application example: QFT . . . . . . . . . . . . . . . . . . . . . . . .
53
Chapter 4
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
4.1
Graph-like diagrams and focused gFlow . . . . . . . . . . . . . . . . .
58
4.2
Translation of hybrid circuits
. . . . . . . . . . . . . . . . . . . . . .
61
4.3
Graph-theoretical circuit optimization
. . . . . . . . . . . . . . . . .
65
4.4
Grounded ZX optimization . . . . . . . . . . . . . . . . . . . . . . . .
66
4.5
Ground-cut simplification
. . . . . . . . . . . . . . . . . . . . . . . .
68
4.6
The Algorithm
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
4.7
Circuit extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
4.8
Extraction examples . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
4.9
Implementation and benchmarks
. . . . . . . . . . . . . . . . . . . .
75
Chapter 5
Classicality detection using ZX⏚diagrams
5.1
The classicalisation problem . . . . . . . . . . . . . . . . . . . . . . .
80
5.2
Labelled diagrams as hybrid circuits
. . . . . . . . . . . . . . . . . .
81
ii

5.3
Push-relabel algorithm . . . . . . . . . . . . . . . . . . . . . . . . . .
84
5.4
Global minima computation . . . . . . . . . . . . . . . . . . . . . . .
88
Conclusion
Bibliography
iii


Introduction
The theory of quantum mechanics has been around for more than a century. The
foundations of our current understanding were developed at the beginning of the 1900s
and has been refined ever since. This model has been used to successfully explain a
wide range of phenomena, from the behaviour of atoms and molecules to the nature
of light.
It’s only relatively recently that we have wielded the properties of quantum mech-
anics to develop a new model of computation that is fundamentally different from
the classical model. The execution of a quantum computing relies on some quantum
property of the system, be it the spin of an electron or the polarization of a photon.
It uses that degree of freedom to encode information as a superposition of states that
would be intractable to perform on a classical computer.
The development of quantum computing is still in its infancy. The first milestone
of Quantum Supremacy was achieved in 2019 [4], where a quantum computer was able
to solve a task that would take a classical computer an impractical amount of time.
However, the current state of quantum computing is still far from being able to solve
real world problems. The near-term era of quantum computers is commonly referred
to as Noisy Intermediate-Scale Quantum (NISQ) [60], where the quantum computers
are limited to a few hundred qubits and are highly subject to noise which can corrupt
the quantum state of the system. It is expected future quantum computers with a
higher number of qubits and less noisy operations will be able to implement fault-
tolerant schemes that will allow for the execution of more complex algorithms.
There are many research groups currently working on producing a quantum com-
puter. They are all trying to solve the same problem but utilise for that different
physical properties to encode the qubits. Nonetheless, most of these experimental
computers share a common interface based on the circuit model. In this model, a
quantum computer is composed of a set of qubits that can be initialized in a state
and then manipulated by a set of quantum gates. The qubits can also be measured,
which will collapse the quantum state and return a classical bit.
In the circuit model, a user sends a series of instructions to the quantum com-
puter by the user, including some measurements that return the classical result of
v

Introduction
the operation. However, a description of a complex algorithm in terms of low-level
operations may be tedious and error prone to produce, and it would be tied to the
specific set of gates available on the quantum computer. Instead, it is often more
convenient to use a higher-level programming language to abstract over the specific
sets of gates, and express generic operations such as working with lists of qubits or
performing conditional branches.
One such language is Quipper [42], which is a functional quantum programming
language able to generically manipulate circuits of qubits and can be compiled to a
variety of quantum computing backends. The language has multiple formalisations
of its semantics, including a recent variation called Proto-Quipper-D which contains
a dependent type system, where the type of a term may depend on the value of some
parameter.
It is the task of a quantum compiler to take a program written in a quantum
programming language such as Quipper and produce a quantum circuit tailored to
a specific architecture. This is normally a multi-stage process, where the program
passes through various intermediate representations where it can be optimized at
different abstraction levels.
In 2019, Duncan et al. [33] presented a new optimization procedure for quantum
circuits based on a formal graphical language called the ZX calculus, which gives a
more granular representation of linear maps than quantum circuits. ZX diagrams
can be seen as open graphs with two kinds of nodes tagged with some labels. The
calculus comes with a complete set of rewriting rules ensuring that we can rewrite
them while maintaining the same interpretation. The optimization method takes a
quantum circuit and effectively uses the ZX calculus as an intermediate representation
to reduce its size and the amount of resources required to execute it.
In this thesis, we present various contributions to the different stages of a quantum
compiler toolchain.
Our first contribution is the definition of a new intermediate
representation for quantum programs based on an extension of the ZX calculus called
Scalable ZX (SZX), which allows us to compactly represent quantum circuits repeated
structure. We introduce a non-trivial fragment of the Proto-Quipper-D language and
present its encoding into families of such SZX-diagrams, that can be used to optimize
recurrent segments of the program in a single optimization pass. This intermediate
representation can then be transformed into a ZX diagram or a quantum circuit to
continue the compilation process. This work was first presented at the International
Workshop on Programming Languages for Quantum Computing (PLanQC 2022), and
a full version was published in the proceedings of the Quantum Physics and Logic
Conference (QPL 2022) [9].
A second contribution of this work is the definition of a new optimization proced-
ure for quantum circuits containing both quantum and classical segments, based on
the method by Duncan et al. [33] We are able to use an extension of the ZX calculus
vi

called ZX Ground (ZX ) to represent such hybrid programs, and optimize programs
that encode some communication between the quantum and classical components. A
preliminary version of this work was first presented in the proceedings of the Inter-
national Workshop on Quantum Compilation (IWQC 2020), and finally published at
the Asian Symposium on Programming Languages and Systems (APLAS 2021) [11].
We have implemented our optimization procedure as an extension of the ZX-diagram
manipulation tool pyzx, and upstreamed some of the changes to the main repository.
Finally, our last contribution pertains to the detection of classical segments in a
hybrid quantum-classical circuit. Some automated optimization processes such as the
one we present may produce circuits that computes quantumly some operations that
could be performed classically using fewer resources. We formalise the classicalisa-
tion problem and present an eﬀicient heuristic to detect such segments. This work
was developed jointly with the optimization procedure for hybrid quantum-classical
circuits, and a succinct version was published along it at APLAS 2021 [11].
The rest of this thesis is organized as follows.
• In Chapter 1 we present the basic concepts of quantum computing and quantum
programming.
• In Chapter 2 we present the ZX calculus and its extensions SZX and ZX , used
throughout the rest of this work. We additionally define the families of SZX
diagrams and present a notation to easily instantiate a family multiple times in
a single diagram.
• In Chapter 3 we present our first contribution; the definition of a Proto-Quipper-
D fragment tailored to list manipulation, and its encoding into a new interme-
diate representation for quantum programs based on families of SZX-diagrams.
• In Chapter 4 we present our second contribution, the definition of a new op-
timization procedure for hybrid quantum-classical programs based on the pure
optimization by Duncan et al.
• In Chapter 5 we present our last contribution, the definition of a heuristic to
detect classical segments in a hybrid quantum-classical circuit.
vii


1
Of Qubits and Quantum Machines
Quantum computing is a growing field of research that is expected to have a large
impact on the future of computing. Quantum computers are able to solve problems
that are intractable for classical computers, and to do so in a much shorter time. This
is because quantum computers are able to exploit the quantum mechanical properties
of matter, which are not available to classical computers. In this chapter, we will give
a brief introduction to quantum mechanics focused on the properties that are relevant
to this work. We will then discuss the basic concepts of quantum computing, and the
advent of quantum programming languages for this new paradigm. For an extended
introduction to the topics presented in this chapter we refer the reader to [56].
1.1
Quantum computation
1.1.1
Hilbert spaces
Hilbert spaces are mathematical objects that are used to model quantum systems.
A Hilbert space H is a vector space equipped with an inner product ⟨·, ·⟩, which is
a conjugate symmetric bilinear map from the vector space to the complex or real
numbers. The inner product must satisfy the following three properties:
1. Conjugate symmetric: ⟨x, y⟩= ⟨y, x⟩
2. Linear: ⟨ax + by, z⟩= a⟨x, z⟩+ b⟨y, z⟩
3. Positive definite: ⟨x, x⟩≥0 and ⟨x, x⟩= 0 if and only if x = 0
From properties 1 and 2 it follows that the inner product is conjugate linear in its
second argument, ⟨x, ay + bz⟩= a⟨x, y⟩+ b⟨x, z⟩
1

Chapter 1.
Of Qubits and Quantum Machines
Example 1.1 The most common example of a Hilbert space, and the one used to
model finite-dimensional quantum systems, is the vector space Cn of n complex
numbers.
In this case, the inner product is defined by the standard dot product
⟨x, y⟩= ∑n
i=1 xiyi.
A useful way to represent vectors in a Hilbert space uses the Dirac notation, also
called braket notation. A vector v ∈H is represented as the ket |v⟩= ∑n
i=1 vi |i⟩,
where |i⟩is the i-th basis vector of the Hilbert space.
Correspondingly, a bra is
defined as the conjugate transpose ⟨v| = |v⟩∗The inner product between two vectors
v, w ∈H is then given directly by ⟨v|w⟩= ⟨v| |w⟩, and the norm of a vector is given
by ∥v∥=
√
⟨v|v⟩.
1.1.2
Pure quantum states
A quantum system is a composition of discrete elements called qubits. The state of
a system at a given time is described by a quantum state, characterised by a unitary
vector in the Hilbert space C2n for an n-qubit system.
The state of a single qubit system is commonly expressed as a linear combination
over the computational basis {|0⟩, |1⟩} = {(1, 0)†, (0, 1)†} or the diagonal matrix
{|+⟩, |−⟩} where |±⟩= |0⟩± |1⟩. A third, less commonly used basis called Y is
formed by the vectors |⟳⟩=
1
√
2(|0⟩+ i |1⟩) and |⟲⟩=
1
√
2(|0⟩−i |1⟩).
Multi-qubit spaces are described by the composition of smaller spaces using a
tensor product. Notice that while the spaces are compositions of smaller spaces, the
state of such multi-qubit state may not be separable into the tensor product of smaller
states. When this is the case, the state is said to be entangled.
Example 1.2 The state of a two-qubit system can be expressed as a vector in C2 ⊗
C2 = C4. Let |ϕ⟩= |00⟩+|01⟩
√
2
notice that |ϕ⟩is a separable state as it can be written as
the tensor product |0⟩⊗|+⟩. On the other hand, the state |ψ⟩= |00⟩+|11⟩
√
2
is entangled
as it cannot be written as a tensor product of single-qubit states.
1.1.3
Quantum operators
The evolution of a closed quantum system is described by a unitary operator acting
on the state of the system. A unitary operator is an operator U : H →H that
satisfies the following conditions:
1. Linear: U(x + y) = U(x) + U(y) and U(λx) = λU(x)
2. Invertible: UU −1 = I and U −1U = I
2

1.1.
Quantum computation
3. U −1 = U †
The action of a unitary operator U on a vector v is given by the matrix product
Uv. The inverse of a unitary operator U is given by U −1.
A consequence of the unitary property of quantum operators is that they do
not allow the duplication of information. This is known as the no-cloning theorem.
Indeed, suppose there is some unitary operator Un ∈C2n×2n and e ∈C2n such that for
any state |ϕ⟩∈C2n, U |ϕe⟩= |ϕϕ⟩. Then, the following must hold for any ϕ, ψ ∈C2n:
⟨ϕ|ψ⟩= ⟨ϕe|ψe⟩= ⟨ϕe| U † U |ψe⟩= ⟨ϕϕ|ψψ⟩= ⟨ϕ|ψ⟩2
Which does not hold for any non-orthogonal or equal states.
Example 1.3 The most common examples of single-qubit unitary operators are the
Pauli matrices σx, σy, σz. These operators are defined as follows:
σx =
(0
1
1
0
)
σy =
(0
−i
i
0
)
σz =
(1
0
0
−1
)
Each of these operators is self-adjoint, and therefore unitary. The action of these
operators on the computational basis is given by:
σx |0⟩= |1⟩
σy |0⟩= i |1⟩
σz |0⟩= |0⟩
σx |1⟩= |0⟩
σy |1⟩= −i |0⟩
σz |1⟩= −|1⟩
These operators are commonly used as the basic building blocks for more complex
operators, where they can be composed using the tensor product to operate over
multi-qubit systems.
Example 1.4 The Hadamard operator is a single-qubit unitary operator that maps
the computational basis {|0⟩, |1⟩} to the diagonal basis {|+⟩, |−⟩}:
H = 1
√
2
(1
1
1
−1
)
The action of the Hadamard operator on the computational basis is given by:
H |0⟩= 1
√
2(|0⟩+ |1⟩) = |+⟩,
H |1⟩= 1
√
2(|0⟩−|1⟩) = |−⟩.
3

Chapter 1.
Of Qubits and Quantum Machines
1.1.4
Quantum measurement
A measurement is the process by which a quantum system is observed. This process is
described by a collection of measurement operators {Mm} acting on the Hilbert space
of the system, for a set of measurement results {m}. The measurement operators are
required to satisfy the completeness condition:
∑
m
M †
mMm = I
When a measurement is performed, the state of the system |ϕ⟩is projected onto
one of the candidate measurement results. The probability of obtaining a given by
the following equation:
p(m) = ⟨ϕ| M †
mMm |ϕ⟩
The measurement process collapses the state of the system to the observed result,
producing a new state |ϕ′⟩given by:
|ϕ′⟩= Mm |ϕ⟩
√
p(m)
Example 1.5 The most common example of a measurement is a single-qubit meas-
urement in the computational basis. In this case, the measurement operators are
given by:
M0 = |0⟩⟨0|
M1 = |1⟩⟨1|
The probability of obtaining the result m given a state |ϕ⟩=
1
√
3 |0⟩+
√
2
√
3 |1⟩is:
p(0) = ⟨ϕ| M †
0M0 |ϕ⟩= ⟨ϕ| |0⟩⟨0| |ϕ⟩= 1
3
p(1) = ⟨ϕ| M †
1M1 |ϕ⟩= ⟨ϕ| |1⟩⟨1| |ϕ⟩= 2
3
After the measurement, the state will collapse to either the state |0⟩or |1⟩with
probability p(0) and p(1) respectively.
1.1.5
Mixed quantum systems
The previous presentation discussed closed quantum systems that are described by a
single pure state and completely isolated from the environment. However, in reality,
4

1.1.
Quantum computation
quantum systems are affected by the environment, and the state of the system may
not be a pure state but a probability distribution over multiple states, {(pi, |ϕi⟩)}.
This is known as a mixed state. In this case, the state of the system can be compactly
described by a density matrix ρ.
A density matrix ρ ∈C2n×2n is a positive semidefinite operator that satisfies the
following conditions:
1. Positive semidefinite: ⟨ϕ| ρ |ϕ⟩≥0 for all |ϕ⟩∈C2n
2. Hermitian: ρ† = ρ
3. Unitary trace: tr(ρ) = 1
Given a mixed state characterised by the probability distribution {(pi, |ϕi⟩)}, its
density matrix is given by ρ = ∑
i pi |ϕi⟩⟨ϕi|. A density matrix corresponds to a pure
state if and only if tr(ρ2) = 1.
Example 1.6 Consider a mixed quantum system in a state |+⟩that has been meas-
ured in the computational basis. The new state of the system is a probability distri-
bution {( 1
2, |0⟩), ( 1
2, |1⟩)}.
We can describe this mixed state using a density matrix:
ρ = 1
2 |0⟩⟨0| + 1
2 |1⟩⟨1| = 1
2
(1
0
0
1
)
Notice that this same density matrix can be obtained from the probability distri-
bution {( 1
2, |+⟩), ( 1
2, |−⟩)}, or generally from any other single-qubit orthogonal basis
where all the states are equally likely. This mixed state is commonly referred to as
the maximally mixed state.
The unitary and measurement operators can be applied over mixed states in a
similar way to pure states. The action of a unitary operator U on a mixed state is
given by:
ρ 7→UρU †
The application of a collection of measurement operators {Mm} to a mixed state,
can be described by the following equation:
ρ 7→
∑
m
p(m)MmρM †
m
5

Chapter 1.
Of Qubits and Quantum Machines
1.2
Quantum circuits
The most common representation of quantum computations is based on the circuit
model. In this model a quantum computer is a black box that contains a number
of qubits serving as a memory. This memory is interacted with using a fixed set of
quantum gates that apply elementary unitary operations to the qubits.
The composition of multiple quantum gates is known as a quantum circuit. The
circuit is depicted as a diagram where each gate is represented by a labelled box with
a set of horizontal input and output wires to its left and right respectively. In pure
circuits, each wire represents a qubit, and the input and output wires of a gate are
connected to the wires of the qubits that the gate acts on. When representing unitary
operations, the circuit will contain the same number of inputs and outputs.
It is also possible to represent non-unitary circuits that include classical data.
For this case, a second kind of wire depicted as double lines is used to represent
classical data in the form of bits. The gates may contain both types in their inputs
and outputs, and the composition must only be performed between compatible sets
of wires.
Example 1.1 The following is an example of a quantum circuit that performs the
quantum experiment known as the superdense coding protocol. In the rest of this
section, we will describe each part of the circuit in detail.
|
0
|
0
H
⊕
⊕Z
⊕
H
1.2.1
Single-qubit gates
The most basic quantum kind of gate is the single-qubit gate. The most common
examples of these gates are the Pauli gates, which apply the corresponding to the
Pauli operators σx, σy, and σz. These gates receive the name X, Y, and Z respectively.
A family of rotation gates can be derived by partially applying the Pauli gates.
These operators are defined by the equations
Rx(θ) = cos(θ/2)I −i sin(θ/2)X
=
( cos(θ/2)
−i sin(θ/2)
−i sin(θ/2)
cos(θ/2)
)
Ry(θ) = cos(θ/2)I −i sin(θ/2)Y
=
(cos(θ/2)
−sin(θ/2)
sin(θ/2)
cos(θ/2)
)
Rz(θ) = cos(θ/2)I −i sin(θ/2)Z
=
(e−iθ/2
0
0
eiθ/2
)
6

1.2.
Quantum circuits
Other commonly used gates include the Hadamard gate H, which applies the
Hadamard operator described in Section 1.1.3, the phase gate S, and the π/8 gate T.
The last two gates are defined by the equations:
S =
(1
0
0
i
)
T =
(1
0
0
eiπ/4
)
The S and T gates are partial applications of the Pauli Z gate. They satisfy the
following relation:
Z = S2 = T 4
1.2.2
Multi-qubit gates
In addition to single-qubit gates it is also possible to apply unitary operations to
multiple qubits simultaneously.
These operations are known as multi-qubit gates.
The most common example of a multi-qubit gate is the controlled-NOT gate, also
known as the CNOT gate or controlled-X gate. This gate is defined by the equation:
CNOT =




1
0
0
0
0
1
0
0
0
0
0
1
0
0
1
0




The CNOT gate can be thought of as a single-qubit X gate that is applied to the
second target qubit only when the first control qubit is in the state |1⟩. It is normally
represented using a special notation in quantum circuits:
⊕
There exists an extended version of the CNOT gate that contains two control
qubits, and only applies the X operation on the target when the controls are in the
state |11⟩. This gate is known as the Toffoli gate and is written as:
⊕
In general, we can define the controlled version of any unitary operator U as
C(U) =
(I
0
0
U
)
and depict it as follows:
U
7

Chapter 1.
Of Qubits and Quantum Machines
Notice that the Toffoli gate corresponds to a controlled-controlled-NOT, Toffoli =
C(CNOT) = C(C(X)).
A last example of a multi-qubit gate is simply the gate that swaps the states of
two qubits. This gate is known as the SWAP gate and is written as:
Its definition as a unitary operator is given by:
SWAP =




1
0
0
0
0
0
1
0
0
1
0
0
0
0
0
1




1.2.3
Initialisation and measurement of qubits
During the execution of a quantum circuit, it may be desired to store some auxiliary
information in the form of extra qubits. This information is known as an ancilla and
is represented by a qubit that is not present a an input or output of the circuit. The
ancilla qubit is initialized in the state |0⟩, and is used to store and modify the state of
other qubits. The ancilla is then discarded at the end of the computation. Similarly,
it is possible to write non unitary circuits that create or discard qubits in the middle
of the computation.
We represent the initialisation of new qubits in the state |0⟩and the discard
operation as follows:
|
0
|0
It is important to note that the discard operation requires the qubit to be in the state
|0⟩. If the qubit is in any other state, the discard operation will not preserve the norm
of the state and the circuit will not be valid. In terms of linear maps the operations
change the size of the vector space, either adding or removing a qubit:
init = |0⟩
terminate = ⟨0|
The termination of a qubit in an specific state is generally implemented as a
measurement of the qubit followed by an assertion of its value. If an incorrect value
is obtained the operation is aborted and the circuit is restarted. This is commonly
known as post-selection.
1.2.4
Circuit interpretation
A quantum circuit can be interpreted into completely positive maps (CPM) acting
over mixed quantum states. We denote the interpretation of a circuit C as JCK. We
8

1.2.
Quantum circuits
interpret a pure quantum gate described by the operator U as the following map:
r
U
z
= ρ 7→Uρ U †
The parallel and sequential composition of circuits is defined as follows:
r
U
V
z
=
r
V
z
◦
r
U
z
t
U
V
|
= ρu ⊗ρv 7→
r
U
z
(ρu) ⊗
r
V
z
(ρv)
1.2.5
Hybrid quantum-classical circuits
In addition to the quantum gates described above, it is also possible to combine
quantum and classical operations in the same circuit. This type of circuit is known as
a hybrid quantum-classical circuit and allows us to represent the interaction between
a quantum processor and a classical computer.
The classical part of the circuit is composed of classical gates, such as the well-
known NOT gate, AND gate, and XOR gate. These gates are interconnected using
classical wires that carry bits, represented by doubled lines. We use the traditional
notation for classical logic gates:
NOT :
XOR :
AND :
Since the classical gates operate over classical bits, their effect on the state of the
system can be written directly as collapsing the states to the computational basis.
We define these linear transformations as follows:
JNOTK := ρ 7→|0⟩⟨1| ρ |1⟩⟨0| + |1⟩⟨0| ρ |0⟩⟨1|
JXORK := ρ 7→
∑
i,j∈{0,1}
|(i ⊕j)⟩⟨ij| ρ |ij⟩⟨(i ⊕j)|
JANDK := ρ 7→
∑
i,j∈{0,1}
|(i ∗j)⟩⟨ij| ρ |ij⟩⟨(i ∗j)|
Additionally, we can also consider the fan-out and swap of wires as classical op-
erations:
r
z
:= ρ 7→
∑
i∈{0,1}
|ii⟩⟨i| ρ |i⟩⟨ii|
r
z
:= ρ 7→
∑
i,j∈{0,1}
|ji⟩⟨ij| ρ |ij⟩⟨ji|
9

Chapter 1.
Of Qubits and Quantum Machines
In the boundary between the quantum and classical parts of the circuit we must
also insert measurement operations to collapse the quantum state carried by qubit
wires into classical bits.
Symmetrically, we can also prepare a new qubit from a
classical bit using a preparation operation. The measurement operation is represented
as a box with a gauge symbol, and the preparation gate is represented as a vertical
line:
|
The interpretation of the measurement gate performs the operation described in Sec-
tion 1.1.4. Since the preparation gate always has a classical bit as input, it can be
described directly as the symmetric operation:
q
y
= ρ 7→
∑
i∈{0,1}
|i⟩⟨i| ρ |i⟩⟨i|
J |
K = ρ 7→
∑
i∈{0,1}
|i⟩⟨i| ρ |i⟩⟨i|
Classical qubits can be initialized and freely discarded, we include two special
gates to represent these operations, and interpret them as follows:
J |K = ρ 7→
∑
i∈{0,1}
⟨i| ρ |i⟩
J |
0
K = |0⟩⟨0|
Finally, we can define the classical counterpart of the quantum-controlled gates
presented in Section 1.2.2. The following gates correspond to a classically controlled
NOT and to a classically controlled Z gate, respectively:
⊕
Z
The interpretation of these gates is given by:
s
U
{
:= (J |K ⊗I) ◦
s
U
{
1.2.6
Universal gate sets
The different realisations of the circuit model may be better suited to apply some
gates more eﬀiciently than others. For example, a common set of gates provided by
experimental quantum processors is the set of operations {CNOT, Xα, Zα, H}.
Although the set of gates provided by a quantum processor may be limited, they
are generally capable of implementing any other quantum unitary by composing mul-
tiple gates. We call this kind of set of gates aa universal gate set. In some other cases,
the set of gates is not capable of exactly implementing all unitaries, but it is possible
to approximate to any desired precision. In this case, we call the set an approximate
universal gate set. Such is the case of the commonly used {CNOT, Rx, Rz, H, T} set.
10

1.3.
Quantum lambda calculi
1.3
Quantum lambda calculi
The quantum lambda calculus [64] is a quantum version of the lambda calculus, a
formalism that was developed by Church and Curry in the 1930s. The introduction
of the lambda calculus was a major step in the development of formal logic, as it
allowed the definition of a simple formal system that encapsulates the concept of
computation and can express arbitrarily complex computations. The original lambda
calculus [7] is a very simple language, with only three different syntactic constructs:
variables, abstractions and applications.
The lambda calculus is a powerful tool
for understanding the concept of computation and has been used to develop many
different formal systems of computation, such as the family of quantum lambda calculi
and a multitude of functional programming languages [51, 36, 49].
In general, the quantum lambda calculi manipulates quantum states or references
to qubits inside the terms. These definitions usually require a linear typing system to
ensure that well-typed terms do not copy the states, an operation which would violate
the no-cloning theorem. In a linearly typed system, any quantum variable is required
to be used exactly once in the term. This prevents both cloning the quantum state
and inadvertently discarding it. Sometimes a less strict variation using aﬀine types
is used instead, which allows a variable to be implicitly discarded.
An important categorization of quantum lambda calculi is whether they allow
quantum superposition of terms in addition to the quantum superposition of data.
Such a feature in a quantum calculus is called quantum control [68] as it allows to
model a program that can execute different code paths in superposition. This is a very
powerful feature, but it is also very diﬀicult to implement in a physically realizable
quantum computer. A quantum lambda calculus with support for quantum control
and data was described by Arrighi et al. [3], and further developed by Noriega and
Diaz-Caro [57].
In this work, we will work solely with classical control, quantum data lambda cal-
culi that do not allow superposition of terms, as dubbed by Selinger in [61]. This is
an assumption that closely matches the circuit architecture described in Section 1.2,
where a series of quantum operations are sent classically to the quantum processor.
A well-known formulation of a classical control, quantum data lambda calculus was
introduced by Selinger and Valiron [65] in 2009. They model the quantum compu-
tations as terms operating over pointers to qubits in an external quantum memory,
closely resembling the circuit architecture. They further ensure a valid use of the qubit
pointers by using a linear type system. Another formulation of a quantum lambda
calculus with similar features was introduced in 2017 by Diaz-Caro [32]. Their model
represents mixed quantum states using density matrices as part of the terms. A vari-
ation of their formulation expands on the concept of classical control by introducing
probabilistic choices between terms that do not allow for quantum superposition of
11

Chapter 1.
Of Qubits and Quantum Machines
terms.
A last property that is sometimes considered in quantum lambda calculi is having
a dependent type system [8]. This is a system where the type of a term can depend
on the value of some variable.
For example, it can be used to generically model
fixed-length lists of qubits. This is a very powerful feature, as it allows to generically
operate over different types of data.
For this work we will reference a quantum lambda calculus called Proto-Quipper-
D, introduced by Fu et al. [41], which introduces dependent types to model higher-
order operations over qubits. This feature is particularly interesting in relation to the
linear type system, as the requirement of using a variable exactly once may clash with
its use as a dependent parameter if not properly handled. This language departs from
the standard quantum lambda calculus model describing operations over quantum
states and instead takes the approach of the Circuit-description languages discussed
in Section 1.4, generating a list of quantum gate operations when evaluated.
1.4
Circuit-description languages
In the last decade a multitude of quantum programming languages have been pro-
posed to implement quantum algorithms.
Most of these languages are high-level
languages that are not intended to be directly compiled to a quantum processor,
but rather to be compiled to a more low-level language that can be compiled to a
quantum processor. These high-level languages have been designed with the goal of
being easy to read and understand, and to be able to express a wide range of quantum
algorithms.
The most notable quantum programming languages are the ones developed by
IBM, Google, and Microsoft. These languages are based on the Qiskit [37], Cirq [31],
and Q# [67] frameworks respectively. They are all based on the circuit-description
formalism and share a common set of quantum gates that are provided by the different
quantum processors. They also provide a way to describe a quantum circuits, and a
way to compile them to specific quantum architectures.
Another quantum programming language is Quipper [42], introduced by Green et
al. in 2013. The language is a functional programming model for quantum programs
and is closely related to the quantum lambda calculi. Although the original definition
implemented as a Haskell DSL does not use linear typing, a number of formal mod-
els of the language have been proposed under the name of Proto-Quipper [39, 40].
These extensions range from adding dependent types to the language, to allowing for
interactions between the quantum execution and program generation using dynamic
lifting of quantum programs. The former extension, called Proto-Quipper-D, has an
alternative description using the equally named lambda calculus by Fu et al. [41]
12

1.4.
Circuit-description languages
mentioned in Section 1.3.
Most high-level quantum programming languages are compiled into quantum cir-
cuit descriptions using a quantum assembly language. That is, a low-level language
that directly describes quantum circuits as a procedural list of operations applied over
explicitly declared quantum registers. These languages are at the lowest level rep-
resentation, that is then directly compiled to instructions for the quantum processor.
The usual choice for this representation is OpenQASM [25], which is a standard used
by most quantum processor providers to describe the quantum circuits that are to be
executed.
The translation between a high-level language and the OpenQASM representation
is usually done by a quantum compiler that in addition to performing a direct trans-
lation, may also perform a number of optimizations to reduce the number of gates
and the number of qubits required to implement the algorithm. This step allows
the high-level representation to ignore some of the technical details of the quantum
processor, and to focus on a simple encoding of the algorithms. In this work we will
discuss multiple contributions to the compilation pipeline for quantum programs.
13


2
The ZX Calculus
The ZX calculus is a formal graphical language which provides a fine-grained repres-
entation of quantum operations. In this chapter we give an introduction to it and
define a number of extensions that extend the representable operations and provide
compact representations of repeated structure. An extensive introduction to the fam-
ily of ZX calculi can be found in [69]. In Section 2.5 we introduce a novel definition
of families of diagrams that we will require for compiling high level languages in
Chapter 3.
2.1
The pure ZX calculus
In its pure version, the ZX calculus is a diagrammatic language that can encode any
linear map between qubits.
In particular, there is a direct translation from pure
quantum circuits representing unitary operators into ZX diagrams.
The building blocks of a ZX diagram are the so-called spiders. These are repres-
ented as vertices in a graph, annotated with a phase in [0, 2π). The spiders come in
two varieties, Z-spiders drawn as green dots and X-spiders drawn as red dots,
α
...
...
n
m
α
...
...
n
m
These spiders form the vertices of an open graph, with inputs on the left and outputs
on the right.
We can think of the phase of a spider as an angle of rotation on the corresponding
basis. For example, a Z-spiders with phase α and a single input and output represents
the same computation as a Rz(α) gate,
α
∼
Zα
15

Chapter 2.
The ZX Calculus
We call a spider with a phase in {0, π} a Pauli spider, since it represents a Pauli
operation. Similarly, when the phase is π
2 we call it a Clifford spider.
The spiders can have multiple inputs and outputs. We can interpret these as a
cloning and post-selection of the qubits over the corresponding basis. As a linear
map, they can be interpreted as:
α
...
...
n
m := |0⟩⊗m ⟨0|⊗n + eiα |1⟩⊗m ⟨1|⊗n
α
...
...
n
m := |+⟩⊗m ⟨+|⊗n + eiα |−⟩⊗m ⟨−|⊗n
There is a third generator of the ZX calculus that represents the Hadamard oper-
ator, drawn as a yellow box with exactly one input and output. It can be composed
from the Z and X spiders using Euler’s decomposition. To do so, we interconnect the
outputs and inputs of the spiders using wires that carry the information of one qubit.
=
−π
2
−π
2
−π
2
:= |+⟩⟨0| + |−⟩⟨1|
The straight wires of a ZX diagrams can be interpreted as simply identity oper-
ations, and the “curved” wires with only inputs or only outputs form similar maps.
We call these last two cups and caps.
:= |0⟩⟨0| + |1⟩⟨1|
:= ⟨00| + ⟨11|
:= |00⟩+ |11⟩
When composed together, we can see that the specific structure of the wires is
irrelevant to the semantics,
=
:=
|0⟩⟨0| + |1⟩⟨1|
=
:=
CNOT
In general, a ZX diagram can be freely deformed my moving the generators around
and bending the wires without changing the interpretation. We say that only the
topology matters, and therefore we can directly reason about the diagram as open
graphs.
In addition to the topological properties, we can define several equalities between
diagrams that let us rewrite parts of it without changing the semantics. Although
16

2.2.
Grounded ZX
multiple equalities are possible, here we present a small set that is complete [44]. This
means that if two ZX diagrams represent the same linear map, there is a sequence of
rules that transform one into the other.
β
...
...
α
...
...
=
...
...
...
α+β
(f)
−α
=
π
π
α
...
...
π
(π)
...
α
=
...
(c)
...
=
...
(h)
(i1)
=
=
(i2)
(b)
=
...
α
α
...
The rule (f) is called spider-fusion, as it takes multiple connected spiders of the
same colour and fuses them together, adding their phases. Similarly, (h) is referred
to as colour changing rule, as it swaps the colours of the generators. Using rules (h)
and (i2), we can swap the colours of all the diagrams and derive the same equalities
with the opposite colours.
For simplicity in our diagrams, we will sometimes use a notation in which we
replace solely the Hadamard boxes with Hadamard wires drawn in blue, as follows.
=
We introduce the following equation, derived by Duncan et al. [33], to remove
parallel Hadamard wires.
...
...
(fh)
=
...
...
We utilise !-box notation [54] to represent infinite families of diagrams with seg-
ments that can be repeated 0 or more times. In the following sections it will be
useful to use this notation for depicting more complex diagrams. Here we present an
example of its usage.
αi
∈{
,
α0 ,
α0
α1 , . . . }
2.2
Grounded ZX
The description of quantum algorithms commonly involves quantum operations in-
teracting with classical data in its inputs, outputs, or intermediary steps via meas-
urements or state preparations. Some applications such as quantum error correc-
tion [34, 28] and quantum assertions [50, 71] explicitly introduce classical measure-
ments and logic between quantum computations. In general, quantum programming
17

Chapter 2.
The ZX Calculus
languages usually allow for measurements and classically controlled quantum operat-
ors mixed-in with unitary gates [42, 25, 46, 66]. Furthermore, Jozsa [45] conjectured
that any polynomial-time quantum algorithm can be simulated by polylogarithmic-
depth quantum computation interleaved with polynomial-depth classical computa-
tion.
As such, there is interest in representing this kind of structures in the ZX
calculus.
The ZX
calculus [16] is an extension to the ZX-calculus which is able to easily
describe such interactions with the environment.
The diagrams have a standard
interpretation as completely positive linear maps between quantum mixed states, cf.
Section 2.3 for a formal description.
In addition to the ZX generators and rewrite rules, the calculus introduces a
ground generator ( ) which represents the tracing operation, or the discarding of
information. When connected to a degree-3 green spider, this can correspond to a
measurement operation over the computational basis or symmetrically to a qubit
initialization from a bit.
∼
∼
|
We refer to the spiders attached to
generators as
-spiders. Notice that we use the
same kind of wire for both classical and quantum data, since we can always carry the
information of the former over the latter. We will discuss a method to differentiate
between the two types of wire in a diagram by using the
-spiders in Chapter 5.
The ZX
calculus extends the set of rewriting rules with the following additions.
(k)
=
(l)=
α
(m)
=
(n)
=
Intuitively, the
generator discards any operation applied over a single qubit. Mul-
tiple discards can be combined into one via the following rule, derived from rules (m),
(n), and (k).
(gg)
=
When using the Hadamard wire notation, we can use a ground to discard such
wires using a combination of rules (m) and (l).
...
(ml)
=
...
Example 2.1 Using the ZX
calculus, it is then possible to encode hybrid quantum-
classical experiments as diagrams. For example, consider the following circuit repres-
18

2.3.
Semantics of the ZX and ZX⏚calculi
entation of the quantum teleportation protocol.
|
0
|
0
H
⊕
⊕
Z
⊕
H
We can encode the same operations as a ZX
diagram as follows.
2.3
Semantics of the ZX and ZX⏚calculi
Carette et al. [16] define an interpretation of ZX
diagrams using a CPM construc-
tion [62]. We describe it here without the categorical language, as an interpretation
of diagrams into density matrices and completely positive maps modulo scalars. This
definition can be used for the pure ZX calculus as well, by ignoring the cases pertain-
ing the
generator.
Let Dn ⊆C2n×2n be the set of n-qubit density matrices. There exists a functor
J·K : ZX
→CPM(Qubit) which associates to any diagram D : n →m a completely
positive map JDK : Dn →Dm, inductively defined as follows.
JD1 ⊗D2K := JD1K ⊗JD2K
JD2 ◦D1K := JD2K ◦JD1K
q
y
:=
(
1
)
J α K :=
(
1 + e2iα)
J
K := id
q
y
:= ρ 7→U ρ U †
where U=|00⟩⟨00|+|01⟩⟨10|+|10⟩⟨01|+|11⟩⟨11|
J
K := ρ 7→H ρ H†
where H= 1
√
2

1
1
1
−1


J
K := |0⟩⟨0| + |1⟩⟨1|
J
K := ρ 7→⟨0| ρ |0⟩+ ⟨1| ρ |1⟩
s
α
...
...
n
m
{
:= ρ 7→A ρ A† if n + m > 0, where A=|0m⟩⟨0n|+eiα|1m⟩⟨1n|
s
α
...
...
n
m
{
:= J
K⊗m ◦
s
α
...
...
n
m
{
◦J
K⊗n
19

Chapter 2.
The ZX Calculus
From the compositional rules, we can see that a ground attached to a green spider
corresponds to a measurement over the computational basis.
t
α
...
...
n
m
|
:= ρ 7→|0m⟩⟨0n| ρ |0n⟩⟨0m| + |1m⟩⟨1n| ρ |1n⟩⟨1m|
It follows from rule (h) that the red
-spider corresponds to a measurement over
the diagonal basis:
t
α
...
...
n
m
|
:= ρ 7→|+m⟩⟨+n| ρ |+n⟩⟨+m| + |−m⟩⟨−n| ρ |−n⟩⟨−m|
Notice that, in accordance to rule (m), the phase of a
-spider is irrelevant.
2.4
The Scalable ZX calculus
The ZX calculus as presented in Section 2.1 is a powerful tool for reasoning about
quantum systems. However, it is not very eﬀicient for large operations with repeated
structure. Consider, for example, a parallel application of Z rotations over a n-qubit
register. To represent such operation a ZX-diagram requires n different green spiders
composed in parallel. This linearly growing diagram can be replaced with a single-
node diagram using the Scalable extension to the ZX-calculus.
The SZX calculus [15, 13] is an extension to the ZX calculus that generalizes the
primitive constructors to work with arbitrarily sized qubit registers. This facilitates
the representation of diagrams with repeated structure in a compact manner. Carette
et al. [13] have shown that the scalable and the grounded extensions described in
Section 2.2 can be directly composed, the resulting SZX
calculus will be referred to
directly as SZX for simplicity.
Bold wires in a SZX diagram are tagged with a non-negative integer representing
the size of the qubit register they carry, and other generators are marked in bold
to represent a parallel application over each qubit in the register. Bold spiders with
multiplicity k are tagged with k-sized vectors of phases α = α1 :: · · · :: αk. Diagrams
in the SZX calculus can be typed according to their input and output wires. We write
1k to denote a wire multiplicity k, and 1k ⊗1l to denote the parallel composition of
two wires. For simplicity we will write nk = ⊗n
i=1 1k. A diagram is then typed as
the map between two wire multiplicities. The natural extension of the ZX generators
correspond to the following primitives:
k
: 1k →1k
: 0k →0k
20

2.4.
The Scalable ZX calculus
k
: 00 →2k
k : 2k →00
k
l
: 1k ⊗1l →1l ⊗1k
−
→
α
...
...
k
k
k
k
n
m : nk →mk
−
→
α
...
...
k
k
k
k
n
m : nk →mk
k
k : 1k →1k
k
: 1k →00
Wires of multiplicity zero are equivalent to the empty mapping. The cup and cap
primitives that connect two outputs or two inputs together bend the wires while
keeping the internal order of qubits in each register. We may omit writing the wire
multiplicity if it can be deduced by context.
The extension defines two additional generators; a split node to split registers into
multiple wires, and a function arrow to apply arbitrary functions over a register. In
this work we restrict the arrow functions to permutations σ : [0 . . . k) →[0 . . . k) that
rearrange the order of the wires. Cf. [13] for a description of the calculus including
the generalized arrow generators. Using the split node and the wire primitives we can
derive the rotated version, which we call a gather.
n
n + m
m : 1n+m →1n ⊗1m
n
n + m
m
: 1n ⊗1m →1n+m
σ
: 1k →1k
We reproduce here the standard interpretation of SZX
diagrams as density
matrices and completely positive maps [16, 13], modulo scalars. Let Dn ⊆C2n×2n be
the set of n-qubit density matrices. We define the functor J·K : ZX
→CPM(Qubit)
which associates to any diagram D : n →m a completely positive map JDK : Dn →
Dm, inductively as follows.
JD1 ⊗D2K := JD1K ⊗JD2K
JD2 ◦D1K := JD2K ◦JD1K
J k
k K := ρ 7→V ρ V † where V =
∑
x,y∈Fk
2
(−1)x•y |y⟩⟨x|
t
−
→
α
...
...
k
k
k
k
n
m
|
:= ρ 7→V ρ V † where V =
∑
x∈Fk
2
eix•−
→
α |x⟩⊗m ⟨x|⊗n
t
−
→
α
...
...
k
k
k
k
n
m
|
:= J k
k K⊗m ◦
t
−
→
α
...
...
k
k
k
k
n
m
|
◦J k
k K⊗n
J k K := ρ 7→
∑
x∈Fk
2
⟨x| ρ |x⟩
J
k K :=
∑
x∈Fk
2
|x⟩⟨x|
J
k
K := ρ 7→ρ
s n
n + m
m
{
:= ρ 7→ρ
r
σ
z
:= ρ 7→V ρ V † where V =
∑
x∈Fk
2
|σ(x)⟩⟨x|
21

Chapter 2.
The ZX Calculus
q
ky
:= ρ 7→
∑
x∈Fk
2
⟨xx| ρ |xx⟩
q
k y
:=
∑
x∈Fk
2
|xx⟩⟨xx|
r
z
:= Id0
s k
l {
:= ρ 7→V ρ V † where V =
∑
x∈Fk
2,y∈Fl
2
|yx⟩⟨xy|
where ∀u, v ∈Rn, u • v = ∑m
i=1 uivi.
The SZX
calculus defines a set of rewrite rules by extending the ones of the ZX
calculus and including extra rules pertaining the gathers. We show this definition
below.
β
...
...
α
...
...
=
...
...
...
α+β
(f)
−α
=
π
π
α
...
...
π
(π)
...
α
=
...
(c)
...
=
...
(h)
(i1)
=
=
(i2)
(b)
=
...
α
α
...
(k)
=
(l)=
α
(m)
=
(n)
=
n+m
n+m
n
m
(sg)
=
n+m
n+m
n
m
n
m
(gs)
=
m
n
−
→
α
...
=
...
−
→
β
(z2)
−
→
α :: −
→
β
=
(w)
(z1)
=
=
(z3)
Additionally, for the arrows restricted to permutations of wires we include the
following rules [13]:
=
(p1)
σ
=
(p)
σ
...
...
...
σ
σ−1
−
→
α
σ(−
→
α )
=
(p2)
...
...
σ
σ
σ
σ
σ
=
(p3)
=
(p4)
...
...
σ1 ⊗σ2
σ1
σ2
From the rewriting rules of the calculus, it follows that the wires of a SZX diagram
can be freely deformed, and therefore it can be considered as an open graph where
22

2.4.
The Scalable ZX calculus
only the topology of its nodes and edges matters. We may also depict composition
of gathers as single multi-legged generators. In an analogous manner, we will use a
legless gather
to terminate wires with cardinality zero. This could be encoded as
the zero-multiplicity spider
[ ] , which represents the empty mapping.
Since wires with cardinality zero correspond to empty mappings they can be
discarded from the diagrams. The additional reduction rules representing this equi-
valence are given below.
...
=
...
(∅1)
[ ]
...
0
0
0
0
...
=
(∅2)
0
0
0
n
=
(∅4)
n
0
n
=
(∅3)
0
0
0
=
(∅w)
0
Carette et al. [13] showed that the SZX calculus can encode the repetition of a
function f : 1n →1n an arbitrary number of times k ≥1 as follows:
kn
n
n
fk
kn
(k−1)n
=
(
n f
n )k
where f k corresponds to k parallel applications of f. With a simple modification we
can extend this construction to be able to encode an accumulating map operation.
Lemma 2.1 Let g : 1n ⊗1s →1m ⊗1s and k ≥1, then
ks
s
s
gk
ks
(k−1)s
kn
km
=
s
g
kn
km
. . .
. . .
g
s
. . .
n
n
m
m
Proof By induction on k. If k = 1,
s
s
s
g
s
0
n
m
(i1,∅1)
=
s
s
s
g
s
0
n
m
(∅4)
=
s
g
s
n
m
If k > 1,
ks
s
s
gk
ks
(k−1)s
kn
km
def
=
ks
s
s
gk−1
ks
(k−1)s
kn
km
g
m
n
(k−1)s
(k−1)s
(gs)
=
s
s
gk−1
(k−2)s
kn
km
g
m
n
(k−1)s
(k−1)s
s
=
s
s
gk−1
(k−2)s
kn
km
g
m
n
(k−1)s
(k−1)s
s
(k−1)n
(k−1)m
HI
=
s
g
kn
km
. . .
. . .
g
s
. . .
n
n
m
m
□
As an example, given a list N = [n1, n2, n3] and a starting accumulator value x0,
this construction would produce the mapping ([n1, n2, n3], x0) 7→([m1, m2, m3], x3)
where (mi, xi) = g(ni, xi−1) for i ∈1 . . . 3.
23

Chapter 2.
The ZX Calculus
2.4.1
Flattening SZX diagrams
Given a SZX diagram, it can always be flattened into a ZX diagram by translating
the bold generators into multiple ZX generators composed in parallel.
Example 2.2 The following SZX diagram manipulating wires of size two can be
flattened into a ZX diagram by cloning the spider and assigning the corresponding
phases. Notice that the gather generator is simply a rearrangement of wires in the
flattened diagram.
=
π, π
2
2
2
π
π
2
2
Using this flat interpretation, we can directly reason about the underlying open-
graph of a SZX diagram. Notice, however, that the size of the graph depends directly
on the multiplicity of the diagram generators, and may be much larger than the size
of the diagram itself. In addition, each member of a diagram family may have a
different underlying graph and must be considered separately.
2.5
SZX diagram families and list instantiation
In addition to the compact representation allowed by the scalable extension, in some
cases we want to represent generic operations indexed by an external variable. In this
section we discuss a new definition of families of diagrams and introduce a syntactic
sugar we call list instantiation to quickly describe such generic diagrams.
We introduce the definition of a family of SZX diagrams D : Nk →D as a
function from k integer parameters to SZX diagrams. We require the structure of the
diagrams to be the same for all elements in the family, parameters may only alter the
wire tags and spider phases. Partial application is allowed, we write D(n) to fix the
first parameter of D.
Example 2.1 The following example describes a family of diagrams D that applies
Z-rotations with angle π/n on n + 1 qubits.
D := n 7→
π
n
n+1
n+1
Since instantiations of a family share the same structure, we can compose them in
parallel by merging the different values of wire tags and spider phases. We introduce
a shorthand for instantiating a family of diagrams on multiple values and combining
the resulting diagrams in parallel. This definition is strictly more general than the
thickening endofunctor presented by Carette et al. [13], which replicates a concrete
diagram in parallel. A list instantiation of a family of diagrams D : Nk+1 →D over a
24

2.5.
SZX diagram families and list instantiation
list N of integers is written as (D(n), n ∈N). This results in a family with one fewer
parameter, (D(n), n ∈N) : Nk →D. We graphically depict a list instantiation as a
dashed box in a diagram, as follows.
D(n)
n ∈N
:=
D(n)
n∈N
The definition of the list instantiation operator is given recursively on the con-
struction of D below. On the diagram wires we use v(N) to denote the wire cardinality
∑
n∈N v(n), −→
α (N) for the concatenation of phase vectors −→
α (n1) :: · · · :: −→
α (nm), and
σ(N) for the composition of permutations ⊗
n∈N σ(n). In general, a permutation
arrow σ(N, v, w) instantiated in concrete values can be replaced by a reordering of
wires between two gather gates using the rewrite rule (p).
Given D : Nk+1 →D, N = [n1, . . . , nm] ∈Nm,
((D1 ⊗D2)(n), n ∈N) := (D1(n), n ∈N) ⊗(D2(n), n ∈N)
n ∈N
v(n)
v(N)
v(N)
:=
v(N)
((D2 ◦D1)(n), n ∈N) := (D2(n), n ∈N) ◦(D1(n), n ∈N)
n ∈N
v(n)
v(N)
:=
v(N)
n ∈N
v(n)
v(n)
v(N)
v(N)
:=
v(N)
v(N)
n ∈N
v(n)
v(n)
σ(N)
v(N)
v(N)
:=
σ(N)
v(N)
v(N)
n ∈N
−
→
α (n)
v(n)
v(n)
v(n)
v(n)
v(N)
v(N)
v(N)
v(N)
...
...
:=
−
→
α (N)
v(N)
v(N)
v(N)
v(N)
...
...
n ∈N
−
→
α (n)
v(n)
v(n)
v(n)
v(n)
v(N)
v(N)
v(N)
v(N)
...
...
:=
−
→
α (N)
v(N)
v(N)
v(N)
v(N)
...
...
n ∈N
v(n)
v(n)+w(n)
w(n)
(v+w)(N)
w(N)
v(N)
:=
(v+w)(N)
w(N)
v(N)
σ(N,v,w)
v(N)+w(N)
Where σ(N, v, w) ∈Fv(N)+w(N)×v(N)+w(N)
2
is the permutation defined as the matrix
σ(N, v, w) =
(σN
f |σN
g
)
,
σN
f ∈Fv(N)+w(N)×v(N)
2
, σN
g ∈Fv(N)+w(N)×w(N)
2
25

Chapter 2.
The ZX Calculus
σ[ ]
f = Id0
σn::N′
f
=


Idv(n)
0
0
0
0
σN′
f


σ[ ]
g = Id0
σn::N′
g
=


0
0
Idw(n)
0
0
σN′
g


A list instantiation of a family of diagrams is equivalent to composing all the
individual family instantiations in parallel, as proven by Lemmas 2.2 and 2.3. But in
contrast to doing a parallel composition, we show in Lemma 2.4 that such operation
adds a small number of additional nodes independently of the size of the list.
Lemma 2.2 For any diagram family D, n0 : N, N : Nk,
D(n)
n∈n0::N
=
D(n)
n∈N
D(n0)
Proof By induction on the term construction
• If D is a gather,
(v+w)(n::N)
w(n::N)
v(n::N)
σ(n::N,v,w)
v(n::N)+w(n::N)
(p)
=
(v+w)(n::N)
w(n::N)
v(n::N)
σ(N,v,w)
v(N)+w(N)
Idw(n)
Idv(n)
v(N)+w(N)
v(n)
v(n)
w(n)
w(n)
w(N)
w(N)
v(N)
v(N)
(sg,gs,p)
=
(v+w)(n::N)
w(n::N)
v(n::N)
σ(N,v,w)
v(N)+w(N)
(v+w)(N)
v(n)
(v+w)(n)
w(n)
w(N)
v(N)
• The other cases can be directly derived from the commutation properties of the
gather generator via rules (z1), (z2), (z3), (w), and (p4).
□
Lemma 2.3 A diagram family initialized with the empty list corresponds to the
empty map. For any diagram family D,
D(n)
n∈[ ]
0
0 =
0
0
Proof Notice that any wire in the initialized diagrams has cardinality zero.
By
rules (∅1), (∅2), (∅3), (∅4), and (∅w) every internal node can be eliminated from the
diagram.
□
26

2.5.
SZX diagram families and list instantiation
Lemma 2.4 The list instantiation procedure on an n-node diagram family adds O(n)
nodes to the original diagram.
Proof By induction on the term construction. Notice that the instantiation of any
term except the gather does not introduce any new nodes, and the gather introduction
creates exactly one extra node. Therefore, the list instantiation adds a number of
nodes equal to the number of gather generators in the diagram.
□
27


3
Compiling high-level quantum
programs into SZX diagrams
The ZX calculus is a powerful tool when used as an intermediate representation
language for quantum compilers. In this line it has successfully been used for the
compilation and verification of quantum programs and quantum circuits.
Indeed, starting from a quantum circuit we are able to obtain an equivalent ZX
representation directly by translating each gate into a small number of nodes. In
Chapter 4 we will see an instance of a translation that generates diagrams with a
similar size to the original circuit.
While the ZX calculus proves to be a good representation for specific quantum
maps, it suffers the same limitation as the quantum circuits in that it cannot express
generic operations with parametric iteration or parallelism. As an example, a function
applying a quantum gate over each qubit in a register would be required to define
the exact number of qubits before compiling it into a diagram with a proportional
number of nodes.
An alternative representation of quantum programs can be obtained using families
of SZX diagrams, introduced in Section 2.4. In this chapter we show how this ex-
tension can be used as an eﬀicient intermediate representation to encode parametric
parallel and iterative operations in constant-sized diagrams.
The Proto-Quipper-D language described in Section 1.4 is a powerful language
for describing high-level quantum operations. This instance of the Proto-Quipper-
D family includes support for dependently typed functions. Such capability allows
encoding a function like the previously mentioned parallel gate application with an
explicit natural parameter indicating the number of qubits to be used.
The full language however can describe operations that cannot be encoded as
SZX diagrams, such as non-terminating operations and unbounded recursion.
As
such, we are required to define a less expressive fragment of the language that can be
29

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
completely encoded as SZX diagrams.
We start this chapter by introducing a suitable starting language based on Proto-
Quipper-D in Section 3.1 and then define a compilation procedure for it in Section 3.3.
Finally, in Section 3.4 we show an example encoding of the generic Quantum Fourier
Transform (QFT) as a SZX diagram family.
3.1
The λD calculus
We begin by defining a starting language from where to define a complete translation
into SZX diagram families. In this section we present the calculus λD, as a subset of
the strongly normalizing Proto-Quipper-D programs.
The calculus includes products, fixed length vectors, natural numbers, and a num-
ber of quantum primitives. Terms are inductively defined by:
M, N, L := x | C | R | U | 0 | 1 | n | meas | new |λxS.M | M N | λ′xP.M | M @ N |
⋆| M ⊗N | let xS1 ⊗yS2 = M in N | M; N |
VNilA | M :: N | let xS :: yVec n S = M in N
M□N | ifz L then M else N | for kP in M do N
where C is a set of implicit bounded recursive primitives used for operating over vec-
tors and describing iterating functions, n ∈N, □∈{+, −, ×, /, ∧} and ifz L then M
else N is a conditional branching with a test-for-zero guard.
Here U denotes a set of unitary operations and R is a phase shift gate with a
parametrized angle. In this article we arbitrarily fix the former to the CNOT and
Hadamard (H) gates and the latter to the arbitrary rotation gates Rz(α) and Rx(α),
forming a universal quantum gate set.
For the remaining constants, 0 and 1 represent bits, new is used to create a qubit,
and meas to measure it. ⋆is the inhabitant of the Unit type, and the sequence M; N
is used to eliminate it. Qubits can be combined via the tensor product M ⊗N with
let xS1 ⊗yS2 = M in N as its corresponding destructor.
The system supports lists; VNilA represents the empty list, M :: N the con-
structor and let xS :: yVec n S = M in N acts as the destructor. Finally, the term
for kP in M do N allows iterating over parameter lists.
The typing system is defined in Figure 3.1. We write |Φ| for the list of variables
in a typing context Φ. The type Vec n A represents a vector of known length n with
elements of type A.
We differentiate between state contexts (Noted with Γ and ∆) and parameter
contexts (Noted with Φ). For our case of study, parameter contexts consist only of
pairs x : Nat or x : Vec (n : Nat) Nat, since they are the only non-linear types of
30

3.1.
The λD calculus
variables that we manage. Every other variable falls under the state context. The
terms λxS.M and MN correspond to the abstraction and application which will be
used for state-typed terms. The analogous constructions for parameter-typed terms
are λ′xP.M and M @N.
In this sense we deviate from the original Proto-Quipper-D type system, which
supports a single context decorated with indices. Instead, we use a linear and non-
linear approach similar to the work of Cervesato and Pfenning[19].
A key difference between Quipper (and, by extension, Proto-Quipper-D) and λD
is the approach to defining circuits. In Quipper, circuits are an intrinsic part of the
language and can be operated upon. In our case, the translation into SZX diagrams
will be mediated with a function defined outside the language.
Types are divided into two kinds: parameter and state types. Both can depend
on terms of type Nat. For the scope of this work, this dependence may only influence
the size of vector types.
Parameter types represent non-linear variable types which are known at the time of
generation of the concrete quantum operations. In the translation into SZX diagrams,
these variables may dictate the labels of the wires and spiders. Vectors of Nat terms
represent their cartesian product. On the other hand, state types correspond to the
quantum operations and states to be computed. In the translation, these terms inform
the shape and composition of the diagrams. Vectors of state type terms represent
their tensor product.
In lieu of unbounded and implicit recursion, we define a series of primitive func-
tions for performing explicit vector manipulation. These primitives can be defined in
the original language, with the advantage of them being strongly normalizing. The
first four primitives are used to manage state vectors, while the last one is used for
generating parameters. For ease of translation some terms are decorated with type
annotations. However, we will omit these for clarity when the type is apparent.
accuMapA,B,C : (n : Nat) →
Vec n A ⊸Vec n (A ⊸C ⊸B ⊗C) ⊸C ⊸(Vec n B) ⊗C
splitA : (n : Nat) →(m : Nat) →Vec (n + m) A ⊸Vec n A ⊗Vec m A
appendA : (n : Nat) →(m : Nat) →Vec n A ⊸Vec m A ⊸Vec (n + m) A
drop : (n : Nat) →Vec n Unit ⊸Unit
range : (n : Nat) →(m : Nat) →Vec (m −n) Nat
These primitives include an accumulating map operation over a list, utilities to
separate and merge lists and products of lists, a function to drop empty lists, and a
last one to generate a list with a range of integers.
We additionally define the following helpful terms based on the previous primitives
to aid in the manipulation of vectors.
31

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
Types: A := S | P | (n : Nat) →A[n]
State types: S := B | Q | Unit | S1 ⊗S2 | S1 ⊸S2 | Vec (n : Nat) S
Parameter types: P := Nat | Vec (n : Nat) Nat
State contexts: Γ, ∆:= · | x : S, Γ
Parameter contexts: Φ := · | x : P, Φ
Φ, x : A ⊢x : A ax
Φ ⊢0 : B ax0
Φ ⊢1 : B ax1
n ∈N
Φ ⊢n : Nat axn
Φ ⊢M : Nat
Φ ⊢N : Nat
Φ ⊢M□N : Nat
□
Φ ⊢meas : Q ⊸B meas
Φ ⊢new : B ⊸Q new
Φ ⊢⋆: Unit axUnit
Φ ⊢U : Q⊗n ⊸Q⊗n u
Φ ⊢R : (n : Nat) →Q⊗n ⊸Q⊗n r
Φ, Γ, x : A ⊢M : B
Φ, Γ ⊢λxA.M : A ⊸B ⊸i
Φ, n : Nat, Γ ⊢M : B[n]
Φ, Γ ⊢λ′nNat.M : (n : Nat) →B
→i
Φ, Γ ⊢M : A ⊸B
Φ, ∆⊢N : A
Φ, Γ, ∆⊢MN : B
⊸e
Φ, Γ ⊢M : (n : Nat) →B
Φ ⊢N : Nat
Φ, Γ ⊢M@N : B[n/N]
→e
Φ, Γ ⊢M : Unit
Φ, ∆⊢N : B
Φ, Γ, ∆⊢M; N : B
;
Φ, Γ ⊢M : Vec 0 A
Φ, ∆⊢N : B
Φ, Γ, ∆⊢M;v N : B
;vec
Φ, Γ ⊢M : A
Φ, ∆⊢N : B
Φ, Γ, ∆⊢M ⊗N : A ⊗B
⊗
Φ, Γ ⊢M : A ⊗B
Φ, ∆, x : A, y : B ⊢N : C
Φ, Γ, ∆⊢let xA ⊗yB = M in N : C
let⊗
Φ ⊢VNilA : Vec 0 A VNil
Φ, Γ ⊢M : A
Φ, ∆⊢N : Vec n A
Φ, Γ, ∆⊢M ::N : Vec (n + 1) A
Vec
Φ, Γ ⊢M : Vec (n + 1) A
Φ, ∆, x : A, y : Vec n A ⊢N : C
Φ, Γ, ∆⊢let xA : yVec n A = M in N : C
letvec
n : Nat
Φ ⊢V : Vec n Nat
k : Nat, Φ, Γ ⊢M : A[k]
Φ, Γn ⊢for k in V do M : Vec n A[k]
for
Φ ⊢L : Nat
Φ, Γ ⊢M : A
Φ, Γ ⊢N : A
Φ, Γ ⊢ifz L then M else N : A
ifz
Figure 3.1: Type system.
32

3.1.
The λD calculus
mapA,B : (n : Nat) →Vec n A ⊸Vec n (A ⊸B) ⊸Vec n B
foldA,C : (n : Nat) →Vec n A ⊸Vec n (A ⊸C ⊸C) ⊸C ⊸C
composeA : (n : Nat) →Vec n (A ⊸A) ⊸A ⊸A
The map and fold functions are directly derived from the accumap primitive,
and the third one allows for composing multiple functions sequentially. They can be
defined directly in the calculus as follows,
map := λ′nNat. λxsVec n A. λfsVec n (A⊸B).
let fs′ ⊗u1 = accuMap @n fs
(for k in (0..n) do λf.λu.(λx.λu.fx ⊗u) ⊗u) ⋆
in let xs′ ⊗u2 = accuMap @n xs fs′ ⋆
in u1 ; u2 ; xs′
fold := λ′nNat. λxsVec n A. λfsVec n (A⊸C⊸C). λzC.
let fs′ ⊗u = accuMap @n fs
(for k in (0..n) do λf.λu.(λx.λy. ⋆⊗f x y) ⊗u) ⋆
in let us ⊗r = accuMap @n xs fs′ z
in u ; drop @n us ; r
compose := λ′nNat. λxsVec n (A⊸A).
fold @n xs (for k in 0..n do (λf.λg.λx.f (g x))) (λx.x)
Notice that the parameter abstraction only takes single integers, and similarly
none of the primitives take integer vectors as arguments. This highlights the need
for inclusion of the for as a construction into the language. Since it acts over both
parameter and state types, its function is effectively to bridge the gap between the
two of them. This operation closely corresponds to the list instantiation procedure
for SZX diagrams presented in the Section 2.4.
Example 3.1 Let xs be a vector of 2 open terms R @k (new 0). The term
for k in 2::4::VNilNat do xs
generates a vector of quantum maps by instantiating the abstractions for each indi-
vidual parameter in the vector of integers, equivalent to the vector of qubits
R @2 (new 0) :: R @4 (new 0) ::VNilQ
The primitives can be encoded as Proto-Quipper-D functions, and programs in
λD can be written and compiled into circuits using the dpq tool, published by Frank
Fu [38]. The definitions in Proto-Quipper-D shown below have been fully checked
with said tool.
33

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
module Primitives where
import "/dpq/Prelude.dpq"
foreach : ! forall a b (n : Nat)
-> (Parameter a) => !(a -> b) -> Vec a n -> Vec b n
foreach f l = map f l
split : ! forall a (n : Nat) (m: Nat) -> Vec a (n+m) -> Vec a n * Vec a m
split n m v =
case v of
VNil -> (VNil, VNil)
VCons x v' ->
case n of
Z -> (VNil, v)
S n' ->
let (v1, v2) = split n' m v'
in (VCons x v1, v2)
cons : ! forall a (n : Nat) (m: Nat) -> Vec a n -> Vec a m -> Vec a (n+m)
cons n m vn vm =
case vn of
VNil -> VNil
VCons x vn' -> x : cons n m vn' vm
accuMap : ! forall a b c (n : Nat)
-> Vec a n -> Vec (a -> c -> (b,c)) n -> c -> (Vec b n, c)
accuMap n v fs z =
case v of
VNil -> (VNil, z)
VCons x v' ->
case n of
S n' ->
let (y, z') = f x z
in (VCons y accuMap n' v' f z', z')
mapp : ! forall a b (n : Nat) -> Vec a n -> Vec (a -> b) n -> Vec b n
mapp n v f =
let (v', _) = accuMap n v (\x z -> (f x, z)) VNil
in v'
fold : ! forall a b (n : Nat) -> Vec a n -> Vec (a -> b -> b) n -> b -> b
fold n v f z =
34

3.2.
Operational Semantics of the λD calculus
let (_, z') = accuMap n v (\x z -> (VNil, f x z)) z
in z'
compose : ! (n : Nat) -> Vec (a -> a) n -> a -> a
compose n fs x = fold fs (replicate n (\f x -> f x)) x
range_aux : ! (n : Nat) -> (m : Nat) -> Nat -> Vec Nat (minus m n)
range_aux n m x =
case m of
Z -> VNil
S m' -> case n of
Z -> let r' = range_aux Z m' (S x)
in subst (\x -> Vec Nat x) (minusSZ' m') (VCons x r')
S n' -> range_aux n' m' (S x)
range : ! (n : Nat) -> (m : Nat) -> Vec Nat (minus m n)
range n m = range_aux n m Z
drop : ! (n : Nat) -> Vec Unit n -> Unit
drop n v = case n of
Z -> ()
S n' -> case v of
VCons _ v' -> drop n' v'
3.2
Operational Semantics of the λD calculus
We define a call-by-value small step operational semantics for the λD calculus. The
set of values is given as:
V := x | C | 0 | 1 | meas | new | U | λxS.M | λ′xP.M | ⋆| M ⊗N | VNil | M :: N
The reduction system is defined in Figure 3.2.
A key point to note here is that the reduction is merely syntactical. The rewriting
rules do not modify the quantum states, the measurements and unitary operations
are not reduced.
This system is powerful enough for our goal of translating into
SZX-diagrams. We include the rewrite rules for the primitives on Table 3.1.
Proto-Quipper-D has been given a categorical semantic in [41] based on a fibra-
tion of a certain monoidal category. We should then be able to define a categorical
semantic for the λD calculus based on this construction. However, since our calculus
is a reduced fraction of the full language there is interest in finding a restricted codo-
35

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
(λx.M)V →M[V /x]
(λ′x.M)@V →M[V /x]
let x ⊗y = M1 ⊗M2 in N →N[x/M1][y/M2]
let x :: y = M1 :: M2 in N →N[x/M1][y/M2]
ifz V then M else N →
{
M
If V = 0
N
Otherwise
⋆; M →M
VNil ;v M →M
V1□V2 →V
Where Vi = ni and V = n1□n2
for k in M1 :: M2 do N →N[k/M1] :: for k in M2 do N
for k in VNil do N →VNil
M →N
MV →NV
M →N
LM →LN
M →N
M@V →N@V
M →N
L@M →L@N
M →N
let x ⊗y = M in L →let x ⊗y = N in L
M →N
let x :: y = M in L →let x :: y = N in L
M →N
L□M →L□N
M →N
M□V →M□V
M →N
M ; L →N ; L
M →N
let x : y = M in L →let x : y = N in L
M →N
ifz M then L1 else L2 →ifz N then L1 else L2
M →N
for k in M do L →for k in N do L
Figure 3.2: Reduction system of λD.
36

3.2.
Operational Semantics of the λD calculus
accuMap @n xs fs z →ifz n then xs ;v fs ;v VNil ⊗z else
let x :: xs′ = xs in let f :: fs′ = fs in
let y ⊗z′ = f x z in
let ys ⊗z′′ = accuMap @(n −1) xs′ fs′ z′ in
(y :: ys) ⊗z′′
split @n @m xs →ifz n then VNil ⊗xs else let y :: xs′ = xs in
let ys1 ⊗ys2 = split@(n −1) @m xs′ in
(y :: ys1) ⊗ys2
append @n @m xs ys →ifz n then xs ;v ys else
let x :: xs′ = xs in x :: (append @(n −1) @m xs′ ys)
drop @n xs →ifz n then xs ;v ⋆else
let x :: xs′ = xs in x ; drop @(n −1) xs′
range @n @m →ifz m −n then VNil else n :: range @(n + 1) @m
Table 3.1: Reductions pertaining to the primitives.
37

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
main that would allow for a simpler definition of the semantics. We have left this
development as future work.
3.3
Encoding programs as diagram families
In this section we introduce an encoding of the lambda calculus presented in Sec-
tion 3.1 into families of SZX diagrams with context variables as inputs and term
values as outputs. We split the lambda-terms into those that represent linear map-
pings between quantum states and can be encoded as families of SZX diagrams, and
parameter terms that can be completely evaluated at compile-time.
3.3.1
Parameter evaluation
We say a type is evaluable if it has the form A = (n1 : Nat) →· · · →(nk : Nat) →
P[n1, . . . , nk] with P a parameter type. Since A does not encode a quantum operation,
we interpret it directly into functions over vectors of natural numbers. The translation
of an evaluable type, ⌊A⌋, is defined recursively as follows:
⌊(n : Nat) →B[n]⌋= N →
∪
n∈N
⌊B[n]⌋
⌊Nat⌋= N
⌊Vec (n : Nat) Nat⌋= Nn
Given a type judgement Φ ⊢L : P where P is an evaluable type, we define ⌊L⌋Φ
as the evaluation of the term into a function from parameters into products of natural
numbers. Since the typing is syntax directed, the evaluation is defined directly over
the terms as follows:
⌊x⌋x:Nat,Φ = x, |Φ| 7→x
⌊n⌋Φ = |Φ| 7→n
⌊M□N⌋Φ = |Φ| 7→⌊M⌋Φ (|Φ|)□⌊N⌋Φ (|Φ|)
⌊M :: N⌋Φ = |Φ| 7→⌊M⌋Φ (|Φ|) × ⌊N⌋Φ (|Φ|)
⌊
VNilNat⌋
Φ = |Φ| 7→[]
⌊
λ′xP.M
⌋
Φ = x, |Φ| 7→⌊M⌋Φ (x, |Φ|)
⌊M@N⌋Φ = ⌊M⌋Φ (⌊N⌋Φ (|Φ|), Φ)
⌊ifz L then M else N⌋Φ = |Φ| 7→
{
⌊M⌋Φ (|Φ|) if ⌊L⌋Φ (|Φ|) = 0
⌊N⌋Φ (|Φ|) otherwise
⌊range ⌋Φ = n, m, |Φ| 7→
m−1×
i=n
i
⌊for k in V do M⌋Φ = |Φ| 7→×
k∈⌊V ⌋Φ(|Φ|)
⌊M⌋k:NatΦ (k, |Φ|)
38

3.3.
Encoding programs as diagram families
⌊
let xP :: yVec n P = M in N
⌋
Φ = |Φ| 7→⌊N⌋x:P,y:Vec n P,Φ (y1, [y2, . . . , yn], |Φ|)
Where [y1, . . . , yn] = ⌊M⌋Φ (|Φ|).
We can prove that the evaluation of terms behaves as expected, and that it is
correct in respect to the operational semantics of the language.
Lemma 3.1 Given an evaluable type A and a type judgement Φ ⊢L : A, ⌊L⌋Φ ∈
(×x:P∈Φ ⌊P⌋
)
→⌊A⌋. That is, ⌊L⌋Φ is a function from parameters to products of
natural numbers in ⌊A⌋.
Proof By induction on the typing judgement Φ ⊢M : A:
• If Φ ⊢n : Nat, then ⌊n⌋Φ = |Φ| 7→n ∈×x:P∈Φ ⌊P⌋→N.
• If Φ, x : A ⊢x : A, then ⌊x⌋x:A,Φ = x, |Φ| 7→x ∈×y:P∈x:A,Φ ⌊P⌋→⌊A⌋.
• If Φ ⊢M□N : Nat and Φ, Γ, ∆⊢M :: N
: Vec (n + 1) A, then ⌊M□N⌋Φ =
|Φ| 7→⌊M⌋Φ (|Φ|)□⌊N⌋Φ ( |Φ| ).
By inductive hypothesis, ⌊M⌋Φ (|Φ|), ⌊M⌋Φ (|Φ|) ∈N.
Then, |Φ| 7→⌊M⌋Φ (|Φ|)□⌊N⌋Φ (|Φ|) ∈×x:P∈Φ ⌊P⌋→N.
• If Φ ⊢λ′x.M : (x : P) →B then
⌊
λ′xP.M
⌋
Φ = x, |Φ| 7→⌊M⌋Φ (x, |Φ|).
By inductive hypothesis, ⌊M⌋Φ (x, |Φ|) ∈⌊B⌋. Then, |Φ| 7→⌊M⌋Φ (x, |Φ|) ∈
×y:P∈x:PΦ ⌊P⌋→⌊B⌋.
• If Φ, Γ ⊢M@N : B[x/r], then ⌊M@N⌋Φ = |Φ| 7→⌊M⌋Φ (⌊N⌋Φ (|Φ|), Φ). By
inductive hypothesis, ⌊N⌋Φ (|Φ|) ∈N and x 7→⌊M⌋Φ (x, Φ) ∈⌊x : Nat →B[x]⌋.
Then, |Φ| 7→⌊M⌋Φ (⌊N⌋Φ (|Φ|), Φ) ∈×y:P∈Φ ⌊P⌋→⌊B[A/x]⌋.
• If Φ ⊢VNilA : Vec 0 A, then
⌊
VNilP⌋
Φ = |Φ| 7→[] ∈×x:P∈Φ ⌊P⌋→N0.
• If Φ, Γ, ∆⊢M :: N
: Vec (n + 1) A, then ⌊M :: N⌋Φ = |Φ| 7→⌊M⌋Φ (|Φ|) ×
⌊N⌋Φ (|Φ|). By inductive hypothesis MΦ(|Φ|) ∈⌊A⌋and ⌊N⌋Φ (|Φ|) ∈⌊A⌋n.
Then, |Φ| 7→⌊M⌋Φ (|Φ|) × ⌊N⌋Φ (|Φ|) ∈×x:P∈Φ ⌊P⌋→⌊A⌋n+1.
• If Φ, Γ ⊢ifz L then M else N : A, then
⌊ifz L then M else N⌋Φ = |Φ| 7→
{
⌊M⌋Φ (|Φ|) if ⌊L⌋Φ (|Φ|) = 0
⌊N⌋Φ (|Φ|) otherwise
.
By inductive hypothesis ⌊m⌋Φ (|Φ|), ⌊N⌋Φ (|Φ|) ∈⌊A⌋and ⌊L⌋Φ (|Φ|) ∈N.
Then ⌊ifz L then M else N⌋Φ ∈×x:P∈Φ ⌊P⌋→⌊A⌋.
39

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
• If Φ ⊢for k in N do M : Vec n A, then ⌊for k in V do M⌋Φ = |Φ| 7→
×k∈⌊N⌋Φ(|Φ|) ⌊M⌋k:NatΦ (k, |Φ|). By induction hypothesis, ⌊N⌋Φ (|Φ|) ∈Natn
and x 7→⌊M⌋Φ (x, Φ) ∈⌊k : Nat →A[k]⌋.
Then |Φ| 7→×k∈⌊N⌋Φ(|Φ|) ⌊M⌋k:NatΦ (k, |Φ|) ∈×x:P∈Φ ⌊P⌋→⌊A[k/N]⌋n.
• If Φ ⊢let xB : yVec n B = M in N : A, then
⌊
let xP :: yVec n P = M in N
⌋
Φ
= |Φ| 7→⌊N⌋x:P,y:Vec n PΦ (y1, [y2, . . . , yn], |Φ|) where [y1, . . . , yn] = ⌊M⌋Φ (|Φ|).
By inductive hypothesis ⌊M⌋Φ (|Φ|) ∈⌊B⌋n and ⌊N⌋x:P,y:Vec n PΦ (y1, [y2, . . . ,
yn ] , |Φ|) ∈⌊A⌋. Then |Φ| 7→⌊N⌋x:P,y:Vec n PΦ (y1, [y2, . . . , yn], |Φ|) ∈×x:P∈Φ
⌊P⌋→⌊A⌋.
• If Φ ⊢range : (n : Nat) →(m : Nat) →Vec (m −n) Nat, then ⌊range ⌋Φ =
n, m, |Φ| 7→×
m−1
i=n i ∈×z:P∈x:Nat,y:Nat,Φ ⌊P⌋→Nm−n
□
To prove Lemma 3.3 we first require the following auxiliary Lemma.
Lemma 3.2 Given the typing judgements Φ, x : A ⊢M : B, and Φ ⊢N : A,
then ⌊M⌋x:A,Φ (⌊N⌋Φ , |Φ|) = ⌊M[N/x]⌋Φ ( |Φ| ). That is, passing a parameter to the
evaluation of a term is equivalent to substituting the corresponding variable in the
term.
Proof Proof by straightforward induction on M.
□
Lemma 3.3 Given an evaluable type A, a type judgement Φ ⊢L : A, and M →N,
then ⌊M⌋Φ = ⌊N⌋Φ.
Proof By induction on the evaluation function ⌊M⌋Φ:
• If M = x, M = n, M = VNilNat, M = λ′x.M ′, M = M1 :: M2 or M = range
then M is in normal form and it does not reduce.
• If M = M1□M2 we have three cases:
– If M →M1□N with M2 →N, then:
⌊M1□M2⌋Φ = |Φ| 7→⌊M1⌋Φ (|Φ|)□⌊M2⌋Φ (|Φ|)
= |Φ| 7→⌊M1⌋Φ (|Φ|)□⌊N⌋Φ (|Φ|)
= ⌊M1□N⌋Φ
40

3.3.
Encoding programs as diagram families
– If M →N□V with M1 →N, then:
⌊M1□V ⌋Φ = |Φ| 7→⌊M1⌋Φ (|Φ|)□⌊V ⌋Φ (|Φ|)
= |Φ| 7→⌊N⌋Φ (|Φ|)□⌊V ⌋Φ (|Φ|)
= ⌊N□V ⌋Φ
– If M →n with Mi = ni ∈N and n = n1□n2, then:
⌊n1□n2⌋Φ = |Φ| 7→⌊n1⌋Φ (|Φ|)□⌊n2⌋Φ (|Φ|)
= |Φ| 7→n1□n2
= |Φ| 7→n
= ⌊n⌋Φ
• If M = M1 @M2 we have three cases:
– If M →M1 @N with M2 →N, then:
⌊M1 @M2⌋Φ = |Φ| 7→⌊M1⌋Φ (⌊M2⌋Φ (|Φ|), Φ)
= |Φ| 7→⌊M1⌋Φ (⌊N⌋Φ (|Φ|), Φ)
= ⌊M1 @N⌋Φ
– If M →N@ V with M1 →N, then:
⌊M1 @V ⌋Φ = |Φ| 7→⌊M1⌋Φ (⌊V ⌋Φ (|Φ|), Φ)
= |Φ| 7→⌊M1⌋Φ (⌊V ⌋Φ (|Φ|), Φ)
= ⌊N @V ⌋Φ
– If M →M ′[V /x] with M1 = λ′x.M ′ and M2 = V , then:
⌊(λ′x.M)@V ⌋Φ = |Φ| 7→⌊λ′x.M⌋Φ (⌊V ⌋Φ (|Φ|), Φ)
= |Φ| 7→(x, |Φ| 7→⌊M⌋x,Φ (x, |Φ|))(⌊V ⌋Φ (|Φ|), Φ)
Lemma 3.3
=
|Φ| 7→⌊M[V /X]⌋Φ (|Φ|)
= ⌊M[V /X]⌋Φ
• If M = ifz M ′ then L else R we have three cases:
41

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
– If M →ifz N then L else R with M ′ →N, then:
⌊ifz M ′ then L else R⌋Φ = |Φ| 7→
{
⌊M⌋Φ (|Φ|) if ⌊M ′⌋Φ (|Φ|) = 0
⌊N⌋Φ (|Φ|) otherwise
= |Φ| 7→
{
⌊M⌋Φ (|Φ|) if ⌊M ′⌋Φ (|Φ|) = 0
⌊N⌋Φ (|Φ|) otherwise
= ⌊ifz N then L else R⌋Φ
– If M →L with M ′ = 0, then:
⌊ifz M ′ then L else R⌋Φ = |Φ| 7→
{
⌊M⌋Φ (|Φ|) if ⌊M ′⌋Φ (|Φ|) = 0
⌊N⌋Φ (|Φ|) otherwise
= |Φ| 7→⌊L⌋Φ (|Φ|)
= ⌊L⌋Φ
– The symmetric case for the else branch is similar to the previous one.
• If M = for k in M ′ do R we have three cases:
– If M →for k in N do R with M ′ →N, then:
⌊for k in M ′ do R⌋Φ = |Φ| 7→
×
k∈⌊M′⌋Φ(|Φ|)
⌊R⌋Φ (k, |Φ|)
= |Φ| 7→×
k∈⌊N⌋Φ(|Φ|)
⌊R⌋Φ (k, |Φ|)
= ⌊for k in N do R⌋Φ
– If M →R[k/M1] : for k in M2 do R with M ′ = V :: L, then:
⌊for k in M1 :: M2 do R⌋Φ
= |Φ| 7→
×
k∈⌊M1 :: M2⌋Φ(|Φ|)
⌊R⌋Φ (k, |Φ|)
= |Φ| 7→
×
k∈⌊M1⌋Φ(|Φ|)×⌊M2⌋Φ(|Φ|)
⌊R⌋Φ (k, |Φ|)
= |Φ| 7→⌊R⌋k,Φ (⌊M1⌋Φ (|Φ|), |Φ|) × ×
k∈⌊M2⌋Φ(|Φ|
⌊R⌋k,Φ (k, |Φ|)
Lemma 3.3
=
⌊R[M1/k]⌋Φ × ⌊for k in M2 do R⌋Φ
= ⌊R[M1/k] :: for k in M2 do R⌋Φ
42

3.3.
Encoding programs as diagram families
– If M →VNil with M ′ = VNilNat, then:
⌊
for k in VNilNat do R
⌋
Φ = |Φ| 7→
×
k∈⌊VNilNat⌋Φ(|Φ|)
⌊R⌋Φ (k, |Φ|)
= |Φ| 7→×
k∈[]
⌊R⌋Φ (k, |Φ|)
= |Φ| 7→[]
=
⌊
VNilNat⌋
Φ
• If M = let x :: y = M1 in M2 we have two cases:
– If M →let x :: y = N in M2 with M1 →N, then:
⌊let x :: y = M1 in M2⌋Φ
= |Φ| 7→⌊M2⌋Φ (y1, [y2, . . . , yn], |Φ|) where [y1,...,yn]=⌊M1⌋Φ(|Φ|)
= |Φ| 7→⌊M2⌋Φ (y1, [y2, . . . , yn], |Φ|) where [y1,...,yn]=⌊N⌋Φ(|Φ|)
= ⌊let x :: y = N in M2⌋Φ
– If M →N[x/M1][y/M2] with M ′ = M1 :: M2, then:
⌊for k in M1 :: M2 do N⌋Φ = |Φ| 7→⌊N⌋x,y,Φ (y1, [y2, . . . , yn], |Φ|)
= |Φ| 7→⌊N⌋x,y,Φ (M1, M2, |Φ|)
Lemma 3.3
=
|Φ| 7→⌊N[M1/x][M2/y]⌋Φ (|Φ|)
= ⌊N[M1/x][M2/y]⌋Φ
where [y1, . . . , yn] = ⌊M1 :: M2⌋Φ (|Φ|).
• If M = range @n @M2 then:
⌊range @n@m⌋Φ = |Φ| 7→
m−1×
i=n
i
= |Φ| 7→
{
[] if n −m = 0
n ××
m−1
i=n+1 i otherwise
= |Φ| 7→
{
[] if ⌊n −m⌋Φ = 0
⌊n⌋Φ × ⌊range @(n + 1)@m)⌋otherwise
= ⌊ifz m −n then VNil else n :: range @(n + 1) @m⌋Φ□
43

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
3.3.2
Diagram encoding
A non-evaluable type has necessarily the form A = (n1 : Nat) →· · · →(nk : Nat) →
S, with S any state type. We call such types translatable since they correspond to
terms encoding quantum operations that can be described as families of diagrams.
We first define a translation J·K from state types into wire multiplicities as follows.
Notice that due to the symmetries of the SZX diagrams the linear functions have the
same representation as the products.
JBK = 1
JQK = 1
JVec (n : Nat) AK = JAK⊗n
JA ⊗BK = JAK ⊗JBK
JA ⊸BK = JAK ⊗JBK
Given a translatable type judgement
Φ, Γ ⊢M : (n1 : Nat) →· · · →(nk : Nat) →S
we can encode it as a family of SZX diagrams
n1, . . . , nk, |Φ| 7→
M(|Φ|)
JS[|Φ|]K
JΓK
. In our diagrams we will omit the brackets for clarity. In a similar manner to the
evaluation, we define the translation JMKΦ,Γ recursively on the terms as follows:
JxKΦ,x:A = |Φ| 7→
A
J0KΦ = |Φ| 7→
Q
J1KΦ = |Φ| 7→
Q
π
JmeasKΦ = |Φ| 7→
Q⊸Q
JnewKΦ = |Φ| 7→
1⊸1
JUKΦ = |Φ| 7→
nQ⊸nQ
U
JRKΦ = n, |Φ| 7→
Q⊸Q
R(n)
q
λ′xA.M
y
Φ,Γ = x, |Φ| 7→
M(x, |Φ|)
A
Γ
JM @NKΦ,Γ = |Φ| 7→
M(⌊N⌋Φ (|Φ|), |Φ|)
B
Γ
q
λxA.M
y
Φ,Γ = |Φ| 7→
A
M(|Φ|) B
A⊸B
Γ
JM NKΦ,Γ,∆= |Φ| 7→
∆
M(|Φ|)
A⊸B
B
Γ
N(|Φ|)
A
JM; NKΦ,Γ,∆= |Φ| 7→
∆N(|Φ|)
A
Γ M(|Φ|)
J⋆KΦ = |Φ| 7→
JM ⊗NKΦ,Γ,∆= |Φ| 7→∆N(|Φ|)
A
Γ M(|Φ|)
B
A⊗B
44

3.3.
Encoding programs as diagram families
JM;v NKΦ,Γ,∆= |Φ| 7→
∆N(|Φ|)
A
Γ M(|Φ|)
JVNilKΦ = |Φ| 7→
q
let xA ⊗yB = M in N
y
Φ,Γ,∆= |Φ| 7→
∆
N(|Φ|)
B
Γ M(|Φ|)
A⊗B
A
C
q
let xA : yVec n A = M in N
y
Φ,Γ,∆= |Φ| 7→
∆
N(|Φ|)
A⊗n
Γ M(|Φ|)
A⊗n+1
A
C
JM ::NKΦ,Γ,∆= |Φ| 7→∆N(|Φ|)
A
Γ M(|Φ|)
A⊗n
A⊗n+1
Jfor k in V do MKΦ,Γn = |Φ| 7→
A⊗n
M(k)
k∈⌊V ⌋(|Φ|)
Γ⊗n
Jifz L then M else NKΦ,Γ = |Φ| 7→
N
k∈[0]⊗δl>0
Γ
M
k∈[0]⊗δl=0
A⊗δl>0
A
Γ⊗δl=0
Γ⊗δl>0
A⊗δl=0
where δ is the Kronecker delta and l = ⌊L⌋(|Φ|). Notice that the new and meas
operations share the same translation. Although new can be encoded as a simple wire,
we keep the additional
node to maintain the symmetry with the measurement.
The unitary operators U and rotations R correspond to a predefined set of prim-
itives, and their translation is defined on a by case basis. The following table shows
the encoding of the operators used in this procedure.
Name
Rz(n)
R−1
z (n)
Rx(n)
R−1
x (n)
H
CNOT
Encoding
π
n
−π
n
π
n
−π
n
Notice that the spiders and Hadamard nodes from the ZX calculus are only re-
quired for the quantum primitives. Our choice of quantum operators is an arbitrary
universal set that is easily representable in ZX. If required we could straightforwardly
replace this definition with an alternative calculus supporting the scalable extension
such as ZH [5], and use a different set of quantum primitives, without altering the
rest of our translation.
The primitives split, append, drop and accuMap are translated below. Since
vectors are isomorphic to products in the wire encoding, the first three primitives do
not perform any operation. For the accumulating map we utilize the construction
presented in Lemma 2.1, replacing the function box with a function vector input. In
the latter we omit the wires and gathers connecting the inputs and outputs of the
function to a single wire on the right of the diagram for clarity.
JsplitAKΦ = n, m, |Φ| 7→
(n+m)A⊸nA⊗mA
(n+m)A
45

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
JappendAKΦ = n, m, |Φ| 7→
nA⊸mA⊸(n+m)A
(n+m)A
JdropKΦ = n, |Φ| 7→
n0⊸0
q
accuMapA,B,C
y
Φ =
n, |Φ| 7→
nC
C
C
(n−1)C
nA
nB
τn,A,B,C
n(A⊸C⊸B⊗C)
nA⊸nC⊸nB⊗nC
C
nA
n(A⊸C⊸B⊗C)
nB⊗C
C
0A
0(A⊸C⊸B⊗C)
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
where τn,A,B,C is a permutation that rearranges the vectors of functions into tensors
of vectors for each parameter and return value. That is, τn,A,B,C reorders a sequence
of registers (A, C, B, C) . . . (A, C, B, C) into the sequence (A . . . A)(C . . . C)(B . . . B)
(C . . . C). It is defined as follows,
τn,A,B,C(i) =









i mod k + a ∗(i div k)
if i mod k < a
i mod k + c ∗(i div k) + a ∗(n −1)
if a ≤i mod k < (a + c)
i mod k + b ∗(i div k) + (a + c) ∗(n −1)
if (a + c) ≤i mod k < (a + c + b)
i mod k + c ∗(i div k) + (a + c + b) ∗(n −1)
if (a + c + b) ≤i mod k
for i ∈[0, (a + c + b + c) ∗n), where mod and div are the integer modulo and division
operators, a = JAK, b = JBK, c = JCK, and k = a + c + b + c.
As a consequence of Lemma 2.4, the number of nodes in the produced diagrams
grows linearly with the size of the input.
Lemma 3.4 The translation procedure is correct in respect to the operational se-
mantics of λD.
If A is a translatable type, Φ, Γ ⊢M : A, and M →N, then
JMKΦ,Γ = JNKΦ,Γ.
Proof By case analysis on the reductions of translatable terms.
46

3.3.
Encoding programs as diagram families
• If M = (λxA.M ′)V and N = M ′[V /x],
q
(λxA.M ′)V
y
Φ,∆,Γ = |Φ| 7→
∆
B
V (|Φ|)
A
A
M′(|Φ|) B
A⊸B
Γ
(gs)
= |Φ| 7→
∆V (|Φ|)
A
M′(|Φ|)
B
Γ
= JM ′[V /x]KΦ,∆,Γ
• If M = (λ′xA.M ′) @V and N = M ′[V /x],
q
(λ′xA.M ′) @V
y
Φ,Γ = |Φ| 7→
⌊
(λ′xA.M ′)
⌋
Φ (⌊V ⌋Φ (|Φ|), |Φ|)
B
Γ
= |Φ| 7→
⌊M′⌋Φ (⌊V ⌋Φ (|Φ|), |Φ|)
B
Γ
= JM ′[V /x]KΦ,Γ
By Lemma ??.
• If M = let xA ⊗yB = V1 ⊗V2 in M ′ and N = M ′[V1/x][V2/y],
q
let xA ⊗yB = V1 ⊗V2 in M ′y
Φ,Γ,∆,Λ = |Φ| 7→
Λ
M′(|Φ|)
B
A
C
∆V2(|Φ|)
A
Γ V1(|Φ|)
B
A⊗B
(gs)
= |Φ| 7→
Λ
M′(|Φ|)
C
∆V2(|Φ|)
A
Γ V1(|Φ|)
B
= JM ′[V1/x][V2/y]KΦ,∆,Γ,Λ
• If M = let xA :: yVec n A = V1 :: V2 in M ′ and N = M ′[V1/x][V2/y],
q
let xA :: yVec n A = V1 :: V2 in M ′y
Φ,Γ,∆,Λ
= |Φ| 7→
Λ
M′(|Φ|)
nA
A
B
∆V2(|Φ|)
A
Γ V1(|Φ|)
nA
(n+1)A
(gs)
= |Φ| 7→
Λ
M′(|Φ|)
B
∆V2(|Φ|)
A
Γ V1(|Φ|)
nA
= JM ′[V1/x][V2/y]KΦ,∆,Γ,Λ
• If M = ifz L then M ′ else N ′,
47

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
– if L = 0 and N = M ′, ⌊L⌋Φ = 0 and
Jifz L then M ′ else N ′KΦ,Γ = |Φ| 7→
N′(|Φ|)
k∈[ ]
Γ
M′(|Φ|)
k∈[0]
A
Γ
0
A
0
Lemma 2.3
=
|Φ| 7→
Γ
M′(|Φ|)
A
Γ
0
A
0
(∅4)
= |Φ| 7→
Γ
M′(|Φ|)
A
= JM ′KΦ,Γ
– The case where L > 0 and N = N ′ is symmetric to the case above.
• If M = VNil; M ′ and N = M ′,
JVNil;v M ′KΦ,Γ = |Φ| 7→
Γ M′(|Φ|)
A = JM ′KΦ,Γ
• If M = ⋆; M ′ and N = M ′,
J⋆; M ′KΦ,Γ = |Φ| 7→
Γ M′(|Φ|)
A = JM ′KΦ,Γ
• If M = for k in V :: M ′ do N ′ and N = N ′[k/V ] :: for k in M ′ do N ′,
Jfor k in V :: M ′ do N ′KΦ,Γ⊗n = |Φ| 7→
A⊗n
N′(k, |Φ|)
k∈⌊V ::M′⌋(|Φ|)
Γ⊗n
Lemma 2.2
=
|Φ| 7→
A⊗n
N′(k, |Φ|)
k∈⌊M′⌋(|Φ|)
Γ⊗n
N′(⌊V ⌋(|Φ|), |Φ|)
A
Γ
Γ⊗n−1
A⊗n−1
= JN ′[k/V ] :: for k in M ′ do N ′KΦ,Γ⊗n
• If M = for k in VNil do N ′ and N = VNil,
Jfor k in VNil do N ′KΦ = |Φ| 7→
0
N′(k, |Φ|)
k∈[ ]
0
Lemma 2.3
=
|Φ| 7→
0
0
= |Φ| 7→
= JVNilKΦ
48

3.3.
Encoding programs as diagram families
• If M = accuMapA,B,C N ′ Mxs Mfs Mz and
N = ifz N ′ then xs ;v fs ;v VNil ⊗Mz else
let x :: xs′ = Mxs in let f :: fs′ = Mfs in let y ⊗z′ = f x z in let ys ⊗
z′′ = accuMap @(N ′ −1) xs′ fs′ z′ in (y :: ys) ⊗z′′. Let n = ⌊N1⌋Φ (|Φ|).
Notice that, by definition of τn,A,B,C,
τn+1,A,B,C
(n+1)(A⊸C⊸B⊗C)
(n+1)A⊸(n+1)C⊸(n+1)B⊗(n+1)C
(n+1)A
(n+1)C
(n+1)B
(n+1)C
(p)
=
τn,A,B,C
n(A⊸C⊸B⊗C)
nA⊸nC⊸nB⊗nC
A⊸C⊸B⊗C
(n+1)A
(n+1)C
(n+1)B
(n+1)C
Therefore,
q
accuMapA,B,C N ′ Mxs Mfs Mz
y
Φ,Γ,∆,Π
= |Φ| 7→
Mfs(|Φ|)
Mxs(|Φ|)
Mz(|Φ|)
Γ
Π
∆
nC
C
C
(n−1)C
nA
nB
τn,A,B,C
n(A⊸C⊸B⊗C)
nA⊸nC⊸nB⊗nC
C
nA
n(A⊸C⊸B⊗C)
nB⊗C
C
0A
0(A⊸C⊸B⊗C)
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
(p,gs,sg)
=
49

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
|Φ| 7→
Mfs(|Φ|)
Mxs(|Φ|)
Mz(|Φ|)
Γ
Π
∆
(n−1)C
C
C
(n−2)C
nA
nB
τn−1,A,B,C
C
nA
n(A⊸C⊸B⊗C)
nB⊗C
C
0A
0(A⊸C⊸B⊗C)
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
A⊸C⊸B⊗C
(n−1)A
A
(n−1)B
B
C
= Jifz N ′ then xs ;v fs ;v VNil ⊗Mz else let x :: xs′ = Mxs in let f ::
fs′ = Mfs in
let y ⊗z′ = f x z in let ys ⊗z′′ = accuMap @(N ′ −1) xs′ fs′ z′ in (y ::
ys) ⊗z′′KΦ,Γ,∆,Π
• If M = splitA @n @m xs and N = ifz n then VNil ⊗xs else let y :: xs′ =
xs in let ys1 ⊗ys2 = split@(n −1) @m xs′ in (y :: ys1) ⊗ys2. Let n =
⌊N1⌋Φ (|Φ|) and m = ⌊N2⌋Φ (|Φ|).
JsplitA @n @m xsKΦ,Γ
= |Φ| 7→
Γ
M′(|Φ|)
(n+m)A
(n+m)A
(n+m)A
(sg,gs)
=
|Φ| 7→
Γ
M′(|Φ|)
(n+m)A
(∅4),Lemma 2.3
=
|Φ| 7→
Γ
M′(|Φ|)
(n+m)A
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
Γ
M′(|Φ|)
(n+m)A
Γ
(n+m)A
50

3.3.
Encoding programs as diagram families
(sg,gs,∅4)
=
|Φ| 7→
Γ
M′(|Φ|)
(n+m)A
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
Γ
M′(|Φ|)
(n+m)A
Γ
(n+m)A
0
(n+m)A
(n+m)A
mA
nA
A
(n−1+m)A
(n−1+m)A
(n−1+m)A
(n−1)A
= Jifz n then VNil ⊗xs else let y :: xs′ = xs in let ys1 ⊗ys2 = split
@(n −1) @m xs′ in (y :: ys1) ⊗ys2KΦ,Γ
• If M = appendA @N1 @N2 M1 M2 and N = ifz N1 then M1 ;v M2 else
let x :: xs′ = M1 in x :: (append @(N1−1) @N2 M1 M2). Let n = ⌊N1⌋Φ (|Φ|)
and m = ⌊N2⌋Φ (|Φ|).
JappendA @N1 @N2 M1 M2KΦ,Γ,∆= |Φ| 7→
Γ
M1(|Φ|)
nA
∆
M2(|Φ|)
mA
(n+m)A
(n+m)A
(n+m)A
(∅4),Lemma 2.3
=
|Φ| 7→
Γ
M1(|Φ|)
nA
∆
M2(|Φ|)
mA
(n+m)A
(n+m)A
(n+m)A
Γ
M1(|Φ|)
nA
∆
M2(|Φ|)
mA
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
Γ
∆
(sg,gs)
=
|Φ| 7→
Γ
M1(|Φ|)
nA
∆
M2(|Φ|)
mA
(n+m)A
Γ
M1(|Φ|)
nA
∆
M2(|Φ|)
mA
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
Γ
∆
51

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
(i1,∅1,∅4,sg,gs)
=
|Φ| 7→
Γ
M1(|Φ|)
nA
∆
M2(|Φ|)
mA
(n+m)A
Γ
M1(|Φ|)
∆
M2(|Φ|)
mA
k ∈[0]⊗δn>0
k ∈[0]⊗δn=0
Γ
∆
(n−1+m)A
(n−1+m)A
(n−1+m)A
A
(n−1)A
= Jifz N1 then M1 ;v M2 else let x :: xs′ = M1 in x :: (append @(N1 −
1) @N2 M1 M2KΦ,Γ,∆
• If M = drop @N ′ M ′ and N = ifz N ′ then M ′ ; ⋆else let x :: xs′ = M ′ in
x ; drop @(N ′ −1) xs′. Let l = ⌊N ′⌋Φ (|Φ|),
Jdrop @N ′ M ′KΦ,Γ = |Φ| 7→
0
Γ M′
0
0
(∅4),Lemma 2.3
=
|Φ| 7→
0
Γ M′
0
0
0
Γ M′
0
0
Γ
k ∈[0]⊗δl>0
k ∈[0]⊗δl=0
0
(z3,∅4)
=
|Φ| 7→
0
Γ M′
0
0
Γ M′
0
Γ
k ∈[0]⊗δl>0
k ∈[0]⊗δl=0
0
0
0
= Jifz N ′ then M ′ ; ⋆else let x :: xs′ = M ′ in x ; drop @(N ′ −1) xs′KΦ,Γ
52

3.4.
Application example: QFT
• If M →N is an internal reduction of a translatable term, then the diagrams
are equivalent under the inductive hypothesis.
• If M →N is an internal reduction of an evaluable term, then the diagrams are
equivalent under the inductive hypothesis and Lemma 3.3.
□
3.4
Application example: QFT
The Quantum Fourier Transform is an algorithm used extensively in quantum com-
putation, notably as part of Shor’s algorithm for integer factorization [56]. The QFT
function operates generically over n-qubit states and when compiled into a circuit
produces operations with O(n2) quantum gates. In this section we present an en-
coding of the algorithm as a λD term, followed by the translation into a family of
constant-sized diagrams.
The following presentation divides the algorithm into three parts. We present for
each part its encoding as a lambda term and as a Quipper program using our library
of primitives, followed by the translation into SZX diagram families. In the terms, we
use n . . . m as a shorthand for range @n @m. For the translations we omit the wire
connecting the function inputs to the right side of the graphs for clarity and eliminate
superfluous gathers and splitters using rules (sg) and (gs).
The first function crot applies a controlled rotation over a qubit with a paramet-
rized angle. For the Quipper program, we use directly a controlled rotation primitive.
crot : (n : Nat) →(Q ⊗Q) ⊸(Q ⊗Q)
crot := λ′nNat.λqsQ⊗Q.
let cQ ⊗qQ = qs in
let cQ ⊗qQ = CNOT c (Rz @2n q) in
CNOT c (Rz−1 @2n q)
crot : ! (n : Nat) -> Qubit * Qubit -> Qubit * Qubit
crot n q = let (q',c) = q in flip $ R n q' c
The term can be directly translated as by encoding each quantum gate.
JcrotK = n 7→
2
−π
2n
π
2n
2
The second function apply_crot operates over the last n −k qubits of an n-qubit
state by applying a Hadamard gate to the first one and then using it as target of
53

Chapter 3.
Compiling high-level quantum programs into SZX diagrams
successive crot applications using the rest of the qubits as controls. Notice that, in
contrast to the presented lambda terms, the type checker implementation requires
explicit encodings of the Leibniz equalities between parameter types.
apply_crot : (n : Nat) →(k : Nat) →Vec n Q ⊸Vec n Q
apply_crot := λ′nNat. λ′kNat. λqsVec n Q.
ifz (n −k) then qs else
let hVec k Q ⊗qs′ Vec n−k Q = split @k @(n −k) qs in
let qQ ⊗csVec n−k−1 Q = qs′ in
let fsVec (n−k−1) (Q⊗Q⊸Q⊗Q)
= (for mNat in 2..(n −k + 1) do crot @m) in
let cs′ (Vec n−k−1 Q) ⊗q′ Q = accuMap fs (H q) cs in
concat h (q′ : cs′)
-- Specify types to help the typechecker
applyCrot_aux : ! (n : Nat) -> Qubit -> Qubit -> Qubit * Qubit
applyCrot_aux n ctrl q = crot n (q, ctrl)
-- Apply a CROT sequence to a qubit register, ignoring the first k qubits.
applyCrot : ! (n k : Nat) -> Vec Qubit n -> Vec Qubit n
applyCrot n k qs =
let WithEq r e = inspect (minus n k)
in case r of
Z -> qs
S n' ->
let
-- e : Eq Nat (S n') (minus n k)
-- e' : Eq Nat (add k (S n')) n
e' = trans (symAdd k (S n')) $ minusPlus n n' k $ sym (minus n k) e
-- qs' : Vec Qubit (minus n k)
qs' = subst (\m -> Vec Qubit m) (sym (add k (S n')) e') qs
(head, qs') = split k (S n') $ qs'
(q,ctrls) = chop qs'
-- fs : Vec (Qubit -> Qubit -> Qubit * Qubit) (minus n' Z)
fs = foreach (\k -> applyCrot_aux (S(S k))) $ 0..n'
-- fs : Vec (Qubit -> Qubit -> Qubit * Qubit) Z
eq = sym n' $ minusZ n'
fs = subst (\m -> Vec (Qubit -> Qubit -> Qubit * Qubit) m) eq fs
(ctrls', q') = accumap fs (H q) ctrls
in subst (\m -> Vec Qubit m) e' $ append head (VCons q' ctrls')
54

3.4.
Application example: QFT
The translation of apply_crot only includes the diagram for crot once, and it it-
erates it using the accumap construction.
Japply_crotK =
n, k 7→
n
n
k
n−k
crot(m)
m∈2..(n−k+1)
n−k−2
n−k−1
n−k−1
n−k−1
n−k−1
n−k
n×δn−k=0
n×δn−k>0
n×δn−k>0
x∈[0]⊗δn−k>0
Finally, qft repeats apply_crot for all values of k.
qft : (n : Nat) →Vec n Q ⊸Vec n Q
qft := λ′nNat.λqsVec n Q.compose
(for kNat in reverse_vec @(0..n) do λqs′ Vec n Q.apply_crot @n @k qs′) qs
-- Required for the type checker to derive the second !
qft_aux : ! (n : Nat) -> ! (k : Nat) -> Vec Qubit n -> Vec Qubit n
qft_aux n head_size qs = applyCrot n head_size qs
qft : ! (n : Nat) -> Vec Qubit n -> Vec Qubit n
qft n qs = let f = qft_aux n in compose' (foreach f $ reverse_vec (0..n)) qs
JqftK = n 7→n
n
n×(n−1)
apply_crot(n,k)
k∈rev(0..n)
n×n
n×n
Notice that, in contrast to a quantum circuit encoding of QFT which required a
quadratic number of gates, the produced SZX diagram’s size does not depend on the
number of qubits n.
55


4
Optimizing hybrid
quantum-classical circuits with the
ZX⏚calculus
In general, in any resource-constrained system it is important to make an eﬀicient use
of the available resources during its operation. In the context of quantum computers
and especially for NISQ machines, the execution of a quantum program is heavily
restrained by the available number of qubits and the inherent noise of the quantum
operation which limit the number of operations that can executed.
As quantum circuits became the standard representation for running operations on
quantum machines, the research on optimization procedures has been mostly focused
on methods based on gate substitution or optimization of phase polynomials [2, 43].
One notable exception is the one introduced by Duncan et al. in 2019 [33] in which
they use the ZX calculus as an alternative intermediate representation to apply gran-
ular rewriting rules that ignore the boundaries between gates. In this chapter we will
refer to their procedure as the Clifford optimization algorithm.
Most common optimization strategies for quantum circuits focus exclusively on
pure operations, without contemplating any hybrid quantum-classical structure. Al-
though pure quantum circuits can be effectively optimized in isolation from the clas-
sical segments, it is natural to look at the more general problem of optimization
considering the interaction with the environment in addition to the pure quantum
fragments. In this chapter we present an optimization procedure for hybrid quantum-
classical circuits using the ZX
calculus.
We first introduce in Section 4.1 the subset of graph-like ZX
diagrams that we will
require during the process and describe a translation from hybrid circuits into such
diagrams in Section 4.2. In Section 4.3 we describe the original ZX based optimization
procedure for pure quantum circuits by Duncan et. al. which serves as a basis for
57

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
our definition.
Then, in Section 4.4 we begin the discussion of our main contribution in the form of
an extension of the pure optimization procedure to hybrid quantum-classical circuits
using the ZX
calculus. Section 4.5 further improves the optimization by introducing
a methodology to find additional rewriting opportunities. Section 4.6 describes an
eﬀicient algorithm to apply our optimization and finally Section 4.7 formalises an
extraction back into quantum circuits based on the Clifford procedure.
Section 4.8 includes an example execution of the extraction algorithm, and finally
Section 4.9 discusses the implementation and benchmarking of our algorithm.
The results described in this chapter have been presented at the APLAS 2021
conference [11].
4.1
Graph-like diagrams and focused gFlow
Our plan for the optimization involves transforming the quantum circuits into ZX
diagrams and extracting them back into circuits. The translation into ZX
diagrams
is a straightforward operation; the usual set of Clifford+T quantum gates has a direct
representation as compact ZX diagrams and the measurements and qubit initializ-
ations can be directly represented with the ground operator. On the other hand,
extracting back the circuits can be a complex task.
Recently, de Beaudrap et al. [29] proved that the problem of extracting a quantum
circuit from an arbitrary ZX diagrams is #P-hard. However, some eﬀicient extraction
algorithms have been described for ZX
diagrams which admit a special partial order
between spiders called focused gFlow.
To define the gFlow property, we must first introduce the special form of graph-
like diagrams [33]. We say that a pure ZX diagram is graph-like if it only contains
Z-spiders internally connected by Hadamard wires, it has no parallel edges nor self-
loops, and no spider is connected to more than one input or output. We define the
graph-like form for ZX
diagrams in a similar manner, additionally restricting the
spiders to be connected to at most one
, and restricting the connections between
-spiders and the inputs and outputs.
When translating a quantum circuit into a ZX
diagram, we will first generate
diagrams in a weaker form allowing a node to connect to an input, a
, and any num-
ber of outputs simultaneously. We will then rewrite these weakly graph-like diagrams
to transform the final translation result into the strict version afterwards.
The string and weak graph-like forms are formally defined as follows:
Definition 4.1 A ZX
diagram is graph-like (respectively weakly graph-like) when:
1. All spiders are Z-spiders.
58

4.1.
Graph-like diagrams and focused gFlow
2. Z-spiders are only connected via Hadamard edges.
3. There are no parallel Hadamard edges or self-loops.
4. There is no pair of connected
-spiders.
5. Every input, output, or
is connected to a Z-spider.
6. Every Z-spider connected to a
has phase 0.
7. Every Z-spider is connected to at most one input, one output, or one
(at most
one input and at most one
).
Lemma 4.2 Every ZX
diagram is equivalent to a weakly graph-like ZX
diagram.
Proof Duncan et al. [33, Lemma 3.2] proved that any pure-ZX diagram is equivalent
to a graph-like one. When applied to a ZX
diagram, their procedure results in a
diagram that satisfy the conditions 1, 2, and 3 of Definition 4.1, and where every
input and output is connected to a different Z-spider.
From this point, we can apply rule (l) to eliminate Hadamards connected to
generators, satisfying condition 5. We then apply rule (n) to disconnect wires between
-spiders, rule (gg) to eliminate duplicated
connected to the same spider, and rules
(m) and (f) to remove the phase of
-spiders.
The resulting diagram satisfies all conditions of the weakly graph-like form.
□
Lemma 4.3 There exists an algorithm to transform an arbitrary ZX
diagram into
an equivalent strictly graph-like diagram.
Proof By adding identity spiders to the inputs and outputs.
The strict graph-like condition limits to 1 the number of inputs, outputs, and
ground generators connected to each spider, in addition to the weakly graph-like
restrictions. By Lemma 4.2, the diagram can be rewritten into an equivalent weakly
graph-like diagram D. We describe an algorithm which modifies D to comply with
the additional restriction.
For each spider v in D connected to at least two inputs, outputs or
generators,
add two Z-spiders and Hadamard wires to each connected input and output as follows.
α
→
v
D/{v}
α
v
D/{v}
vouti,1 vouti,2
vin1
vin2
…
…
(4.4)
Notice that v may have at most one connected input. The introduced spiders corres-
pond to identity operations, and therefore the procedure generates a strictly graph-like
diagram equivalent to D.
□
59

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
Once a diagram is in a weakly graph-like form, all its spiders as well as all its
internal connections are of the same kind. We can refer to its underlying structure
as a simple undirected graph, marking the nodes connected to inputs and outputs.
In addition,
generators or the
-spiders connected to them can be seen as outputs
discarding information into the environment. This is known as the underlying open
graph of a diagram.
Definition 4.5 An open graph is a triple (G, S, T) where G = (V, E) is an undirected
graph, and S ⊆V is a set of sources and T ⊆V is a set of sinks. For a weakly graph-
like ZX diagram D, the underlying open graph G(D) is the open graph whose vertices
are spiders D, whose edges correspond to Hadamard edges, whose set S is the subset
of spiders connected to the inputs of D, and whose set T is the subset of spiders
connected to the outputs of D or to ground generators.
The underlying open graph of a ZX diagram produced from our translation of
quantum circuits verify a graph-theoretic invariant called focused gFlow [53]. This
structure —originally conceived for graph states in measurement-based quantum
computation— gives a notion of flow of information and time on the diagram. It
will be required to guide the extraction strategy in Section 4.7.
Definition 4.6 Given an open graph G, a focused gFlow (g, ≺) on G consists of a
function g : T →2S and a partial order ≺on the vertices V of G such that for all
u ∈T, OddG(g(u)) ∩T = {u} and ∀v ∈g(u), u ≺v where 2S is the powerset of S
and OddG(A) := {v ∈V (G) | |N(v) ∩A| ≡1 mod 2} is the odd neighbourhood of A.
Example 4.7 Consider the following graph-like diagram and associated open graph,
where each node has been labelled with an index.
0
1
2
3
4
5
S = {0, 4}
T = {1, 3, 5}
The natural label ordering i < j and the function
g(0) := {1, 2, 3}
g(2) := {3}
g(4) := {5}
form a valid focused gFlow on this open graph.
60

4.2.
Translation of hybrid circuits
4.2
Translation of hybrid circuits
We describe our translation from hybrid quantum-classical circuits into strictly graph-
like ZX
diagrams by steps. First, we translate each individual gate directly into a
weakly graph-like diagram and connect them with regular wires. We define this trans-
lation T(·) by inductively translating the gates as described in Table 4.1 immediately
followed by the application of the spider fusion rule (f) and rules (gg) and (fh)
to remove all regular wires, duplicated
generators, and parallel Hadamard wires,
ensuring that the final combined diagram is in a weakly graph-like form.
Notice that the translation maps both classical and quantum wires to regular
ZX
diagram edges. We keep track of which inputs and outputs of the diagram were
connected to classical wires and introduce
generators for the operations that interact
with the environment. In Chapter 5 we present a method to detect the sections of the
final circuit that can be implemented as classical operations by looking at the classical
inputs/outputs and the
generators, independently of which wires were originally
classical.
In this work we restrict the inputs to circuits with classical parity logic, choosing
not to include AND gates. The ZX
calculus is able to represent these operations
in what equates to the Clifford+T decomposition of the Toffoli gate, in an approach
that introduces multiple T-gates and CNOT gates to the circuit [63]. The multiple
spiders would be dispersed around the diagram during the optimization step, poten-
tially breaking the pattern formed by the AND gate and replacing it with multiple
quantum operations. This could produce the unexpected result of introducing ex-
pensive quantum operations in an originally pure classical circuit. Therefore, we keep
the restriction during the rest of this chapter.
Lemma 4.1 The ZX
diagram resulting from the translation T(·) is weakly graph-
like.
Proof By induction on the circuit construction.
Notice that all the translation rules aside from the serial composition generate
weakly graph-like diagrams trivially.
For the serial composition, notice that both T(C) and T(C′) are weakly graph-
like by the induction hypothesis and therefore all spiders in the resulting diagram
are Z-spiders, all inputs and outputs are connected to Z-spiders, no two inputs are
connected to the same spider, and all spiders connected to
-generators have phase
0. The internal edges added by the composition will therefore connect two green
spiders, which will be merged by the fusion rule application.
The fusion step may create spiders connected to two ground generators, one of
which is removed by the application of rule (gg).
It may also generate parallel
Hadamard wires, which are removed by the application of rule (fh).
61

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
⊕
7→
H
7→
Zα
7→
α
|
0
7→
|0
7→
7→
7→
π
7→
7→
|
7→
⊕
7→
Z
7→
7→
7→
7→
7→
C
· · ·
C′
· · ·
· · ·
7→
T(C)
· · ·
T(C′)
· · ·
· · ·
C
· · ·
C′
· · ·
· · ·
· · ·
7→
T(C)
· · ·
T(C′)
· · ·
· · ·
· · ·
Table 4.1: Translation from hybrid quantum-classical circuits into ZX
diagrams.
Therefore, the translation generates weakly graph-like ZX -diagrams.
□
After the translation, we can apply Lemma 4.3 to obtain a strictly graph-like
diagram. This step essentially separates the
generators from the inputs and outputs,
allowing the optimization procedure to move them around and let them interact with
other parts of the diagram.
The underlying graph of a diagram produced by the translation admits a gFlow.
To prove this, we first use a weaker version of the focused gFlow invariant called
causal flow [53].
Definition 4.2 Given an open graph G, a causal flow (f, ≺) on G consists of a
function f : T →S and a partial order ≺on the set V satisfying the following
properties:
1. f(v) ∼v
2. v ≺f(v)
62

4.2.
Translation of hybrid circuits
3. If u ∼f(v) and u ̸= v then v ≺u
where u ∼v if u is connected to v in the graph, and A = V (G)/A.
Example 4.3 Consider the graph-like diagram and associated open graph from Ex-
ample 4.7.
0
1
2
3
4
5
S = {0, 4}
T = {1, 3, 5}
The natural label ordering i < j and the function
f(0) := 1
f(2) := 3
f(4) := 5
form a valid causal flow on this open graph.
Duncan et al. prove the following lemma relating both flow properties:
Lemma 4.4 ([33, Theorem B.3]) If G admits a causal flow, then there exists a
valid focused gFlow for G.
Lemma 4.5 If D is a weakly graph-like ZX
diagram and G(D) admits a causal flow,
the strictly graph-like diagram generated by the algorithm described in Lemma 4.3
admits a causal flow.
Proof Let (fD, ≺D) be a valid causal flow for D and let D′ be the resulting diagram
after applying rule 4.4 over a node v. We construct a causal flow for D′ by defining
a function fD′ and relation ≺D′ as the minimal objects such that
• fD′ ⊇fD and ≺D′⊇≺D.
• If v is connected to an input in D, fD′(vin1) = vin2, fD′(vin2) = v, and (vin1, vin2),
(vin2, v) ∈≺D′.
• If v is connected to at least one output in D and v is not a
-spider, fD′(v) =
vout1,1.
• For each output i connected to v in D, (v, vouti,1), (vouti,1, vouti,2) ∈≺D′ and
fD′(vouti,1) = vouti,2.
Notice that (fD′, ≺+
D′) is a valid focused flow for D′, where ≺+
D′ is the transitive
closure of ≺D′. Since the rule 4.4 preserves the focused flow, the resulting diagram
after successive application admits a causal flow.
□
63

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
Lemma 4.6 If C is a hybrid quantum-classical circuit and D is the graph-like ZX
diagram obtained from the translation T(C) and Lemma 4.3, then G(D) admits a
focused gFlow.
Proof By induction on C.
By Lemma 4.4, it suﬀices to prove that G(D) admits a causal flow. We proceed
by induction on the construction of C.
• Notice that the translation of each base constructors cannot be further simplified
by rules (f), (gg), or (fh), and the underlying open graph trivially admits a
causal flow.
• If C = C1 ⊗C2, let Di = T(Ci). Since the two circuits are not connected after
the composition, they do not interact via the rules (f), (gg), or (fh), and
therefore D = D1 ⊗D2. By the induction hypothesis G(D1) and G(D2) admit
some causal flow (f1, ≺1) and (f2, ≺2) respectively. Then, (f1 ∪f2, ≺1 ∪≺2) is
a causal flow for G(D).
• If C = C1 ⊗C2, let Di = T(Ci).
By the induction hypothesis G(D1) and
G(D2) admit some causal flow (f1, ≺1) and (f2, ≺2) respectively. Notice that
rule (f) will be applied between each output of C1 and the connected inputs
in C2.
Let f ′
1 be a function and ≺′
1 a relation such that for each vertex v
in G(D1) and corresponding non-empty set of inputs {u1, . . . , uk} in G(D2),
∀v′st. f1(v′) = v, f ′
1(v′) = u1 and ∀v′st. v′ ≺1 v, {(v′, ui)}k
i=1 ⊆≺′
1. Notice that
since D2 is weakly graph-like, u1 has exactly one corresponding sink node in
G(D1). Additionally, for all v1, v2 non-output nodes in G(D1) let f ′
1(v1) = v2 if
f1(v1) = v2 and let v1 ≺′
1 v2 if v1 ≺1 v2. Then, (f ′
1 ∪f2, (≺′
1 ∪≺2)+) is a causal
flow for G(D).
Then, by Lemma 4.5, the application of Lemma 4.3 preserves the existence of a causal
flow.
□
Example 4.7 We demonstrate the translation of the following quantum-classical
circuit representing a superdense coding scheme into a ZX
diagram.
|
0
|
0
H
⊕
⊕Z
⊕
H
We start by applying the translation rules from Table 4.1 to obtain the following ZX
diagram with labels corresponding to whether each input or output was a classical or
64

4.3.
Graph-theoretical circuit optimization
quantum wire.
c
c
c
c
To obtain the final weakly graph-like diagram, we apply some spider-fusion steps on
the simple wires to obtain a weakly graph-like diagram.
c
c
c
c
Notice that the
-spiders connected to the inputs and outputs prevent it from being
in graph-like form. However, we can easily rewrite the diagram into a strictly graph-
like form using Lemma 4.3, adding identity spiders to the inputs and outputs where
required.
4.3
Graph-theoretical circuit optimization
We can now describe the Clifford optimization procedure for pure ZX diagrams intro-
duced by Duncan et al. [33]. In their work, they introduce a number of rewriting steps
that preserve the gFlow in a graph-like ZX-diagram and define a reduction strategy
that decreases the number of nodes until it reaches a local minima.
The first rewriting rule, called local complementation and referred as (LC), is
able to remove a proper Clifford node from the diagram by moving its phase to its
neighbours and inverting the connectivity between them. The second rule is called
pivoting (p)and performs a similar operation on a pair of connected Pauli nodes while
switching the connectivity between the two sets of exclusive neighbours to each node,
and the set of common neighbours. The rules have been proven to preserve the gFlow
in a graph-like diagram. They are depicted as follows,
± π
2
α1
αn
...
...
...
(LC)
=
...
α1∓π
2
...
αn∓π
2
α2
...
αn−1
...
α2∓π
2
...
αn−1∓π
2
...
...
∗
aπ
bπ
∗
∗
αi
βj
γk
(p)
=
αi + bπ
βj + (a + b + 1)π
γk + aπ
65

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
Both rules effectively reduce the size of the diagram by at least one node on each
application. The optimization strategy finds matches for both rules and applies them
repeatedly until the diagram cannot be further reduced. The resulting diagrams may
not necessarily be globally minimal. Due to the interactions between the rules, it is
possible for two different orderings of reductions to produce different results. Never-
theless, the optimization procedure has been shown to produce suﬀiciently minimal
circuits when compared to other state of the art algorithms on standardised sets of
benchmarks.
This optimization method has been used as a basis for the construction of ad-
ditional simplification procedures, as in the case of the T-gate reduction algorithm
by Kissinger and van de Wetering [48] and the extended procedure by Backens et
al. [6]. In the following section we will present our extension of this method to ZX
diagrams.
4.4
Grounded ZX optimization
Similarly to the Clifford optimization presented in Section 4.3, our simplification
strategy for ZX
diagrams is based on eliminating nodes from the diagram by sys-
tematically applying a number of rewriting rules while preserving the existence of a
focused gFlow.
The pure ZX rules presented in Section 4.3 can be applied directly in ZX
dia-
grams when the target spiders are not connected to a
generator. For the cases
where some of the target spiders are
-spiders we introduce the following additional
rules.
α1
αn
...
...
...
α2
...
αn−1
...
∗
(LC
)
=
α1 + π
2
αn + π
2
...
...
...
α2 + π
2
...
αn−1 + π
2
...
∗
∗
αi
βj
γk
(p
)
=
αi
βj + π
γk
jπ
∗
∗
αi
βj
γk
(pp
)
=
αi + jπ
βj + (j + 1)π
γk
66

4.4.
Grounded ZX optimization
Notice that both rules (LC ) and (p ) do not decrease the number of spiders in the
diagram. As such, we will focus on rule (pp ) for our optimization.
These rules can be derived using the standard ZX
rules as follows.
• Rule (LC ):
α1
αn
...
...
...
α2
...
αn−1
...
∗
(m)
=
α1
αn
...
...
...
α2
...
αn−1
...
(LC)
=
α1 + π
2
αn + π
2
...
...
...
α2 + π
2
...
αn−1 + π
2
...
• Rule (p ):
∗
∗
αi
βj
γk
(m)
=
αi
βj
γk
(p)
=
αi
βj + π
γk
=
αi
βj + π
γk
• Rule (pp ):
jπ
∗
∗
αi
βj
γk
(m)
=
jπ
αi
βj
γk
(p)
=
αi + jπ
βj + (j + 1)π
γk
If (pp ) is applied with a non-
spider connected to a boundary, the rule produces
a
-spider connected to an input or output thus requires adding an identity operation
as described in Lemma 4.3 to preserve the graph-like property. Since in this case we
add additional nodes to the graph, we will only apply rule (pp ) on a boundary
spider if it can be followed by another node-removing rule.
Additionally, we use rules (ml) and (k) directly to remove nodes in the diagram
when there are
-spiders with degree 1 or 0 in the graph, respectively.
67

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
Lemma 4.1 If the non-
spider in the left-hand side of the discarding rule (ml) is
not connected to an output or input, then applying the rule over a graph-like diagram
D preserves the existence of a focused gFlow.
Proof If the non-
spider in the left-hand side is not connected to an input or output
of the diagram, then applying the rule does not break the graph-like property of D.
The preservation of the gFlow follows from
-spiders being sinks of the underlying
open graph.
□
Lemma 4.2 Rules (LC ), (p ), and (pp ) preserve the existence of a focused
gFlow.
Proof Notice that rules (LC ), (p ), and (pp ) are defined as compositions of
gFlow-preserving rules.
□
In addition to the previous rules, we can derive following ground teleportation rule
from rule (pp ),
αi
βj
=
α
β
αi
βj
α
β
=
αi
βj
α
β
kπ
kπ
kπ
γi
γi
γi
While this rule does not remove any spider, if there is only one β spider then it can
be followed by a use of rules (ml) and (pp ) to delete two nodes from the graph.
Experimentally, this case rarely happened on the tested circuits and therefore we do
not include this rule in our optimization algorithm.
4.5
Ground-cut simplification
The previously introduced rewriting rules require a simplification strategy to apply
them. A simple solution used in the Clifford optimization is to try to find a match
for each rule and apply them iteratively until no more matches are available. Altern-
atively, we can apply non-reducing rewriting rules aimed at exposing hidden optim-
ization opportunities. To that end, we describe a strategy that can find additional
rule matches by operating on the biadjacency matrix between the
-spiders and the
non-
spiders.
Definition 4.1 The ground-cut of a graph-like ZX
diagram D is the cut resulting
from splitting the
and non-
spiders in G(D).
68

4.5.
Ground-cut simplification
Since the diagram is graph-like, there are no internal wires in the
partition.
Given a ZX
diagram D, we denote MD the biadjacency matrix of its ground-cut,
where rows correspond to
-spiders and columns correspond to non-
spiders. We
can apply all elementary row operations on the matrix by rewriting the diagram.
The addition operation between the rows corresponding to the
-spider u and the
-spider v can be implemented via the following rule.
αi
γk
βj
u
v
(+)
=
αi
γk
βj
u
v
The rule can be derived from the ZX
equations as follows.
αi
γk
βj
u
v
(n)
=
αi
γk
βj
u
v
(LC
)u
=
αi −π
2
γk
βj −π
2
u
v
(n)
=
αi −π
2
γk
βj −π
2
u
v
(LC
)u
=
αi
γk
βj
u
v
Using the elementary row operations we can apply Gaussian elimination on the
ground-cut biadjacency matrix of a graph-like ZX
diagram, generating in the process
an equivalent diagram whose ground-cut biadjacency matrix is in reduced echelon
form, where the leading coeﬀicient of each row is strictly to the right of the leading
coeﬀicients of the rows above it.
Any row in the ground-cut biadjacency matrix left without non-zero elements after
applying Gaussian elimination corresponds to an isolated
-spider in the diagram
that can be eliminated by rule (k). If the reduced row echelon form of the biadjacency
matrix contains a row with exactly one non-zero elements, then that element corres-
ponds to an isolated
-spider and non-
spider pair in the diagram and therefore we
can apply rule (ml) to remove the non-
spider.
Example 4.2 The following example demonstrates the application of a Gauss elim-
ination over a graph-like diagram. The corresponding ground-cut adjacency matrices
are shown below each step.
69

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
row1 ←[ row1+row2
−−−−−−−−−−−−→
row3 ←[ row3+row2
−−−−−−−−−−−−→


1
1
0
1
0
1




1
0
0
1
0
1




1
0
0
1
0
0


After the reduction procedure, we can eliminate the isolated
-spiders using rule
(k) and use rule (ml) on the spiders corresponding to the first two rows.
4.6
The Algorithm
Based on the gFlow-preserving rules presented in Section 4.4 and the strategy from
Section 4.5, we define a terminating procedure which turns any graph-like ZX
dia-
gram into an equivalent simplified diagram that cannot be further reduced.
Definition 4.1 A graph-like ZX
diagram is in simplified form if it does not contain
any of the following, up to single-qubit unitaries on the inputs and outputs.
• Interior proper Clifford spiders.
• Adjacent pairs of interior Pauli spiders.
• Interior Pauli spiders adjacent to boundary spiders.
• Interior Pauli spiders adjacent to
-spiders.
• Degree-1
-spiders not connected to input or output spiders.
• Connected components not containing inputs nor outputs.
Example 4.2 The following is a comparison between two equivalent diagrams that
satisfy and do not satisfy the simplified form property.
π
Diagram not in simplified form
π
Diagram in simplified form
Notice that the first diagram contains interior Pauli spiders adjacent to
-spiders
and connected components not containing inputs nor outputs, and therefore it does
not comply with the simplified form rules.
70

4.6.
The Algorithm
We define an optimization algorithm that produces diagrams in simplified form
by piggybacking on the pure optimization procedure. This optimization applies the
local complementations (LC) and pivoting (p) rules until there are no interior proper
Clifford spiders or adjacent pairs of non-
interior Pauli spiders. After the initial pure
simplification, we continue our optimization as follows.
1. Repeat until no rule matches, removing wires between
-spiders and parallel
Hadamard connections after each step:
(a) Run Gaussian elimination on the ground-cut of the diagram as described
in Section 4.5.
(b) Remove the grounds corresponding to null rows with rule (k).
(c) If any row of the biadjacency matrix has a single non-zero element, cor-
responding to a
-spider connected to a spider v, then:
i. If v is not a boundary spider, apply rule (ml).
ii. If v is a boundary spider and v is adjacent to a Pauli spider, apply
rule (ml) immediately followed by the procedure from Lemma 4.3 to
make the diagram graph-like again. Then delete the Pauli neighbour
using rule (pp ), to ensure that the step removes at least one node.
(d) Apply Pauli spider elimination rule (pp ) until there are no Pauli spiders
connected to ground spiders.
2. Remove any connected component of the graph without inputs or outputs.
Notice that each cycle the loop reduces the number of nodes in the graph, so
this is a terminating procedure. Additionally, since each applied rule preserves the
existence of a gFlow the final diagram admits a gFlow.
Example 4.3 We show an an example run of the algorithm on the diagram presented
in Example 4.2.
π
→
π
∗
∗
→
π
∗
∗
→
π
We start by applying Gaussian elimination on the ground-cut of the diagram.
This step simplifies the connections of the third
-spider.
Next, after looking at rows of the biadjacency matrix we remove the disconnected
and apply rule (ml) on the third
-spider to discard an additional node in the
diagram.
Finally, we apply the Pauli elimination rule (pp ) to produce the final diagram.
71

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
4.7
Circuit extraction
We now describe a general circuit extraction procedure for graph-like ZX
diagrams
admitting a focused gFlow into hybrid quantum-classical circuits, by modifying the
procedure for pure diagrams from the Clifford optimization. We present the pseudo-
code in Algorithm 1 and an example of an execution in Section 4.8.
The algorithm progresses through the diagram from right-to-left, maintaining a set
of spiders F, called the frontier, which represents the unextracted spiders connected
to the extracted segment. Each frontier spider is assigned an output qubit line Q(v).
This set is initially populated by the nodes connected to outputs of the diagram. The
strategy is to proceed backwards by steps, adding unextracted spiders into the frontier
and deleting some of them to extract operations on the output circuit, in back-to-front
order. In the pseudocode, we refer to the set of input- and output-spiders connected
to outputs and inputs of the diagram respectively as O and I.
To find candidate spiders to add to the frontier we apply Gaussian elimination
on the biadjacency matrix of the frontier and non-frontier spiders, similarly to the
optimization method described in Section 4.5.
The gFlow property of the graph
ensures that we can always progress by extracting a node; it suﬀices to look at the
set of non-frontier vertices maximal in the order and notice that, after the Gauss
elimination, either we can choose a
-spider from the set, or a non-
spider that has
a single connection to the frontier.
We require the following proposition by Duncan et al. to apply the row additions
on the graph.
Proposition 4.1 ([33, Proposition 7.1]) For any ZX
diagram D, the following
equation holds:
D
...
...
...
...
M
=
D
...
...
...
...
M ′
where M describes the biadjacency matrix of the relevant vertices, and M ′ is the
matrix produced by adding row 2 to row 1 in M. Furthermore, if the diagram on the
left-hand side has a focused gFlow, then so does the right-hand side.
In our pseudocode, the call to CleanFrontier ensures that F only contains
phaseless spiders without internal wires. Notice that it preserves the gFlow since
it only modifies edges between sink nodes and removes spiders with no other con-
nections. After the while loop terminates, all outputs of the circuit will have been
72

4.8.
Extraction examples
extracted. If there are inputs left unextracted, and since the diagram had a gFlow,
we can discard them directly via measurement operations.
Finally, we add any necessary swap operations to map the inputs to the correct
lines and insert qubit initializations and measurements at inputs and outputs marked
as classical. In Chapter 5 we detail a method to better detect the internal parts of
the circuit that can be implemented classically.
In any case, each step of the while loop in Algorithm 1 Line 5 preserves the gFlow
of the diagram and we can show that it terminates in at most |V | steps: Indeed,
if there are no non-frontier spiders, then a call to CleanFrontier will remove all
nodes from the frontier. Moreover, each step of the while loop in Line 5 moves one
non-frontier spider to F.
Lemma 4.2 Each step of the while loop in Algorithm 1, Line 5, preserves the gFlow
of the diagram.
Proof By Proposition 4.1, the Gauss elimination application preserves the gFlow.
Then, look at the set of non-frontier spiders maximal in the gFlow order.
If the set contains a non-
spider u then by definition g(u) ∈F. If OddG(g(u))
does not contain
nodes, after the Gauss elimination there must be a frontier spider
v such that it is only connected to u. Therefore, removing v and making u a sink of
the diagram does not break the gFlow.
In the other case, since
-spiders are always sinks of the diagram, promoting
them to the frontier does not modify the gFlow of the diagram.
Finally, the call to CleanFrontier does not modify the gFlow.
□
Lemma 4.3 The algorithm terminates.
Proof Notice that if there are no non-frontier spiders, then a call to CleanFron-
tier will remove all nodes from the frontier. Notice that each step of the while loop
in Line 5 moves one non-frontier spider to F. Therefore, the loop terminates in at
most |V | steps.
□
4.8
Extraction examples
We show here an example of running the extraction procedure on a diagram. The
frontier set is demarcated with a dashed red box, and the extracted circuit is repres-
ented with their ZX equivalent directly connected to the right of the frontier.
73

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
We start with the frontier initialized as the output vertices, and directly extract
any
.
Clean
frontier
−−−−−→
During each step of the algorithm, a maximal non-extracted element in the gFlow
order is chosen. Candidates can be chosen eﬀiciently without calculating the gFlow
by running Gauss elimination on the biadjacency matrix between the border and the
non-extracted spiders, and mirroring the row-sum operations using a gFlow preserving
rewrite rule on the diagram.
Gauss
−−−→
∗
Extract
−−−−→
∗
Extract
−−−−→
Now, there are no candidate frontier spiders connected to a single unextracted spider.
We must therefore extract one of the connected
-spiders as a qubit termination.
Extract
−−−−→
Clean
frontier
−−−−−→
∗
Extract
−−−−→
If after any step there are nodes in the frontier that are not connected to any
internal spider then they can be removed from the frontier and extracted as a qubit
initialization, as show in the following example.
∗
→
74

4.9.
Implementation and benchmarks
4.9
Implementation and benchmarks
We have implemented each of the algorithms presented in this work as an extension
to the open-source Python library PyZX [47] by modifying its implementation of ZX
diagrams to admit ZX
primitives. A repository with the complete code is available
on GitHub [10], and parts of the implementation have been upstreamed to the main
PyZX repository. We additionally implemented a naive ZX
extension of the pure
Clifford optimization for comparison purposes, which doesn’t use any of our
rewrit-
ing rules. When applied to pure quantum circuits, our algorithm does not perform
additional optimizations after the Clifford procedure and therefore achieves the same
benchmark results recorded by Duncan et al. on the circuit set described by Amy et
al. [2].
We tested the procedure over two classes of randomly generated hybrid circuits,
and measured the size of the resulting diagram as the number of spiders left after the
optimization. This metric correlates with the size of the final circuit, although the
algorithmic noise caused by the arbitrary choices in the extraction procedure may
result in some cases in bigger extracted circuit after a reduction step.
The first test generates Clifford+T circuits with measurements by applying ran-
domly chosen gates from the set {CNOT, S, HSH, T, Meas} over a fixed number
of qubits, where Meas are measurement gates on a qubit immediately followed by
a qubit initialization. We fix the probability of choosing a CNOT, S, or HSH gate
to 0.2 each and vary the probabilities for T and Meas in the remaining 0.4. These
circuits present a general worst case, where there is no additional classical structure
to exploit during the hybrid circuit optimization.
The second type of generated operations are classical parity-logic circuits. These
consist on a number of classical inputs, fixed at 10, where we apply randomly chosen
operations from the set {NOT, XOR, Fanout} with probabilities 0.3, 0.3, and 0.4
respectively.
In Figure 4.1 we compare the results of our optimization using the Clifford optim-
ization as baseline. Figure 4.1a shows the reduction of diagram size when running the
algorithm on randomly generated Clifford+T circuits with measurement. We vary
the probability of generating a measurement gate between 0 and 0.2 while corres-
pondingly changing the probability of generating a T-gate between 0.4 and 0.2 and
show the results for different combinations of qubit and gate quantities. We remark
that the optimization produces noticeably smaller diagrams once enough
generators
start interacting with each other. There is a critical threshold of measurement gate
probability, especially visible in the cases with 8 qubits and 1024 gates, where with
high probability the outputs of the diagram become disconnected from the inputs due
to the
interactions. This results in our algorithm optimizing the circuits to produce
a constant result while discarding their input.
75

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
(a) Diagram size reduction on Clifford+T circuits with measurements.
(b) Diagram size reduction on parity-logic circuits.
Figure 4.1: Benchmark results on randomly generated diagrams.
Figure 4.1b shows the comparison of diagram size between our procedure and
the Clifford optimization when run over classical parity circuits. The optimization
produces consistently smaller diagrams, generally achieving the theoretical minimal
number of
generators, equal to the number of inputs. We further remark that in
all of the tested cases the classicalisation procedure was able to detect that all the
extracted operations on the optimized parity-logic circuit were classically realisable.
The runtime of our algorithm implementation is polynomial in the size of the
circuit. As with the Clifford optimization, the cost of our optimization and extraction
processes is dominated by the Gauss elimination steps. For the ground-node rewriting
rules, our unoptimised implementation is roughly O(n2k2) in the worst case with k
being the number of measurement gates and n the number of gates, but in practice
it behaves cubically on the number of gates due to the sparseness of the diagrams.
The implementation was not developed with a focus on the runtime cost, and some
76

4.9.
Implementation and benchmarks
possible optimizations may reduce this bound.
77

Chapter 4.
Optimizing hybrid quantum-classical circuits with the ZX⏚calculus
Algorithm 1 Circuit extraction
1: function Extraction
2:
F : Set⟨Node⟩←O, Q : Map⟨Node, int⟩←∅
3:
for all v ∈F do Q(v) ←Output connected to v
4:
CleanFrontier(F, Q)
5:
while F ̸= ∅do
6:
Run Gauss elimination on the frontier biadjacency matrix M (Prop. 4.1)
▷M is in row echelon form
7:
if a row of M has a single non-zero element then
8:
Let u and v be the corresponding non-frontier and frontier node
9:
Q(u) ←Q(v)
10:
Remove v from the diagram and add u to F
11:
else
12:
v ←Arbitrary
-spider in the neighbourhood of F
13:
Q(v) ←New qubit line id
14:
Extract a classical bit termination on Q(v) and add u to F
15:
CleanFrontier(F, Q)
16:
for all Unextracted v ∈I do
17:
Q(v) ←Input connected to v
18:
Extract a measurement gate and a classical bit termination on Q(v)
19:
Assign the corresponding input to Q(v)
20: function CleanFrontier(F, Q)
21:
for all v ∈F do
22:
if v is a
-spider then Remove the
, extract a measurement on Q(v)
23:
if v has a phase α ̸= 0 then Set α = 0, extract a Zα gate on Q(v)
24:
for all u ∈F, v ∼u do Remove the wire, extract a CZ gate on Q(v), Q(u)
25:
if v is not connected to any other node then
26:
Remove v
27:
if v ∈I then assign the input to qubit Q
28:
else extract a |+⟩qubit initialization on Q(v)
78

5
Classicality detection using ZX⏚
diagrams
In Chapter 4 we describe an optimization procedure for quantum circuits that uses
the ZX
calculus as an alternative representation to perform rewriting operations.
During this simplification process we forget the difference between quantum and clas-
sical wires and use a single type of edge to represent interconnections in the diagram.
This step allows the algorithm to optimize the complete hybrid system as a homo-
geneous diagram, where operations that can be done either quantumly or classically
have a common representation. While this is a necessary step for the optimization, it
carries the loss of information on which parts of the circuit can be implemented clas-
sically. The extraction procedure from ZX
diagrams into hybrid quantum-classical
circuits presented in Section 4.7 defaults into always favouring the use of quantum
gates.
While the circuits generated by the method are correct representations of
the quantum operations, they are almost completely composed by quantum operands
and wires, and do not include any classical operation beyond qubit preparations and
measurements on some inputs and outputs.
Generally, in a physical quantum computer the implementation of classical opera-
tions is more eﬀicient than their quantum counterparts, in addition to being cheaper
and less error prone. In the case of quantum simulators, they are commonly able to
exploit the knowledge of which wires carry classical data to speed up their operation.
As such, in this chapter we explore a method to detect parts of a hybrid quantum
circuits that can be turned into classical circuits. These techniques can be directly
applied after the previously presented extraction procedure.
Notice, however, that while we aim to recognize all classically realizable operations
in the circuit, the characteristics of each quantum computer may dictate the final
choice between quantum and classical operators by considering the costs of exchanging
data between both realms.
79

Chapter 5.
Classicality detection using ZX⏚diagrams
5.1
The classicalisation problem
In this section we define the classicalisation problem as a labelling problem on the
wires of a ZX
diagram that indicates the flow of classical information. Given a
ZX
diagram corresponding to a quantum circuit, a valid labelling can be used to
guide the extraction back into hybrid gates (Cf. Section 5.2). This formulation can
be directly combined with the extraction method from ZX
diagrams admitting an
extended gFlow into hybrid quantum-classical circuits presented in Chapter 4.
Given a ZX
diagram, we decorate its wires using labels from the set L =
{Q, X, Y, Z, ⊥}. In a circuit-like diagram, the label Z indicates that this particular
wire in the corresponding circuit carries the same information as a classical wire with
data in the computational-basis and could be potentially replaced by one, possibly
adding a standard basis measurement and a qubit initialisation in the standard basis
depending on whether the connected wires are also classical or not. Similarly, the X
and Y labels represent classical information carriers in the diagonal and Y basis re-
spectively. A Q label means that the wire is a quantum wire carrying any (potentially
entangled) qubit value, and finally the ⊥label marks a wire carrying no information,
which could be replaced by discarding the input and generating a maximally mixed
state as output. That is, a ⊥can always be replaced by two
generators.
The wire labels can be interpreted as density matrix subspaces of C2×2, represent-
ing all possible mixed states allowed by a particular kind of wire. This interpretation
is defined as follows.
Q = C2×2
Z = {α |0⟩⟨0| + β |1⟩⟨1| | α, β ∈R≥0, α + β = 1}
⊥= { 1
2 |0⟩⟨0| + 1
2 |1⟩⟨1|}
X = {α |+⟩⟨+| + β |−⟩⟨−| | α, β ∈R≥0, α + β = 1}
Y = {α |⟳⟩⟨⟳| + β |⟲⟩⟨⟲| | α, β ∈R≥0, α + β = 1}
The set of labels L therefore form a partial order given by ⊆which can be depicted
as follows.
Q
X
Y
Z
⊥
Notice that the greatest common ancestor of two labels A ⊔B corresponds to the
intersection of the sets.
A labelling L of a diagram D is a map from its edges into a pair of labels. The two
labels, drawn at each end of the wire, indicate the origin of the constraint. Intuitively,
Z
A means that the wire is produced in such a way that guarantees that the qubit
carries classical information encoded in the computational basis, whereas
A
Z means
that the wire can be replaced by a classical wire because some future process will
80

5.2.
Labelled diagrams as hybrid circuits
force this qubit to be in that basis —for instance, it is going to be measured in the
standard basis and thus one can pre-emptively measure this qubit in the standard
basis and use a classical wire instead. We define a partial order between labellings of
a diagram as the natural lift from the partial order of the labels.
A labelling is valid if we can cut any wire in the diagram and, after forcing a
valid state in the inputs and outputs, we get a valid state in the cut terminals. That
is, we rearrange the diagram to transform all outputs into inputs and connect the
cut terminals as outputs as shown below. Then, any arbitrary input ρ ∈(⊗n
i Ai) ⊗
(⊗m
j Dj) applied to the diagrams produces an output in E ⊗F.
A1
An
B1
An
...
C1
Cm
D1
Dm
...
E
F
D
Notice that if A is a valid label for a wire then any B ≥A is also valid, and in
particular Q is always a valid label. We can therefore omit unnecessary labels in the
diagrams, marking them implicitly as Q.
Given a ZX
diagram D with marked classical inputs and outputs, we define the
classicalisation problem as finding a minimal valid labelling where the inputs and
outputs are labelled as Q or Z accordingly.
5.2
Labelled diagrams as hybrid circuits
Consider now the diagrams resulting from the translation of a hybrid quantum-
classical circuit with parity classical logic. As the classicalisation problem can be
defined on arbitrary diagrams we are not required to produce graph-like diagrams as
is the case with the compilation presented in Chapter 4. We present instead a simpler
81

Chapter 5.
Classicality detection using ZX⏚diagrams
direct translation which produces diagrams with both colours of spider.
7→
7→
7→
7→
7→
|
0
7→
|
0
7→
|0
7→
| 7→
|
7→
7→
7→
π
Xα
7→
α
Zα
7→
α
H
7→
Z
7→
⊕
7→
7→
⊕
7→
Since the labelling process does not alter the diagram corresponding to a circuit, we
will now consider the significance of a labelling on a circuit.
Notice that due to the collapse of both quantum and classical wires into a single
type of diagram edge, some quantum and classical gates may have the same dia-
grammatic representation, as show below for the case of a quantum X rotation and a
classical NOT gate.
Xπ
7→
π
←[
In the extraction procedure presented in Chapter 4 we took the most general
strategy consisting of always extracting such patterns as quantum gates, and only
introducing classical wires in the corresponding. However, given a valid labelling on
the diagram we may be able to correctly introduce classical gates in the circuit.
Consider a circuit applying an X rotation gate over a classical input,
|
Xπ
and its corresponding ZX
diagram labelled,
π
Z
Z
The local label information around the spider further signals that both wires carry
data in the computational basis. Therefore, we can replace the X gate in the circuit
82

5.2.
Labelled diagrams as hybrid circuits
with a classical NOT gate while preserving the semantics of the operation. We can
verify this using the semantics,
∀ρ ∈Z
r |
Xπ
z
(ρ) = J
|
K (ρ)
where U(ρ) = U †ρ U.
Following this idea, given a valid labelling of the diagram corresponding to a
circuit we present below a set of replacement rules for each quantum gate.
This
replacement operation introduces qubit preparations and measurements that can be
cancelled where applicable.
Gate
Labelled diagram
Replacement gates
|
0
|
0
|
|0
|
Xπ
π
B
A
|
where A ⊔B ≤Z
Zα
α B
A
|
where A ⊔B ≤Z
⊕
B
A
⊕
|
where A ⊔B ≤Z
B
A
D
C
|
|
where A ⊔B ≤Z and C ⊔D ≤Z
⊕
Z
Z
|
Z
Z
Z
Z
|
|
Lemma 5.1 The replacement operations preserve the semantics of the circuit.
Proof By case analysis on the labelled diagrams.
83

Chapter 5.
Classicality detection using ZX⏚diagrams
• J |
0
|
K = |0⟩⟨0| = J
K
•
q
|
y
= ρ 7→⟨0| ρ |0⟩+ ⟨1| ρ |1⟩= J
K
•
q
|
y
= ρ 7→|1⟩⟨0| ρ |0⟩⟨1| + |0⟩⟨1| ρ |1⟩⟨0| =
q
π
B
A
y
where A ⊔
B ≤Z.
•
q
|
y
= ρ 7→|0⟩⟨0| ρ |0⟩⟨0|+|1⟩⟨1| ρ |1⟩⟨1| =
q
α B
A
y
where A⊔B ≤
Z.
•
s
⊕
|
{
= ρ 7→U †
0ρU0 + U †
1ρU1 =
s
B
A
{
where A ⊔B ≤Z,
U0 = |00⟩⟨00| + |01⟩⟨01|, and U1 = |11⟩⟨10| + |10⟩⟨11|.
•
u
v
|
|
}
~ = ρ 7→∑
i∈{00,01,10,11} U †
i ρUi =
s
B
A
D
C
{
where A ⊔
B ≤Z, C ⊔D ≤Z, U00 = |00⟩⟨00|, U01 = |01⟩⟨01|, U10 = |11⟩⟨10|, and
U11 = |10⟩⟨11|.
•
u
wv
|
}
~ = ρ 7→∑
i∈{00,01,10,11} U †
i ρUi =
s
Z
Z
{
where
U00 = |0⟩⟨00|, U01 = |1⟩⟨01|, U10 = |1⟩⟨10|, and U11 = |0⟩⟨11|.
•
s
Z
{
= ρ 7→∑
i∈{00,01,10,11} U †
i ρUi =
u
v
Z
Z
Z
}
~ where U00 = |0⟩⟨00|,
U01 = |1⟩⟨01|, U10 = |0⟩⟨10|, and U11 = |1⟩⟨11|.
□
5.3
Push-relabel algorithm
We present a local search labelling heuristic for ZX
diagrams with explicit Hadamard
gates —replacing the Hadamard wires— and only green spiders, that produces locally
minimal labellings by propagating the labels over individual spiders.
We introduce three operations over the labels. First, a binary function represent-
ing the result of combining two wires via a phaseless green spider, ⋆: L × L →L.
Z ⋆A = Z
X ⋆A = A
Y ⋆Y = X
Q ⋆Y = Q
⊥⋆Y = ⊥
A ⋆Z = Z
A ⋆X = A
Y ⋆Q = Q
Q ⋆Q = Q
⊥⋆Q = Z
Y ⋆⊥= ⊥
Q ⋆⊥= Z
⊥⋆⊥= ⊥
84

5.3.
Push-relabel algorithm
Notice that (L, ⋆) is a commutative monoid with X as neutral element. We also define
a “Z rotation” operation for α ∈[0, 2π), rotα : L →L.
rotα(Z) = Z
rotα(Q) = Q
rotα(⊥) = ⊥
rotα(X) =





X
if α ∈{0, π}
Y
if α ∈{ 1
2π, 3
4π}
Q
otherwise
rotα(Y) =





Y
if α ∈{0, π}
X
if α ∈{ 1
2π, 3
4π}
Q
otherwise
This corresponds to the identity if α ∈{0, π}, and in general rotα(A)⋆b ≥rotα(A⋆B).
Finally, we define a function H representing the application of the Hadamard
operation over a label, H : L →L.
H(Q) = Q
H(X) = Z
H(Z) = X
H(Y) = Y
H(⊥) = ⊥
Our classical detection procedure starts by labelling any classical input or output
with a Z label, and any
with a ⊥label, and the rest of the diagram wires with Q.
It then proceeds by propagating the labels using the following rules:
A
C
D
B
(ch)
→
A
C ⊔H(D)
D
B ⊔H(A)
α
Ai
Bi
i
(cz)
→
α
Ai
Bi ⊔rotα(⋆j̸=iAj)
i
α
Ai
Bi
i
(cx)
→
α
Ai
Bi ⊔H(rotα(⋆j̸=iH(Aj)))
i
For any labels A, B, C, D, E, F ∈L.
We apply these rules until there are no more labels to change. Since each time
we replace labels with lesser ones in the order, the procedure terminates. Finally, we
can interpret wires with a classical label in any direction as classically realisable.
Example 5.1 This example shows the classicalisation of a hybrid quantum-classical
circuit using the push-relabel algorithm. Q labels in the diagrams are omitted.
X
|
⊕
∼
π
c
c
q
q
Labelling
−−−−−→
c
c
q
q
Z
Z
Z
Z
Z
Z
π
∼
|
We now proceed to show that our push-relabel algorithm always produces valid
labellings. To that end we first prove that both rules (ch) and (cz) produce valid
labellings.
85

Chapter 5.
Classicality detection using ZX⏚diagrams
Lemma 5.2 The labelling rule (ch) preserves the validity of the labelling.
Proof We prove the validity of the replacement of label B. The replacement of label
C is the symmetric case.
Since the starting diagram has a valid labelling, B ⊔H(A) is a valid label if H(A)
is a valid label. Therefore, the label is valid if ∀ρ ∈A ⊗B,
s
A
D
H(A)
{
◦ρ ∈H(A) ⊗D
Notice that this is equivalent to requiring ∀a ∈A, (H a H†) ∈H(A), which follows
from the definition of H(·).
□
Lemma 5.3 The labelling rule (cz) preserves the validity of the labelling.
Proof By induction on the number of wires.
• If n = 0, there are no labelled wires.
• If n = 1, since the starting diagram has a valid labelling, B1 ⊔rotα(X) is a valid
labelling if rotα(X) is valid. Notice that
J α
K =
( 1
e−iα
eiα
1
)
∈rotα(X)
• If n = 2, we prove the validity of the replacement of label B2. The replacement
of label B1 is the symmetric case.
Since the starting diagram has a valid labelling, B2 ⊔rotα(A1) is a valid label
if rotα(A1) is a valid label. Therefore, the label is valid if ∀ρ ∈A1 ⊗B1,
u
v
α
A1
B1
rotα(A1)
}
~ ◦ρ ∈rotα(A1) ⊗B1
Notice that this is equivalent to requiring ∀a ∈A1, (U a U †) ∈rotα(A1) for
U = |0⟩⟨0| + eiα |1⟩⟨1|, which follows from the definition of rotα(·).
• If n = 3, we prove the validity of the replacement of label B1. The replacement
of labels B2 and B3 are the symmetric case.
86

5.3.
Push-relabel algorithm
Since the starting diagram has a valid labelling, B1 ⊔rotα(A2 ⋆A3) is a valid
label if rotα(A2⋆A3) is a valid label. We can split the diagram as follows, adding
an intermediary label.
α
A2
rotα(A2 ⋆A3)
A3
(f)
−−→
α
A2
A2 ⋆A3
A3
rotα(A2 ⋆A3)
Notice that by the inductive hypothesis, the labelling step for the degree-2
spider is correct.
Therefore, it suﬀices to prove that the intermediary label
A2 ⋆A3 is valid, that is ∀ρ ∈A2 ⋆A3 ⊗Q,
u
vA3
Q
A2 ⋆A3
A2
}
~ ◦ρ ∈(A2 ⋆A3) ⊗Q
Notice that this is equivalent to requiring ∀a2 ∈A2, a3 ∈A3, (U (a2 ⊗a3) U †) ∈
A2 ⋆A3 for U = |0⟩⟨00| + |1⟩⟨11|, which follows from the definition of ⋆.
• If n > 3, for each i and for some k ̸= i we can rewrite the diagram as follows,
and apply (cz) twice to produce the target Bi ⊔rotα(⋆j̸=iAj) label.
α
Aj
Bj
j ̸∈{i, k}
Ak
Bk
Ai
Bi
↠
α
Aj
Bj
j ̸∈{i, k}
Ak
Bk ⊔rotα(⋆j̸=iAj)
Ai
Bi
⋆j̸∈{i,k}Aj
By inductive hypothesis, both rule applications produce valid labellings.
□
Lemma 5.4 The labelling rule (cx) preserves the validity of the labelling.
Proof By applying the colour changing rule (h) and Lemmas 5.2 and Lemmas 5.3.□
Lemma 5.5 The local-search labelling algorithm produces a valid labelling according
to the standard interpretation of the ZX
calculus.
Proof Notice that labelling every wire as Q is always valid and hence the algorithm
starts with a valid labelling. By Lemmas 5.2, 5.3, and 5.4, each step applying rules
(cz), (cx) and (ch) preserve the validity and therefore the final labelling is valid. □
87

Chapter 5.
Classicality detection using ZX⏚diagrams
5.4
Global minima computation
The push-relabel algorithm presented in Section 5.3 eﬀiciently finds a locally minimum
labelling of the diagram. However, the procedure does not always reach a globally
minimum labelling. Consider for example the following input diagram,
Z
Z
Q
Q
Here, although the diagram is equivalent to the identity and the outputs could the-
oretically be labelled as Z, the entangled wires in the middle do not allow for local
propagation of the classical labels past the double controlled Z gates.
In general, finding the global minimum in the classicalisation problem has the
same complexity as fully simulating a quantum circuit. Indeed, consider a circuit C
solving an Exact Quantum Polynomial-Time (EQP) decision problem precomposed
with a constant input x and postcomposed with a controlled Hadamard operation,
|
x
H
C
|...
|
0
Simulating the output of C(x) is equivalent to deciding if the output can be labelled
as either Z or X.
88

Conclusion
We are still a long way from having fully functional quantum computers can be
used for real-world applications. However, the progress made in the last few years is
very promising. Part of this progress requires the development of tools that help with
compiling human-readable descriptions of quantum algorithms into eﬀicient programs
that can be executed on a quantum computer. In this thesis we have presented a series
of contributions to the different stages of the quantum compilation process, from the
representation of high-level primitives in an optimizable intermediate representation,
to gate-level optimizations of quantum circuits.
Throughout this work we have focused on methods that employ multiple exten-
sions of the ZX calculus to manipulate the quantum programs during each step of
the compilation. We found that it is a very powerful tool for this kind of reasoning,
since it splits the circuit description into simpler elements that lend themselves well to
optimization techniques. Furthermore, the formal nature of the calculus have allowed
us to easily prove the correctness of each of the transformations we have developed.
For our first contribution we leveraged a scalable extension of the ZX calculus
to define a new intermediate representation of quantum programs that is able to
compactly represent the repeated structures generated during iterations and paral-
lel operations. This representation was used to compile a reduced fragment of the
Proto-Quipper-D language, where we showed examples of the encoding of non-trivial
algorithms. As future work, we plan to give some well-suited formal semantics to the
intermediate representation, and to use it as the compilation target of other high-level
quantum programming languages.
For our second contribution we developed a new method for the optimization of
hybrid quantum-classical circuits by first transforming them into a ZX
diagrams and
applying a series of formally proven transformations using an eager algorithm. We
implemented these methods on pyzx, a Python library for manipulating ZX diagrams
and optimizing circuits with it. Part of this work has been upstreamed into the main
project.
Lastly, we defined a problem for detecting classically implementable logic in
quantum circuits. We described a heuristic algorithm for solving the problem, and
89

Conclusion
discussed why an exact solver would be intractable. This development was aimed for
the artifacts produced by our optimizing compilation program, but it can be used for
processing arbitrary quantum circuits.
90

Bibliography
[1] Mario Alvarez-Picallo, Dan R. Ghica, David Sprunger, and Fabio Zanasi.
Functorial
String
Diagrams
for
Reverse-Mode
Automatic
Differentiation.
arXiv:2107.13433 [cs], July 2021. arXiv: 2107.13433.
[2] Matthew Amy, Dmitri Maslov, and Michele Mosca. Polynomial-time T-depth
Optimization of Clifford+T circuits via Matroid Partitioning. IEEE Transactions
on Computer-Aided Design of Integrated Circuits and Systems, 33(10):1476–1489,
October 2014. arXiv: 1303.2042.
[3] Pablo Arrighi, Alejandro Díaz-Caro, and Benoît Valiron. The vectorial ￿-calculus.
Information and Computation, 254:105–139, 2017.
[4] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C Bardin, Rami
Barends, Rupak Biswas, Sergio Boixo, Fernando GSL Brandao, David A Buell,
et al. Quantum supremacy using a programmable superconducting processor.
Nature, 574(7779):505–510, 2019.
[5] Miriam Backens and Aleks Kissinger. ZH: A complete graphical calculus for
quantum computations involving classical non-linearity. Electronic Proceedings
in Theoretical Computer Science, 287:23–42, jan 2019.
[6] Miriam Backens, Hector Miller-Bakewell, Giovanni de Felice, Leo Lobski, and
John van de Wetering. There and back again: A circuit extraction tale, 2020.
[7] HP Barendregt. The lambda calculus. number 103 in studies in logic and the
foundations of mathematics, 1991.
[8] Andrej Bauer, Philipp G. Haselwarter, and Peter LeFanu Lumsdaine. A general
definition of dependent type theories, 2020.
[9] Agustín Borgna and Rafael Romero. Encoding High-level Quantum Programs
as SZX-diagrams. In QPL2022, Oxford, United Kingdom, June 2022.
91

BIBLIOGRAPHY
[10] Agustín Borgna. Ground optimization extensions to pyzx. https://github.
com/aborgna/pyzx/tree/zxgnd, 2021.
[11] Agustín Borgna, Simon Perdrix, and Benoît Valiron. Hybrid Quantum-Classical
Circuit Simplification with the ZX-Calculus. In Hakjoo Oh, editor, Programming
Languages and Systems, pages 121–139, Cham, 2021. Springer International Pub-
lishing.
[12] Titouan Carette. A note on diagonal gates in SZX-calculus. arXiv:2012.09540
[quant-ph], December 2020. arXiv: 2012.09540.
[13] Titouan Carette, Yohann D’Anello, and Simon Perdrix. Quantum Algorithms
and Oracles with the Scalable ZX-calculus. Electronic Proceedings in Theoretical
Computer Science, 343:193–209, September 2021.
[14] Titouan Carette, Marc de Visme, and Simon Perdrix.
Graphical Language
with Delayed Trace:
Picturing Quantum Computing with Finite Memory.
arXiv:2102.03133 [quant-ph], April 2021. arXiv: 2102.03133.
[15] Titouan Carette, Dominic Horsman, and Simon Perdrix. SZX-calculus: Scalable
Graphical Quantum Reasoning.
arXiv:1905.00041 [quant-ph], page 15 pages,
2019. arXiv: 1905.00041.
[16] Titouan Carette, Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. Com-
pleteness of graphical languages for mixed states quantum mechanics, 2019.
[17] Titouan Carette and Simon Perdrix.
Colored props for large scale graphical
reasoning. arXiv:2007.03564 [quant-ph], July 2020. arXiv: 2007.03564.
[18] David Cattanéo and Simon Perdrix. Minimum degree up to local complement-
ation: Bounds, parameterized complexity, and exact algorithms. Lecture Notes
in Computer Science, pages 259–270, 2015.
[19] Iliano Cervesato and Frank Pfenning. A linear logical framework. Proceedings
11th Annual IEEE Symposium on Logic in Computer Science, pages 264–275,
1996.
[20] Nicholas Chancellor, Aleks Kissinger, Joschka Roffe, Stefan Zohren, and Dominic
Horsman. Graphical Structures for Design and Verification of Quantum Error
Correction. arXiv preprint arXiv:1611.08012, 2016.
[21] Nicholas Chancellor, Aleks Kissinger, Joschka Roffe, Stefan Zohren, and Dominic
Horsman. Graphical Structures for Design and Verification of Quantum Error
Correction. arXiv:1611.08012 [quant-ph], January 2018. arXiv: 1611.08012.
92

BIBLIOGRAPHY
[22] Bob Coecke and Ross Duncan. Interacting Quantum Observables. In Automata,
Languages and Programming, Lecture Notes in Computer Science, pages 298–
310, Berlin, Heidelberg, 2008. Springer.
[23] Bob Coecke and Simon Perdrix. Environment and classical channels in categor-
ical quantum mechanics. Logical Methods in Computer Science, Volume 8, Issue
4, November 2012.
[24] Bob Coeke and Aleks Kissinger. Picturing Quantum processes - A diagrammatic
approach. Cambridge University Press, 2017.
[25] Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. Open
quantum assembly language, 2017.
[26] Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. Open
quantum assembly language, 2017.
[27] Niel de Beaudrap. Finding flows in the one-way measurement model. Physical
Review A, 77(2), Feb 2008.
[28] Niel de Beaudrap and Dominic Horsman. The ZX calculus is a language for
surface code lattice surgery. Quantum, 4:218, January 2020. tex.ids: debeau-
drapZXCalculusLanguage2020a arXiv: 1704.08670.
[29] Niel de Beaudrap, Aleks Kissinger, and John van de Wetering. Circuit Extraction
for ZX-diagrams can be #P-hard. arXiv:2202.09194 [quant-ph], February 2022.
arXiv: 2202.09194.
[30] Niel de Beaudrap and Martin Pei.
An extremal result for geometries in the
one-way measurement model, 2007.
[31] Cirq Developers. Cirq, August 2021. See full list of authors on Github: ht-
tps://github .com/quantumlib/Cirq/graphs/contributors.
[32] Alejandro Dí az-Caro. A lambda calculus for density matrices with classical and
probabilistic controls. In Programming Languages and Systems, pages 448–467.
Springer International Publishing, 2017.
[33] Ross Duncan, Aleks Kissinger, Simon Perdrix, and John van de Wetering. Graph-
theoretic simplification of quantum circuits with the zx-calculus, 2019.
[34] Ross Duncan and Maxime Lucas. Verifying the Steane code with Quantomatic.
Electronic Proceedings in Theoretical Computer Science, 171:33–49, December
2014. arXiv: 1306.4532.
93

BIBLIOGRAPHY
[35] Ross Duncan and Simon Perdrix. Rewriting measurement-based quantum com-
putations with generalised flow. In International Colloquium on Automata, Lan-
guages, and Programming, pages 285–296. Springer, 2010.
[36] R Kent Dybvig. The SCHEME programming language. Mit Press, 2009.
[37] MD SAJID ANIS et al. Qiskit: An open-source framework for quantum com-
puting, 2021.
[38] Peng Fu.
dpq, proto-quipper-d implementation.
https://gitlab.com/
frank-peng-fu/dpq-remake, 2022.
[39] Peng Fu, Kohei Kishida, Neil J. Ross, and Peter Selinger.
A tutorial intro-
duction to quantum circuit programming in dependently typed Proto-Quipper.
arXiv:2005.08396 [quant-ph], December 2020. arXiv: 2005.08396.
[40] Peng Fu, Kohei Kishida, Neil J. Ross, and Peter Selinger. Proto-quipper with
dynamic lifting, 2022.
[41] Peng Fu, Kohei Kishida, and Peter Selinger. Linear Dependent Type Theory
for Quantum Programming Languages. arXiv:2004.13472 [quant-ph], December
2021. arXiv: 2004.13472.
[42] Alexander S. Green, Peter LeFanu Lumsdaine, Neil J. Ross, Peter Selinger, and
Benoît Valiron. Quipper. ACM SIGPLAN Notices, 48(6):333, Jun 2013.
[43] Luke Heyfron and Earl T. Campbell.
An Eﬀicient Quantum Compiler that
reduces T count. arXiv:1712.01557 [quant-ph], June 2018. arXiv: 1712.01557.
[44] Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. Completeness of the
ZX-Calculus. arXiv:1903.06035 [quant-ph], October 2019. arXiv: 1903.06035.
[45] Richard Jozsa. An introduction to measurement based quantum computation.
Quantum Information Processing, 199, 09 2005.
[46] N. Khammassi, G. G. Guerreschi, I. Ashraf, J. W. Hogaboam, C. G. Almudever,
and K. Bertels. cqasm v1.0: Towards a common quantum assembly language,
2018.
[47] Aleks Kissinger and John van de Wetering. PyZX: Large Scale Automated Dia-
grammatic Reasoning. Electronic Proceedings in Theoretical Computer Science,
318:229–241, May 2020. arXiv: 1904.04735.
94

BIBLIOGRAPHY
[48] Aleks Kissinger and John van de Wetering. Reducing T-count with the ZX-
calculus. arXiv:1903.10477 [quant-ph], January 2020. arXiv: 1903.10477.
[49] Xavier Leroy, Damien Doligez, Alain Frisch, Jacques Garrigue, Didier Rémy, and
Jérôme Vouillon. The ocaml system: Documentation and user’s manual. INRIA,
3:42.
[50] Gushu Li, Li Zhou, Nengkun Yu, Yufei Ding, Mingsheng Ying, and Yuan Xie.
Projection-based runtime assertions for testing and debugging quantum pro-
grams. Proc. ACM Program. Lang., 4(OOPSLA), November 2020.
[51] Simon Marlow et al. Haskell 2010 language report. Available online http://www.
haskell. org/(May 2011), 2010.
[52] Paul-André Melliès. Functorial Boxes in String Diagrams. In Computer Science
Logic, volume 4207, pages 1–30. Springer Berlin Heidelberg, Berlin, Heidelberg,
2006. Series Title: Lecture Notes in Computer Science.
[53] Mehdi Mhalla, Mio Murao, Simon Perdrix, Masato Someya, and Peter S. Turner.
Which Graph States are Useful for Quantum Information Processing? In Theory
of Quantum Computation, Communication, and Cryptography, volume 6745,
pages 174–187. Springer Berlin Heidelberg, Berlin, Heidelberg, 2014.
[54] Hector Miller-Bakewell. Finite Verification of Infinite Families of Diagram Equa-
tions. Electronic Proceedings in Theoretical Computer Science, 318:27–52, May
2020. arXiv: 1904.00706 version: 2.
[55] Huy-Tung Nguyen and Sang il Oum. The average cut-rank of graphs, 2019.
[56] Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum
Information: 10th Anniversary Edition. Cambridge University Press, 2011.
[57] Francisco Noriega and Alejandro Díaz-Caro. The vectorial lambda calculus re-
visited, 2020.
[58] Michele Pagani. Some advances in linear logic. Mémoire pour l’obtention de
l’habilitation à diriger les recherches, December 2013.
[59] Michele Pagani, Peter Selinger, and Benoît Valiron.
Applying quantitative
semantics to higher-order quantum computing.
arXiv:1311.2290 [quant-ph],
November 2013.
tex.ids:
paganiApplyingQuantitativeSemantics2014 arXiv:
1311.2290 tex.publisher: ACM.
95

BIBLIOGRAPHY
[60] John Preskill. Quantum Computing in the NISQ era and beyond. Quantum,
2:79, August 2018.
[61] PETER SELINGER. Towards a quantum programming language. Mathematical
Structures in Computer Science, 14(4):527–586, 2004.
[62] Peter Selinger. Dagger compact closed categories and completely positive maps:
(extended abstract). Electronic Notes in Theoretical Computer Science, 170:139
– 163, 2007. Proceedings of the 3rd International Workshop on Quantum Pro-
gramming Languages (QPL 2005).
[63] Peter Selinger. Quantum circuits of t-depth one. Physical Review A, 87(4), Apr
2013.
[64] Peter Selinger, Benoıt Valiron, et al. Quantum lambda calculus. Semantic tech-
niques in quantum computation, pages 135–172, 2009.
[65] Peter Selinger and Benoît Valiron. Quantum Lambda Calculus, page 135–172.
Cambridge University Press, 2009.
[66] Damian S. Steiger, Thomas Häner, and Matthias Troyer. Projectq: an open
source software framework for quantum computing. Quantum, 2:49, Jan 2018.
[67] Krysta Svore, Martin Roetteler, Alan Geller, Matthias Troyer, John Azariah,
Christopher Granade, Bettina Heim, Vadym Kliuchnikov, Mariia Mykhailova,
and Andres Paz. Q#. In Proceedings of the Real World Domain Specific Lan-
guages Workshop 2018 on - RWDSL2018. ACM Press, 2018.
[68] Benoît Valiron. Semantics of quantum programming languages: Classical control,
quantum control. Journal of Logical and Algebraic Methods in Programming,
128:100790, 2022.
[69] John van de Wetering. ZX-calculus for the working quantum computer scientist.
arXiv preprint arXiv:2012.13966, 2020.
[70] Renaud Vilmart. A zx-calculus with triangles for toffoli-hadamard, clifford+t,
and beyond. Electronic Proceedings in Theoretical Computer Science, 287:313–
344, Jan 2019.
[71] Huiyang Zhou and Gregory T. Byrd. Quantum circuits for dynamic runtime
assertions in quantum computation.
IEEE Computer Architecture Letters,
18(2):111–114, Jul 2019.
96

Abstract
The advent of quantum computers capable of solving problems that are un-
tractable on classical computers has motivated the development of new programming
languages and tools for quantum computing. However, the current state of the art
in quantum programming is still in its infancy. In this thesis, we present a series of
novel approaches to different aspects of the quantum compilation process based on
the ZX calculus.
First, we introduce a new intermediate representation for quantum programs ca-
pable of encoding bounded recursion and repeated circuit structures in a compact
way, based on families of the Scalable extension to the ZX calculus. We then present
a compilation algorithm for hybrid circuits containing both quantum and classical
gates, based on the pure circuit optimization by Duncan et al. Finally, we define the
problem of detecting sections of a quantum circuit that can translated to classical
logic, and introduce an heuristic algorithm to solve it.
Keywords: Quantum computing, Compilation, ZX-Calculus, Optimization.
Résumé
L’avènement des ordinateurs quantiques capables de résoudre des problèmes irréalis-
ables sur des ordinateurs classiques a motivé le développement de nouveaux langages
et outils de programmation pour l’informatique quantique. Cependant, l’état de l’art
actuel en matière de programmation quantique n’en est qu’à ses débuts. Dans cette
thèse, nous présentons une série d’approches novatrices de différents aspects du pro-
cessus de compilation quantique basé sur le calcul ZX.
Tout d’abord, nous introduisons une nouvelle représentation intermédiaire pour
les programmes quantiques capable d’encoder la récursion bornée et les structures de
circuits répétés de manière compacte, basée sur les familles de l’extension Scalable
du calcul ZX. Nous présentons ensuite un algorithme de compilation pour les circuits
hybrides contenant à la fois des portes quantiques et classiques, basé sur l’optimisation
de circuits purs de Duncan et al. Enfin, nous définissons le problème de la détection
des sections de circuits quantiques qui peuvent être traduites en logique classique, et
nous introduisons un algorithme heuristique pour le résoudre.
Mots-clés: Informatique quantique, Compilation, ZX-Calcul, Optimisation.
97

98

