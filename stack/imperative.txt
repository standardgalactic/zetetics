Imp
erativ
e
functional
programming
Simon
L
P
eyton
Jones
Philip
W
adler
Dept
of
Computing
Science,
Univ
ersit
y
of
Glasgo
w
Email:
{simonpj,
wa
dle
r}@
dcs
.g
lag
sow
.ac
.u
k
Octob
er
		
This
p
ap
er
app
e
ars
in
A
CM
Symp
osium
on
Principles
Of
Pr
o
gr
amming
L
anguages
(POPL),
Charleston,
Jan
		,
pp-.
This
c
opy
c
orr
e
cts
a
few
minor
typ
o
gr
aphic
al
err
ors
in
the
publishe
d
version.
Abstract
W
e
presen
t
a
new
mo
del,
based
on
monads,
for
p
erform-
ing
input/output
in
a
non-strict,
purely
functional
lan-
guage.
It
is
comp
osable,
extensible,
ecien
t,
requires
no
extensions
to
the
t
yp
e
system,
and
extends
smo
othly
to
incorp
orate
mixed-language
w
orking
and
in-place
arra
y
up
dates.

In
tro
duction
Input/output
has
alw
a
ys
app
eared
to
b
e
one
of
the
less
satisfactory
features
of
purely
functional
languages:
t-
ting
action
in
to
the
functional
paradigm
feels
lik
e
tting
a
square
blo
c
k
in
to
a
round
hole.
Closely
related
dicul-
ties
are
asso
ciated
with
p
erforming
in-place
up
date
op
er-
ations
on
arra
ys,
and
calling
arbitrary
pro
cedures
written
in
some
other
(p
ossibly
side-eecting)
language.
Some
mostly-functional
languages,
suc
h
as
Lisp
or
SML,
deal
successfully
with
input/output
b
y
using
side
eects.
W
e
fo
cus
on
purely-functional
solutions,
whic
h
rule
out
side
eects,
for
t
w
o
reasons.
Firstly
,
the
absence
of
side
eects
p
ermits
unrestricted
use
of
equational
reasoning
and
program
transformation.
Secondly
,
w
e
are
in
terested
in
non-strict
languages,
in
whic
h
the
order
of
ev
aluation
(and
hence
the
order
of
an
y
side
eects)
is
delib
erately
unsp
ecied;
laziness
and
side
eect
are
fundamen
tally
in-
imical.
There
is
no
shortage
of
prop
osals
for
input/output
in
lazy
functional
languages,
some
of
whic
h
w
e
surv
ey
later,
but
no
one
solution
has
b
ecome
accepted
as
the
consensus.
This
pap
er
outlines
a
new
approac
h
based
on
monads
(Moggi
[		];
W
adler
[		];
W
adler
[		0]),
with
a
n
um-
b
er
of
notew
orth
y
features.

It
is
c
omp
osable.
Large
programs
whic
h
engage
in
I/O
are
constructed
b
y
gluing
together
smaller
pro-
grams
that
do
so
(Section
).
Com
bined
with
higher-
order
functions
and
lazy
ev
aluation,
this
giv
es
a
highly
expressiv
e
medium
in
whic
h
to
express
I/O-
p
erforming
computations
(Section
.)
|
quite
the
rev
erse
of
the
sen
timen
t
with
whic
h
w
e
b
egan
this
section.
W
e
compare
the
monadic
approac
h
to
I/O
with
other
standard
approac
hes:
dialogues
and
con
tin
uations
(Section
),
and
eect
systems
and
linear
t
yp
es
(Sec-
tion
).

It
is
e
asily
extensible.
The
k
ey
to
our
implemen
tation
is
to
extend
Hask
ell
with
a
single
form
that
allo
ws
one
to
call
an
an
y
pro
cedure
written
in
the
programmi
ng
language
C
(Kernighan
&
Ritc
hie
[	]),
without
losing
referen
tial
transparency
(Section
.).
Using
it
programmers
can
readily
extend
the
p
o
w
er
of
the
I/O
system,
b
y
writing
Hask
ell
functions
whic
h
call
op
erating
system
pro
cedures.

It
is
ecient.
Our
Hask
ell
compiler
has
C
as
its
target
co
de.
Giv
en
a
Hask
ell
program
p
erforming
an
I/O
lo
op,
the
compiler
can
pro
duce
C
co
de
whic
h
is
v
ery
similar
to
that
whic
h
one
w
ould
write
b
y
hand
(Section
).

Its
eciency
is
achieve
d
by
applying
simple
pr
o-
gr
am
tr
ansformations.
W
e
use
un
b
o
xed
data
t
yp
es
(P
eyton
Jones
&
Launc
h
bury
[		])
to
exp
ose
rep-
resen
tation
and
order-of-ev
aluation
detail
to
co
de-
impro
ving
transformations,
rather
than
relying
on
ad
ho
c
optimisations
in
the
co
de
generator
(Section
.).

It
extends
uniformly
to
pr
ovide
interle
ave
d
I/O
and
r
efer
enc
e
typ
es
(Section
).

It
extends
uniformly
to
supp
ort
incr
emental
arr
ays
with
in-plac
e
up
date
(Section
).
Our
implemen
ta-
tion
is
ecien
t
enough
that
w
e
can
dene
monolithic


Hask
ell
arra
y
op
erations
in
terms
of
incremen
tal
ar-
ra
ys.
Hudak
ha
v
e
prop
osed
a
similar
metho
d
based
on
con
tin
uations.
Our
metho
d
is
more
general
than
his
in
the
follo
wing
sense:
monads
can
implemen
t
con
tin
uations,
but
not
the
con
v
erse.

It
is
b
ase
d
(only)
on
the
Hind
ley-Milner
typ
e
system.
Some
other
prop
osals
require
linear
t
yp
es
or
existen-
tial
t
yp
es;
ours
do
es
not.
W
e
ha
v
e
implem
en
ted
all
that
w
e
describ
e
in
the
con-
text
of
a
compiler
for
Hask
ell
(Hudak
et
al.
[		]),
with
the
exception
of
the
extension
to
arra
ys
and
reference
t
yp
es.
The
en
tire
I/O
system
pro
vided
b
y
our
compiler
is
written
in
Hask
ell,
using
the
non-standard
extensions
w
e
describ
e
b
elo
w.
The
language's
standard
Dialogue
in
terface
for
I/O
is
supp
orted
b
y
pro
viding
a
function
to
con
v
ert
a
Dialogue
in
to
our
IO
monad.
The
system
is
freely
a
v
ailable
b
y
FTP
.
W
e
do
not
claim
an
y
fundamen
tal
expressiv
eness
or
e-
ciency
whic
h
is
not
obtainable
through
existing
systems,
except
where
arra
ys
are
concerned.
Nev
ertheless
w
e
feel
that
the
en
tire
system
w
orks
particularly
smo
othly
as
a
whole,
from
the
standp
oin
t
of
b
oth
programmer
and
im-
plemen
tor.

Ov
erview
W
e
need
a
w
a
y
to
reconcile
b
eing
with
doing:
an
expres-
sion
in
a
functional
language
denotes
a
v
alue,
while
an
I/O
command
should
p
erform
an
action.
W
e
in
tegrate
these
w
orlds
b
y
pro
viding
a
t
yp
e
IO
a
denoting
actions
that,
when
p
erforme
d,
ma
y
do
some
I/O
and
then
return
a
v
alue
of
t
yp
e
a.
The
follo
wing
pro
vide
simple
Unix-
a
v
oured
I/O
op
erations.
getcIO
::
IO
Char
putcIO
::
Char
->
IO
()
Here
getcIO
is
an
action
whic
h,
when
p
erformed,
reads
a
c
haracter
from
the
standard
input,
and
returns
that
c
har-
acter;
and
putcIO
a
is
an
action
whic
h,
when
p
erformed,
writes
the
c
haracter
a
to
the
standard
output.
Actions
whic
h
ha
v
e
nothing
in
teresting
to
return,
suc
h
as
putcIO
,
return
the
empt
y
tuple
(),
whose
t
yp
e
is
also
written
().
Notice
the
distinction
b
et
w
een
an
action
and
its
p
erfor-
mance.
Think
of
an
action
as
a
\script",
whic
h
is
p
er-
formed
b
y
executing
it.
Actions
themselv
es
are
rst-class
citizens.
Ho
w,
then,
are
actions
p
erformed?
In
our
sys-
tem,
the
v
alue
of
the
en
tire
program
is
a
single
(p
erhaps
large)
action,
called
mainIO
,
and
the
program
is
executed
b
y
p
erforming
this
action.
F
or
example,
the
follo
wing
is
a
legal
Hask
ell
program.
mainIO
::
IO
()
mainIO
=
putcIO
'!'
This
is
the
p
oin
t
at
whic
h
b
eing
is
con
v
erted
to
doing:
when
executed,
the
putcIO
action
will
b
e
p
erformed,
and
write
an
exclamation
mark
to
the
standard
output.
.
Comp
osing
I/O
op
erations
The
functions
dened
ab
o
v
e
allo
w
one
to
dene
a
single
action,
but
ho
w
can
actions
b
e
com
bined?
F
or
example,
ho
w
can
w
e
write
a
program
to
prin
t
t
w
o
exclamation
marks?
T
o
do
so,
w
e
in
tro
duce
t
w
o
\glue"
com
binators:
doneIO
::
IO
()
seqIO
::
IO
a
->
IO
b
->
IO
b
The
comp
ound
action
m
`seqIO`
n
is
p
erformed,
b
y
rst
p
erforming
m
and
then
p
erforming
n
,
returning
whatev
er
n
returns
as
the
result
of
the
comp
ound
action.
(Bac
k-
quotes
are
Hask
ell's
syn
tax
for
an
inx
op
erator.)
The
action
doneIO
do
es
no
I/O
and
returns
the
unit
v
alue,
()
.
T
o
illustrate,
here
is
an
action
putsIO
,
whic
h
puts
a
string
to
the
standard
output:
putsIO
::
[Char]
->
IO
()
putsIO
[]
=
doneIO
putsIO
(a:as)
=
putcIO
a
`seqIO`
putsIO
as
W
e
can
no
w
use
putsIO
to
dene
a
program
whic
h
prin
ts
\hello
"
t
wice:
mainIO
=
hello
`seqIO`
hello
where
hello
=
putsIO
"hello"
This
example
illustrates
the
distinction
b
et
w
een
an
action
and
its
p
erformance:
hello
is
an
action
whic
h
happ
ens
to
b
e
p
erformed
t
wice.
The
program
is
precisely
equiv
alen
t
to
one
in
whic
h
putsIO
"hello"
is
substituted
for
either
or
b
oth
of
the
o
ccurrences
of
hello
.
In
short,
programs
remain
referen
tially
transparen
t.
In
general,
an
action
ma
y
also
return
a
v
alue.
Again,
there
are
t
w
o
com
binators.
The
rst
is
again
trivial:
unitIO
::
a
->
IO
a
If
x
is
of
t
yp
e
a,
then
unitIO
x
denotes
the
action
that,
when
p
erformed,
do
es
nothing
sa
v
e
return
x.
The
second
com
bines
t
w
o
actions:
bindIO
::
IO
a
->
(a
->
IO
b)
->
IO
b
If
m
::
IO
a
and
k
::
a
->
IO
b
then
m
`bindIO`
k
denotes
the
action
that,
when
p
erformed,
b
eha
v
es
as
fol-


lo
ws:
rst
p
erform
action
m,
yielding
a
v
alue
x
of
t
yp
e
a,
then
p
erform
action
k
x,
yielding
a
v
alue
y
of
t
yp
e
b,
and
then
return
v
alue
y.
T
o
illustrate,
here
is
an
action
that
ec
ho
es
the
standard
input
to
the
standard
output.
(In
Hask
ell,
\x
->
e
stands
for
a
lam
b
da
abstraction;
the
b
o
dy
of
the
abstraction
extends
as
far
as
p
ossible.)
echo
::
IO
()
echo
=
getcIO
`bindIO`
\a
->
if
(a
==
eof)
then
doneIO
else
putcIO
a
`seqIO`
echo
The
com
binators
bindIO
and
unitIO
are
generalisations
of
seqIO
and
doneIO
.
Here
are
denitions
for
the
latter
in
terms
of
the
former:
doneIO
=
unitIO
()
m
`seqIO`
n
=
m
`bindIO`
\a
->
n
The
com
binators
ha
v
e
a
useful
algebra:
doneIO
and
seqIO
form
a
monoid,
while
bindIO
and
unitIO
form
a
monad
(Moggi
[		];
W
adler
[		];
W
adler
[		0]).
.
Imp
erativ
e
programming
It
will
not
ha
v
e
escap
ed
the
reader's
notice
that
programs
written
in
the
monadic
st
yle
lo
ok
rather
similar
to
imp
er-
ativ
e
programs.
F
or
example,
the
echo
program
in
C
migh
t
lo
ok
something
lik
e
this:
echo()
{
loop:
a
=
getchar(a);
if
(a
==
eof)
return;
else
{
putchar(a);
goto
loop;
}
}
(Indeed,
as
w
e
discuss
later,
our
compiler
translates
the
echo
function
in
to
essen
tially
this
C
co
de.)
Do
es
the
monadic
st
yle
force
one,
in
eect,
to
write
a
functional
facsimile
of
an
imp
erativ
e
program,
thereb
y
losing
an
y
adv
an
tages
of
writing
in
a
functional
language?
W
e
b
e-
liev
e
not.
Firstly
,
the
st
yle
in
whic
h
one
writes
the
functional
pro-
gram's
in
ternal
computation
is
unaected.
F
or
instance,
the
argumen
t
to
putsIO
can
b
e
computed
using
the
usual
list-pro
cessing
op
erations
pro
vided
b
y
a
functional
lan-
guage
(list
comprehensions,
map,
app
end,
and
the
lik
e).
Secondly
,
the
p
o
w
er
of
higher-order
functions
and
non-
strict
seman
tics
can
b
e
used
to
mak
e
I/O
programmi
ng
easier,
b
y
dening
new
action-manipulating
com
binators.
F
or
example,
the
denition
of
putsIO
giv
en
ab
o
v
e
uses
explicit
recursion.
Here
is
an
alternativ
e
w
a
y
to
write
putsIO
whic
h
do
es
not
do
so:
putsIO
as
=
seqsIO
(map
putcIO
as)
The
map
applies
putcIO
to
eac
h
c
haracter
in
the
list
as
to
pro
duce
a
list
of
actions.
The
com
binator
seqsIO
tak
es
a
list
of
actions
and
p
erforms
them
in
sequence;
that
is,
it
encapsulates
the
recursion.
It
is
easy
to
dene
seqsIO
th
us:
seqsIO
::
[IO
a]
->
IO
()
seqsIO
[]
=
doneIO
seqsIO
(a:as)
=
a
`seqIO`
seqsIO
as
or
ev
en,
using
the
standard
list-pro
cessing
function
foldr
,
th
us:
seqsIO
=
foldr
seqIO
doneIO
T
o
tak
e
another
example,
here
is
a
function
whic
h
writes
a
giv
en
n
um
b
er
of
spaces
to
the
standard
output:
spaceIO
::
Int
->
IO
()
spaceIO
n
=
seqsIO
(take
n
(repeat
(putcIO
'
')))
The
functions
take
and
repeat
are
standard
list-
pro
cessing
functions
(with
nothing
to
do
with
I/O)
from
Hask
ell's
standard
prelude.
The
function
repeat
tak
es
a
v
alue
and
returns
an
innite
list
eac
h
of
whose
elemen
ts
is
the
giv
en
v
alue.
The
function
take
tak
es
a
prex
of
giv
en
length
from
a
list.
These
necessarily
small
examples
could
easily
b
e
pro-
grammed
with
explicit
recursion
without
signican
t
loss
of
clarit
y
(or
ev
en
a
gain!).
The
p
oin
t
w
e
are
making
is
that
it
is
easy
for
the
programmer
to
dene
new
\glue"
to
com
bine
actions
in
just
the
w
a
y
whic
h
is
suitable
for
the
program
b
eing
written.
It's
a
bit
lik
e
b
eing
able
to
dene
y
our
o
wn
con
trol
structures
in
an
imp
erativ
e
language.
.
Calling
C
directly
Since
the
\primitiv
e"
functions
putcIO
,
getcIO
,
and
so
on
m
ust
ultimately
b
e
implemen
ted
b
y
a
call
to
the
un-
derlying
op
erating
system,
it
is
natural
to
pro
vide
the
abilit
y
to
call
any
op
erating
system
function
directly
.
T
o
ac
hiev
e
this,
w
e
pro
vide
a
new
form
of
expression,
the
ccall
,
whose
general
form
is:
ccall
pr
o
c
e

:
:
:
e
n
Here,
pr
o
c
is
the
name
of
a
C
pro
cedure,
and
e

,
:
:
:
,
e
n
are
the
parameters
to
b
e
passed
to
it.
This
expression


is
an
action,
with
t
yp
e
IO
Int
;
when
p
erformed,
it
calls
the
named
pro
cedure,
and
deliv
ers
its
result
as
the
v
alue
of
the
action.
Here,
for
example,
are
the
denitions
of
getcIO
and
putcIO
:
putcIO
a
=
ccall
putchar
a
getcIO
=
ccall
getchar
These
ccall
s
directly
in
v
ok
e
the
system-pro
vided
func-
tions;
no
further
run
time
supp
ort
is
necessary
.
Using
this
single
primitiv
e
allo
ws
us
to
implemen
t
our
en
tire
I/O
system
in
Hask
ell.
W
e
dene
ccall
to
b
e
a
language
c
onstruct
rather
than
simply
a
function
b
ecause:

The
rst
\argumen
t"
m
ust
b
e
the
literal
name
of
the
C
pro
cedures
to
b
e
called,
and
not
(sa
y)
an
expres-
sion
whic
h
ev
aluates
to
a
string
whic
h
is
the
name
of
the
function.
T
yp
e
information
alone
cannot
express
this.

Dieren
t
C
pro
cedures
tak
e
dieren
t
n
um
b
ers
of
ar-
gumen
ts,
and
some
tak
e
a
v
ariable
n
um
b
er
of
ar-
gumen
ts.
(It
w
ould
b
e
p
ossible
to
c
hec
k
the
t
yp
e-
correctness
of
the
C
call
b
y
reading
the
signature
of
the
C
pro
cedure,
but
w
e
do
not
at
presen
t
do
so.)

Dieren
t
C
pro
cedures
tak
e
argumen
ts
of
dieren
t
t
yp
es
and
sizes.
(A
t
presen
t,
w
e
only
p
ermit
the
argumen
ts
to
b
e
of
base
t
yp
es,
suc
h
as
Char
,
Int,
Float
,
Double
and
so
on,
though
w
e
are
w
orking
on
extensions
whic
h
allo
w
structured
argumen
ts
to
b
e
built.)
T
reating
ccall
as
a
construct
allo
ws
these
v
ariations
to
b
e
accomo
dated
without
dicult
y
.

Comparison
with
other
I/O
st
yles
In
this
section
w
e
briey
compare
our
approac
h
with
t
w
o
other
p
opular
ones,
dialogues
and
con
tin
uations.
.
Dialogues
The
I/O
system
sp
ecied
for
the
Hask
ell
language
(Hudak
et
al.
[		])
is
based
on
dialo
gues,
also
called
lazy
str
e
ams
(Dw
elly
[		];
O'Donnell
[	];
Thompson
[		]).
In
Hask
ell,
the
v
alue
of
the
program
has
t
yp
e
Dialogue
,
a
synon
ym
for
a
function
b
et
w
een
a
list
of
I/O
resp
onses
to
a
list
of
I/O
requests:
type
Dialogue
=
[Response]
->
[Request]
main
::
Dialogue
Request
and
Response
are
algebraic
data
t
yp
es
whic
h
em
b
o
dy
all
the
p
ossible
I/O
op
erations
and
their
results,
resp
ectiv
ely:
data
Request
=
Putc
Char
|
Getc
data
Response
=
OK
|
OKCh
Char
(F
or
the
purp
oses
of
exp
osition
w
e
ha
v
e
grossly
simpli-
ed
these
data
t
yp
es
compared
with
those
in
standard
Hask
ell.)
A
system
\wrapp
er
program"
rep
eatedly
gets
the
next
request
from
the
list
of
requests
returned
b
y
main
,
in
terprets
and
p
erforms
it,
and
attac
hes
the
re-
sp
onse
to
the
end
of
the
resp
onse
list
to
whic
h
main
is
applied.
Here,
for
example,
is
the
echo
program
written
using
a
Dialogue
.
(In
Hask
ell
xs!!n
extracts
the
n'th
elemen
t
from
the
list
xs
.)
echo
::
Dialogue
echo
resps
=
Getc
:
if
(a
==
eof)
then
[]
else
Putc
a
:
echo
(drop

resps)
where
OKCh
a
=
resps!!
The
diculties
with
this
programmi
ng
st
yle
are
all
to
o
ob
vious,
and
ha
v
e
b
een
w
ell
rehearsed
elsewhere
(P
erry
[		]):

It
is
easy
to
extract
the
wrong
elemen
t
of
the
re-
sp
onses,
a
synchr
onisation
err
or.
This
ma
y
sho
w
up
in
a
v
ariet
y
of
w
a
ys.
If
the
\
"
in
the
ab
o
v
e
program
w
as
erroneously
written
as
\"
the
program
w
ould
fail
with
a
pattern-mathing
error
in
getCharIO
;
if
it
w
ere
written
\"
it
w
ould
deadlo
c
k.

The
Response
data
t
yp
e
has
to
con
tain
a
constructor
for
ev
ery
p
ossible
resp
onse
to
ev
ery
request.
Ev
en
though
Putc
ma
y
only
ev
er
return
a
resp
onse
OKChar
,
the
pattern-matc
hing
p
erformed
b
y
get
has
to
tak
e
accoun
t
of
all
these
other
resp
onses.

Ev
en
more
seriously
,
the
st
yle
is
not
comp
osable:
there
is
no
direct
w
a
y
to
tak
e
t
w
o
v
alues
of
t
yp
e
Dialogue
and
com
bine
them
to
mak
e
a
larger
v
alue
of
t
yp
e
Dialogue
(try
it!).
Dialogues
and
the
IO
monad
ha
v
e
equal
expressiv
e
p
o
w
er,
as
Figure

demonstrates,
b
y
using
Dialogues
to
em
u-
late
the
IO
monad,
and
vice
v
ersa.
The
function
dToIO
,
whic
h
em
ulates
Dialogue
s
in
terms
of
IO
is
rather
cu-
rious,
b
ecause
it
in
v
olv
es
applying
the
single
dialogue
d
to
b
oth
b
ottom
(?)
and
(later)
to
the
\real"
list


Dialogue
to
IO
dToIO
::
Dialogue
->
IO
()
dToIO
d
=
case
(d
bottom)
of
[]
->
doneIO
(q:qs)
->
doReq
q
`bindIO`
\r
->
dToIO
(\rs
->
tail
(d
(r:rs)))
bottom
::
a
bottom
=
error
"Should
never
be
evaluated"
doReq
::
Request
->
IO
Response
doReq
(GetChar
f)
=
getCharIO
f
`bindIO`
(\c
->
unitIO
(OKChar
c))
doReq
(PutChar
f
c)
=
putCharIO
f
c
`seqIO`
unitIO
OK
IO
to
Dialogue
type
IO
a
=
[Response]
->
(a,
[Request],
[Response])
ioToD
::
IO
()
->
Dialogue
ioToD
action
=
\rs
->
case
(action
rs)
of
(_,
qs,
_)
->
qs
unitIO
v
=
\rs
->
(v,
[],
rs)
bindIO
op
fop
=
\rs
->
let
(v,
qs,
rs)
=
op
rs
(v,
qs,
rs)
=
fop
v
rs
in
(v,
qs++qs,
rs)
Figure
:
Con
v
erting
b
et
w
een
Dialogue
and
IO
of
resp
onses
(Hudak
&
Sundaresh
[		];
P
eyton
Jones
[	]).
This
causes
b
oth
duplicated
w
ork
and
a
space
leak,
but
no
more
ecien
t
purely-functional
em
ulation
is
kno
wn.
The
rev
erse
function,
ioToD
do
es
not
suer
from
these
problems,
and
this
asymmetry
is
the
main
reason
that
Dialogue
s
are
sp
ecied
as
primitiv
e
in
Hask
ell.
W
e
return
to
this
this
matter
in
Section
..
.
Con
tin
uati
on
s
The
con
tin
uation-st
yle
I/O
mo
del
(Gordon
[		];
Hudak
&
Sundaresh
[		];
Karlsson
[	];
P
erry
[		])
pro-
vides
primitiv
e
I/O
op
erations
whic
h
tak
e
as
one
of
their
argumen
ts
a
con
tin
uation
whic
h
sa
ys
what
to
do
after
the
I/O
op
eration
is
p
erformed:
main
::
Result
putcC
::
Char
->
Result
->
Result
getcC
::
(Char
->
Result)
->
Result
doneC
::
Result
Using
these
primitiv
es,
the
echo
program
can
b
e
written
as
follo
ws:
echo
::
Result
->
Result
echo
c
=
getcC
(\a
->
if
(a
==
eof)
then
then
c
else
putcC
a
(echo
c))
Since
w
e
migh
t
w
an
t
to
do
some
more
I/O
after
the
ec
ho-
ing
is
completed,
w
e
m
ust
pro
vide
echo
with
a
con
tin
ua-
tion,
c,
to
express
what
to
do
when
echo
is
nished.
This
\extra
argumen
t"
is
required
for
ev
ery
I/O-p
erforming
function
if
it
is
to
b
e
comp
osable,
a
p
erv
asiv
e
and
tire-
some
feature.
The
ab
o
v
e
presen
tation
of
con
tin
uation-st
yle
I/O
is
a
lit-
tle
dieren
t
from
those
cited
ab
o
v
e.
In
all
those
descrip-
tions,
Result
is
an
algebraic
data
t
yp
e,
with
a
construc-
tor
for
eac
h
primitiv
e
I/O
op
eration.
As
with
Dialogue
s,
execution
is
driv
en
b
y
a
\wrapp
er"
program,
whic
h
ev
al-
uates
main,
p
erforms
the
op
eration
indicated
b
y
the
con-
structor,
and
applies
the
con
tin
uation
inside
the
construc-
tor
to
the
result.
This
approac
h
has
the
disadv
an
tage
that
it
requires
existen
tial
t
yp
es
if
p
olymorphic
op
era-
tions,
suc
h
as
those
w
e
in
tro
duce
later
in
Section
.,
are
to
b
e
supp
orted.
An
ob
vious
impro
v
emen
t,
whic
h
w
e
ha
v
e
not
seen
previ-
ously
suggested,
is
to
implemen
t
the
primitiv
e
con
tin
u-
ation
op
erations
(suc
h
as
putcC
,
getcC
and
doneC
)
di-
rectly
,
making
the
Result
t
yp
e
an
abstract
data
t
yp
e
with
no
op
erations
dened
on
it
other
than
the
primi-
tiv
es
themselv
es.
This
solv
es
the
problem.
Con
tin
uations
are
easily
em
ulated
b
y
the
IO
monad,
and
vice
v
ersa,
as
Figure

sho
ws.
The
comparison
b
et
w
een
the
monadic
and
con
tin
uation
approac
h
is
further
ex-
plored
in
Section
.

Implem
en
ting
monadic
I/O
So
far
w
e
ha
v
e
sho
wn
that
an
en
tire
I/O
system
can
b
e
expressed
in
terms
of
ccall
,
bindIO
,
and
unitIO
,
and
of
course
the
IO
t
yp
e
itself.
Ho
w
are
these
com
binators
to
b
e
implemen
ted?
One
p
ossibilit
y
is
to
build
them
in
as
primitiv
es,
but
it
turns
out
to
b
e
b
oth
simpler
and
more
ecien
t
to
implemen
t
all
except
ccall
in
Hask
ell.
The
idea
is
that
an
action
of
t
yp
e
IO
a
is
implemen
ted
as
a
function,
whic
h
tak
es
as
its
input
a
v
alue
represen
ting
the
en
tire
curren
t
state
of
the
w
orld,
and
returns
a
pair,
consisting
of
(a
v
alue
represen
ting)
the
new
state
of
the


Con
tin
uations
to
IO
type
Result
=
IO
()
cToIO
::
Result
->
IO
()
cToIO
r
=
r
putCharC
::
File
->
Char
->
Result
->
Result
putCharC
f
c
k
=
putCharIO
f
c
`seqIO`
k
getCharC
::
File
->
Char
->
(Char
->
Result)
->
Result
getCharC
f
k
=
getCharIO
f
`thenIO`
k
IO
to
con
tin
uations
type
IO
a
=
(a
->
Result)
->
Result
ioToC
::
IO
()
->
Result
ioToC
action
=
action
(\
()
->
nopC)
unitIO
v
=
\k
->
k
v
bindIO
op
fop
=
\k
->
op
(\a
->
fop
a
k)
putCharIO
f
c
=
\k
->
putCharC
f
c
(k
())
getCharIO
f
=
\k
->
getCharC
f
(\c
->
k
c)
Figure
:
Con
v
erting
b
et
w
een
con
tin
uations
and
IO
w
orld,
and
the
result
of
t
yp
e
a:
type
IO
a
=
World
->
IORes
a
data
IORes
a
=
MkIORes
a
World
The
type
declaration
in
tro
duces
a
t
yp
e
synom
ym
for
IO,
and
the
auxiliary
algebraic
datat
yp
e
IORes
simply
pairs
the
result
with
the
new
w
orld.
Recall
that
the
v
alue
of
the
en
tire
program
is
of
t
yp
e
IO
().
The
t
yp
e
World
is
abstract,
with
only
one
op
eration
dened
on
it,
namely
ccall
.
Conceptually
,
the
program
is
executed
b
y
apply-
ing
main
to
a
v
alue
of
t
yp
e
World
represen
ting
curren
t
state
of
the
w
orld,
extracting
the
resulting
World
v
alue
from
the
MkIORes
constructor,
and
applying
an
y
c
hanges
em
b
o
died
therein
to
the
real
w
orld.
If
implemen
ted
literally
,
suc
h
a
system
w
ould
b
e
un
w
ork-
ably
exp
ensiv
e.
The
k
ey
to
making
it
c
heap
is
to
ensur
e
that
the
world
state
is
use
d
in
a
single-thr
e
ade
d
way,
so
that
I/O
op
er
ations
c
an
b
e
applie
d
imme
diately
to
the
r
e
al
world.
One
w
a
y
to
ensure
this
w
ould
b
e
to
do
a
global
analysis
of
the
program.
A
m
uc
h
simpler
w
a
y
is
to
mak
e
IO
in
to
an
abstract
data
t
yp
e
whic
h
encapsulates
the
data
t
yp
es
IO
and
IORes
,
and
the
com
binators
bindIO
and
unitIO
.
Here
are
suitable
denitions
for
the
latter:
unitIO
a
w
=
MkIORes
a
w
bindIO
m
k
w
=
case
(m
w)
of
MkIORes
a
w'
->
k
a
w'
Notice
that
bindIO
and
unitIO
carefully
a
v
oid
duplicat-
ing
the
w
orld.
Pro
vided
that
the
primitiv
e
ccall
ac-
tions
are
com
bined
only
with
these
com
binators,
we
c
an
guar
ante
e
that
the
ccall
s
wil
l
b
e
linke
d
in
a
single,
lin-
e
ar
chain,
connected
b
y
data
dep
endencies
in
whic
h
eac
h
ccall
consumes
the
w
orld
state
pro
duced
b
y
the
previous
one.
In
turn
this
means
that
the
ccall
op
erations
can
up
date
the
real
w
orld
\in
place".
.
Implemen
tin
g
ccall
So
m
uc
h
for
the
com
binators.
All
that
remains
is
the
implemen
tati
on
of
ccall
.
The
only
complication
here
is
that
w
e
m
ust
arrange
to
ev
aluate
the
argumen
ts
to
the
ccall
b
efore
passing
them
to
C.
This
is
v
ery
similar
to
the
argumen
t
ev
aluation
required
for
built-in
functions
suc
h
as
addition,
for
whic
h
w
e
ha
v
e
earlier
dev
elop
ed
the
idea
of
unb
oxe
d
data
typ
es
(P
ey-
ton
Jones
&
Launc
h
bury
[		]).
These
allo
w
represen
ta-
tion
and
order-of-ev
aluation
information
to
b
e
exp
osed
to
co
de-impro
ving
transformations.
F
or
example,
consider
the
expression
x+x
where
x
is
of
t
yp
e
Int
.
The
impro
v
e-
men
t
w
e
w
an
t
to
express
is
that
x
need
only
b
e
ev
aluated
once.
The
k
ey
idea
is
to
dene
the
t
yp
e
Int
(whic
h
is
usually
primitiv
e)
as
a
structured
algebraic
data
t
yp
e
with
a
sin-
gle
constructor,
MkInt
,
lik
e
this:
data
Int
=
MkInt
Int#
A
v
alue
of
t
yp
e
Int
is
represen
ted
b
y
a
p
oin
ter
to
a
heap-
allo
cated
ob
ject,
whic
h
ma
y
either
b
e
an
unev
aluated
sus-
p
ension,
or
a
MkInt
constructor
con
taining
the
mac
hine
bit-pattern
for
the
in
teger.
This
bit-pattern
is
of
t
yp
e
Int#
.
No
w
that
Int
is
giv
en
structure,
w
e
can
mak
e
explicit
the
ev
aluation
p
erformed
b
y
+,
b
y
giving
the
follo
wing
denition,
whic
h
expresses
+
in
terms
of
the
primitiv
e
mac
hine
op
eration
+#:
a
+
b
=
case
a
of
MkInt
a#
->
case
b
of
MkInt
b#
->
MkInt
(a#
+#
b#)
Inlining
this
denition
of
+
in
the
expression
x+x
,
and
p
erforming
simple,
routine
simplications,
giv
es
the
fol-
lo
wing,
in
whic
h
x
is
ev
aluated
only
once:


case
x
of
MkInt
x#
->
MkInt
(x#
+#
x#)
(Un
b
o
xed
t
yp
es
and
ccall
are
not
part
of
standard
Hask
ell.
They
are
mainly
used
in
ternally
in
our
compiler,
though
w
e
do
also
mak
e
them
a
v
ailable
to
programmers
as
a
non-standard
extension.)
W
e
apply
exactly
the
same
ideas
to
ccall
.
In
particular,
instead
of
implemen
ting
ccall
directly
,
w
e
unfold
ev
ery
use
of
ccall
to
mak
e
the
argumen
t
ev
aluation
explicit
b
efore
using
the
truly
primitiv
e
op
eration
ccall#
.
F
or
example,
the
uses
of
ccall
in
the
denitions
of
putcIO
and
getcIO
giv
en
ab
o
v
e
(Section
.),
are
unfolded
th
us:
putcIO
a
=
\w
->
case
a
of
MkChar
a#
->
case
(ccall#
putchar
a#
w)
of
MkIORes#
n#
w'
->
MkIORes
()
w'
getcIO
=
\w
->
case
(ccall#
getchar
w)
of
MkIORes#
n#
w'
->
MkIORes
(MkChar
n#)
w'
Lik
e
Int,
the
t
yp
e
Char
is
implem
en
ted
as
an
algebraic
data
t
yp
e
th
us:
data
Char
=
MkChar
Int#
The
outer
case
expression
of
putcIO
,
therefore,
ev
alu-
ates
a
and
extracts
the
bit-pattern
a#,
whic
h
is
passed
to
ccall#
.
The
inner
case
expression
ev
aluates
the
ex-
pression
(ccall#
putchar
a#
w),
whic
h
returns
a
pair,
constructed
b
y
MkIORes#
,
consisting
of
the
v
alue
n#
re-
turned
b
y
the
C
pro
cedure
putchar
(whic
h
is
ignored),
and
a
new
w
orld
w'
(whic
h
is
returned).
In
the
case
of
getcIO
,
the
(primitiv
e,
un
b
o
xed)
v
alue
n#
returned
b
y
getchar
is
not
ignored
as
it
is
in
putcIO
;
rather
it
is
wrapp
ed
in
a
MkChar
constructor,
and
re-
turned
as
part
of
the
result.
The
dierences
b
et
w
een
ccall
and
ccall#
are
as
follo
ws.
Firstly
,
ccall#
tak
es
only
un
b
o
xed
argumen
ts,
ready
to
call
C
directly
.
Secondly
,
it
returns
a
pair
built
with
MkIORes#
,
con
tain-
ing
an
un
b
o
xed
in
teger
result
direct
from
the
C
call.
The
IORes#
t
yp
e
is
v
ery
similar
to
IORes
:
data
IORes#
=
MkIORes#
Int#
World
(IORes
and
IORes#
are
distinct
t
yp
es,
b
ecause
while
our
extended
t
yp
e
system
recognises
un
b
o
xed
t
yp
es,
it
do
es
not
p
ermit
p
olymorphic
t
yp
e
constructors,
suc
h
as
IORes
,
to
b
e
instan
tiated
at
an
un
b
o
xed
t
yp
e,
suc
h
as
Int#
.)
Thirdly
,
the
ccall#
primitiv
e
is
recognised
b
y
the
co
de
generator
and
expanded
to
an
actual
call
to
C.
Sp
eci-
cally
,
the
expression:
case
(ccall#
proc
a#
b#
c#
w)
of
MkIORes#
n#
w'
->
...
generates
the
C
statemen
t
n#
=
proc(a#,b#,c#);
...
This
simple
tr
anslation
is
al
l
that
the
c
o
de
gener
ator
is
r
e
quir
e
d
to
do.
The
rest
is
done
b
y
generic
program
trans-
formations;
that
is,
transformations
whic
h
are
not
sp
ecic
to
I/O
or
ev
en
to
un
b
o
xing
(P
eyton
Jones
&
Launc
h
bury
[		]).
.
Where
has
the
w
orld
gone?
But
what
has
b
ecome
of
the
w
orld
v
alues
in
the
nal
C
co
de?
The
w
orld
v
alue
manipulated
b
y
the
program
r
epr
esents
the
curren
t
state
of
the
real
w
orld,
but
since
the
real
w
orld
is
up
dated
\in
place"
the
w
orld
v
alue
carries
no
useful
information.
Hence
w
e
simply
arrange
that
no
co
de
is
ev
er
generated
to
mo
v
e
v
alues
of
t
yp
e
World
.
This
is
easy
to
do,
as
t
yp
e
information
is
preserv
ed
throughout
the
compiler.
In
particular,
the
w
orld
is
nev
er
loaded
in
to
a
register,
stored
in
a
data
structure,
or
passed
to
C
pro
cedure
calls.
Is
it
p
ossible,
then,
to
disp
ense
with
the
w
orld
in
the
func-
tional
part
of
the
implemen
tation
as
w
ell?
F
or
example,
can
w
e
dene
the
IORes
t
yp
e
and
bindIO
com
binators
lik
e
this?
data
IORes
a
=
MkIORes
a
bindIO
m
k
w
=
case
(m
w)
of
MkIORes
a
->
k
a
w
No,
w
e
cannot!
T
o
see
this,
supp
ose
that
bindIO
w
as
ap-
plied
to
a
function
k
whic
h
discarded
its
argumen
t.
Then,
if
bindIO
w
as
unfolded,
and
the
expression
(k
r
w)
w
as
simplied,
ther
e
would
b
e
no
r
emaining
data
dep
endency
to
for
c
e
the
c
al
l
of
k
to
o
c
cur
after
that
of
m.
A
compiler
w
ould
b
e
free
to
call
them
in
either
order,
whic
h
destro
ys
the
I/O
sequencing.
T
o
reiterate,
the
w
orld
is
there
to
form
a
linear
c
hain
of
data
dep
endencies
b
et
w
een
successiv
e
ccall
s.
It
is
quite
safe
to
exp
ose
the
represen
tation
of
the
IO
t
yp
e
to
co
de-impro
ving
transformations,
b
ecause
the
c
hain
of
data
dep
endencies
will
prev
en
t
an
y
transformations
whic
h
reorder
the
ccall
s.
Once
the
co
de
generator
is
reac
hed,


though,
the
w
ork
of
the
w
orld
v
alues
is
done,
so
it
is
safe
to
generate
no
co
de
for
them.
.
echo
revisited
The
implem
en
tation
w
e
ha
v
e
outlined
is
certainly
simple,
but
is
it
ecien
t?
P
erhaps
surprisingly
,
the
answ
er
is
an
emphatic
y
es.
The
reason
for
this
is
that
b
ecause
the
com
binators
are
written
in
Hask
ell,
the
c
ompiler
c
an
un-
fold
them
at
al
l
their
c
al
l
sites;
that
is,
p
erform
pro
cedure
inlining.
V
ery
little
sp
ecial-purp
ose
co
de
is
required
in
the
compiler
to
ac
hiev
e
this
eect
|
essen
tially
all
that
is
required
is
that
the
Hask
ell
denitions
of
bindIO
,
unitIO
,
putcIO
and
so
on,
b
e
unfolded
b
y
the
compiler.
In
con
trast,
if
bindIO
w
ere
primitiv
e,
then
ev
ery
call
to
bindIO
will
re-
quire
the
construction
of
t
w
o
heap-allo
cated
closures
for
its
t
w
o
argumen
ts.
Ev
en
if
bindIO
itself
to
ok
no
time
at
all,
this
w
ould
b
e
a
hea
vy
cost.
T
o
illustrate
the
eectiv
eness
of
the
approac
h
w
e
ha
v
e
outlined,
w
e
return
to
the
echo
program
of
Section
..
If
w
e
tak
e
the
co
de
there,
unfold
the
calls
of
seqIO
,
doneIO
,
eof
,
putcIO
and
getcIO
,
and
do
some
simplication,
w
e
get
the
follo
wing:
echo
=
\w
->
case
(ccall#
getchar
w)
of
MkIORes#
a#
w
->
case
(a#
==#
eof#)
of
T#
->
MkIORes
()
w
F#
->
case
(ccall#
putchar
a#
w)
of
MkIORes#
n#
w
->
echo
w
When
this
is
compiled
using
the
simple
co
de-generator
describ
ed,
the
follo
wing
C
is
pro
duced:
echo()
{
int
a;
a
=
getchar();
if
(a
==
eof)
{
retVal
=
unitTuple;
RETURN;
}
else
{
putchar(a);
JUMP(
echo
);
}
}
(JUMP
and
RETURN
are
artefacts
of
our
use
of
C
as
a
target
\mac
hine
co
de"
(P
eyton
Jones
[		]).
They
expand
only
to
a
mac
hine
instruction
or
t
w
o.)
This
is
v
ery
close
to
the
C
one
w
ould
write
b
y
hand!
W
e
kno
w
of
no
other
implemen
tatio
n
of
I/O
with
b
etter
eciency
.
.
A
con
tin
uati
on-p
assi
ng
implemen
tat
ion
Lik
e
most
abstract
data
t
yp
es,
there
is
more
than
one
w
a
y
to
implemen
t
IO.
In
particular,
it
is
p
ossible
to
implemen
t
the
IO
abstract
t
yp
e
using
a
con
tin
uation-passing
st
yle.
The
t
yp
e
IO
a
is
represen
ted
b
y
a
function
whic
h
tak
es
a
con
tin
uation
exp
ecting
a
v
alue
of
t
yp
e
a,
and
returns
a
v
alue
of
the
opaque
t
yp
e
Result
.
type
IO
a
=
(a
->
Result)
->
Result
It
is
easy
to
implem
en
t
bindIO
and
unitIO
:
bindIO
m
k
cont
=
m
(\a
->
k
a
cont)
unitIO
r
cont
=
cont
r
What
is
there
to
c
ho
ose
b
et
w
een
these
this
represen
tation
of
the
IO
t
yp
e
and
the
one
w
e
describ
ed
initially
(Sec-
tion
)?
The
ma
jor
tradeo
seems
to
b
e
this:
with
the
con
tin
uation-passing
represen
tation,
ev
ery
use
of
bindIO
(ev
en
if
unfolded)
requires
the
construction
of
one
heap-
allo
cated
con
tin
uation.
In
con
trast,
the
implemen
tation
w
e
describ
ed
earlier
k
eeps
the
con
tin
uation
implicitly
on
the
stac
k,
whic
h
is
sligh
tly
c
heap
er
in
our
system.
There
is
a
cost
to
pa
y
for
the
earlier
represen
tation,
namely
that
a
hea
vily
left-sk
ew
ed
comp
osition
of
bindIO
s
can
cause
the
stac
k
to
gro
w
rather
large.
In
con
trast,
the
con
tin
uation-passing
implemen
tation
ma
y
use
a
lot
of
heap
for
suc
h
a
comp
osition,
but
its
stac
k
usage
is
con-
stan
t.
The
main
p
oin
t
is
that
the
implemen
tor
is
free
to
c
ho
ose
the
represen
tation
for
IO
based
only
on
considerations
of
eciency
and
resource
usage;
the
c
hoice
mak
es
no
dier-
ence
to
the
in
terface
seen
b
y
the
programmer.

Extensions
to
the
IO
monad
.
Dela
y
ed
I/O
So
far
all
I/O
op
erations
ha
v
e
b
een
strictly
sequenced
along
a
single
\trunk".
Sometimes,
though,
suc
h
strict
sequencing
is
un
w
an
ted.
F
or
example,
almost
all
lazy
functional-language
I/O
systems
pro
vide
a
readFile
primitiv
e,
whic
h
returns
the
en
tire
con
ten
ts
of
a
sp
eci-
ed
le
as
a
list
of
c
haracters.
It
is
often
vital
that
this
primitiv
e
should
ha
v
e
lazy
seman
tics;
that
is,
the
le
is
op
ened,
but
only
actually
read
when
the
resulting
list
is
ev
aluated.
The
relativ
e
ordering
of
other
I/O
op
erations
and
the
reading
of
the
le
is
imma
terial
(pro
vided
the
le
is
not
sim
ultaneously
written).
This
lazy
read
is
usu-
ally
implemen
ted
b
y
some
ad
ho
c
\magic"
in
the
run
time
system,
but
within
the
monadic
framew
ork
it
is
easy
to
generalise
the
idea.


What
is
required
is
a
new
com
binator
for
the
IO
monad,
delayIO
,
whic
h
forks
o
a
new
branc
h
from
the
main
\trunk":
delayIO
::
IO
a
->
IO
a
When
p
erformed,
(delayIO
action)
immediately
re-
turns
a
susp
ension
whic
h
when
it
is
subse
quently
for
c
e
d
will
p
erform
the
I/O
sp
ecied
b
y
action
.
The
relativ
e
in
terlea
ving
of
the
I/O
op
erations
on
the
\trunk"
and
the
\branc
h"
is
therefore
dep
enden
t
on
the
ev
aluation
order
of
the
program.
The
delayIO
com
binator
is
dangerous
(alb
eit
useful),
b
e-
cause
the
correctness
of
the
program
no
w
requires
that
arbitrary
in
terlea
ving
of
I/O
op
erations
on
the
\trunk"
and
\branc
h"
cannot
aect
the
result.
This
c
ondition
c
annot
b
e
guar
ante
e
d
by
the
c
ompiler;
it
is
a
pr
o
of
obli-
gation
for
the
pr
o
gr
ammer.
In
practice,
w
e
exp
ect
that
delayIO
will
b
e
used
mainly
b
y
system
programmers.
With
the
aid
of
delayIO
(and
a
few
new
primitiv
es
suc
h
as
fOpenIO
),
it
is
easy
to
write
a
lazy
readFile
:
readFile
::
[Char]
->
IO
[Char]
readFile
s
=
fOpenIO
s
`bindIO`
\f
->
delayIO
(lazyRd
f)
lazyRd
::
File
->
IO
[Char]
lazyRd
f
=
readChar
f
`bindIO`
\a
->
if
(a
==
eof)
then
fCloseIO
f
`seqIO`
unitIO
[]
else
delayIO
(lazyRd
f)
`bindIO`
\as
->
unitIO
(a:as)
The
delayIO
com
binator
pro
vides
essen
tially
the
p
o
w
er
of
Gordon's
suspend
op
erator
(Gordon
[		]).
Implementation.
A
nice
feature
of
the
implem
en
tation
tec
hnique
outlined
in
Section

is
that
delayIO
is
v
ery
easy
to
dene:
delayIO
m
=
\w
->
let
res
=
case
(m
w)
of
MkIORes
r
w'
->
r
in
MkIORes
res
w
In
con
trast
to
bindIO
,
notice
ho
w
delayIO
duplicates
the
w
orld
w,
and
then
discards
the
nal
w
orld
w'
of
the
de-
la
y
ed
branc
h;
it
is
this
whic
h
allo
ws
the
unsync
hronised
in
terlea
ving
of
I/O
op
erations
on
the
\branc
h"
with
those
on
the
\trunk".
.
Async
hronous
I/O
An
ev
en
more
dangerous
but
still
useful
com
binator
is
performIO
,
whose
t
yp
e
is
as
follo
ws:
performIO
::
IO
a
->
a
It
allo
ws
p
oten
tially
side-eecting
op
erations
to
tak
e
place
whic
h
are
not
attac
hed
to
the
main
\trunk"
at
all!
The
pro
of
obligation
here
is
that
an
y
suc
h
side
eects
do
not
aect
the
b
eha
viour
of
the
rest
of
the
program.
An
ob
vi-
ous
application
is
when
one
wishes
to
call
a
C
pro
cedure
whic
h
really
is
a
pure
function;
pro
cedures
from
a
n
umer-
ical
analysis
library
are
one
example.
Implementation.
The
implemen
tation
is
quite
simple:
performIO
m
=
case
(m
newWorld)
of
MkIORes
r
w'
->
r
Here,
newWorld
is
a
v
alue
of
t
yp
e
World
conjured
up
out
of
thin
air,
and
discarded
when
the
action
m
has
b
een
p
erformed.
.
Assignmen
t
and
reference
v
ariables
Earlier,
in
Section
.,
w
e
discussed
the
apparen
tly
in-
soluble
ineciency
of
dToIO
,
the
function
whic
h
em
u-
lates
Dialogue
s
using
the
IO
monad.
W
e
can
solv
e
this
problem
b
y
pro
viding
an
extra
general-purp
ose
mec
ha-
nism,
that
of
assignable
r
efer
enc
e
typ
es
and
op
erations
o
v
er
them
(Ireland
[		]):
newVar
::
a
->
IO
(Ref
a)
assignVar
::
Ref
a
->
a
->
IO
()
deRefVar
::
Ref
a
->
IO
a
The
call
newVar
x
allo
cates
a
fresh
v
ariable
con
taining
the
v
alue
x;
the
call
assignVar
v
x
assigns
v
alue
x
to
v
ariable
v;
and
the
call
deRefVar
v
fetc
hes
the
v
alue
in
v
ariable
v.
By
making
these
side-eecting
op
erations
part
of
the
IO
monad,
w
e
mak
e
sure
that
their
order
of
ev
alu-
ation,
and
hence
seman
tics,
is
readily
explicable.
With
the
aid
of
these
primitiv
es
it
is
p
ossible
to
write
an
ecen
t
em
ulation
of
Dialogues
using
IO
(Figure
).
The
idea
is
to
mimi
c
a
system
whic
h
directly
implemen
ts
Dialogues
,
whic
h
follo
ws
the
pro
cessing
of
eac
h
request
with
a
destructiv
e
up
date
to
add
a
new
resp
onse
to
the
end
of
the
list
of
resp
onses.
Notice
the
uses
of
delayIO
,
whic
h
reects
the
fact
that
there
is
no
guaran
tee
that
dialogue
will
not
ev
aluate
a
resp
onse
b
efore
it
has
emit-
ted
a
request.
If
this
o
ccurs,
the
un-assigned
v
ariable
is
ev
aluated,
whic
h
elicits
a
suitable
error
message.
References
in
languages
suc
h
as
ML
require
a
w
eak
ened
form
of
p
olymorphism
in
order
to
main
tain
t
yp
e
safet
y
	

dToIO
::
Dialogue
->
IO
()
dToIO
dialogue
=
newVar
(error
"Synch")
`bindIO`
\rsV
->
delayIO
(deRefVar
rsV)
`bindIO`
\rs
->
run
(dialogue
rs)
rsV
run
::
[Request]
->
Ref
[Response]
->
IO
()
run
[]
v
=
doneIO
run
(req:reqs)
v
=
doReq
req
`bindIO`
\r
->
newVar
(error
"Synch")
`bindIO`
\rsV
->
delayIO
(deRefVar
rsV)
`bindIO`
\rs
->
assignVar
v
(r:rs)
`seqIO`
run
reqs
rsV
Figure
:
Ecien
t
con
v
ersion
from
Dialogue
to
IO
(T
ofte
[		0]).
F
or
instance,
in
ML
a
fresh
reference
to
an
empt
y
list
has
t
yp
e
'_a
list
ref
,
where
the
t
yp
e
v
ariable
'_a
is
we
ak,
and
so
ma
y
b
e
instan
tiated
only
once.
In
con
trast,
here
a
fresh
reference
to
an
empt
y
list
has
t
yp
e
IO
(Ref
a),
and
the
t
yp
e
v
ariable
a
is
normal.
But
no
lac
k
of
safet
y
arises,
b
ecause
an
expression
of
this
t
yp
e
allo
cates
a
new
reference
eac
h
time
it
is
ev
aluated.
The
only
w
a
y
to
c
hange
a
v
alue
of
t
yp
e
IO
(Ref
a)
to
one
of
t
yp
e
Ref
a
is
via
bindIO
,
but
no
w
the
v
ariable
of
t
yp
e
Ref
a
is
not
let-b
ound,
and
so
can
only
b
e
instan
tiated
once
an
yw
a
y
.
Hence
the
extra
complication
of
w
eak
t
yp
e
v
ariables,
required
in
languages
with
side
eects,
seems
unnecessary
here.
(W
e're
indebted
to
Martin
Odersky
for
this
observ
ation.)

Arra
ys
The
approac
h
w
e
tak
e
to
I/O
smo
othly
extends
to
ar-
ra
ys
with
in-place
up
date.
Hudak
has
recen
tly
prop
osed
a
similar
metho
d
based
on
con
tin
uations.
F
or
I/O,
the
monad
and
con
tin
uation
approac
hes
are
in
terdenable.
F
or
arra
ys,
it
turns
out
that
monads
can
implem
en
t
con-
tin
uations,
but
not
the
con
v
erse.
Let
Arr
b
e
the
t
yp
e
of
arra
ys
taking
indexes
of
t
yp
e
Ind
and
yielding
v
alues
of
t
yp
e
Val.
There
are
three
op
era-
tions
on
this
t
yp
e.
new
::
Val
->
Arr
lookup
::
Ind
->
Arr
->
Val
update
::
Ind
->
Val
->
Arr
->
Arr
The
call
new
v
returns
an
arra
y
with
all
en
tries
set
to
v
;
the
call
lookup
i
x
returns
the
v
alue
at
index
i
in
ar-
ra
y
x
;
and
the
call
update
i
v
x
returns
an
arra
y
where
index
i
has
v
alue
v
and
the
remainder
is
iden
tical
to
x.
The
b
eha
viour
of
these
op
erations
is
sp
ecied
b
y
the
usual
la
ws.
lookup
i
(new
v)
=
v
lookup
i
(update
i
v
x)
=
v
lookup
i
(update
j
v
x)
=
lookup
i
x
where
i
=
j
in
the
last
equation.
In
practice,
these
op
er-
ations
w
ould
b
e
more
complex;
one
needs
a
w
a
y
to
sp
ecify
the
arra
y
b
ounds,
for
instance.
But
the
ab
o
v
e
suces
to
explicate
the
main
p
oin
ts.
The
ecien
t
w
a
y
to
implemen
t
the
up
date
op
eration
is
to
o
v
erwrite
the
sp
ecied
en
try
of
the
arra
y
,
but
in
a
pure
functional
language
this
is
only
safe
if
there
are
no
other
p
oin
ters
to
the
arra
y
extan
t
when
the
up
date
op
eration
is
p
erformed.
An
arra
y
satisfying
this
prop
ert
y
is
called
single
thr
e
ade
d,
follo
wing
Sc
hmidt
(Sc
hmidt
[	]).
As
an
example,
consider
the
follo
wing
problem.
An
o
c-
curr
enc
e
is
either
a
denition
pairing
an
index
with
a
v
alue,
or
a
use
of
an
index.
data
Occ
=
Def
Ind
Val
|
Use
Ind
F
or
illustration
tak
e
Ind
=
Int
and
Val
=
Char.
Giv
en
a
list
os
of
o
ccurrences,
the
call
uses
os
returns
for
eac
h
use
the
most
recen
tly
dened
v
alue
(or
'-'
if
there
is
no
previous
denition).
If
os
=
[Def

'a',
Def

'b',
Use
,
Def

'c',
Use
,
Use
]
then
uses
os
=
['a',
'b',
'c'].
Here
is
the
co
de.
uses
::
[Occ]
->
[Val]
uses
os
=
loop
os
(new
'-')
loop
::
[Occ]
->
Arr
->
[Val]
loop
[]
x
=
[]
loop
(Def
i
v
:
os)
x
=
loop
os
(update
i
v
x)
loop
(Use
i
:
os)
x
=
lookup
i
x
:
loop
os
x
The
up
date
in
this
program
can
b
e
p
erformed
b
y
o
v
er-
writing,
but
some
care
is
required
with
the
order
of
ev
al-
uation.
In
the
last
line,
the
lo
okup
m
ust
o
ccur
b
efor
e
the
recursiv
e
call
whic
h
ma
y
up
date
the
arra
y
.
Some
w
ork
has
b
een
done
on
analysing
when
up
date
can
b
e
p
erformed
in-
place,
but
it
is
rather
tric
ky
(Bloss
[		];
Hudak
[	]).
0

.
Monadic
arra
ys
W
e
b
eliev
e
that
single
threading
is
to
o
imp
ortan
t
to
lea
v
e
to
the
v
agaries
of
an
analyser.
Instead,
w
e
use
monads
to
guar
ante
e
single
threading,
in
m
uc
h
the
same
w
a
y
as
w
as
done
with
I/O.
Analogous
to
the
t
yp
e
IO
a
(the
monad
of
I/O
actions),
w
e
pro
vide
an
abstract
t
yp
e
A
a
(the
monad
of
arra
y
transformers).
newA
::
Val
->
A
a
->
a
lookupA
::
Ind
->
A
Val
updateA
::
Ind
->
Val
->
A
()
unitA
::
a
->
A
a
bindA
::
A
a
->
(a
->
A
b)
->
A
b
F
or
purp
oses
of
sp
ecication,
w
e
can
dene
these
in
terms
of
the
pro
ceeding
op
erations
as
follo
ws.
type
A
a
=
Arr
->
(a,
Arr)
newA
v
m
=
fst
(m
(new
v))
lookupA
i
=
\x
->
(lookup
i
x,
x)
updateA
i
v
=
\x
->
((),
update
i
v
x)
unitA
a
=
\x
->
(a,x)
m
`bindA`
k
=
\x
->
let
(a,y)
=
m
x
in
k
a
y
A
little
though
t
sho
ws
that
these
op
erations
are
indeed
single
threaded.
The
only
op
eration
that
could
duplicate
the
arra
y
is
lookupA
,
but
this
ma
y
b
e
implemen
ted
as
follo
ws:
rst
fetc
h
the
en
try
at
the
giv
en
index
in
the
arra
y
,
and
then
return
the
pair
consisting
of
this
v
alue
and
the
p
oin
ter
to
the
arra
y
.
T
o
enforce
the
necessary
sequencing,
w
e
augmen
t
the
ab
o
v
e
sp
ecication
with
the
requiremen
t
that
lookupA
and
updateA
are
strict
in
the
index
and
arra
y
argumen
ts
(but
need
not
b
e
strict
in
the
v
alue).
The
ab
o
v
e
is
giv
en
for
purp
oses
of
sp
ecication
only
{
the
actual
implem
en
tation
is
along
the
lines
of
Section
.
F
or
con
v
enience,
dene
seqA
in
terms
of
bindA
in
the
usual
w
a
y
.
m
`seqA`
n
=
m
`bindA`
\a
->
n
Here
is
the
`denition-use'
problem,
reco
ded
in
monadic
st
yle.
uses
::
[Occ]
->
[Val]
uses
os
=
newA
'-'
(loopA
os)
loopA
::
[Occ]
->
A
[Val]
loopA
[]
=
unitA
[]
loopA
(Def
i
v
:
os)
=
updateA
i
v
`seqA`
loopA
os
loopA
(Use
i
:
os)
=
lookupA
i
`bindA`
\v
->
loopA
os
`bindA`
\vs
->
unitA
(v:vs)
This
is
somewhat
lengthier
than
the
previous
example,
but
it
is
guaran
teed
safe
to
implem
en
t
up
date
b
y
o
v
er-
writing.
.
Con
tin
uatio
n
arra
ys
An
alternativ
e
metho
d
of
guaran
teeing
single
threading
for
arra
ys
has
b
een
prop
osed
b
y
Hudak
[		].
Lik
e
the
previous
w
ork
of
Sw
arup,
Reddy
&
Ireland
[		],
it
is
based
on
con
tin
uations,
but
unlik
e
that
w
ork
it
requires
no
c
hange
to
the
t
yp
e
system.
As
with
the
arra
y
monad,
one
denes
an
abstract
t
yp
e
supp
orting
v
arious
op
erations.
The
t
yp
e
is
C
z,
and
the
op
erations
are
as
follo
ws.
newC
::
Val
->
C
z
->
z
lookupC
::
Ind
->
(Val
->
C
z)
->
C
z
updateC
::
Ind
->
Val
->
C
z
->
C
z
unitC
::
z
->
C
z
Here
a
con
tin
uation,
of
t
yp
e
C
z,
represen
ts
the
remaining
series
of
actions
to
b
e
p
erformed
on
the
arra
y
,
ev
en
tually
returning
(via
unitC
)
a
v
alue
of
t
yp
e
z.
F
or
purp
oses
of
sp
ecication,
w
e
can
dene
these
in
terms
of
the
arra
y
op
erations
as
follo
ws.
type
C
z
=
Arr
->
z
newC
v
c
=
c
(new
v)
lookupC
i
d
=
\x
->
d
(lookup
i
x)
x
updateC
i
v
c
=
\x
->
c
(update
i
v
x)
unitC
z
=
\x
->
z
Again,
these
op
erations
are
single
threaded
if
lookupC
and
updateC
are
strict
in
the
index
and
arra
y
argumen
ts.
F
or
con
v
enience,
dene
m
$
c
=
m
c
This
lets
us
omit
some
paren
theses,
since
m
(\x
->
n)
b
ecomes
m
$
\x
->
n.
Here
is
the
`denition-use'
problem,
reco
ded
in
con
tin
ua-
tion
st
yle.
uses
::
[Occ]
->
[Val]
uses
os
=
newC
'-'
(loopC
os
unitC)
loopC
::
[Occ]
->
([Val]
->
C
z)
->
C
z
loopC
[]
c
=
c
[]
loopC
(Def
i
v
:
os)
c
=
updateC
i
v
$
loopC
os
c


loopC
(Use
i
:
os)
c
=
lookupC
i
$
\v
->
loopC
os
$
\vs
->
c
(v:vs)
This
is
remark
ably
similar
to
the
monadic
st
yle,
where
$
tak
es
the
place
of
bindA
and
seqA
,
and
the
curren
t
con
tin
uation
c
tak
es
the
place
of
unitA
.
(If
c
pla
ys
the
role
of
unitA
,
wh
y
do
w
e
need
unitC
?
Because
it
acts
as
the
`top
lev
el'
con
tin
uation.)
Ho
w
ev
er,
there
are
t
w
o
things
to
note
ab
out
the
con
tin-
uation
st
yle.
First,
the
t
yp
es
are
rather
more
complex
{
compare
the
t
yp
es
of
loopA
and
loopC
.
Second,
the
monadic
st
yle
abstracts
a
w
a
y
from
the
notion
of
con
tin-
uation
{
so
there
are
no
o
ccurrences
of
c
cluttering
the
den
tion
of
loopA
.
.
Monads
vs.
con
tin
uati
on
s
W
e
can
formally
compare
the
p
o
w
er
of
the
t
w
o
approac
hes
b
y
attempting
to
implemen
t
eac
h
in
terms
of
the
other.
Despite
their
similarities,
the
t
w
o
approac
hes
are
not
equiv
alen
t.
Monads
are
p
o
w
erful
enough
to
implemen
t
con
tin
uations,
but
not
(quite)
vice
v
ersa.
T
o
implemen
t
con
tin
uations
in
terms
of
monads
is
sim-
plicit
y
itself.
type
C
z
=
A
z
newC
v
c
=
newA
v
c
lookupC
i
d
=
lookupA
i
`bindA`
d
updateC
i
v
c
=
updateA
i
v
`seqA`
c
unitC
=
unitA
It
is
an
easy
exercise
in
equational
reasoning
to
to
pro
v
e
that
this
implemen
tatio
n
is
correct
in
terms
of
the
sp
eci-
cations
in
Sections
.
and
..
The
rev
erse
implem
en
tation
is
not
p
ossible.
The
trouble
is
the
anno
ying
extra
t
yp
e
v
ariable,
z,
app
earing
in
the
t
yp
es
of
lookupC
and
updateC
.
This
forces
the
in
tro
duc-
tion
of
a
spurious
t
yp
e
v
ariable
in
to
an
y
attempt
to
dene
monads
in
terms
of
con
tin
uations.
Instead
of
a
t
yp
e
A
a,
the
b
est
one
can
do
is
to
dene
a
t
yp
e
B
a
z.
Here
are
the
t
yp
es
of
the
new
op
erations.
newB
::
Val
->
B
a
a
->
a
lookupB
::
Ind
->
B
Val
z
updateB
::
Ind
->
Val
->
B
()
z
unitB
::
a
->
B
a
z
bindB
::
B
a
z
->
(a
->
B
b
z)
->
B
b
z
And
here
are
the
implemen
tations
in
terms
of
con
tin
ua-
tions.
type
B
a
z
=
(a
->
C
z)
->
C
z
newB
v
m
=
newC
v
(m
unitC)
lookupB
i
=
\d
->
lookupC
i
d
updateB
i
v
=
\d
->
updateC
i
v
(d
())
unitB
a
=
\d
->
d
a
m
`bindB`
k
=
\d
->
m
(\a
->
k
a
d)
Again,
it
is
easy
to
pro
v
e
this
implem
en
tation
satises
the
giv
en
sp
ecications.
So
monads
are
more
p
o
w
erful
than
con
tin
uations,
but
only
b
ecause
of
the
t
yp
es!
It
is
not
clear
whether
this
is
simply
an
artifact
of
the
Hindley-Milner
t
yp
e
system,
or
whether
the
t
yp
es
are
rev
ealing
a
dierence
of
funda-
men
tal
imp
ortance.
(Our
o
wn
in
tuition
is
the
latter
{
but
it's
only
an
in
tuition.)
.
Conclusion
The
I/O
approac
h
outlined
earlier
manipulates
a
glob
al
state,
namely
the
en
tire
state
of
the
mac
hine
accessible
via
a
C
program.
What
has
b
een
sho
wn
in
this
section
is
that
this
approac
h
extends
smo
othly
to
manipulating
lo
c
al
state,
suc
h
as
a
single
arra
y
.
F
urther,
although
the
monad
and
con
tin
uation
approac
hes
are
in
tercon
v
ertible
for
I/O,
they
are
not
for
arra
ys:
monads
are
p
o
w
erful
enough
to
dene
con
tin
uations,
but
not
the
rev
erse.
F
or
actual
use
with
Hask
ell,
w
e
require
a
sligh
tly
more
so-
phisticated
set
of
op
erations.
The
t
yp
e
A
m
ust
tak
e
extra
parameters
corresp
onding
to
the
index
and
v
alue
t
yp
es,
the
op
eration
newA
should
tak
e
the
arra
y
b
ounds,
and
so
on.
By
using
a
v
arian
t
of
newA
that
creates
an
unini-
tialised
arra
y
,
and
returns
the
arra
y
after
all
up
dates
are
nished,
it
is
p
ossible
to
implemen
t
Hask
ell
primitiv
es
for
creating
arra
ys
in
terms
of
the
simpler
monad
op
era-
tions.
Th
us
the
same
strategy
that
w
orks
for
implemen
t-
ing
I/O
should
w
ork
for
implem
en
ting
arra
ys:
use
a
small
set
of
primitiv
es
based
on
monads,
and
dep
end
on
pro-
gram
transformation
to
mak
e
this
adequately
ecien
t.
One
question
that
remains
is
ho
w
w
ell
this
approac
h
ex-
tends
to
situations
where
one
wishes
to
manipulate
more
than
one
state
at
a
time,
as
when
com
bining
I/O
with
arra
y
op
erations,
or
op
erating
on
t
w
o
arra
ys.
In
this
re-
sp
ect
eect
systems
or
linear
t
yp
es
ma
y
b
e
sup
erior;
see
b
elo
w.

Related
w
ork
.
Eect
systems
Giord
and
Lucassen
in
tro
duced
`eect
systems'
whic
h
use
t
yp
es
to
record
the
side-eects
p
erformed
b
y
a
pro-


gram,
and
to
determine
whic
h
comp
onen
ts
of
a
program
can
run
in
parallel
without
in
terference
(Giord
&
Lu-
cassen
[	]).
The
original
notion
of
eect
w
as
fairly
crude,
there
b
eing
only
four
p
ossible
eects:
pure
(no
ef-
fect),
allo
cate
(ma
y
allo
cate
storage),
function
(ma
y
read
storage),
pro
cedure
(ma
y
write
storage).
New
systems
are
more
rened,
allo
wing
eects
to
b
e
expressed
separately
for
dieren
t
regions
of
store
(Jouv
elot
&
Giord
[		]).
A
theoretical
precursor
of
the
eects
w
ork
is
that
of
Reynolds,
whic
h
also
used
t
yp
es
to
record
where
eects
could
o
ccur
and
where
parallelism
w
as
allo
w
ed
(Reynolds
[	];
Reynolds
[		]).
Our
w
ork
is
similar
to
the
ab
o
v
e
in
its
commitm
en
t
to
use
t
yp
es
to
indicate
eects.
But
eect
systems
are
de-
signed
for
impure,
strict
functional
languaes,
where
the
order
of
sequencing
is
implicit.
Our
w
ork
is
designed
for
pure,
lazy
functional
languages,
and
the
purp
ose
of
the
`bind
'
op
eration
is
to
mak
e
sequencing
explicit
where
it
is
required.
With
eect
systems,
one
ma
y
use
the
usual
la
ws
of
equational
reasoning
on
an
y
program
segmen
t
without
a
`write'
side
eect.
Our
w
ork
diers
in
that
the
la
ws
of
equational
reasoning
apply
even
wher
e
side
ee
cts
ar
e
al
lowe
d.
This
is
essen
tial,
b
ecause
the
optimisation
phase
of
our
compiler
is
based
on
equational
reasoning.
On
the
other
hand,
eect
systems
mak
e
it
v
ery
easy
to
com
bine
programs
with
dieren
t
eects.
In
our
ap-
proac
h,
eac
h
dieren
t
eect
w
ould
corresp
ond
to
a
dier-
en
t
monad
t
yp
e
(one
for
IO,
one
for
eac
h
arra
y
manip-
ulated,
and
so
on),
and
it
is
not
so
clear
ho
w
one
go
es
ab
out
com
bining
eects.
.
Linear
t
yp
es
The
implem
en
tation
of
the
IO
monad
giv
en
in
Section

is
safe
b
ecause
(and
only
b
ecause)
the
co
de
that
manipu-
lates
the
w
orld
nev
er
duplicates
or
destro
ys
it.
W
e
guar-
an
tee
safet
y
b
y
making
the
IO
t
yp
e
abstract,
so
that
user
has
no
direct
access
to
the
w
orld.
An
alternativ
e
is
to
allo
w
the
user
access
to
the
w
orld,
but
in
tro
duce
a
t
yp
e
system
that
guaran
tees
that
the
w
orld
can
nev
er
b
e
duplicated
or
destro
y
ed.
A
n
um
b
er
of
t
yp
e
systems
ha
v
e
b
een
prop
osed
along
suc
h
lines.
Some
ha
v
e
b
een
based
on
Girard's
linear
logic
(Girard
[	]),
and
this
remains
an
area
of
activ
e
exploration
(Abram-
sky
[		0];
Guzman
&
Hudak
[		0];
W
adler
[		0]).
An-
other
is
the
t
yp
e
system
prop
osed
b
y
the
Nijmegen
Clean
group,
whic
h
is
more
ad-ho
c
but
has
b
een
tested
in
prac-
tical
applications
similar
to
our
o
wn
(Ac
h
ten,
Groningen
&
Plasmeijer
[		]).
F
or
example,
here
is
the
echo
program
again,
written
in
the
st
yle
suggested
b
y
the
Clean
I/O
system:
echo
::
File
->
File
->
World
->
World
echo
fi
fo
w
=
if
a
==
eof
then
w
else
echo
(putChar
fo
a
w)
where
(w,a)
=
getChar
fi
w
Compared
to
the
monad
approac
h,
this
suers
from
a
n
um
b
er
of
dra
wbac
ks:
programs
b
ecome
more
cluttered;
the
linear
t
yp
e
system
has
to
b
e
explained
to
the
pro-
grammer
and
implem
en
ted
in
the
compiler;
and
co
de-
impro
ving
transformations
need
to
b
e
re-examined
to
en-
sure
they
preserv
e
linearit
y
.
The
latter
problem
ma
y
b
e
imp
ortan
t;
W
ak
eling
found
that
some
standard
transfor-
mations
could
not
b
e
p
erformed
in
the
presence
of
linear-
it
y
(W
ak
eling
[		0]).
The
big
adv
an
tage
of
a
linear
t
yp
e
system
is
that
it
en-
ables
us
to
write
programs
whic
h
manipulate
more
than
one
piece
of
up
datable
state
at
a
time.
The
monadic
and
con
tin
uation-passing
presen
tations
of
arra
ys
giv
en
ab
o
v
e
pass
the
arra
y
around
implicitly
,
and
hence
can
only
eas-
ily
handle
one
at
a
time.
This
is
an
imp
ortan
t
area
for
future
w
ork.
On
the
practical
side,
the
Clean
w
ork
is
impressiv
e.
They
ha
v
e
written
a
library
of
high-lev
el
routines
to
call
the
Macin
tosh
windo
w
system,
and
demonstrated
that
it
is
p
ossible
to
build
pure
functional
programs
with
sophisti-
cated
user
in
terfaces.
The
same
approac
h
should
w
ork
for
monads,
and
another
area
for
future
w
ork
is
to
conrm
that
this
is
the
case.

Conclusions
and
further
w
ork
W
e
ha
v
e
b
een
pleasan
tly
surprised
b
y
b
oth
the
expres-
siv
eness
and
the
eciency
of
the
approac
h
w
e
ha
v
e
de-
scrib
ed.
F
or
example,
w
e
ha
v
e
found
that
while
it
is
p
os-
sible
to
write
comp
osable
I/O
programs
in
other
st
yles,
it
is
almost
imp
ossible
not
to
do
so
in
using
the
monadic
approac
h.
Plen
t
y
remains
to
b
e
done.
W
e
are
w
orking
on
our
im-
plemen
tation
of
arra
ys;
this
in
turn
feeds
in
to
the
abilit
y
to
pass
structured
v
alues
in
ccall
s;
w
e
ha
v
e
not
y
et
im-
plemen
ted
assignable
reference
t
yp
es.
More
imp
ortan
tly
,
the
mo
del
w
e
ha
v
e
desrib
ed
concerns
only
the
I/O
infr
astructur
e.
Muc
h
more
w
ork
needs
to
b
e
done
to
design
libraries
of
functions,
built
on
top
of
this
infrastructure,
whic
h
presen
t
a
higher-lev
el
in
terface
to
the
programmer
(Ac
h
ten,
Groningen
&
Plasmeijer
[		];


Hammond,
W
adler
&
Brady
[		]).
Ac
kno
wledgemen
ts
This
w
ork
to
ok
place
in
the
con
text
of
the
team
building
the
Glasgo
w
Hask
ell
compiler:
Cordy
Hall,
Kevin
Ham-
mond
and
Will
P
artain.
Da
vid
W
att,
Jo
e
Morris,
John
Launc
h
bury
also
made
v
ery
helpful
suggestions
ab
out
our
presen
tation.
W
e
gratefully
ac
kno
wledge
their
help.
References
S
Abramsky
[		0],
\Computational
in
terpretations
of
linear
logic,"
DOC
	0/0,
Dept
of
Computing,
Imp
erial
College.
PM
Ac
h
ten,
JHG
v
an
Groningen
&
MJ
Plasmeijer
[		],
\High-lev
el
sp
ecication
of
I/O
in
func-
tional
languages,"
in
Pro
c
Glasgo
w
W
orkshop
on
F
unctional
Programming
,
Launc
h
bury
et
al,
ed.,
Springer
V
erlag.
A
Bloss
[Sept
		],
\Up
date
analysis
and
the
ecien
t
im-
plemen
tation
of
functional
aggregates,"
in
F
unc-
tional
Programmi
ng
Languages
and
Computer
Arc
hitecture,
London,
A
CM.
A
Dw
elly
[Sept
		],
\Dialogue
com
binators
and
dy-
namic
user
in
terfaces,"
in
F
unctional
Program-
ming
Languages
and
Computer
Arc
hitecture,
London,
A
CM.
DK
Giord
&
JM
Lucassen
[Aug
	],
\In
tegrating
func-
tional
and
imp
erativ
e
programming,
"
in
A
CM
Conference
on
Lisp
and
F
unctional
Program-
ming,
MIT
,
A
CM,
{.
J-Y
Girard
[	],
\Linear
Logic,"
Theoretical
Computer
Science
0,
{0.
A
Gordon
[F
eb
		],
\PFL+:
a
k
ernel
sc
heme
for
func-
tional
I/O,"
TR
0,
Computer
Lab,
Univ
ersit
y
of
Cam
bridge.
JC
Guzman
&
P
Hudak
[		0],
\Single-threaded
p
oly-
morphic
lam
b
da
calculus,"
in
Pro
c
th
Ann
ual
IEEE
Symp
osium
on
Logic
in
Computer
Science
.
K
Hammond,
PL
W
adler
&
D
Brady
[		],
\Imp
erate:
b
e
imp
erativ
e,"
Departmen
t
of
Computer
Science,
Univ
of
Glasgo
w.
P
Hudak
[July
		],
\Con
tin
uation-based
m
utable
ab-
stract
datat
yp
es,
or
ho
w
to
ha
v
e
y
our
state
and
m
unge
it
to
o,"
Y
ALEU/DCS/RR-	,
Depart-
men
t
of
Computer
Science,
Y
ale
Univ
ersit
y
.
P
Hudak,
SL
P
eyton
Jones,
PL
W
adler,
Arvind,
B
Boutel,
J
F
airbairn,
J
F
asel,
M
Guzman,
K
Hammo
nd,
J
Hughes,
T
Johnsson,
R
Kieburtz,
RS
Nikhil,
W
P
artain
&
J
P
eterson
[Ma
y
		],
\Rep
ort
on
the
functional
programming
language
Hask
ell,
V
er-
sion
.,"
SIGPLAN
Notices
.
P
Hudak
&
RS
Sundaresh
[Marc
h
		],
\On
the
ex-
pressiv
eness
of
purely-functional
I/O
systems,"
Y
ALEU/DCS/RR-,
Departmen
t
of
Com-
puter
Science,
Y
ale
Univ
ersit
y
.
P
aul
Hudak
[Aug
	],
\A
seman
tic
mo
del
of
reference
coun
ting
and
its
abstraction,"
Pro
c
A
CM
Con-
ference
on
Lisp
and
F
unctional
Programming
.
E
Ireland
[Marc
h
		],
\W
riting
in
teractiv
e
and
le-
pro
cessing
functional
programs,"
MSc
thesis,
Victoria
Univ
ersit
y
of
W
ellington.
P
Jouv
elot
&
D
Giord
[Jan
		],
\Algebraic
reconstruc-
tion
of
t
yp
es
and
eects,"
in
'th
A
CM
Symp
o-
sium
on
Principles
of
Programming
Languages
(POPL),
Orlando
,
A
CM.
Ken
t
Karlsson
[	],
\Nebula
-
a
functional
op
erating
system,"
Chalmers
Inst,
Goteb
org.
BW
Kernighan
&
DM
Ritc
hie
[	],
The
C
programmi
ng
language,
Pren
tice
Hall.
E
Moggi
[June
		],
\Computational
lam
b
da
calculus
and
monads,"
in
Logic
in
Computer
Science,
Cal-
ifornia,
IEEE.
JT
O'Donnell
[	],
\Dialogues:
a
basis
for
construct-
ing
programmi
ng
en
vironmen
ts,"
in
Pro
c
A
CM
Symp
osium
on
Language
Issues
in
Programming
En
vironmen
ts,
Seattle
,
A
CM,
	{.
N
P
erry
[		],
\The
implemen
tation
of
practical
func-
tional
programming
languages,"
PhD
thesis,
Im-
p
erial
College,
London.
SL
P
eyton
Jones
[Apr
		],
\Implemen
ting
lazy
func-
tional
languages
on
sto
c
k
hardw
are:
the
Spine-
less
T
agless
G-mac
hine,"
Journal
of
F
unctional
Programming
,
{0.


SL
P
eyton
Jones
[Oct
	],
\Con
v
erting
streams
to
con-
tin
uations
and
vice
v
ersa,"
Electronic
mail
on
Hask
ell
mailing
list.
SL
P
eyton
Jones
&
J
Launc
h
bury
[Sept
		],
\Un
b
o
xed
v
alues
as
rst
class
citizens,"
in
F
unctional
Pro-
gramming
Languages
and
Computer
Arc
hitec-
ture,
Boston,
Hughes,
ed.,
LNCS
,
Springer
V
erlag.
J
Reynolds
[	],
\The
essence
of
Algol,"
in
Algorithmic
Languages
,
de
Bakk
er
&
v
an
Vliet,
eds.,
North
Holland,
{.
J
Reynolds
[		],
\Syn
tactic
con
trol
of
in
terference,
part
I
I,"
in
In
ternational
Collo
quium
on
Automata,
Languages,
and
Programming
.
D
A
Sc
hmidt
[Apr
	],
\Detecting
global
v
ariables
in
de-
notational
sp
ecications,"
TOPLAS
,
		{0.
V
Sw
arup,
US
Reddy
&
E
Ireland
[Sept
		],
\Assign-
men
ts
for
applicativ
e
languages,"
in
F
unctional
Programming
Languages
and
Computer
Arc
hi-
tecture,
Boston,
Hughes,
ed.,
LNCS
,
Springer
V
erlag,
	{.
SJ
Thompson
[		],
\In
teractiv
e
functional
programs
-
a
metho
d
and
a
formal
seman
tics,"
in
Declarativ
e
Programming
,
D
A
T
urner,
ed.,
Addison
W
esley.
M
T
ofte
[No
v
		0],
\T
yp
e
inference
for
p
olymorphic
ref-
erences,"
Information
and
Computation
	.
PL
W
adler
[		0],
\Linear
t
yp
es
can
c
hange
the
w
orld!,"
in
Programming
concepts
and
metho
ds
,
M
Bro
y
&
C
Jones,
eds.,
North
Holland.
PL
W
adler
[Jan
		],
\The
essence
of
functional
pro-
gramming,
"
in
Pro
c
Principles
of
Programmi
ng
Languages
,
A
CM.
PL
W
adler
[June
		0],
\Comprehending
monads,"
in
Pro
c
A
CM
Conference
on
Lisp
and
F
unctional
Programming,
Nice
,
A
CM.
D
W
ak
eling
[No
v
		0],
\Linearit
y
and
laziness,"
PhD
thesis,
Departmen
t
of
Computer
Science,
Univ
er-
sit
y
of
Y
ork.


