Oracles in Software Networks: A New Scientific and 
Technological Approach to Designing Self-Managing 
Distributed Computing Processes 
Rao Mikkilineni 
C3DNA Inc. 
2520 Mission College Blvd 
Santa Clara, CA 95054 
rao@c3dna.com 
 
Giovanni Morana 
C3DNA Inc. 
2520 Mission College Blvd 
Santa Clara, CA 95054 
giovanni@c3dna.com 
Mark Burgin 
UC Los Angeles 
405 Hilgard Ave 
Los Angeles, CA 90095, USA 
mburgin@math.ucla.edu 
 
 
ABSTRACT 
For Turing and the majority of computer scientists, an Oracle is a 
device that supplies a Turing machine with the values of some 
function (on the natural numbers or words in some alphabet) that 
is not recursively, e.g., Turing-machine, computable. Now 
technological innovations and social progress necessitate further 
changes to the concept of an Oracle.  
The first step in this direction was done by Burgin and 
Mikkilineni [1] using the relativization of the concept of an 
Oracle and extending its functions. Here we develop a forward-
thinking theory of Oracles with application to distributed 
computing network technology. Different types and sorts of 
Oracles are introduced and studied. Their properties are 
explicated and analyzed in the context of computation theory and 
network technology. Utilization of Oracles in the distributed 
intelligent managed element (DIME) network architecture is 
described demonstrating expediency of Oracle theory in designing 
self-managing distributed computing processes.   
Categories and Subject Descriptors 
F.1.1 [Models of Computation]: Automata and Computability 
Theory 
I.1.2 [Algorithms]: Analysis of algorithms 
General Terms 
Algorithms, Theory. 
Keywords 
semantic network; DIME network architecture; grid automaton;  
structural operation;  connectivity; modularity; Turing O-
Machine; cloud computing. 
1. INTRODUCTION 
Self-managing system [2] by definition implies two components 
in the system: the observer (or the Self) and the observed (or the 
environment) with which the observer interacts by monitoring and 
controlling various aspects that are of importance to the observer. 
It also implies that the observer is aware of systemic goals to 
measure and control its interaction with the observed. In living 
organisms, the self-management behavior is attributed to the sense 
of self and to the awareness, which contribute to defining one’s 
multiple tasks to reach specific goals within a dynamic 
environment and adapting the behavior accordingly. The concepts 
of self and self-reflection which model the observer, the observed 
and their interactions are quite different from a third party 
observation of a set of actors or agents who monitor and control 
the system. In the realm of computations, two theoretical 
limitations of formal systems inhibit the implementation of self-
management.  The first one is directly related to the halting 
problem in the current computational model based on Turing 
Machines. The second limitation is due to the Gödel’s [3] 
incompleteness theorem. An important implication of this theorem 
is that it is not possible to have a finite description within the 
description itself as the proper part. In short, Gödel’s theorems 
prohibit “self-reflection” in Turing machines. The “algorithm” 
defines an intent and a process to execute the intent but does not 
know how to execute itself. It requires an external agent to 
execute it by providing the resources required, monitor the 
process and correct it if deviations occur. 
However, as Turing [4] put it beautifully, “the well-known 
theorem of Gödel shows that every system of logic is in a certain 
sense incomplete, but at the same time it indicates means whereby 
from a system L of logic a more complete system L_ may be 
obtained. By repeating the process we get a sequence L, L1 = L_, 
L2 = L_1 … each more complete than the preceding. A logic Lω 
may then be constructed in which the provable theorems are the 
totality of theorems provable with the help of the logics L, L1, L2, 
… Proceeding in this way we can associate a system of logic with 
any constructive ordinal. It may be asked whether such a sequence 
of logics of this kind is complete in the sense that to any problem 
A there corresponds an ordinal α such that A is solvable by means 
of the logic Lα.”  This observation along with his introduction of 
the Oracle-machine influenced many theoretical advances 
including the development of generalized recursion theory that 
extended the concept of an algorithm [5, 6]. “An o-machine is like 
a Turing machine (TM) except that the machine is endowed with 
an additional basic operation of a type that no Turing machine can 
simulate.” Turing called the new operation the ‘Oracle’ and said 
that it works by ‘some unspecified means’. When the Turing 
machine is in a certain internal state, it can query the Oracle for an 
answer to a specific question and act accordingly depending on 
the answer. The o-machine provides a generalization of the Turing 
 
Permission to make digital or hard copies of all or part of this work for 
personal or classroom use is granted without fee provided that copies are 
not made or distributed for profit or commercial advantage and that 
copies bear this notice and the full citation on the first page. To copy 
otherwise, or republish, to post on servers or to redistribute to lists, 
requires prior specific permission and/or a fee.  
ECSAW '15, September 07 - 11, 2015, Dubrovnik/Cavtat, Croatia. 
ISBN 978-1-4503-3393-1/15/09 $15.00 
DOI: http://dx.doi.org/10.1145/2797433.2797444 

machines 
aimed 
at 
exploring 
the 
impact 
of 
Gödel’s 
incompleteness theorems and problems that are not recursively 
computable but are computable in a more general sense using 
relative reducibility and relative computability [6]. 
Later a more formal description of o-machines was given in the 
form of a Turing machine with advice, in which the Oracle was 
simply an additional tape where answers to “specific questions”, 
e.g., values of some recursively non-computable function were 
written [7, 8]. 
Here we essentially extend the concept of an Oracle in the context 
of the theory of Oracles constructing various kinds of Oracles and 
describing their properties. These Oracles allow corrections to 
manage the deviations from the intent from an external viewpoint 
and can be exploited to create a monitoring and control system to 
infuse cognition into computing and this is the theme of this 
paper. In section 2, we present the elements of the theory of 
Oracles. In section 3, we introduce an Oracle based computing 
paradigm called DIME network architecture that has been 
successfully used to implement self-managing distributed systems. 
In section 4, we present a theory of the DIME networks using the 
Grid Automata with Oracles. In section 5, we expound some 
conclusions on how this model based approach can further our 
understanding of the design of self-managing distributed systems. 
2. ELEMENTS OF THE THEORY OF 
ORACLES 
Here we treat an Oracle as a system with definite properties 
with respect to another system. 
Types of Oracles: 
1. 
Simplification Oracle M for T is a system that solves 
some problems more efficiently (with less complexity) than T 
2. 
Augmentation Oracle M for T is a system such that 
there are problems intractable for T but tractable for M 
3. 
Extension Oracle M for T is a system such that there are 
problems unsolvable for T but solvable for M 
Let us consider some examples. 
Example 1. Turing machines can serve as extension Oracles for 
finite automata. 
Example 2. Nondeterministic Turing machines can serve as 
augmentation Oracles for deterministic Turing machines. 
Example 3. Inductive Turing machines can work as extension 
Oracles for Turing machines. 
It is possible to formalize these definitions assuming that all 
considered systems are information processing systems, e.g., 
automata or machines. The type of simplification Oracles includes 
two subtypes. 
Definition 1. An automaton M is a total simplification Oracle in 
a domain D for an automaton T if the following condition is 
satisfied 
 
xD ( T(x)! M(x)! & (c(M(x)) ≺ c(T(x))) ) 
Here: 
 
c: AD  L is a computational complexity measure; ≺ 
is a partial order [8]; the expression A(x)! means that the 
automaton A {M, T} gives the result given the input x. 
Definition 2. An automaton M is a partial simplification 
Oracle in a domain D for an automaton T if the following 
condition is satisfied 
CD (bD(C)) xC (T(x)! M(x)! & (c(M(x)) ≺ c(T(x))) )  
Here the expression bD(C) means that the set C is sufficiently big 
(essential) in D, e.g., when D is infinite, C is also infinite.  
Example 4. In the set N of all natural numbers, co-finite sets, i.e., 
sets that contain almost all natural numbers, form sufficiently big 
subsets of N. 
Example 5. Let us consider a set D and an element a from D. 
Then for C  D, we define that the predicate bD(C) is valid when 
a  C.  
Example 6. Let us consider a set D and a subset X of D. Then for 
C  D, we define that the predicate bD(C) is valid when X  C. 
Note that any total simplification Oracle for T is also a partial 
simplification Oracle for T. 
Lemma 1. An automaton M is a partial simplification Oracle in a 
domain D for an automaton T if it is a total simplification Oracle 
in some sufficiently big subset of D for an automaton T. 
Lemma 2. If an automaton M is a total simplification Oracle in a 
domain D for an automaton T, then it is a partial simplification 
Oracle in any superset H of D for an automaton T if D is a 
sufficiently big subset of H and xH ( T(x)! M(x)! 
Definition 3. An automaton M is a strong partial simplification 
Oracle in a domain D for an automaton T if the following 
condition is satisfied 
CD ( bD(C)) xC zD ( T(z)! M(z)! & (c(M(x)) ≺ 
c(T(x))) ) 
Note that any strong partial simplification Oracle for T is also a 
partial simplification Oracle for T. 
Proposition 1. If an automaton M is a total simplification Oracle 
in a domain D for an automaton T and the automaton T is a total 
simplification Oracle in a domain D for an automaton A, then the 
automaton M is a total simplification Oracle in a domain D for the 
automaton A. Proposition 1 means that the relation “to be a total 
simplification Oracle” is transitive. 
Remark 1. For partial simplification Oracles, Proposition 1 is not 
always true. 
However, under additional conditions, Proposition 2 becomes 
valid for partial simplification oracles. 
Proposition 2. If E, CD (bD(C) &bD(E))  bD(CE), i.e., 
intersection of two sufficiently big in D subsets is a sufficiently 
big subset of D (Condition I), then a (strong) partial 
simplification Oracle M in the domain D for an automaton T, 
which is a (strong) partial simplification Oracle in the domain D 
for an automaton A, is a(strong) partial simplification Oracle in 
the domain D for an automaton A.  

Corollary 1. If the system of sufficiently big in a domain D 
subsets is a filter, then a (strong) partial simplification Oracle M 
in the domain D for an automaton T, which is a (strong) partial 
simplification Oracle in the domain D for an automaton A, is 
a(strong) partial simplification Oracle in the domain D for the 
automaton A. 
Corollary 2. If the system of sufficiently big in a domain D 
subsets is a set ideal, then a (strong) partial simplification Oracle 
M in the domain D for an automaton T, which is a (strong) partial 
simplification Oracle in the domain D for an automaton A, is 
a(strong) partial simplification Oracle in the domain D for the 
automaton A. 
Corollary 3. If the system of sufficiently big in a domain D 
subsets is a set algebra, then a (strong) partial simplification 
Oracle M in the domain D for an automaton T, which is a (strong) 
partial simplification Oracle in the domain D for an automaton A, 
is a(strong) partial simplification Oracle in the domain D for the 
automaton A. 
Proposition 3. If E  D and the automaton M is a total 
simplification Oracle in the domain D for an automaton A, then 
the automaton M is a total simplification Oracle in the domain E 
for the automaton A. 
Remark 2. For partial simplification oracles, Proposition 3 is not 
always true. 
However, under additional conditions, a weaker counterpart of 
Proposition 2 becomes valid for partial simplification oracles.  
Proposition 4. If the system of sufficiently big in a domain D 
subsets satisfies Condition I, E  D, bD(E) is true and M is a 
partial simplification Oracle in the domain D for an automaton T, 
then the automaton M is a total simplification Oracle in some 
sufficiently big subset H of the set E for the automaton T. 
Lemma 1 and Proposition 4 imply the following result. 
Corollary 4. If the system of sufficiently big in D subsets satisfies 
Condition I, E  D, the predicate bD(E) is true and M is a partial 
simplification Oracle in the domain D for an automaton T, then 
the automaton M is a partial simplification Oracle in some 
sufficiently big subset H of the set E for the automaton T. 
Corollary 5. If the system of sufficiently big in a domain D 
subsets is a filter, E  D, the predicate bD(E) is true and M is a 
partial simplification Oracle in the domain D for an automaton T, 
then the automaton M is a partial simplification Oracle in some 
sufficiently big subset H of the set E for the automaton T. 
Corollary 6. If the system of sufficiently big in a domain D 
subsets is a set ideal, E  D, the predicate bD(E) is true and M is 
a partial simplification Oracle in the domain D for an automaton 
T, then the automaton M is a partial simplification Oracle in some 
sufficiently big subset H of the set E for the automaton T. 
Corollary 7. If the system of sufficiently big in a domain D 
subsets is a set algebra, E  D, the predicate bD(E) is true and M 
is a partial simplification Oracle in the domain D for an 
automaton T, then the automaton M is a partial simplification 
Oracle in some sufficiently big subset H of the set E for the 
automaton T. 
Defining simplification oracles, we considered an arbitrary 
complexity function c. Now let us study simplification oracles for 
some important complexity functions, such as time complexity, 
space complexity and operational complexity.  
Definition 4. A simplification Oracle M is called:  
a) 
A temporal Oracle if c is time complexity; 
b) 
A space Oracle if c is space complexity; 
c) 
An operational Oracle if c is operational complexity. 
Note that for Turing machines, time complexity and operational 
complexity (which counts the number of performed operations) 
coincide. Consequently, Turing machines as operational oracles 
are also temporal oracles and vice versa. 
It is interesting that a temporal Oracle M for T, like oracles from 
the Greek mythology, can predict future events for T being able to 
compute these events faster than T comes to them. 
Example 7. It is proved in (Burgin, 1999) that inductive Turing 
machines can serve as temporal oracles for Turing machines. 
Proposition 5. If similar operations in machines M and T need the 
same time and M is an operational Oracle in the domain D for T, 
then M is a temporal Oracle in the domain D for T. 
Now let us consider augmentation oracles. 
Definition 5. An automaton M is an augmentation Oracle in a 
domain D for an automaton T if the following condition is 
satisfied. 
zDxD( T(x)!!M(x)!!&(T(z)!!) &M(z)!! ) 
Here the expression A(x)!! means that processing input x by the 
automaton A {M, T} is tractable. 
Proposition 6. If an automaton M is an augmentation Oracle in a 
domain D for an automaton T and the automaton T is an 
augmentation Oracle in a domain D for an automaton A, then the 
automaton M is an augmentation Oracle in a domain D for an 
automaton T. 
Proposition 6 means that the relation “to be an augmentation 
Oracle” is transitive. 
Definition 6. An automaton M is an essential augmentation 
Oracle in a domain D for an automaton T if the following 
condition is satisfied: 
CD (bD(C)) zCxD (T(x)!! M(x)!! &(T(z)!!) &M(z)!!) 
Note that any essential augmentation Oracle is an augmentation 
Oracle. 
Remark 3. In some cases, simplification oracles are also 
augmentation oracles. 
Remark 4. For essential augmentation oracles, Proposition 1 is 
not always true. 
However, under additional conditions, Proposition 2 becomes 
valid for essential augmentation oracles. 
 Proposition 7. If the system of sufficiently big in D subsets 
satisfies Condition I, then an essential augmentation Oracle M in 
the domain D for an automaton T, which is an essential 
augmentation Oracle in the domain D for an automaton A, is an 
essential augmentation Oracle in the domain D for the automaton 
A. 

Corollary 8. If the system of sufficiently big in a domain D 
subsets is a filter, then an essential augmentation Oracle M in the 
domain D for an automaton T, which is an essential augmentation 
Oracle in the domain D for an automaton A, is an essential 
augmentation Oracle in the domain D for the automaton A. 
Corollary 9. If the system of sufficiently big in a domain D 
subsets is a set ideal, then an essential augmentation Oracle M in 
the domain D for an automaton T, which is an essential 
augmentation Oracle in the domain D for an automaton A, is an 
essential augmentation Oracle in the domain D for the automaton 
A. 
Corollary 10. If the system of sufficiently big in a domain D 
subsets is a set algebra, then an essential augmentation Oracle M 
in the domain D for an automaton T, which is an essential 
augmentation Oracle in the domain D for an automaton A, is an 
essential augmentation Oracle in the domain D for the automaton 
A. 
Definition 7. An automaton M is a total augmentation Oracle in a 
domain D for an automaton T if the following condition is 
satisfied 
CD ( bD(C)) zCxD ( T(x)!! M(x)!! &(T(z)!!) &M(z)!! 
)xD ((T(x)!!) &M(x)!!) 
We saw that the relation “to be a total simplification Oracle” is 
transitive (cf. Proposition 1). In contrast to this, total 
augmentation oracles have, in some sense, the opposite property 
as the following results demonstrate.   
Proposition 8. If an automaton M is a total augmentation Oracle 
in the domain D for an automaton T, then there are no 
augmentation oracles in the domain D for M. 
Because any total augmentation Oracle is an essential 
augmentation Oracle and any essential augmentation Oracle is an 
augmentation Oracle, we have the following results. 
Corollary 11. If an automaton M is a total augmentation Oracle in 
the domain D for an automaton T, then there are no essential 
augmentation oracles in the domain D for M. 
Corollary 12. If an automaton M is a total augmentation Oracle in 
the domain D for an automaton T, then there are no total 
augmentation oracles in the domain D for M. 
However, some automata have many different total augmentation 
oracles, essential augmentation oracles and augmentation oracles. 
Proposition 9. If E  D and an automaton M is a total 
augmentation Oracle in the domain D for an automaton A, then 
the automaton M is a total augmentation Oracle in the domain E 
for an automaton A. 
Now let us study extension oracles. 
Definition 8. An automaton M is an extension Oracle in a domain 
D for an automaton T if the following condition is satisfied 
zDxD ( T(x)! M(x)! &(T(z)!) &M(z)!) 
Lemma 3. Any extension Oracle in a domain D for an automaton 
T is also an augmentation Oracle in a domain D for an automaton 
T. 
Proposition 10. If an automaton M is an extension Oracle in a 
domain D for an automaton T and the automaton T is an extension 
Oracle in a domain D for an automaton A, then the automaton M 
is an extension Oracle in a domain D for the automaton A. 
Proposition 9 means that the relation “to be an extension Oracle” 
is transitive. 
Definition 9. An automaton M is an essential extension Oracle in 
a domain D for an automaton T if the following condition is 
satisfied 
CD ( bD(C)) zCxD ( T(x)! M(x)! &(T(z)!) &M(z)! )  
Proposition 11. If the system of sufficiently big in D subsets 
satisfies Condition I, then an essential extension Oracle M in the 
domain D for an automaton T, which is an essential extension 
Oracle in the domain D for an automaton A, is an essential 
extension Oracle in the domain D for the automaton A. 
Corollary 13. If the system of sufficiently big in a domain D 
subsets is a filter, then an essential extension augmentation Oracle 
M in the domain D for an automaton T, which is an essential 
augmentation Oracle in the domain D for an automaton A, is an 
essential augmentation Oracle in the domain D for an automaton 
A. 
Corollary 14. If the system of sufficiently big in a domain D 
subsets is a set ideal, then an essential extension Oracle M in the 
domain D for an automaton T, which is an essential extension 
Oracle in the domain D for an automaton A, is an essential 
extension Oracle in the domain D for an automaton A. 
Corollary 15. If the system of sufficiently big in a domain D 
subsets is a set algebra, then an essential extension augmentation 
Oracle M in the domain D for an automaton T, which is an 
essential extension augmentation Oracle in the domain D for an 
automaton A, is an essential extension Oracle in the domain D for 
an automaton A. 
Definition 10. An automaton M is a total extension Oracle ina 
domain D for an automaton T if the following condition is 
satisfied 
xD ((T(x)!) &M(x)!) 
Properties of total extension augmentation oracles are similar to 
properties of total augmentation oracles as the following results 
demonstrate.   
Proposition 12. If an automaton M is a total extension 
augmentation Oracle in the domain D for an automaton T, then 
there are no extension oracles in the domain D for M. 
Because any total extension Oracle is an essential extension 
Oracle and any essential extension Oracle is an extension Oracle, 
we have the following results. 
Corollary 16. If an automaton M is a total extension Oracle in the 
domain D for an automaton T, then there are no essential 
extension oracles in the domain D for M. 
Corollary 17. If an automaton M is a total extension Oracle in the 
domain D for an automaton T, then there are no total extension 
oracles in the domain D for M. 
In the next section, we introduce the DIME network architecture 
(DNA) presented in the Turing Centenary Conference [9, 10, 11, 
12, 13, 14] that has successfully used the concept of an Oracle to 
implement self-repair, auto-scaling and live-migration with 

transaction consistency of computational workflows. In this paper, 
we model the DIME networks using Grid Automata with Oracles 
and discuss a framework for analyzing DNA. 
 
 
Figure 1. A Web Application with Apache, Tomcat and MySQL 
delivering a transaction workflow is managed by Oracles at component 
level and at group level with a self-identity, intent, and process knowledge 
to configure, monitor and maintain the resources and the workflow intent. 
 
3. DIME NETWORK ARCHITECTURE 
DNA extends the conventional computational model of 
information processing networks, allowing improvement of the 
efficiency, scaling and resiliency of computational processes by 
utilization of appropriate Oracles. This approach is based on 
organizing the process dynamics under the supervision of 
intelligent agents that, knowing the intent of the underlying 
process, is able to optimize its execution. DNA utilizes the DIME 
(Distributed Intelligent Managed Element) computing model with 
non-von Neumann parallel implementation of managed automata 
from a definite class, such as Turing machines or inductive Turing 
machines, with a signaling network overlay adding cognitive 
elements to evolve super recursive information processing, for 
which it is proved that they improve efficiency and power of 
computational processes [8, 13, 14, 15, 16].  
As discussed in [16], the DIME network architecture 
introduces three key functional constructs to enable process 
design, execution and management to improve both resiliency and 
efficiency of computing networks: 
1. 
Machines with an Oracle 
2. 
Blue-print or policy managed fault, configuration, 
accounting, performance and security monitoring and 
control 
3. 
DIME network management control overlay over the 
managed machines with an Oracle, such as Turing 
Oracle machines or inductive Turing Oracle machines 
While executing an algorithm, the DIME basic processor P 
performs the {read  compute  write} instruction cycle or its 
modified version the {interact with external agent  read  
compute  interact with external agent  write} instruction 
cycle. This allows the external agent to influence the further 
evolution of computation, while the computation is still in 
progress. Three types of agents can modify the evolution of the 
computation:  
(a) A DIME agent. 
(b) A human agent. 
(c) An external computing agent. 
Figure 1 shows an implementation of the DNA to infuse self-
management to a web application using Apache, Tomcat and 
MySQL database [15]. 
In the next section, we model the DNA using Grid Automata with 
Oracles. 
4. MODELING DIME NETWORKS USING 
GRID AUTOMATA WITH ORACLES 
In the context of grid automata, a DIME network is represented by 
a grid automaton with such nodes as DIME units, servers, routers, 
etc. Each DIME unit is modeled by a basic automaton A with an 
Oracle O. The automaton A models the DIME basic processor P, 
while the Oracle O models the DIME agent (DA). Turing 
machines with Oracles, inductive Turing machines with Oracles, 
limit Turing machines with Oracles [8] and evolutionary Turing 
machines [17, 18] are examples of such an automaton A with an 
Oracle O. Note that here Oracle has a much broader meaning than 
the Turing Oracle. 
The Oracle O in a DIME unit knows the intent of the algorithm 
(along with the context, constraints, communications and control 
of the algorithm) the basic automaton A is executing under its 
influence and has the visibility of available resources and the 
needs of the automaton A as it executes its function. In addition, 
the DIME Oracle also has the knowledge about alternate courses 
of action available to facilitate the evolution of the computation to 
achieve its intent. Thus, every algorithm is associated with a 
blueprint (analogous to a genetic specification in biology), which 
can provide the knowledge required by an Oracle to manage its 
evolution. 
In addition to read/write communication of the basic automaton 
(the data channel), the Oracles manage different basic automata 
communicating with each other using a parallel signaling channel. 
This allows the external Oracles to influence the computation of 
any managed basic automaton in progress based on the context 
and constraints just what a managing Oracle is expected to do.  
The Oracle uses the blueprint to configure, instantiate, and 
manage the automaton A executing the algorithm. Utilization of 
concurrent automata in the network with their own blueprints 
specifying their evolution to monitor the vital signs of the DIME 
basic automaton and to implement various policies allows the 
Oracle to assure non-functional requirements such as availability, 
performance, security and cost management, while the managed 
DIME basic automaton is executing its task to achieve its goal and 
realize its intent. 
The external Oracles represent DIME agents, allowing changes in 
one computing element influence the evolution of another 
computing element at run time without stopping its basic 
automaton executing the algorithm. The signaling channel and the 
network of the Oracles can be programmed to execute a process 
whose intent itself can be specified in a blueprint. Each basic 
automaton can have its own Oracle managing its intent, and 
groups of managed basic automata can have their own domain 
managers implementing the domain’s intent to execute a process. 
The management Oracles specify, configure and manage the sub-
network of DIMEs by monitoring and executing policies to 

optimize the resources while delivering the intent. The DIME 
network implementing the Oracles is itself managed by 
monitoring its own vital signs and executing various FCAPS 
(fault, configuration, accounting, performance and security) 
policies to assure availability, performance and security. 
A DIME Oracle is modeled by an abstract automaton that has 
higher 
computational 
power 
and/or 
lower 
computational 
complexity than the basic automaton it manages. For instance, the 
Oracle can be an inductive Turing machine, while the basic 
automaton is a conventional Turing machine. It is proved that 
inductive Turing machines have much higher computational 
power and lower complexity than conventional Turing machine 
[8]. 
DIME agents possess a possibility to infer new data and 
knowledge from the given information. Inference is one of the 
driving principles of the Semantic Web, because it will allow us 
to create software applications quite easily. For the Semantic Web 
applications, DIME agents need high expressive power to help 
users in a wide range of situations. To achieve this, they employ 
powerful logical tools for making inferences. Inference abilities of 
DIME agents are developed based on mathematical models of 
these agents in the form of inductive Turing machines, limit 
Turing machines [17] and evolutionary Turing machines [18, 19]. 
Figure 1 shows a workflow DNA of a web application running on 
a physical infrastructure that has policies to manage auto-failover 
by moving the components when the vital signs being monitored 
at various levels are affected. For example if the virtual machine 
in the middle server fails, the service manager at higher level 
detects it and replicates the components in another server on the 
right and synchronizes the states of the components based on 
consistency policies. 
5. CONCLUSION 
While answering the question "Chicken or the egg, which came 
first?" it is said [20] that the chicken is an egg's way of making 
another egg (or we can say replicating itself). The genes in the egg 
are programmed to replicate themselves using the resources 
available effectively. They already come with an "intent", the 
workflows to execute the intent and monitoring and controlling 
best practices to adjust the course if deviations occur, whether 
they be from fluctuations in resources or the impact of its 
interaction with the environment. The intent of the genes, it 
seems, is the ability to survive and replicate. There is a symbiosis 
of the genes (which contain the information about the intent, 
workflows and also process knowledge to execute the intent) and 
the hardware in the form of chemicals such as amino acids and 
proteins that provide the means. 
A similar symbiosis exists between the software and hardware 
involved in a computation. It can be equally said that the 
hardware is software's means of sustaining itself to deliver its 
intent. The hardware provides the metabolism (here we use the 
word metabolism loosely to denote the resources required to 
execute the algorithm following Dyson [20]) to maintain the vital 
signs of the software (in the form of CPU cycles, memory, 
network bandwidth, latency, storage capacity, IOPs and 
throughput). The software contains the algorithms to deliver the 
intent. In the current state of the art of computations, the software 
is not aware of its vital signs and the hardware is not aware of the 
software's intent. They are brought together by external agents 
who know the intent (functional requirements) and also know the 
hardware capabilities to match them, monitor the vital signs (non-
functional requirements) and adjust the circumstance to meet 
changing demands. When the hardware resources are distributed 
and shared by multiple software algorithms with different intents 
and different “metabolic” rates, the agents that mediate grow 
exponentially increasing both complexity and management 
fatigue. The problems are compounded when both the scale and 
fluctuations in the system increase. In order to understand the 
reason behind this complexity and resulting inefficiency, we have 
to go back to the software origins. 
The software and hardware symbiosis can be said to start from the 
simple theory of Turing machine which was created [5] by 
“replacing the man in the process of computing a real number by a 
machine which is capable of only a finite number of conditions.” 
Turing machine is a hypothetical device that manipulates symbols 
on a strip of tape according to a table of rules. Despite its 
simplicity, a Turing machine can be adapted to simulate the logic 
of any computer algorithm, and is particularly useful in explaining 
the functions of a CPU inside a computer. In its essence, the 
Turing machine consists of a repeated algorithm of “Read-
Compute-Write” cycle until the algorithm reaches its end or stops. 
This simple model combined with John von Neumann’s stored 
program implementation has become the driver behind current 
information processing revolution. As George Dyson explains, 
intelligence is replaced by patience and the algorithm defines the 
intent and the process dynamics to fulfill the intent [20]. 
However, the algorithm has no way to fulfill its intent till it is 
placed in an environment where the metabolism is imbued to 
execute it. While the stored program implementation of the Turing 
machine provides the metabolism, the model assumes that 
adequate energy is available for the algorithm to complete its task 
or it is halted. As Cockshott et al., [21] point out “The key 
property of general-purpose computer is that they are general 
purpose. We can use them to deterministically model any physical 
system, of which they are not themselves a part, to an arbitrary 
degree of accuracy. Their logical limits arise when we try to get 
them to model a part of the world that includes themselves.”  
DNA and the Grid Automata with Oracles are an attempt to 
include self-awareness and self-management by defining the 
intent and process flows of evolving the computation but also the 
knowledge to configure, monitor and control the process 
dynamics to execute the computation under self-supervision to 
accomplish its goal. 
The goals of the distributed system determine the resource 
requirements and computational process definition of individual 
service components based on their priorities, workload 
characteristics and latency constraints. The overall system 
resiliency, efficiency and scalability depend upon the individual 
service component workload and latency characteristics of their 
interconnections that, in turn depend on the placement of these 
components (configuration) and available resources. The 
resiliency (fault, configuration, accounting, performance and 
security often denoted by FCAPS) is measured with respect to a 
service’s tolerance to faults, fluctuations in contention for 
resources, performance fluctuations, security threats and changing 
system-wide priorities.  Efficiency depicts the optimal resource 
utilization.  Scaling addresses end-to-end distributed resource 
provisioning and management with respect to increasing the 
number of computing elements required to meet service needs. 
Current state of the art “chains” the applications to the myriad 
distributed infrastructure management systems with a plethora of 

API; tries to guess what the application needs are; and attempts to 
orchestrate the infrastructure to meet the changing needs. This 
reactive approach fails to meet the on-demand need for resource 
optimization when scale and fluctuations increase. The new 
approach with DNA “unchains” the applications and decouples 
them from being dependent on myriad intermediaries attempting 
to guess their behavior and act. The infusion of self-identity, self-
awareness, self-monitoring, self-protection, and self-optimization 
using global visibility and local control using Oracles and super 
recursive algorithms. This is made possible by addressing the real 
distributed computing limitation discussed by Cockshott et al., 
[21] using the super recursive algorithms proposed by Mark 
Burgin [8]. The solution is based on the extensions of the Turing 
machine implementation of von Neumann serial stored program 
control discussed in the scientific literature during the past six 
years including the Turing Centenary Conference proceedings in 
2012. 
George Dyson [20] speculates on the decoupling of hardware 
infrastructure (providing “metabolism”) and its management, from 
the software executing specific processes with an intent and its 
replication capability: 
“Metabolism and replication, however intricately they 
may be linked in the biological world as it now exists, 
are logically separable. It is logically possible to 
postulate organisms that are composed of pure hardware 
and capable of metabolism but incapable of replication. 
It is also possible to postulate organisms that are 
composed of pure software and capable of replication 
but incapable of metabolism.” 
The DIME network architecture implementation and the theory of 
extended Oracles with application to distributed computing 
networks are baby steps in expanding our understanding of 
cognitive distributed computing. Future work will attempt to test 
the theory with various implementations of self-managing 
distributed systems using DIME network architecture and 
comparing them to other methods. However, their power is 
already evident in the demonstration of database replication and 
live-migration with transaction consistency across physical 
infrastructure extending the current state of the art in distributed 
computing. 
The 
efficiency, 
resiliency 
and 
scaling 
are 
demonstrated in the elimination of myriad intermediaries 
including Virtual Machines and various orchestrators of 
distributed infrastructure. 
6. REFERENCES 
 
[1] Burgin M. and Mikkilineni R. ‘Semantic Network 
Organization based on Distributed Intelligent Managed 
Elements’, In Proceeding of the 6th International Conference 
on Advances in Future Internet, Lisbon, Portugal, pp. 16-20, 
2014. 
[2] I. Corp., “An architectural blueprint for autonomic 
computing,” Tech. Rep. 
http://www306.ibm.com/autonomic/pdfs/ACwpFinal.pdf, 
2004. 
[3] Gödel, K. Über formal unentscheidbare Sätze der Principia 
Mathematics und verwandter System I, Monatshefte für 
Mathematic und Physik, 38, 173-198, 1931 
[4] Turing, A. M. Systems of logic defined by ordinals. Proc. 
Lond. Math. Soc., Ser. 2, 45, pp. 161-228, 1939. 
[5] Turing, A. M. In B. J. Copeland (Ed.), The Essential Turing. 
Oxford, UK: Oxford University Press, 2004. 
[6] Feferman, S. Turing’s Thesis. Notices of the AMS, 53(10), 2, 
2006. 
[7] Balcazar, J.L., Diaz, J., and Gabarro, J. Structural 
Complexity, Springer-Verlag, Berlin/Heidelberg/ New York, 
1988. 
[8] Burgin M. Super-recursive Algorithms, New York, Springer, 
2005. 
[9] Mikkilineni R. Designing a new class of distributed systems. 
New York: Springer, 2011. 
[10] Mikkilineni R., Morana G. and Seyler I. Implementing 
distributed, self-Managing computing services infrastructure 
using a scalable, parallel and network-centric computing 
model, In Villari et al (Eds.), Achieving Federated and Self-
Manageable Cloud Infrastructures: Theory and Practice, pp. 
57-78, 2013. 
[11] Mikkilineni R., Morana G., Zito D., and Di Sano M. Service 
Virtualization 
Using 
a 
Non-von 
Neumann 
Parallel, 
Distributed, and Scalable Computing Model, Journal of 
Computer 
Networks 
and 
Communications 
[online], 
www.hindawi.com/journals/jcnc/2012/604018/ (accessed on 
3 February 2015) 
[12] Mikkilineni, R. Going beyond Computation and Its Limits: 
Injecting Cognition into Computing, Applied Mathematics, 
Vol. 3, No. 11A, pp. 1826-1835, 2012. 
[13] Mikkilineni, R., Comparini, A. and Morana, G. The Turing 
O-machine and the DIME Network Architecture: Injecting 
the Architectural Resiliency into Distributed Computing, In 
Turing-100, The Alan Turing Centenary, EasyChair 
Proceedings in Computing, 2012.   
 www.easychair.org/publications/?page=877986046 
(accessed on 3 February 2015)  
[14] Mikkilineni, R. and Morana, G. Infusing cognition into 
distributed computing: A new approach to distributed 
datacenters with self-managing services, In Proceeding of the 
23rd 
IEEE 
International 
Conference 
on 
Enabling 
Technologies: Infrastructure for Collaborative Enterprises, 
Parma, Italy, pp. 131-136, 2014. 
[15] Burgin, M. Mikkilineni, R and Morana, G. 2015. Intelligent 
Organization of Semantic Networks, DIME Network 
Architecture and Grid Automata, to appear in the Journal of 
Embedded Systems, July 2015. 
[16] Burgin M., Mikkilineni M. and Morana G. From Personal 
Computers to Personal Computing Networks: A New 
Paradigm for Computation, In proceeding of FUTURE 
COMPUTING 2015, The Seventh International Conference 
on Future Computational Technologies and Applications, pp-
24-30, 2015. 
[17] Burgin M. and Eberbach E. On foundations of evolutionary 
computation: an evolutionary automata approach, in 
Hongwei Mo (Eds.), Handbook of Research on Artificial 
Immune Systems and Natural Computing: Applying 
Complex Adaptive Technologies, IGI Global, Hershey, 
Pennsylvania, pp. 342-360, 2009. 
[18] Burgin M. and Eberbach E. Evolutionary Automata: 
Expressiveness 
and 
Convergence 
of 
Evolutionary 

Computation, Computer Journal, Vol. 55, No. 9 pp. 1023-
1029, 2012. 
[19] Burgin M. Reflexive Calculi and Logic of Expert Systems, in 
Creative processes modeling by means of knowledge bases, 
pp. 139-160, 1992. 
[20] Dyson, G. The Darwin Among the Machines: The evolution 
of Global Intelligence, Basic Books, New York, 1997. 
[21] P. Cockshott, L. M. MacKenzie and G. Michaelson, 
Computation and Its Limits, Oxford University Press, 
Oxford, 2012. 
  
 

