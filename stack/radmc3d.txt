radmc3d
Release 2.0
Cornelis Dullemond
Aug 29, 2020


CONTENTS
1
Introduction
1
1.1
What is RADMC-3D? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Capabilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.3
Version tracker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.4
Copyright . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.5
Contributing authors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.6
Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
2
Quickstarting with RADMC-3D
5
3
Overview of the RADMC-3D package
7
3.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
3.2
Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
3.3
Contents of the RADMC-3D package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3.3.1
RADMC-3D package as a .zip archive . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3.3.2
RADMC-3D package from the github repository
. . . . . . . . . . . . . . . . . . . . . . .
8
3.3.3
Contents of the package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.4
Units: RADMC-3D uses CGS units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
4
Installation of RADMC-3D
11
4.1
Compiling the code with ‚Äòmake‚Äô . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
4.2
The install.perl script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
4.3
What to do if this all does not work? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
4.4
Installing the simple Python analysis tools
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
4.4.1
How to install and use the python/radmc3d_tools/
. . . . . . . . . . . . . . . . . .
14
4.4.2
How to install and use the python/radmc3dPy library
. . . . . . . . . . . . . . . . . .
15
4.5
Making special-purpose modiÔ¨Åed versions of RADMC-3D (optional) . . . . . . . . . . . . . . . . .
15
5
Basic structure and functionality
17
5.1
Basic dataÔ¨Çow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
5.2
Radiative processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
5.3
Coordinate systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
5.4
The spatial grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
5.5
Computations that RADMC-3D can perform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
5.6
How a model is set up and computed: a rough overview
. . . . . . . . . . . . . . . . . . . . . . . .
23
5.7
Organization of model directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
5.8
Running the example models
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
6
Dust continuum radiative transfer
27
6.1
The thermal Monte Carlo simulation: computing the dust temperature . . . . . . . . . . . . . . . . .
27
6.1.1
ModiÔ¨Åed Random Walk method for high optical depths . . . . . . . . . . . . . . . . . . . .
28
i

6.2
Making SEDs, spectra, images for dust continuum . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
6.3
OpenMP parallelized Monte Carlo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
6.4
Overview of input data for dust radiative transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
6.5
Special-purpose feature: Computing the local radiation Ô¨Åeld . . . . . . . . . . . . . . . . . . . . . .
31
6.6
More about scattering of photons off dust grains
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
6.6.1
Five modes of treating scattering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
6.6.2
Scattering phase functions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
6.7
Scattering of photons in the Thermal Monte Carlo run . . . . . . . . . . . . . . . . . . . . . . . . .
35
6.8
Scattering of photons in the Monochromatic Monte Carlo run . . . . . . . . . . . . . . . . . . . . .
35
6.8.1
Scattered light in images and spectra: The ‚ÄòScattering Monte Carlo‚Äô computation . . . . . .
36
6.8.2
Single-scattering vs. multiple-scattering . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
6.8.3
SimpliÔ¨Åed single-scattering mode (spherical coordinates) . . . . . . . . . . . . . . . . . . .
39
6.8.4
Warning when using an-isotropic scattering . . . . . . . . . . . . . . . . . . . . . . . . . .
39
6.8.5
For experts: Some more background on scattering . . . . . . . . . . . . . . . . . . . . . . .
39
6.9
Polarization, Stokes vectors and full phase-functions . . . . . . . . . . . . . . . . . . . . . . . . . .
40
6.9.1
DeÔ¨Ånitions and conventions for Stokes vectors . . . . . . . . . . . . . . . . . . . . . . . . .
41
6.9.2
Our conventions compared to other literature
. . . . . . . . . . . . . . . . . . . . . . . . .
43
6.9.3
DeÔ¨Åning orientation for non-observed radiation . . . . . . . . . . . . . . . . . . . . . . . .
44
6.9.4
Polarized scattering off dust particles: general formalism . . . . . . . . . . . . . . . . . . .
45
6.9.5
Polarized scattering off dust particles: randomly oriented particles . . . . . . . . . . . . . .
46
6.9.6
Scattering and axially symmetric models . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.10
More about photon packages in the Monte Carlo simulations . . . . . . . . . . . . . . . . . . . . . .
48
6.11
Polarized emission and absorption by aligned grains . . . . . . . . . . . . . . . . . . . . . . . . . .
48
6.11.1
Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
6.11.2
Implementation in RADMC-3D
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
6.11.3
Consistency with other radiative processes . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
6.11.4
Input Ô¨Åles for RADMC-3D for aligned grains . . . . . . . . . . . . . . . . . . . . . . . . .
53
6.11.5
Effect of aligned grains on the scattering . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
7
Line radiative transfer
57
7.1
Quick start for adding line transfer to images and spectra . . . . . . . . . . . . . . . . . . . . . . . .
57
7.2
Some deÔ¨Ånitions for line transfer
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
7.3
Line transfer modes and how to activate the line transfer . . . . . . . . . . . . . . . . . . . . . . . .
58
7.3.1
Two different atomic/molecular data Ô¨Åle types . . . . . . . . . . . . . . . . . . . . . . . . .
59
7.3.2
The different line modes (the lines_mode parameter) . . . . . . . . . . . . . . . . .
59
7.4
The various input Ô¨Åles for line transfer
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
7.4.1
INPUT: The line transfer entries in the radmc3d.inp Ô¨Åle . . . . . . . . . . . . . . . . . . . .
60
7.4.2
INPUT: The line.inp Ô¨Åle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
7.4.3
INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s) . . . . . . . . . . . . . . . .
62
7.4.4
INPUT: Molecular/atomic data: The linelist_XXX.inp Ô¨Åle(s) . . . . . . . . . . . . . . . . .
65
7.4.5
INPUT: The number density of each molecular species . . . . . . . . . . . . . . . . . . . .
66
7.4.6
INPUT: The gas temperature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
7.4.7
INPUT: The velocity Ô¨Åeld
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
7.4.8
INPUT: The local microturbulent broadening (optional) . . . . . . . . . . . . . . . . . . . .
67
7.4.9
INPUT for LTE line transfer: The partition function (optional) . . . . . . . . . . . . . . . .
67
7.4.10
INPUT: The number density of collision partners (for non-LTE transfer) . . . . . . . . . . .
68
7.5
Making images and spectra with line transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
7.5.1
Speed versus realism of rendering of line images/spectra . . . . . . . . . . . . . . . . . . .
69
7.5.2
Line emission scattered off dust grains . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
7.6
Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method . . .
70
7.7
Non-LTE Transfer: The optically thin line assumption method . . . . . . . . . . . . . . . . . . . . .
73
7.8
Non-LTE Transfer: Full non-local modes (FUTURE) . . . . . . . . . . . . . . . . . . . . . . . . . .
73
7.9
Non-LTE Transfer: Inspecting the level populations
. . . . . . . . . . . . . . . . . . . . . . . . . .
73
7.10
Non-LTE Transfer: Reading the level populations from Ô¨Åle . . . . . . . . . . . . . . . . . . . . . . .
74
ii

7.11
What can go wrong with line transfer? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
7.12
Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô . . . . . . . . . . . . . . . . . . . . . . .
76
7.13
Background information: Calculation and storage of level populations . . . . . . . . . . . . . . . . .
78
7.14
In case it is necessary: On-the-Ô¨Çy calculation of populations . . . . . . . . . . . . . . . . . . . . . .
79
7.15
For experts: Selecting a subset of lines and levels ‚Äòmanually‚Äô . . . . . . . . . . . . . . . . . . . . . .
80
8
Making images and spectra
81
8.1
Basics of image making with RADMC-3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
8.2
Making multi-wavelength images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
8.3
Making spectra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
8.3.1
What is ‚Äòin the beam‚Äô when the spectrum is made?
. . . . . . . . . . . . . . . . . . . . . .
86
8.3.2
Can one specify more realistic ‚Äòbeams‚Äô? . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
8.4
Specifying custom-made sets of wavelength points for the camera . . . . . . . . . . . . . . . . . . .
87
8.4.1
Using lambdarange and (optionally) nlam . . . . . . . . . . . . . . . . . . . . . . . . .
87
8.4.2
Using allwl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
8.4.3
Using loadcolor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
8.4.4
Using loadlambda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
8.4.5
Using iline, imolspec etc (for when lines are included) . . . . . . . . . . . . . . . . .
88
8.5
Heads-up: In reality wavelength are actually wavelength bands
. . . . . . . . . . . . . . . . . . . .
88
8.5.1
Using channel-integrated intensities to improve line channel map quality . . . . . . . . . . .
89
8.6
The issue of Ô¨Çux conservation: recursive sub-pixeling
. . . . . . . . . . . . . . . . . . . . . . . . .
89
8.6.1
The problem of Ô¨Çux conservation in images . . . . . . . . . . . . . . . . . . . . . . . . . .
89
8.6.2
The solution: recursive sub-pixeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
8.6.3
A danger with recursive sub-pixeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
8.6.4
Recursive sub-pixeling in spherical coordinates . . . . . . . . . . . . . . . . . . . . . . . .
91
8.6.5
How can I Ô¨Ånd out which pixels RADMC-3D is recursively reÔ¨Åning? . . . . . . . . . . . . .
92
8.6.6
Alternative to recursive sub-pixeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
8.7
Stars in the images and spectra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
8.8
Second order ray-tracing (Important information!) . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
8.8.1
Second order integration in spherical coordinates: a subtle issue
. . . . . . . . . . . . . . .
98
8.9
Circular images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98
8.10
Visualizing the ùúè= 1 surface
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8.11
For public outreach work: local observers inside the model . . . . . . . . . . . . . . . . . . . . . . . 102
8.12
Multiple vantage points: the ‚ÄòMovie‚Äô mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
9
More information about the gridding
107
9.1
Regular grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
9.2
Separable grid reÔ¨Ånement in spherical coordinates (important!)
. . . . . . . . . . . . . . . . . . . . 108
9.3
Oct-tree Adaptive Mesh ReÔ¨Ånement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
9.4
Layered Adaptive Mesh ReÔ¨Ånement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
9.4.1
On the ‚Äòsuccessively regular‚Äô kind of data storage, and its slight redundancy . . . . . . . . . 113
9.5
Unstructured grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
9.6
1-D Plane-parallel models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
9.6.1
Making a spectrum of the 1-D plane-parallel atmosphere . . . . . . . . . . . . . . . . . . . 115
9.6.2
In 1-D plane-parallel: no star, but incident parallel Ô¨Çux beams
. . . . . . . . . . . . . . . . 115
9.6.3
Similarity and difference between 1-D spherical and 1-D plane-parallel
. . . . . . . . . . . 116
9.7
Thermal boundaries in Cartesian coordinates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
10 More information about the treatment of stars
117
10.1
Stars treated as point sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
10.2
Stars treated as spheres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
10.3
Distributions of zillions of stars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
10.4
The interstellar radiation Ô¨Åeld: external source of energy . . . . . . . . . . . . . . . . . . . . . . . . 119
10.4.1
Role of the external radiation Ô¨Åeld in Monte Carlo simulations . . . . . . . . . . . . . . . . 119
iii

10.4.2
Role of the external radiation Ô¨Åeld in images and spectra . . . . . . . . . . . . . . . . . . . 120
10.5
Internal heat source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
10.5.1
Slow performance of RADMC-3D with heat source . . . . . . . . . . . . . . . . . . . . . . 120
11 Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes
123
11.1
Setting up a model inside of RADMC-3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
11.2
The pre-deÔ¨Åned subroutines of the userdef_module.f90 . . . . . . . . . . . . . . . . . . . . . . . . . 124
11.3
Some caveats and advantages of internal model setup . . . . . . . . . . . . . . . . . . . . . . . . . . 126
11.4
Using the userdef module to compute integrals of ùêΩùúà. . . . . . . . . . . . . . . . . . . . . . . . . . 127
11.5
Some tips and tricks for programming user-deÔ¨Åned subroutines
. . . . . . . . . . . . . . . . . . . . 127
11.6
Creating your own emission and absorption processes
. . . . . . . . . . . . . . . . . . . . . . . . . 128
12 Python analysis tool set
129
12.1
The simpleread.py library
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
12.2
The radmc3dPy library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
12.3
Model creation from within radmc3dPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
12.4
Diagnostic tools in radmc3dPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
12.4.1
Read the amr_grid.inp Ô¨Åle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
12.4.2
Read all the spatial data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
12.4.3
Read the image.out Ô¨Åle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
12.4.4
Read the spectrum.out Ô¨Åle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
13 Analysis tools inside of radmc3d
133
13.1
Making a regularly-spaced datacube (‚Äòsubbox‚Äô) of AMR-based models
. . . . . . . . . . . . . . . . 133
13.1.1
Creating and reading a subbox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
13.1.2
Format of the subbox output Ô¨Åles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.2
Alternative to subbox: arbitrary sampling of AMR-based models
. . . . . . . . . . . . . . . . . . . 134
14 Visualization with VTK tools (e.g. Paraview or VisIt)
137
15 Tips, tricks and problem hunting
141
15.1
Tips and tricks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
15.2
Bug hunting
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
15.3
Some tips for avoiding troubles and for making good models . . . . . . . . . . . . . . . . . . . . . . 142
15.4
Careful: Things that might go wrong
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
15.5
Common technical problems and how to Ô¨Åx them . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
16 Main input and output Ô¨Åles of RADMC-3D
147
16.1
INPUT: radmc3d.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
16.2
INPUT (required): amr_grid.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
16.2.1
Regular grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
16.2.2
Oct-tree-style AMR grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
16.2.3
Layer-style AMR grid
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
16.3
INPUT (required for dust transfer): dust_density.inp . . . . . . . . . . . . . . . . . . . . . . . . . . 156
16.3.1
Example: dust_density.inp for a regular grid . . . . . . . . . . . . . . . . . . . . . . 156
16.3.2
Example: dust_density.inp for an oct-tree reÔ¨Åned grid . . . . . . . . . . . . . . . . . 157
16.3.3
Example: dust_density.inp for a layer-style reÔ¨Åned grid . . . . . . . . . . . . . . . . 159
16.4
INPUT/OUTPUT: dust_temperature.dat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
16.5
INPUT (mostly required): stars.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
16.6
INPUT (optional): stellarsrc_templates.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
16.7
INPUT (optional): stellarsrc_density.inp
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
16.8
INPUT (optional): external_source.inp
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
16.9
INPUT (optional): heatsource.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
16.10 INPUT (required): wavelength_micron.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
16.11 INPUT (optional): camera_wavelength_micron.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
iv

16.12 INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or
dust_optnk_*.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
16.12.1 The dustopac.inp Ô¨Åle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
16.12.2 The dustkappa_*.inp Ô¨Åles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
16.12.3 The dustkapscatmat_*.inp Ô¨Åles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
16.13 OUTPUT: spectrum.out . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
16.14 OUTPUT: image.out or image_****.out
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
16.15 INPUT: (minor input Ô¨Åles) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
16.15.1 The color_inus.inp Ô¨Åle (required with comm-line option ‚Äòloadcolor‚Äô)
. . . . . . . . . 171
16.15.2 INPUT: aperture_info.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
16.16 For developers: some details on the internal workings
. . . . . . . . . . . . . . . . . . . . . . . . . 172
17 Binary I/O Ô¨Åles
173
17.1
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
17.2
How to switch to binary (or back to ascii) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
17.3
Binary I/O Ô¨Åle format of RADMC-3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
18 Command-line options
179
18.1
Main commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
18.2
Additional arguments: general . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
18.3
Switching on/off of radiation processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
19 Which options are mutually incompatible?
183
19.1
Coordinate systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
19.2
Scattering off dust grains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
19.3
Local observer mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
20 Acquiring opacities from the WWW
185
21 Version tracker: Development history
187
22 Indices and tables
195
v

vi

CHAPTER
ONE
INTRODUCTION
1.1 What is RADMC-3D?
RADMC-3D is a software package for astrophysical radiative transfer calculations in arbitrary 1-D, 2-D or 3-D ge-
ometries. It is mainly written for continuum radiative transfer in dusty media, but also includes modules for gas line
transfer. Typical applications would be protoplanetary disks, pre- and proto-stellar molecular cloud cores, and similar
objects. It does not treat photoionization of gas, nor does it treat chemistry. It can self-consistently compute dust
temperatures for the radiative transfer, but it is not equipped for self-consistent gas temperature computations (as this
requires detailed coupling to photochemistry). The main strength of RADMC-3D lies in the Ô¨Çexibility of the spatial
setup of the models: One can create or use parameterized dust and/or gas density distributions, or one can import these
from snapshots of hydrodynamic simulations.
1.2 Capabilities
Here is a list of current and planned features. Those features that are now already working are marked with [+], while
those which are not yet (!!) built in are marked with [-]. Those that are currently being developed are marked with [.]
and those that are ready, but are still in the testing phase are marked with [t].
1. Coordinate systems:
1. [+] Cartesian coordinates (3-D)
2. [+] Spherical coordinates (1-D, 2-D and 3-D)
1. Gridding systems (regular and adaptive mesh reÔ¨Ånement grids are available for cartesian and spherical coordi-
nates):
1. [+] Regular
2. [+] Adaptive Mesh ReÔ¨Ånement: oct-tree style
3. [+] Adaptive Mesh ReÔ¨Ånement: layered (‚Äòpatch‚Äô) style
4. [-] Voronoi gridding [To be implemented on request]
1. Radiation mechanisms:
1. [+] Dust continuum, thermal emission
2. [+] Dust continuum scattering:
1. [+] ...in isotropic approximation
2. [+] ...with full anisotropy
3. [+] ...with full Stokes and Polarization
1

radmc3d, Release 2.0
1. [-] Dust quantum heated grains [To be implemented on request]
2. [t] Polarized dust emission by aligned grains [Ô¨Årst test version]
3. [+] Gas line transfer (LTE)
4. [+] Gas line transfer (non-LTE: LVG)
5. [+] Gas line transfer (non-LTE: LVG + Escape Probability)
6. [-] Gas line transfer (non-LTE: full transfer)
7. [+] Gas line transfer with user-deÔ¨Åned populations
8. [+] Gas continuum opacity and emissivity sources
2. Radiation netto sources for continuum:
1. [+] Discrete stars positioned at will
2. [t] Continuous ‚Äòstarlike‚Äô source
3. [t] Continuous ‚Äòdissipation‚Äô source
4. [t] External ‚Äòinterstellar radiation Ô¨Åeld‚Äô
3. Imaging options:
1. [+] Observer from ‚ÄòinÔ¨Ånite‚Äô distance
2. [+] Zoom-in at will
3. [+] Flux-conserving imaging, i.e. pixels are recursively reÔ¨Åned
4. [+] A movie-making tool
5. [+] Multiple wavelengths in a single image
6. [+] Local observer with perspective view (for PR movies!)
4. Spectrum options:
1. [+] SED spectrum (spectrum on ‚Äòstandard‚Äô wavelength grid)
2. [+] Spectrum on any user-speciÔ¨Åed wavelength grid
3. [+] Spectrum of user-speciÔ¨Åed sub-region (pointing)
4. [t] SpeciÔ¨Åcation of size and shape of a primary ‚Äòbeam‚Äô for spectra
5. User Ô¨Çexibility:
1. [+] Free model speciÔ¨Åcation via tabulated input Ô¨Åles
2. [+] Easy special-purpose compilations of the code (optional)
6. Front-end Python packages:
1. [+] Python simple tools for RADMC-3D
2. [+] Python RADMC-3D library {smalltt radmc3dPy} (author: A. Juhasz)
7.
1. [+] Stars can be treated as point-sources or as spheres
2. [+] Option to calculate the mean intensity ùêΩùúà(‚Éóùë•) in the model
3. [+] OpenMP parallellization of the Monte Carlo
2
Chapter 1. Introduction

radmc3d, Release 2.0
1.3 Version tracker
The RADMC-3D software package in under continuous development. A very detailed development log-book is found
in the git repository. A more user-friendly overview of the development history can be found in this manual, in
appendix ref{chap-development-history}.
1.4 Copyright
RADMC-3D was developed from 2007 to 2010/2011 at the Max Planck Institute for Astronomy in Heidelberg, funded
by a Max Planck Research Group grant from the Max Planck Society. As of 2011 the development continues at the
Institute for Theoretical Astrophysics (ITA) of the Zentrum f√ºr Astronomy (ZAH) at the University of Heidelberg.
The use of this software is free of charge. However, it is not allowed to distribute this package without prior
consent of the lead author (C.P. Dullemond). Please refer any interested user to the web site of this software
where the package is available, which is currently:
http://www.ita.uni-heidelberg.de/~dullemond/software/radmc-3d
or the github repository:
https://github.com/dullemond/radmc3d-2.0
The github repository will always have the latest version, but it may not be always the most stable version (though
usually it is).
1.5 Contributing authors
The main author of RADMC-3D is Cornelis P. Dullemond. However, the main author of the radmc3dPy Python
package is Attila Juhasz.
Numerous people have made contributions to RADMC-3D. Major contributions are from:
‚Ä¢ Michiel Min
‚Ä¢ Attila Juhasz
‚Ä¢ Adriana Pohl
‚Ä¢ Rahul Shetty
‚Ä¢ Farzin Sereshti
‚Ä¢ Thomas Peters
‚Ä¢ Benoit Commercon
‚Ä¢ Alexandros Ziampras
The code proÔ¨Åted from testing, feedback and bug reports from (incomplete list):
‚Ä¢ Daniel Harsono
‚Ä¢ Rainer Rolffs
‚Ä¢ Laszlo Szucs
‚Ä¢ Sean Andrews
‚Ä¢ Stella Offner
1.3. Version tracker
3

radmc3d, Release 2.0
‚Ä¢ Chris Beaumont
‚Ä¢ Katrin Rosenfeld
‚Ä¢ Soren Frimann
‚Ä¢ Jon Ramsey
‚Ä¢ Seokho Lee
‚Ä¢ Blake Hord
‚Ä¢ Tilman Birnstiel
and others.
1.6 Disclaimer
IMPORTANT NOTICE 1: I/We reject all responsibility for the use of this package. The package is provided as-
is, and we are not responsible for any damage to hardware or software, nor for incorrect results that may result
from the software. The user is fully responsible for any results from this code, and we strongly recommend
thorough testing of the code before using its results in any scientiÔ¨Åc papers.
IMPORTANT NOTICE 2: Any publications which involve the use of this software must mention the name of
this software package and cite the accompanying paper once it is published (Dullemond et al.in prep), or before
that the above mentioned web site.
4
Chapter 1. Introduction

CHAPTER
TWO
QUICKSTARTING WITH RADMC-3D
In general I recommend reading the manual fully, but it is often useful to get a quick impression of the package with a
quick-start. To make your Ô¨Årst example model, this is what you do:
1. When you read this you have probably already unzipped this package, or cloned the git repository. You should
Ô¨Ånd, among others, a src/ directory and a examples/ directory. Go into the src/ directory.
2. Edit the src/Makefile Ô¨Åle, and make sure to set the FF variable to the Fortran-90 compiler you have installed
on your system.
3. Type make. If all goes well, this should compile the entire code and create an executable called radmc3d.
4. Type make install. If all goes well this should try to create a link to radmc3d in your $HOME/bin/
directory, where $HOME is your home directory. If this $HOME/bin/ directory does not exist, it will ask to
make one.
5. Make sure to have the $HOME/bin/ directory in your path. If you use, for instance, the bash shell, you do this
by setting the PATH variable by adding a line like export PATH=$HOME/bin:\$PATH to your $HOME/
.bashrc Ô¨Åle. If you change these things you may have to open a new shell to make sure that the shell now
recognizes the new path.
6. Check if the executable is OK by typing radmc3d in the shell. You should get a small welcoming message by
the code.
7. Now enter the directory examples/run_simple_1/. This is the simplest example model.
8. Type python problem_setup.py (Note: you must have a working Python distribution on your computer,
which is reasonably up to date, with numpy and matplotlib libraries included). This will create a series of
input Ô¨Åles for RADMC-3D.
9. Type radmc3d mctherm. This should let the code do a Monte Carlo run. You should see Photon nr
1000, followed by Photon nr 2000, etc until you reach Photon nr 1000000. The Monte Carlo mod-
eling for the dust temperatures has now been done. A Ô¨Åle dust_temperature.dat should have been
created.
10. Type radmc3d image lambda 1000 incl 60 phi 30. This should create an image with the camera
at inclination 60 degrees (from pole-on), and rotated 30 degrees (along the polar axis, clockwise, i.e.the object
rotating counter-clockwise), at wavelength ùúÜ= 1000 ùúám (i.e. at 1 millimeter wavelength). The Ô¨Åle that contains
the image is image.out. It is a text Ô¨Åle that can be read with the simpleread.py tool in the directory
python/radmc3d_tools/.
If you experience troubles with the above steps, and you cannot Ô¨Åx it, please read the next chapters for more details.
5

radmc3d, Release 2.0
6
Chapter 2. Quickstarting with RADMC-3D

CHAPTER
THREE
OVERVIEW OF THE RADMC-3D PACKAGE
3.1 Introduction
The RADMC-3D code is written in fortran-90 and should compile with most f90 compilers without problems. It needs
to be compiled only once for each platform.
The executable is called radmc3d and it performs all the model calculations of the RADMC-3D package, for instance
the Monte Carlo simulations, ray-tracing runs (images, spectra), etc. There is also a set of useful subroutines written
in the Python language to use the radmc3d code, but radmc3d can also run without it. In that case the user will
have to write his/her own pre- and post-processing subroutines.
3.2 Requirements
The following pre-installed software is required:
1. Operating system: Unix-like (e.g. Linux or MacOSX)
This package runs under Unix-like environment (e.g. Linux or MacOSX), but has not been tested under Win-
dows. There is no particular reason why it should not also run under Windows, but it would require different
ways of Ô¨Åle handling. In this manual we always assume a Unix-like environment, in which we will make use of
a bash command-line interface (CLI). We will call this the shell.
2. make or gmake
This is the standard tool for compiling packages on all Unix/Linux/MacOS-based systems.
3. perl
This is a standard scripting language available on most or all Unix/Linux-based systems. If you are in doubt:
type which perl to Ô¨Ånd the location of the perl executable. See http://www.perl.org/ for details on perl,
should you have any problems. But on current-day Unix-type operating systems perl is nearly always installed
in the /usr/bin/ directory. If you do not have Perl installed, you can also do without. Its sole use is to
copy the executables into your home $HOME/bin/ directory for quick access from the Unix/Linux/MacOS
command line. You can work around that, if necessary.
4. A fortran-90 compiler
Preferably the gfortran compiler (which the current installation assumes is present on the system). Website:
http://gcc.gnu.org/fortran/. Other compilers may work, but have not been tested yet.
5. An OpenMP-fortran-90 compiler (optional)
Only needed if you want to use the parallelized OpenMP version for the thermal Monte Carlo (for faster exe-
cution). Preferably the GNUOpenMP/GOMP compiler which is an implementation of OpenMP for the Fortran
7

radmc3d, Release 2.0
compiler in the GNU Compiler Collection. Websites: http://openmp.org/wp and http://gcc.gnu.org. Other com-
pilers may work, but we give no guarantee.
6. Python version 3 with standard libraries
The core RADMC-3D code radmc3d (written in Fortran-90) is the raw workhorse code that reads some input
Ô¨Åles and produces some output Ô¨Åles. Typically you will not need to worry about the internal workings of the
RADMC-3D code. All you need to do is produce the proper input Ô¨Åles, run radmc3d, and read the output
Ô¨Åles for post-processing (such as displaying and analyzing the results). This pre- and post-processing is done in
Python. This RADMC-3D distribution provides you with the Python tools you need, though you will likely want
to program your own additional Python code to adjust the models to your own needs. To use the Python tools
provided in this RADMC-3D distribution, you need Python version 3 (though most things should also work
with the depricated Python 2), with a set of standard libraries such as numpy and matplotlib. Typically we
will assume that Python is used as a Python or iPython command-line interface, which we shall call the Python
command line (as opposed to the shell). The user can, of course, also use Jupyter Notebooks instead. But for
the sake of clarity, in this manual we assume the use of Python the Python command line.
Note that the Monte Carlo code RADMC-3D itself (radmc3d) is in Fortran-90. Only the creation of the input
Ô¨Åles (and hence the problem deÔ¨Ånition) and the analysis of the output Ô¨Åles is done in Python. The user is of course
welcome to use other ways to create the input Ô¨Åles for RADMC-3D if he/she is not able or willing to use Python for
whatever reason. Therefore Python is not strictly required for the use of this code. However, all examples and support
infrastructure is provided in Python.
3.3 Contents of the RADMC-3D package
3.3.1 RADMC-3D package as a .zip archive
If you obtain RADMC-3D from its website, it will be packed in a zip archive called radmc-3d_v*.*_dd.mm.
yy.zip where the *.* is the version number and dd.mm.yy is the date of this version. To unpack on a linux, unix
or Mac OS X machine you type:
unzip <this archive file>
i.e. for example for radmc-3d_v2.0_25.08.20.zip you type:
unzip radmc-3d_v2.0_25.08.20.zip
3.3.2 RADMC-3D package from the github repository
If you obtain RADMC-3D by cloning its github repository, you will get a copy of the full git repository of RADMC-
3D. In principle this is not much different from unzipping the .zip archive. But it is more powerful: You can more
easily stay up to date with the latest bugÔ¨Åxes, and you can see the entire development history of this version of the
code. See https://git-scm.com/book/en/v2 for an extensive documentation of how to use git.
The way to produce a clone of RADMC-3D in the directory where your shell is currently is, is like this:
git clone https://github.com/dullemond/radmc3d-2.0.git
This will create the directory radmc3d-2.0/. At any time you can pull the latest version from the repository like
this:
cd radmc3d-2.0/
git pull
8
Chapter 3. Overview of the RADMC-3D package

radmc3d, Release 2.0
Keep in mind, however, that while the repository is always the very latest version, this comes with a (small) risk that
some new features may not have been tested well, or (new) bugs may have been introduced. Overall, however, we
advise to use the github repository instead of the .zip archive from the website.
3.3.3 Contents of the package
The RADMC-3D package has the following subdirectory structure:
src/
python/
examples/
run_simple_1/
run_simple_1_userdef/
run_simple_1_userdef_refined/
.
.
.
opac/
manual/
plus some further directories.
The Ô¨Årst directory, src/, contains the fortran-90 source code for RADMC-3D. The second directory, python/,
contains two sets of Python modules that are useful for model preparation and post-processing. One is a directory
called radmc3d_tools/, which contains some simple Python tools that might be useful. The other is a directory
called radmc3dPy/, which is a high-level stand-alone Python library developed by Attila Juhasz for RADMC-3D.
The third directory contains a series of example models. The fourth directory, opac/ contains a series of tools and
data for creating the opacity Ô¨Åles needed by RADMC-3D (though the example models all have their own opacity data
already included), The Ô¨Åfth directory contains this manual.
3.4 Units: RADMC-3D uses CGS units
The RADMC-3D package is written such that all units are in CGS (length in cm, time in sec, frequency in Hz, energy
in erg, angle in steradian). There are exceptions:
‚Ä¢ Wavelength is usually written in micron
‚Ä¢ Sometimes angles are in degrees (internally in radian, but input as degrees)
3.4. Units: RADMC-3D uses CGS units
9

radmc3d, Release 2.0
10
Chapter 3. Overview of the RADMC-3D package

CHAPTER
FOUR
INSTALLATION OF RADMC-3D
Although the RADMC-3D package contains a lot of different software, the main code is located in the src/ directory,
and is written in Fortran-90. The executable is radmc3d. Here we explain how to compile the fortran-90 source codes
and create the executable radmc3d.
4.1 Compiling the code with ‚Äòmake‚Äô
To compile the code, enter the src/ directory in your shell. You now may need to edit the Makefile in this directory
using your favorite text editor and replace the line
FF = gfortran -fopenmp
with a line specifying your own compiler (and possibly OpenMP directive, if available). If, of course, you use gfortran,
you can keep this line. But if you use, e.g., ifort, then replace the above line by
FF = ifort -openmp
(note the slightly different OpenMP directive here, too). If you save this Ô¨Åle, and you are back in the shell, you can
compile the radmc3d code by typing
make
in the shell. If all goes well, you have now created a Ô¨Åle called radmc3d in the src/ directory.
If, for whatever reason, the OpenMP compilation does not work, you can also compile the code in serial mode. Simply
remove the -fopenmp directive.
4.2 The install.perl script
If instead of typing just make you type
make install
(or you Ô¨Årst type make and then make install, it is the same), then in addition to creating the executable, it also
automatically executes a perl script called install.perl (located also in the src/ directory). This PERL script
installs the code in such a way that it can be conveniently used in any directory. What it does is:
‚Ä¢ It checks if a bin/ directory is present in your home directory (i.e. a $HOME/bin/ directory). If not, it asks
if you want it to automatically make one.
11

radmc3d, Release 2.0
‚Ä¢ It checks if the $HOME/bin/ directory is in the path of the currently used shell. This is important to allow the
computer to look for the program radmc3d in the $HOME/bin/ directory. If you use a bash shell, then you
can add the following line to your $HOME/.bashrc:
export PATH=/myhomedirectory/bin/python:$PATH
‚Ä¢ It creates a Ô¨Åle radmc3d in this $HOME/bin/ directory with the correct executable permissions. This Ô¨Åle is
merely a dummy executable, that simply redirects everything to the true radmc3d executable located in your
current src/ directory. When you now open a new shell, the path contains the $HOME/bin/ directory, and
the command radmc3d is recognized. You can also type source $HOME/.bashrc followed by rehash.
This also makes sure that your shell recognizes the radmc3d command.
‚Ä¢ It checks if a python/ subdirectory exists in the above mentioned bin/ directory, i.e.a $HOME/bin/
python/ directory. If not, it asks if you want it to automatically create one.
‚Ä¢ If yes, then it will copy all the Ô¨Åles ending with .py in the python/radmc3d_tools/ directory of the
distribution to that $HOME/bin/python/radmc3d_tools/ directory. This is useful to allow you to make
an PYTHONPATH entry to allow python to Ô¨Ånd these python scripts automatically.
Note that this perl script installs the code only for the user that installs it. A system-wide installation is not useful,
because the code package is not very big and it should remain in the control of the user which version of the code
he/she uses for each particular problem.
If all went well, then the perl.install script described here is called automatically once you type make
install following the procedure in Section Compiling the code with ‚Äòmake‚Äô.
Before the installation is recognized by your shell, you must now either type rehash in the shell or simply open a
new shell.
How do you know that all went OK? If you type radmc3d in the shell the RADMC-3D code should now be executed
and give some comments. It should write:
================================================================
WELCOME TO RADMC-3D: A 3-D CONTINUUM AND LINE RT SOLVER
VERSION 2.0
(c) 2008-2020 Cornelis Dullemond
Please feel free to ask questions. Also please report
bugs and/or suspicious behavior without hestitation.
The reliability of this code depends on your vigilance!
dullemond@uni-heidelberg.de
To keep up-to-date with bug-alarms and bugfixes, register to
the RADMC-3D forum:
http://radmc3d.ita.uni-heidelberg.de/phpbb/
Please visit the RADMC-3D home page at
http://www.ita.uni-heidelberg.de/~dullemond/software/radmc-3d/
================================================================
Nothing to do... Use command line options to generate action:
mctherm
: Do Monte Carlo simul of thermal radiation
mcmono
: Do Monte Carlo simul only for computing mean intensity
spectrum
: Make continuum spectrum
image
: Make continuum image
on the screen (or for newer versions of RADMC-3D perhaps some more or different text). This should also work from
any other directory.
12
Chapter 4. Installation of RADMC-3D

radmc3d, Release 2.0
4.3 What to do if this all does not work?
In case the above compilation and installation does not work, here is a proposed procedure to do problem hunting:
1. First, answer the following questions:
‚Ä¢ Did you type make install in the src/ directory? I mean, did you not forget the install part?
‚Ä¢ Did you put $HOME/bin/ in your path (see above)?
‚Ä¢ If you just added $HOME/bin/ to your path, did you follow the rest of the procedure (either closing the
current shell and opening a new shell or typing the source and rehash commands as described above)?
If this does not help, then continue:
2. Close the shell, open a new shell.
3. Go to the RADMC-3D src/ directory.
4. Type ./radmc3d. This should give the above message. If not, then make sure that the compilation went right
in the Ô¨Årst place:
5. Type rm -f radmc3d, to make sure that any old executable is not still present.
6. Type make clean. This should return the sentence OBJECT and MODULE files removed.
7. In case the problem lies with the OpenMP parallellization, you could do cp Makefile_normal
Makefile, which switches off the OpenMP compilation.
8. Then type make.
This should produce a set of lines, each representing a compilation of a module, e.g.
gfortran -c -O2 ./amr_module.f90 -o amr_module.o, etc. The Ô¨Ånal line should be some-
thing like gfortran -O2 main.o ..... gascontinuum_module.o -o radmc3d.
If instead
there is an error message, then do the following:
‚Ä¢ Check if the compiler used (by default gfortran) is available on your computer system.
‚Ä¢ If you use an other compiler, check if the compiler options used are recognized by your compiler.
‚Ä¢ Check if the executable radmc3d is now indeed present. If it is not present, then something
must have gone wrong with the compilation. So then please check the compilation and linking
stage again carefully.
If you followed all these procedures, but you still cannot get even the executable in the src/ direc-
tory to run by typing (in the src/ directory) ./radmc3d (don‚Äôt forget the dot slash!), then please
contact the author.
9. At this point we assume that the previous point worked. Now go to another directory (any one), and type
radmc3d. This should also give the above message. If not, but the radmc3d executable was present, then
apparently the shell path settings are wrong. Do this:
‚Ä¢ Check if, in the current directory (which is now not src/) there is by some accident another copy of the
executable radmc3d. If yes, please remove it.
‚Ä¢ Type which radmc3d to Ô¨Ånd out if it is recognized at all, and if yes, to which location it points.
‚Ä¢ Did you make sure that the shell path includes the $HOME/bin/ directory, as it should? Otherwise the
shell does not know where to Ô¨Ånd the $HOME/bin/radmc3d executable (which is a perl link to the
src/radmc3d executable).
‚Ä¢ Does the Ô¨Åle $HOME/bin/radmc3d perl Ô¨Åle exist in the Ô¨Årst place? If no, check why not.
4.3. What to do if this all does not work?
13

radmc3d, Release 2.0
‚Ä¢ Type less $HOME/bin/radmc3d and you should see a text with Ô¨Årst line being #!/usr/bin/
perl and the second line being someting like system("/Users/user1/radmc-3d/version_2.
0/src/radmc3d @ARGV"); where the /Users/user1 should of course be the path to your home
directory, in fact to the directory in which you installed RADMC-3D.
If this all brings you no further, please Ô¨Årst ask your system administrators if they can help. If not, then please contact
the author.
4.4 Installing the simple Python analysis tools
RADMC-3D offers (in addition to the model setup scripts in the examples/ subdirectories) two Python support
libraries:
1. python/radmc3d_tools/
This library contains only some bare-bones small Python scripts.
2. python/radmc3dPy/
This library is a sophisticated stand-alone library developed by Attila Juhasz, and further maintained together
with the RADMC-3D main author.
4.4.1 How to install and use the python/radmc3d_tools/
The installation of the python/radmc3d_tools should be automatic when you type make install in the
src/ code directory (see above). It will copy the Ô¨Åles to the bin/python/radmc3d_tools/ directory in your
home directory. If this directory does not exist, you will be asked if you want it to be created. If you conÔ¨Årm (typing
‚Äòy‚Äô), then the Ô¨Åles from the python/radmc3d_tools/ directory will be copied into the $HOME/bin/python/
radmc3d_tools/ directory.
Now you need to make sure that Python knows that these tools are there. In Python here are two ways how you can
make sure that Python automatically Ô¨Ånds these scripts:
1. Under Unix/Linux/MacOSX you can set the PYTHONPATH directly in your .bashrc Ô¨Åle. For example: in
.bashrc (if you use the bash shell) you can write:
export PYTHONPATH=$HOME/bin/python:$PYTHONPATH
(where $HOME is your home directory name).
1. Alternatively you can set the PYTHONPATH directly from within Python with the python command:
import os
import sys
home = os.environ["HOME"]
sys.path.append(home+'/bin/python')
If all goes well, if you now start Python you should be able to have access to the basic Python tools of RADMC-3D
directly. To test this, try typing from radmc3d_tools.simpleread import * in Python. If this gives an
error message that simpleread.py cannot be found, then please ask your system administrators how to solve this.
You may ask why Ô¨Årst copy these Ô¨Åles to $HOME/bin/python/radmc3d_tools/ and not point PYTHONPATH
directly to the python/radmc3d_tools in your RADMC-3D distribution? The reason is that if you have multiple
versions of RADMC-3D on your computer system, you always are assured that Python Ô¨Ånds the python routines
belonging to the latest installation of RADMC-3D (note: only assured if that latest compilation was done with make
install).
14
Chapter 4. Installation of RADMC-3D

radmc3d, Release 2.0
Now you should be ready to use the tools. The most important one would be the simpleread.py tool, which
contains a set of functions for reading typical RADMC-3D input and output Ô¨Åles (though only for regular model grid,
not for octree grids). In a Python command line interface you can import them by:
from radmc3d_tools import simpleread
And you can then, for instance, read the dust density Ô¨Åle with:
d = simpleread.read_dustdens()
Here, d is now an object containing a d.grid subobject (which contain information about the grid) and the dust
density array d.rhodust. Have a look at the various functions in simpleread, to see what is available.
4.4.2 How to install and use the python/radmc3dPy library
The installation of the python/radmc3dPy package is described in the python/radmc3dPy/README Ô¨Åle. In
short, by going into the python/radmc3dPy/ directory and typing in the shell:
python setup.py install --user
it should install itself right into your Python distribution. For instance, if you have anaconda3 on a Mac, it would
copy the Ô¨Åles into the directory
$HOME/.local/lib/python3.7/site-packages/radmc3dPy/
Python knows where to Ô¨Ånd it there.
Now you should be ready to use radmc3dPy, by importing it:
import radmc3dPy
radmc3dPy consists of several sub libraries such as radmc3dPy.analyze and radmc3dPy.image. For in-
stance, to read the dust density distribution, you could do this:
from radmc3dPy import analyze
d = readData(ddens=True)
The d.rhodust array now contains the dust density.
For more information, please consult the radmc3dPy documentation in the python/radmc3dPy/doc/ directory.
4.5 Making special-purpose modiÔ¨Åed versions of RADMC-3D (op-
tional)
For most purposes it should be Ô¨Åne to simply compile the latest version of RADMC-3D once-and-for-all, and simply
use the resulting radmc3d executable for all models you make. Normally there is no reason to have to modify the
code, because models can be deÔ¨Åned quite Ô¨Çexibly by preparing the various input Ô¨Åles for RADMC-3D to your needs.
So if you are an average user, you can skip to the next subsection without problem.
But sometimes there is a good reason to want to modify the code. For instance to allow special behavior for a particular
model. Or for a model setup that is simply easier made internally in the code rather than by preparing large input Ô¨Åles.
One can imagine some analytic model setup that might be easier to create internally, so that one can make use of the
full AMR machinery to automatically reÔ¨Åne the grid where needed. Having to do so externally from the code would
require you to set up your own AMR machinery, which would be a waste of time.
4.5. Making special-purpose modiÔ¨Åed versions of RADMC-3D (optional)
15

radmc3d, Release 2.0
The problem is that if the user would modify the central code for each special purpose, one would quickly lose track
of which modiÔ¨Åcation of the code is installed right now.
Here is how this problem is solved in RADMC-3D:
‚Ä¢ For most purposes you can achieve your goals by only editing the Ô¨Åle userdef_module.f90. This is a
set of standard subroutines that the main code calls at special points in the code, and the user can put anything
he/she wants into those subroutines. See Chapter Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed
radiative processes for more information about these standard subroutines. This method is the safest way to
create special-purpose codes. It means (a) that you know that your modiÔ¨Åcation cannot do much harm unless
you make really big blunders, because these subroutines are meant to be modiÔ¨Åed, and (b) you have all your
modiÔ¨Åcations only in one single Ô¨Åle, leaving the rest of the code untouched.
‚Ä¢ You can create a local version of the code, without touching the main code. Suppose you have a model directory
run_mymodel and for this model you want to make a special-purpose version of the code. This is what you
do:
1. Copy the MakeÔ¨Åle from the src/ directory into run_mymodel.
2. Copy the .f90 Ô¨Åle(s) you want to modify from the src/ directory into run_mymodel. Usually you
only want to modify the userdef_module.f90 Ô¨Åle, but you can also copy any other Ô¨Åle if you want.
3. In the run_mymodel/Makefile replace the SRC = . line with SRC = XXXXXX, where XXXXXX
should be the full path to the src/ directory. An example line is given in the MakeÔ¨Åle, but is commented
out.
4. In the run_mymodel/Makefile make sure that all the .f90 Ô¨Åles that should remain as they are have
a $(SRC)/ in front of the name, and all the .f90 Ô¨Åles that you want to modify (and which now have
a copy in the run_mymodel directory) have a ./ in front of the name. By default all .f90 Ô¨Åles have
$(SRC)/ in front of the name, except the userdef_module.f90 Ô¨Åle, which has a ./ in front of the
name because that is the Ô¨Åle that is usually the one that is going to be edited by you.
5. Now edit the local .f90 Ô¨Åles in the run_mymodel directory in the way you want. See Chapter Modifying
RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes for more details.
6. Now inside the run_mymodel directory you can now type make and you will create your own local
radmc3d executable. NOTE: Do not type make install in this case, because it should remain a local
executable, only inside the run_mymodel directory.
7. If you want (though this is not required) you can clean up all the local .o and .mod Ô¨Åles by typing make
clean, so that your run_mymodel directory is not Ô¨Ålled with junk.
8. You can now use this special purpose version of radmc3d by simply calling on the command line: ./
radmc3d, with any command-line options you like. Just beware that, depending on the order in which
you have your paths set (in tcsh or bash) typing just radmc3d may instead use the global version (that you
may have created in the src/ directory with make install). So to be sure to use the local version,
just put the ./ in front of the radmc3d.
Note: In chapter Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes there is more informa-
tion on how to set up models internally in the code using the method described here.
Note: You can use make clean to remove all the .o and .mod Ô¨Åles from your model directory, because they can be
annoying to have hanging around. By typing make cleanmodel you remove, in addition to the .o and .mod Ô¨Åles,
also all model input and output Ô¨Åles, with the exception of dust opacity or molecular data Ô¨Åles (because these latter
Ô¨Åles are usually not created locally by the problem_setup.py script). By typing make cleanall you remove
everything except the basic Ô¨Åles such as the Makefile, any .f90 Ô¨Åles, any .py Ô¨Åles, the dust opacity or molecular
data Ô¨Åles and README Ô¨Åles.
16
Chapter 4. Installation of RADMC-3D

CHAPTER
FIVE
BASIC STRUCTURE AND FUNCTIONALITY
RADMC-3D is a very versatile radiative transfer package with many possibilities. As a consequence it is a rather
complex package. However, we have tried to keep it still as easy as possible to use as a Ô¨Årst-time user. We tried to do
so by keeping many of the sophisticated options ‚Äòhidden‚Äô and having many default settings already well-chosen. The
idea is that one can already use the code at an entry level, and then gradually work oneself into the more fancy options.
RADMC-3D is a general-purpose package, so there are no ‚Äòbuilt-in‚Äô models inside the radmc3d executable (Except
if you insert one yourself using the userdef module, see Chapter Modifying RADMC-3D: Internal setup and user-
speciÔ¨Åed radiative processes). For instance, if you want to model a protoplanetary disk, then you would have to design
the grid and density structure of the disk on this grid yourself. To make it easier for the user, we have provided several
Python-scripts as examples. Among these examples is indeed a protoplanetary disk model. So this is as close as we
go to ‚Äòbuilt-in‚Äô models: we provide, for some cases, already well-developed example models that you, the user, can
use out-of-the-box, or that you can adapt to your needs.
In this chapter we give an overview of the rough functionality of the code in its simplest form: ignoring all the hidden
fancy options and possibilities. For the details we then refer to the chapters ahead.
5.1 Basic dataÔ¨Çow
Let us Ô¨Årst clarify the basic philosophy of the code package (details will be done later). When we talk about RADMC-
3D we talk about the fortran-90 program. The source codes are in the directory src/ and the executable is called
radmc3d. This is the code that does all the main calculations. You can call the code from the bash shell (in
Unix/Linux/MacOSX systems) and you can specify command-line options to tell RADMC-3D what you want it to do.
The code RADMC-3D is in a way just a dumb computational engine. It has no physical data (such as opacities or
material properties) implemented, nor does it have any model implemented. It is totally dependent on input Ô¨Åles of
various kinds. These input Ô¨Åles have Ô¨Ålenames that end in .inp, or .binp, dependent on whether the data in ASCII,
or binary form. You, the user, will have to create these input Ô¨Åles. RADMC-3D will simply look if an .inp, or a
.binp Ô¨Åle is present, and will switch to ASCII, dependent on which Ô¨Åle-extension it Ô¨Ånds.
After you run RADMC-3D (by calling radmc3d with the appropriate command-line options) you will see that the
code will have produced one or more output Ô¨Åles, with Ô¨Ålenames ending in .out or .bout. Whether RADMC-3D
produces ASCII or binary Ô¨Åles, depends on a Ô¨Çag called rto_style that you can set (see Chapter Binary I/O Ô¨Åles).
IMPORTANT NOTE: In this manual we will mostly refer to the ASCII form of input and output Ô¨Åles for convenience.
But each time we refer to an *.inp, *.dat or *.out Ô¨Åle, we implicitly assume that this could also be a *.binp, *.bdat or
*.bout Ô¨Åle.
This basic dataÔ¨Çow is shown in Fig. Pictographic representation of the basic dataÔ¨Çow of RADMC-3D. The user
produces the input Ô¨Åles; RADMC-3D reads them, performs the calculation, and produces output Ô¨Åles. The user can
then analyze the output Ô¨Åles..
Not always can RADMC-3D produce its output Ô¨Åles in one go. Sometimes it has to use a two-stage procedure: For
dust continuum radiative transfer the dust temperatures are computed Ô¨Årst (stage 1), and the images and/or spectra
17

radmc3d, Release 2.0
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
radiative transfer
calculation
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Fig. 5.1: Pictographic representation of the basic dataÔ¨Çow of RADMC-3D. The user produces the input Ô¨Åles; RADMC-
3D reads them, performs the calculation, and produces output Ô¨Åles. The user can then analyze the output Ô¨Åles.
are rendered after that (stage 2). Between stage 1 and stage 2 an intermediate Ô¨Åle is then produced (with Ô¨Ålename
ending in .dat or .bdat), which in the case of dust continuum radiative transfer is dust_temperature.dat
(or *.bdat).
This basic dataÔ¨Çow is shown in Fig. Pictographic representation of the dataÔ¨Çow of RADMC-3D for the case of a
2-stage procedure, such as for dust continuum transfer. An intermediate Ô¨Åle is produced that will be used by stage 2,
but of course the user can also analyze the intermediate Ô¨Åle itself..
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
stage 1 calculation
(e.g. "mctherm")
Intermediate data files,
possible data formats:
***.dat (ascii), or
***.bdat (binary)
RADMC-3D
stage 2 calculation
(e.g. "image" 
or "spectrum")
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Fig. 5.2: Pictographic representation of the dataÔ¨Çow of RADMC-3D for the case of a 2-stage procedure, such as for
dust continuum transfer. An intermediate Ô¨Åle is produced that will be used by stage 2, but of course the user can also
analyze the intermediate Ô¨Åle itself.
Several of these input Ô¨Åles contain large tables, for instance of the density at each grid point, or the stellar Ô¨Çux at each
wavelength bin. It is, of course, impossible to create these dataÔ¨Åles by hand. The idea is that you design a program
(in any language you like) that creates these dataÔ¨Åles. In that program you essentially ‚Äòprogram the model‚Äô. We have
provided a number of example model setups in the examples/ directory. For these examples models the setup
programs were written in Python (their Ô¨Ålenames all start with problem_ and end with .py). For you as the user it
is therefore the easiest to start from one of these examples and modify the Python code to your needs. However, if you
prefer to use another language, you can use the examples to see how the input Ô¨Åles were generated and then program
this in another programming language.
Note: The Python Ô¨Åles called problem_*.py are meant to be edited and changed by you! They are templates from
which you can create your own models.
For the analysis of the output Ô¨Åles created by RADMC-3D you can use your own favorite plotting or data-analysis
software. But also here we provide some tools in Python. These Python routines are in the python/ directory.
Typically you will create your own program, e.g. plot_model.py or so, that will use these subroutines, e.g. by
putting in the Ô¨Årst line: from radmc3dPy import *. In this way Python is used also as a post-processing tool.
But again: this can also be done in another language.
This procedure is shown in Fig. Pictographic representation of how the Python programs in the example directories
are used to create the input Ô¨Åles of RADMC-3D. for the single-stage dataÔ¨Çow and in Fig. Pictographic representation
of the dataÔ¨Çow of RADMC-3D for the case of a 2-stage procedure, such as for dust continuum transfer. An intermediate
Ô¨Åle is produced that will be used by stage 2, but of course the user can also analyze the intermediate Ô¨Åle itself. for the
two-stage dataÔ¨Çow.
18
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
radiative transfer
calculation
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Python
Create model and
write the input files
Python
Read output files,
and analyze / display
results
Fig. 5.3: Pictographic representation of how the Python programs in the example directories are used to create the
input Ô¨Åles of RADMC-3D.
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
stage 1 calculation
(e.g. "mctherm")
Intermediate data files,
possible data formats:
***.dat (ascii), or
***.bdat (binary)
RADMC-3D
stage 2 calculation
(e.g. "image" 
or "spectrum")
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Python
Create model and
write the input files
Python
Read output files,
and analyze / display
results
Python
(optional)
Read intermediate files,
and analyze / display
to check if they are ok
Fig. 5.4: Pictographic representation of the dataÔ¨Çow of RADMC-3D for the case of a 2-stage procedure, such as for
dust continuum transfer. An intermediate Ô¨Åle is produced that will be used by stage 2, but of course the user can also
analyze the intermediate Ô¨Åle itself.
5.2 Radiative processes
Currently RADMC-3D handles the following radiative processes:
‚Ä¢ Dust thermal emission and absorption
RADMC-3D can compute spectra and images in dust continuum. The dust temperature must be known in
addition to the dust density. In typical applications you will know the dust density distribution, but not the dust
temperature, because the latter is the results of a balance between radiative absorption and re-emission. So in
order to make spectra and images of a dusty object we must Ô¨Årst calculate the dust temperature consistently.
This can be done with RADMC-3D by making it perform a ‚Äòthermal Monte Carlo‚Äô simulation (see Chapter Dust
continuum radiative transfer). This can be a time-consuming computation. But once this is done, RADMC-3D
writes the resulting dust temperatures out to the Ô¨Åle dust_temperature.dat, which it can then later use
for images and spectra. We can then call RADMC-3D again with the command to make an image or a spectrum
(see Chapter Dust continuum radiative transfer). To summarize: a typical dust continuum radiative transfer
calculation goes in two stages:
1. A thermal Monte Carlo simulation with RADMC-3D to compute the dust temperatures.
2. A spectrum or image computation using ray-tracing with RADMC-3D.
‚Ä¢ Dust scattering
Dust scattering is automatically included in the thermal Monte Carlo simulations described above, as well as in
the production of images and spectra. For more details, consult Chapter Dust continuum radiative transfer.
‚Ä¢ Gas atomic/molecular lines
RADMC-3D can compute spectra and images in gas lines (see Chapter Line radiative transfer). The images are
also known as channel maps. To compute these, RADMC-3D must know the population densities of the various
atomic/molecular levels. For now there are the following options how to let RADMC-3D know these values:
5.2. Radiative processes
19

radmc3d, Release 2.0
‚Äì Tell RADMC-3D to assume that the molecules or atoms are in Local Thermodynamic Equilibrium (LTE),
and specify the gas temperature at each location to allow RADMC-3D to compute these LTE level pop-
ulations. Note that in principle one is now faced with the same problem as with the dust continuum: we
need to know the gas temperature, which we typically do not know in advance. However, computing the
gas temperature self-consistently is very difÔ¨Åcult, because it involves many heating and cooling processes,
some of which are very complex. That is why most line radiative transfer codes assume that the user gives
the gas temperature as input. We do so as well. If you like, you can tell RADMC-3D to use the (previously
calculated) dust temperature as the gas temperature, for convenience.
‚Äì Deliver RADMC-3D an input Ô¨Åle with all the level populations that you have calculated youself using
some method.
‚Äì Tell RADMC-3D to compute the level populations according to some simple local non-LTE prescription
such as the Sobolev approximation (Large Velocity Gradient method) or the Escape Probability Method.
Currently RADMC-3D does not have a full non-local non-LTE computation method implemented. The reason
is that it is very costly, and for many applications presumably not worth the computational effort.
5.3 Coordinate systems
With RADMC-3D you can specify your density distribution in two coordinate systems:
‚Ä¢ Cartesian coordinates: 3-D
The simplest coordinate system is the Cartesian coordinate system (ùë•, ùë¶, ùëß). For now each model must be 3-D
(i.e. you must specify the densities and other quantities as a function of ùë•, ùë¶and ùëß).
‚Ä¢ Cartesian coordinates: 1-D plane-parallel
This is like the normal cartesian coordinates, but now the ùë•- and ùë¶- directions are inÔ¨Ånitely extended. Only the
ùëß-direction has Ô¨Ånite-size cells, and hence the grid is only in ùëß-direction. This mode is the usual plane-parallel
mode of radiative transfer. See Section 1-D Plane-parallel models for more details on this mode.
‚Ä¢ Cartesian coordinates: 2-D pencil-parallel
This is the intermediate between full 3-D cartesian and 1-D plane-parallel. In this mode only the ùë•-direction is
inÔ¨Ånitely extended and a Ô¨Ånite grid is in both ùë¶and ùëßdirections. This mode is only useful in very special cases,
and is much less familiar to most - so use only when you are conÔ¨Ådent.
‚Ä¢ Spherical coordinates
You can also specify your model in spherical coordinates (ùëü, ùúÉ, ùúë). These coordinates are related to the cartesian
ones by:
ùë•= ùëüsin ùúÉcos ùúë
ùë¶= ùëüsin ùúÉsin ùúë
ùëß= ùëücos ùúÉ
This means that the spatial variables (density, temperature etc) are all speciÔ¨Åed as a function of (ùëü, ùúÉ, ùúë). How-
ever, the location of the stars, the motion and direction of photon packages etc. are still given in cartesian
coordinates (ùë•, ùë¶, ùëß). In other words: any function of space ùëì(‚Éóùë•) will be in spherical coordinates ùëì(ùëü, ùúÉ, ùúë),
but any point-like speciÔ¨Åcation of position ‚Éóùë•will be given as Cartesian coordinates ‚Éóùë•= (ùë•, ùë¶, ùëß). This hybrid
method allows us to do all physics in cartesian coordinates: photon packages or rays are treated always in carte-
sian coordinates, and so is the physics of scattering, line emission etc. Only if RADMC-3D needs to know what
the local conditions are (dust temperature, gas microturbulence, etc) RADMC-3D looks up which coordinates
(ùëü, ùúÉ, ùúë) belong to the current (ùë•, ùë¶, ùëß) and looks up the value of the density, microturbulence etc.at that location
in the (ùëü, ùúÉ, ùúë) grid. And the same is true if RADMC-3D updates or calculates for instance the dust temperature:
it will compute the (ùëü, ùúÉ, ùúë) belong to the current (ùë•, ùë¶, ùëß) and update the temperature in the cell belonging to
20
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
(ùëü, ùúÉ, ùúë). For the rest, all the physics is done in the Cartesian coordinate system. This has the major advantage
that we do not need different physics modules for cartesian and spherical coordinates. Most parts of the code
don‚Äôt care which coordinate system is used: they will do their own work in Cartesian coordinates. When using
spherical coordinates, please read Section Separable grid reÔ¨Ånement in spherical coordinates (important!).
5.4 The spatial grid
To specify the density or temperature structure (or any other spatial variable) as a function of spatial location we must
have a grid. There are two basic types of grids:
The standard gridding is a simple rectangular grid.
‚Ä¢ Cartesian coordinates
When cartesian coordinates are used, this simply means that each cell is deÔ¨Åned as ùë•ùëô< ùë•< ùë•ùëü, ùë¶ùëô< ùë¶< ùë¶ùëü
and ùëßùëô< ùëß< ùëßùëü, where ùëôand ùëüstand for the left and right cell walls respectively.
‚Ä¢ Spherical coordinates
When spherical coordinates are used, this simply means that each cell is deÔ¨Åned as ùëüùëô< ùëü< ùëüùëü, ùúÉùëô< ùúÉ< ùúÉùëü
and ùúëùëô< ùúë< ùúëùëü. Note therefore that the shape of the cells in spherical coordinates is (in real space) curved.
For spherical coordinates the following four modes are available:
‚Äì 1-D Spherical symmetry:
All spatial functions depend only on ùëü.
‚Äì 2-D Axial symmetry:
All spatial functions depend only on ùëüand ùúÉ.
‚Äì 2-D Axial symmetry with mirror symmetry:
All spatial functions depend only on ùëüand ùúÉ, where the ùúÉgrid only covers the part above the ùëß= 0 plane.
Internally it is in this mode assumed that all quantities below the ùëß= 0 plane are equal to those above
the plane by mirror symmetry in the ùëß= 0 plane. This saves a factor of two in computational effort for
Monte Carlo calculations, as well as in memory useage. Note that also the resulting output Ô¨Åles such as
dust_temperature.dat will only be speciÔ¨Åed for ùëß> 0.
‚Äì 3-D:
All spatial functions depend on all three variables ùëü, ùúÉand ùúë.
‚Äì 3-D with mirror symmetry:
All spatial functions depend on all three variables ùëü, ùúÉand ùúë, but like in the 2-D case only the upper part
of the model needs to be speciÔ¨Åed: the lower part is assumed to be a mirror copy.
When using spherical coordinates, please read Section Separable grid reÔ¨Ånement in spherical coordinates (im-
portant!).
In all cases these structured grids allow for oct-tree-style grid reÔ¨Ånement, or its simpliÔ¨Åed version: the layer-style grid
reÔ¨Ånement. See Section INPUT (required): amr_grid.inp and Chapter More information about the gridding for more
information about the gridding and the (adaptive) mesh reÔ¨Ånement (AMR).
5.4. The spatial grid
21

radmc3d, Release 2.0
5.5 Computations that RADMC-3D can perform
The code RADMC-3D (i.e. the executable radmc3d) is one code for many actions. Depending on which command-
line arguments you give, RADMC-3D can do various actions. Here is a list:
1. Compute the dust temperature:
With radmc3d mctherm you call RADMC-3D with the command of performing a thermal Monte Carlo
simulation to compute the dust temperature under the assumption that the dust is in radiative equilibrium with
its radiation Ô¨Åeld. This is normally a prerequisite for computing SEDs and images from dusty objects (see
computing spectra and images below). The output Ô¨Åle of this computation is dust_temperature.dat
which contains the dust temperature everywhere in the model.
2. Compute a spectrum or SED:
With radmc3d sed you call RADMC-3D with the command of performing a ray-tracing computation to
compute the spectral energy distribution (SED) for the model at hand.
Typically you Ô¨Årst need to have
called radmc3d mctherm (see above) beforehand to compute dust temperatures (unless you have cre-
ated the Ô¨Åle dust_temperature.dat yourself because you have a special way of computing the dust
temperature). With radmc3d sed the spectrum is computed for the wavelengths points given in the Ô¨Åle
wavelength_micron.inp, which is the same wavelength grid that is used for radmc3d mctherm.
If you want to compute the spectrum at wavelength other than those used for the thermal Monte Carlo
simulation, you should instead call radmc3d spectrum, and you have the full freedom to choose the
spectral wavelengths points at will, and you can specify these in various ways described in Section Spec-
ifying custom-made sets of wavelength points for the camera.
Most easily you can create a Ô¨Åle called
camera_wavelength_micron.inp (see Section INPUT (optional): camera_wavelength_micron.inp)
and call RADMC-3D using radmc3d spectrum loadlambda. In all these cases the vantage point (where
is the observer) can of course be set as well, see Section Making SEDs, spectra, images for dust continuum and
Chapter Making images and spectra.
3. Compute an image:
With radmc3d image you call RADMC-3D with the command of performing a ray-tracing computation to
compute an image. You must specify the wavelength(s) at which you want the image by, for instance, calling
RADMC-3D as radmc3d image lambda 10, which makes the image at ùúÜ= 10ùúám. But there are other
ways by which the wavelength(s) can be set, see Section Specifying custom-made sets of wavelength points for
the camera. In all these cases the vantage point (where is the observer) can of course be set as well, see Section
Making SEDs, spectra, images for dust continuum and Chapter Making images and spectra.
4. Compute the local radiation Ô¨Åeld inside the model:
With radmc3d mcmono you call RADMC-3D with the command of performing a wavelength-by-
wavlength monochromatic Monte Carlo simulation (at the wavelengths that you specify in the Ô¨Åle
mcmono_wavelength_micron.inp). The output Ô¨Åle of this computation is mean_intensity.out
which contains the mean intensity ùêΩùúàas a function of the (ùë•, ùë¶, ùëß) (cartesian) or (ùëü, ùúÉ, ùúë) (spherical) co-
ordinates at the frequencies ùúàùëñ‚â°104ùëê/ùúÜùëñwhere ùúÜùëñare the wavelengths (in ùúám) speciÔ¨Åed in the Ô¨Åle
mcmono_wavelength_micron.inp. The results of this computation can be interesting for, for instance,
models of photochemistry. But if you use RADMC-3D only for computing spectra and images, then you will
not use this.
In addition to the above main methods, you can ask RADMC-3D to do various minor things as well, which will be
described throughout this manual.
22
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
5.6 How a model is set up and computed: a rough overview
A radiative transfer code such as RADMC-3D has the task of computing synthetic images and spectra of a model that
you specify. You tell the code what the dust and/or gas density distribution in 3-D space is and where the star(s) are,
and the code will then tell you what your cloud looks like in images and/or spectra. That‚Äôs basically it. That‚Äôs the main
task of RADMC-3D.
First you have to tell RADMC-3D what 3-D distribution of dust and/or gas you want it to model. For that you must
specify a coordinate system (cartesian or spherical) and a spatial grid. For cartesian coordinates this grid should be
3-D (although there are exceptions to this), while for spherical coordinates it can be 1-D (spherical symmetry), 2-D
(axial symmetry) or 3-D (no symmetry). RADMC-3D is (for most part) a cell-based code, i.e. your grid devides space
in cells and you have to tell RADMC-3D what the average densities of dust and/or gas are in these cells.
The structure of the grid is speciÔ¨Åed in a Ô¨Åle amr_grid.inp (see Section INPUT (required): amr_grid.inp). All the
other data, such as dust density and/or gas density are speciÔ¨Åed in other Ô¨Åles, but all assume that the grid is given by
amr_grid.inp.
We can also specify the locations and properties of one or more stars in the model. This is done in the stars.inp
(see Section INPUT (mostly required): stars.inp) Ô¨Åle.
Now suppose we want to compute the appearance of our model in dust continuum. We will describe this in detail
in Chapter Dust continuum radiative transfer, but let us give a very rough idea here. We write, in addition to the
amr_grid.inp and stars.inp Ô¨Åles, a Ô¨Åle dust_density.inp which speciÔ¨Åes the density of dust in each cell
(see Section INPUT (required for dust transfer): dust_density.inp). We also must write the main input Ô¨Åle radmc3d.
inp (see Section INPUT: radmc3d.inp), but we can leave it empty for now. We must give RADMC-3D a dust opacity
table in the Ô¨Åles dustopac.inp and for instance dustkappa_silicate.inp (see Section INPUT (required
for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp). And Ô¨Ånally, we
have to give RADMC-3D a table of discrete wavelengths in the Ô¨Åle wavelength_micron.inp that it will use to
perform its calculations on. We then call the radmc3d code with the keyword mctherm (see Chapter Dust continuum
radiative transfer) to tell it to perform a Monte Carlo simulation to compute dust temperatures everywhere. RADMC-
3D will write this to the Ô¨Åle dust_temperature.dat. If we now want to make a spectral energy distribution, for
instance, we call radmc3d sed (see Section Making spectra) and it will write a Ô¨Åle called spectrum.out which
is a list of Ô¨Çuxes at the discrete wavelengths we speciÔ¨Åed in wavelength_micron.inp. Then we are done: we
have computed the spectral energy distribution of our model. We could also make an image at wavelength 10 ùúám
for instance with radmc3d image lambda 10 (see Section Basics of image making with RADMC-3D). This will
write out a Ô¨Åle image.out containing the image data (see Section OUTPUT: image.out or image_****.out).
As you see, RADMC-3D reads all its information from tables in various Ô¨Åles. Since you don‚Äôt want to make large
tables by hand, you will have to write a little computer program that generates these tables automatically. You can do
this in any programming language you want. But in the example models (see Section Running the example models)
we use the programming language Python (see Section Requirements) for this. It is easiest to indeed have a look at the
example models to see how this is (or better: can be) done.
We will explain all these things in much more detail below, and we will discuss also many other radiative transfer
problem types. The above example is really just meant to give an impression of how RADMC-3D works.
5.6. How a model is set up and computed: a rough overview
23

radmc3d, Release 2.0
5.7 Organization of model directories
The general philosophy of the RADMC-3D code package is the following. The core of everything is the fortran code
radmc3d. This is the main code which does the hard work for you: it makes the radiative transfer calculations, makes
images, makes spectra etc. Normally you compile this code just once-and-for-all (see Chapter Installation of RADMC-
3D), and then simply use the executable radmc3d for all models. There is an exception to this ‚Äòonce-and-for-all‚Äô rule
described in Section Making special-purpose modiÔ¨Åed versions of RADMC-3D (optional), but in the present chapter
we will not use this (see Chapter Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes for this
instead). So we will stick here to the philosophy of compiling this code once and using it for all models.
So how to set up a model? The trick is to present radmc3d with a set of input Ô¨Åles in which the model is described
in all its details. The procedure to follow is this:
1. The best thing to do (to avoid a mess) is to make a directory for each model: one model, one directory. Since
radmc3d reads multiple input Ô¨Åles, and also outputs a number of Ô¨Åles, this is a good way to keep organized
and we recommend it strongly. So if we wish to make a new model, we make a new directory, or copy an old
directory to a new name (if we merely want to make small changes to a prior model).
2. In this directory we generate the input Ô¨Åles according to their required format (see Chapter Main input and
output Ô¨Åles of RADMC-3D). You can create these input Ô¨Åles in any way you want. But since many of these
input Ô¨Åles will/must contain huge lists of numbers (for instance, giving the density at each location in your
model), you will typically want to write some script or program in some language (be it either C, C++, Fortran,
IDL, GDL, perl, python, you name it) that automatically creates these input Ô¨Åles. We recommend using Python,
because we provide examples and standard subroutines in the programming language Python; see below for
more details. Section Running the example models describes how to use the example Python scripts to make
these input Ô¨Åles with Python.
3. When all the input Ô¨Åles are created, and we make sure that we are inside the model directory, we call radmc3d
with the desired command-line options (see Chapter Command-line options). This will do the work for us.
4. Once this is done, we can analyze the results by reading the output Ô¨Åles (see Chapter Main input and output Ô¨Åles
of RADMC-3D). To help you reading and analyzing these output Ô¨Åles you can use a set of Python routines that
we created for the user (see Chapter Python analysis tool set and Section Installing the simple Python analysis
tools). But here again, you are free to use any other plotting software and/or data postprocessing packages.
5.8 Running the example models
Often the fastest and easiest way to learn a code is simply to analyze and run a set of example models. They are listed
in the examples directory. Each model occupies a separate directory. This is also the style we normally recommend:
each model should have its own directory. Of course there are also exceptions to this rule, and the user is free to
organize her/his data in any way he/she pleases. But in all the examples and throughout this manual each model has
its own directory.
To run an example model, go into the directory of this model, and follow the directions that are written in the README
Ô¨Åle in each of these directories. This is under the assumption that you have a full Python distribution installed on your
system, including Numpy and Matplotlib.
Let us do for instance run_simple_1/:
cd examples/run_simple_1
Now we must create all the input Ô¨Åles for this model. These input Ô¨Åles are all described in chapter Main input and
output Ô¨Åles of RADMC-3D, but let us here just ‚Äòblindly‚Äô follow the example. In this example most (all except one) of
the input Ô¨Åles are created using a Python script called problem_setup.py. To execute this script, this is what you
do on the shell:
24
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
python problem_setup.py
This Python script has now created a whole series of input Ô¨Åles, all ending with the extension .inp. To see which
Ô¨Åles are created, type the following in the shell:
ls -l *.inp
There is one Ô¨Åle that this example does not create, and that is the Ô¨Åle dustkappa_silicate.inp. This is a Ô¨Åle that
contains the dust opacity in tabulated form. This is a Ô¨Åle that you as the user should provide to the RADMC-3D code
package. The Ô¨Åle dustkappa_silicate.inp is merely an example, which is an amorphous spherical silicate
grain with radius 0.1 micron. But see Section INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp
or dustkapscatmat_*.inp or dust_optnk_*.inp for more information about the opacities.
Now that the input Ô¨Åles are created, we must run radmc3d:
radmc3d mctherm
This tells RADMC-3D to do the thermal Monte Carlo simulation. This may take some time. When the model is ready,
the prompt of the shell returns. To see what Ô¨Åles have been created by this run of the code, type:
ls -l *.dat
You will Ô¨Ånd the dust_temperature.dat containing the dust temperature everywhere in the model. See again
chapter Main input and output Ô¨Åles of RADMC-3D for details of these Ô¨Åles. To create a spectral energy distribution
(SED):
radmc3d sed incl 45.
This will create a Ô¨Åle spectrum.out. To analyze these data you can use the Python routines delivered with the
code (see Chapter Python analysis tool set and Section Installing the simple Python analysis tools).
There is a Ô¨Åle Makefile in the directory. This is here only meant to make it easy to clean the directory. Type make
cleanmodel to clean all the output from the radmc3d code. Type make cleanall to clean the directory back to
basics.
Let us now do for instance model run_simple_1_userdef/:
cd examples/run_simple_1_userdef
This is the same model as above, but now the grid and the dust density are set up inside radmc3d, using the Ô¨Åle
userdef_module.f90 which is present in this directory. See Chapter Modifying RADMC-3D: Internal setup
and user-speciÔ¨Åed radiative processes for details and follow the directions in the README Ô¨Åle.
In short: Ô¨Årst
edit the variable SRC in the Makefile to point to the src/ directory. Then type make. Then type python
problem_setup.py on the shell command line (which now only sets up the frequency grid, the star and the
radmc3d.inp Ô¨Åle and some small stuff). Now you can run the model.
Please read the README Ô¨Åle in each of the example model directories. Everything is explained there, including how
to make the relevant plots.
5.8. Running the example models
25

radmc3d, Release 2.0
26
Chapter 5. Basic structure and functionality

CHAPTER
SIX
DUST CONTINUUM RADIATIVE TRANSFER
Many of the things related to dust continuum radiative transfer have already been said in the previous chapters. But
here we combine these things, and expand with more in-depth information.
Most users simply want RADMC-3D to compute images and spectra from a model. This is done in a two-stage
procedure:
1. First compute the dust temperature everywhere using the thermal Monte Carlo computation (Section The thermal
Monte Carlo simulation: computing the dust temperature).
2. Then making the images and/or spectra (Section Making SEDs, spectra, images for dust continuum).
You can then view the output spectra and images with the Python tools or use your own plotting software.
Some expert users may wish to use RADMC-3D for something entirely different: to compute the local radiation Ô¨Åeld
{em inside} a model, and use this for e.g. computing photochemistry rates of a chemical model or so. This is described
in Section Special-purpose feature: Computing the local radiation Ô¨Åeld.
You may also use the thermal Monte Carlo computation of the dust temperature to help estimating the {em gas}
temperature for the line radiative transfer. See Chapter Line radiative transfer for more on line transfer.
6.1 The thermal Monte Carlo simulation: computing the dust temper-
ature
RADMC-3D can compute the dust temperature using the Monte Carlo method of Bjorkman & Wood (2001, ApJ 554,
615) with various improvements such as the continuous absorption method of Lucy (1999, A&A 344, 282). Once a
model is entirely set up, you can ask radmc3d to do the Monte Carlo run for you by typing in a shell:
radmc3d mctherm
if you use the standard radmc3d code, or
./radmc3d mctherm
if you have created a local version of radmc3d (see Section Making special-purpose modiÔ¨Åed versions of RADMC-3D
(optional)).
What the method does is the following: First all the netto sources of energy (or more accurately: sources of luminosity)
are identiÔ¨Åed. The following net sources of energy can be included:
‚Ä¢ Stars: You can specify any number of individual stars: their position, and their spectrum and luminosity (See
Section INPUT (mostly required): stars.inp). This is the most commonly used source of luminosity, and as a
beginning user we recommend to use only this for now.
27

radmc3d, Release 2.0
‚Ä¢ Continuum stellar source: For simulations of galaxies it would require by far too many individual stars to
properly include the input of stellar light from the billions of stars in the galaxy. To overcome this problem you
can specify a continuously spatially distributed source of stars. NOTE: Still in testing phase.
‚Ä¢ Viscous heating / internal heating: Sometimes the dust grains acquire energy directly from the gas, for instance
through viscous heating of the gas or adiabatic compression of the gas. This can be included as a spatially
distributed source of energy. NOTE: Still in progress... Not yet working.
To compute the dust temperature we must have at least one source of luminosity, otherwise the equilibrium dust
temperature would be everywhere 0.
The next step is that this total luminosity is divided into nphot packages, where nphot is 100000 by default, but can
be set to any value by the user (see the Ô¨Åle radmc3d.inp described in Section INPUT: radmc3d.inp). Then these
photon packages are emitted by these sources one-by-one. As they move through the grid they may scatter off dust
grains and thus change their direction. They may also get absorbed by the dust. If that happens, the photon package
is immediately re-emitted in another direction and with another wavelength. The wavelength is chosen according to
the recipe by Bjorkman & Wood (2001, ApJ 554, 615). The luminosity fraction that each photon package represents
remains, however, the same. Each time a photon package enters a cell it increases the ‚Äòenergy‚Äô of this cell and thus
increases the temperature of the dust of this cell. The recipe for this is again described by Bjorkman & Wood (2001,
ApJ 554, 615), but contrary to that paper we increase the temperature of the dust always when a photon package enters
a cell, while Bjorkman & Wood only increase the dust temperature if a discrete absorption event has taken place. Each
photon package will ping-pong through the model and never gets lost until it escapes the model through the outer edge
of the grid (which, for cartesianl coordinates, is any of the grid edges in ùë•, ùë¶or ùëß, and for spherical coordinates is the
outer edge of ùëü). Once it escapes, a new photon package is launched, until also it escapes. After all photon packages
have been launched and escaped, the dust temperature that remains is the Ô¨Ånal answer of the dust temperature.
One must keep in mind that the temperature thus computed is an equilibrium dust temperature. It assumes that each
dust grain acquires as much energy as it radiates away. This is for most cases presumably a very good approximation,
because the heating/cooling time scales for dust grains are typically very short compared to any time-dependent dy-
namics of the system. But there might be situations where this may not be true: in case of rapid compression of gas,
near shock waves or in extremely optically thick regions.
NOTE: Monte Carlo simulations are based on pseudo-random numbers. The seed for the random number generator is
by default set to -17933201. If you want to perform multiple identical simulations with a different random sequence
you will need to set the seed by hand. This can be done by adding a line
iseed = -5415
(where -5415 is to be replaced by the value you want) to the radmc3d.inp Ô¨Åle.
6.1.1 ModiÔ¨Åed Random Walk method for high optical depths
As you will soon Ô¨Ånd out: very optically thick models make the RADMC-3D thermal Monte Carlo simulations to be
slow. This is because in the thermal Monte Carlo method a photon package is never destroyed unless it leaves the
system. A photon package can thus ‚Äòget lost‚Äô deep inside an optically thick region, making millions (or even billions)
of absorption+reemission or scattering events. Furthermore, you will notice that in order to get the temperatures in
these very optically thick regions to be reliable (i.e. not too noisy) you may need a very large number of photon
packages for your simulation, which slows down the simulation even more. It is hard to prevent such problems. Min,
Dullemond, Dominik, de Koter & Hovenier (2009) A&A 497, 155 discuss two methods of dealing with this problem.
One is a diffusion method, which we will not discuss here. The other is the ‚ÄòModiÔ¨Åed Random Walk‚Äô (MRW) method,
based on the method by Fleck & CanÔ¨Åeld (1984) J.Comput.Phys. 54, 508. Note that Robitaille (2010) A&A 520, 70
presented a simpliÔ¨Åcation of this method. Min et al. Ô¨Årst implemented this method into the MCMax code. It is also
implemented in RADMC-3D, in Robitaille‚Äôs simpliÔ¨Åed form.
The crucial idea of the method is that if a photon package ‚Äògets lost‚Äô deep inside a single ultra-optically-thick cell, we
can use the analytical solutions of the diffusion equation in a constant-density medium to predict where the photon
28
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
package will go next. This thus allows RADMC-3D to make a single large step of the photon package which actually
corresponds to hundreds or thousands of absorption+reemission or scattering events.
The method works best if the optically thick cells are as large as possible. This is because the analytical solutions
are only valid within a single cell, and thus the ‚Äòlarge step‚Äô can not be larger than a single cell size. Moreover, cell
crossings will reduce the step length again to the physical mean free path, so the more cell crossings are made, the less
effective the MRW becomes.
NOTE: The MRW is by default switched off. The reason is that it is, after all, an approximation. However, if RADMC-
3D thinks that the MRW may help speed up the thermal Monte Carlo, it will make the suggestion to the user to switch
on the MRW method.
You can switch on the MRW by adding the following line to the radmc3d.inp Ô¨Åle:
modified_random_walk = 1
6.2 Making SEDs, spectra, images for dust continuum
You can use RADMC-3D for computing spectra and images in dust continuum emission. This is described in detail
in Chapter Making images and spectra. RADMC-3D needs to know not only the dust spatial distribution, given in the
Ô¨Åle dust_density.inp, but also the dust temperature, given in the Ô¨Åle dust_temperature.dat (see Chapter
Binary I/O Ô¨Åles for the binary version of these Ô¨Åles, which are more compact, and which you can use instead of the
ascii versions). The dust_temperature.dat is normally computed by RADMC-3D itself through the thermal
Monte Carlo computation (see Section The thermal Monte Carlo simulation: computing the dust temperature). But
if you, the user, wants to specify the dust temperature at each location in the model youself, then you can simply
create your own Ô¨Åle dust_temperature.dat and skip the thermal Monte Carlo simulation and go straight to the
creation of images or spectra.
The
basic
command
to
make
a
spectrum
at
the
global
grid
of
wavelength
(speciÔ¨Åed
in
the
Ô¨Åle
wavelength_micron.inp, see Section INPUT (required): wavelength_micron.inp) is:
radmc3d sed
You can specify the direction of the observer with incl and phi:
radmc3d sed incl 20 phi 80
which means: put the observer at inclination 20 degrees and ùúë-angle 80 degrees.
You can also make a spectrum for a given grid of wavelength (independent of the global wavelength grid). You Ô¨Årst
create a Ô¨Åle camera_wavelength_micron.inp, which has the same format as wavelength_micron.inp.
You can put any set of wavelengths in this Ô¨Åle without modifying the global wavelength grid (which is used by the
thermal Monte Carlo computation). Then you type
radmc3d spectrum loadlambda
and it will create the spectrum on this wavelength grid. More information about making spectra is given in Chapter
Making images and spectra.
For creating an image you can type
radmc3d image lambda 10
which creates an image at wavelength ùúÜmu`m. More information about making images is given in Chapter Making
images and spectra.
6.2. Making SEDs, spectra, images for dust continuum
29

radmc3d, Release 2.0
Important note: To handle scattering of light off dust grains, the ray-tracing is preceded by a quick Monte Carlo run
that is specially designed to compute the ‚Äòscattering source function‚Äô. This Monte Carlo run is usually much faster
than the thermal Monte Carlo run, but must be done at each wavelength. It can lead, however, to slight spectral noise,
because the random photon paths are different for each wavelength. See Section More about scattering of photons off
dust grains for details.
6.3 OpenMP parallelized Monte Carlo
Depending on the model properties and the number of photon packages used in the simulation the Monte Carlo
calculation (in particular the thermal Monte Carlo, but under some conditions also the scattering Monte Carlo) can be
a time-consuming computation when executed only in a serial mode. To improve this, these Monte Carlo calculations
can be done in OpenMP parallel mode. The loop over photon packages is then distributed amongst the different
threads, where each thread adopts a speciÔ¨Åc number of loop iterations following the order of the thread identiÔ¨Åcation
number. To this end the random number generator was modiÔ¨Åed. The important point for the parallel version is that
different threads must not share the same random seed initially. To be certain that each thread is assigned a different
seed at the beginning, the thread identity number is added to the initial seed.
The default value for the number of threads in the parallel version is set to one, so that the program is identical with
the serial version, except for the random generator‚Äôs initial seed. The user can change the value by either typing
setthreads <nr>, where <nr> is the number of requested threads (integer value) in the command line or by
adding a corresponding line to the radmc3d.inp Ô¨Åle. If the chosen number of threads is larger than the available
number of processor cores, the user is asked to reduce it.
For example, you can ask radmc3d to do the parallelized Monte Carlo run for you by typing in a shell:
radmc3d mctherm setthreads 4
or by adding the following keyword to the radmc3d.inp Ô¨Åle:
setthreads = 4
which means that four threads are used for the thermal Monte Carlo computation.
For the image or spectrum you can do the same: just add setthreads 4 or so on the command line or put
setthreads = 4 into the radmc3d.inp Ô¨Åle.
Make sure that you have included the -fopenmp keyword in the Makefile and have compiled the whole radmc3d
source code with this additional command before using the OpenMP parallelized thermal Monte Carlo version (cf.
Section Compiling the code with ‚Äòmake‚Äô).
6.4 Overview of input data for dust radiative transfer
In order to perform any of the actions described in Sections The thermal Monte Carlo simulation: computing the dust
temperature, Special-purpose feature: Computing the local radiation Ô¨Åeld or Making SEDs, spectra, images for dust
continuum, you must give RADMC-3D the following data:
‚Ä¢ amr_grid.inp: The grid Ô¨Åle (see Section INPUT (required): amr_grid.inp).
‚Ä¢ wavelength_micron.inp:
The global wavelength Ô¨Åle (see Section INPUT (required):
wave-
length_micron.inp).
‚Ä¢ stars.inp: The locations and properties of stars (see Section INPUT (mostly required): stars.inp).
‚Ä¢ dust_density.inp: The spatial distribution of dust on the grid (see Section INPUT (required for dust
transfer): dust_density.inp).
30
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
‚Ä¢ dustopac.inp: A Ô¨Åle with overall information about the various species of dust in the model (see Sec-
tion INPUT (required for dust transfer):
dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or
dust_optnk_*.inp). One of the main pieces of information here is (a) how many dust species are included
in the model and (b) the tag names of these dust species (see dustkappa_XXX.inp below).
The Ô¨Åle
dust_density.inp must contain exactly this number of density distributions: one density distribution for
each dust species.
‚Ä¢ dustkappa_XXX.inp: One or more dust opacity Ô¨Åles (where XXX should in fact be a tag name you de-
Ô¨Åne, for instance dustkappa_silicate.inp). The labels are listed in the dustopac.inp Ô¨Åle. ee
Section INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or
dust_optnk_*.inp for more information.
‚Ä¢ camera_wavelength_micron.inp (optional): This Ô¨Åle is only needed if you want to create a spec-
trum at a special set of wavelengths (otherwise use radmc3d sed).
‚Ä¢ mcmono_wavelength_micron.inp (optional): This Ô¨Åle is only needed if you want to compute the
radiation Ô¨Åeld inside the model by calling radmc3d mcmono (e.g. for photochemistry).
Other input Ô¨Åles could be required in certain cases, but you will then be asked about it by RADMC-3D.
6.5 Special-purpose feature: Computing the local radiation Ô¨Åeld
If you wish to use RADMC-3D for computing the radiation Ô¨Åeld inside the model, for instance for computing photo-
chemical rates in a chemical model, then RADMC-3D can do so by calling RADMC-3D in the following way:
radmc3d mcmono
This computes the mean intensity
ùêΩùúà= 1
4ùúã
‚àÆÔ∏Å
ùêºùúà(‚Ñ¶)ùëë‚Ñ¶
(in units of erg s‚àí1 cm‚àí2 Hz‚àí1 ster‚àí1) as a function of the (ùë•, ùë¶, ùëß) (cartesian) or (ùëü, ùúÉ, ùúë) (spherical) co-
ordinates at frequencies ùúàùëñ
‚â°
104ùëê/ùúÜùëñwhere ùúÜùëñare the wavelengths (in ùúám) speciÔ¨Åed in the Ô¨Åle
mcmono_wavelength_micron.inp (same format as the Ô¨Åle wavelength_micron.inp which is described
in Section INPUT (required): wavelength_micron.inp). The results of this computation can be interesting for, for
instance, models of photochemistry.
The Ô¨Åle that is produced by radmc3d mcmono is called mean_intensity.out and has the following form:
iformat
<=== Typically 2 at present
nrcells
nfreq
<=== Nr of frequencies
freq_1 freq_2 ... freq_nfreq
<=== List of frequencies in Hz
meanint[1,icell=1]
meanint[1,icell=2]
...
meanint[1,icell=nrcells]
meanint[2,icell=1]
meanint[2,icell=2]
...
meanint[2,icell=nrcells]
...
...
...
meanint[nfreq,icell=1]
(continues on next page)
6.5. Special-purpose feature: Computing the local radiation Ô¨Åeld
31

radmc3d, Release 2.0
(continued from previous page)
meanint[nfreq,icell=2]
...
meanint[nfreq,icell=nrcells]
The list of frequencies will, in fact, be the same as those listed in the Ô¨Åle mcmono_wavelength_micron.inp.
Note that if your model is very large, the computation of the radiation Ô¨Åeld on a large set of wavelength could easily
overload the memory of the computer. However, often you are in the end not interested in the entire spectrum at
each location, but just in integrals of this spectrum over some cross section. For instance, if you want to compute
the degree to which dust shields molecular photodissociation lines in the UV, then you only need to compute the total
photodissociation rate, which is an integral of the photodissociation cross section times the radiation Ô¨Åeld. In Section
Using the userdef module to compute integrals of J_\nu it will be explained how you can create a userdef subroutine
(see Chapter Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes) that will do this for you
in a memory-saving way.
There is an important parameter for this Monochromatic Monte Carlo that you may wish to play with:
‚Ä¢ nphot_mono The parameter nphot_mono sets the number of photon packages that are used for the
Monochromatic Monte Carlo simulation. It has as default 100000, but that may be too little for 3-D models.
You can set this value in two ways:
‚Äì In the radmc3d.inp Ô¨Åle as a line nphot_mono = 1000000 for instance.
‚Äì On the command-line by adding nphot_mono 1000000.
6.6 More about scattering of photons off dust grains
Photons can not only be absorbed and re-emitted by dust grains: They can also be scattered. Scattering does nothing
else than change the direction of propagation of a photon, and in case polarization is included, its Stokes parameters.
Strictly speaking it may also slightly change its wavelength, if the dust grains move with considerable speed they may
Doppler-shift the wavelength of the outgoing photon (which may be relevant, if at all, when dust radiative transfer
is combined with line radiative transfer, see chapter Line radiative transfer), but this subtle effect is not treated in
RADMC-3D. For RADMC-3D scattering is just the changing of direction of a photon.
6.6.1 Five modes of treating scattering
RADMC-3D has Ô¨Åve levels of realism of treatment of scattering, starting with scattering_mode=1 (simplest) to
scattering_mode=5 (most realistic):
‚Ä¢ No scattering (scattering_mode=0):
If either the dustkappa_XXX.inp Ô¨Åles do not contain a scattering opacity or scattering is switched off
by setting scattering_mode_max to 0 in the radmc3d.inp Ô¨Åle, then scattering is ignored. It is then
assumed that the dust grains have zero albedo.
‚Ä¢ Isotropic scattering (scattering_mode=1):
If either the dustkappa_XXX.inp Ô¨Åles do not contain information about the anisotropy of the scattering or
anisotropic scattering is switched off by setting scattering_mode_max to 1 in the radmc3d.inp Ô¨Åle,
then scattering is treated as isotropic scattering. Note that this can be a bad approximation.
‚Ä¢ Anisotropic scattering using Henyey-Greenstein (scattering_mode=2):
If the dustkappa_XXX.inp Ô¨Åles contain the scattering opacity and the ùëîparameter of anisotropy (the
Henyey-Greenstein ùëîparameter which is equal, by deÔ¨Ånition, to ùëî= ‚ü®cos ùúÉ‚ü©, where ùúÉis the scattering de-
32
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
Ô¨Çection angle), and scattering_mode_max is set to 2 or higher in the radmc3d.inp Ô¨Åle then anisotropic
scattering is treated using the Henyey-Greenstein approximate formula.
‚Ä¢ Anisotropic scattering using tabulated phase function (scattering_mode=3):
To treat scattering using a tabulated phase function,
you must specify the dust opacities using
dustkapscatmat_XXX.inp Ô¨Åles instead of the simpler dustkappa_XXX.inp Ô¨Åles (see Section The
dustkapscatmat_*.inp Ô¨Åles). You must also set scattering_mode_max is set to 3 or higher.
‚Ä¢ Anisotropic scattering with polarization for last scattering (scattering_mode=4):
To
treat
scattering
off
randomly
oriented
particles
with
the
full
polarization
you
need
to
set
scattering_mode_max is set to 4 or higher, and you must specify the full dust opacity and scattering ma-
trix using the dustkapscatmat_XXX.inp Ô¨Åles instead of the simpler dustkappa_XXX.inp Ô¨Åles (see
Section The dustkapscatmat_*.inp Ô¨Åles). If scattering_mode=4 the full polarization is only done upon
the last scattering before light reaches the observer (i.e. it is only treated in the computation of the scattering
source function that is used for the images, but it is not used for the movement of the photons in the Monte
Carlo simulation). See Section Polarization, Stokes vectors and full phase-functions for more information about
polarized scattering.
‚Ä¢ Anisotropic scattering with polarization, full treatment (scattering_mode=5):
For the full treatment of polarized scattering off randomly oriented particles,
you need to set
scattering_mode_max is set to 5, and you must specify the full dust opacity and scattering matrix us-
ing the dustkapscatmat_XXX.inp Ô¨Åles instead of the simpler dustkappa_XXX.inp Ô¨Åles (see Section
The dustkapscatmat_*.inp Ô¨Åles). See Section Polarization, Stokes vectors and full phase-functions for more
information about polarized scattering. end{enumerate} Please refer to Sections Scattering phase functions
and Polarization, Stokes vectors and full phase-functions for more information about these different scattering
modes.
So in summary: the dust opacity Ô¨Åles themselves tell how detailed the scattering is going to be included. If no scat-
tering information is present in these Ô¨Åles, RADMC-3D has no choice but to ignore scattering. If they only contain
scattering opacities but no phase information (no ùëî-factor), then RADMC-3D will treat scattering in the isotropic ap-
proximation. If the ùëî-factor is also included, then RADMC-3D will use the Henyey-Greenstein formula for anisotropic
scattering. If you specify the full scattering matrix (using the dustkapscatmat_XXX.inp Ô¨Åles instead of the
dustkappa_XXX.inp Ô¨Åles) then you can use tabulated scattering phase functions, and even polarized scattering.
If scattering_mode_max is not set in the radmc3d.inp Ô¨Åle, it is by default 9999, meaning: RADMC-3D will
always use the maximally realistic scattering mode that the dust opacities allow.
BUT you can always limit the realism of scattering by setting the scattering_mode_max to 4, 3, 3, 1 or 0 in the
Ô¨Åle radmc3d.inp. This can be useful to speed up the calculations or be sure to avoid certain complexities of the
full phase-function treatment of scattering.
At the moment there are some limitations to the full anisotropic scattering treatment:
‚Ä¢ Anisotropic scattering in 1-D and 2-D Spherical coordinates:
For 1-D spherical coordinates there is currently no possibility of treating anisotropic scattering in the image-
and spectrum-making. The reason is that the scattering source function (see Section Scattered light in images
and spectra: The ‚ÄòScattering Monte Carlo‚Äô computation) must be stored in an angle-dependent way. However,
for 2-D spherical coordinates, this has been implemented, and for each grid ‚Äòcell‚Äô (actually an annulus) the
scattering source function is now stored for an entire sequence of angles.
‚Ä¢ Full phase functions and polarization only for randomly-oriented particles:
Currently RADMC-3D cannot handle scattering off Ô¨Åxed-oriented non-spherical particles, because it requires a
much more detailed handling of the angles. It would require at least 3 scattering angles (for axially-symmetric
particles) or more (for completely asymmetric particles), which is currently beyond the scope of RADMC-3D.
6.6. More about scattering of photons off dust grains
33

radmc3d, Release 2.0
6.6.2 Scattering phase functions
As mentioned above, for the different scattering_mode settings you have different levels of realism of treating
scattering.
The transfer equation along each ray, ignoring polarization for now, is:
ùëëùêºùúà
ùëëùë†= ùëótherm
ùúà
+ ùëóscat
ùúà
‚àí(ùõºabs
ùúà
+ ùõºscat
ùúà
)ùêºùúà
where ùõºabs
ùúà
and ùõºscat
ùúà
are the extinction coefÔ¨Åcients for absorption and scattering. Let us assume, for convenience of
notation, that we have just one dust species with density dstribution ùúå, absorption opacity ùúÖabs
ùúà
and scattering opacity
ùúÖscat
ùúà
. We then have
ùõºabs
ùúà
‚â°ùúåùúÖabs
ùúà
ùõºscat
ùúà
‚â°ùúåùúÖscat
ùúà
ùëótherm
ùúà
= ùõºabs
ùúà
ùêµùúà(ùëá)
where ùêµùúà(ùëá) is the Planck function. The last equation is an expression of Kirchhoff‚Äôs law.
For isotropic scattering (scattering_mode=1) the scattering source function ùëóscat
ùúà
is given by
ùëóscat
ùúà
= ùõºscat
ùúà
1
4ùúã
‚àÆÔ∏Å
ùêºùúàùëë‚Ñ¶
where the integral is the integral over solid angle. In this case ùëóscat
ùúà
does not depend on solid angle.
For anisotropic scattering (scattering_mode>1) we must introduce the scattering phase function Œ¶(nin, nout),
where nin is the unit direction vector for incoming radiation and nout is the unit direction vector for the scattered
radiation. The scattering phase function is normalized to unity:
1
4ùúã
‚àÆÔ∏Å
Œ¶(nin, nout)ùëë‚Ñ¶out = 1
4ùúã
‚àÆÔ∏Å
Œ¶(nin, nout)ùëë‚Ñ¶in = 1
where we integrated over all possible nout or nin. Then the scattering source function becomes:
ùëóscat
ùúà
(nout) = ùõºscat
ùúà
1
4ùúã
‚àÆÔ∏Å
ùêºùúà(nin)Œ¶(nin, nout)ùëë‚Ñ¶in
which is angle-dependent. The angular dependence means: a photon package has not completely forgotten from which
direction it came before hitting the dust grain.
If we do not include the polarization of radiation and we have randomly oriented particles, then the scattering phase
function will only depend on the scattering (deÔ¨Çection) angle ùúÉdeÔ¨Åned by
cos ùúÉ‚â°ùúá= nout ¬∑ nin
We will thus be able to write
Œ¶(nin, nout) ‚â°Œ¶(ùúá)
where Œ¶(ùúá) is normalized as
1
2
‚à´Ô∏Å+1
‚àí1
Œ¶(ùúá)ùëëùúá= 1
34
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
If we have scattering_mode=2 then the phase function is the Henyey-Greenstein phase function deÔ¨Åned as
Œ¶(ùúá) =
1 ‚àíùëî2
(1 + ùëî2 ‚àí2ùëîùúá)3/2
where the value of the anisotropy parameter ùëîis taken from the dust opacity Ô¨Åle. Note that for ùëî= 0 you get Œ¶(ùúá) = 1
which is the phase function for isotropic scattering.
If we have scattering_mode=3 then the phase function is tabulated by you.
You have to provide the
tabulated phase function as the ùëç11(ùúÉ) scattering matrix element for a tabulated set of ùúÉùëñvalues, and this is
done in a Ô¨Åle dustkapscatmat_xxx.inp (see Section The dustkapscatmat_*.inp Ô¨Åles and note that for
scattering_mode=3 the other ùëçùëñùëóelements can be kept 0 as they are of no consequence). The relation between
ùëç11(ùúÉ) and Œ¶(ùúá) is:
Œ¶(ùúá) ‚â°Œ¶(cos(ùúÉ)) =
4ùúã
ùúÖscat
ùëç11(ùúÉ)
(which holds at each wavelength individually).
If we have scattering_mode=4 then the scattering in the Monte Carlo code is done according to the tabulated
Œ¶(ùúá) mode mentioned above, but for computing the scattering source function the full polarized scattering matrix is
used. See Section Polarization, Stokes vectors and full phase-functions.
If we have scattering_mode=5 then the scattering phase function is not only dependent on ùúábut also on the other
angle. And it depends on the polarization state of the input radiation. See Section Polarization, Stokes vectors and full
phase-functions.
6.7 Scattering of photons in the Thermal Monte Carlo run
So how is scattering treated in practice? In the thermal Monte Carlo model (Section The thermal Monte Carlo simu-
lation: computing the dust temperature) the scattering has only one effect: it changes the direction of propagation of
the photon packages whenever such a photon package experiences a scattering event. This may change the results for
the dust temperatures subtly. In special cases it may even change the dust temperatures more strongly, for instance if
scattering allows ‚Äòhot‚Äô photons to reach regions that would have otherwise been in the shadow. It may also increase
the optical depth of an object and thus change the temperatures accordingly. But this is all there is to it.
If you include the full treatment of polarized scattering (scattering_mode=5), then a photon package also gets
polarized when it undergoes a scattering event. This can affect the phase function for the next scattering event. This
means that the inclusion of the full polarized scattering processes (as opposed to using non-polarized photon packages)
can, at least in principle, have an effect on the dust temperatures that result from the thermal Monte Carlo computation.
This effect is, however, rather small in practice.
6.8 Scattering of photons in the Monochromatic Monte Carlo run
For the monochromatic Monte Carlo calculation for computing the mean intensity radiation Ô¨Åeld (Section Special-
purpose feature: Computing the local radiation Ô¨Åeld) the scattering has the same effect as for the thermal Monte
Carlo model: it changes the direction of photon packages. In this way ‚Äòhot‚Äô radiation may enter regions which would
otherwise have been in a shadow. And by increasing the optical depth of regions, it may increase the local radiation
Ô¨Åeld by the greenhouse effect or decrease it by preventing photons from entering it. As in the thermal Monte Carlo
model the effect of scattering in the monochromatic Monte Carlo model is simply to change the direction of motion
of the radiation Ô¨Åeld, but for the rest nothing differs to the case without scattering. Also here the small effects caused
by polarized scattering apply, like in the thermal Monte Carlo case.
6.7. Scattering of photons in the Thermal Monte Carlo run
35

radmc3d, Release 2.0
6.8.1 Scattered light in images and spectra: The ‚ÄòScattering Monte Carlo‚Äô compu-
tation
For making images and spectra with the ray-tracing capabilities of RADMC-3D (see Section Making SEDs, spectra,
images for dust continuum and Chapter Making images and spectra) the role of scattering is a much more complex one
than in the thermal and monochromatic Monte Carlo runs. The reason is that the scattered radiation will eventually
end up on your images and spectra.
If we want to make an image or a spectrum, then for each pixel we must integrate Eq. (eq-ray-tracing-rt) along
the 1-D ray belonging to that pixel. If we performed the thermal Monte Carlo simulation beforehand (or if we speciÔ¨Åed
the dust temperatures by hand) we know the thermal source function through Eq. (eq-thermal-source-function). But
we have, at that point, no information yet about the scattering source function. The thermal Monte Carlo calculation
{em could} have also stored this function at each spatial point and each wavelength and each observer direction, but
that would require gigantic amounts of memory (for a typical 3-D model it might be many Gbytes, going into the
Tbyte regime). So in RADMC-3D the scattering source function is {em not} computed during the thermal Monte
Carlo run.
In RADMC-3D the scattering source function ùëóscat
ùúà
(‚Ñ¶‚Ä≤) is computed {em just prior to} the ray-tracing through a
brief ‚ÄòScattering Monte Carlo‚Äô run. This is done {em automatically} by RADMC-3D, so you don‚Äôt have to worry
about this. Whenever you ask RADMC-3D to make an image (and if the scattering is in fact included in the model,
see Section Five modes of treating scattering), RADMC-3D will automatically realize that it requires knowledge of
ùëóscat
ùúà
(‚Ñ¶‚Ä≤), and it will start a brief single-wavelength Monte Carlo simulation for computing ùëóscat
ùúà
(‚Ñ¶‚Ä≤). This single-
wavelength ‚ÄòScattering Monte Carlo‚Äô simulation is relatively fast compared to the thermal Monte Carlo simulation,
because photon packages can be destroyed by absorption. So photon packages do not bounce around for long, as
they do in the thermal Monte Carlo simulation. This Scattering Monte Carlo simulation is in fact very similar to
the monochromatic Monte Carlo model described in Section Special-purpose feature: Computing the local radiation
Ô¨Åeld. While the monochromatic Monte Carlo model is called speciÔ¨Åcally by the user (by calling RADMC-3D with
radmc3d mcmono), the Scattering Monte Carlo simulation is not something the user must specify him/her-self: it
is automatically done by RADMC-3D if it is needed (which is typically before making an image or during the making
of a spectrum). And while the monochromatic Monte Carlo model returns the mean intensity inside the model, the
Scattering Monte Carlo simulation provides the raytracing routines with the scattering source function but does not
store this function in a Ô¨Åle.
You can see this happen if you have a model with scattering opacity included, and you make an image with RADMC-
3D, you see that it prints 1000, 2000, 3000, ... etc., in other words, it performs a little Monte Carlo simulation
before making the image.
There is an important parameter for this Scattering Monte Carlo that you may wish to play with:
‚Ä¢ nphot_scat
The parameter nphot_scat sets the number of photon packages that are used for the Scattering Monte Carlo
simulation. It has as default 100000, but that may be too little for 3-D models and/or cases where you wish
to reduce the ‚Äòstreaky‚Äô features sometimes visible in scattered-light images when too few photon packages are
used. You can set this value in two ways:
‚Äì In the radmc3d.inp Ô¨Åle as a line nphot_scat = 1000000 for instance.
‚Äì On the command-line by adding nphot_scat 1000000.
In Figure Fig. 6.1 you can see how the quality of an image in scattered light improves when increasing
nphot_scat.
‚Ä¢ nphot_spec
The parameter nphot_spec is actually exactly the same as nphot_scat, but is used (and used only!) for
the creation of spectra. The default is 10000, i.e. substantially smaller than nphot_scat. The reason for this
separate parameter is that if you make spectra, you integrate over the image to obtain the Ô¨Çux (i.e. the value of
the spectrum at that wavelength). Even if the scattered light image may look streaky, the integral may still be
36
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
accurate. We can thus afford much fewer photon packages when we make spectra than when we make images,
and can thus speed up the calculation of the spectrum. You can set this value in two ways:
‚Äì In the radmc3d.inp Ô¨Åle as a line nphot_spec = 100000 for instance.
‚Äì On the command-line by adding nphot_spec 100000.
NOTE: It may be possible to get still very good results with even smaller values of nphot_spec than the
default value of 10000. That might speed up the calculation of the spectrum even more in some cases. On
the other hand, if you notice ‚Äònoise‚Äô on your spectrum, you may want to increase nphot_spec. If you are
interested in an optimal balance between accuracy (high value of nphot_spec) and speed of calculation (low
value of nphot_spec) then it is recommended to experiment with this value. If you want to be on the safe
side, then set nphot_spec to a high value (i.e. set it to 100000, as nphot_spec).
Nphot=1000000
Nphot=1000
Nphot=10000
Nphot=100000
Fig. 6.1: The effect of nphot_scat on the image quality when the image is dominated by scattered light. The images
show the result of model examples/run_simple_2_scatmat at ùúÜ= 0.84ùúám in which polarized scattering with
the full scattering phase function and scattering matrix is used. See Section Polarization, Stokes vectors and full phase-
functions about the scattering matrices for polarized scattering. See Section Single-scattering vs. multiple-scattering
for a discussion about the ‚Äòscratches‚Äô seen in the top two panels.
WARNING: At wavelengths where the dominant source of photons is thermal dust emission but scattering is still
important (high albedo), it cannot be excluded that the ‚Äòscattering monte carlo‚Äô method used by RADMC-3D produces
very large noise. Example: a very optically thick dust disk consisting of large grains (10 ùúám size), producing thermal
dust emission in the near infrared in its inner disk regions. This thermal radiation can scatter off the large dust grains at
large radii (where the disk is cold and where the only ‚Äòemission‚Äô in the near-infrared is thus the scattered light) and thus
reveal the outer disk in scattered light emerging from the inner disk. However, unless nphot_scat is huge, most
thermally emitted photons from the inner disk will be emitted so deeply in the disk interior (i.e. below the surface)
that they will be immediately reabsorbed and lost. This means that that radiation that does escape is extremely noisy.
The corresponding scattered light source function at large radii is therefore very noisy as well, unless nphot_scat
is taken to be huge. Currently no elegant solution is found, but maybe there will in the future. Stay tuned...
NOTE: Monte Carlo simulations are based on pseudo-random numbers. The seed for the random number generator is
by default set to -17933201. If you want to perform multiple identical simulations with a different random sequence
you will need to set the seed by hand. This can be done by adding a line
6.8. Scattering of photons in the Monochromatic Monte Carlo run
37

radmc3d, Release 2.0
iseed = -5415
(where -5415 is to be replaced by the value you want) to the radmc3d.inp Ô¨Åle.
6.8.2 Single-scattering vs. multiple-scattering
If scattering is included in the images and spectra, the Monte Carlo run computes the full multiple-scattering prob-
lem. Photon packages are followed as they scatter and change their direction (possibly many times) until they es-
cape to inÔ¨Ånity or until they are extincted by many orders of magnitude (the exact extinction limit can be set by
mc_scat_maxtauabs, which by default is set to 30, meaning a photon package is considered extincted when it has
travelled an absorption optical depth of 30).
Important note: In many (most?) cases this default value of mc_scat_maxtauabs=30 is overly conservative.
Especially when the scattering Monte Carlo is very time-consuming, you may want to experiment with a lower value.
Try adding a line to the radmc3d.inp with:
mc_scat_maxtauabs = 5
This may speed up the scattering Monte Carlo by up to a factor of 6, while still yielding reasonable results.
It can be useful to Ô¨Ågure out how important the effect of multiple scattering in an image is compared to single scattering.
For instance: a protoplanetary disk with a ‚Äòself-shadowed‚Äô geometry will show some scattering even in the shadowed
region because some photon packages scatter {em into} the shadowed region and then scatter into the line of sight. To
Ô¨Ågure out if this is indeed what happens, you can make two images: one normal image with
radmc3d image lambda 1.0
cp image.out image_fullscat.out
and then another image which only treats single scattering:
radmc3d image lambda 1.0 maxnrscat 1
cp image.out image_singlescat.out
The command-line option maxnrscat 1 tells RADMC-3D to stop following photon packages once they hit their
Ô¨Årst discrete scattering event. You can also check out the effect of single- and double-scattering (but excluding triple
and higher order scattering) with: maxnrscat 2, etc.
Note that multiple scattering may require a very high number of photon packages (i.e. setting nphot_scat to a very
high number). For single scattering with too low nphot_scat you typically see radial ‚Äòrays‚Äô in the image emanating
from each stellar source of photons. For multiple scattering, when taking too low nphot_scat small you would see
strange non-radial ‚Äòscratches‚Äô in the image (see Fig. Fig. 6.1, top two images). It looks as if someone has used a pen
and randomly added some streaks. These streaks are the double-scattering events which, in that case, apparently are
rare enough that they show up as individual streaks. To test whether these streaks are indeed such double scattering
events, you can use maxnrscat 1, and they should disappear. If the streaks are indeed very few, it may turn out
that the single-scattering image (maxnrscat 1) is almost already the correct image. The double scattering is then
only a minor addition to the image, but due to the Ô¨Ånite Monte Carlo noise it would yield annoying streaks which ruin
a nice image. If you are {em very sure} that the second scattering and higher-order scattering are only a very minor
effect, then you might use the maxnrscat 1 image as the Ô¨Ånal image. By comparing the Ô¨Çux in the images with
full scattering and single scattering you can estimate how important the multiple-scattering contribution is compared
to single scattering. But of course, it is always safer to simply increase nphot_scat and patiently wait until the
Monte Carlo run is Ô¨Ånished.
38
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.8.3 SimpliÔ¨Åed single-scattering mode (spherical coordinates)
If you are sure that multiple scattering is rare (low albedo and/or low optical depth), then you may be interested in
using a simpler (non-Monte-Carlo) mode for including scattering in your images. But please Ô¨Årst read Section Single-
scattering vs. multiple-scattering and test if multiple scattering is indeed unimportant. If so, and if you are using
spherical coordinates, a single star at the center which is point-like, and if you are conÔ¨Ådent that at the wavelength you
are interested in the thermal dust emission is not strong enough to be a considerable source of light that can be scattered
into the line-of-sight (i.e. all scattered light is scattered star light), then you can use the simpliÔ¨Åed single-scattering
mode.
This mode does not use the Monte Carlo method to compute the scattering source function, but instead uses direct
integration of the starlight through the grid. It is much faster than Monte Carlo, and it does not contain noise.
By adding simplescat to the command line when making an image or spectrum, you switch this mode on. Please
compare Ô¨Årst to the single-scattering Monte Carlo method (see Section Single-scattering vs. multiple-scattering; it
should yield very similar result, but without noise) and then to the full multiple scattering Monte Carlo. The full
multiple scattering case will likely produce more Ô¨Çux. If the difference is large, then you should not use the simple
single scattering mode. However, if the difference is minor, then the single scattering approximation is reasonable.
6.8.4 Warning when using an-isotropic scattering
An important issue with anisotropic scattering is that if the phase function is very forward-peaked, then you may get
problems with the spatial resolution of your model: it could then happen that one grid cell may be too much to the
left to ‚Äòbeam‚Äô the scattered light into your line of sight, while the next grid point will be too much to the right. A
proper treatment of strongly anisotropic scattering therefore requires also a good check of the spatial resolution of
your model. There are, however, also two possible tricks (approximations) to prevent problems. They both involve
slight modiÔ¨Åcations of the dust opacity Ô¨Åles:
‚Ä¢ You can simply assure in the opacity Ô¨Åles that the forward peaking of the phase function has some upper limit.
‚Ä¢ Or you can simply treat extremely forward-peaked scattering as no scattering at all (simply setting the scattering
opacity to zero at those wavelengths).
Both ‚Äòtricks‚Äô are presumably reasonable and will not affect your results, unless you concentrate in your modeling very
much on the angular dependence of the scattering.
6.8.5 For experts: Some more background on scattering
The inclusion of the scattering source function in the images and spectra is a non-trivial task for RADMC-3D because
of memory constraints. If we would have inÔ¨Ånite random access memory, then the inclusion of scattering in the images
and spectra would be relatively easy, as we could then store the entire scattering source function ùëóscat(ùë•, ùë¶, ùëß, ùúà, ‚Ñ¶) and
use what we need at any time. But as you see, this function is a 6-dimensional function: three spatial dimensions, one
frequency and one angular direction (which consists of two angles). For any respectable model this function is far too
large to be stored. So nearly all the ‚Äònumerical logistic‚Äô complexity of the treatment of scattering comes from various
ways to deal with this problem. In principle RADMC-3D makes the choices of which method to use itself, so the user
is not bothered with it. But depending on which kind of model the user sets up, the performance of RADMC-3D may
change as a result of this issue.
So here are a few hints as to the internal workings of RADMC-3D in this regard. You do not have to read this, but it
may help understanding the performance of RADMC-3D in various cases.
‚Ä¢ Scattering in spectra and multi-wavelength images
If no scattering is present in the model (see Section Five modes of treating scattering), then RADMC-3D
can save time when making spectra and/or multi-wavelength images. I will then do each integration of Eq.
(eq-ray-tracing-rt) directly for all wavelengths at once before going to the next pixel. This saves some
6.8. Scattering of photons in the Monochromatic Monte Carlo run
39

radmc3d, Release 2.0
time because RADMC-3D then has to calculate the geometric stuff (how the ray moves through the model) just
once for each ray. If, however, scattering is included, the scattering source function must be computed using the
Scattering Monte Carlo computation. Since for large models it would be too memory consuming (in particular
for 3-D models) to store this function for all positions and all wavelengths, it must do this calculation one-by-
one for each wavelength, and calculate the image for that wavelength, and then go off to the next wavelength.
This means that for each ray (pixel) the geometric computations (where the ray moves through the model) has
to be redone for each new wavelength. This may slow down the code a bit.
‚Ä¢ Anisotropic scattering and multi-viewpoint images
Suppose we wish to look at an object at one single wavelength, but from a number of different vantage points. If
we have {em isotropic} scattering, then we need to do the Scattering Monte Carlo calculation just once, and we
can make multiple images at different vantage points with the same scattering source function. This saves time,
if you use the ‚Äòmovie‚Äô mode of RADMC-3D (Section Multiple vantage points: the ‚ÄòMovie‚Äô mode). However,
if the scattering is anisotropic, then the source function would differ for each vantage point. In that case the
scattering source function must be recalculated for each vantage point. There is, deeply hidden in RADMC-3D,
a way to compute scattering source functions for multiple vantage points within a single Scattering Monte Carlo
run, but for the moment this is not yet activated. end{itemize}
6.9 Polarization, Stokes vectors and full phase-functions
The module in RADMC-3D that deals with polarization (polarization_module.f90) is based on code de-
veloped by Michiel Min for his MCMAX code, and has been used and modiÔ¨Åed for use in RADMC-3D with his
permission.
Radiative transfer of polarized radiation is a relatively complex issue. A good and extensive review on the details of
polarization is given in the book by Mishchenko, Travis & Lacis, ‚ÄòScattering, Absorption and Emission of Light by
Small Particles‚Äô, 2002, Cambridge University Press (also electronically available on-line). Another good book (and a
classic!) is the book by Bohren & Huffman ‚ÄòAbsorption and scattering of light by small particles‚Äô, Wiley-VCH. Finally,
the ultimate classic is the book by van de Hulst ‚ÄòLight scattering by small particles‚Äô, 1981. For some discussions on
how polarization can be built in into radiative transfer codes, see e.g. Wolf, Voshchinnikov & Henning (2002, A&A
385, 365).
When we wish to include polarization in our model we must follow not just the intensity ùêºof light (or equivalently,
the energy ùê∏of a photon package), but the full Stokes vector (ùêº, ùëÑ, ùëà, ùëâ) (see review above for deÔ¨Ånitions, or any
textbook on radiation processes). If a photon scatters off a dust grain, then the scattering angular probability density
function depends not only on the scattering angle ùúá, but also on the input state of polarization, i.e. the values of
(ùêº, ùëÑ, ùëà, ùëâ). And the output polarization state will be modiÔ¨Åed. Moreover, even if we would not be interested in
polarization at all, but we {em do} want to have a correct scattering phase function, we need to treat polarization,
because a Ô¨Årst scattering will polarize the photon, which will then have different angular scattering probability in the
next scattering event. Normally these effects are very small, so if we are not particularly interested in polarization, one
can usually ignore this effect without too high a penalty in reliability. But if one wants to be accurate, there is no way
around a full treatment of the (ùêº, ùëÑ, ùëà, ùëâ).
Interaction between polarized radiation with matter happens through so-called M√ºller matrices, which are 4 √ó 4
matrices that can be multiplied by the (ùêº, ùëÑ, ùëà, ùëâ) vector. More on this later.
It is important to distinguish between two situations:
1. The simplest case (and fortunately applicable in many cases) is if all dust particles are randomly oriented,
and there is no preferential helicity of the dust grains (i.e. for each particle shape there are equal numbers
of particles with that shape and with its mirror copy shape). This is also automatically true if all grains are
spherically symmetric. In this case the problem of polarized radiative transfer simpliÔ¨Åes in several ways:
‚Ä¢ The scattering M√ºller matrix simpliÔ¨Åes, and contains only 6 independent matrix elements (see later). More-
over, these matrix elements depend only on a single angle: the scattering angle ùúÉ, and of course on the
40
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
wavelength. This means that the amount of information is small enough that these M√ºller matrix elements
can be stored in computer memory in tabulated form, so that they do not have to be calculated real-time.
‚Ä¢ The total scattering cross section is independent of the input polarization state. Only the output radiation
(i.e. in which direction the photon will scatter) depends on the input polarization state.
‚Ä¢ The absorption cross section is the same for all components of the (ùêº, ùëÑ, ùëà, ùëâ)-vector. In other words: the
absorption M√ºller matrix is the usual scalar absorption coefÔ¨Åcient times the unit matrix.
The last two points assure that most of the structure of the RADMC-3D code for non-polarized radiation can
remain untouched. Only for computing the new direction and polarization state of a photon after a scattering
event in the Monte Carlo module, as well as for computing the scattering source function in the Monte Carlo
module (for use in the camera module) we must do extra work. Thermal emission and thermal absorption remain
the same, and computing optical depths remains also the same.
2. A (much!) more complex situation arises if dust grains are non-spherical and are somehow aligned due to
external forces. For instance, particles tend to align themselves in the interstellar medium if strong enough
magnetic Ô¨Åelds are present. Or particles tend to align themselves due to the combination of gravity and friction
if they are in a planetary/stellar atmosphere. Here are the ways in which things become more complex:
‚Ä¢ All the scattering M√ºller matrix components will become non-zero and independent. We will thus get 16
independent variables.
‚Ä¢ The matrix elements will depend on four angles, of which one can, in some cases, be removed due to
symmetry (e.g. if we have gravity, there is still a remaining rotational symmetry; same is true of particles
are aligned by a ‚Éóùêµ-Ô¨Åeld; but if both gravity and a ‚Éóùêµ-Ô¨Åeld are present, this symmetry may get lost). It will
in most practical circumstances not be possible to precalculate the scattering M√ºller matrix beforehand
and tabulate it, because there are too many variables. The matrix must be computed on-the-Ô¨Çy.
‚Ä¢ The total scattering cross section now does depend on the polarization state of the input photon, and on the
incidence angle. This means that scattering extinction becomes anisotropic.
‚Ä¢ Thermal emission and absorption extinction will also no longer be isotropic. Moreover, they are no longer
scalar: they are described by a non-trivial M√ºller matrix.
The complexity of this case is rather large. As of version 0.41 we have included polarized thermal emission by
aligned grains (see Section Polarized emission and absorption by aligned grains), and we will implement more
of the above mentioned aspects of aligned grains step by step.
6.9.1 DeÔ¨Ånitions and conventions for Stokes vectors
There are different conventions for how to set up the coordinate system and deÔ¨Åne the Stokes vectors. Our deÔ¨Ånition
follows the IAU 1974 deÔ¨Ånition as described in Hamaker & Bregman (1996) A&AS 117, pp.161.
In this convention the ùë•‚Ä≤ axis points to the north on the sky, while the ùë¶‚Ä≤ axis points to the east on the sky (but see
the ‚Äòimportant note‚Äô below). The ùëß‚Ä≤ axis points to the observer. This coordinate system is positively right-handed.
The radiation moves toward positive ùëß‚Ä≤. Angles in the (ùë•‚Ä≤, ùë¶‚Ä≤) plane are measured counter-clockwise (angle=0 means
positive ùë•‚Ä≤ direction, angle=ùúã/2 means positive ùë¶‚Ä≤ direction).
In the following we will (still completely consistent with the IAU deÔ¨Ånitions above, see the ‚Äòimportant note‚Äô below)
deÔ¨Åne ‚Äúup‚Äù to be positive ùë¶‚Ä≤ and ‚Äúright‚Äù to be positive ùë•‚Ä≤. So, the (ùë•‚Ä≤, ùë¶‚Ä≤) coordinates are in a plane perpendicular to
the photon propagation, and oriented as seen by the observer of that photon. So the direction of propagation is toward
you, while ùë¶‚Ä≤ points up and ùë•‚Ä≤ points to the right, just as one would normally orient it.
Important Note: This is fully equivalent to adjusting the IAU 1974 deÔ¨Ånition to have ùë•‚Ä≤ pointing west and ùë¶‚Ä≤ pointing
north, which is perhaps more intuitive, since most images in the literature have this orientation. So for convenience of
communication, let us simply adjust the IAU 1974 deÔ¨Ånition to have positive ùë•‚Ä≤ (‚Äòright‚Äô) pointing west and positive ùë¶‚Ä≤
(‚Äòup‚Äô) pointing north. It will have no further consequences for the deÔ¨Ånitions and internal workings of RADMC-3D
because RADMC-3D does not know what ‚Äònorth‚Äô and ‚Äòeast‚Äô are.
6.9. Polarization, Stokes vectors and full phase-functions
41

radmc3d, Release 2.0
The (ùëÑ, ùëà) deÔ¨Ånition (linear polarization) is such that a linearly polarized ray with ùëÑ= +ùêº, ùëà= ùëâ= 0 has the
electric Ô¨Åeld in the (ùë•‚Ä≤, ùë¶‚Ä≤) = (1, 0) direction, while ùëÑ= ‚àíùêº, ùëà= ùëâ= 0 has the electric Ô¨Åeld in the (ùë•‚Ä≤, ùë¶‚Ä≤) = (0, 1)
direction. If we have ùëÑ= 0, ùëà= +ùêº, ùëâ= 0 then the E-Ô¨Åeld points in the ùë•‚Ä≤ = ùë¶‚Ä≤ direction, while ùëÑ= 0, ùëà= ‚àíùêº,
ùëâ= 0 the E-Ô¨Åeld points in the ùë•‚Ä≤ = ‚àíùë¶‚Ä≤ direction (see Figure 1 of Hamaker & Bregman 1996).
The (ùëâ) deÔ¨Ånition (circular polarization) is such that (quoting directly from the Hamaker & Bregman paper): For
right-handed circularly polarized radiation, the position angle of the electric vector at any point increases with time;
this implies that the ùë¶‚Ä≤ component of the Ô¨Åeld lags the ùë•‚Ä≤ component. Also the electric vectors along the line of sight
form a left-handed screw. The Stokes ùëâis positive for right-handed circular polarization.
Angle>0 definition
+x‚Äô
‚àíx‚Äô
+y‚Äô
‚àíy‚Äô
Q=0, U=+I, V=0
+x‚Äô
+y‚Äô
‚àíy‚Äô
Q=+I, U=0, V=0
Q=0, U=0, V=+I
‚àíx‚Äô
+x‚Äô
‚àíx‚Äô
+y‚Äô
‚àíy‚Äô
+x‚Äô
‚àíx‚Äô
+y‚Äô
‚àíy‚Äô
Œ±
Fig. 6.2: The deÔ¨Ånition of the Stokes parameters used in RADMC-3D, which is consistent with the IAU 1974 deÔ¨Å-
nitions (see Hamaker & Bregman (1996) A&AS 117, pp.161). First panel shows that positive angle means counter-
clockwise. In the second to fourth panels the fat lines show how the tip of the real electric Ô¨Åeld vector goes as a
function of time for an observer at a Ô¨Åxed location in space watching the radiation. The radiation moves toward the
reader. We call the second panel (ùëÑ= +ùêº) ‚Äòhorizontally polarized‚Äô, the third panel (ùëà= +ùêº) ‚Äòdiagonally polar-
ized by +45 degrees‚Äô and the fourth panel (ùëâ= +ùêº) ‚Äòright-handed circularly polarized‚Äô. In the images produced by
RADMC-3D (image.out, see Section OUTPUT: image.out or image_****.out and Fig. Fig. 8.1) the ùë•‚Ä≤ direction
is the horizontal direction and the ùë¶‚Ä≤ direction is the vertical direction.
We can put these deÔ¨Ånitions into the standard formulae:
ùëÑ= ùêºcos(2ùõΩ) cos(2ùúí)
ùëà= ùêºcos(2ùõΩ) sin(2ùúí)
ùëâ= ùêºsin(2ùõΩ)
The angle ùúíis the angle of the E-Ô¨Åeld in the (ùë•‚Ä≤, ùë¶‚Ä≤) coordinates, measured counter-clockwise from ùë•‚Ä≤ (consistent with
our deÔ¨Ånition of angles). Example: ùúí= 45 deg = ùúã/4, then cos(2ùúí) = 0 and sin(2ùúí) = 1, meaning that ùëÑ= 0 and
ùëà/ùêº= +1. Indeed this is consistent with the above deÔ¨Ånition that ùëà/ùêº= +1 is ùê∏‚Ä≤
ùë•= ùê∏‚Ä≤
ùë¶.
The angle 2ùõΩis the phase difference between the ùë¶‚Ä≤-component of the E-Ô¨Åeld and the ùë•‚Ä≤-component of the E-Ô¨Åeld such
that for 0 < ùõΩ< ùúã/2 the E-Ô¨Åeld rotates in a counter-clockwise sense. In other words: the ùë¶‚Ä≤-wave lags 2ùõΩbehind the
ùë•‚Ä≤ wave. Example: if we have ùõΩ= ùúã/4, i.e. 2ùõΩ= ùúã/2, then cos(2ùõΩ) = 0 and sin(2ùõΩ) = 1, so we have ùëÑ= ùëà= 0
and ùëâ/ùêº= +1. This corresponds to the ùë¶‚Ä≤ wave being lagged ùúã/2 behind the ùë•‚Ä≤ wave, meaning that we have a counter-
clockwise rotation. If we use the right-hand-rule and point the thumb into the direction of propagation (toward us)
then the Ô¨Ångers indeed point in counter-rotating direction, meaning that ùëâ/ùêº= +1 is righthanded polarized radiation.
In terms of the real electric Ô¨Åelds of a plane monochromatic wave:
ùê∏‚Ä≤
ùë•(ùë°) = ùê∏‚Ñécos(ùúîùë°‚àí‚àÜ‚Ñé)
ùê∏‚Ä≤
ùë¶(ùë°) = ùê∏ùë£cos(ùúîùë°‚àí‚àÜùë£)
(with ùê∏‚Ñé> 0 and ùê∏ùë£> 0 and ‚àÜ‚Ñé,ùë£are the phase lags of the components with respect to some arbitrary phase) we
42
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
can write the Stokes components as:
ùêº= ùê∏2
‚Ñé+ ùê∏2
ùë£
ùëÑ= ùê∏2
‚Ñé‚àíùê∏2
ùë£
ùëà= 2ùê∏‚Ñéùê∏ùë£cos(‚àÜ)
ùëâ= 2ùê∏‚Ñéùê∏ùë£sin(‚àÜ)
with ‚àÜ= ‚àÜùë£‚àí‚àÜ‚Ñé= 2ùõΩ.
In terms of the {em complex} electric Ô¨Åelds of a plane monochromatic wave (the sign before the ùëñùúîùë°is important):
ùê∏‚Ä≤
ùë•(ùë°) = ùê∏‚Ñéùëíùëñ(Œî‚Ñé‚àíùúîùë°)
ùê∏‚Ä≤
ùë¶(ùë°) = ùê∏ùë£ùëíùëñ(Œîùë£‚àíùúîùë°)
(with ùê∏‚Ñé> 0 and ùê∏ùë£> 0 real numbers and ‚àÜ‚Ñé,ùë£are the phase lags of the components with respect to some arbitrary
phase) we can write the Stokes components as:
ùêº= ‚ü®ùê∏ùë•‚Ä≤ùê∏*
ùë•‚Ä≤ + ùê∏ùë¶‚Ä≤ùê∏*
ùë¶‚Ä≤‚ü©
ùëÑ= ‚ü®ùê∏ùë•‚Ä≤ùê∏*
ùë•‚Ä≤ ‚àíùê∏ùë¶‚Ä≤ùê∏*
ùë¶‚Ä≤‚ü©
ùëà= ‚ü®ùê∏ùë•‚Ä≤ùê∏*
ùë¶‚Ä≤ + ùê∏ùë¶‚Ä≤ùê∏*
ùë•‚Ä≤‚ü©
ùëâ= ùëñ‚ü®ùê∏ùë•‚Ä≤ùê∏*
ùë¶‚Ä≤ ‚àíùê∏ùë¶‚Ä≤ùê∏*
ùë•‚Ä≤‚ü©
6.9.2 Our conventions compared to other literature
The IAU 1974 deÔ¨Ånition is different from the deÔ¨Ånitions used in the Planck mission, for instance. So be careful. There
is something said about this on the website of the healpix software http://healpix.jpl.nasa.gov/html/intronode12.htm .
Our deÔ¨Ånition is also different from the Mishchenko book and papers (see below).
Compared to the books of
Mishchenko and Bohren & Huffman, our deÔ¨Ånitions are:
ùêºours = ùêºmishch = ùêºbohrenhuffman
ùëÑours = ùëÑmishch = ùëÑbohrenhuffman
ùëàours = ‚àíùëàmishch = ‚àíùëàbohrenhuffman
ùëâours = ‚àíùëâmishch = ‚àíùëâbohrenhuffman
As you see: only the ùëàand ùëâchange sign. For a 4 √ó 4 M√ºller matrix ùëÄthis means that the ùëÄùêºùêº, ùëÄùêºùëÑ, ùëÄùëÑùêº, ùëÄùëÑùëÑ,
as well as the ùëÄùëàùëà, ùëÄùëàùëâ, ùëÄùëâùëà, ùëÄùëâùëâstay the same, while ùëÄùêºùëà, ùëÄùêºùëâ, ùëÄùëÑùëà, ùëÄùëÑùëâ, as well as ùëÄùëàùêº, ùëÄùëàùëÑ, ùëÄùëâùêº,
ùëÄùëâùëÑcomponents would Ô¨Çip sign.
Compared to Mishchenko, Travis & Lacis book, what we call ùë•‚Ä≤ they call ùúÉand what we call ùë¶‚Ä≤ they call ùúë. In their
Figure 1.3 (which describes the deÔ¨Ånition of the Stokes parameters) they have the ùúÉdirection pointing downward,
rather than toward the right, i.e. rotated by 90 degrees clockwise compared to RADMC-3D. However, since RADMC-
3D does not know what ‚Äòright‚Äô or ‚Äòdown‚Äô are (only what ùë•‚Ä≤ and ùë¶‚Ä≤ are) this rotation is merely a difference in how
we plot things in a Ô¨Ågure, and has no consequences for the results, as long as we deÔ¨Åne how ùë•‚Ä≤ and ùë¶‚Ä≤ are oriented
compared to our model (see Fig. Fig. 8.1 where ùë•image is our ùë•‚Ä≤ here and likewise for ùë¶‚Ä≤).
Bohren & Huffman have the two unit vectors plotted in the following way: e‚Äñ is plotted horizontally to the left and e‚ä•
is plotted vertically upward. Compared to us, our ùë•‚Ä≤ points toward {em minus} their e‚Äñ, while our ùë¶‚Ä≤ points toward
their e‚ä•, but since they plot their e‚Äñ to the left, the orientation of our plot and their plots are consistent (i.e. if they say
‚Äòpointing to the right‚Äô, they mean the same direction as we). But their deÔ¨Ånition of ‚Äòright-handed circular polarization‚Äô
(clockwise when seen toward the source of the radiation) is our ‚Äòleft handed‚Äô.
The book by Wendisch & Yang ‚ÄòTheory of Atmospheric Radiative Transfer‚Äô uses the same conventions as Bohren &
Huffman, but their basis vector e‚Äñ is plotted vertically and e‚ä•is plotted horizontally to the right. This only affects
what they call ‚Äòhorizontal‚Äô and ‚Äòvertical‚Äô but the math stays the same.
6.9. Polarization, Stokes vectors and full phase-functions
43

radmc3d, Release 2.0
Our deÔ¨Ånition is identical to the one on the English Wikipedia page on Stokes parameters http://en.wikipedia.org/wiki/
Stokes_parameters (on 2 January 2013), with the only exception that what they call ‚Äòrighthanded‚Äô circularly polarized,
we call ‚Äòlefthanded‚Äô. This is just a matter of nomenclature of what is right/left-handed, and since RADMC-3D does not
know what ‚Äòright/lefthanded‚Äô is, this difference has no further consequences. Note, however, that the same Wikipedia
page in different languages use different conventions! For instance, the German version of the page (on 2 January
2013) has the same Q and U deÔ¨Ånitions, but has the sign of V Ô¨Çipped.
Note that in RADMC-3D we have no global deÔ¨Ånition of the orientation of ùë•‚Ä≤ and ùë¶‚Ä≤ (see e.g. Section DeÔ¨Åning
orientation for non-observed radiation). If we make an image with RADMC-3D, then the horizontal (x-) direction in
the image corresponds to ùë•‚Ä≤ and the vertical (y-) direction corresponds to ùë¶‚Ä≤, just as one would expect. So if you obtain
an image from RADMC-3D and all the pixels in the image have ùëÑ= ùêºand ùëà= ùëâ= 0, then the electric Ô¨Åeld points
horizontally in the image.
6.9.3 DeÔ¨Åning orientation for non-observed radiation
To complete our description of the Stokes parameters we still need to deÔ¨Åne in which direction we let ùë•‚Ä≤ and ùë¶‚Ä≤ point
if we do not have an obvious observer, i.e. for radiation moving through our object of interest which may never reach
us. In the Monte Carlo modules of RADMC-3D, when polarization is switched on, any photon package does not only
have a wavelength ùúÜand a direction of propagation n associated with it, but also a second unit vector S, which is
always assured to obey:
|S| = 1
and
S ¬∑ n = 0
This leaves, for a given n, one degree of freedom (any direction as long as it is perpendicular to n). It is irrelevant
which direction is chosen for this, but whatever choice is made, it sets the deÔ¨Ånitions of the ùë•‚Ä≤ and ùë¶‚Ä≤ directions. The
deÔ¨Ånitions are:
ùë•‚Ä≤ =
points in the direction
S √ó n
ùë¶‚Ä≤ =
points in the direction
S
ùëß‚Ä≤ =
points in the direction
n
So for ùëÑ= ‚àíùêº, ùëà= ùëâ= 0 the electric Ô¨Åeld points in the direction of S, while for ùëÑ= +ùêº, ùëà= ùëâ= 0 it is
perpendicular to both n and S.
However, if you are forced to change the direction of S for whatever reason, the Stokes components will also change.
This coordinate transformation works as follows. We can transform from a ‚Äò-basis to a ‚Äò‚Äô-basis by rotating the S-vector
counter-clockwise (as seen by the observer watching the radiation) by an angle ùõº. Any vector (ùë•‚Ä≤, ùë¶‚Ä≤) in the ‚Äò-basis
will become a vector (ùë•‚Ä≤‚Ä≤, ùë¶‚Ä≤‚Ä≤) in a ‚Äò‚Äô-basis, given by the transformation:
(Ô∏Çùë•‚Ä≤‚Ä≤
ùë¶‚Ä≤‚Ä≤
)Ô∏Ç
=
(Ô∏Çcos(ùõº)
sin(ùõº)
‚àísin(ùõº)
cos(ùõº)
)Ô∏Ç(Ô∏Çùë•‚Ä≤
ùë¶‚Ä≤
)Ô∏Ç
NOTE: We choose (ùë•‚Ä≤, ùë¶‚Ä≤) to be the usual counter-clockwise basis for the observer seeing the radiation. Rotating
the basis in counter-clockwise direction means rotating the vector in that basis in clockwise direction, hence the sign
convention in the matrix.
If we have (ùêº, ùëÑ, ùëà, ùëâ) in the ‚Äò-basis (which we might have written as (ùêº‚Ä≤, ùëÑ‚Ä≤, ùëà‚Ä≤, ùëâ‚Ä≤) but by convention we drop the
‚Äò), the (ùêº‚Ä≤‚Ä≤, ùëÑ‚Ä≤‚Ä≤, ùëà‚Ä≤‚Ä≤, ùëâ‚Ä≤‚Ä≤) in the ‚Äò‚Äô-basis becomes
‚éõ
‚éú
‚éú
‚éù
ùêº‚Ä≤‚Ä≤
ùëÑ‚Ä≤‚Ä≤
ùëà‚Ä≤‚Ä≤
ùëâ‚Ä≤‚Ä≤
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
1
0
0
0
0
cos(2ùõº)
sin(2ùõº)
0
0
‚àísin(2ùõº)
cos(2ùõº)
0
0
0
0
1
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
44
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.9.4 Polarized scattering off dust particles: general formalism
Suppose we have one dust particle of mass ùëögrain and we place it at location x. Suppose this particle is exposed to
a plane wave of electromagnetic radiation pointing in direction nin with a Ô¨Çux Fin = ùêπin nin. This radiation can be
polarized, so that ùêπin actually is a Stokes vector:
ùêπin =
‚éõ
‚éú
‚éú
‚éù
ùêπùêº,in
ùêπùëÑ,in
ùêπùëà,in
ùêπùëâ,in
‚éû
‚éü
‚éü
‚é†
This particle will scatter some of this radiation into all directions. What will the Ô¨Çux of scattered radiation be, as
observed at location y Ã∏= x? Let us deÔ¨Åne the vector
r = y ‚àíx
its length
ùëü= |r|
and the unit vector
eùëü= r
ùëü
We will assume that ùëü‚â´ùëéwhere ùëéis the particle size. We deÔ¨Åne the {em scattering matrix elements} ùëçùëñùëó(with ùëñ, ùëó
= 1, 2, 3, 4) such that the measured outgoing Ô¨Çux from the particle at y is
Fout = ùêπouteùëü
ùêπout =
‚éõ
‚éú
‚éú
‚éù
ùêπùêº,out
ùêπùëÑ,out
ùêπùëà,out
ùêπùëâ,out
‚éû
‚éü
‚éü
‚é†= ùëögrain
ùëü2
‚éõ
‚éú
‚éú
‚éù
ùëç11
ùëç12
ùëç13
ùëç14
ùëç21
ùëç22
ùëç23
ùëç24
ùëç31
ùëç32
ùëç33
ùëç34
ùëç41
ùëç42
ùëç43
ùëç44
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêπùêº,in
ùêπùëÑ,in
ùêπùëà,in
ùêπùëâ,in
‚éû
‚éü
‚éü
‚é†
The values ùëçùëñùëódepend on the direction into which the radiation is scattered (i.e. eùëü) and on the direction of the
incoming Ô¨Çux (i.e. n), but not on ùëü: the radial dependence of the outgoing Ô¨Çux is taken care of through the 1/ùëü2 factor
in the above formula.
Some notes about our conventions are useful at this place. In many books the ‚Äòscattering matrix‚Äô is written as ùêπùëñùëó
instead of ùëçùëñùëó, and is deÔ¨Åned as the ùëçùëñùëófor the case when radiation comes from one particular direction: n = (0, 0, 1).
In this manual and in the RADMC-3D code, however, we will always write ùëçùëñùëó, because the symbol ùêπcan be confused
with Ô¨Çux. The normalization of these matrix elements is also different in different books. In our case it has the
dimension cm2 gram‚àí1 ster‚àí1. The conversion from the conventions of other books is (where ùëò= 2ùúã/ùúÜis the wave
number in units of 1/cm):
ùëçùëñùëó,RADMC‚àí3D = ùëçùëñùëó,Mishchenko
ùëögrain
= ùëÜùëñùëó,BohrenH
ùëò2ùëögrain
except that for the ùëç13, ùëç14, ùëç23, ùëç24, ùëç31, ùëç41, ùëç32, ùëç42 elements (if non-zero) there must be a minus sign before the
ùëçùëñùëó,RADMC‚àí3D because of the opposite ùëàand ùëâsign conventions (see Section Our conventions compared to other
literature).
Note that the ùëÜùëñùëó,BohrenH are the matrix elements obtained from the famous BHMIE.F code from the Bohren &
Huffman book (see Chapter Acquiring opacities from the WWW).
6.9. Polarization, Stokes vectors and full phase-functions
45

radmc3d, Release 2.0
6.9.5 Polarized scattering off dust particles: randomly oriented particles
In the special case in which we either have spherical particles or we average over a large number of randomly oriented
particles, the ùëçùëñùëóelements are no longer dependent on both eùëüand n but only on the angle between them:
cos ùúÉ= n ¬∑ eùëü
So we go from ùëçùëñùëó(n, eùëü), i.e. a four-angle dependence, to ùëçùëñùëó(ùúÉ), i.e. a one-angle dependence.
Now let us also assume that there is no netto helicity of the particles (they are either axisymmetric or there exist equal
amounts of particles as their mirror symmetric counterparts). In that case (see e.g. Mishchenko book) of the 16 matrix
elements only 6 are non-zero and independent:
ùêπout =
‚éõ
‚éú
‚éú
‚éù
ùêπùêº,out
ùêπùëÑ,out
ùêπùëà,out
ùêπùëâ,out
‚éû
‚éü
‚éü
‚é†= ùëögrain
ùëü2
‚éõ
‚éú
‚éú
‚éù
ùëç11
ùëç12
0
0
ùëç12
ùëç22
0
0
0
0
ùëç33
ùëç34
0
0
‚àíùëç34
ùëç44
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêπùêº,in
ùêπùëÑ,in
ùêπùëà,in
ùêπùëâ,in
‚éû
‚éü
‚éü
‚é†
This is the case for scattering in RADMC-3D. Note that in Mie scattering the number of independent matrix elements
reduces to just 4 because then ùëç22 = ùëç11 and ùëç44 = ùëç33. But RADMC-3D also allows for cases where ùëç22 Ã∏= ùëç11
and ùëç44 Ã∏= ùëç33, i.e. for opacities resulting from more detailed calculations such as DDA or T-matrix calculations.
Now, as described above, the Stokes vectors only have meaning if the directions of ùë•‚Ä≤ and ùë¶‚Ä≤ are well-deÔ¨Åned. For Eq.
(eq-scatmat-for-randorient-nohelic) to be valid (and for the correct meaning of the ùëçùëñùëóelements) the following deÔ¨Åni-
tion is used: Before the scattering, the S-vector of the photon package is rotated (and the Stokes vectors accordingly
transformed) such that the new S-vector is perpendicular to both n and eùëü. In other words, the scattering angle ùúÉis a
rotation of the photon propagation around the (new) S-vector. The sign convention is such that
(n √ó eùëü) ¬∑ S = sin(ùúÉ)
In other words, if we look into the incoming light (with ùëß‚Ä≤ pointing toward us), then for sin(ùúÉ) > 0 the photon is
scattered into the ùë•‚Ä≤ > 0, ùë¶‚Ä≤ = 0 direction (i.e. for us it is scattered to the right). The S vector for the outgoing photon
remains unchanged, since the new n is also perpendicular to it.
So what does this all mean for the opacity? The scattering opacity tells us how much of the incident radiation is
removed and converted into outgoing scattered radiation. The absorption opacity tells us how much of the incident
radiation is removed and converted into heat. For randomly oriented particles without netto helicity both opacities are
independent of the polarization state of the radiation. Moreover, the thermal emission is unpolarized in this case. This
means that in the radiative transfer equation the extinction remains simple:
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêºùêº
ùêºùëÑ
ùêºùëà
ùêºùëâ
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
ùëóemis,ùêº
0
0
0
‚éû
‚éü
‚éü
‚é†+
‚éõ
‚éú
‚éú
‚éù
ùëóscat,ùêº
ùëóscat,ùëÑ
ùëóscat,ùëà
ùëóscat,ùëâ
‚éû
‚éü
‚éü
‚é†‚àíùúå(ùúÖabs + ùúÖscat)
‚éõ
‚éú
‚éú
‚éù
ùêºùêº
ùêºùëÑ
ùêºùëà
ùêºùëâ
‚éû
‚éü
‚éü
‚é†
where ùêºùêº, ùêºùëÑ, ùêºùëà, ùêºùëâare the intensities (erg s‚àí1 cm‚àí2 Hz‚àí1 ster‚àí1) for the four Stokes parameters, and likewise
for ùëóemis and ùëóscat, and Ô¨Ånally, ùë†the path length along the ray under consideration. Note that if we would allow for
Ô¨Åxed-orientation dust particles (which we don‚Äôt), Eq. (eq-radtrans-randomorient) would become considerably more
complex, with extinction being matrix-valued and thermal emission being polarized.
Since ùúÖscat converts incoming radiation into outgoing scattered radiation, it should be possible to calculate ùúÖscat from
angular integrals of the scattering matrix elements. For randomly oriented non-helical particles we indeed have:
ùúÖscat =
‚àÆÔ∏Å
ùëç11ùëë‚Ñ¶= 2ùúã
‚à´Ô∏Å+1
‚àí1
ùëç11(ùúá)ùëëùúá
46
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
where ùúá= cos ùúÉ. In a similar exercise we can calculate the anisotropy factor ùëîfrom the scattering matrix elements:
ùëî=
2ùúã
ùúÖscat
‚à´Ô∏Å+1
‚àí1
ùëç11(ùúá)ùúáùëëùúá
This essentially completes the description of scattering as it is implemented in RADMC-3D.
We can precalculate the ùëçùëñùëó(ùúÉ) for every wavelength and for a discrete set of values of ùúÉ, and store these in a table.
This is indeed the philosophy of RADMC-3D: You have to precompute them using, for instance, the Mie code of
Bohren and Huffman (see Chapter Acquiring opacities from the WWW for RADMC-3D compliant wrappers around
that code), and then provide them to RADMC-3D through a Ô¨Åle called dustkapscatmat_xxx.inp (where xxx
is the name of the dust species) which is described in Section The dustkapscatmat_*.inp Ô¨Åles. This Ô¨Åle provides not
only the matrix elements, but also the ùúÖabs, ùúÖscat and ùëî(the anisotropy factor). RADMC-3D will then internally check
that Eqs.(eq-scatmat-selfconsist-kappa, eq-scatmat-selfconsist-g) are indeed fulÔ¨Ålled. If not, an error message will
result.
One more note: As mentioned in Section DeÔ¨Ånitions and conventions for Stokes vectors, the sign conventions of the
Stokes vector components we use (the IAU 1974 deÔ¨Ånition) are different from the Bohren & Huffman and Mishchenko
books. For randomly oriented particles, however, the sign conventions of the ùëç-matrix elements are not affected,
because those matrix elements that would be affected are those that are in the upper-right and lower-left quadrants of
the matrix, and these elements are anyway zero. So we can use, for randomly oriented particles, the matrix elements
from those books and their computer codes without having to adjust the signs.
6.9.6 Scattering and axially symmetric models
In spherical coordinates it is possible in RADMC-3D to set up axially symmetric models. The trick is simply to set the
number of ùúëcoordinate points nphi to 1 and to switch off the ùúë-dimension in the grid (see Section INPUT (required):
amr_grid.inp). For isotropic scattering this mode has always been implemented. But for anisotropic scattering things
become more complex. For such a model the scattering remains a fully 3-D problem: the scattering source function
has to be stored not only as a function of ùëüand ùúÉ, but also as a function of ùúë(for a given observer vantage point). The
reason is that anisotropic scattering {em does} care about viewing angle (in contrast to isotropic scattering). So even
though for an axisymmetric model the density and temperature functions only depend on ùëüand ùúÉ(and are therefore
mathematically 2-D), the scattering source function depends on ùëü, ùúÉand ùúë.
For this reason anisotropic scattering was, until version 0.40, not allowed for 2-D axisymmetric models. As of version
0.41 it is now possible to use the full polarized scattering mode (scattering_mode=5) also for 2-D axisymmet-
ric models. The intermediate scattering modes (scattering_mode=2, 3, 4) remain incompatible with 2-D
axisymmetry. Isotropic scattering remains, as before, fully compatible with 2-D axisymmetry.
One note of explanation: the way the full scattering is now implemented into the case of 2-D axisymmetry is the
following: internally we compute not just the scattering source function for one angle, but for a whole set of ùúëangles
(even though the grid has no ùúë-points). Each time a photon in the scattering Monte Carlo simulation enters a cell
(which in 2-D axisymmetry is an annulus), a loop over 360 ùúëangles is performed, and the scattering source function is
computed for all of these angles. {em This makes the code rather slow for each photon package!} But one needs fewer
photon packages to get sufÔ¨Åciently high signal-to-noise ratio. You can experiment with fewer ùúëangles by adding, in
radmc3d.inp, the following line (as an example):
dust_2daniso_nphi = 60
in which case instead of 360 the model will only use 60 ùúëpoints. That will speed up the code signiÔ¨Åcantly, but of
course will treat the ùúë-dependence of the scattering source function with lower precision.
For now the 2-D axisymmetric version of full scattering is only possible with Ô¨Årst-order integration.
6.9. Polarization, Stokes vectors and full phase-functions
47

radmc3d, Release 2.0
6.10 More about photon packages in the Monte Carlo simulations
In the ‚Äòstandard‚Äô Monte Carlo approach, the input energy (e.g. starlight or, for the scattering Monte Carlo, the thermal
emission of dust) is divided into ùëÅequal energy packages of photons, which then travel through the model and
eventually either escape or get destroyed. This equal division scheme is, however, problematic for some model setups.
For instance, if you have stars with vastly different luminosity in the model, then the brightest of these stars will
dominate, by far, the number of output photon packages. This means that the material around low-brightness stars
(which, by their proximity to these low-brightness stars, are still dominated by heating by these low-brightness stars)
will experience very bad photon statistics.
To avoid this problem, RADMC-3D has, by default, its ‚Äòweighted photon package mode‚Äô switched on. This will make
sure that each source of energy (i.e. each star, but also each other type of source) emits the same amount of photons.
Only: bright stars will emit more energetic photon packages than dim stars.
The ‚Äòweighted photon package mode‚Äô will also solve another problem. Suppose a star lies far outside of the grid. It
will emit most of its photons in directions that completely miss the grid. This means that RADMC-3D would waste
a lot of time drawing random numbers for photons that will anyway not affect the model. Also here the ‚Äòweighted
photon package mode‚Äô solves the problem: It will focus the photon packages toward the model grid, and lower their
energy to compensate for their favorable focusing toward the grid.
NOTE: You can switch the mode off by setting mc_weighted_photons=0 in the radmc3d.inp Ô¨Åle.
6.11 Polarized emission and absorption by aligned grains
NOTE: This mode is still in the testing phase
Grain alignment and its effects on radiative transfer is a complex topic. A review is e.g. Andersson, B.G., Lazarian,
A., & Vaillancourt, J.E. (2015) ‚ÄòInterstellar Dust Grain Alignment‚Äô, Annual Review of Astronomy and Astrophysics,
53(1), 501‚Äì539. In RADMC-3D grain alignment is included only in a limited form. First and foremost: RADMC-3D
does not know about the physics {em causing} the grain alignment. You, the user, will have to tell how the grain are
aligned by giving the code a directional vector Ô¨Åeld and for each wavelength the degree to which the grain is aligned
to that directional vector (more on this later). This is according to the RADMC-3D philosophy of doing {em only}
the radiative transfer and leaving the physics of the material to the user.
6.11.1 Basics
Suppose we have Ô¨Çattened (oblate) ellipsoidal grains with one axis of symmetry and no helicity. (While helicity may
be needed to radiatively spin up grains, we assume that on average the helicity of the grains is zero.). Let us assume that
they are aligned with that symmetry axis along the ùë¶-axis. We view radiation from the point where the ùëß-axis points
toward us. Horizontally polarized light (which has ùê∏-Ô¨Åeld in horizontal direction, i.e. in ùë•-direction) has ùëÑ/ùêº= +1,
vertically polarized light (with the ‚Éóùê∏vector aligned with the symmetry axis of the grain) has ùëÑ/ùêº= ‚àí1. We can then
assume that the dust has different extinction coefÔ¨Åcients for the horizontal and vertical axis. Let us call these:
ùõºabs,ùúà,h ‚â°ùúåùëëùúÖabs,ùúà,h
ùõºabs,ùúà,v ‚â°ùúåùëëùúÖabs,ùúà,v
We can deÔ¨Åne ùêº, ùëÑ, ùëàand ùëâin terms of the electric Ô¨Åeld components ùê∏ùë•and ùê∏ùë¶. The electric Ô¨Åeld components for
a perfectly coherent wave can be written as
ùê∏ùë•= ùê∏ùë•,0 cos(ùúîùë°‚àí‚àÜùë•)
ùê∏ùë¶= ùê∏ùë¶,0 cos(ùúîùë°‚àí‚àÜùë¶)
where ‚àÜùë•and ‚àÜùë¶are phase lags. The phase lag between the ùë¶and ùë•-Ô¨Åelds is ‚àÜ= ‚àÜùë¶‚àí‚àÜùë•, meaning that for positive
‚àÜthe ùë¶-Ô¨Åeld lags behind the ùë•-Ô¨Åeld. We then deÔ¨Åne the Stokes components as:
48
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
ùêº= ùê∏2
ùë•,0 + ùê∏2
ùë¶,0
ùëÑ= ùê∏2
ùë•,0 ‚àíùê∏2
ùë¶,0
ùëà= 2ùê∏ùë•,0ùê∏ùë¶,0 cos ‚àÜ
ùëâ= 2ùê∏ùë•,0ùê∏ùë¶,0 sin ‚àÜ
Note that for ùëâ= ùêº(‚àÜ= ùúã/2, i.e. the ùê∏ùë¶lags ùúã/2 behind ùê∏ùë•) we have right-handed circularly polarized light,
meaning that the tip of the ‚Éóùê∏Ô¨Åeld at a Ô¨Åxed point in space, when looking into the light (the propagation of light is
toward the reader) rotates counter-clockwise (when the ùë•-coordinate points right, and the ùë¶-coordinate points up). The
3-D helix of his Ô¨Åeld will be {em left-handed} (when the z-coordinate points into the propagation direction of the light,
i.e. toward the reader, i.e. a right-handed coordinate system). For ùëÑ= ùêºwe have linearly polarized light in which the
‚Éóùê∏-Ô¨Åeld lies in the ùë•-direction. For ùëà= ùêºwe have linearly polarized light in which ‚Éóùê∏lies along the ùë•= ùë¶line (when
looking into the light). These deÔ¨Ånitions are consistent with the IAU 1974 deÔ¨Ånitions (Hamaker & Bregman 1996,
A&AS 117, pp.161).
The ùê∏ùë•and ùê∏ùë¶get absorbed in the following way:
ùê∏‚Ä≤
ùë•,0 = ùê∏ùë•,0ùëí‚àí1
2 ùõºabs,ùúà,hùë†
ùê∏‚Ä≤
ùë¶,0 = ùê∏ùë¶,0ùëí‚àí1
2 ùõºabs,ùúà,vùë†
where ùë†is a length along the ray.
For this kind of problem it is convenient to introduce the so-called modiÔ¨Åed Stokes parameters ùêºh and ùêºv:
ùêºh = 1
2(ùêº+ ùëÑ)
ùêºv = 1
2(ùêº‚àíùëÑ)
so that we have
ùêº= ùêºh + ùêºv
ùëÑ= ùêºh ‚àíùêºv
so that one can say, for perfectly coherent light,
ùêºh = ùê∏2
ùë•,0
ùêºv = ùê∏2
ùë¶,0
With this we get the following extinction law:
ùêº‚Ä≤
h = ùêºhùëí‚àíùõºabs,ùúà,hùë†
ùêº‚Ä≤
v = ùêºvùëí‚àíùõºabs,ùúà,vùë†
How do ùëàand ùëâextinct? If we use Eqs. (eq-def-stokes-u, eq-def-stokes-v), and assume that the phase lag ‚àÜwill not
change during the extinction, then
ùëà‚Ä≤ = ùëàùëí‚àí1
2 ùõºabs,ùúà,hùë†ùëí‚àí1
2 ùõºabs,ùúà,vùë†
= ùëàùëí‚àí1
2 (ùõºabs,ùúà,h+ùõºabs,ùúà,v)ùë†
This means that
ùõºabs,ùúà,uv = 1
2 (ùõºabs,ùúà,h + ùõºabs,ùúà,v)
6.11. Polarized emission and absorption by aligned grains
49

radmc3d, Release 2.0
and
ùêº‚Ä≤
u = ùêºuùëí‚àíùõºabs,ùúà,uvùë†
ùêº‚Ä≤
v = ùêºvùëí‚àíùõºabs,ùúà,uvùë†
In matrix notation
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêºh
ùêºv
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†= ‚àí
‚éõ
‚éú
‚éú
‚éù
ùõºh
0
0
0
0
ùõºv
0
0
0
0
ùõºuv
0
0
0
0
ùõºuv
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêºh
ùêºv
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
If we translate this to the usual Stokes components we get
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†= ‚àí
‚éõ
‚éú
‚éú
‚éù
ùõº1
ùõº2
0
0
ùõº2
ùõº1
0
0
0
0
ùõº1
0
0
0
0
ùõº1
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
with
ùõº1 = 1
2 (ùõºabs,ùúà,h + ùõºabs,ùúà,v) = ùõºabs,ùúà,uv
ùõº2 = 1
2 (ùõºabs,ùúà,h ‚àíùõºabs,ùúà,v)
The emission will be also independently in horizontal and vertical direction. But nothing will be emitted in U or
V direction. So it is most convenient to express the emission/absorption process in terms of the modiÔ¨Åed Stokes
parameters:
ùëëùêºùúà,h
ùëëùë†
= ùõºabs,ùúà,h(1
2ùêµùúà(ùëá) ‚àíùêºùúà,h)
ùëëùêºùúà,v
ùëëùë†
= ùõºabs,ùúà,v(1
2ùêµùúà(ùëá) ‚àíùêºùúà,v)
ùëëùëàùúà
ùëëùë†= ‚àíùõºabs,ùúà,uvùëàùúà
ùëëùëâùúà
ùëëùë†= ‚àíùõºabs,ùúà,uvùëâùúà
In terms of matrix notation this becomes
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêºh
ùêºv
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
1
2ùõºhùêµùúà(ùëá)
1
2ùõºvùêµùúà(ùëá)
0
0
‚éû
‚éü
‚éü
‚é†‚àí
‚éõ
‚éú
‚éú
‚éù
ùõºh
0
0
0
0
ùõºv
0
0
0
0
ùõºuv
0
0
0
0
ùõºuv
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêºh
ùêºv
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
In terms of the normal Stokes parameters this becomes
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
ùõº1ùêµùúà(ùëá)
ùõº2ùêµùúà(ùëá)
0
0
‚éû
‚éü
‚éü
‚é†‚àí
‚éõ
‚éú
‚éú
‚éù
ùõº1
ùõº2
0
0
ùõº2
ùõº1
0
0
0
0
ùõº1
0
0
0
0
ùõº1
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
or written slightly differently:
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
ùõº1
ùõº2
0
0
ùõº2
ùõº1
0
0
0
0
ùõº1
0
0
0
0
ùõº1
‚éû
‚éü
‚éü
‚é†
‚é°
‚é¢‚é¢‚é£
‚éõ
‚éú
‚éú
‚éù
ùêµùúà(ùëá)
0
0
0
‚éû
‚éü
‚éü
‚é†‚àí
‚éõ
‚éú
‚éú
‚éù
ùêº
ùëÑ
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
‚é§
‚é•‚é•‚é¶
So to sum things up: We need only the absorption opacity for light with ‚Éóùê∏perpencidular to the symmetry axis
(ùúÖabs,ùúà,‚Ñé) and the absorption opacity for light with ‚Éóùê∏parallel to the symmetry axis (ùúÖabs,ùúà,ùë£).
50
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.11.2 Implementation in RADMC-3D
Polarized emission in the images and spectra
When creating images (and spectra) the camera module of RADMC-3D performs a ray-tracing calculation (‚Äòvolume
rendering‚Äô) through the grid. Normally (for randomly oriented grains) the extinction along the line of sight is always
unpolarized, i.e. each Stokes component is extincted equally much. The thermal emission along the line of sight is
also unpolarized.
Now, however, we wish to include the effect of grain alignment in the ray-tracing. We assume that at position ‚Éóùë•in
the grid our oblate grain is aligned such that the minor axis points in the direction of the orientation vector ‚Éóùëõalign(‚Éóùë•).
If the grain is prolate, we assume that it spins along one of its minor axes such that this spin axis is pointing along
‚Éóùëõalign(‚Éóùë•), so that, in effect, it acts as if it were an oblate grain again. In practice the alignment vector ‚Éóùëõalign(‚Éóùë•) does
not lie always in the plane of the sky of the observer. Instead it will have an angle ùúÉwith the line-of-sight direction
vector ‚Éóùëõlos (note that this ùúÉangle is different from the scattering angle ùúÉ), deÔ¨Åned as
cos ùúÉ‚â°= |‚Éóùëõalign ¬∑ ‚Éóùëõlos|
Here we assume that the grains have top/bottom symmetry so that we only have to concern ourselves with the positive
values of cos ùúÉ, hence the ||. If cos ùúÉ= 1 then we see the oblate grain from the top or the bottom, so that we do not
expect any polarized emission. The strongest polarized emission is expected when cos ùúÉ= 0, which means that the
oblate grain is seen edge-on.
We can now deÔ¨Åne the ‚Äòprojected alignment vector‚Äô ‚Éóùëõalign,proj, which is the alignment vector projected into the image
plane:
‚Éóùëõalign,proj = ‚Éóùëõalign ‚àí(‚Éóùëõalign ¬∑ ‚Éóùëõlos) ‚Éóùëõlos
To use the equations from Section Basics we must Ô¨Årst rotate our image plane coordinates (ùë•, ùë¶) to new coordinates
(ùë•‚Ä≤, ùë¶‚Ä≤) such that the ùë¶‚Ä≤ (vertical) direction points along the ‚Éóùëõalign,proj vector while the ùë•‚Ä≤ (horizontal) direction points
perpendicular to it. Let us write the Stokes vector of the radiation along the line of sight (ùêºin, ùëÑin, ùëàin, ùëâin), where we
implicitly know that these are also a function of frequency ùúà. This Stokes vector is deÔ¨Åned with respect to the vector ‚ÉóùëÜ
which is perpendicular to the line-of-sight direction vector ‚Éóùëõlos and deÔ¨Ånes the direction in which the ùë¶-coordinate of
the image plane points. We must now express this incoming radiation (at the start of the segment) in the new (ùë•‚Ä≤, ùë¶‚Ä≤)
image plane coordinates, i.e. with respect to the new vector ‚ÉóùëÜ‚Ä≤ that points along ‚Éóùëõalign,proj (i.e. ‚ÉóùëÜ‚Ä≤ is the normalized
version of ‚Éóùëõalign,proj). This rotation is performed using
‚éõ
‚éú
‚éú
‚éù
ùêº‚Ä≤
ùëÑ‚Ä≤
ùëà‚Ä≤
ùëâ‚Ä≤
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
1
0
0
0
0
cos(2ùõº)
sin(2ùõº)
0
0
‚àísin(2ùõº)
cos(2ùõº)
0
0
0
0
1
‚éû
‚éü
‚éü
‚é†
‚éõ
‚éú
‚éú
‚éù
ùêºin
ùëÑin
ùëàin
ùëâin
‚éû
‚éü
‚éü
‚é†
where ùõºis the angle between ‚ÉóùëÜ‚Ä≤ and ‚ÉóùëÜsuch that if (as seen by the observer) ‚ÉóùëÜ‚Ä≤ lies counter-clockwise from ‚ÉóùëÜ, ùõºis
positive (the usual deÔ¨Ånition). With this new Stokes vector (ùêº‚Ä≤, ùëÑ‚Ä≤, ùëà‚Ä≤, ùëâ‚Ä≤) we will now use the equations of Section
Basics.
To be able to perform this rotation in a uniquely deÔ¨Åned way, it is necessary that along each segment along the line
of sight this new (ùë•‚Ä≤, ùë¶‚Ä≤) orientation stays Ô¨Åxed (but can vary from segment to segment). As the line-of-sight ray
enters a cell and leaves it again, this line element (segment) will have its image-plane coordinates rotated according
to the alignment vector of that cell. As a result, the integration must be done Ô¨Årst order (assuming all source terms to
be constant along the segment). In principle second order integration would also be possible, but then the trick with
the rotation of the image coordinate plane such that ùë¶‚Ä≤ points along the orientation vector does no longer work, and
the integration of the formal transfer equation would become much more complex, involving the full M√ºller matrix
formulation. We will not do this, so we will stick to Ô¨Årst order integration of Eq. eq-formal-rt-emisabs-in-rotated-
system.
6.11. Polarized emission and absorption by aligned grains
51

radmc3d, Release 2.0
For convenience we will leave out the primes (‚Äò) from here on, so while we write (ùêº, ùëÑ, ùëà, ùëâ) we mean in fact
(ùêº‚Ä≤, ùëÑ‚Ä≤, ùëà‚Ä≤, ùëâ‚Ä≤). We now compute ùêºh and ùêºv using Eqs. (eq-modif-stokes-h, eq-modif-stokes-v). Now, along this
segment of the ray, we can write Eq. eq-formal-rt-emisabs-in-rotated-system in the following form:
ùëë
ùëëùë†
‚éõ
‚éú
‚éú
‚éù
ùêºh
ùêºv
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†=
‚éõ
‚éú
‚éú
‚éù
ùõºh
0
0
0
0
ùõºv
0
0
0
0
ùõºuv
0
0
0
0
ùõºuv
‚éû
‚éü
‚éü
‚é†
‚é°
‚é¢‚é¢‚é£
‚éõ
‚éú
‚éú
‚éù
1
2ùêµùúà(ùëá)
1
2ùêµùúà(ùëá)
0
0
‚éû
‚éü
‚éü
‚é†‚àí
‚éõ
‚éú
‚éú
‚éù
ùêºh
ùêºv
ùëà
ùëâ
‚éû
‚éü
‚éü
‚é†
‚é§
‚é•‚é•‚é¶
It becomes clear that it is easy to perform the Ô¨Årst order integration of this equation along this ray segment:
ùêºh,end = ùëí‚àíùúè‚Ñéùêºh,start + 1
2ùëí‚àíùúè‚Ñéùêµùúà(ùëá)
ùêºv,end = ùëí‚àíùúèùë£ùêºv,start + 1
2ùëí‚àíùúèùë£ùêµùúà(ùëá)
ùëàend = ùëí‚àíùúèùë¢ùë£ùëàstart
ùëâend = ùëí‚àíùúèùë¢ùë£ùëâstart
where ‚Äòstart‚Äô stands for the start of the ray segment, and ‚Äòend‚Äô the end of the ray segment (which becomes the start of
the next ray segment), and ùúè‚Ñé= ùõºh‚àÜùë†, ùúèùë£= ùõºv‚àÜùë†and ùúèùë¢ùë£= ùõºuv‚àÜùë†, with ‚àÜùë†being the length of the segment.
We now compute ùêºend and ùëÑend, and rotate back to the (ùë•, ùë¶) image plane coordinate system (i.e. using ‚ÉóùëÜinstead
of ‚ÉóùëÜ‚Ä≤ to deÔ¨Åne the Stokes parameters) by applying Eq. eq-rot-stokes-align but now with ùõº‚Üí‚àíùõº, and we have the
values of the Stokes parameter at the end of the ray segment. Now we repeat this whole procedure for the next ray
segment.
Polarized emission as source term in the Monte Carlo simulation
The polarization effects and anisotropic emission by aligned grains will also affect the Monte Carlo simulations.
For the thermal Monte Carlo (see Section The thermal Monte Carlo simulation: computing the dust temperature) this
effect is not included. In principle it should be included, but it would slow the code down, and it is unlikely to play
a signiÔ¨Åcant role for the dust temperature, in particular since the anisotropy of thermal emission is not expected to be
so strong (and the polarization state is irrelevant for computing the dust temperature). It is clear that we make a small
error here, but we believe that this is well within the much stronger uncertainties of the dust opacities.
For the scattering Monte Carlo (see Section Scattered light in images and spectra: The ‚ÄòScattering Monte Carlo‚Äô
computation), however, this effect may be important! The polarization caused by scattering of light off dust grains
yields of course different results if the incident light is unpolarized or if it is already strongly polarized through, for
instance, polarized thermal emission. In RADMC-3D this is therefore built into the scattering Monte Carlo. This will
not slow down the code much because (in contrast to the thermal Monte Carlo) the polarized thermal emission only
has to be computed at the start of each photon path, if the photon is emitted by the dust.
The way this is included is that when a photon is emitted by the dust inside a cell, RADMC-3D Ô¨Årst randomly
chooses which of the dust species emits the photon (the probabilities are weighted by the contribution each dust
species makes to the emissivity at the given wavelength). Then the emission direction is randomly chosen, based
on the ùúÉ-dependent probability function (where ùúÉis the angle with the alignment direction) given by the average of
the orthogonal (horizontal) and parallel (vertical) absorption opacities. Once the emission direction is chosen, the
polarization state of the photon package is computed based on the orthogonal and parallel absorption opacities. Then
the photon package is sent on its way.
Note that if alignment_mode = -1 then the polarized (and anisotropic) thermal emission by aligned grains is
only included in the ray-tracing for images and spectra, while for alignment_mode = 1 it is also included in the
scattering Monte Carlo computation.
52
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.11.3 Consistency with other radiative processes
The above equations assume that the absorption/emission is the only radiative process included. However, in practice
we also have other processes involved, such as line emission/absorption or the scattering source function. The way this
can be treated here is to simply add these additional opacities to all four components of the extinction matrix of Eq.
(eq-formal-rt-emisabs-in-rotated-system) and to add the additional emissivities to the vector with the Planck functions
in Eq. (eq-formal-rt-emisabs-in-rotated-system). For the scattered light emissivity (which is a Stokes vector) we must
also Ô¨Årst perform a rotation from ‚ÉóùëÜto ‚ÉóùëÜ‚Ä≤ using the Stokes rotation formula of Eq. (eq-rot-stokes-align) before we add
this emissivity to the equation. If we include the effect of alignment on the scattering (see Section Effect of aligned
grains on the scattering) then also the scattering extinction will be different for the orthogonal (horizontal) and parallel
(vertical) Stokes components. That is easy to include in this formalism.
6.11.4 Input Ô¨Åles for RADMC-3D for aligned grains
In RADMC-3D we implement the functions ùúÖabs,ùúà,‚Ñéand ùúÖabs,ùúà,ùë£as a function of angle ùúÉwhich the alignment axis
makes with the light of sight. For ùúÉwe see the oblate grain from the top (face-on), so that there is no asymmetry
between horizontal (orthogonal to the alignment orientation vector) and vertical (parallel to the alignment orientation
vector). Then we will have ùúÖabs,ùúà,‚Ñé= ùúÖabs,ùúà,ùë£. For ùúÉ= 90‚àòwe will have the maximum difference between ùúÖabs,ùúà,‚Ñé
and ùúÖabs,ùúà,ùë£. We write
ùúÖabs,ùúà,‚Ñé(ùúÉ) = ùúÖabs,ùúàùëòùúà,‚Ñé(ùúÉ)
ùúÖabs,ùúà,ùë£(ùúÉ) = ùúÖabs,ùúàùëòùúà,ùë£(ùúÉ)
where ùëòùúà,‚Ñé(ùúÉ) and ùëòùúà,ùë£(ùúÉ) are dimensionless functions, and where we take ùúÉ‚àà[0, 90] (in degrees), or equivalently
cos(ùúÉ) ‚àà[0, 1]. We impose the condition that if we randomly orient this grain, the average opacity becomes the one
we computed for the randomly oriented grains:
‚à´Ô∏Å‚àû
0
1
2 [ùúÖabs,ùúà,‚Ñé(ùúÉ) + ùúÖabs,ùúà,ùë£(ùúÉ)] ùëëùúá= ùúÖabs,ùúà
This yields the following integration condition on the dimensionless ùëòùúà,‚Ñéand ùëòùúà,ùë£:
‚à´Ô∏Å‚àû
0
1
2 [ùëòùúà,‚Ñé(ùúÉ) + ùëòùúà,ùë£(ùúÉ)] ùëëùúá= 1
If we set, for all values of ùúÉ, ùëòùúà,‚Ñé(ùúÉ) = ùëòùúà,ùë£(ùúÉ) = 1 then we retrieve the result for spherical grains.
In RADMC-3D the functions ùëòùúà,‚Ñé(ùúÉ) and ùëòùúà,ùë£(ùúÉ) are read in via the Ô¨Åle dustkapalignfact_*.inp. This Ô¨Åle
has the following structure:
# Any amount of arbitrary
# comment lines that tell which opacity this is.
# Each comment line must start with an # or ; or ! character
iformat
<=== Typically 1 at present
nlam
<=== Nr of wavelengths
nmu
<=== Nr of angles sampled
lambda[1]
<=== Wavelength grid in micron
...
lambda[nlam]
theta[1]
<=== Angle grid in degrees
...
theta[nmu]
k_orth[1,1]
k_para[1,1]
<=== The arrays k_orth and k_para
...
(continues on next page)
6.11. Polarized emission and absorption by aligned grains
53

radmc3d, Release 2.0
(continued from previous page)
k_orth[nmu,1]
k_para[nmu,1]
k_orth[1,2]
k_para[1,2]
...
k_orth[nmu,2]
k_para[nmu,2]
...
...
...
k_orth[1,nlam]
k_para[1,nlam]
...
k_orth[nmu,nlam]
k_para[nmu,nlam]
The angles theta are in degrees and must start at 0 and end at 90, or vice versa. The nmu does not have to be the
same (and the angles do not have to be the same) as those in the dustkapscatmat_*.inp Ô¨Åle. But the wavelength
grid must be identical to the one in the dustkapscatmat_*.inp Ô¨Åle.
In order to make RADMC-3D read this Ô¨Åle dustkapalignfact_*.inp the dustopac.inp Ô¨Åle should, for
this particular dust species, have ‚Äò20‚Äô as the way in which this dust species is read (instead of 10 which is used for
polarized scattering with the Z matrix).
In addition, RADMC-3D also needs to know the orientation direction of the grains. This is a vector Ô¨Åeld ‚Éóùëùalign(‚Éóùë•).
The length of these vectors should be between 0 and 1, where 1 means that the grains are perfectly aligned and 0
means they are not aligned at all. The efÔ¨Åciency ùúñalign is thus given by
ùúñalign(‚Éóùë•) = |‚Éóùëùalign(‚Éóùë•)|
The directional unit-vector of alignment ‚Éóùëõalign(‚Éóùë•) is thus
‚Éóùëõalign(‚Éóùë•) =
(Ô∏Ä
ùúñalign(‚Éóùë•)
)Ô∏Ä‚àí1‚Éóùëùalign(‚Éóùë•)
The
‚Éóùëùalign(‚Éóùë•)
vector
Ô¨Åeld
is
in
the
Ô¨Åle
grainalign_dir.inp
(or
its
binary
formatted
version
grainalign_dir.binp).
The format of this Ô¨Åle is exactly the same as that of the gas velocity Ô¨Åle
gas_velocity.inp. The ascii format looks like:
iformat
<=== Typically 1 at present
nrcells
p_x[1]
p_y[1]
p_z[1]
..
p_x[nrcells] p_y[nrcells] p_z[nrcells]
Note that |‚Éóùëùalign(‚Éóùë•)| should never be > 1. If it is found to be signiÔ¨Åcantly > 1 at some point in the grid, then an error
occurs. If it is only a tiny bit above 1, due to rounding errors, it will be normalized to 1.
The way in which partial alignment (0 < ùúñalign < 1) is treated in RADMC-3D is to treat the opacities and emissivities
as simple linear sums of fully aligned and non aligned versions. For instance, Eqs. (eq-align-kappa-k-h, eq-align-
kappa-k-v) then become
ùúÖabs,ùúà,‚Ñé(ùúÉ) = ùúÖabs,ùúà[ùúñalignùëòùúà,‚Ñé(ùúÉ) + 1 ‚àíùúñalign]
ùúÖabs,ùúà,ùë£(ùúÉ) = ùúÖabs,ùúà[ùúñalignùëòùúà,ùë£(ùúÉ) + 1 ‚àíùúñalign]
In order to tell RADMC-3D that it should include the effect of alignment on the thermal emission of dust grains one
must add a line in the radmc3d.inp Ô¨Åle with:
alignment_mode = 1
The example model in examples/run_simple_1_align/ demonstrates how the input Ô¨Åles have to be made to
have RADMC-3D treat the aligned dust grains for thermal emission.
54
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.11.5 Effect of aligned grains on the scattering
This is, currently, not yet implemented.
6.11. Polarized emission and absorption by aligned grains
55

radmc3d, Release 2.0
56
Chapter 6. Dust continuum radiative transfer

CHAPTER
SEVEN
LINE RADIATIVE TRANSFER
RADMC-3D is capable of modeling radiative transfer in molecular and/or atomic lines. Due to the complexity of line
radiative transfer, and the huge computational and memory requirements of full-scale non-LTE line transfer, RADMC-
3D has various different modes of line transfer. Some modes are very memory efÔ¨Åcient, but slower, while others are
faster, but less memory efÔ¨Åcient, yet others are more accurate but much slower and memory demanding. The default
mode (and certainly recommended initially) is LTE ray-tracing in the slow but memory efÔ¨Åcient way: the simple LTE
mode (see Section Line transfer modes and how to activate the line transfer). Since this is the default mode, you do
not need to specify anything to have this selected.
7.1 Quick start for adding line transfer to images and spectra
Do properly model line transfer requires dedication and experimentation. This is not a simple task. See Section What
can go wrong with line transfer? for an analysis of several pitfalls one may encounter. However, nothing is better than
experimenting and thus gaining hands-on experience. So the easiest and quickest way to start is to start with one of
the simple line transfer test models in the examples/ directory.
So simply visit examples/run_test_lines_1/, examples/run_test_lines_2/ or examples/
run_test_lines_3/ and follow the directions in the README Ô¨Åle. The main features of adding line ray tracing
to a model is to add the following Ô¨Åles into any previously constructed model with dust radiative transfer:
‚Ä¢ lines.inp: A control Ô¨Åle for line transfer.
‚Ä¢ molecule_co.inp: or any other molecular data Ô¨Åle containing properties of the molecule or atom.
‚Ä¢ numberdens_co.inp (or its binary version, see Chapter Binary I/O Ô¨Åles) or that of another molecule: The
number density of that molecule in units of cm‚àí3.
‚Ä¢ gas_temperature.inp (or its binary version, see Chapter Binary I/O Ô¨Åles): The gas temperature at each
grid cell.
You do not need to specify this Ô¨Åle if you add the keyword tgas_eq_tdust = 1 into the
radmc3d.inp Ô¨Åle.
7.2 Some deÔ¨Ånitions for line transfer
The formal transfer equation is:
ùëëùêºùúà(ùúî)
ùëëùë†
= ùëóùúà(ùúî) ‚àíùõºùúà(ùúî)ùêºùúà(ùúî)
which is true also for the lines. Here ùúîis the direction, ùúàthe frequency, ùêºthe intensity. The emissivity ùëóùúàand
extinction ùõºùúàfor each line (given by ùëñ=upper level and ùëó=lower level) is given by:
57

radmc3d, Release 2.0
ùëóùëñùëó(‚Ñ¶, ùúà) = ‚Ñéùúà
4ùúãùëÅùëõùëñùê¥ùëñùëóùúôùëñùëó(ùúî, ùúà)
ùõºùëñùëó(ùúî, ùúà) = ‚Ñéùúà
4ùúãùëÅ(ùëõùëóùêµùëóùëñ‚àíùëõùëñùêµùëñùëó)ùúôùëñùëó(ùúî, ùúà)
Here ùëÅis the number density of the molecule, ùëõùëñis the fraction of the molecules that are in level ùëñ, ùê¥ùëñùëóis the Einstein
coefÔ¨Åcient for spontaneous emission from level ùëñto level ùëó, and ùêµùëñùëóand ùêµùëóùëñare the Einstein-B-coefÔ¨Åcients which
obey:
ùê¥ùëñùëó= 2‚Ñéùúà3
ùëñùëó
ùëê2
ùêµùëñùëó, ùêµùëóùëñùëîùëó= ùêµùëñùëóùëîùëñ
where ùëîare the statistical weights of the levels, ‚Ñéthe Planck constant and ùëêthe light speed. The symbol ùúôùëñùëó(ùúî, ùúà) is
the line proÔ¨Åle function. For zero velocity Ô¨Åeld ùúôùëñùëó(ùúî, ùúà) = Àúùúôùëñùëó(ùúà), i.e. the line proÔ¨Åle function is independent of
direction. The tilde is to say that this is the comoving line proÔ¨Åle. It is given by
Àúùúôùëñùëó(ùúà) =
ùëê
ùëétotùúàùëñùëó
‚àöùúãexp
(Ô∏É
‚àíùëê2(ùúà‚àíùúàùëñùëó)2
ùëé2
totùúà2
ùëñùëó
)Ô∏É
where ùúàùëñùëóis the line-center frequency for the line and ùëétot is the line width in units of cm/s. For pure thermal broadning
we have
ùëétot = ùëétherm =
‚àöÔ∏Ç
2ùëòùëágas
ùëömol
where ùëömol is the weight of the molecule in gram, ùëòis the Boltzmann constant, ùëágas the gas temperature in K. As we
shall discuss in Section INPUT: The local microturbulent broadening (optional): we can also add ‚Äòmicroturbulent line
broadning‚Äô ùëéturb, also in cm/s:
ùëétot =
‚àöÔ∏Å
ùëé2
turb + ùëé2
therm =
‚àöÔ∏Ç
ùëé2
turb + 2ùëòùëágas
ùëömol
When we have macroscopic velocities in our model, then the line proÔ¨Åle becomes angle-dependent (at a given lab-
frame frequency):
ùúôùëñùëó(ùúî, ùúà) = Àúùúôùëñùëó
(Ô∏Ä
ùúà(1 ‚àí‚Éóùúî¬∑ ‚Éóùë£/ùëê) ‚àíùúàùëñùëó
)Ô∏Ä
The radiative transfer equation for non overlapping lines is then
ùëëùêºùëñùëó(ùúî, ùúà)
ùëëùë†
= ùëóùëñùëó(ùúî, ùúà) ‚àíùõºùëñùëó(ùúî, ùúà)ùêºùëñùëó(ùúî, ùúà) .
But RADMC-3D naturally includes overlapping lines, at least in the ray-tracing (for spectra and images). For non-LTE
modes the line overlapping is not yet (as of December 2011) included.
7.3 Line transfer modes and how to activate the line transfer
Line transfer can be done in various different ways. This is controlled by the global variable lines_mode (see
below) and by the nature of the molecular/atomic data (see discussion in Section INPUT: The line.inp Ô¨Åle).
58
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
7.3.1 Two different atomic/molecular data Ô¨Åle types
Let us start with the latter: RADMC-3D does not have any atomic or molecular data hard-coded inside. It reads these
data from data Ô¨Åles that you provide. There are two fundamentally different ways to feed atomic/molecular data into
RADMC-3D:
‚Ä¢ Files containing the full level and line information (named molecule_XXX.inp, where XXX is the name of
the molecule or atom). Atoms or molecules for which this data is provided can be treated in LTE as well as in
non-LTE.
‚Ä¢ Files containing only a line list (named linelist_XXX.inp, where XXX is the name of the molecule or
atom). Atoms or molecules for which this data is provided can only be treated in LTE.
7.3.2 The different line modes (the lines_mode parameter)
For the atoms or molecules for which the full data are speciÔ¨Åed (the molecule_XXX.inp Ô¨Åles) RADMC-3D has
various different line transfer modes, including different treatments of LTE or non-LTE. Which of the modes you want
RADMC-3D to use can be speciÔ¨Åed in the radmc3d.inp Ô¨Åle by setting the variable lines_mode, for instance,
by adding the following line to radmc3d.inp:
lines_mode = 3
for LVG + Escape Probability populations. If no option is given, then the LTE mode (lines_mode=1) is used.
The various line modes are:
‚Ä¢ LTE mode (=default mode): [lines_mode=1]
In this mode the line radiative transfer is done under LTE assumptions.
‚Ä¢ User-deÔ¨Åned populations: [lines_mode=2]
This calls the routine userdef_compute_levelpop() to compute the level populations. This allows the
user to specify the populations of the levels of the molecules freely.
‚Ä¢ Large Velocity Gradient (Sobolev) populations: [lines_mode=3]
This is one of the non-LTE modes of RADMC-3D. This mode calculates the angle-averaged velocity gradient,
and uses this to compute the level populations according to the Large Velocity Gradient method (also often
called Sobolev‚Äôs method). This method is like an escape probability method, where the escape probability is
calculated based on the velocity gradient. For this mode to work, the velocity Ô¨Åeld has to be read in, as well as
at least one of the number densities of the collision partners of the molecule. See Section Non-LTE Transfer:
The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method.
‚Ä¢ Optically Thin non-LTE level populations method: [lines_mode=4]
This is one of the non-LTE modes of RADMC-3D. This mode calculates the non-LTE level populations under
the assumption that all emitted line radiation escapes and is not reabsorbed. For this mode to work, at least one
of the number densities of the collision partners of the molecule. See Section Non-LTE Transfer: The optically
thin line assumption method.
‚Ä¢ User-deÔ¨Åned populations: [lines_mode=-10]
This calls the routine userdef_general_compute_levelpop() on-the-Ô¨Çy during the ray-tracing. This
is very much like userdef_compute_levelpop(), except that it leaves the entire line-related stuff to the
user: It does not read the molecular data from a Ô¨Åle. NOTE: This is a rather tricky mode, to be used only if you
know very well what you are doing...
‚Ä¢ Full non-LTE modes: {bf Not yet ready}
7.3. Line transfer modes and how to activate the line transfer
59

radmc3d, Release 2.0
The default of the lines_mode variable is lines_mode=1.
NOTE 1: Line emission is automatically included in the images and spectra if RADMC-3D Ô¨Ånds the Ô¨Åle lines.inp
in the model directory. You can switch off the lines with the command-line option 'noline'.
NOTE 2: If you are very limited by memory, and if you use LTE, LVG+EscProb or optically thin populations, you
can also ask RADMC-3D to not precalculate the level populations before the rendering, but instead compute them on-
the-Ô¨Çy. This makes the code slower, but requires less memory. You can do this by choosing e.g. lines_mode=-3
instead of lines_mode=3 (for LVG+EscProb).
7.4 The various input Ô¨Åles for line transfer
7.4.1 INPUT: The line transfer entries in the radmc3d.inp Ô¨Åle
Like all other modules of radmc3d, also the line module can be steered through keywords in the radmc3d.inp
Ô¨Åle. Here is a list:
‚Ä¢ tgas_eq_tdust (default: 0)
Normally you must specify the gas temperature at each grid cell using the gas_temperature.inp Ô¨Åle
(or directly in the userdef_module.f90, see Chapter Modifying RADMC-3D: Internal setup and user-
speciÔ¨Åed radiative processes). But sometimes you may want to compute Ô¨Årst the dust temperature and then set
the gas temperature equal to the dust temperature. You can do this obviously by hand: read the output dust
temperature and create the equivalent gas temperature input Ô¨Åle from it. But that is cumbersome. By setting
tgas_eq_tdust=1 you tell radmc3d to simply read the dust_temperature.inp Ô¨Åle and then equate
the gas temperature to the dust temperature. If multiple dust species are present, only the Ô¨Årst species will be
used.
7.4.2 INPUT: The line.inp Ô¨Åle
Like with the dust (which has this dustopac.inp master Ô¨Åle, also the line module has a master Ô¨Åle: lines.inp.
It speciÔ¨Åes which molecules/atoms are to be modeled and in which Ô¨Åle the molecular/atomic data (such as the energy
levels and the Einstein ùê¥coefÔ¨Åcients) are to be found
iformat
<=== Put this to 2
N
Nr of molecular or atomic species to be
Àì‚Üímodeled
molname1 inpstyle1 iduma1 idumb1 ncol1
Which molecule used as species 1 + other info
.
.
.
molnameN inpstyleN idumaN idumbN ncolN
Which molecule used as species N + other info
The N is the number of molecular or atomic species you wish to model. Typically this is 1. But if you want to
simultaneously model for instance the ortho-H2O and para-H2O infrared lines, you would need to set this to 2.
The N lines following N (i.e. lines 3 to N+2) specify the molecule or atom, the kind of input Ô¨Åle format (explained
below), and two integers which, at least for now, can be simply set to 0 (see Section For experts: Selecting a subset of
lines and levels ‚Äòmanually‚Äô for the meaning of these integers - for experts only), plus Ô¨Ånally third integer, which has
to do with non-LTE transfer: the number of collision partners (set to 0 if you only intend to do LTE transfer).
The molecule name can be e.g.
co for carbon monoxide.
The Ô¨Åle containing the data should then be called
molecule_co.inp (even if it is an atom rather than a molecule; I could not Ô¨Ånd a good name which means both
molecule or atom). This Ô¨Åle should be either generated by the user, or (which is obviously the preferred option) taken
from one of the databases of molecular/atomic radiative properties. Since there are a number of such databases and I
60
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
want the code to be able to read those Ô¨Åles without the need of casting them into some special RADMC-3D format,
radmc3d allows the user to select which kind of Ô¨Åle the molecule_co.inp (for CO) Ô¨Åle is. At present only one
format is supported: the Leiden database. But more will follow. To specify to radmc3d to use the Leiden style, you
put the inpstyle to ‚Äòleiden‚Äô. So here is a typical example of a lines.inp Ô¨Åle:
2
1
co
leiden
0
0
0
This means: one molecule will be modeled, namely CO (and thus read from the Ô¨Åle molecule_co.inp), and the
data format is the Leiden database format.
NOTE: Since version 0.26 the Ô¨Åle format number of this Ô¨Åle lines.inp has increased. It is now 2, because in each
line an extra integer is added.
NOTE: The Ô¨Åles from the Leiden LAMDA database (see Section INPUT: Molecular/atomic data:
The
molecule_XXX.inp Ô¨Åle(s)) are usually called something like co.dat.
You will have to simply rename to
molecule_co.inp.
Most molecular data Ô¨Åles have, in addition to the levels and radiative rates, also the collision rates listed. See Section
INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s). For non-LTE radiative transfer this is essential infor-
mation. The number densities of the collision partners (the particles with which the molecule can collide and which
can collisionally excited or de-excite the molecule) are given in number density Ô¨Åles with the same format as those of
the molecule itself (see Section INPUT: The number density of collision partners (for non-LTE transfer)). However,
we must tell RADMC-3D to which collision partner particle the rate tables listed in the molecule_co.inp are as-
sociated (see Section INPUT: The number density of collision partners (for non-LTE transfer) for a better explanation
of the issue here). This can be done with the last of the integers in each line. Example: if the lines.inp Ô¨Åle reads:
2
1
co
leiden
0
0
2
p-h2
o-h2
this means that the Ô¨Årst collision rate table (starting with the number 3.2e-11 in the example of Section INPUT:
Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s)) is for collisions with particles for which the number density is
given in the Ô¨Åle numberdens_p-h2.inp and the second collision rate table (starting with the number 4.1e-11 in
the example of Section INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s)) is for collisions with particles
for which the number density is given in the Ô¨Åle numberdens_o-h2.inp.
We could also decide to ignore the difference between para-H2 and ortho-H2, and simply use the Ô¨Årst table (starting
with the number 3.2e-11 in the example of Section INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s)),
which is actually for para-H2 only, as a proxy for the overall mixture of H2 molecules. After all: The collision rate for
para-H2 and ortho-H2 are not so very different. In that case we may simply ignore this difference and only provide a
Ô¨Åle numberdens_h2.inp, and link that to the Ô¨Årst of the two collision rate tables:
2
1
co
leiden
0
0
1
h2
(Note: we cannot, in this way, link this to the second of the two tables, only to the Ô¨Årst). But if we would do this:
2
1
co
leiden
0
0
3
p-h2
(continues on next page)
7.4. The various input Ô¨Åles for line transfer
61

radmc3d, Release 2.0
(continued from previous page)
o-h2
h
we would get an error, because only two collision rate tables are provided in molecule_co.inp.
Finally, as we will explain in Section INPUT: Molecular/atomic data: The linelist_XXX.inp Ô¨Åle(s), there is an alterna-
tive way to feed atomic/molecular data into RADMC-3D: By using linelists. To tell RADMC-3D to read a linelist Ô¨Åle
instead of a Leiden-style molecular/atomic data Ô¨Åle, just write the following in the lines.inp Ô¨Åle:
2
1
h2o
linelist 0
0
0
(example here is for water). This will make RADMC-3D read the linelist_h2o.inp Ô¨Åle as a linelist Ô¨Åle (see
Section INPUT: Molecular/atomic data: The linelist_XXX.inp Ô¨Åle(s)). Note that lines from a linelist will always be in
LTE.
You can also have multiple species, for which some are of Leiden-style and some are linelist style. For instance:
2
2
co
leiden
0
0
2
p-h2
o-h2
h2o
linelist 0
0
0
Here the CO lines can be treated in a non-LTE manner (depending on what you put for lines_mode, see Section
Line transfer modes and how to activate the line transfer), and the H2O is treated in LTE.
7.4.3 INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s)
As mentioned in Section INPUT: The line.inp Ô¨Åle the atomic or molecular fundamental data such as the level di-
agram and the radiative decay rates (Einstein A coefÔ¨Åcients) are read from a Ô¨Åle (or more than one Ô¨Åles) named
molecule_XXX.inp, where the XXX is to be replaced by the name of the molecule or atom in question. For these
Ô¨Åles RADMC-3D uses the Leiden LAMDA database format. Note that, instead of a molecule_XXX.inp Ô¨Åle you
can also give a linelist Ô¨Åle, but this will be discussed in Section INPUT: Molecular/atomic data: The linelist_XXX.inp
Ô¨Åle(s).
The precise format of the Leiden database data Ô¨Åles is of course described in detail on their web page http://www.strw.
leidenuniv.nl/~moldata/ . Here we only give a very brief overview, based on an example of CO in which only the Ô¨Årst
few levels are speciÔ¨Åed (taken from the LAMDA database):
!MOLECULE (Data from the LAMDA database)
CO
!MOLECULAR WEIGHT
28.0
!NUMBER OF ENERGY LEVELS
5
!LEVEL + ENERGIES(cm^-1) + WEIGHT + J
1
0.000000000
1.0
0
2
3.845033413
3.0
1
3
11.534919938
5.0
2
4
23.069512649
7.0
3
5
38.448164669
9.0
4
!NUMBER OF RADIATIVE TRANSITIONS
(continues on next page)
62
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
(continued from previous page)
4
!TRANS + UP + LOW + EINSTEINA(s^-1) + FREQ(GHz) + E_u(K)
1
2
1
7.203e-08
115.2712018
5.53
2
3
2
6.910e-07
230.5380000
16.60
3
4
3
2.497e-06
345.7959899
33.19
4
5
4
6.126e-06
461.0407682
55.32
The Ô¨Årst few lines are self-explanatory. The Ô¨Årst of the two tables is about the levels. Column one is simply a
numbering. Column 2 is the energy of the level ùê∏ùëò, speciÔ¨Åed in units of 1/cm. To get the energy in erg you multiply
this number with ‚Ñéùëê/ùëòwhere ‚Ñéis the Planck constant, ùëêthe light speed and ùëòthe Boltzmann constant. Column 3 is
the degeneration number, i.e. the the ùëîparameter of the level. Column 4 is redundant information, not used by the
code.
The second table is the line list. Column 1 is again a simple counter. Column 2 and 3 specify which two levels the line
connects. Column 4 is the radiative decay rate in units of 1/s, i.e. the Einstein ùê¥coefÔ¨Åcient. The last two columns are
redundant information that can be easily derived from the other information.
If you are interested in LTE line transfer, this is enough information. However, if you want to use one of the non-LTE
modes of RADMC-3D, you must also have the collisional rate data. An example of a molecule_XXX.inp Ô¨Åle that
also contains these data is:
!MOLECULE (Data from the LAMDA database)
CO
!MOLECULAR WEIGHT
28.0
!NUMBER OF ENERGY LEVELS
10
!LEVEL + ENERGIES(cm^-1) + WEIGHT + J
1
0.000000000
1.0
0
2
3.845033413
3.0
1
3
11.534919938
5.0
2
4
23.069512649
7.0
3
5
38.448164669
9.0
4
!NUMBER OF RADIATIVE TRANSITIONS
9
!TRANS + UP + LOW + EINSTEINA(s^-1) + FREQ(GHz) + E_u(K)
1
2
1
7.203e-08
115.2712018
5.53
2
3
2
6.910e-07
230.5380000
16.60
3
4
3
2.497e-06
345.7959899
33.19
4
5
4
6.126e-06
461.0407682
55.32
!NUMBER OF COLL PARTNERS
2
!COLLISIONS BETWEEN
2 CO-pH2 from Flower (2001) & Wernli et al. (2006) + extrapolation
!NUMBER OF COLL TRANS
10
!NUMBER OF COLL TEMPS
7
!COLL TEMPS
5.0
10.0
20.0
30.0
50.0
70.0
100.0
!TRANS + UP + LOW + COLLRATES(cm^3 s^-1)
1
2
1
3.2e-11 3.3e-11 3.3e-11 3.3e-11 3.4e-11 3.4e-11 3.4e-11
2
3
1
2.9e-11 3.0e-11 3.1e-11 3.2e-11 3.2e-11 3.2e-11 3.2e-11
3
3
2
7.9e-11 7.2e-11 6.5e-11 6.1e-11 5.9e-11 6.0e-11 6.5e-11
4
4
1
4.8e-12 5.2e-12 5.6e-12 6.0e-12 7.1e-12 8.4e-12 1.2e-11
5
4
2
4.7e-11 5.0e-11 5.1e-11 5.1e-11 5.1e-11 5.1e-11 5.1e-11
6
4
3
9.0e-11 7.9e-11 7.1e-11 6.7e-11 6.5e-11 6.6e-11 7.2e-11
(continues on next page)
7.4. The various input Ô¨Åles for line transfer
63

radmc3d, Release 2.0
(continued from previous page)
7
5
1
2.8e-12 3.1e-12 3.4e-12 3.7e-12 4.0e-12 4.4e-12 4.0e-12
8
5
2
8.0e-12 9.6e-12 1.1e-11 1.2e-11 1.4e-11 1.6e-11 2.2e-11
9
5
3
5.9e-11 6.2e-11 6.2e-11 6.1e-11 6.0e-11 5.9e-11 5.8e-11
10
5
4
8.5e-11 8.2e-11 7.5e-11 7.1e-11 6.9e-11 6.9e-11 7.3e-11
!COLLISIONS BETWEEN
3 CO-oH2 from Flower (2001) & Wernli et al. (2006) + extrapolation
!NUMBER OF COLL TRANS
10
!NUMBER OF COLL TEMPS
7
!COLL TEMPS
5.0
10.0
20.0
30.0
50.0
70.0
100.0
!TRANS + UP + LOW + COLLRATES(cm^3 s^-1)
1
2
1
4.1e-11 3.8e-11 3.4e-11 3.3e-11 3.4e-11 3.5e-11 3.9e-11
2
3
1
5.8e-11 5.6e-11 5.2e-11 5.0e-11 4.7e-11 4.7e-11 6.2e-11
3
3
2
7.5e-11 7.1e-11 6.6e-11 6.2e-11 6.1e-11 6.2e-11 7.1e-11
4
4
1
6.6e-12 7.1e-12 7.3e-12 7.5e-12 8.1e-12 9.0e-12 1.3e-11
5
4
2
7.9e-11 8.3e-11 8.1e-11 7.8e-11 7.4e-11 7.3e-11 8.5e-11
6
4
3
8.0e-11 7.5e-11 7.0e-11 6.8e-11 6.7e-11 6.9e-11 7.7e-11
7
5
1
5.8e-12 6.1e-12 6.1e-12 6.1e-12 6.2e-12 6.3e-12 7.8e-12
8
5
2
1.0e-11 1.2e-11 1.4e-11 1.4e-11 1.6e-11 1.8e-11 2.2e-11
9
5
3
8.3e-11 8.9e-11 9.0e-11 8.8e-11 8.3e-11 8.1e-11 8.7e-11
10
5
4
8.0e-11 7.9e-11 7.5e-11 7.2e-11 7.1e-11 7.1e-11 7.6e-11
As you see, the Ô¨Årst part is the same. Now, however, there is extra information. First, the number of collision partners,
for which these collisional rate data is speciÔ¨Åed, is given. Then follows the reference to the paper containing these data
(this is not used by RADMC-3D; it is just for information). Then the number of collisional transitions that are tabulated
(since collisions can relate any level to any other level, this number should ideally be nlevels*(nlevels-1)/2,
but this is not strictly enforced). Then the number of temperature points at which these collisional rates are tabulated.
Then follows this list of temperatures. Finally we have the table of collisional transitions. Each line consists of, Ô¨Årst,
the ID of the transition (dummy), then the upper level, then the lower level, and then the ùêæup,low collisional rates in
units of [cm3/ùë†]. The same is again repeated (because in this example we have two collision partners: the para-H2
molecule and the ortho-H2 molecule).
To get the collision rate ùê∂up,low per molecule (in units of [1/s]) for the molecule of interest, we must multiply ùêæup,low
with the number density of the collision partner (see Section INPUT: The number density of collision partners (for
non-LTE transfer)). So in this example, the ùê∂up,low becomes:
ùê∂up,low = ùëÅp‚àíH2ùêæp‚àíH2
up,low + ùëÅo‚àíH2ùêæo‚àíH2
up,low
The rates tabulated in this Ô¨Åle are always the downward collision rate. The upward rate is internally computed by
RADMC-3D using the following formula:
ùê∂low,up = ùê∂up,low
ùëîup
ùëîlow
exp
(Ô∏Ç
‚àí‚àÜùê∏
ùëòùëá
)Ô∏Ç
where the ùëîfactors are the statistical weights of the levels, ‚àÜùê∏is the energy difference between the levels, ùëòis the
Boltzmann constant and ùëáthe gas temperature.
Some notes:
‚Ä¢ When doing LTE transfer and you make RADMC-3D read a separate Ô¨Åle with the partition function (Section
INPUT for LTE line transfer: The partition function (optional)), you can limit the molecule_XXX.inp Ô¨Åles
to just the levels and lines you are interested in. But again: You must then read the partition function separately,
and not let RADMC-3D compute it internally based on the molecule_XXX.inp Ô¨Åle.
‚Ä¢ When doing non-LTE transfer and/or when you let RADMC-3D compute the partition function internally you
must make sure to include all possible levels that might get populated, otherwise you may overpredict the
strength of the lines you are interested in.
64
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
‚Ä¢ The association of each of the collision partners in this Ô¨Åle to Ô¨Åles that contain their spatial distribution is a bit
complicated. See Section INPUT: The number density of collision partners (for non-LTE transfer).
7.4.4 INPUT: Molecular/atomic data: The linelist_XXX.inp Ô¨Åle(s)
In many cases molecular data are merely given as lists of lines (e.g. the HITRAN database, the Kurucz database, the
Jorgensen et al. databases etc.). These line lists contain information about the line wavelength ùúÜ0, the line strength
ùê¥ud, the statistical weights of the lower and upper level and the energy of the lower or upper level. Sometimes also
the name or set of quantum numbers of the levels, or additional information about the line proÔ¨Åle shapes are speciÔ¨Åed.
These line lists contain no direct information about the level diagram, although this information can be extracted from
the line list (if it is complete). These lines lists also do not contain any information about collisional (de-)excitation,
so they cannot be used for non-LTE line transfer of any kind. They only work for LTE line transfer. But such line lists
are nevertheless used often (and thus LTE is then assumed).
RADMC-3D can read the molecular data in line-list-form (Ô¨Åles named linelist_XXX.inp). RADMC-3D can
in fact use both formats mixed (the line list one and the ‚Äònormal‚Äô one of Section INPUT: Molecular/atomic data:
The molecule_XXX.inp Ô¨Åle(s)). Some molecules may be speciÔ¨Åed as line lists (linelist_XXX.inp) while simul-
taneously others as full molecular Ô¨Åles (molecule_XXX.inp, see Section INPUT: Molecular/atomic data: The
molecule_XXX.inp Ô¨Åle(s)). For the ‚Äòlinelist molecules‚Äô RADMC-3D will then automatically use LTE, while for the
other molecules RADMC-3D will use the mode according to the lines_mode value. This means that you can use
this to have mixed LTE and non-LTE species of molecules/atoms within the same model, as long as the LTE ones have
their molecular/atomic data given in a line list form. This can be useful to model situations where most of the lines are
in LTE, but one (or a few) are non-LTE.
Now coming back to the linelist data. Here is an example of such a Ô¨Åle (created from data from the HITRAN database):
! RADMC-3D Standard line list
! Format number:
1
! Molecule name:
h2o
! Reference: From the HITRAN Database (see below for more info)
! Molecular weight (in atomic units)
18.010565
! Include table of partition sum? (0=no, 1=yes)
1
! Include additional information? (0=no, 1=yes)
0
! Nr of temperature points for the partition sum
2931
!
Temp [K]
PartSum
7.000000E+01
2.100000E+01
7.100000E+01
2.143247E+01
7.200000E+01
2.186765E+01
7.300000E+01
2.230553E+01
....
....
....
2.997000E+03
1.594216E+04
2.998000E+03
1.595784E+04
2.999000E+03
1.597353E+04
3.000000E+03
1.598924E+04
! Nr of lines
37432
! ID
Lambda [mic]
Aud [sec^-1]
E_lo [cm^-1]
E_up [cm^-1]
g_lo
g_up
1
1.387752E+05
5.088000E-12
1.922829E+03
1.922901E+03
11.
9.
(continues on next page)
7.4. The various input Ô¨Åles for line transfer
65

radmc3d, Release 2.0
(continued from previous page)
2
2.496430E+04
1.009000E-09
1.907616E+03
1.908016E+03
21.
27.
3
1.348270E+04
1.991000E-09
4.465107E+02
4.472524E+02
33.
39.
4
1.117204E+04
8.314000E-09
2.129599E+03
2.130494E+03
27.
33.
5
4.421465E+03
1.953000E-07
1.819335E+03
1.821597E+03
21.
27.
....
....
....
37429
3.965831E-01
3.427000E-05
7.949640E+01
2.529490E+04
15.
21.
37430
3.965250E-01
1.508000E-04
2.121564E+02
2.543125E+04
21.
27.
37431
3.964335E-01
5.341000E-05
2.854186E+02
2.551033E+04
21.
27.
37432
3.963221E-01
1.036000E-04
3.825169E+02
2.561452E+04
27.
33.
The Ô¨Åle is pretty self-explanatory. It contains a table for the partition function (necessary for LTE transfer) and a
table with all the lines (or any subset you wish to select). The lines table columns are as follows: Ô¨Årst column is
just a dummy index. Second column is the wavelength in micron. Third is the Einstein-A-coefÔ¨Åcient (spontaneous
downward rate) in units of s‚àí1. Fourth and Ô¨Åfth are the energies above the ground state of the lower and upper levels
belonging to this line in units of cm‚àí1. Sixth and seventh are the statistical weights (degenracies) of the lower and
upper levels belonging to this line.
Note that you can tell RADMC-3D to read linelist_h2o.inp (instead of search for molecule_h2o.inp) by
specifying linelist instead of leiden in the lines.inp Ô¨Åle (see Section INPUT: The line.inp Ô¨Åle).
7.4.5 INPUT: The number density of each molecular species
For the line radiative transfer we need to know how many molecules of each species are there per cubic centimeter.
For molecular/atom species XXX this is given in the Ô¨Åle numberdens_XXX.inp (see Chapter Binary I/O Ô¨Åles for
the binary version of this Ô¨Åle, which is more compact, and which you can use instead of the ascii version). For
each molecular/atomic species listed in the lines.inp Ô¨Åle there must be a corresponding numberdens_XXX.
inp Ô¨Åle. The structure of the Ô¨Åle is very similar (though not identical) to the structure of the dust density input Ô¨Åle
dust_density.inp (Section INPUT (required for dust transfer): dust_density.inp). For the precise way to address
the various cells in the different AMR modes, we refer to Section INPUT (required for dust transfer): dust_density.inp,
where this is described in detail.
For formatted style (numberdens_XXX.inp):
iformat
<=== Typically 1 at present
nrcells
numberdensity[1]
..
numberdensity[nrcells]
The number densities are to be speciÔ¨Åed in units of molecule per cubic centimeter.
7.4.6 INPUT: The gas temperature
For line transfer we need to know the gas temperature. You specify this in the Ô¨Åle gas_temperature.inp (see
Chapter Binary I/O Ô¨Åles for the binary version of these Ô¨Åles, which are more compact, and which you can use instead
of the ascii versions). The structure of this Ô¨Åle is identical to that described in Section INPUT: The number density
of each molecular species, but of course with number density replaced by gas temperature in Kelvin. For the precise
way to address the various cells in the different AMR modes, we refer to Section INPUT (required for dust transfer):
dust_density.inp, where this is described in detail.
Note: Instead of literally specifying the gas temperature you can also tell radmc3d to copy the dust temperature (if it
know it) into the gas temperature. See the keyword tgas_eq_tdust described in Section INPUT: The line transfer
66
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
entries in the radmc3d.inp Ô¨Åle.
7.4.7 INPUT: The velocity Ô¨Åeld
Since gas motions are usually the main source of Doppler shift or broadening in astrophysical settings, it is obligatory
to specify the gas velocity. This can be done with the Ô¨Åle gas_velocity.inp (see Chapter Binary I/O Ô¨Åles for
the binary version of these Ô¨Åles, which are more compact, and which you can use instead of the ascii versions). The
structure is again similar to that described in Section INPUT: The number density of each molecular species, but now
with three numbers at each grid point instead of just one. The three numbers are the velocity in ùë•, ùë¶and ùëßdirection
for Cartesian coordinates, or in ùëü, ùúÉand ùúëdirection for spherical coordinates. Note that both in cartesian coordinates
and in spherical coordinates all velocity components have the same dimension of cm/s. For spherical coordinates the
conventions are: positive ùë£ùëüpoints outwards, positive ùë£ùúÉpoints downward (toward larger ùúÉ) for 0 < ùúÉ< ùúã(where
‚Äòdownward‚Äô is toward smaller ùëß), and positive ùë£ùúëmeans velocity in counter-clockwise direction in the ùë•, ùë¶-plane.
For the precise way to address the various cells in the different AMR modes, we refer to Section INPUT (required for
dust transfer): dust_density.inp, where this is described in detail.
7.4.8 INPUT: The local microturbulent broadening (optional)
The radmc3d code automatically includes thermal broadening of the line. But sometimes it is also useful to specify a
local (spatially unresolved) turbulent width. This is not obligatory (if it is not speciÔ¨Åed, only the thermal broadening is
used) but if you want to specify it, you can do so in the Ô¨Åle microturbulence.inp (see Chapter Binary I/O Ô¨Åles
for the binary version of these Ô¨Åles, which are more compact, and which you can use instead of the ascii versions).
The Ô¨Åle format is the same structure as described in Section INPUT: The number density of each molecular species.
For the precise way to address the various cells in the different AMR modes, we refer to Section INPUT (required for
dust transfer): dust_density.inp, where this is described in detail.
Here is the way it is included into the line proÔ¨Åle:
ùëé2
linewidth = ùëé2
turb + 2ùëòùëágas
ùúá
where ùëágas is the temperature of the gas, ùúáthe molecular weight, ùëòthe Boltzmann constant and ùëéturb the microturbu-
lent line width in units of cm/s. The ùëélinewidth is then the total (thermal plus microturbulent) line width.
7.4.9 INPUT for LTE line transfer: The partition function (optional)
If you use the LTE mode (either lines_mode=-1 or lines_mode=1), then the partition function is required to
calculate, for a given temperature the populations of the various levels. Since this involves a summation over all levels
of all kinds that can possibly be populated, and since the molecular/atomic data Ô¨Åle may not include all these possible
levels, it may be useful to look the partition function up in some literature and give this to radmc3d. This can be
done with the Ô¨Åle partitionfunction_XXX.inp, where again XXX is here a placeholder for the actual name
of the molecule at hand. If you do not have this Ô¨Åle in the present model directory, then radmc3d will compute the
partition function itself, but based on the (maybe limited) set of levels given in the molecular data Ô¨Åle. The structure
of the partitionfunction_XXX.inp Ô¨Åle is:
iformat
; The usual format number, currently 1
ntemp
; The number of temperatures at which it is specified
temp(1)
pfunc(1)
temp(2)
pfunc(2)
.
.
.
.
.
.
temp(ntemp)
pfunc(ntemp)
7.4. The various input Ô¨Åles for line transfer
67

radmc3d, Release 2.0
NOTE: RADMC-3D assumes the partition function to be deÔ¨Åned in the following way:
ùëç(ùëá) =
‚àëÔ∏Å
ùëñ=1
ùëîùëñùëí‚àí(ùê∏ùëñ‚àíùê∏1)/ùëòùëá
In other words: the Ô¨Årst level is assumed to be the ground state. This is done so that one can also use an energy
deÔ¨Ånition in which the ground state energy is non-zero (example: Hydrogen ùê∏1 = ‚àí13.6 eV). If you use molecular
line dataÔ¨Åles that contain only a subset of levels (which is in principle no problem for LTE calculations) then it is
essential that the ground state is included in this list, and that it is the Ô¨Årst level (ilevel=1).
7.4.10 INPUT: The number density of collision partners (for non-LTE transfer)
For non-LTE line transfer (see e.g. Sections Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape Prob-
ability (EscProb) method, Non-LTE Transfer: The optically thin line assumption method) the molecules can be colli-
sionally excited. The collision rates for each pair of molecule + collision partner are given in the molecular input data
Ô¨Åles (Section INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s)). To Ô¨Ånd how often a molecular level of a
single molecule is collisionally excited to another level we also need to know the number density of the collision part-
ner molecules. In the example in Section INPUT: Molecular/atomic data: The molecule_XXX.inp Ô¨Åle(s) these were
para-H2 and ortho-H2. We must therefore somehow tell RADMC-3D what the number densities of these molecules
are. This is done by reading in the number densities for this(these) collision partner(s). The Ô¨Åle for this has exactly the
same format as that for the number density of any molecule (see Section INPUT: The number density of each molec-
ular species). So for our example we would thus have two Ô¨Åles, which could be named numberdens_p-h2.inp
and numberdens_o-h2.inp respectively. See Section INPUT: The number density of each molecular species for
details.
However, how does RADMC-3D know that the Ô¨Årst collision partner of CO is called p-h2 and the second o-h2?
In principle the Ô¨Åle molecule_co.inp give some information about the name of the collision partners. But this
is often not machine-readable. Example, in molecule_co.inp of Section INPUT: Molecular/atomic data: The
molecule_XXX.inp Ô¨Åle(s) the line that should tell this reads:
2 CO-pH2 from Flower (2001) & Wernli et al. (2006) + extrapolation
for the Ô¨Årst of the two (which is directly from the LAMDA database). This is hard to decipher for RADMC-3D.
Therefore you have to tell this explicitly in the Ô¨Åle lines.inp, and we refer to Section INPUT: The line.inp Ô¨Åle for
how to do this.
7.5 Making images and spectra with line transfer
Making images and spectra with/of lines works in the same way as for the continuum. RADMC-3D will check if the
Ô¨Åle lines.inp is present in your directory, and if so, it will automatically switch on the line transfer. If you insist on
not having the lines switched on, in spite of the presence of the lines.inp Ô¨Åle, you can add the option noline to
radmc3d on the command line. If you don‚Äôt, then lines are normally automatically switched on, except in situations
where it is obviously not required.
You can just make an image at some wavelength and you‚Äôll get the image with any line emission included if it is there.
For instance, if you have the molecular data of CO included, then:
radmc3d image lambda 2600.757
will give an image right at the CO 1-0 line center. The code will automatically check if (and if yes, which) line(s) are
contributing to the wavelength of interest. Also it will include all the continuum emission (and absorption) that you
would usually obtain.
There is, however, an exception to this automatic line inclusion: If you make a spectral energy distribution (with the
command sed, see Section Making spectra), then lines are not included. The same is true if you use the loadcolor
68
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
command. But for normal spectra or images the line emission will automatically be included. So if you make a
spectrum at wavelength around some line, you will get a spectrum including the line proÔ¨Åle from the object, as well
as the dust continuum.
It is not always convenient to have to know by heart the exact wavelengths of the lines you are interested in. So
RADMC-3D allows you to specify the wavelength by specifying which line of which molecule, and at which velocity
you want to render:
radmc3d image iline 2 vkms 2.4
If you have CO as your molecule, then iline 2 means CO 2-1 (the second line in the rotational ladder).
By default the Ô¨Årst molecule is used (if you have more than one molecule), but you can also specify another one:
radmc3d image imolspec 2 iline 2 vkms 2.4
which would select the second molecule instead of the Ô¨Årst one.
If you wish to make an entire spectrum of the line, you can do for instance:
radmc3d spectrum iline 1 widthkms 10
which produces a spectrum of the line with a passband going from -10 km/s to +10 km/s. By default 40 wavelength
points are used, and they are evenly spaced. You can set this number of wavelengths:
radmc3d spectrum iline 1 widthkms 10 linenlam 100
which would make a spectrum with 100 wavelength points, evenly spaced around the line center. You can also shift
the passband center:
radmc3d spectrum iline 1 widthkms 10 linenlam 100 vkms -10
which would make the wavelength grid 10 kms shifted in short direction.
Note that you can use the widthkms and linenlam keywords also for images:
radmc3d image iline 1 widthkms 10 linenlam 100
This will make a multi-color image, i.e. it will make images at 100 wavelenths points evenly spaced around the line
center. In this way you can make channel maps.
For more details on how to specify the spectral sampling, please read Section Specifying custom-made sets of wave-
length points for the camera. Note that keywords such as incl, phi, and any other keywords specifying the camera
position, zooming factor etc, can all be used in addition to the above keywords.
7.5.1 Speed versus realism of rendering of line images/spectra
As usual with numerical modeling: including realism to the modeling goes at the cost of rendering speed. A ‚Äòfully
realistic‚Äô rendering of a model spectrum or image of a gas line involves (assuming the level populations are already
known):
1. Doppler-shifted emission and absorption.
2. Inclusion of dust thermal emission and dust extinction while rendering the lines.
3. Continuum emission scattered by dust into the line-of-sight
4. Line emission from (possibly obscured) other regions is allowed to scatter into the line-of-sight by dust grains
(see Section Line emission scattered off dust grains).
7.5. Making images and spectra with line transfer
69

radmc3d, Release 2.0
RADMC-3D always includes the Doppler shifts. By default, RADMC-3D also includes dust thermal emission and
extinction, as well as the scattered continuum radiation.
For many lines, however, dust continuum scattering is a negligible portion of the Ô¨Çux, so you can speed things up
by not including dust scattering! This can be easily done by adding the noscat option on the command-line when
you issue the command for a line spectrum or multi-frequency image. This way, the scattering source function is not
computed (is assumed to be zero), and no scattering Monte Carlo runs are necessary. This means that the ray-tracer
can now render all wavelength simultaneously (each ray doing all wavelength at the same time), and the local level
populations along each ray can now be computed once, and be used for all wavelengths. This may speed up things
drastically, and for most purposes virtually perfectly correct. Just beware that when you render short-wavelength lines
(optical) or you use large grains, i.e. when the scattering albedo at the wavelength of the line is not negligible, this
may result in a mis-estimation of the continuum around the line.
7.5.2 Line emission scattered off dust grains
NOTE: The contents of this subsection may not be 100% implemented yet.
Also any line emission from obscured regions that get scattered into the line of sight by the dust (if dust scattering is
included) will be included. Note, however, that any possible Doppler shift induced by this scattering is not included.
This means that if line emission is scattered by a dust cloud moving at a very large speed, then this line emission will
be scattered by the dust, but no Doppler shift at the projected velocity of the dust will be added. Only the Doppler
shift of the line-emitting region is accounted for. This is rarely a problem, because typically the dust that may scatter
line emission is located far away from the source of line emission and moves at substantially lower speed.
7.6 Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape
Probability (EscProb) method
The assumption that the energy levels of a molecule or atom are always populated according to a thermal distribution
(the so-called ‚Äòlocal thermodynamic equilibrium‚Äô, or LTE, assumption) is valid under certain circumstances. For
instance for planetary atmospheres in most cases. But in the dilute interstellar medium this assumption is very often
invalid. One must then compute the level populations consistent with the local density and temperature, and often
also consistent with the local radiation Ô¨Åeld. Part of this radiation Ô¨Åeld might even be the emission from the lines
themselves, meaning that the molecules radiatively inÔ¨Çuence their neighbors. Solving the level populations self-
consistently is called ‚Äònon-LTE radiative transfer‚Äô. A full non-LTE radiative transfer calculation is, however, in most
cases (a) too numerically demanding and sometimes (b) unnecessary. Sometimes a simple approximation of the non-
LTE effects is sufÔ¨Åcient.
One such approximation method is the ‚ÄòLarge Velocity Gradient‚Äô (LVG) method, also called the ‚ÄòSobolev approxima-
tion‚Äô. Please read for instance the paper by Ossenkopf (1997) ‚ÄòThe Sobolev approximation in molecular clouds‚Äô, New
Astronomy, 2, 365 for more explanation, and a study how it works in the context of molecular clouds. The LVG mode
of RADMC-3D has been used for the Ô¨Årst time by Shetty et al. (2011, MNRAS 412, 1686), and a description of the
method is included in that paper. The nice aspect of this method is that it is, for most part, local. The only slightly
non-local aspect is that a velocity gradient has to be computed by comparing the gas velocity in one cell with the gas
velocity in neighboring cells.
As of RADMC-3D Version 0.33 the LVG method is combined with an escape probability (EscProb) method. In fact,
LVG is a kind of escape probability method itself. It is just that for the classic EscProb method the photons can escape
due to the Ô¨Ånite size of the object, and thus the Ô¨Ånite optical depth in the lines. In the LVG the object size is not the
issue, but the gradient of the velocity. The line width combined with the velocity gradient give a length scale over
which a photon can escape.
In the LVG + EscProb method the line-integrated mean intensity ùêΩùëñùëóis given by
70
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
ùêΩùëñùëó= (1 ‚àíùõΩùëñùëó)ùëÜùëñùëó+ ùõΩùëñùëóùêΩbg
ùëñùëó
where ùêΩbg
ùëñùëóis the mean intensity of the background radiation Ô¨Åeld at frequency ùúà= ùúàùëñùëó(default is blackbody at 2.73
K, but this temperature can be varied with the lines_tbg variable in radmc3d.inp), while ùõΩùëñùëóis the escape
probability for line ùëñ‚Üíùëó. This is given by
ùõΩùëñùëó= 1 ‚àíexp(‚àíùúèùëñùëó)
ùúèùëñùëó
where ùúèùëñùëóis the line-center optical depth in the line.
For the LVG method this optical depth is given by the velocity gradient:
ùúèLVG
ùëñùëó
= ùëê‚Ñé
4ùúã
ùëÅmolec
1.064 |‚àá‚Éóùë£| [ùëõùëóùêµùëóùëñ‚àíùëõùëñùêµùëñùëó]
=
ùëê3
8ùúãùúà3
ùëñùëó
ùê¥ùëñùëóùëÅmolec
1.064 |‚àá‚Éóùë£|
[Ô∏Çùëîùëñ
ùëîùëó
ùëõùëó‚àíùëõùëñ
]Ô∏Ç
(see e.g. van der Tak et al. 2007, A&A 468, 627), where ùëõùëñis the fractional level population of level ùëñ, ùëÅmolec the
total number density of the molecule, |‚àá‚Éóùë£| the absolute value of the velocity gradient, ùëîùëñthe statistical weight of level
ùëñand ùúàùëñùëóthe line frequency for transition ùëñ‚Üíùëó. In comparing to Eq. 21 of van der Tak‚Äôs paper, note that their ùëÅmol
is a column density (cm‚àí2) and their ‚àÜùëâis the line width (cm/s), while our ùëÅmolec is the number density (cm‚àí3) and
|‚àá‚Éóùë£| is the velocity gradient (s‚àí1). Their formula is thus in fact EscProb while ours is LVG.
For the EscProb method without velocity gradients, we need to be able to compute the total column depth Œ£molec in
the direction where this Œ£molec is minimal. This is something that, at the moment, RADMC-3D cannot yet do. But
this is something that can be estimated based on a ‚Äòtypical length scale‚Äô ùêø, such that
Œ£molec ‚âÉùëÅmolec ùêø
RADMC-3D allows you to specify ùêøseparately for each cell (in the Ô¨Åle escprob_lengthscale.inp or its binary
version). The simplest would be to set it to a global value equal to the typical size of the object we are interested in.
Then the line-center optical depth, assuming a Gaussian line proÔ¨Åle with width ùëélinewidth, is
ùúèEscProb
ùëñùëó
=
‚ÑéùëêŒ£molec
4ùúã‚àöùúãùëélinewidth
[ùëõùëóùêµùëóùëñ‚àíùëõùëñùêµùëñùëó]
because ùúë(ùúà= ùúàùëñùëó) = ùëê/(ùëéùúàùëñùëó
‚àöùúã).
The optical depth of the combined LVG + EscProb method is then:
ùúèùëñùëó= min
(Ô∏Ä
ùúèLVG
ùëñùëó
, ùúèEscProb
ùëñùëó
)Ô∏Ä
This is then the ùúèùëñùëóthat needs to be inserted into Eq. (eq-escprob-beta-formula) for obtaining the escape probability
ùõΩùëñùëó(which includes escape due to LVG as well as the Ô¨Ånite length scale ùêø).
The LVG+EscProb method solves at each location the following statistical equilibrium equation:
‚àëÔ∏Å
ùëó>ùëñ
[Ô∏Å
ùëõùëóùê¥ùëóùëñ+ (ùëõùëóùêµùëóùëñ‚àíùëõùëñùêµùëñùëó)ùêΩùëóùëñ
]Ô∏Å
‚àí
‚àëÔ∏Å
ùëó<ùëñ
[Ô∏Å
ùëõùëñùê¥ùëñùëó+ (ùëõùëñùêµùëñùëó‚àíùëõùëóùêµùëóùëñ)ùêΩùëñùëó
]Ô∏Å
+
‚àëÔ∏Å
ùëóÃ∏=ùëñ
[Ô∏Ä
ùëõùëóùê∂ùëóùëñ‚àíùëõùëñùê∂ùëñùëó
]Ô∏Ä
= 0
7.6. Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method71

radmc3d, Release 2.0
Replacing ùêΩùëñùëó(and similarly ùêΩùëóùëñ) with the expression of Eq. (eq-linemeanint-escp) and subsequently replacing ùëÜùëñùëó
with the well-known expression for the line source function
ùëÜùëñùëó=
ùëõùëñùê¥ùëñùëó
ùëõùëóùêµùëóùëñ‚àíùëõùëñùêµùëñùëó
leads to
‚àëÔ∏Å
ùëó>ùëñ
[Ô∏Å
ùëõùëóùê¥ùëóùëñùõΩùëóùëñ+ (ùëõùëóùêµùëóùëñ‚àíùëõùëñùêµùëñùëó)ùõΩùëóùëñùêΩbg
ùëóùëñ
]Ô∏Å
‚àí
‚àëÔ∏Å
ùëó<ùëñ
[Ô∏Å
ùëõùëñùê¥ùëñùëóùõΩùëñùëó+ (ùëõùëñùêµùëñùëó‚àíùëõùëóùêµùëóùëñ)ùõΩùëñùëóùêΩbg
ùëñùëó
]Ô∏Å
+
‚àëÔ∏Å
ùëóÃ∏=ùëñ
[Ô∏Ä
ùëõùëóùê∂ùëóùëñ‚àíùëõùëñùê∂ùëñùëó
]Ô∏Ä
= 0
A few iteration steps are necessary, because the ùõΩùëñùëódepends on the optical depths, which depend on the populations.
But since this is only a weak dependence, the iteration should converge rapidly.
To use the LVG+EscProb method, the following has to be done:
‚Ä¢ Make sure that you use a molecular data Ô¨Åle that contains collision rate tables (see Section INPUT: Molecu-
lar/atomic data: The molecule_XXX.inp Ô¨Åle(s)).
‚Ä¢ Make
sure
to
provide
Ô¨Åle(s)
containing
the
number
densities
of
the
collision
partners,
e.g.
numberdens_p-h2.inp (see Section INPUT: The number density of collision partners (for non-LTE
transfer)).
‚Ä¢ Make sure to link the rate tables to the number density Ô¨Åles in lines.inp (see Section INPUT: The line.inp
Ô¨Åle).
‚Ä¢ Set the lines_mode=3 in the radmc3d.inp Ô¨Åle.
‚Ä¢ You may want to also specify the maximum number of iterations for non-LTE iterations, by setting
lines_nonlte_maxiter in the radmc3d.inp Ô¨Åle. The default is 100 (as of version 0.36). If con-
vergence is not reached within lines_nonlte_maxiter iterations, RADMC-3D stops.
‚Ä¢ You
may
want
to
also
specify
the
convergence
criterion
for
non-LTE
iterations,
by
setting
lines_nonlte_convcrit in the radmc3d.inp Ô¨Åle.
The default is 1d-2 (which is not very strict!
Smaller values may be necessary).
‚Ä¢ Specify the gas velocity vector Ô¨Åeld in the Ô¨Åle gas_velocity.inp (or .binp), see Section INPUT: The
velocity Ô¨Åeld. If this Ô¨Åle is not present, the gas velocity will be assumed to be 0 everywhere, meaning that you
have pure escape probability.
‚Ä¢ Specify the ‚Äòtypical length scale‚Äô ùêøat each cell in the Ô¨Åle escprob_lengthscale.inp (or .binp). If this
Ô¨Åle is not present, then the length scale is assumed to be inÔ¨Ånite, meaning that you are back at pure LVG. The
format of this Ô¨Åle is identical to that of the gas density.
Note that having no escprob_lengthscale.inp nor gas_velocity.inp Ô¨Åle in your model directory means
that the photons cannot escape at all, and you should Ô¨Ånd LTE populations (always a good test of the code).
Note that it is essential, when using the Large Velocity Gradient method without specifying a length scale, that the
gradients in the velocity Ô¨Åeld (given in the Ô¨Åle gas_velocity.inp, see Section INPUT: The velocity Ô¨Åeld) are
indeed sufÔ¨Åciently large. If they are zero, then this effectively means that the optical depth in all the lines is assumed
to be inÔ¨Ånite, which means that the populations are LTE again. If you use LVG but also specify a length scale in the
escprob_lengthscale.inp Ô¨Åle, then this danger of unphysically LTE populations is avoided.
NOTE: Currently this method does not yet include radiative exchange with the dust continuum radiation Ô¨Åeld.
NOTE: Currently this method does not yet include radiative pumping by stellar radiation. Will be included soon.
72
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
7.7 Non-LTE Transfer: The optically thin line assumption method
An even simpler non-LTE method is applicable in very dilute media, in which the lines are all optically thin. This
means that a photon that is emitted by the gas will never be reabsorbed. If this condition is satisÔ¨Åed, then the non-
LTE level populations can be computed even easier than in the case of LVG (Section Non-LTE Transfer: The Large
Velocity Gradient (LVG) + Escape Probability (EscProb) method). No iteration is then required. So to activate this,
the following has to be done:
‚Ä¢ Make sure that you use a molecular data Ô¨Åle that contains collision rate tables (see Section INPUT: Molecu-
lar/atomic data: The molecule_XXX.inp Ô¨Åle(s)).
‚Ä¢ Make
sure
to
provide
Ô¨Åle(s)
containing
the
number
densities
of
the
collision
partners,
e.g.
numberdens_p-h2.inp (see Section INPUT: The number density of collision partners (for non-LTE
transfer)).
‚Ä¢ Make sure to link the rate tables to the number density Ô¨Åles in lines.inp (see Section INPUT: The line.inp
Ô¨Åle).
‚Ä¢ Set the lines_mode=4 in the radmc3d.inp Ô¨Åle (see Section INPUT: radmc3d.inp).
NOTE: Currently this method does not yet include radiative pumping by stellar radiation.
NOTE: This mode does not *make a model optically thin. Only the populations of the levels are computed under the
{bf assumption} that the lines are optically thin. If you subsequently make a spectrum or image of your model, all
absorption effects are again included.*
7.8 Non-LTE Transfer: Full non-local modes (FUTURE)
In the near future RADMC-3D will hopefully also feature full non-LTE transfer, in which the level populations are
coupled to the full non-local radiation Ô¨Åeld. Methods such as lambda iteration and accelerated lambda iteration will
be implemented. For nomenclature we will call these ‚Äònon-local non-LTE modes‚Äô.
For these non-local non-LTE modes the level population calculation is done separately from the image/spectrum ray-
tracing: You will run RADMC-3D Ô¨Årst for computing the non-LTE populations. RADMC-3D will then write these
to Ô¨Åle. Then you will call RADMC-3D for making images/spectra. This is very similar to the dust transfer, in which
you Ô¨Årst call RADMC-3D for the Monte Carlo dust temperature computation, and after that for the ray-tracing. It
is, however, different from the local non-LTE modes, where the populations are calculated automatically before any
image/spectrum ray-tracing, and the populations do not have to be written to Ô¨Åle (only if you want to inspect them:
Section Non-LTE Transfer: Inspecting the level populations).
For now, however, RADMC-3D still does not have the non-local non-LTE modes.
7.9 Non-LTE Transfer: Inspecting the level populations
When doing line radiative transfer it is often useful to inspect the level populations. For instance, you may want to
inspect how far from LTE your populations are, or just check if the results are reasonable. There are two ways to do
this:
1. When making an image or spectrum, add the command-line option writepop, which will make RADMC-3D
create output Ô¨Åles containing the level population values. Example:
radmc3d image lambda 2300 writepop
2. Just calling radmc3d with the command-line option calcpop, which will ask RADMC-3D to compute the
populations and write them to Ô¨Åle, even without making any images or spectra. Example:
7.7. Non-LTE Transfer: The optically thin line assumption method
73

radmc3d, Release 2.0
radmc3d calcpop
NOTE: For (future) non-local non-LTE modes (Section Non-LTE Transfer: Full non-local modes (FUTURE)) these
level populations will anyway be written to a Ô¨Åle, irrespective of the writepop command.
The resulting Ô¨Åles will have names such as levelpop_co.dat (for the CO molecule). The structure is as follows:
iformat
<=== Typically 1 at present
nrcells
nrlevels_subset
level1
level2 .....
<=== The level subset selection
popul[level1,1]
popul[level2,1] .....
<=== Populations (for subset) at cell 1
popul[level1,2]
popul[level2,2] .....
<=== Populations (for subset) at cell 2
.
.
popul[level1,nrcells]
popul[level2,nrcells] ....
The Ô¨Årst number is the format number, which is simply for RADMC-3D to be backward compatible in the future, in
case we decide to change/improve the Ô¨Åle format. The nrcells is the number of cells.
Then follows the number of levels (written as nrlevels_subset above). Note that this is not necessarily equal
to the number of levels found in the molecule_co.inp Ô¨Åle (for our CO example). It will only be equal to that if
the Ô¨Åle has been produced by the command radmc3d calcpop. If, however, the Ô¨Åle was produced after making
an image or spectrum (e.g. through the command radmc3d image lambda 2300 writepop), then RADMC-
3D will only write out those levels that have been used to make the image or spectrum. See Section Background
information: Calculation and storage of level populations for more information about this. It is for this reason that the
Ô¨Åle in fact contains a list of levels that are included (the level1 level 2 ... in the above Ô¨Åle format example).
After these header lines follows the actual data. Each line contains the populations at a spatial cell in units of cm‚àí3.
This Ô¨Åle format is a generalization of the standard format which is described for the example of dust density in Section
INPUT (required for dust transfer): dust_density.inp. Please read that section for more details, and also on how the
format changes if you use ‚Äòlayers‚Äô.
Also the unformatted style is described in Section INPUT (required for dust transfer): dust_density.inp. We have,
however, here the extra complication that at each cell we have more than one number. Essentially this simply means
that the length of the data per cell is larger, so that fewer cells Ô¨Åt into a single record.
7.10 Non-LTE Transfer: Reading the level populations from Ô¨Åle
Sometimes you may want to make images and/or spectra of lines based on level populations that you calculated
using another program (or calculated using RADMC-3D at some earlier time). You can ask RADMC-3D to read
these populations from Ô¨Åles with the same name and same format as, for example, levelpop_co.dat (for CO) as
described in Section Non-LTE Transfer: Inspecting the level populations. The way to do this is to add a line:
lines_mode = 50
to the radmc3d.inp Ô¨Åle.
You can test that it works by calculating the populations using another lines_mode and calling radmc3d
calcpop writepop (which will produce the levelpop_xxx.dat Ô¨Åle); then change lines_mode to 50, and
call radmc3d image iline 1. You should see a message that RAMDC-3D is actually reading the populations
(and it may, for 3-D models, take a bit of time to read the large Ô¨Åle).
Because of the rather lage size of these Ô¨Åles for 3-D models, it might be worthwhile to make sure to reduce the number
of levels of the molecule_xx.inp Ô¨Åles to only those you actually need.
74
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
7.11 What can go wrong with line transfer?
Even the simple task of performing a ray-tracing line transfer calculation with given level populations (i.e. the so-
called formal transfer equation) is a non-trivial task in complex 3-D AMR models with possibly highly supersonic
motions. I recommend the user to do extensive and critical experimentation with the code and make many simple tests
to check if the results are as they are expected to be. In the end a result must be understandable in terms of simple
argumentation. If weird effects show up, please do some detective work until you understand why they show up, i.e.
that they are either a real effect or a numerical issue. There are many numerical artifacts that can show up that are not a
bug in the code. The code simply does a numerical integration of the equations on some spatial- and wavelength-grid.
If the user chooses these grids unwisely, the results may be completely wrong even if the code is formally OK. These
possible pitfalls is what this section is about.
So here is a list of things to check:
1. Make sure that the line(s) you want to model are indeed in the molecular data Ô¨Åle you use. Also make sure that
it/they are included in the line selection (if you are using this option; by default all lines and levels from the
molecular/atomic data Ô¨Åles are included; see Section Background information: Calculation and storage of level
populations).
2. If you do LTE line transfer, and you do not let radmc3d read in a special Ô¨Åle for the partition function, then the
partition function will be computed internally by radmc3d. The code will do so based on the levels speciÔ¨Åed
in the molecule_XXX.inp Ô¨Åle for molecule XXX. This requires of course that all levels that may be excited
at the temperatures found in the model are in fact present in the molecule_XXX.inp Ô¨Åle. If, for instance,
you model 1.3 mm and 2.6 mm rotational lines of CO gas of up to 300 K, and your Ô¨Åle molecule_co.inp
only contains the Ô¨Årst three levels because you think you only need those for your 1.3 and 2.6 mm lines, and
you don‚Äôt specify the partition function explicitly, then radmc3d will compute the partition function for all
temperatures including 300 K based on only the Ô¨Årst three levels. This is evidently wrong. The nasty thing is:
the resulting lines won‚Äôt be totally absurd. They will just be too bright. But this can easily go undetected by
you as the user. So please keep this always in mind. Note that if you make a selection of the Ô¨Årst three levels
(see Section For experts: Selecting a subset of lines and levels ‚Äòmanually‚Äô) but the Ô¨Åle molecule_XXX.inp
contains many more levels, then this problem will not appear, because the partition function will be calculated
on the original data from the molecule_XXX.inp Ô¨Åle, not from the selected levels. Of course it is safer
to specify the true partition function directly through the Ô¨Åle partitionfunction_XXX.inp (see Section
INPUT for LTE line transfer: The partition function (optional)).
3. If you have a model with non-zero gas velocities, and if these gas velocities have cell-to-cell differences that are
larger than or equal to the intrinsic (thermal+microturbulent) line width, then the ray-tracing will not be able to
pick up signals from intermediate velocities. In other words, because of the discrete gridding of the model, only
discrete velocities are present, which can cause numerical problems. See Fig. Fig. 7.2-Left for a pictographic
representation of this problem. There are two possible solutions. One is the wavelength band method described
in Section Heads-up: In reality wavelength are actually wavelength bands. But a more systematic method is
the ‚Äòdoppler catching‚Äô method described in Section Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô
(which can be combined with the wavelength band method of Section Heads-up: In reality wavelength are
actually wavelength bands to make it even more perfect).
7.11. What can go wrong with line transfer?
75

radmc3d, Release 2.0
7.12 Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô
If the local co-moving line width of a line (due to thermal/fundamental broadning and/or local subgrid ‚Äòmicroturbu-
lence‚Äô) is much smaller than the typical velocity Ô¨Åelds in the model, then a dangerous situation can occur. This can
happen if the co-moving line width is narrower than the doppler shift between two adjacent cells. When a ray is traced,
in one cell the line can then have a doppler shift substantially to the blue of the wavelength-of-sight, while in the next
cell the line suddenly shifted to the red side. If the intrinsic (= thermal + microturbulent) line width is smaller than
these shifts, neither cell gives a contribution to the emission in the ray. See Fig. Fig. 7.1 for a pictographic represen-
tation of this problem. In reality the doppler shift between these two cells would be smooth, and thus the line would
smoothly pass over the wavelength-of-sight, and thus make a contribution. Therefore the numerical integration may
thus go wrong.
cell i
cell i‚àí1
cell i+1
cell i+2
velocity/c
‚âÖ(ŒΩ‚àíŒΩ0)/ŒΩ0
position
along
ray
Fig. 7.1: Pictographic representation of the doppler jumping problem with ray-tracing through a model with strong
cell-to-cell velocity differences.
cell i
velocity/c
‚âÖ(ŒΩ‚àíŒΩ0)/ŒΩ0
position
along
ray
cell i‚àí1
cell i+1
cell i+2
Fig. 7.2: Right: Pictographic representation of the doppler catching method to prevent this problem: First of all,
second order integration is done instead of Ô¨Årst order. Secondly, the method automatically detects a possibly dangerous
doppler jump and makes sub-steps to neatly integrate over the line that shifts in- and out of the wavelength channel of
interest.
The problem is described in more detail in Section Heads-up: In reality wavelength are actually wavelength bands,
76
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
and one possible solution is proposed there. But that solution does not always solve the problem.
RADMC-3D has a special method to catch situations like the above, and when it detects one, to make sub-steps in
the integration of the formal transfer equation so that the smooth passing of the line through the wavelength-of-sight
can be properly accounted for. Here this is called ‚Äòdoppler catching‚Äô, for lack of a better name. The technique was
discussed in great detail in Pontoppidan et al. (2009, ApJ 704, 1482). The idea is that the method automatically tests
if a line might ‚Äòdoppler jump‚Äô over the current wavelength channel. If so, it will insert substeps in the integration at
the location where this danger is present. See Fig. Fig. 7.2 for a pictographic representation of this method. Note
that this method can only be used with the second order ray-tracing (see Section Second order ray-tracing (Important
information!)); in fact, as soon as you switch the doppler catching on, RADMC-3D will automatically also switch on
the second order ray-tracing.
To switch on doppler catching, you simply add the command-line option doppcatch to the image or spectrum
command. For instance:
radmc3d spectrum iline 1 widthkms 10 doppcatch
(again: you do not need to add secondorder, because it is automatic when doppcatch is used).
The Doppler catching method will assure that the line is integrated over with small enough steps that it cannot ac-
cidently get jumped over. How Ô¨Åne these steps will be can be adjusted with the catch_doppler_resolution
keyword in the radmc3d.inp Ô¨Åle. The default value is 0.2, meaning that it will make the integration steps small
enough that the doppler shift over each step is not more than 0.2 times the local intrinsic (thermal+microturbulent) line
width. That is usually enough, but for some problems it might be important to ensure that smaller steps are taken. By
adding a line:
catch_doppler_resolution = 0.05
to the radmc3d.inp Ô¨Åle you will ensure that steps are small enough that the doppler shift is at most 0.05 times the
local line width.
So why is doppler catching an option, i.e. why would this not be standard? The reason is that doppler catching requires
second order integration, which requires RADMC-3D to Ô¨Årst map all the cell-based quantities to the cell-corners. This
requires extra memory, which for very large models can be problematic. It also requires more CPU time to calculate
images/spectra with second order integration. So if you do not need it, i.e. if your velocity gradients are not very steep
compared to the intrinsic line width, then it saves time and memory to not use doppler catching.
It is, however, important to realize that doppler catching is not the golden bullet. Even with doppler catching it might
happen that some line Ô¨Çux is lost, but this time as a result of too low image resolution. This is less likely to happen
in problems like ISM turbulence, but it is pretty likely to happen in models of rotating disks. Suppose we have a
very thin local line width (i.e. low gas temperature and no microturbulence) in a rotating thin disk around a star. In
a given velocity channel (i.e. at a given observer-frame frequency) a molecular line in the disk emits only in a very
thin ‚Äòear-shaped‚Äô ring or band in the image. The thinner the intrinsic line width, the thinner the band on the image.
See Pontoppidan et al. (2009, ApJ 704, 1482) and Pavlyuchenkov et al. (2007, ApJ 669, 1262) for example. If the
pixel-resolution of the image is smaller than that of this band, the image is simply underresolved. This has nothing
to do with the doppler jumping problem, but can be equally devastating for the results if the user is unaware of this.
There appears to be only one proper solution: assure that the pixel-resolution of the image is sufÔ¨Åciently Ô¨Åne for the
problem at hand. This is easy to Ô¨Ånd out: The image would simply look terribly noisy if the resolution is insufÔ¨Åcient.
However, if you are not interested in the images, but only in the spectra, then some amount of noisiness in the image
(i.e. marginally sufÔ¨Åcient resolution) is OK, since the total Ô¨Çux is an integral over the entire image, smearing out much
of the noise. It requires some experimentation, though.
Here are some additional issues to keep in mind:
‚Ä¢ The doppler catching method uses second order integration (see Section Second order ray-tracing (Important
information!)), and therefore all the relevant quantities Ô¨Årst have to be interpolated from the cell centers to the
cell corners. Well inside the computational domain this amounts to linear interpolation. But at the edges of the
domain it would require extra polation. In 1-D this is more easily illustrated, because there the cell corners are in
7.12. Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô
77

radmc3d, Release 2.0
fact cell interfaces. Cells ùëñand ùëñ+1 share cell interface ùëñ+1/2. If we have ùëÅcells, i.e. cells ùëñ= 1, ¬∑ ¬∑ ¬∑ , ùëÅ, then
we have ùëÅ+ 1 interfaces, i.e. interfaces ùëñ= 1
2, ¬∑ ¬∑ ¬∑ , ùëÅ+ 1
2. To get physical quantities from the cell centers to
cell interfaces ùëñ= 3
2, ¬∑ ¬∑ ¬∑ , ùëÅ‚àí1
2 requires just interpolation. But to Ô¨Ånd the physical quantities at cell interfaces
ùëñ= 1
2 and ùëñ= ùëÅ+ 1
2 one has to extrapolate or simply take the values at the cell centers ùëñ= 1 and ùëñ= ùëÅ.
RADMC-3D does not do extrapolation but simply takes the average values of the nearest cells. Also the gas
velocity is treated like this. This means that over the edge cells the gradient in the gas velocity tends to be (near)
0. Since for the doppler catching it is the gradient of the velocity that matters, this might yield some artifacts in
the spectrum if the density in the border cells is high enough to produce substantial line emission. Avoiding this
numerical artifact is relatively easy: One should then simply put the number density of the molecule in question
to zero in the boundary cells.
‚Ä¢ If you are using RADMC-3D on a 3-D (M)HD model which has strong shocks in its domain, then one must
be careful that (magneto-)hydrodynamic codes tend to smear out the shock a bit. This means that there will be
some cells that have intermediate density and velocity in the smeared out region of the shock. This is unphysical,
but an intrinsic numerical artifact of numerical hydrodynamics codes. This might, under some conditions, lead
to unphysical signal in the spectrum, because there would be cells at densities, temperatures and velocities that
would be in between the values at both sides of the shock and would, in reality, not be there. It is very difÔ¨Åcult to
avoid this problem, and even to Ô¨Ånd out if this problem is occurring and by how much. One must simply be very
careful of models containing strong shocks and do lots of testing. One way to test is to use the doppler catching
method and vary the doppler catching resolution (using the catch_doppler_resolution keyword in
radmc3d.inp).
‚Ä¢ If using line transfer in spherical coordinates using doppler catching, the linear interpolation of the line shift
between the beginning and the end of a segment may not always be enough to accurately prevent doppler jumps.
This is because in addition to the physical gradient of gas velocity, the projected gas velocity along a ray changes
also along the ray due to the geometry (the use of spherical coordinates). Example: a spherically symmetric
radially outÔ¨Çowing wind with constant outward velocity ùë£ùëü= is constant, the 3-D vector ‚Éóùë£is not constant, since
it always points outward. A ray through this wind will thus have a varying ‚Éóùëõ¬∑ ‚Éóùë£along the ray. In the cell where
the ray reaches its closest approach to the origin of the coordinate system the ‚Éóùëõ¬∑ ‚Éóùë£will vary the strongest. This
may be such a strong effect that it could affect the reliability of the code. As of version 0.41 of this code a
method is in place to prevent this. It is switched on by default, but it can be switched off manually for testing
purposes. See Section Second order integration in spherical coordinates: a subtle issue for details.
7.13 Background information: Calculation and storage of level popu-
lations
If RADMC-3D makes an image or a spectrum with molecular (or atomic) lines included, then the level populations
of the molecules/atoms have to be computed. In the standard method of ray-tracing of images or spectra, these level
populations are Ô¨Årst calculated in each grid cell and stored in a global array. Then the raytracer will render the image
or spectrum.
The storage of the level populations is a tricky matter, because if this is done in the obvious manner, it might require
a huge amount of memory. This would then prevent us from making large scale models. For instance: if you have a
molecule with 100 levels in a model with 256x256x256 ‚âÉ1.7 √ó 107 cells, the global storage for the populations alone
(with each number in double precision) would be roughly 100x8x256x256x256 ‚âÉ13 Gigabyte.
However, if you intend to make a spectrum in just 1 line, you do not need all these level populations. To stick to the
above example, let us take the CO 1-0 line, which is then line 1 and which connects levels ùêΩ= 1 and ùêΩ= 0, which
are levels 2 and 1 in the code (if you use the Leiden database CO data Ô¨Åle). Once the populations have been computed,
we only need to store the levels 1 and 2. This would then require 2x8x256x256x256 ‚âÉ0.26 Gigabyte, which would
be much less memory-costly.
As of version 0.29 RADMC-3D automatically Ô¨Ågures out which levels have to be stored in a global array, in order to
be able to render the images or the spectrum properly. RADMC-3D will go through all the lines of all molecules and
78
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
checks if they contribute to the wavelength(s), of the image(s) or the spectrum. Once it has assembled a list of ‚Äòactive‚Äô
lines, it will make a list of ‚Äòactive‚Äô levels that belong to these lines. It will then declare this to be the ‚Äòsubset‚Äô of levels
for which the populations will be stored globally.
In other words: RADMC-3D now takes care of the memory-saving storage of the populations automatically.
How does RADMC-3D decide whether a line contributes to some wavelength ùúÜ? A line ùëñwith line center ùúÜùëñis
considered to contribute to an image at wavelength ùúÜif
|ùúÜùëñ‚àíùúÜ| ‚â§ùê∂margin‚àÜùúÜùëñ
where ‚àÜùúÜùëñis the line width (including all contributions) and ùê∂margin is a constant. By default
ùê∂margin = 12
But you can change this to another value, say 24, by adding in the radmc3d.inp Ô¨Åle a line containing, e.g.
lines_widthmargin = 24.
You can in fact get a dump of the level populations that have been computed and used for the image(s)/spectrum you
created, by adding writepop on the command line. Example:
radmc3d spectrum iline 1 widthkms 10 writepop
This then creates (in addition to the spectrum) a Ô¨Åle called (for our example of the CO molecule) levelpop_co.
dat. Here is how you can read this data in Python:
from radmc3d_tools import simpleread
data = simpleread.read_levelpop()
The data object then contains data.pop and data.relpop, which are the level populations in 1/ùëêùëö3 and in
normalized form.
If, for some reason, you want always all levels to be stored (and you can afford to do so with the size of your computer‚Äôs
memory), you can make RADMC-3D do so by adding noautosubset as a keyword to the command line, or by
adding lines_autosubset = 0 to the radmc3d.inp Ô¨Åle. However, for other than code testing purposes, it
seems unlikely you will wish to do this.
7.14 In case it is necessary: On-the-Ô¨Çy calculation of populations
There might be rare circumstances in which you do not want to have to store the level populations in a global array. For
example: you are making a spectrum of the CO bandhead, in which case you have many tens of lines in a single spec-
trum. If your model contains 256x256x256 cells (see example in Section Background information: Calculation and
storage of level populations) then this might easily require many Gigabytes of memory just to store the populations.
For the LTE, LVG and optically thin level population modes there is a way out: You can force RADMC-3D to compute
the populations on-the-Ô¨Çy during the ray-tracing, which does not require a global storage of the level populations.
The way to do this is simple:
Just make the lines_mode negative.
So for on-the-Ô¨Çy LTE mode use
lines_mode=-1, for on-the-Ô¨Çy user-deÔ¨Åned populations mode use lines_mode=-2, for on-the-Ô¨Çy LVG mode
use lines_mode=-3 and for on-the-Ô¨Çy optically thin populations use lines_mode=-4.
NOTE: The drawback of this method is that, under certain circumstances, it can slow down the code dramatically.
This slow-down happens if you use e.g. second-order integration (Section Second order ray-tracing (Important infor-
mation!)) and/or doppler catching (Section Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô) together with
non-trivial population solving methods like LVG. So please use the on-the-Ô¨Çy method only when you are forced to do
so (for memory reasons).
7.14. In case it is necessary: On-the-Ô¨Çy calculation of populations
79

radmc3d, Release 2.0
7.15 For experts: Selecting a subset of lines and levels ‚Äòmanually‚Äô
As explained in Section Background information: Calculation and storage of level populations, RADMC-3D auto-
matically makes a selection of levels for which it will allocate memory for the global level population storage.
If, for some reason, you wish to make this selection yourself ‚Äòby hand‚Äô, this can also be done. However, please be
informed that there are very few circumstances under which you may want to do this. The automatic subset selection
of RADMC-3D is usually sufÔ¨Åcient!
If you decided to really want to do this, here is how:
1. Switch off the automatic subset selection by adding noautosubset as a keyword to the command line, or by
adding lines_autosubset = 0 to the radmc3d.inp Ô¨Åle.
2. In the lines.inp Ô¨Åle, for each molecule, modify the ‚Äò0 0‚Äô (the Ô¨Årst two zeroes after ‚Äòleiden‚Äô) in the way
described below.
In Section INPUT: The line.inp Ô¨Åle you can see that each molecule has a line like:
co
leiden
0
0
0
or so (here for the example of CO). In Section INPUT: The line.inp Ô¨Åle we explained the meaning of the third number,
but we did not explain the meaning of the Ô¨Årst and second ones. These are meant for this subset selection. If we want
to store only the Ô¨Årst 10 levels of the CO molecule, then replace the above line with:
co
leiden
0
10
0
If you want to select speciÔ¨Åc levels (let us choose the ilevel=3 and ilevel=4 levels of the above example), then
write:
co
leiden
1
2
0
3 4
The ‚Äò1‚Äô says that a list of levels follows, the ‚Äò2‚Äô says that two levels will be selected and the next line with ‚Äò3‚Äô and ‚Äò4‚Äô
say that levels 3 and 4 should be selected.
80
Chapter 7. Line radiative transfer

CHAPTER
EIGHT
MAKING IMAGES AND SPECTRA
Much has already been said about images and spectra in the chapters on dust radiative transfer and line radiative
transfer. But here we will combine all this and go deeper into this material. So presumably you do not need to read
this chapter if you are a beginning user. But for more sophisticated users (or as a reference manual) this chapter may
be useful and presents many new features and more in-depth insight.
8.1 Basics of image making with RADMC-3D
Images and spectra are typically made after the dust temperature has been determined using the thermal Monte Carlo
run (see Chapter Dust continuum radiative transfer). An image can now be made with a simple call to radmc3d:
radmc3d image lambda 10
This makes an image of the model at wavelength ùúÜ= 10ùúá.
We refer to Section OUTPUT: image.out or im-
age_****.out for details of this Ô¨Åle and how to interpret the content. See Chapter Python analysis tool set for an
extensive Python tools that make it easy to read and handle these Ô¨Åles. The vantage point is at inÔ¨Ånity at a default
inclination of 0, i.e. pole-on view. You can change the vantage point:
radmc3d image lambda 10 incl 80 phi 30
which now makes the image at inclination 80 degrees away from the z-axis (i.e. almost edge-on with respect to the x-y
plane), and rotates the location of the observer by 30 degrees clockwise around the z-axis (Here clockwise is deÔ¨Åned
with the z-axis pointing toward you, i.e. with respect to the observer the model is rotated counter-clockwise around
the z-axis by 30 degrees).
You can also rotate the camera in the image plane with
radmc3d image lambda 10 incl 45 phi 30 posang 20
which rotates the camera by 20 degrees clockwise (i.e. the image rotates counter-clockwise). Figures Fig. 8.1 and Fig.
8.2 show the deÔ¨Ånitions of all three angles. Up to now the camera always pointed to one single point in space: the
point (0,0,0). You can change this:
radmc3d image lambda 10 incl 45 phi 30 posang 20 pointau 3.2 0.1 0.4
which now points the camera at the point (3.2,0.1,0.4), where the numbers are in units of AU. The same can be done
in units of parsec:
radmc3d image lambda 10 incl 45 phi 30 posang 20 pointpc 3.2 0.1 0.4
Note that pointau and pointpc are always 3-D positions speciÔ¨Åed in cartesian coordinates. This remains also
true when the model-grid is in spherical coordinates and/or when the model is 2-D (axisymmetric) or 1-D (spherically
symmetric): 3-D positions are always speciÔ¨Åed in x,y,z.
81

radmc3d, Release 2.0
y
z
œÜobs
iobs
x
ximage
yimage
Fig. 8.1: Figure depicting how the angles ‚Äòincl‚Äô and ‚Äòphi‚Äô place the camera for images and spectra made with RADMC-
3D. The code uses a right-handed coordinate system. The Ô¨Ågure shows from which direction the observer is looking
at the system, where ùëñobs is the ‚Äòincl‚Äô keyword and ùúëobs is the ‚Äòphi‚Äô keyword. The ùë•image and ùë¶image are the horizontal
(left-to-right) and vertical (bottom-to-top) coordinates of the image. For ùëñobs = 0 and ùúëobs = 0 the ùë•image aligns with
the 3-D ùë•-coordinate and ùë¶image aligns with the 3-D ùë¶-coordinate.
posang = 20
image
yimage
x
x
yimage
image
posang = 0
Fig. 8.2: This Ô¨Ågure shows the way the camera can be rotated in the image plane using ‚Äòposang‚Äô. Positive ‚Äòposang‚Äô
means that the camera is rotated clockwise, so the object shown is rotated counter-clockwise with respect to the image
coordinates.
82
Chapter 8. Making images and spectra

radmc3d, Release 2.0
Let‚Äôs now drop the pointing again, and also forget about the posang, and try to change the number of pixels used:
radmc3d image lambda 10 incl 45 phi 30 npix 100
This will make an image of 100x100. You can also specify the x- and y- direction number of pixels separately:
radmc3d image lambda 10 incl 45 phi 30 npixx 100 npixy 30
Now let‚Äôs forget again about the number of pixels and change the size of the image, i.e. which zooming factor we
have:
radmc3d image lambda 10 incl 45 phi 30 sizeau 30
This makes an image which has 30 AU width and 30 AU height (i.e. 15 AU from the center in both directions). Same
can be done in units of parsec
radmc3d image lambda 10 incl 45 phi 30 sizepc 30
Although strictly speaking redundant is the possibility to zoom-in right into a selected box in this image:
radmc3d image lambda 10 incl 45 phi 30 zoomau -10 -4. 0 6
which means that we zoom in to the box given by ‚àí10 ‚â§ùë•‚â§‚àí4 AU and 0 ‚â§ùë¶‚â§6 AU on the original image (note
that zoomau -15 15 -15 15 gives the identical result as sizeau 30). This possibility is strictly speaking
redundant, because you could also change the pointau and sizeau to achieve the same effect (unless you want to
make a non-square image, in which case this is the only way). But it is just more convenient to do any zooming-in
this way. Please note that when you make non-square images with zoomau or zoompc, the code will automatically
try to keep the pixels square in shape by adapting the number of pixels in x- or y- direction in the image and adjusting
one of the sizes a tiny bit to assure that both x- and y- size are an integer times the pixel size. These are very small
adjustments (and only take place for non-square zoom-ins). If you want to force the code to take exactly the zoom
area, and you don‚Äôt care that the pixels then become slightly non-square, you can force it with truezoom:
radmc3d image lambda 10 incl 45 phi 30 sizeau 30 zoomau -10 -4. 0 3.1415 truezoom
If you do not want the code to adjust the number of pixels in x- and y- direction in its attempt to keep the pixels square:
radmc3d image lambda 10 incl 45 phi 30 sizeau 30 zoomau -10 -4. 0 3.1415 npixx 100
Àì‚Üínpixy 4 truepix
Now here are some special things. Sometimes you would like to see an image of just the dust, not including stars
(for stars in the image: see Section Stars in the images and spectra). So blend out the stars in the image, you use the
nostar option:
radmc3d image lambda 10 incl 45 phi 30 nostar
Another special option is to get a ‚Äòquick image‚Äô, in which the code does not attempt assure Ô¨Çux conservation in the
image (see Section The issue of Ô¨Çux conservation: recursive sub-pixeling for the issue of Ô¨Çux conservation). Doing
the image with Ô¨Çux conservation is slower than if you make it without Ô¨Çux conservation. Making an image without
Ô¨Çux conservation can be useful if you want to have a ‚Äòquick look‚Äô, but is strongly discouraged for actual scientiÔ¨Åc use.
But for a quick look you can do:
radmc3d image lambda 10 incl 45 phi 30 nofluxcons
If you want to produce images with a smoother look (and which also are more accurate), you can ask RADMC-3D to
use second order integration for the images:
8.1. Basics of image making with RADMC-3D
83

radmc3d, Release 2.0
radmc3d image lambda 10 incl 45 phi 30 secondorder
NOTE: The resulting intensities may be slightly different from the case when Ô¨Årst order integration (default) is used, in
particular if the grid is somewhat course and the objects of interest are optically thick. Please consult Section Second
order ray-tracing (Important information!) for more information.
Important for polarized radiative transfer: If you use polarized scattering, then you may want to creat images with
polarization information in them. You have to tell RADMC-3D to do this by adding stokes to the command line:
radmc3d image lambda 10 incl 45 phi 30 stokes
The deÔ¨Ånitions of the Stokes parameters (orientation etc) can be found in Section DeÔ¨Ånitions and conventions for
Stokes vectors and the format of image.out in this case can be found in Section OUTPUT: image.out or im-
age_****.out.
Note: All the above commands call radmc3d separately. If it needs to load a large model (i.e. a model with many
cells), then the loading may take a long time. If you want to make many images in a row, this may take too much
time. Then it is better to call radmc3d as a child process and pass the above commands through the biway pipe (see
Chapter chap-child-mode).
8.2 Making multi-wavelength images
Sometimes you want to have an image of an object at multiple wavelength simultaneously. Rather than calling
RADMC-3D separately to make an image for each wavelength, you can make all images in one command. The
only thing you have to do is to tell RADMC-3D which wavelengths it should take. There are various different ways
you can tell RADMC-3D what wavelengths to take. This is described in detail in Section Specifying custom-made
sets of wavelength points for the camera. Here we will focus as an example on just one of these methods. Type, for
instance,
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
This will create 10 images at once, all with the same viewing perspective, but at 10 wavelengths regularly distributed
between 5 ùúámu`m. All images are written into a single Ô¨Åle, image.out (See Section OUTPUT: image.out or
image_****.out for its format).
In Python you simply type:
from radmc3dPy import image
a=image.readImage()
and you will get all images at once. To plot one of them:
image.plotImage(image=a,ifreq=3)
which will plot image number 3 (out of images number 0 to 9). To Ô¨Ånd out which wavelength this image is at:
print(a.wav[3])
which will return 7.9370053 in this example.
Note that all of the commands in Section Basics of image making with RADMC-3D are of course also applicable to
multi-wavelength images, except for the lambda keyword, as this conÔ¨Çicts with the other method(s) of specifying
the wavlengths of the images. Now please turn to Section Specifying custom-made sets of wavelength points for the
camera for more information on how to specify the wavelengths for the multiple wavelength images.
84
Chapter 8. Making images and spectra

radmc3d, Release 2.0
8.3 Making spectra
The standard way of making a spectrum with radmc3d is in fact identical to making 100x100 pixel images with
Ô¨Çux conservation (i.e. recursive sub-pixeling, see Section The issue of Ô¨Çux conservation: recursive sub-pixeling) at
multiple frequencies. You can ask radmc3d to make a spectral energy distribution (SED) with the command
radmc3d sed incl 45 phi 30
This will put the observer at inclination 45 degrees and angle phi 30 degrees, and make a spectrum with wavelength
points equal to those listed in the wavelength_micron.inp Ô¨Åle.
The output will be a Ô¨Åle called spectrum.out (see Section OUTPUT: spectrum.out).
You can also make a spectrum on a set of wavelength points of your own choice. There are multiple ways by which
you can specify the set of frequencies/wavelength points for which to make the spectrum: they are described in Section
Specifying custom-made sets of wavelength points for the camera. If you have made your selection in such a way, you
can make the spectrum at this wavelength grid by
radmc3d spectrum incl 45 phi 30 <COMMANDS FOR WAVELENGTH SELECTION>
where the last stuff is telling radmc3d how to select the wavelengths (Section Specifying custom-made sets of wave-
length points for the camera). An example:
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20. nlam 100
will make a spectrum with a regular wavelength grid between 5 and 20 ùúám and 100 wavelength points. But see Section
Specifying custom-made sets of wavelength points for the camera for more details and options.
The output Ô¨Åle spectrum.out will have the same format as for the sed command.
Making a spectrum can take RADMC-3D some time, especially in the default mode, because it will do its best to shoot
its rays to pick up all cells of the model (see Section The solution: recursive sub-pixeling). In particularly in spherical
coordinates RADMC-3D can be perhaps too conservative (and thus slow). For spherical coordinates there are ways
to tell RADMC-3D to be somewhat less careful (and thereby faster): see Section Recursive sub-pixeling in spherical
coordinates.
Note that you can adjust the Ô¨Åne-ness of the images from which the spectrum is calculated using npix:
radmc3d sed incl 45 phi 30 npix 2
What this does is use a 2x2 pixel image instead of a 100x100 pixel image as the starting resolution. Of course, if it
would really be just a 2x2 pixel image, the Ô¨Çux would be entirely unreliable and useless. However, using the above
mentioned ‚Äòsub-pixeling‚Äô (see Section The solution: recursive sub-pixeling) it will automatically try to recursively
reÔ¨Åne these pixels until the required level of reÔ¨Ånement is reached. So under normal circumstances even npix=2 is
enough, and in earlier versions of RADMC-3D this 2x2 top-level image resolution was in fact used as a starting point.
But for safety reasons this has now been changed to the standard 100x100 resolution which is also the default for
normal images. If 100x100 is not enough, try e.g.:
radmc3d sed incl 45 phi 30 npix 400
which may require some patience.
8.3. Making spectra
85

radmc3d, Release 2.0
8.3.1 What is ‚Äòin the beam‚Äô when the spectrum is made?
As mentioned above, a spectrum is simply made by making a rectangular image at all the wavelengths points, and
integrating over these images. The resulting Ô¨Çuxes at each wavelength point is then the spectral Ô¨Çux at that wavelength
point. This means that the integration area of Ô¨Çux for the spectrum is (a) rectangular and (b) of the same size at all
wavelengths.
So, what is the size of the image that is integrated over? The answer is: it is the same size as the default size of an
image. In fact, if you make a spectrum with
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20. nlam 10
then this is the same as if you would type
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
and read in the Ô¨Åle image.out in into Python (see Section Making multi-wavelength images) or your favorite other
data language, and integrate the images to obtain Ô¨Çuxes. In other words: the command spectrum is effectively the
same as the command image but then instead of writing out an image.out Ô¨Åle, it will integrate over all images and
write a spectrum.out Ô¨Åle.
If you want to have a quick look at the area over which the spectrum is to be computed, but you don‚Äôt want to compute
all the images, just type e.g.:
radmc3d image lambda 10 incl 45 phi 30
then you see an image of your source at ùúÜ= 10ùúám, and the integration area is precisely this area - at all wavelengths.
Like with the images, you can specify your viewing area, and thus your integration area. For instance, by typing
radmc3d image lambda 10 incl 45 phi 30 zoomau -2 -1 -0.5 0.5
makes an image of your source at ùúÜ= 10ùúám at inclination 45 degrees, and orientation 30 degrees, and zooms in at an
are from -2 AU to -1 AU in x-direction (in the image) and from -0.5 AU to 0.5 AU in y-direction (in the image). To
make an SED within the same integration area:
radmc3d sed incl 45 phi 30 zoomau -2 -1 -0.5 0.5
In this case we have an SED with a ‚Äòbeam size‚Äô of 1 AU diameter, but keep in mind that the ‚Äòbeam‚Äô is square, not
circular.
8.3.2 Can one specify more realistic ‚Äòbeams‚Äô?
Clearly, a wavelength-independent beam size is unrealistic, and also the square beam is unrealistic. So is there a way
to do this better? In reality one should really know exactly how the object is observed and how the Ô¨Çux is measured.
If you use an interferometer, for instance, maybe your Ô¨Çux is meant to be the Ô¨Çux in a single synthesized beam. For
a spectrum obtained with a slit, the precise Ô¨Çux is dependent on the slit width: the wider the slit, the more signal you
pick up, but it is a signal from a larger area.
So if you really want to be sure that you know exactly what you are doing, then the best method is to do this youself
by hand. You make multi-wavelength images:
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
and integrate over the images in the way you think best mimics the actual observing procedure. You can do so,
for instance, in Python. See Section Making multi-wavelength images for more information about multi-wavelength
images.
86
Chapter 8. Making images and spectra

radmc3d, Release 2.0
But to get some reasonable estimate of the effect of the wavelength-dependent size and circular geometry of a ‚Äòbeam‚Äô,
RADMC-3D allows you to make spectra with a simplistic circular mask, the radius of which can be speciÔ¨Åed as a
function of wavelength in the Ô¨Åle aperture_info.inp (see Section INPUT: aperture_info.inp). This Ô¨Åle should
contain a table of mask radii at various wavelengths, and when making a spectrum with the command-line keyword
useapert the mask radii will be found from this table by interpolation. In other words: the wavelength points of the
aperture_info.inp Ô¨Åle do not have to be the same as those used for the spectrum. But their range must be larger
or equal than the range of the wavelengths used for the spectrum, because otherwise interpolation does not work. In
the most extreme simplistic case the aperture_info.inp Ô¨Åle contains merely two values: one for a very short
wavelength (shorter than used in the spectrum) and one for a very long wavelength (longer than used in the spectrum).
The interpolation is then done double-logarithmically, so that a powerlaw is used between sampling points. So if you
use a telescope with a given diameter for the entire range of the spectrum, two sampling points would indeed sufÔ¨Åce.
You can now make the spectrum with the aperture in the following way:
radmc3d sed useapert dpc 100
The keyword dpc 100 is the distance of the observer in units of parsec, here assumed to be 100. This distance is
necessary because the aperture information is given in arcseconds, and the distance is used to convert this is image
size.
Important note: Although you specify the distance of the observer here, the spectrum.out Ô¨Åle that is produced is
still normalized to a distance of 1 parsec.
Note also that in the above example you can add any other keywords as shown in the examples before, as long as you
add the useapert keyword and specify dpc.
A Ô¨Ånal note: the default behavior of RADMC-3D is to use the square Ô¨Åeld approach described before. You can
explicitly turn off the use of apertures (which may be useful in the child mode of RADMC-3D) with the keyword
noapert, but normally this is not necessary as it is the default.
8.4 Specifying custom-made sets of wavelength points for the cam-
era
If you want to make a spectrum at a special grid of wavelengths/frequencies, with the spectrum command (see
Section Making spectra), you must tell radmc3d which wavelengths you want to use. Here is described how to do
this in various ways.
8.4.1 Using lambdarange and (optionally) nlam
The simplest way to choose a set of wavelength for a spectrum is with the lambdarange and (optionally) nlam
command line options. Here is how to do this:
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20.
This will make a spectrum between 5 and 20 ùúámu`m. You can change the number of wavelength points as well:
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20. nlam 1000
This will do the same, but creates a spectrum of 1000 wavelength points.
You can use the lambdarange and nlam options also for multi-wavelength images:
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
8.4. Specifying custom-made sets of wavelength points for the camera
87

radmc3d, Release 2.0
but it is wise to choose nlam small, because otherwise the output Ô¨Åle, containing all the images, would become too
large.
8.4.2 Using allwl
You can also tell RADMC-3D to simply make an image at all of the wavelengths in the wavelength_micron.inp
Ô¨Åle:
radmc3d image incl 45 phi 30 allwl
The keyword allwl stands for ‚Äòall wavelengths‚Äô.
8.4.3 Using loadcolor
By giving the command loadcolor on the command line, radmc3d will search for the Ô¨Åle color_inus.inp.
This Ô¨Åle contains integers selecting the wavelengths from the Ô¨Åle wavelength_micron.inp. The Ô¨Åle is described
in Section The color_inus.inp Ô¨Åle (required with comm-line option ‚Äòloadcolor‚Äô).
8.4.4 Using loadlambda
By
giving
the
command
loadlambda
on
the
command
line,
radmc3d
will
search
for
the
Ô¨Åle
camera_wavelength_micron.inp. This Ô¨Åle contains a list of wavelengths in micron which constitute the
grid in wavelength. This Ô¨Åle is described in Section INPUT (optional): camera_wavelength_micron.inp.
8.4.5 Using iline, imolspec etc (for when lines are included)
By adding for instance iline 3 to the command line you specify a window around line number 3 (by default of
molecule 1). By also specifying for instance imolspec 2 you select line 3 of molecule 2. By adding widthkms
3 you specify how wide the window around the line should be (3 km/s in this example). With vkms 2 you set
the window offset from line center by 2 km/s in this example. By adding linenlam 30 you set the number of
wavelength points for this spectrum to be 30 in this example. So a complete (though different) example is:
radmc3d spectrum incl 45 phi 30 iline 2 imolspec 1 widthkms 6.0 vkms 0.0 linenlam 40
8.5 Heads-up: In reality wavelength are actually wavelength bands
In a radiative transfer program like RADMC-3D the images or spectral Ô¨Çuxes are calculated at exact wavelengths. This
would correspond to making observations with inÔ¨Ånitely narrow Ô¨Ålters, i.e. Ô¨Ålters with ‚àÜùúÜ= 0. This is not how
real observations work. In reality each wavelength channel has a Ô¨Ånite width ‚àÜùúÜand the measured Ô¨Çux (or image
intensity) is an average over this range. To be even more precise, each wavelength channel ùëñhas some proÔ¨Åle Œ¶ùëñ(ùúÜ)
deÔ¨Åned such that
‚à´Ô∏Å‚àû
0
Œ¶ùëñ(ùúÜ)ùëëùúÜ= 1
For wide Ô¨Ålters such as the standard photometric systems (e.g. UVBRI in the optical and JHK in the near infrared) these
proÔ¨Åles span ranges with a width of the order of ùúÜitself. Many instruments have their own set of Ô¨Ålters. Usually one
can download these proÔ¨Åles as digital tables. It can, under some circumstances, be important to include a treatment of
88
Chapter 8. Making images and spectra

radmc3d, Release 2.0
these proÔ¨Åles in the model predictions. As an example take the N band. This is a band that includes the 10 ùúálambda_i`
for 1 ‚â§ùëñ‚â§ùëõ, where ùëõis the number of wavelength samples, and then compute the Ô¨Ålter-averaged Ô¨Çux with:
ùêπùëèùëéùëõùëë=
‚à´Ô∏Å‚àû
0
Œ¶ùëñ(ùúÜ)ùêπ(ùúÜ)ùëëùúÜ=
ùëõ
‚àëÔ∏Å
ùëñ=1
Œ¶ùëñùêπùëñùõøùúÜ
where ùõøùúÜis the wavelength sampling spacing used. The same is true for image intensities. RADMC-3D will not do
this automatically. You have to tell it the ùúÜùëñsampling points, let it make the images or Ô¨Çuxes, and you will then have
to perform this sum yourself. Note that this will not always be necessary! In many (most?) cases the dust continuum
is not expected to change so dramatically over the width of the Ô¨Ålter that such degree of accuracy is required. So you
are advised to think carefully: ‚Äòdo I need to take care of this or can I make do with a single wavelength sample for
each Ô¨Ålter?‚Äô. If the former, then do the hard work. If the latter: then you can save time.
8.5.1 Using channel-integrated intensities to improve line channel map quality
When you make line channel maps you may face a problem that is somehow related to the above issue of single-
ùúÜ-sampling versus Ô¨Ålter-integrated Ô¨Çuxes/intensities. If the model contains gas motion, then doppler shift will shift
the line proÔ¨Åle around. In your channel map you may see regions devoid of emission because the lines have doppler
shifted out of the channel you are looking at. However, as described in Section What can go wrong with line transfer?,
if the intrinsic line width of the gas is smaller than the cell-to-cell velocity differences, then the channel images may
look very distorted (they will look ‚Äòblocky‚Äô, as if there is a bug in the code). Please refer to Section What can go wrong
with line transfer? for more details and updates on this important, but difÔ¨Åcult issue. It is not a bug, but a general
problem with ray-tracing of gas lines in models with large velocity gradients.
As one of the ùõΩ-testers of RADMC-3D, Rahul Shetty, has found out, this problem can often be alleviated a lot if you
treat the Ô¨Ånite width of a channel. By taking multiple ùúÜùëñpoints in each wavelength channel (i.e. multiple ùë£ùëñpoints in
each velocity channel) and simply averaging the intensities (i.e. assuming a perfectly square Œ¶ function) and taking
the width of the channels to be not smaller (preferably substantially wider) than the cell-to-cell velocity differences,
this ‚Äòblocky noise‚Äô sometimes smoothes out well. However, it is always safer to use the ‚Äòdoppler catching‚Äô mode (see
Section Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô) to automatically prevent such problems (though
this mode requires more computer memory).
8.6 The issue of Ô¨Çux conservation: recursive sub-pixeling
8.6.1 The problem of Ô¨Çux conservation in images
If an image of nx√óny pixels is made simply by ray-tracing one single ray for each pixel, then there is the grave
danger that certain regions with high reÔ¨Ånement (for instance with AMR in cartesian coordinates, or near the center
of the coordinate system for spherical coordinates) are not properly ‚Äòpicked up‚Äô. An example: suppose we start with
a circumstellar disk ranging from 0.1 AU out to 1000 AU. Most of the near infrared Ô¨Çux comes from the very inner
regions near 0.1 AU. If an image of the disk is made with 100x100 pixels and image half-size of 1000 AU, then none
of the pixels in fact pass through these very bright inner regions, for lack of spatial resolution. The problem is then that
the image, when integrated over the entire image, does not have the correct Ô¨Çux. What should be is that the centermost
pixels contain the Ô¨Çux from this innermost region, even if these pixels are much larger than the entire bright region. In
other words, the intensity of these pixels must represent the average intensity, averaged over the entire pixel. Strictly
speaking one should trace an inÔ¨Ånite continuous 2-D series of rays covering the entire pixel and then average over all
these rays; but this is of course not possible. In practice we should Ô¨Ånd a way to estimate the average intensity with
only a Ô¨Ånite number of rays.
8.6. The issue of Ô¨Çux conservation: recursive sub-pixeling
89

radmc3d, Release 2.0
8.6.2 The solution: recursive sub-pixeling
In RADMC-3D what we do is to use some kind of ‚Äòadaptive grid reÔ¨Ånement‚Äô of the pixels of the image. For each pixel
in the image the intensity is computed through a call to a subroutine called camera_compute_one_pixel(). In
this subroutine a ray-tracing is performed for a ray that ends right in the middle of our pixel. During the ray-tracing,
however, we check if we pass regions in the model grid that have grid cells with sizes ùëÜthat are smaller than the
pixel size divided by some factor ùëìref (where pixel size is, like the model grid size S itself, measured in centimeters.
If this is found not to be true, then the pixel size was apparently ok, and the intensity resulting from the ray-tracing
is now returned as the Ô¨Ånal intensity of this pixel. If, however, this condition is found to be true, then the result of
this ray is rejected, and instead 2x2 sub-pixels are computed by calling the camera_compute_one_pixel()
subroutine recursively. We thus receive the intensity of each of these four sub-pixels, and we return the average of
these 4 intensities.
Note, by the way, that each of these 2x2 subpixels may be split even further into 2x2 sub-pixels etc until the desired
resolution is reached, i.e. until the condition that ùëÜis larger or equal to the pixel size divided by ùëìref is met. This
is illustrated in Fig. Fig. 8.3. By this recursive calling, we always end up at the top level with the average intesity
of the entire top-level pixel. This method is very similar to quad-tree mesh reÔ¨Ånement, but instead of retaining and
returning the entire complex mesh structure to the user, this method only returns the Ô¨Ånal average intensity of each (by
deÔ¨Ånition top level) pixel in the image. So the recursive sub-pixeling technique described here is all done internally
in the RADMC-3D code, and the user will not really notice anything except that this sub-pixeling can of course be
computationally more expensive than if such a method is not used.
Fig. 8.3: Pictographic representation of how the recursive sub-pixeling for images works. Pixels are recursively split in
2x2 subpixels as far as needed to resolve the 3-D grid structure of the model. But at the end, the Ô¨Çuxes of all subpixels
are summed up such that the resulting image has a regular grid again.
Note that the smaller we choose ùëìref the more accurate our image becomes. In the radmc3d.inp Ô¨Åle the value
of ùëìref can be set by setting the variable camera_refine_criterion to the value you want ùëìref to be. Not
setting this variable means RADMC-3D will use the default value which is reasonable as a choice (default is 1.0). The
smaller you set camera_refine_criterion, the more accurate and reliable the results become (but the heavier
the calculation becomes, too).
NOTE: The issue of recursive sub-pixeling becomes tricky when stars are treated as spheres, i.e. non-point-like (see
Section Stars in the images and spectra and Chapter More information about the treatment of stars).
90
Chapter 8. Making images and spectra

radmc3d, Release 2.0
8.6.3 A danger with recursive sub-pixeling
It is useful to keep in mind that for each pixel the recursive sub-pixeling is triggered if the ray belonging to that pixel
encounters a cell that is smaller than the pixel size. This normally works well if ùëìref is chosen small enough. But
if there exist regions in the model where one big non-reÔ¨Åned cell lies adjacent to a cell that is reÔ¨Åned, say, 4 times
(meaning the big cell has neighbors that are 16 times smaller!), then if the ray of the pixel just happens to miss the small
cells and only passes the big cell, it won‚Äôt ‚Äònotice‚Äô that it may need to reÔ¨Åne to correctly capture the tiny neighboring
cells accurarely.
Such a problem only happens if reÔ¨Ånement levels jump by more than 1 between adjacent cells. If so, then it may be
important to make ùëìref correspondingly smaller (by setting camera_refine_criterion in radmc3d.inp to
the desired value). A bit of experimentation may be needed here.
8.6.4 Recursive sub-pixeling in spherical coordinates
In spherical coordinates the recursive sub-pixeling has a few issues that you may want to be aware of. First of all,
in 1-D spherical coordinates each cell is in fact a shell of a certain thickness. In 2-D spherical coordinates cells are
rings. In both cases the cells are not just local boxes, but have 2 or 1 (respectively) extended dimensions. RADMC-
3D takes care to still calculate properly how to deÔ¨Åne the recursive sub-pixeling scale. But for rays that go through
the central cavity of the coordinate system there is no uniquely deÔ¨Åned pixel resolution to take. The global variable
camera_spher_cavity_relres (with default value 0.05) deÔ¨Ånes such a relative scale. You can change this
value in the radmc3d.inp Ô¨Åle.
A second issue is when the user introduces extreme ‚Äòseparable reÔ¨Ånement‚Äô (see Section Separable grid reÔ¨Ånement
in spherical coordinates (important!) and Figure Fig. 9.3) in the ùëÖ, Œò or Œ¶ coordinate. This may, for instance, be
necessary near the inner edge of a dusty disk model in order to keep the Ô¨Årst cell optically thin. This may lead,
however, to extremely deep sub-pixeling for rays that skim the inner edge of the grid. This leads to a huge slow-down
of the ray-tracing process although it is likely not to give much a different result. By default RADMC-3D plays it safe.
If you wish to prevent this excessive sub-pixeling (at your own risk) then you can set the following variables in the
radmc3d.inp Ô¨Åle:
‚Ä¢ camera_min_drr which sets a lower limit to the ‚àÜùëÖ/ùëÖtaken into account for the sub-pixeling (region ‚ÄòB‚Äô
in Figure Fig. 9.2). The default is 0.003. By setting this to e.g. 0.03 you can already get a strong speed-up for
models with strong ùëÖ-reÔ¨Ånement.
‚Ä¢ camera_min_dangle which sets a lower limit to ‚àÜŒò (region ‚ÄòC‚Äô in Figure Fig. 9.2) and/or ‚àÜŒ¶. The default
is 0.05. By setting this to e.g. 0.1 you can already get some speed-up for models with e.g. strong Œò-reÔ¨Ånement.
It is important to keep in mind that the smaller you make this number, the more accurate and reliable the results. It
may be prudent to experiment with smaller values of camera_min_drr for models with extremely optically thick
inner edges, e.g. a protoplanetary disk with an abrupt inner edge and a high dust surface density. For a disk model
with a very thin vertical extent it will be important to choose small values of camera_min_dangle, perhaps even
smaller than the default value.
For your convenience: Because it can be sometimes annoying to always have to play with the camera_min_drr,
camera_min_dangle and camera_spher_cavity_relres values, and since it is usually (!) not really
necessary to have such extremely careful subpixeling, RADMC-3D now has a new command line option called
sloppy.
This command-line option will set:
camera_min_drr=0.1, camera_min_dangle=0.1 and
camera_spher_cavity_relres=0.1. So if you have an image like this:
radmc3d image lambda 10 incl 45 phi 30 sloppy
then it will make the image with moderate, but not excessive subpixeling. This may, under some circumstances, speed
up the image-making in spherical coordinates by a large factor. Similar for making spectra. For instance:
8.6. The issue of Ô¨Çux conservation: recursive sub-pixeling
91

radmc3d, Release 2.0
radmc3d sed incl 45 phi 30 sloppy
can be, under some circumstances, very much faster than without the sloppy option.
Note,however,
that
using
the
sloppy
option
and/or
setting
the
values
of
camera_min_drr,
camera_min_dangle and camera_spher_cavity_relres in the radmc3d.inp Ô¨Åle by hand, {bf
is all at your own risk!} It is always prudent to check your results, now and then, against a non-sloppy calculation.
8.6.5 How can I Ô¨Ånd out which pixels RADMC-3D is recursively reÔ¨Åning?
Sometimes you notice that the rendering of an image or spectrum takes much more time than you expected. When
recursive sub-pixeling is used for imaging, RADMC-3D will give diagnostic information about how many more pixels
it has rendered than the original image resolution. This factor can give some insight if extreme amount of sub-pixeling
reÔ¨Ånement has been used. But it does not say where in the image this occurs. If you want to see exactly which pixels
and subpixels RADMC-3D has rendered for some image, you can use the following command-line option:
radmc3d image lambda 10 diag_subpix
This diag_subpix option will tell RADMC-3D to write a Ô¨Åle called subpixeling_diagnostics.out which
contains four columns: One for the x-coordinate of the (sub-)pixel, one for the y-coordinate of the (sub-)pixel, one
for the x-width of the (sub-)pixel and a Ô¨Ånal one for the y-width of the (sub-)pixel. In Python you can then use, for
instance, the Numpy loadtxt method to read these columns.
If this diagnostic shows that the subpixeling is excessive (which can particularly happen in spherical coordinates) then
you might want to read Section Recursive sub-pixeling in spherical coordinates.
8.6.6 Alternative to recursive sub-pixeling
As an alternative to using this recursive sub-pixeling technique to ensure Ô¨Çux conservation for images, one can simply
enhance the spatial resolution of the image, for instance
radmc3d image lambda 10 npix 400
Or even 800 or so. This has the clear advantage that the user gets the complete information of the details in the image
(while in the recursive sub-pixeling technique only the averages are retained). The clear disadvantages are that one
may need rediculously high-resolution images (i.e. large data sets) to resolve all the details and one may waste a lot of
time rendering parts of the image which do not need that resolution. The latter is typically an issue when images are
rendered from models that use AMR techniques.
8.7 Stars in the images and spectra
Per default, stars are still treated as point sources. That means that none of the rays of an image can be intercepted
by a star. Starlight is included in each image as a post-processing step. First the image is rendered without the stars
(though with of course all the emission of dust, lines etc induced by the stars) and then for each star a ray tracing is
done from the star to the observer (where only extinction is taken into account, because the emission is already taken
care of) and the Ô¨Çux is then added to the image at the correct position. You can switch off the inclusion of the stars in
the images or spectra with the nostar command line option.
However, as of version 0.17, stars can also be treated as the Ô¨Ånite-size spheres they are. This is done with setting
istar_sphere = 1 in radmc3d.inp. However, this mode can slow down the code a bit or even substantially.
And it may still be partly under development, so the code may stop if it is required to handle a situation it cannot
handle yet. See Chapter More information about the treatment of stars for details.
92
Chapter 8. Making images and spectra

radmc3d, Release 2.0
8.8 Second order ray-tracing (Important information!)
Ideally we would like to assure that the model grid is sufÔ¨Åciently Ô¨Ånely spaced everywhere. But in many cases of
interest one does not have this luxury. One must live with the fact that, for memory and/or computing time reasons,
the grid is perhaps a bit coarser than would be ideal. In such a case it becomes important to consider the ‚Äòorder‚Äô of
integration of the transfer equation. By default, for images and spectra, RADMC-3D uses Ô¨Årst order integration: The
source term and the opacity in each cell are assumed to be constant over the cell. This is illustrated in Fig. Fig. 8.4.
A
B
D
C
A
B
C
D
position
along ray 
jŒΩ
Fig. 8.4: Pictographic representation of the Ô¨Årst order integration of the transfer equation along a ray (red line with
arrow head) through an AMR grid (black lines). The grid cuts the ray into ray segments A, B, C and D. At the bottom
it is shown how the integrands are assumed to be along these four segments. The emissivity function ùëóùúàand extinction
function ùõºùúàare constant within each cell and thus constant along each ray segment.
The integration over each cell proceeds according to the following formula:
ùêºresult = ùêºstartùëí‚àíùúè+ (1 ‚àíùëí‚àíùúè)ùëÜ
where ùëÜ= ùëó/ùõºis the source function, assumed constant throughout the cell, ùúè= ùõº‚àÜùë†is the optical depth along the
path that the ray makes through the cell, and ùêºstart is the intensity upon entering the cell. This is the default used by
RADMC-3D because the Monte Carlo methods also treat cells as having constant properties over each cell. This type
of simple integration is therefore the closest to how the Monte Carlo methods (thermal MC, scattering MC and mono
MC) ‚Äòsee‚Äô the grid. However, with Ô¨Årst order integration the images look somewhat ‚Äòblocky‚Äô: you can literally see
the block structure of the grid cells in the image, especially if you make images at angles aligned with the grid. For
objects with high optical depths you may even see grid patterns in the images.
RADMC-3D can also use second order integration for its images and spectra. This is illustrated in Fig. Fig. 8.5.
This is done with a simple secondorder option added on the command line, for instance:
radmc3d image lambda 10 secondorder
The integration now follows the formula (Olson et al. 1986):
ùêºresult = ùêºstartùëí‚àíùúè+ (1 ‚àíùëí‚àíùúè‚àíùõΩ)ùëÜstart + ùõΩùëÜend
8.8. Second order ray-tracing (Important information!)
93

radmc3d, Release 2.0
A
B
D
C
A
B
C
D
position
along ray 
jŒΩ
Fig. 8.5: Pictographic representation of the second order integration of the transfer equation along a ray (red line
with arrow head) through an AMR grid (black lines). The grid cuts the ray into ray segments A, B, C and D. At the
bottom it is shown how the integrands are assumed to be along these four segments. The emissivity function ùëóùúàand
extinction function ùõºùúàare given at the cell corners (solid blue circles), and linearly interpolated from the cell corners
to the locations where the ray crosses the cell walls (open blue circles). Then, along each ray segment the emissivity
and extinction functions are assumed to be linear functions, so that the integration result is quadratic.
94
Chapter 8. Making images and spectra

radmc3d, Release 2.0
with
ùõΩ= ùúè‚àí1 + ùëí‚àíùúè
ùúè
and
ùúè= ùõºstart + ùõºend
2
‚àÜùë†
For ùúè‚Üí0 we have the limit ùõΩ‚Üíùúè/2, while for ùúè‚Üí‚àûwe have the limit ùõΩ‚Üí1.
The values of ùõº, ùëÜetc., at the ‚Äòstart‚Äô position are obtained at the cell interface where the ray enters the cell. The values
at the ‚Äòend‚Äô position are obtained at the cell interface where the ray leaves the cell. The above formulas represent
the exact solution of the transfer equation along this ray-section if we assume that all variables are linear functions
between the ‚Äòstart‚Äô and ‚Äòend‚Äô positions.
The next question is: How do we determine the physical variables at the cell interfaces (‚Äòstart‚Äô and ‚Äòend‚Äô)? After all,
initially all variables are stored for each cell, not for each cell interface or cell corner. The way that RADMC-3D does
this is:
‚Ä¢ First create a ‚Äògrid of cell corners‚Äô, which we call the vertex grid (see the solid blue dots in Fig. Fig. 8.5). The
cell grid already implicitly deÔ¨Ånes the locations of all the cell corners, but these corners are, by default, not
explicitly listed in computer memory. When the secondorder option is given, however, RADMC-3D will
explicitly Ô¨Ånd all cell corners and assign an identity (a unique integer number) to each one of them. NOTE:
Setting up this vertex grid costs computer memory!
‚Ä¢ At each vertex (cell corner) the physical variables of the (up to) 8 cells touching the vertex are averaged with
equal weight for each cell. This now maps the physical variables from the cells to the vertices.
‚Ä¢ Whenever a ray passes through a cell wall, the physical variables of the 4 vertices of the cell wall are interpolated
bilinearly onto the point where the ray passes through the cell wall (see the open blue circles in Fig. Fig. 8.5).
This gives the values at the ‚Äòstart‚Äô or ‚Äòend‚Äô points.
‚Ä¢ Since the current ‚Äòend‚Äô point will be the ‚Äòstart‚Äô point for the next ray segment, the physical variables need only
be obtained once per cell wall, as they can be recycled for the next ray segment. Each set of physical variables
will thus be used twice: once for the ‚Äòend‚Äô and once for the ‚Äòstart‚Äô of a ray segment (except of course at the very
beginning and very end of the ray).
If you compare the images or spectra obtained with Ô¨Årst order integration (default, see Figs. Fig. 8.8 and Fig. 8.9) or
second order integration (see Figs. Fig. 8.8 and Fig. 8.9) you see that with the Ô¨Årst order method you still see the cell
structure of the grid very much. Also numerical noise in the temperature due to the Monte Carlo statistics is much
more prominent in the Ô¨Årst order method. The second order method makes much smoother results.
For line transfer the second order mode can be even improved with the ‚Äòdoppler catching method‚Äô, see Section Pre-
venting doppler jumps: The ‚Äòdoppler catching method‚Äô.
WARNING: Second order integration for the images and spectra from dust continuum emission can in some cases
lead to overestimation of the Ô¨Çuxes. This is because the dust temperature calculated using the thermal Monte Carlo
algorithm assumes the temperature to be constant over each cell. The second order integration for the images and
spectra will, however, smear the sources a bit out. This then leads to ‚Äòleaking‚Äô of emissivity from optically thick cells
into optically thin cells. These optically thin cells can then become too bright.
8.8. Second order ray-tracing (Important information!)
95

radmc3d, Release 2.0
Fig. 8.6: First-order integration of transfer equation in ray-tracing seen at inclination 4 degrees.
Fig. 8.7: First-order integration of transfer equation in ray-tracing seen at inclination 60 degrees.
96
Chapter 8. Making images and spectra

radmc3d, Release 2.0
Fig. 8.8: Second-order integration of transfer equation in ray-tracing seen at inclination 4 degrees.
Fig. 8.9: Second-order integration of transfer equation in ray-tracing seen at inclination 60 degrees.
8.8. Second order ray-tracing (Important information!)
97

radmc3d, Release 2.0
8.8.1 Second order integration in spherical coordinates: a subtle issue
The second order integration (as well as the doppler-catching method, see Section Preventing doppler jumps: The
‚Äòdoppler catching method‚Äô) work in cartesian coordinates as well as in spherical coordinates. In spherical coordinates
in 1-D (spherical symmetry) or 2-D (axial symmetry) there is, however, a very subtle issue that can lead to inaccuracies,
in particular with line transfer. The problem arises in the cell where a ray reaches its closest approach to the origin
of the coordinate system (or closest approach to the symmetry axis). There the ray segment can become fairly long,
and its angle with respect to the symmetry axis and/or the origin can drastically change within this single ray-segment.
This can sometimes lead to inaccuracies.
As of version 0.41 of RADMC-3D a new global variable is introduced, camera_maxdphi, which has as default the
value 0.1, but which can be set to another value in the radmc3d.inp Ô¨Åle. It sets the maximum angle (in radian)
which a ray segment in spherical coordinates is allowed to span with respect to the origin of the coordinate system. If
a ray segment spans an angle larger than that, the ray-segment is cut into smaller segments. This means that in that
cell the ray will consist of more than one segment.
If camera_maxdphi=0 this segment cutting is switched off (for backward compatibility to earlier versions of
RADMC-3d).
8.9 Circular images
RADMC-3D offers (optionally!) an alternative to the usual x-y rectangular pixel arrangement of images: circular
images. Here the pixels are not arranged in rows that are vertically stacked (ùë•, ùë¶), but in concentric circles (ùëü, ùúë). Such
a pixel arrangement is, of course, radically different from what we usually consider ‚Äúan image‚Äù, and it is therefore
not possible to view such an image with the usual image viewing methods (such as Python‚Äôs plt.imshow()). Or
more precisely: if you would use plt.imshow() on a circular image you would see something that you would not
recognize as the image it should represent.
So what is the purpose? It is useful for models created on a spherical coordinate system. Such models can have
structure at a huge range of scales, from very tiny (at the small-end side of the radius coordinate ùëü) to very large (at the
large-end side of the radius coordinate ùëü). If you make a normal image, you have to pick the right ‚Äúzoom factor‚Äù: are
you interested to see the outer regions or more interested in the inner regions? If you choose a ‚Äúzoomed out‚Äù image,
you will under-resolve the inner regions. If you choose a ‚Äúzoomed in‚Äù image, you will not see the outer regions (they
are beyond the edge of the image). One solution could be to choose a huge number of pixels, but that would create
huge image Ô¨Åles.
Circular images solve this dilemma. By arranging the pixels not in (ùë•, ùë¶) but instead of (ùëü, ùúë), the ùëücoordinate grid
of the image will automatically be adapted to the ùëücoordinate grid of the spherical coordinate system. If the latter is
logarithmically spaced, so will the circular image.
Here is how it works: Assuming you have a model in spherical coordinates, you can create a circular image as follows:
radmc3d image circ lambda 10
which creates a circular image at wavelength ùúÜ= 10ùúáùëö.
Using radmc3dPy you can read this image as follows:
from radmc3dPy import image
im = image.readcircimage()
The data is now in im.image. A radial plot of the intensity at a given angle ùúëcould be made as follows:
import matplotlib.pyplot as plt
plt.loglog(im.rc,im.image[:,0,0,0])
(continues on next page)
98
Chapter 8. Making images and spectra

radmc3d, Release 2.0
(continued from previous page)
plt.xlabel('r [cm]')
plt.ylabel(r'$I_\nu [erg\, cm^{-2}\, s^{-1}\, Hz^{-1}\, ster^{-1}]$')
The result will look like shown in Fig. Fig. 8.10 .
1013
1014
1015
r [cm]
10
19
10
17
10
15
10
13
10
11
10
9
I [erg cm
2 s
1 Hz
1 ster
1]
Fig. 8.10: Example of a circular image of a 1-D spherical model (the model in the examples/run_spher1d_1/
directory).
If you have 2-D or 3-D models in spherical coordinates, the circular images (should) have not only a grid in ùëü, but
also ùúëgrid points. A simple plot such as Fig. Fig. 8.10 will only show the intensity for a single ùëù‚Ñéùëñchoice. There
is no ‚Äúright‚Äù or ‚Äúwrong‚Äù way of displaying such an image. It depends on your taste. You could, of course, remap
onto a ‚Äúnormal‚Äù image, but that would defeat the purpose of circular images. You could also display the (ùëü, ùúë) image
directly with e.g. plt.imshow(), which simply puts the ùëüaxis horizontally on the screen, and the ùúëaxis vertically,
essentially creating a ‚Äòheat map‚Äô of the intensity as a function of ùëüand ùúë.
This is illustrated in the model examples/run_spher2d_1/. Fig. Fig. 8.11 shows the circular image (as a ‚Äòheat
map‚Äô) at a wavelength of ùúÜ= 10 ùúáùëö. For comparison, the same image is shown as a ‚Äònormal‚Äô image in Fig. Fig. 8.12.
With a bit of ‚Äúgetting used to‚Äù one will Ô¨Ånd that the circular images will reveal a lot of information.
Note: Fig.
:numÔ¨Åg:`Ô¨Åg-circ-image-2d` shows an effect similar to what is shown in Fig.
Fig. 15.1.
This in-
dicates that near the inner radius of the model, the radial grid is under-resolved in example model examples/
run_spher2d_1/: see Section Careful: Things that might go wrong, point ‚ÄòToo optically thick cells at the surface
or inner edge‚Äô. So, to improve the reliability of model examples/run_spher2d_1/, one would need to reÔ¨Åne
the radial grid near the inner edge and/or smooth the density there.
8.9. Circular images
99

radmc3d, Release 2.0
0
50
100
150
200
250
300
350
[deg]
0.0
0.5
1.0
1.5
10log(r) [AU]
= 10 m
16
15
14
13
12
11
10
10log(I ) [erg cm
2 s
1 Hz
1 ster
1 ]
Fig. 8.11: Example of a circular image of a 2-D spherical model (the model in the examples/run_spher2d_1/
directory).
100
Chapter 8. Making images and spectra

radmc3d, Release 2.0
100
50
0
50
100
X [AU]
100
75
50
25
0
25
50
75
100
Y [AU]
=10.00000 m
16
15
14
13
12
11
log(I  [erg/s/cm/cm/Hz/ster])
Fig. 8.12: The rectangular (‚Äònormal‚Äô) version of the image of Fig. Fig. 8.11. As one can see: the inner regions of this
image are not well-resolved.
8.9. Circular images
101

radmc3d, Release 2.0
8.10 Visualizing the ùúè= 1 surface
To be able to interpret the outcome of the radiative transfer calculations it is often useful to Ô¨Ånd the spatial location of
the ùúè= 1 surface (or, for that matter, the ùúè= 0.1 surface or any ùúè= ùúèùë†surface) as seen from the vantage point of the
observer. This makes it easier to understand where the emission comes from that you are seeing. RADMC-3D makes
this possible. Thanks to Peter Schilke and his team, for suggesting this useful option.
The idea is to simply replace the command-line keyword image with tausurf 1.0. The 1.0 stands for ùúèùë†= 1.0,
meaning we will Ô¨Ånd the ùúè= 1.0 surface. Example: Normally you might make an image with e.g. the following
command:
radmc3d image lambda 10 incl 45 phi 30
Now you make a ùúè= 1 surface with the command:
radmc3d tausurf 1.0 lambda 10 incl 45 phi 30
or a ùúè= 0.2 surface with
radmc3d tausurf 0.2 lambda 10 incl 45 phi 30
The image output Ô¨Åle image.out will now contain, for each pixel, the position along the ray in centimeters where
ùúè= ùúèùë†. The zero point is the surface perpendicular to the direction of observation, going through the pointing position
(which is, by default (0, 0, 0), but see the description of pointau in Section Basics of image making with RADMC-
3D). Positive values mean that the surface is closer to the observer than the plane, while negative values mean that the
surface is behind the plane.
If, for some pixel, there exists no ùúè= ùúèùë†point because the total optical depth of the object for the ray belonging to
that pixel is less than ùúèùë†, then the value will be -1e91.
You can also get the 3-D (i.e. ùë•, ùë¶, ùëß) positions of each of these points on the ùúè= ùúèùë†surface. They are stored in the
Ô¨Åle tausurface_3d.out.
Note that if you make multi-frequency images, you will also get multi-frequency ùúè= ùúèùë†surfaces. This can be
particularly useful if you want to understand the sometimes complex origins of the shapes of molecular/atomic lines.
You can also use this option in the local observer mode, though I am not sure how useful it is. Note, however, that in
that mode the value stored in the image.out Ô¨Åle will describe the distance in centimeter to the local observer. The
larger the value, the farther away from the observer (contrary to the case of observer-at-inÔ¨Ånity).
Example usage:
radmc3d tausurf 1 lambda 10 incl 45 phi 30
8.11 For public outreach work: local observers inside the model
While it may not be very useful for scientiÔ¨Åc purposes (though there may be exceptions), it is very nice for public
outreach to be able to view a model from the inside, as if you, as the observer, were standing right in the middle of the
model cloud or object. One can then use physical or semi-physical or even completely ad-hoc opacities to create the
right ‚Äòvisual effects‚Äô. RADMC-3D has a viewing mode for this purpose. You can use different projections:
‚Ä¢ Projection onto Ô¨Çat screen:
The simplest one is a projection onto a screen in front (or behind) the point-location of the ob-
server.
This gives an image that is good for viewing in a normal screen.
This is the default
(camera_localobs_projection=1).
102
Chapter 8. Making images and spectra

radmc3d, Release 2.0
‚Ä¢ Projection onto a sphere:
Another projection is a projection onto a sphere, which allow Ô¨Åelds of view that are equal or larger than
2ùúãof the sky.
It may be useful for projection onto an OMNIMAX dome.
This is projection mode
camera_localobs_projection=2.
You can set the variable camera_localobs_projection to 1 or 2 by adding on the command line
projection 2 (or 1), or by setting it in the radmc3d.inp as a line camera_localobs_projection =
2 (or 1).
To use the local projection mode you must specify the following variables on the command line:
‚Ä¢ sizeradian: This sets the size of the image in radian (i.e. the entire width of the image). Setting this will
make the image width and height the same (like setting sizeau in the observer-at-inÔ¨Ånity mode, see Section
Basics of image making with RADMC-3D).
‚Ä¢ zoomradian: Instead of sizeradian you can also specify zoomradian, which is the local-observer
version of zoomau or``zoompc`` (see Section Basics of image making with RADMC-3D).
‚Ä¢ posang: The position angle of the camera. Has the same meaning as in the observer-at-inÔ¨Ånity mode.
‚Ä¢ locobsau or locobspc: Specify the 3-D location of the local observer inside the model in units of AU or
parsec. This requires 3 numbers which are the x, y and z positions (also when using spherical coordinates for
the model setup: these are still the cartesian coordinates).
‚Ä¢ pointau or pointpc: These have the same meaning as in the observer-at-inÔ¨Ånity model. They specify the
3-D location of the point of focus for the camera (to which point in space is the camera pointing) in units of AU
or parsec. This requires 3 numbers which are the x, y and z positions (also when using spherical coordinates for
the model setup: these are still the cartesian coordinates).
‚Ä¢ zenith (optional): For Planetarium Dome projection (camera_localobs_projection=2) it is useful
to make the pointing direction not at the zenith (because then the audience will always have to look straight up)
but at, say, 45 degrees. You can facilitate this (optionally) by adding the command line option zenith 45 for
a 45 degrees offset. This means that if you are sitting under the OMNIMAX dome, then the camera pointing
(see pointau above) is 45 degrees in front of you rather than at the zenith. This option is highly recommended
for dome projections, but you may need to play with the angle to see which gives the best effect.
Setting sizeradian, zoomradian, locobsau or locobspc on the command line automatically switches to
the local observer mode (i.e. there is no need for an extra keyword setting the local observer mode on). To switch back
to observer-at-inÔ¨Ånity mode, you specify e.g. incl or phi (the direction toward which the observer is located in the
observer-at-inÔ¨Ånity mode). Note that if you accidently specify both e.g. sizeradian and incl, you might end up
with the wrong mode, because the mode is set by the last relevant entry on the command line.
The images that are produced using the local observer mode will have the x- and y- pixel size speciÔ¨Åcations in radian
instead of cm. The Ô¨Årst line of an image (the format number of the Ô¨Åle) contains then the value 2 (indicating local
observer image with pixel sizes in radian) instead of 1 (which indicates observer-at-inÔ¨Ånity image with pixel sizes in
cm).
NOTE: For technical reasons dust scattering is (at least for now) not included in the local observer mode! It is
discouraged to use the local observer mode for scientiÔ¨Åc purposes.
8.11. For public outreach work: local observers inside the model
103

radmc3d, Release 2.0
8.12 Multiple vantage points: the ‚ÄòMovie‚Äô mode
It can be useful, both scientiÔ¨Åcally and for public outreach, to make movies of your model, for instance by showing
your model from different vantage points or by ‚Äòtravelling‚Äô through the model using the local observer mode (Section
For public outreach work: local observers inside the model). For a movie one must make many frames, each frame
being an image created by RADMC-3D‚Äôs image capabilities. If you call radmc3d separately for each image, then
often the reading of all the large input Ô¨Åles takes up most of the time. One way to solve this is to call radmc3d in
‚Äòchild mode‚Äô (see Chapter chap-child-mode). But this is somewhat complicated and cumbersome. A better way is to
use RADMC-3D‚Äôs ‚Äòmovie mode‚Äô. This allows you to ask RADMC-3D to make a sequence of images in a single call.
The way to do this is to call radmc3d with the movie keyword:
radmc3d movie
This will make radmc3d to look for a Ô¨Åle called movie.inp which contains the information about each image it
should make. The structure of the movie.inp Ô¨Åle is:
iformat
nframes
<<information for frame 1>>
<<information for frame 2>>
<<information for frame 3>>
...
<<information for frame nframes>>
The iformat is an integer that is described below. The nframes is the number of frames. The <<information
for frame xx>> are lines containing the information of how the camera should be positioned for each frame of
the movie (i.e. for each imag). It is also described below.
There are multiple ways to tell RADMC-3D how to make this sequence of images. Which if these ways RADMC-3D
should use is speciÔ¨Åed by the iformat number. Currently there are 2, but later we may add further possibilities.
Here are the current possibilities
‚Ä¢ iformat=1: The observer is at inÔ¨Ånity (as usual) and the <<information for frame xx>> consists
of the following numbers (separated by spaces):
pntx pnty pntz hsx hsy pa incl phi
These 8 numbers have the following meaning:
‚Äì pntx,pnty,pntz: These are the x, y and z coordinates (in units of cm) of the point toward which the
camera is pointing.
‚Äì hsx,hsy: These are the image half-size in horizontal and vertical direction on the image (in units of cm).
‚Äì pa: This is the position angle of the camera in degrees. This has the same meaning as for a single image.
‚Äì incl,phi: These are the inclination and phi angle toward the observer in degrees. These have the same
meaning as for a single image.
‚Ä¢ iformat=-1: The observer is local (see Section For public outreach work: local observers inside the model)
and the <<information for frame xx>> consists of the following numbers (separated by spaces):
pntx pnty pntz hsx hsy pa obsx obsy obsz
These 9 numbers have the following meaning:
‚Äì pntx,pnty,pntz,hsx,hsy,pa: Same meaning as for iformat=1.
‚Äì obsx,obsy,obsz: These are the x, y and z position of the local observer (in units of cm).
104
Chapter 8. Making images and spectra

radmc3d, Release 2.0
Apart from the quantities that are thus set for each image separately, all other command-line options still remain valid.
Example, let us make a movie of 360 frames of a model seen at inÔ¨Ånity while rotating the object 360 degrees, and as
seen at a wavelength of ùúÜ= 10ùúáÔ¨Åle:
1
360
0. 0. 0. 1e15 1e15 0. 60.
1.
0. 0. 0. 1e15 1e15 0. 60.
2.
0. 0. 0. 1e15 1e15 0. 60.
3.
.
.
.
0. 0. 0. 1e15 1e15 0. 60.
358.
0. 0. 0. 1e15 1e15 0. 60.
359.
0. 0. 0. 1e15 1e15 0. 60.
360.
We now call RADMC-3D in the following way:
radmc3d movie lambda 10. npix 200
This will create image Ô¨Åles image_0001.out, image_0002.out, all the way to image_0360.out. The
images will have a full width and height of 2 √ó 1015phi`-angle.
Another example: let us move through the object (local observer mode), approaching the center very closely, but not
precisely:
-1
101
0. 0. 0. 0.8 0.8 0. 6.e13 -1.0000e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13 -0.9800e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13 -0.9600e15 0.
.
.
0. 0. 0. 0.8 0.8 0. 6.e13 -0.0200e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
0.0000e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
0.0200e15 0.
.
.
0. 0. 0. 0.8 0.8 0. 6.e13
0.9600e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
0.9800e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
1.0000e15 0.
Here the camera automatically rotates such that the focus remains on the center, as the camera Ô¨Çies by the center of
the object at a closest-approach to the center of 6 √ó 1013 cm. The half-width of the image is 0.8 radian.
Important note: If you have scattering switched on, then every rendering of an image makes a new scattering Monte
Carlo run. Since Monte Carlo produces noise, this would lead to a movie that is very jittery (every frame has a new
noise set). It is of course best to avoid this by using so many photon packages that this is not a concern. But in practice
this may be very CPU-time consuming. You can also Ô¨Åx the noise in the following way: add resetseed to the
command-line call:
radmc3d movie resetseed
and it will force each new scattering Monte Carlo computation to start with the same seed, so that the photons will
exactly move along the same trajectories. Now only the scattering phase function will change because of the different
vantage points, but not the Monte Carlo noise. You can in fact set the actual value of the initial seed in the radmc3d.
inp Ô¨Åle by adding a line
8.12. Multiple vantage points: the ‚ÄòMovie‚Äô mode
105

radmc3d, Release 2.0
iseed = -5415
(where -5415 is to be replaced by the value you want) to the radmc3d.inp Ô¨Åle. Note also that if your movie goes
through different wavelengths, the resetseed will likely not help Ô¨Åxing the noisiness, because the paths of photons will
change for different wavelengths, even with the same initial seed.
106
Chapter 8. Making images and spectra

CHAPTER
NINE
MORE INFORMATION ABOUT THE GRIDDING
We already discussed the various types of grids in Section The spatial grid, and the grid input Ô¨Åle structure is described
in Section INPUT (required): amr_grid.inp. In this chapter let us take a closer look at the gridding possibilities and
things to take special care of.
9.1 Regular grids
A regular grid is called ‚Äògrid style 0‚Äô in RADMC-3D. It can be used in Cartesian coordinates as well as in spherical
coordinates (Section Coordinate systems).
A regular grid, in our deÔ¨Ånition, is a multi-dimensional grid which is separable in ùë•, ùë¶and ùëß(or in spherical coordinates
in ùëü, ùúÉand ùúë). You specify a 1-D monotonically increasing array of values ùë•1, ùë•2, ¬∑ ¬∑ ¬∑ , ùë•nx+1 which represent the cell
walls in ùë•‚àíùëëùëñùëüùëíùëêùë°ùëñùëúùëõ. You do the same for the other directions: ùë¶1, ùë¶2, ¬∑ ¬∑ ¬∑ , ùë¶ny+1 and ùëß1, ùëß2, ¬∑ ¬∑ ¬∑ , ùëßnz+1. The value
of, say, ùë•2 is the same for every position in ùë¶and ùëß: this is what we mean with ‚Äòseparable‚Äô.
In Cartesian coordinates RADMC-3D enforces perfectly cubic grid cells (i.e. linear grids). But that is only to make the
image sub-pixeling easier (see Section The solution: recursive sub-pixeling). For spherical grids this is not enforced,
and in fact it is strongly encouraged to use non-linear grids in spherical coordinates. Please read Section Separable
grid reÔ¨Ånement in spherical coordinates (important!) if you use spherical coordinates!
In a regular grid you specify the grids in each direction separately. For instance, the x-grid is given by specifying
the cell walls in x-direction. If we have, say, 10 cells in x-direction, we must specify 11 cell wall positions. For
instance: ùë•ùëñ= {‚àí5, ‚àí4, ‚àí3, ‚àí2, ‚àí1, 0, 1, 2, 3, 4, 5}. For the ùë¶-direction and ùëß-direction likewise. Fig. Fig. 9.1 shows
an example of a 2-D regular grid of 4x3 cells.
yc[2]
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
Fig. 9.1: Example of a regular 2-D grid with nx=4 and ny=3.
107

radmc3d, Release 2.0
In Cartesian coordinates we typically deÔ¨Åne our model in full 3-D. However, if your problem has translational sym-
metries, you might also want to consider the 1-D plane-parallel mode (see Section 1-D Plane-parallel models).
In full 3-D Cartesian coordinates the cell sizes must be perfectly cubical, i.e. the spacing in each direction must be the
same. If you need a Ô¨Åner grid in some location, you can use the AMR capabilities discussed below.
In spherical coordinates you can choose between 1-D spherically symmetric models, 2-D axisymmetric models or
fully 3-D models. In spherical coordinates you do not have restrictions to the cell geometry or grid spacing. You can
choose any set of numbers ùëü1, ¬∑ ¬∑ ¬∑ , ùëünr as radial grid, as long as this set of numbers is larger than 0 and monotonically
increasing. The same is true for the ùúÉ-grid and the ùúë-grid.
The precise way how to set up a regular grid using the amr_grid.inp Ô¨Åle is described in Section Regular grid. The
input of any spatial variables (such as e.g. the dust density) uses the sequence of grid cells in the same order as the
cells are speciÔ¨Åed in that amr_grid.inp Ô¨Åle.
For input and output data to Ô¨Åle, for stuff on a regular grid, the order of nested loops over coordinates would be:
do iz=1,amr_grid_nz
do iy=1,amr_grid_ny
do ix=1,amr_grid_nx
<< read or write your data >>
enddo
enddo
enddo
For spherical coordinates we have the following association: ùë•‚Üíùëü, ùë¶‚ÜíùúÉ, ùëß‚Üíùúë.
9.2 Separable grid reÔ¨Ånement in spherical coordinates (important!)
Spherical coordinates are a very powerful way of dealing with centrally-concentrated problems. For instance, col-
lapsing protostellar cores, protoplanetary disks, disk galaxies, dust tori around active galactic nuclei, accretion disks
around compact objects, etc. In other words: problems in which a single central body dominates the problem, and
material at all distances from the central body matters. For example a disk around a young star goes all the way from
0.01 AU out to 1000 AU, covering 5 orders of magnitude in radius. Spherical coordinates are the easiest way of dealing
with such a huge radial dynamic range: you simply make a radial grid, where the grid spacing ùëüùëñ+1 ‚àíùëüùëñscales roughly
with ùëüùëñ.
This is called a logarithmic radial grid. This is a grid whith a spacing in which (ùëüùëñ+1 ‚àíùëüùëñ)/ùëüùëñis constant with ùëü.
In this way you assure that you have always the right spatial resolution in ùëüat each radius. In spherical coordinates
it is highly recomended to use such a log spacing. But you can also reÔ¨Åne the ùëügrid even more (in addition to the
log-spacing). This is also strongly recommended near the inner edge of a circumstellar shell, for instance. Or at the
inner dust rim of a disk. There you must reÔ¨Åne the ùëügrid (by simply making the spacing smaller as you approach the
inner edge from the outside) to assure that the Ô¨Årst few cells are optically thin and that there is a gradual transition
from optically thin to optically thick as you go outward. This is particularly important for, for instance, the inner rim
of a dusty disk.
In spherical coordinates you can vary the spacing in ùëü, ùúÉand ùúëcompletely freely. That means: you could have for
instance ùëüto be spaced as 1.00, 1.01, 1.03, 1.05, 1.1, 1.2, 1.35, ¬∑ ¬∑ ¬∑. There is no restriction, as long as the coordinate
points are monotonically increasing. In Figs Fig. 9.2 and Fig. 9.3 this is illustrated.
Note that in addition to separable reÔ¨Ånement, also AMR reÔ¨Ånement is possible in spherical coordinates. See Section
Oct-tree Adaptive Mesh ReÔ¨Ånement.
For models of accretion disks it can, for instance, be useful to make sure that there are more grid points of ùúÉnear
the equatorial plane ùúÉ= ùúã/2. So the grid spacing between ùúÉ= 0.0 and ùúÉ= 1.0 may be very coarse while between
ùúÉ= 1.0 and ùúÉ= ùúã/2 you may put a Ô¨Åner grid. All of this ‚Äògrid reÔ¨Ånement‚Äô can be done without the ‚ÄòAMR‚Äô reÔ¨Ånement
technique: this is the ‚Äòseparable‚Äô grid reÔ¨Ånement, because you can do this separately for ùëü, for ùúÉand for ùúë.
108
Chapter 9. More information about the gridding

radmc3d, Release 2.0
coordinates
A
B
C
Separable
grid refinement
in spherical
Fig. 9.2: Example of a spherical 2-D grid in which the radial and ùúÉgrids are reÔ¨Åned in a ‚Äòseparable‚Äô way. In radial
direction the inner cells are reÔ¨Åned (‚ÄòB‚Äô in the right Ô¨Ågure) and in ùúÉdirection the cells near the equatorial plane are
reÔ¨Åned (‚ÄòC‚Äô in the right Ô¨Ågure). This kind of grid reÔ¨Ånement does not require oct-tree AMR: the grid remains separable.
For models in which the inner grid edge is also the inner model edge (e.g. a simple model of a protoplanetary disk
with a sharp inner cut-off) this kind of separable grid reÔ¨Ånement in ùëÖ-direction may be essential to avoid problems
with optically thick inner cells (see e.g. Fig. Fig. 15.1 for an example of what could go wrong if you do not do this).
Separable grid reÔ¨Ånement in Œò-direction is typically important for protoplanetary disk models, where the midplane
and surface layers of the disk need to have sufÔ¨Åcient resolution, but any possible surrounding spherical nebula may
not.
9.2. Separable grid reÔ¨Ånement in spherical coordinates (important!)
109

radmc3d, Release 2.0
for images and spectra
High‚àíres sub‚àípixels
High‚àíres sub‚àípixels
High‚àíres sub‚àípixels
Arrangement of rays
Fig. 9.3: When making an image, RADMC-3D will automatically make ‚Äòsub-pixels‚Äô to ensure that all structure of the
model as projected on the sky of the observer are spatially resolved. Extreme grid reÔ¨Ånement leads thus to extreme
sub-pixeling. See Section Recursive sub-pixeling in spherical coordinates for details, and ways to prevent excessive
sub-pixeling when this is not necessary.
Sometimes, however, separable reÔ¨Ånement may not help you to reÔ¨Åne the grid where necessary. For instance: if you
model a disk with a planet in the disk, then you may need to reÔ¨Åne the grid around the planet. You could reÔ¨Åne the grid
in principle in a separable way, but you would then have a large redundancy in cells that are reÔ¨Åned by far away from
the planet. Or if you have a disk with an inner rim that is not exactly at ùëü= ùëürim, but is a rounded-off rim. In these
cases you need reÔ¨Ånement exactly located at the region of interest. For that you need the ‚ÄòAMR‚Äô reÔ¨Ånement (Sections
Oct-tree Adaptive Mesh ReÔ¨Ånement and Layered Adaptive Mesh ReÔ¨Ånement).
Important note: When using strong reÔ¨Ånement in one of the coordinates ùëü, ùúÉor ùúë, image-rendering and spectrum-
rendering can become very slow, because of the excessive sub-pixeling this causes. There are ways to limit the
sub-pixeling for those cases. See the Section on sub-pixeling in spherical coordinate: Section Recursive sub-pixeling
in spherical coordinates.
9.3 Oct-tree Adaptive Mesh ReÔ¨Ånement
An oct-tree reÔ¨Ånened grid is called ‚Äògrid style 1‚Äô in RADMC-3D. It can be used in Cartesian coordinates as well as in
spherical coordinates (Section Coordinate systems).
You start from a normal regular base grid (see Section Regular grids), possibly even with ‚Äòseparable reÔ¨Ånement‚Äô (see
Section Separable grid reÔ¨Ånement in spherical coordinates (important!)). You can then split some of the cells into
2x2x2 subcells (or more precisely: in 1-D 2 subcells, in 2-D 2x2 subcells and in 3-D 2x2x2 subcells). If necessary,
each of these 2x2x2 subcells can also be split into further subcells. This can be repeated as many times as you wish
until the desired grid reÔ¨Ånement level is reached. Each reÔ¨Ånement step reÔ¨Ånes the grid by a factor of 2 in linear
dimension, which means in 3-D a factor of 8 in volume. In this way you get, for each reÔ¨Åned cell of the base grid, a
tree of reÔ¨Ånement. The base grid can have any size, as long as the number of cells in each direction is an even number.
For instance, you can have a 6x4 base grid in 2-D, and reÔ¨Åne cell (1,2) by one level, so that this cell splits into 2x2
subcells.
110
Chapter 9. More information about the gridding

radmc3d, Release 2.0
Note that it is important to set which dimensions are ‚Äòactive‚Äô and which are ‚Äònon-active‚Äô. For instance, if you have
a 1-D model with 100 cells and you tell RADMC-3D (see Section Oct-tree-style AMR grid) to make a base grid of
100x1x1 cells, but you still keep all three dimensions ‚Äòactive‚Äô (see Section Oct-tree-style AMR grid), then a reÔ¨Ånement
of cell 1 (which is actually cell (1,1,1)) will split that cell into 2x2x2 subcells, i.e. it will also reÔ¨Åne in y and z direction.
Only if you explicitly switch the y and z dimensions off the AMR will split it into just 2 subcells.
Oct-tree mesh reÔ¨Ånement is very powerful, because it allows you to reÔ¨Åne the grid exactly there where you need it.
And because we start from a regular base grid like the grid speciÔ¨Åed in Section Regular grids, we can start designing
our model on a regular base grid, and then reÔ¨Åne where needed. See Fig. Fig. 9.4.
yc[2]
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
Fig. 9.4: Example of a 2-D grid with oct-tree reÔ¨Ånement. The base grid has nx=4 and ny=3. Three levels of
reÔ¨Ånement are added to this base grid.
The AMR stand for ‚ÄòAdaptive Mesh ReÔ¨Ånement‚Äô, which may suggest that RADMC-3D will reÔ¨Åne internally. At the
moment this is not yet the case. The ‚Äòadaptive‚Äô aspect is left to the user: he/she will have to ‚Äòadapt‚Äô the grid such that
it is sufÔ¨Åciently reÔ¨Ånened where it is needed. In the future we may allow on-the-Ô¨Çy adaption of the grid, but that is not
yet possible now.
One problem with oct-tree AMR is that it is difÔ¨Åcult to handle such grids in external plotting programs, or even in
programs that set up the grid. While it is highly Ô¨Çexible, it is not very user-friendly. Typically you may use this
oct-tree reÔ¨Ånement either because you import data from a hydrodynamics code that works with oct-tree reÔ¨Ånement
(e.g. FLASH, RAMSES), or when you internally reÔ¨Åne the grid using the userdef_module.f90 (see Chapter
Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes). In the former case you are anyway
forced to manage the complexities of AMR, while in the latter case you can make use of the AMR modules of
RADMC-3D internally to handle them. But if you do not need to full Ô¨Çexibility of oct-tree reÔ¨Ånement and want to
use a simpler kind of reÔ¨Ånement, then you can use RADMC-3D‚Äôs alternative reÔ¨Ånement mode: the layer-style AMR
described in Section Layered Adaptive Mesh ReÔ¨Ånement below.
The precise way how to set up such an oct-tree grid using the amr_grid.inp Ô¨Åle is described in Section Oct-tree-
style AMR grid. The input of any spatial variables (such as e.g. the dust density) uses the sequence of grid cells in the
same order as the cells are speciÔ¨Åed in that amr_grid.inp Ô¨Åle.
9.3. Oct-tree Adaptive Mesh ReÔ¨Ånement
111

radmc3d, Release 2.0
9.4 Layered Adaptive Mesh ReÔ¨Ånement
A layer-style reÔ¨Ånened grid is called ‚Äògrid style 10‚Äô in RADMC-3D. It can be used in Cartesian coordinates as well as
in spherical coordinates (Section Coordinate systems).
This is an alternative to the full-Ô¨Çedged oct-tree reÔ¨Ånement of Section Oct-tree Adaptive Mesh ReÔ¨Ånement. The main
advantage of the layer-style reÔ¨Ånement is that it is far easier to handle by the human brain, and thus easier for model
setup and the analysis of the results.
The idea here is that you start again with a regular grid (like that of Section Regular grids), but you can now specify a
rectangular region which you want to reÔ¨Åne by a factor of 2. The way you do this is by choosing the starting indices
of the rectangle and specifying the size of the rectangle by setting the number of cells in each direction from that
starting point onward. For instance, setting the starting point at (2,3,1) and the size at (1,1,1) will simply reÔ¨Åne just
cell (2,3,1) of the base grid into a set of 2x2x2 sub-cells. But setting the starting point at (2,3,1) and the size at (2,2,2)
will split cells (2,3,1), (3,3,1), (2,4,1), (3,4,1), (2,3,2), (3,3,2), (2,4,2) and (3,4,2) each into 2x2x2 subcells. This in fact
is handled as a 4x4x4 regular sub-grid patch. And setting the starting point at (2,3,1) and the size at (4,6,8) will make
an entire regular sub-grid patch of 8x12x16 cells. Such a sub-grid patch is called a layer.
The nice thing of these layers is that each layer (i.e. subgrid patch) is handled as a regular sub-grid. The base grid is
layer number 0, and the Ô¨Årst layer is layer number 1, etc. Each layer (including the base grid) can contain multiple
sub-layers. The only restriction is that each layer Ô¨Åts entirely inside its parent layer, and layers with the same parent
layer should not overlap. Each layer can thus have one or more sub-layers, each of which can again be divided into
sub-layers. This builds a tree structure, with the base layer as the trunk of the tree (this is contrary to the oct-tree
structure, where each base grid cell forms the trunk of its own tree). In Fig. Fig. 9.5 an example is shown of two layers
with the same parent (= layer 0 = base grid), while in Fig. Fig. 9.6 an example is shown of two nested layers.
iy=6
iy=5
xi[1]
yi[1]
ix=1
ix=2
ix=3
ix=4
xc[1]
xi[2]
xc[2]
xi[3]
xc[3]
xi[4]
xc[4]
xi[5]
ix=5
ix=6
ix=7
ix=8
xi[6]
xi[7]
xi[8]
xc[6]
xc[7]
xc[8]
xc[5]
xi[9]
yc[1]
iy=1
iy=2
iy=3
yi[2]
yc[2]
yi[3]
yc[3]
yi[4]
yi[5]
yi[6]
yi[7]
yc[4]
yc[5]
yc[6]
iy=4
Fig. 9.5: Example of a 2-D base grid with nx=4 and ny=3, with two AMR-layers added to it. This example has just
one level of reÔ¨Ånement, as the two layers (brown and green) are on the same level (they have the same parent layer =
layer 0).
If you now want to specify data on this grid, then you simply specify it on each layer separately, as if each layer
is a separate entity. Each layer is treated as a regular grid, irrespective of whether it contains sub-layers or not. So
if we have a base grid of 4x4x4 grid cells containing two layers: one starting at (1,1,1) and having (2,2,2) size and
another starting at (3,3,3) and having (1,1,2) size, then we Ô¨Årst specify the data on the 43 = 64 base grid, then on the
(2√ó2)3 = 64 grid cells of the Ô¨Årst layer and then on the 2x2x4=16 cells of the second layer. Each of these three layers
are regular grids, and the data is inputted/outputted in the same way as if these are normal regular grids (see Section
Regular grids). But instead of just one such regular grid, now the data Ô¨Åle (e.g. dust_density.inp) will contain
three successive lists of numbers, the Ô¨Årst for the base grid, the second for the Ô¨Årst layer and the last for the second
layer. You may realize at this point that this will introduce a redundancy. See Subsection On the ‚Äòsuccessively regular‚Äô
112
Chapter 9. More information about the gridding

radmc3d, Release 2.0
iy=6
iy=5
xi[1]
yi[1]
ix=1
ix=2
ix=3
ix=4
xc[1]
xi[2]
xc[2]
xi[3]
xc[3]
xi[4]
xc[4]
xi[5]
ix=5
ix=6
ix=7
ix=8
xi[6]
xi[7]
xi[8]
xc[6]
xc[7]
xc[8]
xc[5]
xi[9]
yc[1]
iy=1
iy=2
iy=3
yi[2]
yc[2]
yi[3]
yc[3]
yi[4]
yi[5]
yi[6]
yi[7]
yc[4]
yc[5]
yc[6]
iy=4
Fig. 9.6: Example of a 2-D base grid with nx=4 and ny=3, with two nested AMR-layers added to it. This example
has two levels of reÔ¨Ånement, as layer 1 (brown) is the parent of layer 2 (green).
kind of data storage, and its slight redundancy for a discussion of this redundancy.
The precise way how to set up such an oct-tree grid using the amr_grid.inp Ô¨Åle is described in Section Layer-style
AMR grid. The input of any spatial variables (such as e.g. the dust density) uses the sequence of grid cells in the same
order as the cells are speciÔ¨Åed in that amr_grid.inp Ô¨Åle.
9.4.1 On the ‚Äòsuccessively regular‚Äô kind of data storage, and its slight redundancy
With the layered grid reÔ¨Ånement style there will be redundant data in the data Ô¨Åles (such as e.g. the dust_density.
inp Ô¨Åle. Each layer is a regular (sub-)grid and the data will be speciÔ¨Åed in each of these grid cells of that regular
(sub-)grid. If then some of these cells are overwritten by a higher-level layer, these data are then redundant. We could
of course have insistent that only the data in those cells that are not reÔ¨Åned by a layer should be written to (or read
from) the data Ô¨Åles. But this would require quite some clever programming on the part of the user to a-priori Ô¨Ånd out
where the layers are and therefore which cells should be skipped. We have decided that it is far easier to just insist
that each layer (including the base grid, which is layer number 0) is simply written to the data Ô¨Åle as a regular block
of data. The fact that some of this data will be not used (because they reside in cells that are reÔ¨Åned) means that we
write more data to Ô¨Åle than really exists in the model. This makes the Ô¨Åles larger than strictly necessary, but it makes
the data structure by far easier. Example: suppose you have a base grid of 8x8x8 cells and you replace the inner 4x4x4
cells with a layer of 8x8x8 cells (each cell being half the size of the original cells). Then you will have for instance a
dust_density.inp Ô¨Åle containing 1024 values of the density: 83=512 values for the base grid and again 83=512
values for the reÔ¨Ånement layer. Of the Ô¨Årst 83=512 values 43=64 values are ignored (they could have any value as they
will not be used). The Ô¨Åle is thus 64 values larger than strictly necessary, which is a redundancy of 64/1024=0.0625. If
you would have used the oct-tree reÔ¨Ånement style for making exactly the same grid, you would have only 1024-64=960
values in your Ô¨Åle, making the Ô¨Åle 6.25% smaller. But since 6.25% is just a very small difference, we decided that this
is not a major problem and the simplicity of our ‚Äòsuccessively regular‚Äô kind of data format is more of an advantage
than the 6.25% redundance is a disadvantage.
9.4. Layered Adaptive Mesh ReÔ¨Ånement
113

radmc3d, Release 2.0
9.5 Unstructured grids
In a future version of RADMC-3D we will include unstructured gridding as a possibility. But at this moment such a
gridding is not yet implemented.
9.6 1-D Plane-parallel models
Sometimes it can be useful to make simple 1-D plane parallel models, for instance if you want to make a simple 1-D
model of a stellar atmosphere. RADMC-3D is, however, by nature a 3-D code. But as of version 0.31 it features
a genuine 1-D plane-parallel mode as well. This coordinate type has the number 10. In this mode the ùë•- and ùë¶-
coordinates are the in-plane coordinates, while the ùëß-coordinate is the 1-D coordinate. We thus have a 1-D grid in the
ùëß-coordinate, but no grid in ùë•- or ùë¶-directions.
You can make a 1-D plane-parallel model by setting some settings in the amr_grid.inp Ô¨Åle. Please consult Section
INPUT (required): amr_grid.inp for the format of this Ô¨Åle. The changes/settings you have to do are (see example
below): (1) set the coordinate type number to 10, (2) set the ùë•and ùë¶dimensions to non-active and (3) setting the cell
interfaces in ùë•to -1d90, +1d90, and likewise for ùë¶. Here is then how it looks:
1
<=== Format number = 1
0
<=== Grid style (0=regular grid)
10
<=== Coordinate type (10=plane-parallel)
0
<=== (obsolete)
0
0
1
<=== x and y are non-active, z is active
1
1
100
<=== x and y are 1 cell, in z we have 100 cells
-1e90 1e90
<=== cell walls in x are at "infinity"
-1e90 1e90
<=== cell walls in y are at "infinity"
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
The other input Ô¨Åles are for the rest as usual, as in the 3-D case.
You can now make your 1-D model as usual. For 1-D plane-parallel problems it is often useful to put a thermal
boundary at the bottom of the model. For instance, if the model is a stellar atmosphere, you may want to cap the grid
from below with some given temperature. See Section Thermal boundaries in Cartesian coordinates for details on
how to set up thermal boundaries.
In the 1-D plane-parallel mode some things work a bit different than in the ‚Äúnormal‚Äù 3-D mode:
‚Ä¢ Images are by default 1x1 pixels, because in a plane-parallel case it is useless to have multiple pixels.
‚Ä¢ Spectra cannot be made, because ‚Äúspectrum‚Äù is (in RADMC-3D ‚Äòlanguage‚Äô) the Ô¨Çux as a function of frequency
as seen at a very large distance of the object, so that the object is in the ‚Äúfar Ô¨Åeld‚Äù. Since the concept of ‚Äúfar-Ô¨Åeld‚Äù
is no longer meaningful in a plane-parallel case, it is better to make frequency-dependent 1x1 pixel images. This
gives you the frequence-dependent intensity, which is all you should need.
‚Ä¢ Stars are not allowed, as they have truly 3-D positions, which is inconsistent with the plane-parallel assumption.
But for the rest, most stuff works similarly to the 3-D version. For instance, you can compute dust temperatures with
radmc3d mctherm
as usual.
114
Chapter 9. More information about the gridding

radmc3d, Release 2.0
9.6.1 Making a spectrum of the 1-D plane-parallel atmosphere
As mentioned above, the ‚Äònormal‚Äô 3-D way of making a spectrum of the 1-D plane-parallel atmosphere is not possible,
because formally the atmosphere is inÔ¨Ånitely extended. Instead you can obtain a spectrum in the form of an intensity
(erg s‚àí1 cm‚àí2 Hz‚àí1 ster‚àí1) as a function of wavelength. To do this you ask RADMC-3D to make a multi-wavelength
image of the atmosphere under a certain inclination (inclination 0 meaning face-on), e.g.:
radmc3d image allwl incl 70
This make an SED at ùúÜ= 10 ùúám for the observer seeing the atmosphere at an inclination of 70 degrees. This produces
a Ô¨Åle image.out, described in Section OUTPUT: image.out or image_****.out. The image is, in fact, a 1x1 pixel
multi-wavelength image. The allwl (which stands for ‚Äòall wavelengths‚Äô) means that the spectral points are the same
as those in the wavelength_micron.inp Ô¨Åle (see Section INPUT (required): wavelength_micron.inp). You can
also specify the wavelengths in a different way, e.g.:
radmc3d image lambdarange 5 20 nlam 10
In fact, see Section Making multi-wavelength images and Section Specifying custom-made sets of wavelength points
for the camera for details.
9.6.2 In 1-D plane-parallel: no star, but incident parallel Ô¨Çux beams
In 1-D plane-parallel geometry it is impossible to include meaningful stars as sources of photons. This is not a technical
issue, but a mathematical truth: a point in 1-D is in reality a plane in 3-D. As a replacement RADMC-3D offers (only
in 1-D plane-parallel geometry) the possibility of illuminating the 1-D atmosphere from above with a Ô¨Çux, incident
onto the atmosphere in a prescribed angle. This allows you to model, e.g., the Earth‚Äôs atmosphere being illuminated by
the sun at a given time of the day. This is done by providing an ascii Ô¨Åle called illum.inp which has the following
form (similar, but not identical, to the stars.inp Ô¨Åle, see Section INPUT (mostly required): stars.inp):
iformat
<=== Put this to 2 !
nillum
nlam
theta[1]
phi[1]
.
.
.
.
theta[nillum] phi[nillum]
lambda[1]
.
.
lambda[nlam]
flux[1,illum=1]
.
.
flux[nlam,illum=1]
flux[1,illum=2]
.
.
flux[nlam,illum=2]
.
.
.
.
flux[nlam,illum=nstar]
Here nillum is the number of illuminating beams you want to specify. Normally this is 1, unless you have, e.g., a
planet around a double star. The theta is the angle (in degrees) under which the beam impinges onto the atmosphere.
9.6. 1-D Plane-parallel models
115

radmc3d, Release 2.0
If you have theta=0, then the Ô¨Çux points vertically downward (sun at zenith). If you have theta=89, then the Ô¨Çux
points almost parallel to the atmosphere (sunset). It is not allowed to put theta=90.
You can, if you wish, also put the source behind the slab, i.e. theta>90. Please note, however, that if you compute
the spectrum of the plane-parallel atmosphere the direct Ô¨Çux from these illumination beams does not get picked up in
the spectrum.
9.6.3 Similarity and difference between 1-D spherical and 1-D plane-parallel
Note that this 1-D plane-parallel mode is only available in ùëß-direction, and only for cartesian coordinates! For spherical
coordinates, a simple switch to 1-D yields spherically symmetric 1-D radiative transfer, which is, however, geometri-
cally distinct from 1-D plane-parallel radiative transfer. However, you can also use a 1-D spherically symmetric setup
to ‚Äòemulate‚Äô 1-D plane parallel problems: You can make, for instance, a radial grid in which ùëünr/ùëü1 ‚àí1 ‚â™1. An
example: ùëü= {10000.0, 10000.1, 10000.2, ¬∑ ¬∑ ¬∑ , 10001.0}. This is not perfectly plane-parallel, but sufÔ¨Åciently much
so that the difference is presumably indiscernable. The spectrum is then automatically that of the entire large sphere,
but by dividing it by the surface area, you can recalculate the local Ô¨Çux. In fact, since a plane-parallel model usually
is meant to approximate a tiny part of a large sphere, this mode is presumably even more realistic than a truly 1-D
plane-parallel model.
9.7 Thermal boundaries in Cartesian coordinates
By default all boundaries of the computational domain are open, in the sense that photons can move out freely. The
only photons that move into the domain from the outside are those from the interstellar radiation Ô¨Åeld (see Section The
interstellar radiation Ô¨Åeld: external source of energy) and from any stars that are located outside of the computational
domain (see Section INPUT (mostly required): stars.inp). For some purposes it might, however, be useful to have
one or more of the six boundaries in 3-D to be closed. RADMC-3D offers the possibility, in cartesian coordinates, to
convert the boundaries (each of the six separately) to a thermal boundary, i.e. a blackbody emitter at some user-seciÔ¨Åed
temperature. If you want that the left X-boundary is a thermal wall at T=100 Kelvin, then you add the following line
to the radmc3d.inp Ô¨Åle:
thermal_boundary_xl = 100
and similarly for xr (right X-boundary), yl, yr, zl and/or zr. You can set this for each boundary separately, and
particularly you can choose to set just one or just two of the boundaries to thermal boundaries. Note that setting
thermal_boundary_xl=0 is equivalent to switching off the thermal boundary.
Note that if you now make an image of the box, the ray-tracer will show you still the inside of the box, through
any possible thermal boundary. In other words: for the imaging or spectra these thermal boundaries are opaque
for radiation entering the grid, while they are transparent for radiation exiting the grid. In other words, we see the
blackbody emission from the backside walls, but not of the frontside walls. In this way we can have a look inside the
box in spite of the thermal walls.
116
Chapter 9. More information about the gridding

CHAPTER
TEN
MORE INFORMATION ABOUT THE TREATMENT OF STARS
How stars are treated in RADMC-3D is perhaps something that needs some more background information. This is the
structure:
1. Stars as individual objects:
The most standard way of injecting stellar light into the model is by putting one or more individual stars in the
model. A star can be placed anywhere, both inside the grid and outside. The main input Ô¨Åle specifying their
location and properties is: stars.inp. The stars can be treated in two different ways, depending on the setting
of the variable istar_sphere that can be set to 0 or 1 in the Ô¨Åle radmc3d.inp Ô¨Åle.
‚Ä¢ The default is to treat stars as zero-size point sources. This is the way it is done if (as is the default)
istar_sphere=0. The stars are then treated as point sources in spite of the fact that their radius is
speciÔ¨Åed as non-zero in the stars.inp Ô¨Åle. This default mode is the easiest and quickest. For most
purposes it is perfectly Ô¨Åne. Only if you have material very close to a stellar surface it may be important
to treat the Ô¨Ånite size(s) of the star(s).
‚Ä¢ If istar_sphere=1 in the radmc3d.inp Ô¨Åle, then all stars are treated as spheres, their radii being
the radii speciÔ¨Åed in the stars.inp Ô¨Åle. This mode can be tricky, so please read Section Stars treated
as spheres.
2. Smooth distributions of zillions of stars:
For modeling galaxies or objects of that size scale, it is of course impossible and unnecessary to treat each star
individually. So in addition to the individual stars you can specify spatial distributions of stars, assuming that
the number of stars is so large that there will always be a very large number of them in each cell. Please note
that using this possibility does not exclude the use of individual stars as well. For instance, for a galaxy you
may want to have distributions of unresolved stars, but one single ‚Äòstar‚Äô for the active nucleus and perhaps a few
individual ‚Äòstars‚Äô for bright star formation regions or O-star clusters or so. The distribution of stars is described
in Section Distributions of zillions of stars.
3. An external ‚Äòinterstellar radiation Ô¨Åeld‚Äô:
Often an object is affected not only by the stellar radiation from the stars inside the object itself, but also by the
diffuse radiation from the many near and far stars surrounding the object. This ‚ÄòInterstellar Radiation Field‚Äô can
be treated by RADMC-3D as well. This is called the ‚Äòexternal source‚Äô in RADMC-3D. It is described in Section
The interstellar radiation Ô¨Åeld: external source of energy.
117

radmc3d, Release 2.0
10.1 Stars treated as point sources
By default the stars are treated as point-sources. Even if the radius is speciÔ¨Åed as non-zero in the stars.inp Ô¨Åle,
they are still treated as points. The reason for this is that it is much easier and faster for the code to treat them as
point-sources. Point sources cannot occult anything in the background, and nothing can partly occult them (they are
only fully or not occulted, of course modulo optical depth of the occulting object). This approximation is, however,
not valid if the spatial scales you are interested in are not much larger (or even the same or smaller) than the size of the
star. For instance, if we are interested in modeling the radiative transfer in a disk around a Brown Dwarf, where dust
can survive perhaps even all the way down to the stellar surface, we must take the non-point-like geometry of the star
into account. This is because due to its size, the star can shine down onto the disk, which would not be possible if the
star is treated as a point source. However, for a dust disk arounda Herbig Ae star, where the dust evaporation radius is
at about 0.5 AU, the star can be treated as a point-source without problems.
So if you just use RADMC-3D as-is, or if you explicitly set istar_sphere=0 in the Ô¨Åle radmc3d.inp, then the
stars are all treated as point sources.
10.2 Stars treated as spheres
For problems in which the Ô¨Ånite geometrical size of the star (or stars) is/are important, RADMC-3D has a mode by
which the stars are treated as spheres. This can be necessary for instance if you model a disk around a Brown Dwarf,
where the dusty disk goes all the way down to the stellar surface. The Ô¨Ånite size of the star can thus shine down onto
the disk, but only if its Ô¨Ånite size is treated as such. In the default point-source approximation the surface layers of
such a disk would be too cold, because this ‚Äòshining down onto the disk‚Äô phenomenon is not treated.
You can switch this mode on by setting istar_sphere=1 in the Ô¨Åle radmc3d.inp. Note that no limb darkening
or brightening is included in this mode, and currently RADMC-3D does not have such a mode available.
This mode is, however, somewhat complex. A sphere can partly overlap the grid, while being partly outside the grid.
A sphere can also overlap multiple cells at the same time, engulÔ¨Ång some cells entirely, while only partly overlapping
others. The correct and fast treatment of this makes the code a bit slower, and required some complex programming.
So the user is at the moment advised to use this mode only if necessary and remain aware of possible errors for now
(as of version 0.17).
For the Monte Carlo simulations the Ô¨Ånite star size means that photon packages are emitted from the surface of the
sphere of the star. It also means that any photon that re-enters the star during the Monte Carlo simulation is assumed
to be lost.
10.3 Distributions of zillions of stars
For models of galaxies it is important to be able to have distributed stellar sources instead of individual stars. The way
to implement this in a model for RADMC-3D is to
1. Prepare one or more template stellar spectra, for instance, one for each stellar type you wish to include.
These must be speciÔ¨Åed in the Ô¨Åle stellarsrc_templates.inp (see Section INPUT (optional): stel-
larsrc_templates.inp). Of course the more templates you have, the more memory consuming it becomes, which
is of particular concern for models on large grids. You can of course also take a sum of various stellar types as
a template. For instance, if we wish to include a ‚Äòtypical‚Äô bulge stellar component, then you do not need to treat
each stellar type of bulge stars separately. You can take the ‚Äòaverage spectrum per gram of average star‚Äô as the
template and thus save memory.
2. For each template you must specify the spatial distribution, i.e. how many stars of each template star are there
per unit volume in each cell. The stellar density is, in fact, given as gram-of-star/cm3 (i.e. not as number density
118
Chapter 10. More information about the treatment of stars

radmc3d, Release 2.0
of stars). The stellar spatial densities are speciÔ¨Åed in the Ô¨Åle stellarsrc_density.inp (see Section
INPUT (optional): stellarsrc_density.inp).
Note that if you have a Ô¨Åle stellarsrc_templates.inp in your model directly, then the stellar sources are
automatically switched on. If you do not want to use them, then you must delete this Ô¨Åle.
The smooth stellar source distributions are nothing else than source functions for the radiative transfer with the spectral
shape of the template stellar spectra from the stellarsrc_templates.inp. You will see that if you make
a spectrum of your object, then even if the dust temperature etc is zero everywhere, you still see a spectrum: that
of the stellar template(s). In the Monte Carlo simulations these stellar templates act as net sources of photons, that
subsequently move through the grid in a Monte Carlo way.
Note that the smooth stellar source distributions assume that the zillions of stars that they represent are so small that
they do not absorb any appreciable amount of radiation. They are therefore pure sources, not sinks.
10.4 The interstellar radiation Ô¨Åeld: external source of energy
You can include an isotropic interstellar radiation Ô¨Åeld in RADMC-3D. This will take effect both in the making of
spectra and images, as well as in the Monte Carlo module.
The way to activate this is to make a Ô¨Åle external_source.inp and Ô¨Åll it with the information needed (see
Section INPUT (optional): external_source.inp).
10.4.1 Role of the external radiation Ô¨Åeld in Monte Carlo simulations
For the Monte Carlo simulations this means that photons may be launched from outside inward. The way that this
is done is that RADMC-3D will make a sphere around the entire grid, just large enough to Ô¨Åt in the entire grid but
not larger. Photon packages can freely leave this sphere. But if necessary, photon packages can be launched from
this sphere inward. RADMC-3D will then calculate the total luminosity of this sphere, which is ùêø= 4ùúã2ùêºùëü2
sphere
where ùêºis the intensity. For monochromatic Monte Carlo it is simply ùêº= ùêºùúà, while for the thermal Monte Carlo it
is ùêº=
‚à´Ô∏Ä‚àû
0
ùêºùúàùëëùúà, where ùêºùúàis the intensity as speciÔ¨Åed in the Ô¨Åle external_source.inp. Note that if the sphere
would have been taken larger, then the luminosity of the external radiation Ô¨Åeld would increase. This may seem anti-
intuitive. The trick, however, is that if the sphere is larger, then also more of these interstellar photons never enter the
grid and are lost immediately. That is why it is so important that RADMC-3D makes the sphere as small as possible,
so that it limits the number of lost photon packages. It also means that you, the user, would make the grid much larger
than the object you are interested in, then RADMC-3D is forced to make a large sphere, and thus potentially many
photons will get lost: they may enter the outer parts of the grid, but there they will not get absorbed, nor will they do
much.
In fact, this is a potential difÔ¨Åculty of the use of the external sources: since the photon packages are lauchned from
outside-inward, it may happen that only few of them will enter in the regions of the model that you, the user, are
interested in. For instance, you are modeling a 3-D molecular cloud complex with a few dense cold starless cores.
Suppose that no stellar sources exist in this model, only the interstellar radiation Ô¨Åeld. The temperature in the centers of
these starless cores will be determined by the interstellar radiation Ô¨Åeld. But since the cores are very small compared
to the total model (e.g. you have used AMR to reÔ¨Åne the grid around/in these cores), the chance of each external
photon package to ‚Äòhit‚Äô the starless core is small. It means that the larger the grid or the smaller the starless core, the
more photon packages (nphot, see Section The thermal Monte Carlo simulation: computing the dust temperature)
one must use to make sure that at least some of them enter the starless cores. If you choose phot too small in this
case, then the temperature in these cores would remain undetermined (i.e. they will be zero in the results).
10.4. The interstellar radiation Ô¨Åeld: external source of energy
119

radmc3d, Release 2.0
10.4.2 Role of the external radiation Ô¨Åeld in images and spectra
The interstellar radiation Ô¨Åeld also affects the images and spectra that you make. Every ray will start at minus-inÔ¨Ånity
with the intensity given by the external radiation Ô¨Åeld, instead of 0 as it would be if no external radiation Ô¨Åeld is
speciÔ¨Åed. If you make an image, the background of your object will then therefore not be black. You can even make
silhouette images like those of the famous silhouette disks in Orion.
But there is a danger: if you make spectra, then also the background radiation is inside the beam, and will thus
contribute to the spectrum. In fact, the larger you make the beam the more you will pick up of the background. This
could thus lead to the spectrum of your source to be swamped by the background if you do not specify a beam in the
spectrum.
10.5 Internal heat source
Sometimes the gas and dust inside the object of interest gets heated up by some internal process such as friction,
magnetic reconnection, chemical reactions, etc. A nice example is the ‚Äòviscous heating‚Äô inside an accretion disk.
This net heat source can be included in RADMC-3D by creating a Ô¨Åle heatsource.inp. The format of the Ô¨Åle is
described in Section INPUT (optional): heatsource.inp. It is the same as for other scalar Ô¨Åelds.
With this input Ô¨Åle you have to specify in each cell how much energy per second per cubic centimeter is released in the
form of heat. This energy will then be emitted as radiation by the dust. The way the code does this in the Bjorkman
& Wood algorithm is that it will launch photon packages from these cells. The difference with the stellar energy input
(see Section Distributions of zillions of stars) is that the energy is Ô¨Årst injected into the dust of the cell, and then
emitted as thermal dust emission. The launching of the photon package is therefore always a thermal dust emission. In
contrast, in the stellar energy input method of Section Distributions of zillions of stars the photon package is launched
directly, with a wavelength randomly drawn from the local stellar spectrum shape. The difference between these two
methods will be most apparent for optically thin models. For very optically thick cases, where the heat source is
released deep inside an optically thick object, both methods will presumably yield the same result. Nevertheless, it is
recommended to use the heat source method for cases such as chemical or viscous heating of the gas and dust, even
for optically thick cases.
A note of caution: in spite of the fact that this heat source method allows you to add additional energy sources,
the object of study must still be in local thermodynamic equilibrium (LTE). If the gas+dust mixture is Ô¨Çowing and
experiences signiÔ¨Åcant adiabatic heating and cooling events, then the LTE condition is no longer met and RADMC-
3D will not be able to give reliable answers. Sometimes one may be able to fudge this in some clever way, but one
should always be aware that strictly speaking the Bjorkman & Wood Monte Carlo method only works if in each cell all
energy input (be it radiative absorption or an internal heat source) is balanced exactly by the same amount of radiative
energy output. The algorithm computes the dust temperature on that assumption: it computes how much energy the
cell gains (by the heat source or by absorbing photons) and then it requires that the temperature of the dust is such that
precisely the same amount of radiative energy is emitted.
10.5.1 Slow performance of RADMC-3D with heat source
For very optically thick models, such as the inner regions of actively accreting dusty protoplanetary disks, the use of
this heat source can lead to extremely slow performance. The reason is that all photons originating from this heat
source will start their journey right in the middle of the most optically thick regions, requiring these photons to make
gazillions of absorption/re-emission events before Ô¨Ånally diffusing out. It should in principle work if the code runs
long enough. But one must have some patience. The use of the ModiÔ¨Åed Random Walk method (see Section ModiÔ¨Åed
Random Walk method for high optical depths) would then be useful to speed things up, but still it can take time.
A few things might be useful to consider. One is that protoplanetary disks only have such insane optical depths
(ùúè‚â≥105) if none of the dust has coagulated to bigger grains. This might be the correct assumption, especially in
the very early phases of protoplanetary disk evolution. But dust coagulation is known to be quick, so it might equally
120
Chapter 10. More information about the treatment of stars

radmc3d, Release 2.0
well be that, say, 90% of the small grain dust has already grown to larger grains, which have less opacity. This is of
course just a pure guess. Another thing is that many MHD models of disk turbulence show that most of the energy is
not released near the midplane, but instead at one or two scale heights above the midplane. Both considerations would
lower the optical depth for the energy to get out of the disk, speeding up the calculation. And the outcoming spectrum
or image it will presumably not be affected that much, because at the end of the day the effective temperature of the
disk surface must anyway be such that it radiates away the internal heat, independent of how deep inside the disk this
heat is released.
10.5. Internal heat source
121

radmc3d, Release 2.0
122
Chapter 10. More information about the treatment of stars

CHAPTER
ELEVEN
MODIFYING RADMC-3D: INTERNAL SETUP AND USER-SPECIFIED
RADIATIVE PROCESSES
It has been mentioned several times before that as an alternative to the standard compile once-and-for-all‚Äô philosophy,
one can also use RADMC-3D by modifying the code directly so that ``radmc3d` will have new functionality that might
be of use for you. We refer to Section Making special-purpose modiÔ¨Åed versions of RADMC-3D (optional) for an
in-depth description of how to modify the code in a way that is non-invasive to the main code. We urge the reader to
read Section Making special-purpose modiÔ¨Åed versions of RADMC-3D (optional) Ô¨Årst before continuing to read this
chapter. In all of the following we assume that the editings to the fortran Ô¨Åles are done in the local way described
in Section Making special-purpose modiÔ¨Åed versions of RADMC-3D (optional) so that the original source Ô¨Åles in the
src/ directory stay unaffected, and only local copies are edited.
11.1 Setting up a model inside of RADMC-3D
The most common reason for editing the code itself is for setting up the model internally rather than reading in all
data via input Ô¨Åles. For a list of advantages and disadvantages of setting models up internally as opposed to the
standard way, see Section Some caveats and advantages of internal model setup below. Setting up a model within
RADMC-3D is done by making a local copy of the Ô¨Åle userdef_module.f90 and editing it (see Section Making
special-purpose modiÔ¨Åed versions of RADMC-3D (optional)). This Ô¨Åle contains a set of standard subroutines that
are called by the main program at special points in the code. Each subroutine has a special purpose which will be
described below. By keeping a subroutine empty, nothing is done. By Ô¨Ålling it with your own code lines, you can set
up the density, temperature or whatever needs to be set up for the model. In addition to this you can do the following
as well:
‚Ä¢ Add new variables or arrays in the module header (above the contains command), which you can use in the
subroutines of the userdef_module.f90 module. You are completely free to add any new variables you
like. A small tip: it may be useful (though not required) to start all their names with e.g. userdef_ to make
sure that no name conÔ¨Çicts with other variables in the code happen.
‚Ä¢ Add new subroutines at will (below the contains command) which you can call from within the standard
subroutines.
‚Ä¢ Introduce your own radmc3d command-line options (see Section The pre-deÔ¨Åned subroutines of the
userdef_module.f90).
‚Ä¢ Introduce your own radmc3d.inp namelist variables (see Section The pre-deÔ¨Åned subroutines of the
userdef_module.f90).
Often you still want some of the input data to be still read in in the usual way, using input Ô¨Åles. For instance, you may
want to still read the dustopac.inp and the opacities using the dustkappa_xxx.inp Ô¨Åles. This is all possible.
Typically, you simply keep the Ô¨Åles you still want RADMC-3D to read, and omit the Ô¨Åles that contain data that you
allocate and set in the userdef_module.f90. This is all a bit complicated, so the best way to learn how to do this
is to start from the example directories in which a model is set up with the userdef_module.f90 method.
123

radmc3d, Release 2.0
Input data files. Only the
data not set by userdef.
Optionally (radmc3d.inp)
also parameters of your
user-defined model.
***.inp or ***.binp
RADMC-3D
radtrans calculation
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
userdef_module.f90
internal model setup
Fig. 11.1: Pictographic representation of the dataÔ¨Çow for the case when you deÔ¨Åne your model internally using the
userdef_module.f90.
In Fig. Fig. 11.1 the dataÔ¨Çow for the user-deÔ¨Åned model setup is graphically depicted.
11.2 The pre-deÔ¨Åned subroutines of the userdef_module.f90
The idea of the userdef_module.f90 is that it contains a number of standard pre-deÔ¨Åned subroutines that are
called from the main.f90 code (and only from there). Just browse through the main.f90 Ô¨Åle and search for the
sequence calluserdef_ and you will Ô¨Ånd all the points where these standard routines are called. It means that at
these points you as the user have inÔ¨Çuence on the process of model setup. Here is the list of standard routines and how
they are used. They are ordered roughly in chronological order in which they are called.
‚Ä¢ userdef_defaults()
This subroutine allows you to set the default value of any new parameters you may have introduced. If neither
on the command line nor in the radmc3d.inp Ô¨Åle the values of these parameters are set, then they will simply
retain this default value.
‚Ä¢ userdef_commandline(buffer,numarg,iarg,fromstdi,gotit)
This subroutine allows you to add your own command-line options for radmc3d. The routine has a series
of standard arguments which you are not allowed to change. The buffer is a string containing the current
command line option that is parsed. You will check here if it is an option of your module, and if yes, activate it.
An example is listed in the code. You an also require a second argument, for which also an example is listed in
the original code.
‚Ä¢ userdef_commandline_postprocessing()
After the command line options have been read, it can be useful to check if the user has not asked for conÔ¨Çicting
things. Here you can do such checks.
‚Ä¢ userdef_parse_main_namelist()
Here you can add your own namelist parameters that read from the radmc3d.inp Ô¨Åle. An example is provided
in the original code.
‚Ä¢ userdef_main_namelist_postprocessing()
Also here, after the entire radmc3d.inp Ô¨Åle has been read and interpreted, you can do some consistency
checks and postprocessing here.
‚Ä¢ userdef_prep_model()
This routine can be used if you wish to set up the grid not from input Ô¨Åles but internally. You will have to know
how to deal with the amr_module.f90 module. You can also set your own global frequency grid here. And
Ô¨Ånally, you can set your own stellar sources here. In all cases, if you set these things here (which requires you
to make the proper memory allocations, or in case of the gridding, let the amr_module.f90 do the memory
allocations for you) the further course of radmc3d will skip any of its own settings (it will simply detect if
these arrays are allocated already, and if yes, it will simply not read or allocate them anymore).
124
Chapter 11. Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes

radmc3d, Release 2.0
‚Ä¢ userdef_setup_model()
This is the place where you can actually make your own model setup. By the time this subroutine is called, all
your parameters have been read in, as well as all of the other parameters from the original radmc3d code. So
you can now set up the dust density, or the gas velocity or you name it. For all of these things you will have
to allocate the arrays youself (!!!). Once you did this, the rest of the radmc3d code won‚Äôt read those data
anymore, because it detects that the corresponding arrays have already been allocated (by you). This allows you
to completely circumvent the reading of any of the following Ô¨Åles by making these data yourself here at this
location:
‚Äì amr_grid.inp or in the future the input Ô¨Åles for any of the other griding types.
‚Äì dust_density.inp
‚Äì dust_temperature.dat
‚Äì gas_density.inp
‚Äì gas_temperature.inp
‚Äì gas_velocity.inp
‚Äì microturbulence.inp
‚Äì levelpop_XXX.dat
‚Äì numberdens_XXX.inp
To learn how to set up a model in this way, we refer you for now to the ioput_module.f90 or
lines_module.f90 and search for the above Ô¨Åle names to see how the arrays are allocated and how the
data are inserted. I apologise for not explaining this in more detail at this point. But examples are or will be
given in the examples/ directory.
‚Ä¢ userdef_dostuff()
This routine will be called by the main routine to allow you to do any kind of calculation after the main calcu-
lation (for instance after the monte carlo simulation). This is done within the execution-loop.
‚Ä¢ userdef_compute_levelpop()
This is a subroutine that can be called by the camera module for on-the-Ô¨Çy calculation of level populations
according to your own recipe. This may be a bit tricky to use, but I hope to be able to provide some example(s)
in the near future.
‚Ä¢ userdef_srcalp()
This subroutine allows you to add any emission/absorption process you want, even fake ones. For instance,
you could use this to create nicely volume-rendered images of your 3-D models with fake opacities, which are
chosen to make the image look nice and/or insight-giving. You can also use this to add physical processes that are
not yet implemented in RADMC-3D. This subroutine allows you full freedom and Ô¨Çexibility to add emissivity
and extinction whereever/however you like. To activate it you must set incl_userdef_srcalp=1 in the
radmc3d.inp Ô¨Åle.
‚Ä¢ userdef_writemodel()
This allows the user to dump any stuff to Ô¨Åle that the user computed in this module. You can also use this routine
to write out Ô¨Åles that would have been used normally as input Ô¨Åle (like amr_grid.inp or dust_density.
inp) so that the Python routines can read them if they need. In particular the grid information may be needed
by these external analysis tools. Here is a list of standard subroutines you can call for writing such Ô¨Åles:
‚Äì write_grid_file()
‚Äì write_dust_density()
‚Äì . . .more to come...
11.2. The pre-deÔ¨Åned subroutines of the userdef_module.f90
125

radmc3d, Release 2.0
For now this is it, more routines will be included in the future.
Note that the userdef_compute_levelpop() subroutine, in contrast to all the others, is called not from the
main.f90 program but from the camera_module.f90 module. This is why the camera module is the only
module that is higher in compilation ranking than the userdef module (i.e. the userdef module will be compiled before
the camera module). For this reason the userdef module has no access to the variables of the camera module. For the
rest, the userdef module has access to the variables in all other modules.
Note also that not all input data is meant to be generated in this way. The following types of data are still supposed to
be read from Ô¨Åle:
‚Ä¢ Dust opacity data
‚Ä¢ Molecular fundamental data
Please have a look in the examples/ directory for models which are set up in this internal way.
11.3 Some caveats and advantages of internal model setup
Setting up the models internally has several advantages as well as disadvantages compared to the standard way of
feeding the models into radmc3d via Ô¨Åles. The advantages are, among others:
‚Ä¢ You can modify the model parameters in radmc3d.inp and/or in the command line options (depending on
how you allow the user to set these parameters, i.e. in the userdef_parse_main_namelist() routine
and/or in the userdef_commandline() routine. You then do not need to run Python anymore (except for
setting up the basic Ô¨Åles; see examples). Some advantages of this:
‚Äì It allows you, for instance, to create a version of the radmc3d code that acts as if it is a special-purpose
model. You can specify model parameters on the command line (rather than going through the cumbersome
Python stuff).
‚Äì It is faster: even a large model is built up quickly and does not require a long read from large input Ô¨Åles.
‚Ä¢ You can make use of the AMR module routines such as the amr_branch_refine() routine, so you can
adaptively reÔ¨Åne the grid while you are setting up the model.
Some of the disadvantages are:
‚Ä¢ The model needs to be explicitly written out to Ô¨Åle and read into Python or any other data plotting package
before you can analyze the density structure to test if you‚Äôve done it right. You can explicitly ask ./radmc3d
to call the userdef_writemodel() subroutine (which is supposed to be writing out all essential data; but
that is the user‚Äôs responsibility) by typing ./radmc3dwritemodel.
‚Ä¢ Same is true for the grid, and this is potentially even more dangerous if not done. You can explicitly ask
./radmc3d to write out the grid Ô¨Åle by typing ./radmc3dwritegridfile. Note that if you call the
write_grid_file() subroutine from within userdef_writemodel(), then you do not have to ex-
plicitly type ./radmc3dwritegridfile as well. Note also that radmc3d will automatically call the
write_grid_file() subroutine when it writes the results of the thermal Monte Carlo computation, if it has
its grid from inside (i.e. it has not read the grid from the Ô¨Åle amr_grid.inp.
‚Ä¢ It requires a bit more knowledge of the internal workings of the radmc3d code, as you will need to directly
insert code lines in the userdef_module.f90 Ô¨Åle.
126
Chapter 11. Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes

radmc3d, Release 2.0
11.4 Using the userdef module to compute integrals of ùêΩùúà
With the monochromatic Monte Carlo computation (see Section Special-purpose feature: Computing the local radia-
tion Ô¨Åeld) we can calculate the mean intensity ùêΩùúàat every location in the model at a user-deÔ¨Åned set of wavelengths.
However, as mentioned before, for large models and large numbers of wavelengths this could easily lead to a data
volume that is larger than what the computer can handle. Since typically the main motivation for computing ùêΩùúàis to
compute some integral of the the form:
ùëÑ=
‚à´Ô∏Å‚àû
0
ùêΩùúàùêæùúàùëëùúà
where ùêæùúàis some cross section function or so, it may not be necessary to store the entire function ùêΩas a function of
ùëõùë¢. Instead we would then only by interested in the result of this integral at each spatial location.
So it would be useful to allow the user to do this computation internally. We should start by initializing ùëÑ(ùë•, ùë¶, ùëß) = 0
(or ùëÑ(ùëü, ùúÉ, ùúë) = 0 if you use spherical coordinates). Then we call the monochromatic Monte Carlo routine for the
Ô¨Årst wavelength we want to include, and multiply the resulting mean intensities with an appropriate ‚àÜùúàand add this
to ùëÑ(ùë•, ùë¶, ùëß). Then we do the monochromatic Monte Carlo for the next wavelength and again add to ùëÑeverywhere.
We repeat this until our integral (at every spatial location on the grid) is Ô¨Ånished, and we are done. This saves a huge
amount of memory.
Since
this
is
somewhat
hard
to
explain
in
this
PDF
document,
we
refer
to
the
example
model
run_example_jnu_integral/.
STILL IN PROGRESS.
11.5 Some tips and tricks for programming user-deÔ¨Åned subroutines
Apart from the standard subroutines that must be present in the userdef_module.f90 Ô¨Åle (see Section The pre-
deÔ¨Åned subroutines of the userdef_module.f90), you are free to add any subroutines or functions that you want, which
you can call from within the predeÔ¨Åned subroutines of Section The pre-deÔ¨Åned subroutines of the userdef_module.f90.
You are completely free to expand this module as you wish. You can add your own variables, your own arrays, allocate
arrays, etc.
Sometimes
you
may
need
to
know
‚Äòwhere
you
are‚Äô
in
the
grid.
For
instance,
the
subroutine
userdef_compute_levelpop() is called with an argument index. This is the index of the current cell from
within which the subroutine has been called. You can now address, for instance, the dust temperature at this location:
temp = dusttemp(1,index)
(for the case of a single dust species). You may also want to know the coordinates of the center of the cell. For this,
you must Ô¨Årst get a pointer to the AMR-tree structure of this cell. The pointer b is declared as
type(amr_branch), pointer :: b
Then you can point the pointer to that cell structure
b => amr_index_to_leaf(index)%link
And now you can get the x,y,z-coordinates of the center of the cell:
xc = amr_finegrid_xc(b%ixyzf(1),1,b%level)
yc = amr_finegrid_xc(b%ixyzf(2),2,b%level)
zc = amr_finegrid_xc(b%ixyzf(3),3,b%level)
Or the left and right cell walls:
11.4. Using the userdef module to compute integrals of ùêΩùúà
127

radmc3d, Release 2.0
xi_l = amr_finegrid_xi(b%ixyzf(1),1,b%level)
yi_l = amr_finegrid_xi(b%ixyzf(2),2,b%level)
zi_l = amr_finegrid_xi(b%ixyzf(3),3,b%level)
xi_r = amr_finegrid_xi(b%ixyzf(1)+1,1,b%level)
yi_r = amr_finegrid_xi(b%ixyzf(2)+1,2,b%level)
zi_r = amr_finegrid_xi(b%ixyzf(3)+1,3,b%level)
11.6 Creating your own emission and absorption processes
RADMC-3D Allows you to add your own physics to the ray-tracing images and spectra.
At every point dur-
ing the ray-tracing process, when it computes the emissivity and extinction coefÔ¨Åcients ùëóùúàand ùõºùúàit calls the
userdef_srcalp() subroutine, giving it the index in which cell we are, the frequencies of the different im-
age channels and the src and alp arrays which are for resp.ùëóùúàand ùõºùúà. You can add any process by
src(:) = src(:) + .....
alp(:) = alp(:) + .....
where . . . . . . is your formula. You can Ô¨Ånd the local variables like density and temperature using the index, e.g.:
rho_g = gasdens(index)
You can be completely free in your choices. If you need some information that is not usually read into RADMC-3D,
you can add read commands in the userdef_setup_model() subroutine, e.g.:
call read_gas_density(1)
See the example directory examples/run_simple_userdefsrc for more ideas.
128
Chapter 11. Modifying RADMC-3D: Internal setup and user-speciÔ¨Åed radiative processes

CHAPTER
TWELVE
PYTHON ANALYSIS TOOL SET
While the code RADMC-3D is written in fortran-90, there is an extensive set of tools written in Python that make it
easier for the user to set up models and interpret results. See Section Installing the simple Python analysis tools for
where they are and how they can be properly installed so that they are easy to use.
The RADMC-3D package has two support-libraries:
1. python/tools/simpleread.py
The python/tools/simpleread.py is a set of functions to read the most important data Ô¨Åles used by
RADMC-3D. However, the simpleread.py module is very simple, and does not read all RADMC-3D Ô¨Åles
in all formats. It can therefore only be used for certain (simple) models, and is primarily useful as a didactical
tool.
2. python/radmc3dPy
The radmc3dPy package is a stand-alone Python package, written by Attila Juhasz, meant for the pre- and
post-processing of RADMC-3D Ô¨Åles.
It has its own manual, and has to be installed using e.g.~Python‚Äôs
pipinstall method. This is described in the README Ô¨Åle in that package.
12.1 The simpleread.py library
For the most rudimentary analysis of the output (or input) Ô¨Åles of RADMC-3D you can use the simpleread.py
Ô¨Åle, which you can Ô¨Ånd in the python/tools/ directory. If everything has been installed correctly, you should be
able to use it within Python like this:
from radmc3d_tools.simpleread import *
Examples of data Ô¨Åles you can read:
d = read_dustdens()
d = read_dusttemp()
d = read_image()
d = read_spectrum()
d = read_dustkappa()
d = read_gastemp()
d = read_gasvelocity()
d = read_molnumdens('co')
d = read_mollevelpop('co')
Of course each one only if the corresponding Ô¨Åle is present. Note that ‚Äòco‚Äô is just an example molecule. In all these
reading functions, except the ones for images and spectra, the reading function automatically calls:
129

radmc3d, Release 2.0
grid = read_grid()
which reads the information about the spatial grid. This is then put inside the d object like this: d.grid.
Here is an example of how you can plot the data (let us take the examples/run_simple_1/ model, after we ran
radmc3d mctherm and radmc3d image incl 60 phi 30 lambda 1000):
import matplotlib.pyplot as plt
from radmc3d_tools.simpleread import *
import radmc3d_tools.natconst as nc
tm = read_dusttemp()
plt.figure()
plt.plot(tm.grid.x/nc.au,tm.dusttemp[:,16,16])
plt.xlabel('x [au]')
plt.ylabel('T [K]')
im = read_image()
plt.figure()
plt.imshow(im.image[:,:,0],vmax=3e-14)
plt.show()
Important: These reading functions are rather basic. At the moment, no binary Ô¨Åle support is included (though this
may change), no AMR octree grids can be read, and several other limitations. For more sophisticated Python tools,
use the radmc3dPy library.
12.2 The radmc3dPy library
The radmc3dPy library is a sophisticated Python library that you can use for the in-depth analysis of the output
(or input) Ô¨Åles of RADMC-3D. It supports most in/output formats of RADMC-3D, including octree grids, binary Ô¨Åle
formats etc.
The package is stand-alone, and has its own bitbucket repository:
https://bitbucket.org/at_juhasz/radmc3dpy/
But you can Ô¨Ånd a copy of this package also inside the RADMC-3D package, in the directory python/radmc3dPy/
.
The radmc3dPy package has its own manual, so we will not reiterate it here. Instead, please simply open the html
manual in that package with a browser. The entry Ô¨Åle of that manual is the doc/html/index.html. On a Mac you
can simply type opendoc/html/index.html on the command line when you are in the radmc3dPy directory.
To install radmc3dPy please consult the README Ô¨Åle in the radmc3dPy directory.
Once it is installed, you can use radmc3dPy in Python in the following way:
1. Make sure to start Python 3 using {small ipython ‚Äìmatplotlib} if you start Python from the command line. If
you instead use a Jupyter notebook, make sure that as a Ô¨Årst line you use %matplotlibinline to get the
plots inside the notebook. These are standard Python things, so if you have trouble, ask your python friends or
system manager.
2. Once you are inside Python you can include radmc3dPy using a simple fromradmc3dPyimport*. This
loads a series of radmc3dPy sub-libraries, including analyze, image and several others.
We give here a very concise overview of the radmc3dPy package. Please refer to the above mentioned stand-alone
documentation for more details.
130
Chapter 12. Python analysis tool set

radmc3d, Release 2.0
12.3 Model creation from within radmc3dPy
Several of the example models of the RADMC-3D examples/ directory have been implemented as part of the
radmc3dPy package. This allows you to launch these models straight from within radmc3dPy. But this is merely
optional. You can equally well use the models in the examples/ directory in the RADMC-3D package, and post-
process the results with radmc3dPy.
To use one of the radmc3dPy-internal models, create a directory (e.g. mymodel), go into it, and go into iPython.
Then type fromradmc3dPyimport*. By typing models.getModelNames() you get a list of available mod-
els. Suppose we choose the model ‚Äòppdisk‚Äô, then we would go about like this (for example):
from radmc3dPy import *
analyze.writeDefaultParfile('ppdisk')
setup.problemSetupDust('ppdisk', mdisk='1e-5*ms', gap_rin='[10.0*au]', gap_rout='[40.
Àì‚Üí*au]', gap_drfact='[1e-5]', nz='0')
This example will set up a protoplanetary disk model in 2-D (ùëü, ùúÉ), with a gap between 10 and 40 au. You can now
run RADMC-3D to compute the dust temperature structure, by calling (on the Linux shell):
radmc3d mctherm
An image can be created with (again on the Lunix shell):
radmc3d image lambda 1000 incl 60
And the image can be displayed (in Python) by
import matplotlib.pyplot as plt
from matplotlib import cm
from radmc3dPy import *
im=image.readImage()
image.plotImage(im,vmax=3e-3,au=True,cmap=cm.gist_heat)
12.4 Diagnostic tools in radmc3dPy
No matter whether you use the radmc3dPy-internal model set, or you create your own model setup, you can use
the extensive tool set inside radmc3dPy to analyze the model itself, and the results of RADMC-3D calculations. In
everything below, we assume that you use fromradmc3dPyimport* beforehand.
12.4.1 Read the amr_grid.inp Ô¨Åle
Use grid=analyze.readGrid() to read the information about the spatial and wavelength grid.
12.3. Model creation from within radmc3dPy
131

radmc3d, Release 2.0
12.4.2 Read all the spatial data
Using data=analyze.readData() you read the entire spatial structure of the model: The dust density, dust
temperature, velocity etc.
12.4.3 Read the image.out Ô¨Åle
Using im=image.readImage() you read the image.out Ô¨Åle created by RADMC-3D (if you call radmc3d for
creating an image). You can use the image.plotImage() function to display the image with the proper axes and
color bar.
12.4.4 Read the spectrum.out Ô¨Åle
Any spectrum you create (a Ô¨Åle called spectrum.out can be read using s=analyze.readSpectrum().
132
Chapter 12. Python analysis tool set

CHAPTER
THIRTEEN
ANALYSIS TOOLS INSIDE OF RADMC3D
There are also some special purpose features in the Fortran-90 radmc3d code that can be useful for analyzing complex
AMR-gridded models.
13.1 Making a regularly-spaced datacube (‚Äòsubbox‚Äô) of AMR-based
models
Because handling AMR-based models in Python or other data analysis packages can be rather cumbersome, we de-
cided that it would be useful to create the possibility in radmc3d to generate 1-D, 2-D or 3-D regularly spaced
‚Äòcut-outs‚Äô or ‚Äòsub-boxes‚Äô (whatever you want to call them) of any variable of the model.
13.1.1 Creating and reading a subbox
You can call radmc3d directly from the shell asking it to make the subbox. Here is an example:
./radmc3d subbox_dust_temperature subbox_nxyz 64 64 64 subbox_xyz01 -2.d15 2.d15 -2.
Àì‚Üíd15 2.d15 -2.d15 2.d15
An example for the level populations would be:
./radmc3d subbox_levelpop subbox_nxyz 64 64 64 subbox_xyz01 -2.d15 2.d15 -2.d15 2.d15
Àì‚Üí-2.d15 2.d15
Note about subbox for level populations: By default all level populations will be written out. However, if you would
add the subbox_levelpop keyword in a call to RADMC-3D for making an image or spectrum, then it will only
write out the level populations that have been used for that image. Example:
./radmc3d image lambda 2600 subbox_levelpop subbox_nxyz 64 64 64 subbox_xyz01 -2.d15
Àì‚Üí2.d15 -2.d15 2.d15 -2.d15 2.d15
would give a much smaller 'levelpop_co_subbox.out' Ô¨Åle, because only the Ô¨Årst two levels are included
(remember that ùúÜ= 2600 ùúáfor more information on how RADMC-3D automatically selects a subset of levels for
storage in the global array (and thus also for writing out to Ô¨Åle).
133

radmc3d, Release 2.0
13.1.2 Format of the subbox output Ô¨Åles
All the Ô¨Åles produced by the subbox method have the following format:
iformat
<=== Typically 2 at present
nx ny nz nv
<=== Box of nx*ny*nz cells, each with nv
Àì‚Üívalues
x0 x1 y0 y1 z0 z1
<=== The x, y and z boundaries of the box
phi1 theta phi2
<=== Three rotation angles of the box
<=== Empty line
1 2 3 4 ....
<=== Identifications of the nv values
<=== Empty line
data[ix=1,iy=1,iz=1,iv=1]
data[ix=2,iy=1,iz=1,iv=1]
.
.
data[ix=nx,iy=1,iz=1,iv=1]
data[ix=1,iy=2,iz=1,iv=1]
.
.
.
data[ix=nx,iy=ny,iz=nz,iv=1]
<=== Empty line between components
data[ix=1,iy=1,iz=1,iv=2]
.
.
data[ix=nx,iy=ny,iz=nz,iv=2]
<=== Empty line between components
.
.
.
<=== Empty line between components
data[ix=1,iy=1,iz=1,iv=nv]
.
.
data[ix=nx,iy=ny,iz=nz,iv=nv]
and they are always in ascii format. For a subbox of the level populations the identiÔ¨Åcation numbers are the levels.
For instance, if only the populations of levels 4 and 8 are in this Ô¨Åle, then nv=2 and the line with the identiÔ¨Åcation
numbers will be 48. For all other quantities (dust density, dust temperature) this line of identiÔ¨Åcation numbers is
simply 123 etc.
13.2 Alternative to subbox: arbitrary sampling of AMR-based models
For some purposes it is useful to sample values of various quantities at arbitrary positions in the grid. The idea is very
much like the subbox method of Section Making a regularly-spaced datacube (‚Äòsubbox‚Äô) of AMR-based models, but
instead of a regular subbox grid the user provides a list of 3-D points where he/she wants to sample the variables of
the model. Here is how to do this. First you must produce a Ô¨Åle containing the list of 3-D positions. The Ô¨Åle is called
sample_points.inp and is an ascii Ô¨Åle that looks as follows:
iformat
<=== Typically 1 at present
npt
<=== Nr of 3-D sampling points
xpt[1]
ypt[1]
zpt[1]
<=== 3-D coordinates of point 1
xpt[2]
ypt[2]
zpt[2]
<=== 3-D coordinates of point 2
xpt[3]
ypt[3]
zpt[3]
<=== 3-D coordinates of point 3
(continues on next page)
134
Chapter 13. Analysis tools inside of radmc3d

radmc3d, Release 2.0
(continued from previous page)
...
...
An example for the case in which you want to sample at just one point:
1
1
1.49d13
4.02d14
1.03d12
If you want to let RADMC-3D do the sampling of the dust density and temperature, type (after you have calculated
the temperature using radmc3dmctherm):
radmc3d sample-dustdens sample-dusttemp
You can also do the dust temperature calculation and the sampling in one go:
radmc3d mctherm sample-dustdens sample-dusttemp
You can also do only sample-dusttemp or only sample-dustdens.
The output is written to Ô¨Åles
dust_density_sample.out resp.dust_temperature_sample.out. The format of these Ô¨Åles is (take
dust density as example):
iformat
<=== Typically 2 at present
npt
nv
<=== Nr of point and size of datavector
<=== Empty line
1 2 3 4 ....
<=== Identifications of the nv values
<=== Empty line
dustdensity[ipt=1,iv=1]
dustdensity[ipt=2,iv=1]
...
dustdensity[ipt=npt,iv=1]
<=== Empty line between components
dustdensity[ipt=1,iv=2]
...
dustdensity[ipt=npt,iv=2]
<=== Empty line between components
...
<=== Empty line between components
dustdensity[ipt=npt,iv=nv]
where nv is in this case the nr of species of dust and iv=``ispecies``.
For a sample of the level populations the identiÔ¨Åcation numbers are the levels. For instance, if only the populations
of levels 4 and 8 are in this Ô¨Åle, then nv=2 and the line with the identiÔ¨Åcation numbers will be 48. For all other
quantities (dust density, dust temperature) this line of identiÔ¨Åcation numbers is simply 123 etc.
Later we will add other possible arrays to sample (at the moment it is only dust density, dust temperature and level
populations). But you can also implement this yourself. Search in the following Ô¨Åles for the following parts to add
your own sampling:
‚Ä¢ In rtglobal_module.f90:
Search for do_sample_dustdens and add your own variable, e.g.
o_sample_myvariable.
‚Ä¢ In main.f90: Search for do_sample_dustdens and you will Ô¨Ånd all places where you have to add your
own stuff, i.e. where you will have to add statements like if(do_sample_myvariable) or where you
have to set do_sample_myvariable=.true. or reset do_sample_myvariable=.false. etc.
That should do it.
13.2. Alternative to subbox: arbitrary sampling of AMR-based models
135

radmc3d, Release 2.0
136
Chapter 13. Analysis tools inside of radmc3d

CHAPTER
FOURTEEN
VISUALIZATION WITH VTK TOOLS (E.G. PARAVIEW OR VISIT)
Since 3-D models can be very hard to visualize, and since RADMC-3D is not made for quick rendering, it can be very
useful to make use of a number of freely available 3-D rendering tools, for example:
‚Ä¢ Paraview www.paraview.org
‚Ä¢ VisIt visit.llnl.gov
RADMC-3D can create data Ô¨Åles for use with these tools. The Ô¨Åle format is VTK (Visual Tool Kit), which is a simple
ascii Ô¨Åle format which is used by various programs. Those tools are not only useful for visualizing the 3-D structure
of the model, but also for visualizing the structure of the grid which can be, when using AMR, rather complex.
The Ô¨Åle that RADMC-3D writes is called model.vtk. You should be able to open it directly from within e.g.
paraview. Figures Fig. 14.1 and Fig. 14.2 gives an example of how you can analyze a complex geometry with AMR
reÔ¨Ånement with Paraview. The Ô¨Åle {em always} includes the information about the grid. In addition you can also
make RADMC-3D add scalar Ô¨Åelds or vector Ô¨Åelds.
To create a VTK Ô¨Åle for viewing the grid only, type:
radmc3d vtk_grid
To create a VTK Ô¨Åle for viewing the gas density (this Ô¨Åle then also includes the grid of course) type:
radmc3d vtk_gas_density
Since density can span a huge range, the 10-log of the density (in units of gram/cm3) is written instead. For the gas
temperature:
radmc3d vtk_gas_temperature
which is written in Kelvin (and linearly, not log). For the dust density of dust species 1:
radmc3d vtk_dust_density 1
and for dust species 2:
radmc3d vtk_dust_density 2
Also these densities are 10-log. RADMC-3D typically computes the dust temperature using a Monte Carlo approach.
By typing
radmc3d vtk_dust_temperature 1
RADMC-3D will try to read the dust temperature from the Ô¨Åle dust_temperature.dat (if this Ô¨Åle has been
created earlier by a radmc3d mctherm call) and then create the VTK Ô¨Åle. You can also let RADMC-3D compute
the temperature directly and write it out to VTK right afterward:
137

radmc3d, Release 2.0
radmc3d mctherm vtk_dust_temperature 1
If you are doing line transfer you may wish to visualize the number density of the molecules (or atoms):
radmc3d vtk_molspec 1
(for molecular species 1). This number density (in cm‚àí3) is also written in 10-log form. You may also wish to
visualize the polulations of level 1 (ground state) of molecule 2:
radmc3d vtk_levelpop 2 1
The gas velocity Ô¨Åeld can be written to VTK Ô¨Åle by
radmc3d vtk_velocity
This is a vector Ô¨Åeld.
Note: The VTK mode works for 3-D cartesian and 3-D spherical coordinates (thanks, Attila Juhasz, for the 3-D
spherical mode!).
Fig. 14.1: Example of image created with Paraview, using the VTK output of RADMC-3D. The model shown here is
a warped disk model by Katherine Rosenfeld, in 3-D cartesian coordinates with oct-tree AMR reÔ¨Ånement.
138
Chapter 14. Visualization with VTK tools (e.g. Paraview or VisIt)

radmc3d, Release 2.0
Fig. 14.2: Example of image created with Paraview, using the VTK output of RADMC-3D. The model shown here
is a warped disk model by Attila Juhasz, in 3-D spherical coordinates with separable reÔ¨Ånement, but without AMR
reÔ¨Ånement. The model is kept low-resolution on purpose, to show the grid structure better.
139

radmc3d, Release 2.0
140
Chapter 14. Visualization with VTK tools (e.g. Paraview or VisIt)

CHAPTER
FIFTEEN
TIPS, TRICKS AND PROBLEM HUNTING
15.1 Tips and tricks
RADMC-3D is a large software package, and the user will in all likelihood not understand all its internal workings. In
this section we will discuss some issues that might be useful to know when you do modeling.
‚Ä¢ Things that can drastically slow down ray-tracing:
When you create images or spectra, radmc3d will perform a ray-tracing calculation. You may notice that
sometimes this can be very fast, but for other problems it can be very slow. This is because, depending on
which physics is switched on, different ray-tracing strategies must be followed. For instance, if you use a dust
opacity without scattering opacity (or if you switch dust scattering off by setting scattering_mode_max to
0 in the radmc3d.inp Ô¨Åle), and you make dust continuum images, or make SEDs, this may go very rapidly:
less than a minute on a modern computer for grids of 256x256x256. However, when you include scattering,
it may go slower. Why is that? That is because at each wavelength radmc3d will now have to make a quick
Monte Carlo scattering model to compute the dust scattering source function. This costs time. And it will cost
more time if you have nphot_scat set to a high value in the radmc3d.inp Ô¨Åle, although it will create
better images. Furthermore, if you also include gas lines using the simple LTE or simple LVG methods, then
things become even slower, because each wavelength channel image is done after each other, and each time
all the populations of the molecular levels have to be re-computed. If dust scattering would be switched off
(which is for some wavelength domains presumably not a bad approximation; in particular for the millimeter
domain), then no scattering Monte Carlo runs have to be done for each wavelength. Then the code can ray-
trace all wavelength simultaneously: each ray is traced only once, for all wavelength simultaneously. Then the
LTE/LVG level populations have to be computed only once at each location along the ray. So if you use dust
and lines simultaneously, it can be advantageous for speed if you can afford to switch off the dust scattering,
for instance, if you model sub-millimeter lines in regions with dust grains smaller than 10 micron or so. If you
must include scattering, but your model is not so big that you may get memory limitation problems, then you
may also try the fast LTE or fast LVG modes: in those modes the level populations are pre-computed before the
ray-tracing starts, which saves time. But that may require much memory.
15.2 Bug hunting
Although we of course hope that radmc3d will not run into troubles or crash, it is nevertheless possible that it will.
There are several ways by which one can hunt for bugs, and we list here a few obvious ones:
‚Ä¢ In principle the Makefile should make sure that all dependencies of all modules are correct, so that the most
dependent modules are compiled last. But during the further development of the code perhaps this may be not
100% guaranteed. So try do makeclean followed by make (or makeinstall) to assure a clean make.
‚Ä¢ In the Makefile you can add (or uncomment) the line BCHECK=-fbounds-check, if you use gfortran.
Find the array boundary check switch on your own compiler if it is not gfortran.
141

radmc3d, Release 2.0
‚Ä¢ Make sure that in the main.f90 code the variable debug_check_all is set to 1. This will do some on-the-
Ô¨Çy checks in the code.
15.3 Some tips for avoiding troubles and for making good models
Here is a set of tips that we recommend you to follow, in order to avoid troubles with the code and to make sure that
the models you make are OK. This list is far from complete! It will be updated as we continue to develop the code.
1. Make a separate directory for each model. This avoids confusion with the many input and output Ô¨Åles from the
models.
2. When experimenting: regularly keep models that work, and continue experimenting with a fresh model direc-
tory. If things go wrong later, you can always fall back on an older model that did work well.
3. Keep model directories within a parent directory of the code, just like it is currently organized. This ensures that
each model is always associated to the version of the code for which it was developed. If you update to a new
version of the code, it is recommended to simply copy the models you want to continue with to the new code
directory (and edit the SRC variable in the Makefile if you use the techniques described in Section Making
special-purpose modiÔ¨Åed versions of RADMC-3D (optional) and Chapter Modifying RADMC-3D: Internal setup
and user-speciÔ¨Åed radiative processes).
4. If you make a new model, try to start with as clean a directory as possible. This avoids that you accidently have a
old Ô¨Åles hanging around, their presence of which may cause troubles in your new model. So if you make a model
update, make a new directory and then copy only the Ô¨Åles that are necesary (for instance, problem_setup.
py, dustkappa_silicate.inp, Makefile and other necessary Ô¨Åles). One way of doing this easily is to
write a little perl script or csh script that does this for you.
5. In the example model directories there is always a Makefile present, even if no local *.f90 Ô¨Åles are present.
The idea is that by typing {small make cleanall} you can safely clean up the model directory and restore it to
pre-model status. This can be useful for safely cleaning model directories so that only the model setup Ô¨Åles
remain there. It may save enormous amounts of disk space. But of course, it means that if you revisit the model
later, you would need to redo the Monte Carlo simulations again, for instance. It is a matter of choice between
speed of access to results on the one hand and disk space on the other hand.
6. If you use LVG or escape probability to compute the level populations of molecules, please be aware that you
must include all levels that could be populated, not only the levels belonging to the line you are interested in.
15.4 Careful: Things that might go wrong
In principle RADMC-3D should be Ô¨Åne-tuned such that it produced reliable results in most circumstances. But radia-
tive transfer modeling, like all kinds of modeling, is not an entirely trivial issue. Extreme circumstances can lead to
wrong results, if the user is not careful in doing various sanity checks. This section gives some tips that you, the user,
may wish to do to check that the results are ok. This is not an exhaustive list! So please remain creative yourself in
coming up with good tests and checks.
1. Too low number of photon packages for thermal Monte Carlo
If the number of photon packages for the thermal Monte Carlo simulation (Section The thermal Monte Carlo
simulation: computing the dust temperature) is too low, the dust temperatures are going to be very noisy. Some
cells may even have temperature zero. This may not only lead to noisy images and spectra, but also simply
wrong results. However, deep inside optically thick clouds (or protoplanetary disks) it will be hard to avoid this
problem. Since those regions are very deep below the ùúè= 1 surface, it might not be always too critical in that
case. A bit of experimenting might be necessary.
142
Chapter 15. Tips, tricks and problem hunting

radmc3d, Release 2.0
2. Too low number of photon packages for scattering
When making images or spectra in which dust scattering is important, the scattered light emissivity is computed
by a quick Monte Carlo simulation before the ray-tracing (see Section Scattered light in images and spectra:
The ‚ÄòScattering Monte Carlo‚Äô computation). This requires the setting of the number of photon packages used
for this (the variable nphot_scat for images and equivalently nphot_spec for spectra, both can be set in
the radmc3d.inp Ô¨Åle). If you see too much ‚Äònoise‚Äô in your scattering image, you can improve this by setting
nphot_scat to a larger value (default = 100000). If your spectrum contains too much noise, try setting
nphot_spec to a larger value (default = 10000).
3. Too optically thick cells at the surface or inner edge
You may want to experiment with grid resolution and reÔ¨Ånement. Strictly speaking the transition from optically
thin to optically thick, as seen both by the radiation entering the object and by the observer, has to occur over
more than one cell. That is for very optically thick models, one may need to introduce grid reÔ¨Ånement in various
regions. As an example: an optically thick protoplanetary disk may have an extremely sharp thin-thick transition
near the inner edge. To get the spectra and images right, it is important that these regions are resolved by the grid
(note: once well inside the optically thick interior, it is no longer necessary to resolve individual optical mean
free paths, thankfully). It should be said that in practice it is often impossible to do this in full strictness. But
you may want to at least experiment a bit with reÔ¨Åning the grid (using either ‚Äòseparable reÔ¨Ånement‚Äô, see Section
Separable grid reÔ¨Ånement in spherical coordinates (important!), or AMR reÔ¨Ånement, see Section Oct-tree-style
AMR grid). An example how wrong things can go at the inner edge of a protoplanetary disk, if the inner cells
are not assured to be optically thin through grid reÔ¨Ånement (and possibly additionally a bit of smoothing of the
density proÔ¨Åle too) is given in Fig. Fig. 15.1.
Fig. 15.1: Example of what can go wrong with radiative transfer if the inner cells of a model are optically thick (i.e.if
no grid reÔ¨Ånement is used, see Section Separable grid reÔ¨Ånement in spherical coordinates (important!)). Shown here
are scattered light images at ùúÜ= 0.7ùúáDelta R/R=0.04`. Left image: the inner cells are marginally optically thin
‚àÜùúè‚âÉ1, creating a bright inner ring, as is expected. Right image: ten times higher optical depth, making the inner
cells optically thick with roughly ‚àÜùúè‚âÉ10, resulting in a wrong image in which the emission near the midplane is
strongly reduced. The reason for that is that the scattering source function, due to photons scattering at the inner 10%
of the inner cell, is diluted over the entire cell, making the scattered light brighness 10x lower than it should be.
4. Model does not Ô¨Åt onto the grid (or onto the reÔ¨Åned part of the grid)
The grid must be large enough to contain the entire ùúèùúÜ= 1 surface of a model at all relevant wavelengths. If you
use grid reÔ¨Ånement, the same is true for the ùúèùúÜ= 1 surface being within the reÔ¨Ånened part of the grid. This is not
trivial! If you, for instance, import a 3-D hydrodynamic model into RADMC-3D, then it is a common problem
15.4. Careful: Things that might go wrong
143

radmc3d, Release 2.0
that the ùúèùúÜ= 1 surface ‚Äòwants‚Äô to be outside of the grid (or outside of the higher-resolution part of the ùúÉ-grid
if you use separable grid reÔ¨Ånement: see Fig. Ô¨Åg-spher-sep-ref). For example: if you make a * hydrodynamic*
model of a protoplanetary disk in ùëÖ, Œò and Œ¶ coordinates, you typically want to model only the lower 2 pressure
scale heights of the disk, since that contains 99.5% of the mass of the disk. However, for radiative transfer this
may not be enough, since if the disk has an optical depth of ùúè= 103, the optically thin surface layer is less
than 0.1% of the disk mass, meaning that you need to model the lower 3 (not 2!) pressure scale heights. Simply
inserting the hydrodynamics model with the Ô¨Årst 2 scale heights would lead to an artiÔ¨Åcal cut-off of the disk. In
other words, the real ùúèùúÜ= 1 surface ‚Äòwants‚Äô to be outside of the grid (or outside of the reÔ¨Åned part of the grid).
This leads to wrong results.
15.5 Common technical problems and how to Ô¨Åx them
When using a complex code such as RADMC-3D there are many ways you might encounter a problem. Here is a list
of common issues and tips how to Ô¨Åx them.
1. After updating RADMC-3D to a new version, some setups don‚Äôt work anymore.
This problem can be due to several things:
‚Ä¢ When your model makes a local radmc3d executable (see Section Making special-purpose modiÔ¨Åed
versions of RADMC-3D (optional)), for instance when you use the userdef_module.f90 to set up
the model, then you may need to edit the SRC variable in the Makefile again to point to the new code
directory, and type makeclean followed by make.
‚Ä¢ Are you sure to have recompiled radmc3d again and installed it (by going in src/ and typing
makeinstall)?
‚Ä¢ Try going back to the old version and recheck that the model works well there. If that works, and the above
tricks don‚Äôt Ô¨Åx the problem, then it may be a bug. Please contact the author.
2. After updating RADMC-3D to a new version: the new features are not present/working.
Maybe again the Makefile issue above.
3. After updating RADMC-3D to a new version: model based on userdef_module fails to compile
If you switch to a new version of the code and try to ‚Äòmake‚Äô an earlier model that uses the userdef_module.f90,
it might sometimes happen that the compilation fails because some subroutine userdef_*** is not known
(here *** is some name). Presumably what happened is that a new user-deÔ¨Åned functionality has been added to
the code, and the corresponding subroutine userdef_*** has been added to the userdef_module.f90.
If, however, in your own userdef_module.f90 this subroutine is not yet built in, then the compiler can‚Äôt
Ô¨Ånd this subroutine and complains. Solution: just add a dummy subroutine to your userdef_module.f90
with that name (have a look at the userdef_module.f90 in the src/ directory). Then recompile and it
should now work.
4. While reading an input Ô¨Åle, RADMC-3D says ‚ÄòFortran runtime error: End of Ô¨Åle‚Äô
This can of course have many reasons. Some common mistakes are:
‚Ä¢ In amr_grid.inp you may have speciÔ¨Åed the coordinates of the nx*ny*nz grid centers instead of
(nx+1)*(ny+1)*(nz+1) grid cell interfaces.
‚Ä¢ You may have no line feed at the end of one of the ascii input Ô¨Åles. Some fortran compilers can read only
lines that are ofÔ¨Åcially ended with a return or line feed. Solution: Just write an empty line at the end of
such a Ô¨Åle.
5. My changes to the main code do not take effect
Did you type, in the src/ directory, the full makeinstall? If you type just make, then the code is compiled
but not installed as the default code.
144
Chapter 15. Tips, tricks and problem hunting

radmc3d, Release 2.0
6. My userdef_module.f90 stuff does not work
If you run radmc3d with own userdeÔ¨Åned stuff, then you must make sure to run the right executable. Just
typing radmc3d in the shell might cause you to run the standard compilation instead of your special-purpose
one. Try typing ./radmc3d instead, which forces the shell to use the local executable.
7. When I make images from the command line, they take very long
If you make images with radmc3dimage (plus some keywords) from the command line, the default is that
a Ô¨Çux-conserving method of ray-tracing is used, which is called recursive sub-pixeling (see Section The issue
of Ô¨Çux conservation: recursive sub-pixeling). You can make an image without sub-pixeling with the command-
line option nofluxcons. That goes much faster, and also gives nice images, but the Ô¨Çux (the integral over the
entire image) may not be accurate.
8. My line channel maps (images) look bad
If you have a model with non-zero gas velocities, and if these gas velocities have cell-to-cell differences that
are larger than or equal to the intrinsic (thermal+microturbulent) line width, then the ray-tracing will not be able
to pick up signals from intermediate velocities. In other words, because of the discrete gridding of the model,
only discrete velocities are present, which can cause numerical problems. There are two possible solutions
to this problem. One is the wavelength band method described in Section Heads-up: In reality wavelength
are actually wavelength bands. But a more systematic method is the ‚Äòdoppler catching‚Äô method described in
Section Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô (which can be combined with the wavelength
band method of Section Heads-up: In reality wavelength are actually wavelength bands to make it even more
perfect).
9. My line spectra look somewhat noisy
If you include dust continuum scattering (Section More about scattering of photons off dust grains) then the
ray-tracer will perform a scattering Monte Carlo simulation at each wavelength. If you look at lines where
dust scattering is still a strong source of emission, and if nphot_scat (Section Scattered light in images and
spectra: The ‚ÄòScattering Monte Carlo‚Äô computation) is set to a low value, then the different random walks of
the photon packages in each wavelength channel may cause slightly different resulting Ô¨Çuxes, hence the noise.
10. My dust continuum images look very noisy/streaky: many ‚Äòlines‚Äô in the image
There are two possible reasons:
1. Photon noise in the thermal Monte Carlo run: If you have too few photon packages for the thermal Monte
Carlo computation (see Chapter Dust continuum radiative transfer), then the dust temperatures are simply
not well computed. This may give these effects. You must then increase nphot in the radmc3d.inp
Ô¨Åle to increase the photon statistics for the thermal Monte Carlo run.
2. Photon noise in the scattering Monte Carlo run: If you are making an image at a wavelength at which
the disk is not emitting much thermal radiation, then what you will see in the image is scattered light.
RADMC-3D makes a special Monte Carlo run for scattered light before each image. This Monte Carlo
run has its own variable for setting the number of photon packages: nphot_scat. If this value is set
too low, then you can see individual ‚Äòphoton‚Äô-trajectories in the image, making the image look bad. It
is important to note that this can only be remedied by increasing nphot_scat (in the radmc3d.inp
Ô¨Åle, see Section Scattered light in images and spectra: The ‚ÄòScattering Monte Carlo‚Äô computation), not
by setting nphot (which is the number of photon packages for the thermal Monte Carlo computation).
Please also read Section Single-scattering vs. multiple-scattering for a detailed discussion about the effects
of multiple scattering and the possibility of it leading to streaks in the images.
However, it might also mean that something is wrong with the setup. A few common setup-errors that could
cause these issues are:
‚Ä¢ Accidently created a way too massive object. Let us discuss this with an example of a protoplanetary
disk: suppose you created, in spherical coordinates, not a protoplanetary disk with ùëÄdisk = 0.01 ùëÄ‚äô
but accidently one with ùëÄdisk = 10 ùëÄ‚äô. In such a case a lot of things will go wrong. First of all the
15.5. Common technical problems and how to Ô¨Åx them
145

radmc3d, Release 2.0
inner edge of the disk will almost certainly behave strangely (see Fig. Example of what can go wrong
with radiative transfer if the inner cells of a model are optically thick (i.e.if no grid reÔ¨Ånement is used,
see Section sec-separable-reÔ¨Ånement). Shown here are scattered light images at \lambda=0.7\muDelta
R/R=0.04`. Left image: the inner cells are marginally optically thin \Delta\tau\simeq 1, creating a bright
inner ring, as is expected. Right image: ten times higher optical depth, making the inner cells optically
thick with roughly \Delta\tau\simeq 10, resulting in a wrong image in which the emission near the midplane
is strongly reduced. The reason for that is that the scattering source function, due to photons scattering
at the inner 10% of the inner cell, is diluted over the entire cell, making the scattered light brighness 10x
lower than it should be.). Secondly, the surface of the disk will almost certainly be cut-off in the way
decribed in Section Careful: Things that might go wrong, in which case the surface of the disk will be
hardly illuminated by the star, because the disk surface is then exactly conical (i.e.starlight will not be able
to impinge on the surface). This will lead to very low photon statistics at the surface.
146
Chapter 15. Tips, tricks and problem hunting

CHAPTER
SIXTEEN
MAIN INPUT AND OUTPUT FILES OF RADMC-3D
RADMC-3D is written in fortran-90. It is written in such a way that the user prepares input Ô¨Åles (ending in .inp) for
the program and then calls radmc3d with some command-line options. The program then reads the input Ô¨Åles, and
based on the command-line options will perform a certain calculation, and Ô¨Ånally outputs the results to output Ô¨Åles
(ending in .out) or intermediate Ô¨Åles (ending in .dat) which need further processing. In principle the user therefore
needs to compile the program only once, and can then use the executable from that point onward. In this chapter we
will describe the various input/output and intermediate Ô¨Åles and their formats. Just for clarity: the Python routines in
the python/ directory are only meant to make it easier for the user to prepare the .inp Ô¨Åles, and to make sense of
the .out and .dat Ô¨Åles. They are not part of the main code radmc3d.
A few comments on RADMC-3D input and output Ô¨Åles:
‚Ä¢ Most (though not all) Ô¨Åles start with a format number. This number simply keeps track of the version of the
way the information is stored the Ô¨Åle. The idea is that if new versions of RADMC-3D come out in the future, it
would be good to have the possibility that new information is added to the Ô¨Åles. The format number is there to
tell RADMC-3D whether a Ô¨Åle is the new version or still an older version.
‚Ä¢ RADMC-3D has four types of I/O Ô¨Åles:
1. Files ending with .inp or .binp are input Ô¨Åles that allow the user to specify to RADMC-3D which
problem to solve.
2. Files ending with .dat or .bdatare intermediate Ô¨Åles that are typically created by RADMC-3D itself,
but can also be read by RADMC-3D for further processing. For instance, the dust temperature is computed
by the Monte Carlo method, but can also be read in later for ray-tracing.
3. Files ending with .out or .bout are Ô¨Ånal products of RADMC-3D, such as an image or spectrum.
4. File ending with .info are small Ô¨Åles containing some numbers that are useful to better interpret the
output Ô¨Åles of RADMC-3D. They are typically not very important for every-day use.
‚Ä¢ For many of the I/O Ô¨Åles RADMC-3D can read and write formatted (i.e. text style: ascii) Ô¨Åles, or binary Ô¨Åles
(i.e. C-style unformatted). This is speciÔ¨Åed by the Ô¨Åle extension. See Chapter Binary I/O Ô¨Åles for more details.
16.1 INPUT: radmc3d.inp
The radmc3d.inp Ô¨Åle is a namelist Ô¨Åle with the main settings for RADMC-3D. The namelist is not a standard
Fortran namelist style, but a simple name = value list. If a name is not speciÔ¨Åed, the default values are taken. So if
the radmc3d.inp Ô¨Åle is empty, then all settings are standard. Note that some of these settings can be overwritten by
command-line options! Here is a non-exhaustive list of the variables that can be set.
‚Ä¢ incl_dust (default: depends on which input Ô¨Åles are present)
147

radmc3d, Release 2.0
Normally RADMC-3D will recognize automatically whether dust continuum emission, absorption and scatter-
ing must be included: if e.g. a Ô¨Åle called dustopac.inp is present, it assumes that the dust must be included.
But with this Ô¨Çag you can explicitly tell RADMC-3D whether it must be included (1) or not (0).
‚Ä¢ incl_lines (default: depends on which input Ô¨Åles are present)
Normally RADMC-3D will recognize automatically whether line emission and absorption must be included: if
e.g. a Ô¨Åle called lines.inp is present, it assumes that molecular/atomic lines must be included. But with this
Ô¨Çag you can explicitly tell RADMC-3D whether it must be included (1) or not (0).
‚Ä¢ nphot or nphot_therm (default: 100000)
The number of photon packages used for the thermal Monte Carlo simulation.
‚Ä¢ nphot_scat (default: 100000)
The number of photon packages for the scattering Monte Carlo simulations, done before image-rendering.
‚Ä¢ nphot_spec (default: 10000)
The number of photon packages for the scattering Monte Carlo simulations, done during spectrum-calculation.
This is actually the same functionality as for nphot_scat, but it is used (and only used) for the spectrum and
SED calculations. The reason to have a separate value for this is that for spectra you may not need as many
photon packages as for imaging, because you anyway integrate over the images. Many of the annoying ‚Äòstripe
noise‚Äô in images when using insufÔ¨Åciently large nphot_scat will cancel each other out in the Ô¨Çux calculation.
So nphot_spec is usually taken smaller than nphot_scat.
‚Ä¢ nphot_mono (default: 100000)
The number of photon packages for the Monte Carlo simulations for the mcmono calculation (see Section
Special-purpose feature: Computing the local radiation Ô¨Åeld).
‚Ä¢ iseed (default: -17933201) [Fine-tuning only]
A starting value of the random seed for the Monte Carlo simulation.
‚Ä¢ ifast (default: 0) [Fine-tuning only]
By setting this to 1 or 2 you will get a faster Monte Carlo simulation, at the cost of being less accurate.
‚Ä¢ enthres (default: 0.01) [Fine-tuning only]
This is the fraction by which the energy in each cell may increase before the temperature is recalculated in the
Monte Carlo simulation. The smaller this value, the more accurate the thermal Monte Carlo simulation, but the
more computationally costly. 0.01 has proven to be Ô¨Åne.
‚Ä¢ itempdecoup (default: 1)
If set to 0, then the temperatures of all coexisting dust species are always forced to be the same. If 1, then each
dust species is thermally independent of the other.
‚Ä¢ istar_sphere (default: 0)
If 0 (=default), then all stars are treated as point-sources. If 1, then all stars are treated as Ô¨Ånite-size spheres.
This mode is more accurate and more realistic, but the applications are a bit more restricted. Such Ô¨Ånite-size
stars are (for technical reasons) not always allowed anywhere in the model. But for problems of circumstellar
disks and envelopes in spherical coordinates, it is recommended to set this to 1. Typically, if a star is outside the
grid (in spherical coordinates this can also be at the origin of the coordinate system, as long as the inner radius
of the coordinate system is larger than the stellar radius!) the use of the Ô¨Ånite-size star mode is always possible.
But if the star is on the grid, there are technical limitations.
‚Ä¢ ntemp (default: 1000) [Fine-tuning only]
148
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
The temperatures are determined in the Monte Carlo method using tabulated pre-computed integrals. This saves
time. This is the number of temperatures for which this is precalculated. The temperatures are sampled in a
logarithmic way, i.e. log(temp) is linearly equally spaced between log(temp0) and log(temp1), see below.
‚Ä¢ temp0 (default: 0.01) [Fine-tuning only]
The lowest pre-calculated temperature.
‚Ä¢ temp1 (default: 1e5) [Fine-tuning only]
The highest pre-calculated temperature.
‚Ä¢ scattering_mode_max
When radmc3d reads the dust opacity Ô¨Åles it checks if one or more of the opacity Ô¨Åles has scattering opacity
included. If yes, the scattering_mode will automatically be set to 1. It will also check if one or more
includes anisotropic scattering. If yes, the scattering_mode will automatically be set to 2. But the user
may nevertheless want to exclude anisotropic scattering or exclude scattering altogether (for instance for testing
purposes, or if the user knows from experience that the scattering or anisotropic nature of scattering is not
important for the problem at hand). Rather than editing the opacity Ô¨Åles to remove the scattering and/or Henyey-
Greenstein ùëî-factors, you can limit the value that radmc3d is allowed to make scattering_mode by setting
the variable scattering_mode_max. If you set scattering_mode_max=0 then no matter what opacity
Ô¨Åles you have, scattering will not be treated. If you set scattering_mode_max=1, then no matter what
opacity Ô¨Åles you have, scattering will be treated in an isotropic way.
‚Ä¢ unformatted (Obsolete)
‚Ä¢ rto_style (default=1)
This determines whether the output of space-dependent data will be in ASCII form (rto_style=1), f77-
unformatted form (rto_style=2, obsolete) or binary form (rto_style=3). See Chapter Binary I/O Ô¨Åles
for details.
‚Ä¢ camera_tracemode (default: 1)
If camera_tracemode=-1, the images that are rendered by RADMC-3D will instead by the column depth
traced along each ray. If camera_tracemode=-2, the images that are rendered by RADMC-3D will instead
by the continuum optical depth traced along each ray. By default camera_tracemode=1, which is the normal
mode, where real images are being created.
‚Ä¢ camera_nrrefine (default: 100)
For images: to assure that Ô¨Çux is correctly sampled, the image pixels will not just be rendered one ray per pixel.
Instead, if necessary, a pixel will spawn 2x2 sub-pixels recursively (each of which can split again into 2x2 until
the required resolution is obtained) so as to assure that the Ô¨Çux in each pixel is correct. camera_nrrefine
tells how deep RADMC-3D is allowed to recursively reÔ¨Åne. 100 is therefore effectively inÔ¨Ånite. Putting this to
0 means that you go back to 1 ray per pixel, which is fast, but may seriously misrepresent the Ô¨Çux in each pixel.
See Section The issue of Ô¨Çux conservation: recursive sub-pixeling for more details.
‚Ä¢ camera_refine_criterion (default: 1.0) [Fine-tuning only]
Setting this value to smaller than 1 means that you reÔ¨Åne the recursive pixeling until a tighter criterion is met.
The smaller this value, the more accurate the Ô¨Çuxes in each pixel, but the longer it takes to render. See Section
The issue of Ô¨Çux conservation: recursive sub-pixeling for more details.
‚Ä¢ camera_incl_stars (default: 1)
If 0, then only the interstellar/circumstellar material is rendered for the images and spectra. If 1, then also the
stellar Ô¨Çux is included in the spectra and images.
‚Ä¢ camera_starsphere_nrpix (default: 20) [Fine-tuning only]
16.1. INPUT: radmc3d.inp
149

radmc3d, Release 2.0
For rectangular images and for the spectra/SEDs (but not for spectra/SEDs created with circular pixel arrange-
ments, see Section Circular images), this number tells RADMC-3D how much it should do sub-pixeling over
the stellar surface. That is: 20 means that at least 20 sub-pixels are assured over the stellar surface. This is
important for Ô¨Çux conservation (see Section The issue of Ô¨Çux conservation: recursive sub-pixeling).
‚Ä¢ camera_spher_cavity_relres (default: 0.05) [Fine-tuning only]
Determines the size of sub-pixels inside the inner grid radius of spherical coordinates.
‚Ä¢ camera_localobs_projection (default: 1)
(Only for local observer mode) The type of projection on the sphere of observation.
‚Ä¢ camera_min_dangle (default 0.05) [Fine-tuning only]
Fine-tuning parameter for recursive subpixeling (see Section The solution: recursive sub-pixeling), for spherical
coordinates, assuring that not too Ô¨Åne subpixeling would slow down the rendering of images or spectra too
much.
‚Ä¢ camera_max_dangle (default 0.3) [Fine-tuning only]
Fine-tuning parameter for recursive subpixeling (see Section The solution: recursive sub-pixeling), for spherical
coordinates, preventing that too coarse subpixeling would reduce the accuracy.
‚Ä¢ camera_min_dr (default 0.003) [Fine-tuning only]
Fine-tuning parameter for recursive subpixeling, for spherical coordinates, assuring that not too Ô¨Åne subpixeling
would slow down the rendering of images or spectra too much.
‚Ä¢ camera_diagnostics_subpix (default: 0)
Setting this to 1 forces RADMC-3D to write out a Ô¨Åle called subpixeling_diagnostics.out which
contains four columns, for respectivly: px,py,pdx,pdy, i.e. the pixel position and its size. This is for
all pixels, including the sub-pixels created during the recursive subpixeling procedure (Section The solution:
recursive sub-pixeling). This allows the user to Ô¨Ånd out if the recursive subpixeling went well or if certain areas
were over/under-resolved. This is really only meant as a diagnostic.
‚Ä¢ camera_secondorder (default: 0)
If set to 1, RADMC-3D will interpolate all emission/absorption quantities to the cell corners, and then use
a second order integration routine with bilinear interpolation of the source terms to integrate the ray-tracing
formal transfer equations. See Section Second order ray-tracing (Important information!) for more information
about the second order integration: It is recommended to read it!
‚Ä¢ camera_interpol_jnu (default: 0) [Fine-tuning only]
Fine-tuning parameter for ray-tracing, only used for when second order integration is done (i.e.
if
camera_secondorder=1). If 0 (default), then the source function ùëÜùúàis the one that is interpolated on
the grid, while if 1, then the emissivity ùëóùúàis the one that is interpolated on the grid. The differences are minimal,
but if strange results appear (when using second order integration) then you may want to experiment a bit with
this parameter.
‚Ä¢ mc_weighted_photons (default: 1) [Fine-tuning only]
If mc_weighted_photons=1 (default) then in Monte Carlo simulations not all photon packages will have
the same energy (see Section More about photon packages in the Monte Carlo simulations). The energy will be
weighted such that each star or emission mechanism will emit, on average, the same number of photon packages.
As an example: If you have a stellar binary consisting of an O-star surrounded by a Brown Dwarf, but the Brown
Dwarf is surrounded by a disk, then although the O star is much brighter than the O-star, the very inner regions
of the Brown Dwarf disk is still predominantly heated by the Brown Dwarf stellar surface, because it is much
closer to that material. If you do not have weighted photon packages, then statistically the Brown Dwarf would
emit perhaps 1 or 2 photon packages, which makes the statistics of the energy balance in the inner disk very
bad. By mc_weighted_photons=1 both the Brown Dwarf and the O-star will each emit the same number
150
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
of photon packages; just the energy of the photon packages emitted by the Brown Dwarf are much less energetic
than those from the O-star. This now assures a good photon statistics everywhere.
‚Ä¢ optimized_motion (default: 0) [Fine-tuning only]
If optimized_motion is set to 1, then RADMC-3D will try to calculate the photon motion inside cells more
efÔ¨Åciently. This may save computational time, but since it is still not very well tested, please use this mode with
great care! It is always safer not to use this mode.
‚Ä¢ lines_mode (default: 1)
This mode determines how the level populations for line transfer are computed. The default is 1, which means:
Local Thermodynamic Equilibrium (LTE). For other modes, please consult Chapter Line radiative transfer.
‚Ä¢ lines_maxdoppler (default: 0.3) [Fine-tuning only]
If the doppler catching mode is used (see Section Preventing doppler jumps: The ‚Äòdoppler catching method‚Äô),
this parameter tells how Ô¨Åne RADMC-3D must sample along the ray, in units of the doppler width, when a line
is doppler-shifting along the wavelength-of-sight.
‚Ä¢ lines_partition_ntempint (default 1000) [Fine-tuning only]
Number of temperature sampling points for the internally calculated partition function for molecular/atomic
lines.
‚Ä¢ lines_partition_temp0 (default 0.1) [Fine-tuning only]
Smallest temperature sampling point for the internally calculated partition function for molecular/atomic lines.
‚Ä¢ lines_partition_temp1 (default 1E5) [Fine-tuning only]
Largest temperature sampling point for the internally calculated partition function for molecular/atomic lines.
‚Ä¢ lines_show_pictograms (default 0)
If 1, then print a pictogram of the levels of the molecules/atoms.
‚Ä¢ tgas_eq_tdust (default: 0)
By setting tgas_eq_tdust=1 you tell radmc3d to simply read the dust_temperature.inp Ô¨Åle and
then equate the gas temperature to the dust temperature. If multiple dust species are present, only the Ô¨Årst species
will be used.
‚Ä¢ subbox_nx,subbox_ny,subbox_nz,subbox_x0,subbox_x1,subbox_y0,subbox_y1,
subbox_z0,subbox_z1
Parameters specifying the subbox size for the subbox extraction. See Section Making a regularly-spaced dat-
acube (‚Äòsubbox‚Äô) of AMR-based models for details.
16.2 INPUT (required): amr_grid.inp
This is the Ô¨Åle that speciÔ¨Åes what the spatial grid of the model looks like. See Chapter More information about the
gridding. This Ô¨Åle is essential, because most other .inp and .dat Ô¨Åles are simple lists of numbers which do not
contain any information about the grid. All information about the grid is contained in the amr_grid.inp, also for
non-AMR regular grids. Note that in the future we will also allow for unstructured grids. The corresponding grid Ô¨Åles
will then be named differently.
There are three possible AMR grid styles:
‚Ä¢ Regular grid: No mesh reÔ¨Ånement. This is grid style 0.
‚Ä¢ Oct-tree-style AMR (‚ÄòAdaptive Mesh ReÔ¨Ånement‚Äô, although for now it is not really ‚Äòadaptive‚Äô). This is grid
style 1.
16.2. INPUT (required): amr_grid.inp
151

radmc3d, Release 2.0
‚Ä¢ Layer-style AMR. This is grid style 10.
16.2.1 Regular grid
For a regular grid, without grid reÔ¨Ånement, the amr_grid.inp looks like:
iformat
<=== Typically 1 at present
0
<=== Grid style (regular = 0)
coordsystem
gridinfo
incl_x
incl_y
incl_z
nx
ny
nz
xi[1]
xi[2]
xi[3]
........
xi[nx+1]
yi[1]
yi[2]
yi[3]
........
yi[ny+1]
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
The meaning of the entries are:
‚Ä¢ iformat: The format number, at present 1. For unformatted Ô¨Åles this must be 4-byte integer.
‚Ä¢ coordsystem: If coordsystem < 100 the coordinate system is cartesian. If 100 <= coordsystem
< 200 the coordinate system is spherical (polar). If 200 <= coordsystem < 300 the coordinate system
is cylindrical. For unformatted Ô¨Åles this must be 4-byte integer.
‚Ä¢ gridinfo: If gridinfo==1 there will be abundant grid information written into this Ô¨Åle, possibly useful
for post-processing routines. Typically this is redundant information, so it is advised to set gridinfo=0 to
save disk space. In the following we will assume that gridinfo=0. For unformatted Ô¨Åles this must be 4-byte
integer.
‚Ä¢ incl_x,incl_y,incl_z: These are either 0 or 1. If 0 then this dimension is not active (so upon grid
reÔ¨Ånement no reÔ¨Ånement in this dimension is done). If 1 this dimension is fully active, even if the number of
base grid cells in this direction is just 1. Upon reÔ¨Ånement the cell will also be splitted in this dimension. For
unformatted Ô¨Åles these numbers must be 4-byte integer.
‚Ä¢ nx,ny,nz: These are the number of grid cells on the base grid in each of these dimensions. For unformatted
Ô¨Åles these numbers must be 4-byte integer.
‚Ä¢ xi[1]...xi[nx+1]: The edges of the cells of the base grid in x-direction. For nx grid cells we have nx+1
cell walls, hence nx+1 cell wall positions. For unformatted Ô¨Åles these numbers must be 8-byte reals (=double
precision).
‚Ä¢ yi[1]...yi[ny+1]: Same as above, but now for y-direction.
‚Ä¢ zi[1]...zi[nz+1]: Same as above, but now for z-direction.
Example of a simple 2x2x2 regular grid in cartesian coordinates:
1
0
1
0
1
1
1
2
2
2
-1.
0. 1.
-1.
0. 1.
-1.
0. 1.
152
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
16.2.2 Oct-tree-style AMR grid
For a grid with oct-tree style grid reÔ¨Ånement (see Section Oct-tree Adaptive Mesh ReÔ¨Ånement), the amr_grid.inp
looks like:
iformat
<=== Typically 1 at present
1
<=== Grid style (1 = Oct-tree)
coordsystem
gridinfo
incl_x
incl_y
incl_z
nx
ny
nz
levelmax
nleafsmax
nbranchmax
<=== This line only if grid style == 1
xi[1]
xi[2]
xi[3]
........
xi[nx+1]
yi[1]
yi[2]
yi[3]
........
yi[ny+1]
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
...
...
The keywords have the same meaning as before, but in addition we have:
‚Ä¢ (0/1): NOTE: Only for amrstyle==1. These are numbers that are either 0 or 1. If 0, this means the current
cell is a leaf (= a cell that is not reÔ¨Åned and is therefore a ‚Äòtrue‚Äô cell). If 1, the current cell is a branch with 2 (in
1-D), 4 (in 2-D) or 8 (in 3-D) daughter cells. In that case the next (0/1) numbers are for these daughter cells.
In other words, we immediately recursively follow the tree. The order in which this happens is logical. In 3-D
the Ô¨Årst daughter cell is (1,1,1), then (2,1,1), then (1,2,1), then (2,2,1), then (1,1,2), then (2,1,2), then (1,2,2)
and Ô¨Ånally (2,2,2), where the Ô¨Årst entry represents the x-direction, the second the y-direction and the third the
z-direction. If one or more of the daughter cells is also reÔ¨Åned (i.e. has a value 1), then Ô¨Årst this sub-tree is
followed before continuing with the rest of the daughter cells. If we Ô¨Ånally return to the base grid at some point,
the next (0/1) number is for the next base grid cell (again possibly going into this tree if the value is 1). The order
in which the base grid is scanned in this way is from 1 to nx in the innermost loop, from 1 to ny in the middle
loop and from 1 to nz in the outermost loop. For unformatted Ô¨Åles these numbers must be 4-byte integers, one
record per number.
Example of a simple 1x1x1 grid which is reÔ¨Åned into 2x2x2 and for which the (1,2,1) cell is reÔ¨Åned again in 2x2x2:
1
1
1
0
1
1
1
1
1
1
10 100 100
-1.
1.
-1.
1.
-1.
1.
1
0
0
(continues on next page)
16.2. INPUT (required): amr_grid.inp
153

radmc3d, Release 2.0
(continued from previous page)
1
0
0
0
0
0
0
0
0
0
0
0
0
0
16.2.3 Layer-style AMR grid
For a grid with layer-style grid reÔ¨Ånement (see Section Layered Adaptive Mesh ReÔ¨Ånement), the amr_grid.inp
looks like:
iformat
<=== Typically 1 at present
10
<=== Grid style (10 = layer-style)
coordsystem
gridinfo
incl_x
incl_y
incl_z
nx
ny
nz
nrlevels
nrlayers
<=== This line only if grid style == 10
xi[1]
xi[2]
xi[3]
........
xi[nx+1]
yi[1]
yi[2]
yi[3]
........
yi[ny+1]
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
parentid
ix
iy
iz
nx
ny
nz
parentid
ix
iy
iz
nx
ny
nz
parentid
ix
iy
iz
nx
ny
nz
parentid
ix
iy
iz
nx
ny
nz
.
.
.
The keywords have the same meaning as before, but in addition we have:
‚Ä¢ nrlevels: How many levels you plan to go, where nrlevels==0 means no reÔ¨Ånement, nrlevels==1
means one level of reÔ¨Ånement (factor of 2 in resolution), etc.
‚Ä¢ nrlayers: How many layers do you have, with nrlayers==0 means no reÔ¨Ånement, nrlayers==1 means
one layer of reÔ¨Ånement (factor of 2 in resolution), etc.
‚Ä¢ parentid: (For each layer) The parent layer for this layer. parentid==0 means parent is base grid. First
layer has id==1.
‚Ä¢ ix,iy,iz: (For each layer) The location in the parent layer where the current layer starts.
‚Ä¢ nx,ny,nz: (For each layer) The size of the layer as measured in units of the the parent layer. So the actual size
of the current layer will be (in 3-D): 2*nx,2*ny,2*nz. In 2-D, with only the x- and y- dimensions active,
we have a size of 2*nx,2*ny with of course size 1 in z-direction.
As you can see, this is a much easier and more compact way to specify mesh reÔ¨Ånement. But it is also less ‚Äòadaptive‚Äô, as
it is always organized in square/cubic patches. But it is much easier to handle for the user than full oct-tree reÔ¨Ånement.
154
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
Note that this layer-style reÔ¨Ånement is in fact, internally, translated into the oct-tree reÔ¨Ånement. But you, as the user,
will not notice any of that. The code will input and output entirely in layer style.
NOTE: The layers must be specify in increasing reÔ¨Ånement level! So the Ô¨Årst layer (layer 1) must have the base grid
(layer 0) as its parent. The second layer can have either the base grid (layer 0) or the Ô¨Årst layer (layer 1) as parent, etc.
In other words: the parent layer must always already have been speciÔ¨Åed before.
Example of a simple 2-D 4x4 grid which has a reÔ¨Ånement patch in the middle of again 4x4 cells (=2x2 on the parent
grid), and a patch of 2x2 (=1x1 on the parent grid) starting in the upper left corner:
1
100
1
0
1
1
0
4
4
1
1
2
-2. -1. 0. 1. 2.
-2. -1. 0. 1. 2.
-0.5 0.5
0
2
2
1
2
2
1
0
1
1
1
1
1
1
This has just one level of reÔ¨Ånement, but two patches at level 1.
Anothe example: two recursive layers. Again start with a 2-D 4x4 grid, now reÔ¨Åne it in the middle with again a 4x4
sub-grid (=2x2 on the parent grid = layer 0) and then again a deeper layer of 4x4 (=2x2 on the parent grid = layer 1)
this time starting in the corner:
1
100
1
0
1
1
0
4
4
1
2
2
-2. -1. 0. 1. 2.
-2. -1. 0. 1. 2.
-0.5 0.5
0
2
2
1
2
2
1
1
1
1
1
2
2
1
Note that with this layer-style grid, the input data will have to be speÔ¨Åcied layer-by-layer: Ô¨Årst the base grid, then the
Ô¨Årst layer, then the second etc. This is worked out in detail for dust_density.inp in Section INPUT (required
for dust transfer): dust_density.inp. This will include redundant data, because you specify the data on the entire base
grid, also the cells that later will be replaced by a layer. Same is true for any layer that has sub-layers. The data that
is speciÔ¨Åed in these regions will be simply ignored. But for simplicity we do still require it to be present, so that
irrespective of the deeper layers, the data in any layer (including the base grid, which is layer number 0) is simply
organized as a simple data cube. This redundancy makes the input and output Ô¨Åles larger than strictly necessary, but
it is much easier to handle as each layer is a datacube. For memory/hardisk-friendly storage you must use the oct-tree
reÔ¨Ånement instead. The layers are meant to make the AMR much more accessible, but are somewhat more memory
consuming.
16.2. INPUT (required): amr_grid.inp
155

radmc3d, Release 2.0
16.3 INPUT (required for dust transfer): dust_density.inp
This is the Ô¨Åle that contains the dust densities. It is merely a list of numbers. Their association to grid cells is via the
Ô¨Åle amr_grid.inp (see Chapter Binary I/O Ô¨Åles for the binary version of this Ô¨Åle, which is more compact). Each
dust species will have its own density distribution, completely independently of the others. That means that at each
position in space several dust species can exist, and the density of these can be fully freely speciÔ¨Åed. The structure of
this Ô¨Åle is as follows. For formatted style (dust_density.inp):
iformat
<=== Typically 1 at present
nrcells
nrspec
density[1,ispec=1]
..
density[nrcells,ispec=1]
density[1,ispec=2]
..
..
..
density[nrcells,ispec=nrspec]
Here nrspec is the number of independent dust species densities that will be given here. It can be 1 or larger. If it is
1, then of course the density[1,ispec=2] and following lines are not present in the Ô¨Åle. The nrcells is the
number of cells. For different kinds of grids this can have different meaning. Moreover, for different kinds of grids the
order in which the density values are given is also different. So let us now immediately make the following distinction
(See Chapter More information about the gridding on the different kinds of grids):
‚Ä¢ For regular grid and oct-tree AMR grids:
The value of nrcells denotes the number of true cells, excluding the cells that are in fact the parents of 2x2x2
subcells; i.e. the sum of the volumes of all true cells (=leafs) adds up to the volume of the total grid). The order
of these numbers is always the same ‚Äòimmediate recursive subtree entry‚Äô as in the amr_grid.inp (Section
INPUT (required): amr_grid.inp).
‚Ä¢ For layer-style AMR grids:
The value of nrcells denotes the number of values that are speciÔ¨Åed. This is generally a bit more than the
true number of cells speciÔ¨Åed in the oct-tree style AMR (see above). In the layer-style AMR mode you specify
the dust density (or any other value) Ô¨Årst at all cells of the base grid (whether a cell is reÔ¨Åned or not does not
matter), the at all cells of the Ô¨Årst layer, then the second layer etc. Each layer is a regular (sub-)grid, so the order
of the values is simply the standard order (same as for regular grids). This means, however, that the values of
the density in the regular grid cells that are replaced by a layer are therefore redundant. See Section On the
‚Äòsuccessively regular‚Äô kind of data storage, and its slight redundancy for a discussion of this redundancy. The
main advantage of this layer-style grid reÔ¨Ånement is that the input and output always takes place on regular
grids and subgrids (=layers). This is much easier to handle than the complexities of the oct-tree AMR.
16.3.1 Example: dust_density.inp for a regular grid
Now let us look at an example of a dust_density.inp Ô¨Åle, starting with one for the simpliÔ¨Åed case of a regular
3-D grid (see Sections Regular grid and Regular grids):
iformat
<=== Typically 1 at present
nrcells
nrspec
density[1,1,1,ispec=1]
density[2,1,1,ispec=1]
(continues on next page)
156
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
..
density[nx,1,1,ispec=1]
density[1,2,1,ispec=1]
..
..
density[nz,ny,nz,ispec=1]
density[1,1,1,ispec=2]
..
..
..
density[nz,ny,nz,ispec=nrspec]
8
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
yc[2]
1
2
3
4
5
7
9
10
11
12
6
Fig. 16.1: Example of a regular 2-D grid with nx=4 and ny=3 (as Fig. Fig. 9.1), with the order of the cells shown as
numbers in the cells.
16.3.2 Example: dust_density.inp for an oct-tree reÔ¨Åned grid
For the case when you have an oct-tree reÔ¨Åned grid (see Sections Oct-tree-style AMR grid and Oct-tree Adaptive Mesh
ReÔ¨Ånement), the order of the numbers is the same as the order of the cells as speciÔ¨Åed in the amr_grid.(u)inp
Ô¨Åle (Section INPUT (required): amr_grid.inp). Let us take the example of a simple 1x1x1 grid which is reÔ¨Åned into
2x2x2 and for which the (1,2,1) cell is reÔ¨Åned again in 2x2x2 (this is exactly the same example as shown in Section
Oct-tree-style AMR grid, and for which the amr_grid.inp is given in that section). Let us also assume that we
have only one dust species. Then the dust_density.inp Ô¨Åle would be:
iformat
<=== Typically 1 at present
15
<=== 2x2x2 - 1 + 2x2x2 = 15
1
<=== Let us take just one dust spec
density[1,1,1]
<=== This is the first base grid cell
(continues on next page)
16.3. INPUT (required for dust transfer): dust_density.inp
157

radmc3d, Release 2.0
(continued from previous page)
density[2,1,1]
density[1,2,1;1,1,1]
<=== This is the first refined cell
density[1,2,1;2,1,1]
density[1,2,1;1,2,1]
density[1,2,1;1,2,1]
density[1,2,1;1,1,2]
density[1,2,1;2,1,2]
density[1,2,1;1,2,2]
density[1,2,1;1,2,2]
<=== This is the last refined cell
density[2,2,1]
density[1,1,2]
density[2,1,2]
density[1,2,2]
density[2,2,2]
<=== This is the last base grid cell
A more complex example is shown in Fig. Example of a 2-D grid with oct-tree reÔ¨Ånement (as Fig. Ô¨Åg-oct-tree-amr)
with the order of the cells shown as numbers in the cells.. An unformatted version is also available, in the standard
way (see above).
yc[2]
1
2
5
6
3
4
7
8
9
10
11
12
13
14
15
16
17
18
19
20 21
22 23
26 27
28 29
24
25
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
49
47 48
50
51
52
53
54
55
56
57
58
59
60
61
62
63
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
Fig. 16.2: Example of a 2-D grid with oct-tree reÔ¨Ånement (as Fig. Example of a 2-D grid with oct-tree reÔ¨Ånement.
The base grid has nx=4 and ny=3. Three levels of reÔ¨Ånement are added to this base grid.) with the order of the cells
shown as numbers in the cells.
158
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
16.3.3 Example: dust_density.inp for a layer-style reÔ¨Åned grid
For the case when you have an layer-style reÔ¨Åned grid (see Sections Layer-style AMR grid and Layered Adaptive Mesh
ReÔ¨Ånement) you specify the density in a series of regular boxes (=layers). The Ô¨Årst box is the base grid, the second
the Ô¨Årst layer, the third the second layer etc. The value nrcells now tells the combined sizes of the all the boxes.
If we take the second example of Section Layer-style AMR grid: a simple 2-D 4x4 grid which has a reÔ¨Ånement patch
(=layer) in the middle of again 4x4 cells, and again one patch of 4x4 this time, however, starting in the upper left
corner (see the amr_grid.inp Ô¨Åle given in Section Layer-style AMR grid), then the dust_density.inp Ô¨Åle
has the following form:
iformat
<=== Typically 1 at present
48
<=== 4x4 + 4x4 + 4x4 = 48
1
<=== Let us take just one dust spec
density[1,1,1,layer=0]
density[2,1,1,layer=0]
density[3,1,1,layer=0]
density[4,1,1,layer=0]
density[1,2,1,layer=0]
density[2,2,1,layer=0]
<=== This a redundant value
density[3,2,1,layer=0]
<=== This a redundant value
density[4,2,1,layer=0]
density[1,3,1,layer=0]
density[2,3,1,layer=0]
<=== This a redundant value
density[3,3,1,layer=0]
<=== This a redundant value
density[4,3,1,layer=0]
density[1,4,1,layer=0]
density[2,4,1,layer=0]
density[3,4,1,layer=0]
density[4,4,1,layer=0]
density[1,1,1,layer=1]
<=== This a redundant value
density[2,1,1,layer=1]
<=== This a redundant value
density[3,1,1,layer=1]
density[4,1,1,layer=1]
density[1,2,1,layer=1]
<=== This a redundant value
density[2,2,1,layer=1]
<=== This a redundant value
density[3,2,1,layer=1]
density[4,2,1,layer=1]
density[1,3,1,layer=1]
density[2,3,1,layer=1]
density[3,3,1,layer=1]
density[4,3,1,layer=1]
density[1,4,1,layer=1]
density[2,4,1,layer=1]
density[3,4,1,layer=1]
density[4,4,1,layer=1]
density[1,1,1,layer=2]
density[2,1,1,layer=2]
density[3,1,1,layer=2]
density[4,1,1,layer=2]
density[1,2,1,layer=2]
density[2,2,1,layer=2]
density[3,2,1,layer=2]
density[4,2,1,layer=2]
density[1,3,1,layer=2]
density[2,3,1,layer=2]
density[3,3,1,layer=2]
density[4,3,1,layer=2]
(continues on next page)
16.3. INPUT (required for dust transfer): dust_density.inp
159

radmc3d, Release 2.0
(continued from previous page)
density[1,4,1,layer=2]
density[2,4,1,layer=2]
density[3,4,1,layer=2]
density[4,4,1,layer=2]
An unformatted version is also available, in the standard way (see above).
It is clear that 48 is now the total number of values to be read, which is 16 values for layer 0 (= base grid), 16 values
for layer 1 and 16 values for layer 2. It is also clear that some values are redundant (they can have any value, does not
matter). But it at least assures that each data block is a simple regular data block, which is easier to handle. Note that
these values (marked as redundant in the above example) must be present in the Ô¨Åle, but they can have any value you
like (typically 0).
Note that if you have multiple species of dust then we will still have 48 as the value of nrcells. The number of
values to be read, if you have 2 dust species, is then simply 2*nrcells = 2*48 = 96.
16.4 INPUT/OUTPUT: dust_temperature.dat
The dust temperature Ô¨Åle is an intermediate result of RADMC-3D and follows from the thermal Monte Carlo simu-
lation. The name of this Ô¨Åle is dust_temperature.dat (see Chapter Binary I/O Ô¨Åles for the binary version of
this Ô¨Åle, which is more compact). It can be used by the user for other purposes (e.g. determination of chemical reac-
tion rates), but also by RADMC-3D itself when making ray-traced images and/or spectra. The user can also produce
his/her own dust_temperature.dat Ô¨Åle (without invoking the Monte Carlo computation) if she/he has her/his
own way of computing the dust temperature.
The structure of this Ô¨Åle is identical to that of dust_density.inp (Section INPUT (required for dust transfer):
dust_density.inp), but with density replaced by temperature. We refer to section INPUT (required for dust transfer):
dust_density.inp for the details.
16.5 INPUT (mostly required): stars.inp
This is the Ô¨Åle that speciÔ¨Åes the number of stars, their positions, radii, and spectra. Stars are sources of netto energy.
For the dust continuum Monte Carlo simulation these are a source of photon packages. This Ô¨Åle exists only in formatted
(ascii) style. Its structure is:
iformat
<=== Put this to 2 !
nstars
nlam
rstar[1]
mstar[1]
xstar[1]
ystar[1]
zstar[1]
.
.
.
.
.
.
.
.
.
.
rstar[nstars
mstar[nstars] xstar[nstars] ystar[nstars] zstar[nstars]
lambda[1]
.
.
lambda[nlam]
flux[1,star=1]
.
.
flux[nlam,star=1]
flux[1,star=2]
.
.
(continues on next page)
160
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
flux[nlam,star=2]
.
.
.
.
flux[nlam,star=nstar]
which is valid only if iformat==2. The meaning of the variables:
‚Ä¢ iformat: The format number, at present better keep it at 2. If you put it to 1, the list of wavelengths (see
below) will instead be a list of frequencies in Herz.
‚Ä¢ nstars: The number of stars you wish to specify.
‚Ä¢ nlam: The number of frequency points for the stellar spectra. At present this must be identical to the num-
ber of walvelength points in the Ô¨Åle wavelength_micron.inp (see Section INPUT (required): wave-
length_micron.inp).
‚Ä¢ rstar[i]: The radius of star ùëñin centimeters.
‚Ä¢ mstar[i]: The mass of star ùëñin grams. This is not important for the current version of RADMC-3D, but may
be in the future.
‚Ä¢ xstar[i]: The x-coordinate of star ùëñin centimeters.
‚Ä¢ ystar[i]: The y-coordinate of star ùëñin centimeters.
‚Ä¢ zstar[i]: The z-coordinate of star ùëñin centimeters.
‚Ä¢ lambda[i]: Wavelength point ùëñ(where ùëñ‚àà[1, nlam]) in microns. This must be identical (!) to the equivalent
point in the Ô¨Åle wavelength_micron.inp (see Section INPUT (required): wavelength_micron.inp). If not,
an error occurs.
‚Ä¢ flux[i,star=n]: The Ô¨Çux ùêπùúàat wavelength point ùëñfor star ùëõin units of erg cm‚àí2, s‚àí1, Hz‚àí1 as seen from
a distance of 1 parsec = 3.08572 √ó 1018 cm (for normalization).
Sometimes it may be sufÔ¨Åcient to assume simple blackbody spectra for these stars. If for any of the stars the Ô¨Årst (!)
Ô¨Çux number (flux[1,star=n]) is negative, then the absolute value of this number is taken to be the blackbody
temperature of the star, and no further values for this star are read. Example:
2
1
100
6.96e10
1.99e33
0.
0.
0.
0.1
.
.
1000.
-5780.
will make one star, at the center of the coordinate system, with one solar radius, one solar mass, on a wavelength grid
ranging from 0.1 micron to 1000 micron (100 wavelength points) and with a blackbody spectrum with a temperature
equal to the effective temperature of the sun.
Note: The position of a star can be both inside and outside of the computational domain.
16.5. INPUT (mostly required): stars.inp
161

radmc3d, Release 2.0
16.6 INPUT (optional): stellarsrc_templates.inp
This is the Ô¨Åle that speciÔ¨Åes the template spectra for the smooth stellar source distributions. See Section Distributions
of zillions of stars. The Ô¨Åle exists only in formatted (ascii) style. Its structure is:
iformat
<=== Put this to 2 !
ntempl
nlam
lambda[1]
.
.
lambda[nlam]
flux[1,templ=1]
.
.
flux[nlam,templ=1]
flux[1,templ=2]
.
.
flux[nlam,templ=2]
.
.
.
.
flux[nlam,templ=ntempl]
which is valid only if iformat==2. The meaning of the variables:
‚Ä¢ iformat: The format number, at present better keep it at 2. If you put it to 1, the list of wavelengths (see
below) will instead be a list of frequencies in Herz.
‚Ä¢ ntempl: The number of stellar templates you wish to specify.
‚Ä¢ nlam: The number of frequency points for the stellar template spectra. At present this must be identical to
the number of walvelength points in the Ô¨Åle wavelength_micron.inp (see Section INPUT (required):
wavelength_micron.inp).
‚Ä¢ lambda[i]: Wavelength point ùëñ(where ùëñ‚àà[1, nlam]) in microns. This must be identical (!) to the equivalent
point in the Ô¨Åle wavelength_micron.inp (see Section INPUT (required): wavelength_micron.inp). If not,
an error occurs.
‚Ä¢ flux[i,templ=n]: The ‚ÄòÔ¨Çux‚Äô at wavelength ùëñfor stellar template ùëõ. The units are somewhat tricky. It is
given in units of erg / sec / Hz / gram-of-star. So multiply this by the density of stars in units of gram-of-star /
cm3, and divide by 4*pi to get the stellar source function in units of erg / src / Hz / cm3 / steradian.
Sometimes it may be sufÔ¨Åcient to assume simple blackbody spectra for these stellar sources. If for any of the stellar
sources the Ô¨Årst (!) Ô¨Çux number (flux[1,templ=n]) is negative, then the absolute value of this number is taken to
be the blackbody temperature of the stellar source, and the following two numbers are interpreted as the stellar radius
and stellar mass respectively. From that, RADMC-3D will then internally compute the stellar template. Example:
2
1
100
0.1
.
.
1000.
-5780.
(continues on next page)
162
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
6.9600000e+10
1.9889200e+33
will tell RADMC-3D that there is just one stellar template, assumed to have a blackbody spectrum with solar effective
temperature. Each star of this template has one solar radius, one solar mass.
16.7 INPUT (optional): stellarsrc_density.inp
This is the Ô¨Åle that contains the smooth stellar source densities. If you have the Ô¨Åle stellarsrc_templates.
inp
speciÔ¨Åed
(see
Section
INPUT
(optional):
stellarsrc_templates.inp)
then
you
must
also
specify
stellarsrc_density.inp (or its binary form, see Chapter Binary I/O Ô¨Åles). The format of this Ô¨Åle is very
similar to dust_density.inp (Section INPUT (required for dust transfer): dust_density.inp), but instead differ-
ent dust species, we have different templates. For the rest we refer to Section INPUT (required for dust transfer):
dust_density.inp for the format. Just replace ispec (the dust species) with itempl (the template).
16.8 INPUT (optional): external_source.inp
This is the Ô¨Åle that speciÔ¨Åes the spectrum and intensity of the external radiation Ô¨Åeld, i.e. the ‚Äòinterstellar radiation
Ô¨Åeld‚Äô (see Section The interstellar radiation Ô¨Åeld: external source of energy). Its structure is:
iformat
<=== Put this to 2 !
nlam
lambda[1]
.
.
lambda[nlam]
Intensity[1]
.
.
Intensity[nlam]
which is valid only if iformat==2. The meaning of the variables:
‚Ä¢ iformat: The format number, at present better keep it at 2. If you put it to 1, the list of wavelengths (see
below) will instead be a list of frequencies in Herz.
‚Ä¢ nlam: The number of frequency points for the stellar template spectra. At present this must be identical to
the number of walvelength points in the Ô¨Åle wavelength_micron.inp (see Section INPUT (required):
wavelength_micron.inp).
‚Ä¢ lambda[i]: Wavelength point ùëñ(where ùëñ‚àà[1, nlam]) in microns. This must be identical (!) to the equivalent
point in the Ô¨Åle wavelength_micron.inp (see Section INPUT (required): wavelength_micron.inp). If not,
an error occurs.
‚Ä¢ Intensity[i]: The intensity of the radiation Ô¨Åeld at wavelength ùëñin units of erg / cm2 / sec / Hz / steradian.
16.7. INPUT (optional): stellarsrc_density.inp
163

radmc3d, Release 2.0
16.9 INPUT (optional): heatsource.inp
This Ô¨Åle, if present (it is an optional Ô¨Åle!), gives the internal heat source of the gas-dust mixture in every cell. For
formatted style (heatsource.inp) the structure of this Ô¨Åle is as follows.:
iformat
<=== Typically 1 at present
nrcells
heatsource[1]
..
heatsource[nrcells]
As with most input/output Ô¨Åles of RADMC-3D, you can also specify the input data in binary form (heatsource.
binp), see Chapter Binary I/O Ô¨Åles.
The physical unit of heatsource is erg cm‚àí3 s‚àí1. The total luminosity of the heat source would then be the sum
over all cells of heatsource times the cell volume.
16.10 INPUT (required): wavelength_micron.inp
This is the Ô¨Åle that sets the discrete wavelength points for the continuum radiative transfer calculations. Note that
this is not the same as the wavelength grid used for e.g. line radiative transfer. See Section INPUT (optional):
camera_wavelength_micron.inp and/or Chapter Line radiative transfer for that. This Ô¨Åle is only in formatted (ascii)
style. It‚Äôs structure is:
nlam
lambda[1]
.
.
lambda[nlam]
where
‚Ä¢ nlam: The number of frequency points for the stellar spectra.
‚Ä¢ lambda[i]: Wavelength point ùëñ(where ùëñ‚àà[1, nlam]) in microns.
The list of wavelengths can be in increasing order or decreasing order, but must be monotonically increas-
ing/decreasing.
IMPORTANT: It is important to keep in mind that the wavelength coverage must include the wavelengths at which
the stellar spectra have most of their energy, and at which the dust cools predominantly. This in practice means that
this should go all the way from 0.1 ùúám to 1000 ùúám, typically logarithmically spaced (i.e. equally spaced in log(ùúÜ)).
A smaller coverage will cause serious problems in the Monte Carlo run and dust temperatures may then be severely
miscalculated. Note that the 0.1 ùúám is OK for stellar temperatures below 10000 K. For higher temperatures a shorter
wavelength lower limit must be used.
164
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
16.11 INPUT (optional): camera_wavelength_micron.inp
The wavelength points in the wavelength_micron.inp Ô¨Åle are the global continuum wavelength points. On
this grid the continuum transfer is done. However, there may be various reasons why the user may want to gen-
erate spectra on a different (usually more Ô¨Ånely spaced) wavelength grid, or make an image at a wavelength that
is not available in the global continuum wavelength grid. Rather than redoing the entire model with a different
wavelength_micron.inp, which may involve a lot of reorganization and recomputation, the user can specify
a Ô¨Åle called camera_wavelength_micron.inp. If this Ô¨Åle exists, it will be read into RADMC-3D, and the user
can now ask RADMC-3D to make images in those wavelength or make a spectrum in those wavelengths.
If the user wants to make images or spectra of a model that involves gas lines (such as atomic lines or molecular
rotational and/or ro-vibrational lines), the use of a camera_wavelength_micron.inp Ô¨Åle allows the user to do
the line+dust transfer (gas lines plus the continuum) on this speciÔ¨Åc wavelength grid. For line transfer there are also
other ways by which the user can specify the wavelength grid (see Chapter Line radiative transfer), and it is left to the
user to choose which method to use.
The structure of the camera_wavelength_micron.inp Ô¨Åle is identical to that of wavelength_micron.
inp (see Section INPUT (required): wavelength_micron.inp).
Note that there are also various other ways by which the user can let RADMC-3D choose wavelength points, many of
which may be even simpler and more preferable than the method described here. See Section Specifying custom-made
sets of wavelength points for the camera.
16.12 INPUT
(required
for
dust
transfer):
dustopac.inp
and
dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp
These Ô¨Åles specify the dust opacities to be used. More than one can be speciÔ¨Åed, meaning that there will be more
than one co-existing dust species. Each of these species will have its own dust density speciÔ¨Åed (see Section INPUT
(required for dust transfer): dust_density.inp). The opacity of each species is speciÔ¨Åed in a separate Ô¨Åle for each
species. The dustopac.inp Ô¨Åle tells which Ô¨Åle to read for each of these species.
16.12.1 The dustopac.inp Ô¨Åle
The Ô¨Åle dustopac.inp has the following structure, where an example of 2 separate dust species is used:
iformat
<=== Put this to 2
nspec
-----------------------------
inputstyle[1]
iquantum[1]
<=== Put to 0 in this example
<name of dust species 1>
-----------------------------
inputstyle[2]
iquantum[2]
<=== Put to 0 in this example
<name of dust species 2>
where:
‚Ä¢ iformat: Currently the format number is 2, and in this manual we always assume it is 2.
‚Ä¢ nspec: The number of dust species that will be loaded.
‚Ä¢ inputstyle[i]: This number tells in which form the dust opacity of dust species ùëñis to be read:
‚Äì 1 Use the dustkappa_*.inp input Ô¨Åle style (see Section The dustkappa_*.inp Ô¨Åles).
16.11. INPUT (optional): camera_wavelength_micron.inp
165

radmc3d, Release 2.0
‚Äì 10 Use the dustkapscatmat_*.inp input Ô¨Åle style (see Section The dustkapscatmat_*.inp Ô¨Åles).
‚Ä¢ iquantum[i]: For normal thermal grains this is 0. If, however, this grain species is supposed to be treated as
a quantum-heated grain, then non-zero values are to be speciÔ¨Åed. NOTE: At the moment the quantum heating is
not yet implemented. Will be done in the future, if users request it. Until then, please set this to 0!
‚Ä¢ <name of dust species i>: This is the name of the dust species (without blank spaces). This name
is then glued to the base name of the opacity Ô¨Åle (see above). For instance, if the name is enstatite, and
inputstyle==1, then the Ô¨Åle to be read is dustkappa_enstatite.inp.
16.12.2 The dustkappa_*.inp Ô¨Åles
If you wish to use dust opacities that include the mass-weighted absorption opacity ùúÖabs, the (optionally) mass-
weighted scattering opacity ùúÖscat, and (optionally) the anisotropy factor ùëîfor scattering, you can do this with a Ô¨Åle
dustkappa_*.inp (set input style to 1 in dustopac.inp, see Section The dustopac.inp Ô¨Åle). With this kind
of opacity input Ô¨Åle, scattering is included either isotropically or using the Henyey-Greenstein function. Using an
opacity Ô¨Åle of this kind does not allow for full realistic scattering phase functions nor for polarization. For that, you
need dustkapscatmat_*.inp Ô¨Åles (see Section The dustkapscatmat_*.inp Ô¨Åles). Please refer to Section More
about scattering of photons off dust grains for more information about how RADMC-3D treats scattering.
If for dust species <name> the inputstyle in the dustopac.inp Ô¨Åle is set to 1, then the Ô¨Åle
dustkappa_<name>.inp is sought and read. The structure of this Ô¨Åle is:
# Any amount of arbitrary
# comment lines that tell which opacity this is.
# Each comment line must start with an # or ; or ! character
iformat
<== This example is for iformat==3
nlam
lambda[1]
kappa_abs[1]
kappa_scat[1]
g[1]
.
.
.
.
.
.
.
.
lambda[nlam]
kappa_abs[nlam]
kappa_scat[nlam]
g[nlam]
The meaning of these entries is:
‚Ä¢ iformat: If iformat==1, then only the lambda and kappa_abs colums are present. In that case the scattering
opacity is assumed to be 0, i.e. a zero albedo is assumed. If iformat==2 also kappa_scat is read (third
column). If iformat==3 (which is what is used in the above example) then also the anisotropy factor ùëîis
included.
‚Ä¢ nlam: The number of wavelength points in this Ô¨Åle. This can be any number, and does not have to be the
same as those of the wavelength_micron.inp. It is typically advisable to have a rather large number of
wavelength points.
‚Ä¢ lambda[i]: The wavelength point ùëñin micron. This does not have to be (and indeed typically is not) the same
as the values in the wavelength_micron.inp Ô¨Åle. Also for each opacity this list of wavelengths can be
different (and can be a different quantity of points).
‚Ä¢ kappa_abs[i]: The absorption opacity ùúÖabs in units of cm2 per gram of dust.
‚Ä¢ kappa_scat[i]: The scattering opacity ùúÖabs in units of cm2 per gram of dust. Note that this column should
only be included if iformat==2 or higher.
‚Ä¢ g[ilam]: The mean scattering angle ‚ü®cos(ùúÉ)‚ü©, often called ùëî. This will be used by RADMC-3D in the Henyey-
Greenstein scattering phase function. Note that this column should only be included if iformat==3 or higher.
Once this Ô¨Åle is read, the opacities will be mapped onto the global wavelength grid of the wavelength_micron.
inp Ô¨Åle. Since this mapping always involve uncertainties and errors, a Ô¨Åle dustkappa_*.inp_used is created
which lists the opacity how it is remapped onto the global wavelength grid. This is only for you as the user, so that you
166
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
can verify what RADMC-3D has internally done. Note that if the upper or lower edges of the wavelength domain of the
dustkappa_*.inp Ô¨Åle is within the domain of the wavelength_micron.inp grid, some extrapolation will
have to be done. At short wavelength this will simply be constant extrapolation while at long wavelength a powerlaw
extrapolation is done. Have a look at the dustkappa_*.inp_used Ô¨Åle to see how RADMC-3D has done this in
your particular case.
16.12.3 The dustkapscatmat_*.inp Ô¨Åles
If you wish to treat scattering in a more realistic way than just the Henyey-Greenstein non-polarized way, then you
must provide RADMC-3D with more information than is present in the dustkappa_xxx.inp Ô¨Åles: RADMC-
3D will need the full scattering M√ºller matrix for all angles of scattering (see e.g. the books by Mishchenko, or by
Bohren & Huffman or by van de Hulst). For randomly oriented particles only 6 of these matrix elements can be
non-zero: ùëç11, ùëç12 = ùëç21, ùëç22, ùëç33, ùëç34 = ‚àíùëç43, ùëç44, where 1,2,3,4 represent the I,Q,U,V Stokes parameters.
Moreover, for randomly oriented particles there is only 1 scattering angle involved: the angle between the incoming
and outgoing radiation of the scattering event. This means that we must give RADMC-3D, (for every wavelength
and for a discrete set of scattering angles) a list of values of these 6 matrix elements. These can be provided in a Ô¨Åle
dustkapscatmat_xxx.inp (set input style to 10 in dustopac.inp, see Section The dustopac.inp Ô¨Åle) which
comes * instead of* the dustkappa_xxx.inp Ô¨Åle. Please refer to Section More about scattering of photons off
dust grains for more information about how RADMC-3D treats scattering.
If for dust species <name> the inputstyle in the dustopac.inp Ô¨Åle is set to 10, then the Ô¨Åle
dustkapscatmat_<name>.inp is sought and read. The structure of this Ô¨Åle is:
# Any amount of arbitrary
# comment lines that tell which opacity this is.
# Each comment line must start with an # or ; or ! character
iformat
<== Format number must be 1
nlam
nang
<== A reasonable value is 181 (e.g. angle = 0.0,1.0,...,180.0)
lambda[1]
kappa_abs[1]
kappa_scat[1]
g[1]
.
.
.
.
.
.
.
.
lambda[nlam]
kappa_abs[nlam]
kappa_scat[nlam]
g[nlam]
angle_in_degrees[1]
.
.
angle_in_degrees[nang]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=1]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=2]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=3]
.
.
.
.
.
.
.
.
.
.
.
.
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=nang]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=2 and iang=1]
.
.
.
.
.
.
.
.
.
.
.
.
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=2 and iang=nang]
....
....
....
(continues on next page)
16.12. INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or
dustkapscatmat_*.inp or dust_optnk_*.inp
167

radmc3d, Release 2.0
(continued from previous page)
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=nlam and iang=1]
.
.
.
.
.
.
.
.
.
.
.
.
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=nlam and iang=nang]
The meaning of these entries is:
‚Ä¢ iformat: For now this value should remain 1.
‚Ä¢ nlam: The number of wavelength points in this Ô¨Åle. This can be any number, and does not have to be the
same as those of the wavelength_micron.inp. It is typically advisable to have a rather large number of
wavelength points.
‚Ä¢ nang: The number of scattering angle sampling points. This should be large enough that a proper integration
over scattering angle can be carried out reliably. A reasonable value is 181, so that (for a regular grid in scattering
angle ùúÉ) you have as scattering angles ùúÉ= 0, 1, 2, ¬∑ ¬∑ ¬∑ , 180 (in degrees). But if you have extremely forward- or
backward peaked scattering, then maybe even 181 is not enough.
‚Ä¢ lambda[ilam]: The wavelength point ilam in micron. This does not have to be (and indeed typically is not)
the same as the values in the wavelength_micron.inp Ô¨Åle. Also for each opacity this list of wavelengths
can be different (and can be a different quantity of points).
‚Ä¢ angle_in_degrees[iang]: The scattering angle sampling point iang in degrees (0 degrees is per-
fect forward scattering, 180 degrees is perfect backscattering). There should be nang such points, where
angle_in_degrees[1] must be 0 and angle_in_degrees[nang] must be 180. In between the angle
grid can be anything, as long as it is monotonic.
‚Ä¢ kappa_abs[ilam]: The absorption opacity ùúÖabs in units of cm2 per gram of dust.
‚Ä¢ kappa_scat[ilam]: The scattering opacity ùúÖscat in units of cm2 per gram of dust. RADMC-3D can (and
will) in fact calculate ùúÖscat from the scattering matrix elements. It will then check (for every wavelength) if that
is the same as the value listed here. If the difference is small, it will simply adjust the kappa_scat[ilam]
value internally to get a perfect match. If it is larger than 1E-4 then it will, in addition to adjusting, make a
warning. if it is larger than 1E-1, it will abort. Note that the fewer angles are used, the worse the match will be
because the integration over angle will be worse.
‚Ä¢ g[ilam]: The mean scattering angle ‚ü®cos(ùúÉ)‚ü©, often called ùëî. RADMC-3D can (and will) in fact calculate ùëî
from the scattering matrix elements. Like with kappa_scat[ilam] it will adjust if the difference is not too
large and it will complain or abort if the difference is larger than some limit.
‚Ä¢ Z_{xx} These are the scattering matrix elements in units of cm2 g‚àí1 ster‚àí1 (i.e. they are angular differential
cross sections). See Section More about scattering of photons off dust grains for more details.
NOTE: This only allows the treatment of randomly oriented particles. RADMC-3D does not, for now, have the
capability of treating scattering off Ô¨Åxed-oriented particles. In fact, for oriented particles it would be impractical to
use dust opacity Ô¨Åles of this kind, since we would then have at least three scattering angles, which would require huge
table. In that case it would be presumably necessary to compute the matrix elements on-the-Ô¨Çy.
Note that the scattering-angle grid of the dustkapscatmat_xxx.inp Ô¨Åles can be chosen non-regular, e.g. to put
a more Ô¨Ånely spaced grid close to ùúÉ= 0 (forward scattering) and ùúÉ= ùúã(backscattering). This can be useful for
large grains and/or short wavelengths, where forward scattering can be extremely strongly peaked. Since multiple
dust species can each have a different scattering ùúÉ-grid, it requires you to give an additional Ô¨Åle to RADMC-3D that
represents the scattering ùúÉ-grid for all grains. This Ô¨Åle is called scattering_angular_grid.inp. The format
is as follows:
1
<=== Format number, must be 1
181
<=== Nr of theta grid points
0.0
<=== First angle (in degrees). Must be 0
(continues on next page)
168
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
1.0
2.0
...
...
...
179.0
180.0
<=== Last angle (in degrees). Must be 180
NOTE: This Ô¨Åle is not compulsory. If it is not given, then RADMC-3D will make its own internal scattering angle grid.
16.13 OUTPUT: spectrum.out
Any spectrum that is made with RADMC-3D will be either called spectrum.out or spectrum_<somename>.
out and will have the following structure:
iformat
<=== For now this is 1
nlam
lambda[1]
flux[1]
.
.
.
.
lambda[nlam]
flux[nlam]
where:
‚Ä¢ iformat: This format number is currently set to 1.
‚Ä¢ nlam: The number of wavelength points in this spectrum. This does not necessarily have to be the same as
those in the wavelength_micron.inp Ô¨Åle. It can be any number.
‚Ä¢ lambda[i]:
Wavelength in micron.
This does not necessarily have to be the same as those in the
wavelength_micron.inp Ô¨Åle. The wavelength grid of a spectrum Ô¨Åle can be completely independent
of all other wavelength grids. For standard SED computations for the continuum typically these will be indeed
the same as those in the wavelength_micron.inp Ô¨Åle. But for line transfer or for spectra based on the
camera_wavelength_micron.inp they are not.
‚Ä¢ flux[i]: Flux in units of erg s‚àí1 cm‚àí2 Hz‚àí1 at this wavelength as measured at a standard distance of 1 parsec
(just as a way of normalization).
NOTE: Maybe in the future a new iformat version will be possible where more telescope information is given in the
spectrum Ô¨Åle.
16.14 OUTPUT: image.out or image_****.out
Any images that are produced by RADMC-3D will be written in a Ô¨Åle called image.out. The Ô¨Åle has the following
structure (for the case without Stokes parameters):
iformat
<=== For now this is 1 (or 2 for local observer mode)
im_nx
im_ny
nlam
pixsize_x
pixsize_y
lambda[1]
......... lambda[nlam+1]
(continues on next page)
16.13. OUTPUT: spectrum.out
169

radmc3d, Release 2.0
(continued from previous page)
image[ix=1,iy=1,img=1]
image[ix=2,iy=1,img=1]
.
.
image[ix=im_nx,iy=1,img=1]
image[ix=1,iy=2,img=1]
.
.
image[ix=im_nx,iy=2,img=1]
image[ix=1,iy=im_ny,img=1]
.
.
.
image[ix=im_nx,iy=im_ny,img=nlam]
image[ix=1,iy=1,img=1]
.
.
.
.
image[ix=im_nx,iy=im_ny,img=nlam]
In most cases the nr of images (nr of wavelengths) is just 1, meaning only one image is written (i.e. the img=2, ....
img=nlam are not there, only the img=1). The meaning of the various entries is:
‚Ä¢ iformat: This format number is currently set to 1
for images from an observer at inÔ¨Ånity (default) and 2 for a local observer. Note: For full-Stokes images it is 3, but
then also the data changes a bit, see below.
‚Ä¢ im_nx,im_ny: The number of pixels in x and in y direction of the image.
‚Ä¢ nlam: The number of images at different wavelengths that
are in this Ô¨Åle. You can make a series of images at different wavelengths in one go, and write them in this Ô¨Åle. The
wavelength belonging to each of these images is listed below. The nlam can be any number from 1 to however large
you want. Mostly one typically just makes an images at one wavelength, meaning nlam=1.
‚Ä¢ pixsize_x,pixsize_y: The size of the pixels in cm (for an observer at inÔ¨Ånity) or radian (for local ob-
server mode). This means that for the observer-at-inÔ¨Ånity mode (default) the size is given in model units (dis-
tance within the 3-D model) and the user can, for any distance, convert this into arcseconds: pixel size in arcsec
= ( pixel size in cm / 1.496E13) / (distance in parsec). The pixel size is the full size from the left of the pixel to
the right of the pixel (or from bottom to top).
‚Ä¢ lambda[i]: Wavelengths in micron belonging to the various images in this Ô¨Åle. In case nlam=1 there will
be here just a single number. Note that this set of wavelengths can be completely independent of all other
wavelength grids.
‚Ä¢ image[ix,iy,img]: Intensity in the image at pixel ix, iy at wavelength img (of the above listed wave-
length points) in units of erg s‚àí1 cm‚àí2 Hz‚àí1 ster‚àí1. Important: The pixels are ordered from left to right (i.e.
increasing ùë•) in the inner loop, and from bottom to top (i.e. increasing ùë¶) in the outer loop.
You can also make images with full Stokes parameters. For this you must have dust opacities that include the full
scattering matrix, and you must add the keyword stokes to the radmc3dimage command on the command-line.
In that case the image.out Ô¨Åle has the following form:
iformat
<=== For Stokes this is 3
im_nx
im_ny
nlam
(continues on next page)
170
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
pixsize_x
pixsize_y
lambda[1]
......... lambda[nlam+1]
image_I[ix=1,iy=1,img=1] image_Q[ix=1,iy=1,img=1] image_U[ix=1,iy=1,img=1] image_
Àì‚ÜíV[ix=1,iy=1,img=1]
.
.
image_I[ix=im_nx,iy=1,img=1] (and so forth for Q U and V)
image_I[ix=1,iy=2,img=1] (and so forth for Q U and V)
.
.
image_I[ix=im_nx,iy=2,img=1] (and so forth for Q U and V)
image_I[ix=1,iy=im_ny,img=1] (and so forth for Q U and V)
.
.
.
image_I[ix=im_nx,iy=im_ny,img=nlam] (and so forth for Q U and V)
image_I[ix=1,iy=1,img=1] (and so forth for Q U and V)
.
.
.
.
image_I[ix=im_nx,iy=im_ny,img=nlam] (and so forth for Q U and V)
That is: instead of 1 number per line we now have 4 numbers per line, which are the four Stokes parameters. Note that
iformat=3 to indicate that we have now all four Stokes parameters in the image.
16.15 INPUT: (minor input Ô¨Åles)
There is a number of lesser important input Ô¨Åles, or input Ô¨Åles that are only read under certain circumstances (for
instance when certain command line options are given). Here they are described.
16.15.1 The color_inus.inp Ô¨Åle (required with comm-line option ‚Äòloadcolor‚Äô)
The Ô¨Åle color_inus.inp will only be read by RADMC-3D if on the command line the option loadcolor or
color is speciÔ¨Åed, and if the main action is image.
iformat
<=== For now this is 1
nlam
ilam[1]
.
.
ilam[nlam]
‚Ä¢ iformat: This format number is currently set to 1.
‚Ä¢ nlam: Number of wavelength indices speciÔ¨Åed here.
‚Ä¢ ilam[i]: The wavelength index for image i (the wavelength index refers to the list of wavelengths in the
wavelength_micron.inp Ô¨Åle.
16.15. INPUT: (minor input Ô¨Åles)
171

radmc3d, Release 2.0
16.15.2 INPUT: aperture_info.inp
If you wish to make spectra with wavelength-dependent collecting area, i.e. aperture (see Section Can one specify
more realistic ‚Äòbeams‚Äô?), then you must prepare the Ô¨Åle aperture_info.inp. Here is its structure:
iformat
<=== For now this is 1
nlam
lambda[1]
rcol_as[1]
.
.
.
.
lambda[nlam]
rcol_as[nlam]
with
‚Ä¢ iformat: This format number is currently set to 1.
‚Ä¢ nlam: Number of wavelength indices speciÔ¨Åed here. This does not have to be the same as the number of
wavelength of a spectrum or the number of wavelengths speciÔ¨Åed in the Ô¨Åle wavelength_micron.inp. It
can be any number.
‚Ä¢ lambda[i]: Wavelength sampling point, in microns. You can use a course grid, as long as the range of
wavelengths is large enough to encompass all wavelengths you may wish to include in spectra.
‚Ä¢ rcol_as[i]: The radius of the circular image mask used for the aperture model, in units of arcsec.
16.16 For developers: some details on the internal workings
There are several input Ô¨Åles that can be quite large. Reading these Ô¨Åles into RADMC-3D memory can take time, so it
is important not to read Ô¨Åles that are not required for the execution of the particular command at hand. For instance,
if a model exists in which both dust and molecular lines are included, but RADMC-3D is called to merely make a
continuum SED (which in RADMC-3D never includes the lines), then it would be a waste of time to let RADMC-3D
read all the gas velocity and temperature data and level population data into memory if they are not used.
To avoid unnecessary reading of large Ô¨Åles the reading of these Ô¨Åles is usually organized in a ‚Äòread when required‚Äô
way. Any subroutine in the code that relies on e.g. line data to be present in memory can simply call the routine
read_lines_all(action) with argument action being 1, i.e.:
call read_lines_all(1)
This routine will check if the data are present: if no, it will read them, if yes, it will return without further action. This
means that you can call read_lines_all(1) as often as you want: the line data will be read once, and only once.
If you look through the code you will therefore Ô¨Ånd that many read_*** routines are called abundantly, whenever
the program wants to make sure that certain data is present. The advantage is then that the programmer does not have
to have a grand strategy for when which data must be read in memory: he/she simply inserts a call to the read routines
for all the data she/he needs at that particular point in the program, (always with action=1), and it will organize itself.
If certain data is nowhere needed, they will not be read.
All these read_*** routines with argument action can also be called with action=2. This will force the routine
to (re-)read these data. But this is rarely needed.
172
Chapter 16. Main input and output Ô¨Åles of RADMC-3D

CHAPTER
SEVENTEEN
BINARY I/O FILES
17.1 Overview
By default all input and output Ô¨Åles of RADMC-3D are in ASCII (i.e.text) form. This makes it easier to verify if
the Ô¨Åles are ok. Also, it is easier to produce Ô¨Åles with the right format and read the output of RADMC-3D. The
disadvantage is that ASCII Ô¨Åles are substantially larger than strictly required to store their information content. For
large models, i.e.models with many grid points, this may lead to unpractically large Ô¨Åles.
RADMC-3D supports a more compact data format: binary data. In this form, a double precision variable occupies just
8 bytes, while a single precision variable occupies just 4 bytes.
Unfortunately, Fortran-90 and Fortran-95 did, for a long time, not support true binary Ô¨Åles. Instead they offered
‚Äòf77-unformatted‚Äô Ô¨Åles, which uses ‚Äòrecords‚Äô, and is harder to read than true binary Ô¨Åles. Recently, however, many
Fortran-90 and Fortran-95 compilers have introduced a true binary format, which is called ‚Äòstreaming access‚Äô. It is,
actually, a Fortran-2003 feature, but has been retroactively implemented into Fortran-90 and Fortran-95. The gfortran
and g95 compilers have it. Also the ifort compiler has it. Presumably others as well.
RADMC-3D offers a binary I/O capability. A Ô¨Åle containing three double precision variables will have a length of
exactly 24 bytes. Files with this format will have extensions such as .binp, .bdat or .bout.
Here is a (presumably incomplete) list of Ô¨Åles that have binary versions:
Name
ascii
binary
dust_density
.inp
.binp
dust_temperature
.inp
.binp
dust_temperature
.dat
.bdat
gas_density
.inp
.binp
gas_temperature
.inp
.binp
electron_numdens
.inp
.binp
ion_numdens
.inp
.binp
levelpop_***
.dat
.bdat
numberdens_***
.inp
.binp
gas_velocity
.inp
.binp
microturbulence
.inp
.binp
stellarsrc_density
.inp
.binp
mean_intensity
.out
.bout
heatsource
.inp
.binp
173

radmc3d, Release 2.0
17.2 How to switch to binary (or back to ascii)
Specifying whether RADMC-3D should use ASCII or binary input is easy: It will simply look which extension each
input Ô¨Åle has, and read it accordingly. If you present RADMC-3D Ô¨Åle input Ô¨Åles with extension .binp, it will read
these Ô¨Åles as binaries.
More tricky is how to tell RADMC-3D to use binary Ô¨Åles on output. By default, RADMC-3D will always write ASCII
style (.out and .dat). However, if you add the following line to the radmc3d.inp Ô¨Åle:
rto_style = 3
it will instead use binary output (.bout and .bdat). And, for completeness (though it is the default anyway), if you
set rto_style=1 RADMC-3D will write output in ASCII form. Note that rto_style = 2 is the old Fortran
unformatted data format, which is deprecated.
For the binary form of output you can also tell RADMC-3D to use single-precision for the main data, to produce
smaller output Ô¨Åles. This is done by adding the following line to the radmc3d.inp Ô¨Åle:
rto_single = 1
By default RADMC-3D will always output double precision in the binary format.
Note: Images are still outputted in ascii even if you have rto_style=3. This is because images are rarely Ô¨Åles of
huge size, and ascii Ô¨Åles are easier to analyze and check. However, sometimes images can be still quite big (e.g.if you
make multi-frequency images). Then it might still be useful to output binary. If you want to also have the images in
binary format, you must set
writeimage_unformatted = 1
in the radmc3d.inp Ô¨Åle, or you add a keyword imageunform.
17.3 Binary I/O Ô¨Åle format of RADMC-3D
The general format of the Ô¨Åles listed in Section Overview is similar to the ASCII versions, just binary this time. There
is one additional number in the binary version: Right after the format number comes an integer that gives the precision
of the main data. This number is either 4, meaning that the main data consists of 4-byte Ô¨Çoating point numbers
(i.e.single precision), or 8, meaning that the main data consists of 8-byte Ô¨Çoating point numbers (i.e.double precision).
Other than that additional number, the order of the data is the same.
The following rules apply:
‚Ä¢ With the exception of the amr_grid.binp Ô¨Åle (see below), all integers are 8-byte integers.
‚Ä¢ Floating point numbers for the main data (i.e.the data that represents the space-dependent variables) are either
4-byte (single) or 8-byte (double) precision numbers. Which of the two is speciÔ¨Åed in the second integer of the
Ô¨Åle (the integer right after the format number, see above).
‚Ä¢ All other Ô¨Çoating point numbers are double precision (i.e.8-byte Ô¨Çoats).
‚Ä¢ For AMR-grids the amr_grid.binp Ô¨Åle contains a huge list of 0 or 1 numbers (see Section Oct-tree-style
AMR grid). Since it is silly to use 8-byte integers for numbers that are either 0 or 1, the numbers in this list are
1-byte integers (bytes).
Example:
According to Section INPUT (required for dust transfer):
dust_density.inp the ASCII Ô¨Åle
dust_density.inp Ô¨Åle has the following format:
174
Chapter 17. Binary I/O Ô¨Åles

radmc3d, Release 2.0
iformat
<=== Typically 1 at present
nrcells
nrspec
density[1,ispec=1]
..
density[nrcells,ispec=1]
density[1,ispec=2]
..
..
..
density[nrcells,ispec=nrspec]
According to the above listed rules the binary Ô¨Åle dust_density.binp Ô¨Åle then has the following format:
<int8:iformat=1>
<int8:precis=8>
<int8:nrcells>
<int8:nrspec>
<dbl8:density[1,ispec=1]>
..
<dbl8:density[nrcells,ispec=1]>
<dbl8:density[1,ispec=2]>
..
..
..
<dbl8:density[nrcells,ispec=nrspec]>
where the <int8:precis=8> means that this is an 8-byte integer that we call ‚Äòprecis‚Äô (the name is irrelevant here),
and it has value 8, and <dbl8:density[1,ispec=1]> means that this is a double-precision number (8-byte
Ô¨Çoat). In other words: the Ô¨Årst 8 bytes of the Ô¨Åle contain the format number (which is 1 at present). The second 8 bytes
contain the number 8, telling that the main data (i.e.the density data) are double precision variables. The third set of
8 bytes gives the number of cells, while the fourth set gives the number of dust species. The data of density starts
as of the 33rd byte of the Ô¨Åle. If you want to compress the Ô¨Åle even further, and you are satisÔ¨Åed with single-precision
data, then the Ô¨Åle would look like:
<int8:iformat=1>
<int8:precis=4>
<int8:nrcells>
<int8:nrspec>
<flt4:density[1,ispec=1]>
..
<flt4:density[nrcells,ispec=1]>
<flt4:density[1,ispec=2]>
..
..
..
<flt4:density[nrcells,ispec=nrspec]>
Another example: According to Section Special-purpose feature: Computing the local radiation Ô¨Åeld RADMC-3D
can compute the mean intensity of radiation at each grid point at a set of pre-deÔ¨Åned frequencies, and write this out to
an ASCII Ô¨Åle called mean_intensity.out. The contents of this Ô¨Åle are:
iformat
<=== Typically 2 at present
nrcells
nfreq
<=== Nr of frequencies
freq_1 freq_2 ... freq_nfreq
<=== List of frequencies in Hz
meanint[1,icell=1]
(continues on next page)
17.3. Binary I/O Ô¨Åle format of RADMC-3D
175

radmc3d, Release 2.0
(continued from previous page)
meanint[1,icell=2]
...
meanint[1,icell=nrcells]
meanint[2,icell=1]
meanint[2,icell=2]
...
meanint[2,icell=nrcells]
...
...
...
meanint[nfreq,icell=1]
meanint[nfreq,icell=2]
...
meanint[nfreq,icell=nrcells]
By setting rto_style=3 in the radmc3d.inp Ô¨Åle, however, RADMC-3D will instead produce a binary Ô¨Åle called
mean_intensity.bout, which has the contents:
<int8:iformat=2>
<int8:precis=8>
<int8:nrcells>
<int8:nfreq>
<dbl8:freq_1>
<dbl8:freq_2>
...
<dbl8:freq_nfreq>
<dbl8:meanint[1,icell=1]>
<dbl8:meanint[1,icell=2]>
...
<dbl8:meanint[1,icell=nrcells]>
<dbl8:meanint[2,icell=1]>
<dbl8:meanint[2,icell=2]>
...
<dbl8:meanint[2,icell=nrcells]>
...
...
...
<dbl8:meanint[nfreq,icell=1]>
<dbl8:meanint[nfreq,icell=2]>
...
<dbl8:meanint[nfreq,icell=nrcells]>
If you also set rto_single=1 in the radmc3d.inp Ô¨Åle, then you will get:
<int8:iformat=2>
<int8:precis=4>
<int8:nrcells>
<int8:nfreq>
<dbl8:freq_1>
<dbl8:freq_2>
...
<dbl8:freq_nfreq>
<flt4:meanint[1,icell=1]>
<flt4:meanint[1,icell=2]>
...
<flt4:meanint[1,icell=nrcells]>
(continues on next page)
176
Chapter 17. Binary I/O Ô¨Åles

radmc3d, Release 2.0
(continued from previous page)
<flt4:meanint[2,icell=1]>
<flt4:meanint[2,icell=2]>
...
<flt4:meanint[2,icell=nrcells]>
...
...
...
<flt4:meanint[nfreq,icell=1]>
<flt4:meanint[nfreq,icell=2]>
...
<flt4:meanint[nfreq,icell=nrcells]>
Note that only the mean intensity data (the main data) are single precision Ô¨Çoats.
17.3. Binary I/O Ô¨Åle format of RADMC-3D
177

radmc3d, Release 2.0
178
Chapter 17. Binary I/O Ô¨Åles

CHAPTER
EIGHTEEN
COMMAND-LINE OPTIONS
This chapter deals with all the possible command-line options one can give when calling the radmc3d code.
18.1 Main commands
In addition to the radmc3d.inp Ô¨Åle, which contains many ‚Äòsteering‚Äô parameters, one can (and even must) give RADMC-
3D also command-line options. The most important (and compulsory) options are the ‚Äòcommand‚Äô what RADMC-3D
should do. At the moment you can choose from:
‚Ä¢ mctherm: Runs RADMC-3D for computing the dust temperatures using the Monte Carlo method.
‚Ä¢ spectrum: Runs RADMC-3D for making a spectrum based on certain settings. This option requires further
command-line speciÔ¨Åcations. See chapter Making images and spectra.
‚Ä¢ sed: Runs RADMC-3D for making a SED based on certain settings. This option requires further command-
line speciÔ¨Åcations. Note that a SED is like a spectrum, but for continuum processes only (no lines). See chapter
Making images and spectra for more details.
‚Ä¢ image: Runs RADMC-3D for making an image. This option requires further command-line speciÔ¨Åcations.
See chapter Making images and spectra.
‚Ä¢ movie: Like image, but now for a series of different vantage points. Useful for making movies in one go,
without having to call RADMC-3D time and again. NOTE: This command is still under development. See
chapter Making images and spectra.
‚Ä¢ mcmono: (Only expect use). Runs RADMC-3D for computing the local radiation Ô¨Åeld at each location in the
model. This is only useful for when you wish to couple RADMC-3D to models of chemistry or so, which need
the local radiation Ô¨Åeld. See Section Special-purpose feature: Computing the local radiation Ô¨Åeld.
Example:
radmc3d mctherm
runs the RADMC-3D code for computing the dust temperatures everywhere using the Monte Carlo method.
There are also some additional commands that may be useful for diagnostics:
‚Ä¢ subbox_****: where **** is one of the following: dust_density, dust_temperature. But other
quantities will follow in later versions. See Section Making a regularly-spaced datacube (‚Äòsubbox‚Äô) of AMR-
based models.
‚Ä¢ linelist: Write a list of all the lines included in this model.
179

radmc3d, Release 2.0
18.2 Additional arguments: general
Here is a list of command line options, on top of the above listed main commands (Note: We‚Äôll try to be complete, but
as the code develops we may forget to list new options here):
‚Ä¢ setthreads [for MC] The next number sets the number of OpenMP parallel threads to be used.
‚Ä¢ npix: [for images] The next number speciÔ¨Åes the number of pixels in both x and y direction, assuming a square
image.
‚Ä¢ npixx: [for images] The next number speciÔ¨Åes the number of pixels in x direction only.
‚Ä¢ npixy: [for images] The next number speciÔ¨Åes the number of pixels in y direction only.
‚Ä¢ nrrefine: [for images and spectra] SpeciÔ¨Åes a maximum depth of reÔ¨Ånement of the pixels (see Section The
issue of Ô¨Çux conservation: recursive sub-pixeling).
‚Ä¢ fluxcons: [for images and spectra] Puts nrreÔ¨Åne (see above) to a large value to assue Ô¨Çux conservation (see
Section The issue of Ô¨Çux conservation: recursive sub-pixeling).
‚Ä¢ norefine: [for images and spectra] Puts nrreÔ¨Åne (see above) to 0 so that each pixel of the image corre-
sponds only to 1 ray. This is fast but not reliable and therefore not recommended (see Section The issue of Ô¨Çux
conservation: recursive sub-pixeling).
‚Ä¢ nofluxcons: [for images and spectra] As norefine above.
‚Ä¢ noscat: This option makes RADMC-3D ignore the dust scattering process (though not the scattering extinc-
tion!) in the images, spectra and Monte Carlo simulations. For images and spectra this means that no scattering
Monte Carlo run has to be performed before each image ray tracing (see Section Scattered light in images
and spectra: The ‚ÄòScattering Monte Carlo‚Äô computation). This can speed up the making of images or spectra
enormously. This is even more so if you make images/spectra of gas lines with LTE, LVG or ESCP methods,
because if no scattering Monte Carlo needs to be made, ray-tracing can be done multi-frequency for each ray,
and the populations can be calculated once in each cell, and used for all frequencies. That can speed up the line
rendering enormously ‚Äì of course at the cost of not including dust scattering. For lines in the infrared and sub-
millimeter, if no large grains are present, this is usually OK, because small grains (smaller than about 1 micron)
have very low scattering albedos in the infrared and submillimeter.
‚Ä¢ ilambda or inu: [for images] Specify the index of the wavelength from the wavelength_micron.inp
Ô¨Åle for which a ray-trace image should be made.
‚Ä¢ color: [for images] Allows you to make multiple images (each at a different wavelength) in one go. This will
make RADMC-3D read the Ô¨Åle color_inus.inp (see Section INPUT: (minor input Ô¨Åles)) which is a list of
indices i referring to the wavelength_micron.inp Ô¨Åle for which the images should be made. See Section
Specifying custom-made sets of wavelength points for the camera for details.
‚Ä¢ loadcolor: [for images] Same as color.
‚Ä¢ loadlambda: [for images] Allows you to make multiple images (each at a different wavelength) in one
go. This will make RADMC-3D read the Ô¨Åle camera_wavelength_micron.inp to read the precise
wavelength points at which you wish to make the images. In contrast to loadcolor, which only allows you to
pick from the global set of wavelength used by the Monte Carlo simulation (in the Ô¨Åle wavelength_micron.
inp), with the camera_wavelength_micron.inp Ô¨Åles you can specify any wavelength you want, and
any number of them. See Section Specifying custom-made sets of wavelength points for the camera for details.
‚Ä¢ sizeau: [for images and spectra] The next number speciÔ¨Åes the image size in model space in units of AU
(=1.496E13 cm). This image size is measured from the image left to right and top to bottom. This gives always
square images. This image size in au is observer distance independent. The corresponding image size in arcsec
is: image size in arcsec = image size in AU / (distance in parsec).
‚Ä¢ sizepc: [for images and spectra] Same as sizeau, but now in parsec units.
180
Chapter 18. Command-line options

radmc3d, Release 2.0
‚Ä¢ zoomau: [for images and spectra] The next four numbers set the image window precisely by specifying the
xleft, xright, ybottom, ytop of the image in units of AU. The zero point of the image (the direction of the 2-D
image point located at (0.0,0.0) in image coordinates) stays the same (i.e. it aims toward the 3-D point in model
space given by pointau or pointpc). In this way you can move the image window left or with or up or
down without having to change the pointau or pointpc 3-D locations. Also for local perspective images it
is different if you move the image window in the image plane, or if you actually change the direction in which
you are looking (for images from inÔ¨Ånity this is the same). Note: If you use this option without the truepix
option RADMC-3D will always make square pixels by adapting npixx or npixy such that together with the
zoomau image size you get approximately square pixels. Furthermore, if truezoom is not set, RADMC-3D
will alleviate the remaining tiny deviation from square pixel shape by slightly (!) adapting the zoomau window
to obtain exactly square pixels.
‚Ä¢ zoompc: [for images and spectra] Same as zoomau, but now the four numbers are given in units of parsec.
‚Ä¢ truepix: [for images and spectra] If with zoomau or zoompc the image window is not square then when
specifying npix one gets non-square pixels. Without the truepix option RADMC-3D will adapt the npixx
or npixy number, and subsequently modify the zoom window a bit such that the pixels are square. With the
truepix option RADMC-3D will not change npixx nor npixy and will allow non-square pixels to form.
‚Ä¢ truezoom: [for images and spectra] If set, RADMC-3D will always assure that the exact zoom window
(speciÔ¨Åed with zoomau or zoompc) will be used, i.e. if truepix is not set but truezoom is set, RADMC-
3D will only (!) adapt npixx or npixy to get approximately square pixels.
‚Ä¢ pointau: [for images and spectra] The subsequent three numbers specify a 3-D location in model space toward
which the camera is pointing for images and spectra. The (0,0) coordinate in the image plane corresponds by
deÔ¨Ånition to a ray going right through this 3-D point.
‚Ä¢ pointpc: [for images and spectra] Same as pointau but now in units of parsec.
‚Ä¢ incl: [for images and spectra] For the case when the camera is at inÔ¨Ånity (i.e. at a large distance so that no
local perspective has to be taken into account) this inclination speciÔ¨Åes the direction toward which the camera
for images and spectra is positioned. Incl = 0 means toward the positive ùëß-axis (in cartesian space), incl=90
means toward a position in the ùë•-ùë¶-plane and incl=180 means toward the negative ùëß-axis. The angle is given in
degrees.
‚Ä¢ phi: [for images and spectra] Like incl, but now the remaining angle, also given in degrees. Examples:
incl=90 and phi=0 means that the observer is located at inÔ¨Ånity toward the negative ùë¶axis; incl=90 and
phi=90 means that the observer is located at inÔ¨Ånity toward the negative ùë•axis; incl=90 and phi=180 means
that the observer is located at inÔ¨Ånity toward the positive ùë¶axis (looking back in negative ùë¶direction). Rotation
of the observer around the object around the ùëß-axis goes in clockwise direction. The starting point of this rotation
is such that for incl=0 and phi=0 the (ùë•, ùë¶) in the image plane correspond to the (ùë•, ùë¶) in the 3-D space,
with ùë•pointing toward the right and ùë¶pointing upward. Examples: if we Ô¨Åx the position of the observer at for
instance incl=0 (i.e. we look at the object from the top from the positive ùëß-axis at inÔ¨Ånity downward), then
increasing phi means rotating the object counter-clockwise in the image plane.
‚Ä¢ posang: [for images] This rotates the camera itself around the (0, 0) point in the image plane.
‚Ä¢ imageunform: Write out images in binary format
‚Ä¢ imageformatted: Write out images in text form (default)
‚Ä¢ tracetau: [for images] If this option is set, then instead of ray-tracing a true image, the camera will compute
the optical depth at the wavelength given by e.g. inu and puts this into an image output as if it were a true
image. Can be useful for analysis of models.
‚Ä¢ tracecolumn: [for images] Like tracetau but instead of the optical depth the simple column depth is
computed in g/cm2. NOTE: for now only the column depth of the dust.
‚Ä¢ tracenormal: [for images: Default] Only if you speciÔ¨Åed tracetau or tracecolumn before, and you
are in child mode, you may sometimes want to reset to normal imaging mode.
18.2. Additional arguments: general
181

radmc3d, Release 2.0
‚Ä¢ apert or useapert:
[for images/spectra] Use the image-plane aperture information from the Ô¨Åle
aperture_info.inp.
‚Ä¢ noapert: [for images/spectra] Do not use an image-plane aperture.
‚Ä¢ nphot_therm: [for MC] The nr of photons for the thermal Monte Carlo simulation. But it is better to use
the radmc3d.inp for this (see Section INPUT: radmc3d.inp), because then you can see afterward with which
photon statistics the run was done.
‚Ä¢ nphot_scat: [for MC] The nr of photons for the scattering Monte Carlo simulation done before each im-
age (and thus also in the spectrum). But it is better to use the radmc3d.inp for this (see Section INPUT:
radmc3d.inp), because then you can see afterward with which photon statistics the run was done.
‚Ä¢ nphot_mcmono: [for MC] The nr of photons for the monochromatic Monte Carlo simulation. But it is better
to use the radmc3d.inp for this (see Section INPUT: radmc3d.inp), because then you can see afterward with
which photon statistics the run was done.
‚Ä¢ countwrite: [for MC] The nr of photons between ‚Äòsign of life‚Äô outputs in a Monte Carlo run. Default is 1000.
That means that if you have nrphot=10000000 you will see ten-thousand times something like Photonnr:
19000 on your screen. Can be annoying. By adding countwrite 100000 to the command line, you will
only see a message every 100000 photon packages.
18.3 Switching on/off of radiation processes
You can switch certain radiative processes on or off with the following command-line options (though often the
radmc3d.inp Ô¨Åle also allows this):
‚Ä¢ inclstar: [for images and spectra] Include stars in spectrum or images.
‚Ä¢ nostar: [for images and spectra] Do not include stars in spectrum or images. Only the circumstellar / inter-
stellar material is imaged as if a perfect coronograph is used.
‚Ä¢ inclline: Include line emission and extinction in the ray tracing (for images and spectra).
‚Ä¢ noline: Do not include line emission and extinction in the ray tracing (for images and spectra).
‚Ä¢ incldust: Include dust emission, extinction and (unless it is switched off) dust scattering in ray tracing (for
images and spectra).
‚Ä¢ nodust: Do not include dust emission, extinction and scattering in ray tracing (for images and spectra).
‚Ä¢ maxnrscat 0: (if dust is included) Do not include scattering in the images/spectra created by the camera.
With maxnrscat 1 you limit the scattering in the images/spectra to single-scattering. With maxnrscat 2
to double scattering, etc. Can be useful to Ô¨Ågure out the relative importance of single vs multiple scattering.
182
Chapter 18. Command-line options

CHAPTER
NINETEEN
WHICH OPTIONS ARE MUTUALLY INCOMPATIBLE?
For algorithmic reasons not all options / coordinate systems and all grids are compatible with each other. Here is an
overview of which options/methods work when. Note that only options/methods for which this is a possible issue are
listed.
19.1 Coordinate systems
Some coordinate systems exclude certain possibilities. Here is a list.
Option/Method:
Cart 3D
Sph 3D
Sph 2D (axisymm)
Sph 1D
Second order ray-tracing
yes
yes
yes
yes
Isotropic scattering
yes
yes
yes
yes
An-isotropic scattering for thermal Monte Carlo
yes
yes
yes
yes
An-isotropic scattering for monochromatic Monte Carlo
yes
yes
yes
yes
An-isotropic scattering for images and spectra
yes
yes
yes
no
Full Stokes scattering for thermal Monte Carlo
yes
yes
yes
yes
Full Stokes scattering for monochromatic Monte Carlo
yes
yes
yes
yes
Full Stokes scattering for images and spectra
yes
yes
yes
no
Gas lines
yes
yes
yes
yes
Gas lines and Doppler-shift line catching
yes
yes
no
no
19.2 Scattering off dust grains
The inclusion of the effect of scattering off dust grains in images and spectra typically requires a separate Monte Carlo
computation for each image. This is done automatically by RADMC-3D. But it means that there are some technical
limitations.
Option/Method:
No scatter-
ing
Isotropic
approxi-
mation
Full anisotropic/Stokes scat-
tering
Fast multi-frequency ray tracing for spectra
(auto)
yes
no
no
Multiple images at different vantage point
at once
yes
yes
yes
Local observer
yes
yes
no
183

radmc3d, Release 2.0
19.3 Local observer mode
The local observer mode (Sect. For public outreach work: local observers inside the model) is a special mode for
putting the observer in the near-Ô¨Åeld of the object, or even right in the middle of the object. It is not meant to be really
for science use (though it can be used for it, to a certain extent), but instead for public outreach stuff. However, it
is kept relatively basic, because to make this mode compatible with all the functions of RADMC-3D would require
much more development and that is not worth it at the moment. So here are the restrictions:
Option/Method:
Local observer mode
Dust isotropic scattering
yes
Dust an-isotropic scattering
no
Multiple images at different vantage point at once
yes
Second-order ray-tracing
yes
Doppler-catching of lines
no
184
Chapter 19. Which options are mutually incompatible?

CHAPTER
TWENTY
ACQUIRING OPACITIES FROM THE WWW
Opacities are the basic ingredients necessary for any model with RADMC-3D. The example models in this package
contain example opacities, but for professional usage of RADMC-3D it may be necessary to get speciÔ¨Åc opacity data
from the web. These opacity data are usually in a wide variety of formats. To enable RADMC-3D to read them usually
requires a conversion into RADMC-3D-readable form (see Section INPUT (required for dust transfer): dustopac.inp
and dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp for dust opacities and Section INPUT: Molecu-
lar/atomic data: The molecule_XXX.inp Ô¨Åle(s) for gas line opacities).
To make it easier for the user to create RADMC-3D-readable input Ô¨Åles from opacity data downloaded from the web,
we now feature a new directory opac/ in the RADMC-3D distribution in which, for several of the most common
WWW databases, we provide Python routines for the conversion. Please read the README_* Ô¨Åles in this directory
and its subdirectories for details.
185

radmc3d, Release 2.0
186
Chapter 20. Acquiring opacities from the WWW

CHAPTER
TWENTYONE
VERSION TRACKER: DEVELOPMENT HISTORY
This version overview is very rough, and has only been started as of version 0.25.
‚Ä¢ Version 0.25
‚Äì Second order integration, based on a vertex-based grid (as opposed to the usual cell-based grid), imple-
mented. This gives much smoother images, and you don‚Äôt see the blocky cell structure anymore in the
images. It requires extra memory, though. See Section Second order ray-tracing (Important information!).
‚Äì The number of photons for scattering Monte Carlo (i.e. the small MC run done before each image, if
dust scattering is active) can now be chosen to be smaller for when you make a spectrum instead of an
image. Reason: Since you anyway integrate over the images for a spectrum, you do not need the image
to ‚Äòlook nice‚Äô, i.e. you can afford more photon noise. You can set this in radmc3d.inp by setting
nphot_spec=10000, for instance. See Section Scattered light in images and spectra: The ‚ÄòScattering
Monte Carlo‚Äô computation.
‚Ä¢ Version 0.26
‚Äì For line transfer: Added the ‚Äòdoppler catching‚Äô method to the code. This prevents bad numerical artifacts in
images/spectra of regions with large velocity gradients, where the doppler-shift between two neighboring
cells exceeds the intrinsic line width of the material in the cell. See Section Preventing doppler jumps:
The ‚Äòdoppler catching method‚Äô.
‚Äì NOTE: Up to, and including, version 0.26_23.02.11 this method (and for that matter any second order
integration of line transfer) was not stable when strong shocks or contact discontinuities were encountered.
This was because interpolation of the source function ùëÜùúà‚â°ùëóùúà/ùõºùúàwas done. Experimentation showed
that interpolation of the emissivity ùëóùúàis much more stable. As of version 0.26_27.02.11 this is Ô¨Åxed.
‚Ä¢ Version 0.27
‚Äì For line transfer: Implemented the possibility to use a Voigt line proÔ¨Åle instead of just a Gaussian. This
was implemented by Thomas Peters, and slightly modiÔ¨Åed by CPD. It uses the Voigt approximation by
Humlicek JQSRT 27, 437 (1982) as programmed by Schreier, JQSRT 48, 743 (1992). It requires a user-
deÔ¨Åned subroutine userdef_compute_lorentz_delta() that sets the value of the Lorentz proÔ¨Åle
delta. This implementation is not yet documented, and may still be subject to modiÔ¨Åcation.
‚Äì Implemented the ‚ÄòLarge Velocity Gradient‚Äô (LVG) method (also called the Sobolev method) of approxi-
mate non-LTE line transfer.
‚Äì Implemented the optically thin populations method.
‚Äì Implemented the possibility of reading linelist molecular data instead of full molecular data. Still needs
testing.
‚Äì Finally implemented the positive lines_mode modes, i.e. in which the level populations are computed
and stored globally before the ray-tracing. This has been latently in the code somewhat, but unÔ¨Ånished.
Now it is implemented. The advantage is: it may be under some conditions much faster than the on-the-Ô¨Çy
187

radmc3d, Release 2.0
computation of the populations during the ray-tracing (the negative lines_mode modes). Also it allows
you to write the populations to Ô¨Åle, so that you can examine them. Disadvantage: It is memory hungry.
‚Äì The level subset capacilities are now limited to only the storage of the levels in the global arrays (for
positive lines_mode modes), and to the lines that will appear in images/spectra. For the rest, the full
set of levels are always used from now on.
‚Äì Added a directory ‚Äòopac/‚Äô which contains programs for generating your own dust opacities using optical
constants from the web, and for generating your own molecular/atomic input data Ô¨Åles using data from
several web pages. The data from the web are not included, but there are README Ô¨Åles that point you to
the web sites.
‚Äì Tested the ‚ÄòÔ¨Åsheye‚Äô fulldome (OMNIMAX) projection. It seems to work! Thanks to Mario Flock.
‚Äì Several small (and bigger) bugÔ¨Åxes
* Fixed bug that showed up when no dust is included.
* Fixed bug that caused RADMC-3D to crash when using no stars.
* Fixed bug that caused RADMC-3D to crash when making images at very short wavelengths with
nearly zero thermal emission.
* Fixed bug in the AMR module when using second order integration or the doppler catching method
with certain kinds of AMR-arrangements of cells.
* Fixed many bugs when using a ‚Äòpiece of a cake‚Äô model, i.e. using spherical coordinates in 3-D, but
having the ùúë-grid going not over the full 0 ‚àí2ùúãrange but e.g. just from 0 to ùúã/4. It is rather rare
that one really wants to use such grids (certainly not for real physical models, I presume), but for
visualization of data it might be useful: for instance for visualizing a 3-D disk MHD model, which is
cut open so you can see also to the midplane. Now it works. Thanks to Mario Flock.
* Fixed bug with the aperture mode for spectra. Thanks to Daniel Harsono.
* Fixed many bugs in linelist mode; now it works. Thanks to Attila Juhasz.
* Fixed a bug in LVG mode that caused it to fail when AMR was used. Thanks to Anika Schmiedeke.
* Fixed a tiny bug in idl/radmc3dfits.pro: Ô¨Ålename was unused. Thanks to Stella Offner.
* Retroactive bugÔ¨Åx from version 0.28 (see below): LVG and AMR mode.
For details and for smaller bugÔ¨Åxes, read the src/Radmc_3D_LOG.txt document.
‚Ä¢ Version 0.28
‚Äì A number of people complained that even without AMR the code requires a huge amount of memory.
That is because even if no AMR is used, the cells are connected via the AMR tree. Since the AMR cells
contain information about which are the neighboring cells, and each cell has 6 neighbors, and slots for 8
child-cells (which are unused in case of a regular grid) this wastes a lot of memory space. The Ô¨Årst big
improvement in version 0.28 is that, from now on, the AMR tree is only set up and used if the grid indeed
has reÔ¨Ånement. If RADMC-3D notices that the grid is regular, it will not allocate space for the AMR tree,
and everywhere in the code where the cell-management is done the code will switch to regular grid mode.
There is now a Ô¨Çag amr_tree_present that says whether the AMR tree is present or not. Throughout
the code there are now if-statements to switch between using or not-using the AMR tree. This may make
the code a tiny bit slower, but this is only a minor reduction of speed. But as a result it should now be
much easier to load huge regular grid models into memory.
‚Äì A small (but potentially nasty) bug was found and Ô¨Åxed for the case when you use LVG mode on a grid with
AMR-reÔ¨Ånements. For the regular grid case (even in version 0.27, when it still used the AMR tree) this
bug should not have caused problems, but perhaps you might want to check nevertheless. Note: This bug
is now also retroactively Ô¨Åxed in version 0.27. See, as always, src/Radmc_3D_LOG.txt for details.
188
Chapter 21. Version tracker: Development history

radmc3d, Release 2.0
‚Äì Added the possibility to visualize the location (along the line of sight) of the ùúè= 1 surface (or any ùúè= ùúèùë†
surface for that matter). See new Section Visualizing the \tau=1 surface. This can be very useful for getting
a 3-D feeling for where certain emission comes from.
‚Ä¢ Version 0.29
‚Äì The big change in this version is that the whole stuff with the global storage of level populations has
been improved. In earlier versions of RADMC-3D, either the populations of all levels of a molecule were
stored globally (potentially requiring huge amounts of memory), or you would have to select a ‚Äòsubset‚Äô
of levels to store globally. This subset selection had to be done by the user (‚Äòmanually‚Äô, so to speak).
You would have had to think a-priori which lines you wish to model, and which levels they connect, and
then, in the lines.inp Ô¨Åle you would have to select these levels by hand. That was cumbersome and
prone to error. To avoid having to do this you could use ‚Äòon-the-Ô¨Çy‚Äô calculation of populations (by making
the lines_mode negative), but that sometimes caused the code to become terribly slow. Now this is
dramatically improved: From now on you can forget about the ‚Äòon-the-Ô¨Çy‚Äô calculation of populations. Just
use the ‚Äònormal‚Äô way by which RADMC-3D Ô¨Årst calculates the populations and then starts the ray-tracing.
The subset-selection is now done automatically by RADMC-3D, based on which wavelengths you want to
make the image(s) or spectra for (see Section Background information: Calculation and storage of level
populations). Now the on-the-Ô¨Çy methods are no longer default and should not be used, unless absolutely
necessary. Also the ‚Äòmanual‚Äô subset selection is no longer necessary (though still possible if absolutely
desired).
‚Äì Added the subbox and sample capabilities to the level populations. See Sections Making a regularly-
spaced datacube (‚Äòsubbox‚Äô) of AMR-based models and Alternative to subbox: arbitrary sampling of AMR-
based models. Note that, in order to make it easier to identify which levels were written to Ô¨Åle, the Ô¨Åle
formats of ***_subbox.out and ***_sample.out have been slightly modiÔ¨Åed: A list of identiÔ¨Åca-
tion numbers is added before the main data. For the dust temperature and dust density this list is simply 1
2 3 4 ... (dust species 1, dust species 2, dust species 3 ...), which is trivial. For the level populations (e.g.
the Ô¨Åle levelpop_co_subbox.out and levelpop_co_sample.out for the CO molecule) this
list is, however, essential when not all levels were computed (see Section Background information: Cal-
culation and storage of level populations). So if only level 4 and level 8 are stored, then the identiÔ¨Åcation
list is 4 8.
‚Äì Fixed a bug which caused the code to crash when you put a star substantially far outside of the domain and
try to make an image or spectrum. Thanks, Erika Hamden, for the bug report.
‚Äì Fixed a bug that prevented the lines_mode=50 mode from working. Now it works, and we can ask
RADMC-3D to read the level populations from Ô¨Åle (rather than calculating them internally). Also a new
section was added to this manual describing this option (Section Non-LTE Transfer: Reading the level
populations from Ô¨Åle).
‚Äì Added VTK output options (see chapter Visualization with VTK tools (e.g. Paraview or VisIt)) for allowing
3-D visualization of your model setups using e.g. Paraview, a freely available visualization tool.
‚Äì Fixed a bug that occurred sometimes if a spectrum was made at inclination 90 and phi 90. Thanks Stella
Offner for reporting this bug.
‚Ä¢ Version 0.30
‚Äì Fixed bugs in the Henyey-Greenstein scattering mode.
‚Äì Introduced the new binary I/O feature: No more hassle with f77-unformatted records! The new binary
mode is much simpler and more straightforward. This will help reducing the Ô¨Åle sizes for large models.
See Chapter Binary I/O Ô¨Åles.
‚Ä¢ Version 0.31
‚Äì Added the possibility, in cartesian coordinates, to ‚Äòclose the box‚Äô, in the sense of making the domain
boundaries thermal walls. Each of the 6 boundaries can be set separately, so you can also have just one
189

radmc3d, Release 2.0
thermall wall. Also the temperatures can be set separately for each of the 6 boundaries. See Section
Thermal boundaries in Cartesian coordinates.
‚Äì Added two new coordinate systems:
* Cartesian 1-D plane-parallel (the only remaining active coordinate is ùëß). The ùë•and ùë¶dimensions are
inÔ¨Ånitely extended and have translational symmetry. The photons can, however, travel in full 3-D as
always. See Section 1-D Plane-parallel models.
* Cartesian 2-D pencil-parallel (the two remaining active coordinate are ùë¶and ùëß). The ùë•dimension is
inÔ¨Ånitely extended and has translational symmetry. The photons can, however, travel in full 3-D as
always.
* For the 1-D plane-parallel mode it is possible to include parallel beams of radiative Ô¨Çux impinging on
the 1-D atmosphere.
* Attila Juhasz has improved the VTK output: Now it also supports 3-D spherical coordinates. Thanks,
Attila!
‚Ä¢ Version 0.32
This is an intermediate version in which some stuff for the near-future modus of polarization is implemented.
‚Ä¢ Version 0.33
‚Äì Some minor technical changes to the doppler-catching integration of lines (storing the upper and lower
level population instead of the jnubase and anubase variables).
‚Äì Added the classical escape probability to the LVG mode (see Section Non-LTE Transfer: The Large Ve-
locity Gradient (LVG) + Escape Probability (EscProb) method for details).
‚Äì Sped up the Ô¨Ålling of the matrix of the statistical equilibrium equation.
‚Äì Vastly improved the LVG (and esc prob) method: Instead of the simple ‚Äòlambda iteration style‚Äô iteration
as it was before, the ùê¥ùëñùëòis now multiplied with ùõΩùëñùëò(the escape probability of the line i->k) and the ùêΩùëñùëòis
replaced by ùêΩbackground
ùëñùëò
. This means that the solution is almost instant, requiring only 2 or 3 iterations.
‚Ä¢ Version 0.34
Implemented the ModiÔ¨Åed Random Walk method, based on Min, Dullemond, Dominik, de Koter & Hovenier
(2009) A&A 497, 155, and simpliÔ¨Åed by Robitaille (2010) A&A 520, 70. But beware: Still in the testing phase!
By default it is switched off.
‚Ä¢ Version 0.35
‚Äì Implemented polarized scattering off randomly oriented particles. But beware: Still in the testing phase!
‚Äì Fixed a bug in the modiÔ¨Åed random walk method (thanks to Daniel Harsono for spotting the problem and
thanks to Attila Juhasz for Ô¨Ånding the Ô¨Åx!)
‚Äì Fixed two bugs that made it impossible to use second order integration with axially symmetric spherical
coordinates and/or a Ô¨Ånite-size star (thanks to Rolf Kuiper for reporting the bug).
‚Äì Added the sloppy command line option to spectrum and image making in spherical coordinates. This
was necessary because RADMC-3D is always trying to make 100% sure that all cells are picked up by
the subpixels. In spherical coordinates these cells can be extremely non-cubic (they can be extremely Ô¨Çat
or needle-like), which means that under some projections RADMC-3D feels obliged to do extreme sub-
pixeling, which can make image- and spectrum-making extremely slow. By adding the sloppy keyword
on the command line, RADMC-3D will limit it‚Äôs pubpixeling which could speed up the calculation very
much (but of course at your own risk!).
‚Ä¢ Version 0.38
‚Äì Implemented OpenMP parallellization of the thermal Monte Carlo (by Adriana Pohl). Still beta-version.
190
Chapter 21. Version tracker: Development history

radmc3d, Release 2.0
‚Äì BugÔ¨Åx in the mean intensity computation (mcmono) mode (thanks to Gwendoline Stephan).
‚Äì BugÔ¨Åx in the mean intensity computation (mcmono) mode (thanks to Seokho Lee).
‚Äì Major bugÔ¨Åx in aperture mode (thanks to So ren Frimann).
‚Äì Unformatted image format is from now on C-style binary instead of F77-style unformatted.
‚Äì The viewimage tool is now ported to Qt by Farzin Sereshti, meaning that you can now use viewim-
age without having an IDL license. Viewimage is a very powerful tool to interactively make and view
images of your model at different wavelengths and viewing angles. It can be found in the directory
viewimage_QT_GUI/.
‚Äì A Python package for RADMC-3D was developed by Attila Juhasz. It is included as of RADMC-3D
version 0.38 in the directory python/.
‚Ä¢ Version 0.39
‚Äì Polarization mode is incompatible with mirror mode (in spherical coordinates). An error message is now
included to catch this.
‚Äì Minor bugÔ¨Åx in pick_randomfreq_db() (thanks to Seokho Lee).
‚Äì Optimization of the OpenMP parallellization and extension of the OpenMP parallellization to the Scatter-
ing Monte Carlo computation (both by Farzin Sereshti).
‚Äì BugÔ¨Åx in amrray_module.f90: Sometimes one got ‚ÄòPhoton outside of cell‚Äô error due to a numerical
precision round-off error. This bug is now (mostly?) Ô¨Åxed.
‚Äì BugÔ¨Åx in sources_module.f90: When using second order integration (or doppler catching) for line
transfer in spherical coordinates, the line doppler shift was not transformed to spherical coordinates. This
is now Ô¨Åxed.
‚Äì Several bugÔ¨Åxes in the modiÔ¨Åed random walk method by John Ramsey. The method crashed for extreme
optical depth problems due to out-of-cell events. Still not 100% perfect, but better.
‚Äì John Ramsey also proposed two small Ô¨Åxes to the Planck function routines so that the events of overÔ¨Çow
are caught. Note: This might change the results (in a tiny way: at the machine precision level) to the
extent that a model run by an old version might not yield the same values to machine precision, but the
differences should not matter in any meaningful way.
‚Ä¢ Version 0.40
‚Äì The RADMC-3D package is now ‚ÄòofÔ¨Åcially‚Äô converting from IDL to Python wrappers. The Python mod-
ules were already there since a long time (thanks to Attila Juhasz!). But as of version 0.40 we will no
longer update/maintain the IDL scripts (though they remain there and should remain working), and instead
use python as the main setup and analysis tools for RADMC-3D. The full conversion will still take some
time, but should be Ô¨Ånished by the end of version 0.40.
‚Äì Under some circumstances the simple 2x2 pixel plus sub-pixeling method for making spectra (default
method) can be dangerous. For some grid geometries this can lead to under-resolving of the images that
are integrated to obtain the Ô¨Çux, leading to a too low Ô¨Çux. So as of now 15.09.2016 the spectra and SEDs
are always by default made with 100x100 images (and sub-pixeling of course). One can set the number of
pixels with npix. So if you do radmc3dsednostarnpix2 you get the original behavior again.
‚Äì BugÔ¨Åx in montecarlo_module.f90: The internal heat source method (which is still being tested)
had a bug. The bug manifested itself for optically thin cells with non-negligible internal heat production.
The energy was not immediately added to the cell. It only got added upon re-absorption of that photon
package. Now this is Ô¨Åxed.
‚Äì I now added some documentation for the heat source method, which is useful for e.g. disk viscous accretion
heating.
191

radmc3d, Release 2.0
‚Äì BugÔ¨Åx in montecarlo_module.f90: When using mirror symmetry in spherical coordinates in the
ùúÉ-coordinate (i.e. modeling only the upper part of the disk and letting RADMC-3D assume that the lower
part is identical), the distributed source luminosity was computed only for the top quadrant, and wasn‚Äôt
multiplied by 2. For most applications this does not cause problems, but for the heat source (see above),
for continuous stellar sources and for the thermal origin of the isotropic scattering luminosity (for non-
isotropic scattering, mirror symmetry was not allowed anyway), this could lead to a factor of 2 underesti-
mation (only if mirror symmetry was used, i.e. if the ùúÉcoordinate was going only up to ùúã/2). This is now
Ô¨Åxed. To test if the Ô¨Åx works one can simply make the same model again, but now without using mirror
symmetry (and thus using twice as many cells in ùúÉ, to cover both the upper and lower half of the object).
This should yield (apart from some Monte Carlo noise) the same results.
‚Äì Improved the stability of the ModiÔ¨Åed Random Walk (MRW) method a bit further.
‚Äì Bug Ô¨Åx: scattering mode 3 (tabulated phase function, but not full polarization) had a bug which caused
images of scattered light to be multiplied by some arbitrary number. Reason: as a phase function it returned
ùëç11 instead of 4ùúãùëç11/ùúÖscat. Most people use either isotropic scattering (scattering mode 1), or Henyey-
Greenstein (scattering mode 2) or full polarization (scattering mode 5), all of which are ok. At any rate:
the problem is now Ô¨Åxed, so scattering mode 3 should now also work.
‚Ä¢ Version 0.41
‚Äì Implemented a Ô¨Årst testing version of the aligned grains: only polarized thermal emission so far. Still very
much a testing version.
‚Äì Implemented a method to also allow full Stokes vector polarized scattering in the 2-D axisymmetric mode
in spherical coordinates. Until now the full scattering mode (scattering mode 5) was only possible in full
3-D. Note however that anisotropic scattering in 2-D axisymmetric models requires scattering mode 5,
which is the full scattering mode. It is still not possible to use intermediate scattering modes (like henyey-
greenstein or any scattering mode between 2 and 4) in 2-D axisymmetry. But those intermediate modes
are anyway more for testing than for real models, so that should be ok.
‚Äì BugÔ¨Åxes to the OpenMP stuff. In particular the OpenMP parallellization of the scattering MC crashed.
This is now Ô¨Åxed. In general the OpenMP stuff was a bit cleaned up.
‚Äì BugÔ¨Åx in thermal Monte Carlo with full polarization mode: needed to reset the photon package after each
thermal absorption/re-emission event. Usually the effect is subtle, but had to be Ô¨Åxed.
‚Äì BugÔ¨Åx in reading the scattering_angular_grid.inp: the theta angles should be converted
into radian. But this Ô¨Åle was not ofÔ¨Åcially offered before anyway.
‚Äì Attila Juhasz has made a large improvement of his python package for RADMC-3D. See the python/
directory. This is version 0.29 of his package. This package now also supports reading and writing AMR
grids.
‚Äì BugÔ¨Åx in VTK for 3-D spherical coordinates (thanks Attila Juhasz!). Now it should work.
‚Ä¢ Version 2.0
Version 2.0 is the version after 0.41. We skip version 1.0, because version 1.0 could be mistaken for the Ô¨Årst
version of the code. Version 2.0 is mostly the same as 0.41, but with a few differences.
‚Äì IDL support is removed permanently. From now on, the front-end functionality is only in Python. We
assume Python 3.
‚Äì Version 0.30.2 of the radmc3dPy Python package (written by Attila Juhasz) has been implemented. It is
also being improved, mainly to make its use easier (i.e. with more automatic default behavior).
‚Äì A very simple simpleread.py reading library is provided as a ‚Äòlight version‚Äô of radmc3dPy. It contains
only some basic reading functions, and only for ascii output (no binary Ô¨Åles).
192
Chapter 21. Version tracker: Development history

radmc3d, Release 2.0
‚Äì Some of the standard-output is shortened. You can also call a Monte Carlo run with radmc3d with the
command line options countwrite 100000 to make RADMC-3D write a message only every 105
photon packages instead of every thousand.
‚Äì We removed the fortran-unformatted data format from the manual, and will remove it from the code in
later versions. Use either text (ascii) format or binary format.
‚Äì The manual is now converted to Sphinx, from which the LaTeX version and the HTML version can be
automatically created.
193

radmc3d, Release 2.0
194
Chapter 21. Version tracker: Development history

CHAPTER
TWENTYTWO
INDICES AND TABLES
‚Ä¢ genindex
‚Ä¢ modindex
‚Ä¢ search
195

