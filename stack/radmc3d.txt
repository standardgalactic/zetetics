radmc3d
Release 2.0
Cornelis Dullemond
Aug 29, 2020


CONTENTS
1
Introduction
1
1.1
What is RADMC-3D? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Capabilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.3
Version tracker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.4
Copyright . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.5
Contributing authors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.6
Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
2
Quickstarting with RADMC-3D
5
3
Overview of the RADMC-3D package
7
3.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
3.2
Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
3.3
Contents of the RADMC-3D package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3.3.1
RADMC-3D package as a .zip archive . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3.3.2
RADMC-3D package from the github repository
. . . . . . . . . . . . . . . . . . . . . . .
8
3.3.3
Contents of the package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.4
Units: RADMC-3D uses CGS units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
4
Installation of RADMC-3D
11
4.1
Compiling the code with ‘make’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
4.2
The install.perl script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
4.3
What to do if this all does not work? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
4.4
Installing the simple Python analysis tools
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
4.4.1
How to install and use the python/radmc3d_tools/
. . . . . . . . . . . . . . . . . .
14
4.4.2
How to install and use the python/radmc3dPy library
. . . . . . . . . . . . . . . . . .
15
4.5
Making special-purpose modiﬁed versions of RADMC-3D (optional) . . . . . . . . . . . . . . . . .
15
5
Basic structure and functionality
17
5.1
Basic dataﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
5.2
Radiative processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
5.3
Coordinate systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
5.4
The spatial grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
5.5
Computations that RADMC-3D can perform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
5.6
How a model is set up and computed: a rough overview
. . . . . . . . . . . . . . . . . . . . . . . .
23
5.7
Organization of model directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
5.8
Running the example models
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
6
Dust continuum radiative transfer
27
6.1
The thermal Monte Carlo simulation: computing the dust temperature . . . . . . . . . . . . . . . . .
27
6.1.1
Modiﬁed Random Walk method for high optical depths . . . . . . . . . . . . . . . . . . . .
28
i

6.2
Making SEDs, spectra, images for dust continuum . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
6.3
OpenMP parallelized Monte Carlo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
6.4
Overview of input data for dust radiative transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
6.5
Special-purpose feature: Computing the local radiation ﬁeld . . . . . . . . . . . . . . . . . . . . . .
31
6.6
More about scattering of photons off dust grains
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
6.6.1
Five modes of treating scattering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
6.6.2
Scattering phase functions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
6.7
Scattering of photons in the Thermal Monte Carlo run . . . . . . . . . . . . . . . . . . . . . . . . .
35
6.8
Scattering of photons in the Monochromatic Monte Carlo run . . . . . . . . . . . . . . . . . . . . .
35
6.8.1
Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation . . . . . .
36
6.8.2
Single-scattering vs. multiple-scattering . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
6.8.3
Simpliﬁed single-scattering mode (spherical coordinates) . . . . . . . . . . . . . . . . . . .
39
6.8.4
Warning when using an-isotropic scattering . . . . . . . . . . . . . . . . . . . . . . . . . .
39
6.8.5
For experts: Some more background on scattering . . . . . . . . . . . . . . . . . . . . . . .
39
6.9
Polarization, Stokes vectors and full phase-functions . . . . . . . . . . . . . . . . . . . . . . . . . .
40
6.9.1
Deﬁnitions and conventions for Stokes vectors . . . . . . . . . . . . . . . . . . . . . . . . .
41
6.9.2
Our conventions compared to other literature
. . . . . . . . . . . . . . . . . . . . . . . . .
43
6.9.3
Deﬁning orientation for non-observed radiation . . . . . . . . . . . . . . . . . . . . . . . .
44
6.9.4
Polarized scattering off dust particles: general formalism . . . . . . . . . . . . . . . . . . .
45
6.9.5
Polarized scattering off dust particles: randomly oriented particles . . . . . . . . . . . . . .
46
6.9.6
Scattering and axially symmetric models . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
6.10
More about photon packages in the Monte Carlo simulations . . . . . . . . . . . . . . . . . . . . . .
48
6.11
Polarized emission and absorption by aligned grains . . . . . . . . . . . . . . . . . . . . . . . . . .
48
6.11.1
Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
6.11.2
Implementation in RADMC-3D
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
6.11.3
Consistency with other radiative processes . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
6.11.4
Input ﬁles for RADMC-3D for aligned grains . . . . . . . . . . . . . . . . . . . . . . . . .
53
6.11.5
Effect of aligned grains on the scattering . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
7
Line radiative transfer
57
7.1
Quick start for adding line transfer to images and spectra . . . . . . . . . . . . . . . . . . . . . . . .
57
7.2
Some deﬁnitions for line transfer
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
7.3
Line transfer modes and how to activate the line transfer . . . . . . . . . . . . . . . . . . . . . . . .
58
7.3.1
Two different atomic/molecular data ﬁle types . . . . . . . . . . . . . . . . . . . . . . . . .
59
7.3.2
The different line modes (the lines_mode parameter) . . . . . . . . . . . . . . . . .
59
7.4
The various input ﬁles for line transfer
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
7.4.1
INPUT: The line transfer entries in the radmc3d.inp ﬁle . . . . . . . . . . . . . . . . . . . .
60
7.4.2
INPUT: The line.inp ﬁle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
7.4.3
INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s) . . . . . . . . . . . . . . . .
62
7.4.4
INPUT: Molecular/atomic data: The linelist_XXX.inp ﬁle(s) . . . . . . . . . . . . . . . . .
65
7.4.5
INPUT: The number density of each molecular species . . . . . . . . . . . . . . . . . . . .
66
7.4.6
INPUT: The gas temperature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
7.4.7
INPUT: The velocity ﬁeld
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
7.4.8
INPUT: The local microturbulent broadening (optional) . . . . . . . . . . . . . . . . . . . .
67
7.4.9
INPUT for LTE line transfer: The partition function (optional) . . . . . . . . . . . . . . . .
67
7.4.10
INPUT: The number density of collision partners (for non-LTE transfer) . . . . . . . . . . .
68
7.5
Making images and spectra with line transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
7.5.1
Speed versus realism of rendering of line images/spectra . . . . . . . . . . . . . . . . . . .
69
7.5.2
Line emission scattered off dust grains . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
7.6
Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method . . .
70
7.7
Non-LTE Transfer: The optically thin line assumption method . . . . . . . . . . . . . . . . . . . . .
73
7.8
Non-LTE Transfer: Full non-local modes (FUTURE) . . . . . . . . . . . . . . . . . . . . . . . . . .
73
7.9
Non-LTE Transfer: Inspecting the level populations
. . . . . . . . . . . . . . . . . . . . . . . . . .
73
7.10
Non-LTE Transfer: Reading the level populations from ﬁle . . . . . . . . . . . . . . . . . . . . . . .
74
ii

7.11
What can go wrong with line transfer? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
7.12
Preventing doppler jumps: The ‘doppler catching method’ . . . . . . . . . . . . . . . . . . . . . . .
76
7.13
Background information: Calculation and storage of level populations . . . . . . . . . . . . . . . . .
78
7.14
In case it is necessary: On-the-ﬂy calculation of populations . . . . . . . . . . . . . . . . . . . . . .
79
7.15
For experts: Selecting a subset of lines and levels ‘manually’ . . . . . . . . . . . . . . . . . . . . . .
80
8
Making images and spectra
81
8.1
Basics of image making with RADMC-3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
8.2
Making multi-wavelength images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
8.3
Making spectra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
8.3.1
What is ‘in the beam’ when the spectrum is made?
. . . . . . . . . . . . . . . . . . . . . .
86
8.3.2
Can one specify more realistic ‘beams’? . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
8.4
Specifying custom-made sets of wavelength points for the camera . . . . . . . . . . . . . . . . . . .
87
8.4.1
Using lambdarange and (optionally) nlam . . . . . . . . . . . . . . . . . . . . . . . . .
87
8.4.2
Using allwl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
8.4.3
Using loadcolor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
8.4.4
Using loadlambda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
8.4.5
Using iline, imolspec etc (for when lines are included) . . . . . . . . . . . . . . . . .
88
8.5
Heads-up: In reality wavelength are actually wavelength bands
. . . . . . . . . . . . . . . . . . . .
88
8.5.1
Using channel-integrated intensities to improve line channel map quality . . . . . . . . . . .
89
8.6
The issue of ﬂux conservation: recursive sub-pixeling
. . . . . . . . . . . . . . . . . . . . . . . . .
89
8.6.1
The problem of ﬂux conservation in images . . . . . . . . . . . . . . . . . . . . . . . . . .
89
8.6.2
The solution: recursive sub-pixeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
8.6.3
A danger with recursive sub-pixeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
8.6.4
Recursive sub-pixeling in spherical coordinates . . . . . . . . . . . . . . . . . . . . . . . .
91
8.6.5
How can I ﬁnd out which pixels RADMC-3D is recursively reﬁning? . . . . . . . . . . . . .
92
8.6.6
Alternative to recursive sub-pixeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
8.7
Stars in the images and spectra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
8.8
Second order ray-tracing (Important information!) . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
8.8.1
Second order integration in spherical coordinates: a subtle issue
. . . . . . . . . . . . . . .
98
8.9
Circular images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98
8.10
Visualizing the 𝜏= 1 surface
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8.11
For public outreach work: local observers inside the model . . . . . . . . . . . . . . . . . . . . . . . 102
8.12
Multiple vantage points: the ‘Movie’ mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
9
More information about the gridding
107
9.1
Regular grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
9.2
Separable grid reﬁnement in spherical coordinates (important!)
. . . . . . . . . . . . . . . . . . . . 108
9.3
Oct-tree Adaptive Mesh Reﬁnement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
9.4
Layered Adaptive Mesh Reﬁnement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
9.4.1
On the ‘successively regular’ kind of data storage, and its slight redundancy . . . . . . . . . 113
9.5
Unstructured grids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
9.6
1-D Plane-parallel models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
9.6.1
Making a spectrum of the 1-D plane-parallel atmosphere . . . . . . . . . . . . . . . . . . . 115
9.6.2
In 1-D plane-parallel: no star, but incident parallel ﬂux beams
. . . . . . . . . . . . . . . . 115
9.6.3
Similarity and difference between 1-D spherical and 1-D plane-parallel
. . . . . . . . . . . 116
9.7
Thermal boundaries in Cartesian coordinates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
10 More information about the treatment of stars
117
10.1
Stars treated as point sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
10.2
Stars treated as spheres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
10.3
Distributions of zillions of stars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
10.4
The interstellar radiation ﬁeld: external source of energy . . . . . . . . . . . . . . . . . . . . . . . . 119
10.4.1
Role of the external radiation ﬁeld in Monte Carlo simulations . . . . . . . . . . . . . . . . 119
iii

10.4.2
Role of the external radiation ﬁeld in images and spectra . . . . . . . . . . . . . . . . . . . 120
10.5
Internal heat source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
10.5.1
Slow performance of RADMC-3D with heat source . . . . . . . . . . . . . . . . . . . . . . 120
11 Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes
123
11.1
Setting up a model inside of RADMC-3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
11.2
The pre-deﬁned subroutines of the userdef_module.f90 . . . . . . . . . . . . . . . . . . . . . . . . . 124
11.3
Some caveats and advantages of internal model setup . . . . . . . . . . . . . . . . . . . . . . . . . . 126
11.4
Using the userdef module to compute integrals of 𝐽𝜈. . . . . . . . . . . . . . . . . . . . . . . . . . 127
11.5
Some tips and tricks for programming user-deﬁned subroutines
. . . . . . . . . . . . . . . . . . . . 127
11.6
Creating your own emission and absorption processes
. . . . . . . . . . . . . . . . . . . . . . . . . 128
12 Python analysis tool set
129
12.1
The simpleread.py library
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
12.2
The radmc3dPy library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
12.3
Model creation from within radmc3dPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
12.4
Diagnostic tools in radmc3dPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
12.4.1
Read the amr_grid.inp ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
12.4.2
Read all the spatial data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
12.4.3
Read the image.out ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
12.4.4
Read the spectrum.out ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
13 Analysis tools inside of radmc3d
133
13.1
Making a regularly-spaced datacube (‘subbox’) of AMR-based models
. . . . . . . . . . . . . . . . 133
13.1.1
Creating and reading a subbox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
13.1.2
Format of the subbox output ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.2
Alternative to subbox: arbitrary sampling of AMR-based models
. . . . . . . . . . . . . . . . . . . 134
14 Visualization with VTK tools (e.g. Paraview or VisIt)
137
15 Tips, tricks and problem hunting
141
15.1
Tips and tricks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
15.2
Bug hunting
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
15.3
Some tips for avoiding troubles and for making good models . . . . . . . . . . . . . . . . . . . . . . 142
15.4
Careful: Things that might go wrong
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
15.5
Common technical problems and how to ﬁx them . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
16 Main input and output ﬁles of RADMC-3D
147
16.1
INPUT: radmc3d.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
16.2
INPUT (required): amr_grid.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
16.2.1
Regular grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
16.2.2
Oct-tree-style AMR grid . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
16.2.3
Layer-style AMR grid
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
16.3
INPUT (required for dust transfer): dust_density.inp . . . . . . . . . . . . . . . . . . . . . . . . . . 156
16.3.1
Example: dust_density.inp for a regular grid . . . . . . . . . . . . . . . . . . . . . . 156
16.3.2
Example: dust_density.inp for an oct-tree reﬁned grid . . . . . . . . . . . . . . . . . 157
16.3.3
Example: dust_density.inp for a layer-style reﬁned grid . . . . . . . . . . . . . . . . 159
16.4
INPUT/OUTPUT: dust_temperature.dat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
16.5
INPUT (mostly required): stars.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
16.6
INPUT (optional): stellarsrc_templates.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
16.7
INPUT (optional): stellarsrc_density.inp
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
16.8
INPUT (optional): external_source.inp
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
16.9
INPUT (optional): heatsource.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
16.10 INPUT (required): wavelength_micron.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
16.11 INPUT (optional): camera_wavelength_micron.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
iv

16.12 INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or
dust_optnk_*.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
16.12.1 The dustopac.inp ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
16.12.2 The dustkappa_*.inp ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
16.12.3 The dustkapscatmat_*.inp ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
16.13 OUTPUT: spectrum.out . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
16.14 OUTPUT: image.out or image_****.out
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
16.15 INPUT: (minor input ﬁles) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
16.15.1 The color_inus.inp ﬁle (required with comm-line option ‘loadcolor’)
. . . . . . . . . 171
16.15.2 INPUT: aperture_info.inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
16.16 For developers: some details on the internal workings
. . . . . . . . . . . . . . . . . . . . . . . . . 172
17 Binary I/O ﬁles
173
17.1
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
17.2
How to switch to binary (or back to ascii) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
17.3
Binary I/O ﬁle format of RADMC-3D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
18 Command-line options
179
18.1
Main commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
18.2
Additional arguments: general . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
18.3
Switching on/off of radiation processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
19 Which options are mutually incompatible?
183
19.1
Coordinate systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
19.2
Scattering off dust grains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
19.3
Local observer mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
20 Acquiring opacities from the WWW
185
21 Version tracker: Development history
187
22 Indices and tables
195
v

vi

CHAPTER
ONE
INTRODUCTION
1.1 What is RADMC-3D?
RADMC-3D is a software package for astrophysical radiative transfer calculations in arbitrary 1-D, 2-D or 3-D ge-
ometries. It is mainly written for continuum radiative transfer in dusty media, but also includes modules for gas line
transfer. Typical applications would be protoplanetary disks, pre- and proto-stellar molecular cloud cores, and similar
objects. It does not treat photoionization of gas, nor does it treat chemistry. It can self-consistently compute dust
temperatures for the radiative transfer, but it is not equipped for self-consistent gas temperature computations (as this
requires detailed coupling to photochemistry). The main strength of RADMC-3D lies in the ﬂexibility of the spatial
setup of the models: One can create or use parameterized dust and/or gas density distributions, or one can import these
from snapshots of hydrodynamic simulations.
1.2 Capabilities
Here is a list of current and planned features. Those features that are now already working are marked with [+], while
those which are not yet (!!) built in are marked with [-]. Those that are currently being developed are marked with [.]
and those that are ready, but are still in the testing phase are marked with [t].
1. Coordinate systems:
1. [+] Cartesian coordinates (3-D)
2. [+] Spherical coordinates (1-D, 2-D and 3-D)
1. Gridding systems (regular and adaptive mesh reﬁnement grids are available for cartesian and spherical coordi-
nates):
1. [+] Regular
2. [+] Adaptive Mesh Reﬁnement: oct-tree style
3. [+] Adaptive Mesh Reﬁnement: layered (‘patch’) style
4. [-] Voronoi gridding [To be implemented on request]
1. Radiation mechanisms:
1. [+] Dust continuum, thermal emission
2. [+] Dust continuum scattering:
1. [+] ...in isotropic approximation
2. [+] ...with full anisotropy
3. [+] ...with full Stokes and Polarization
1

radmc3d, Release 2.0
1. [-] Dust quantum heated grains [To be implemented on request]
2. [t] Polarized dust emission by aligned grains [ﬁrst test version]
3. [+] Gas line transfer (LTE)
4. [+] Gas line transfer (non-LTE: LVG)
5. [+] Gas line transfer (non-LTE: LVG + Escape Probability)
6. [-] Gas line transfer (non-LTE: full transfer)
7. [+] Gas line transfer with user-deﬁned populations
8. [+] Gas continuum opacity and emissivity sources
2. Radiation netto sources for continuum:
1. [+] Discrete stars positioned at will
2. [t] Continuous ‘starlike’ source
3. [t] Continuous ‘dissipation’ source
4. [t] External ‘interstellar radiation ﬁeld’
3. Imaging options:
1. [+] Observer from ‘inﬁnite’ distance
2. [+] Zoom-in at will
3. [+] Flux-conserving imaging, i.e. pixels are recursively reﬁned
4. [+] A movie-making tool
5. [+] Multiple wavelengths in a single image
6. [+] Local observer with perspective view (for PR movies!)
4. Spectrum options:
1. [+] SED spectrum (spectrum on ‘standard’ wavelength grid)
2. [+] Spectrum on any user-speciﬁed wavelength grid
3. [+] Spectrum of user-speciﬁed sub-region (pointing)
4. [t] Speciﬁcation of size and shape of a primary ‘beam’ for spectra
5. User ﬂexibility:
1. [+] Free model speciﬁcation via tabulated input ﬁles
2. [+] Easy special-purpose compilations of the code (optional)
6. Front-end Python packages:
1. [+] Python simple tools for RADMC-3D
2. [+] Python RADMC-3D library {smalltt radmc3dPy} (author: A. Juhasz)
7.
1. [+] Stars can be treated as point-sources or as spheres
2. [+] Option to calculate the mean intensity 𝐽𝜈(⃗𝑥) in the model
3. [+] OpenMP parallellization of the Monte Carlo
2
Chapter 1. Introduction

radmc3d, Release 2.0
1.3 Version tracker
The RADMC-3D software package in under continuous development. A very detailed development log-book is found
in the git repository. A more user-friendly overview of the development history can be found in this manual, in
appendix ref{chap-development-history}.
1.4 Copyright
RADMC-3D was developed from 2007 to 2010/2011 at the Max Planck Institute for Astronomy in Heidelberg, funded
by a Max Planck Research Group grant from the Max Planck Society. As of 2011 the development continues at the
Institute for Theoretical Astrophysics (ITA) of the Zentrum für Astronomy (ZAH) at the University of Heidelberg.
The use of this software is free of charge. However, it is not allowed to distribute this package without prior
consent of the lead author (C.P. Dullemond). Please refer any interested user to the web site of this software
where the package is available, which is currently:
http://www.ita.uni-heidelberg.de/~dullemond/software/radmc-3d
or the github repository:
https://github.com/dullemond/radmc3d-2.0
The github repository will always have the latest version, but it may not be always the most stable version (though
usually it is).
1.5 Contributing authors
The main author of RADMC-3D is Cornelis P. Dullemond. However, the main author of the radmc3dPy Python
package is Attila Juhasz.
Numerous people have made contributions to RADMC-3D. Major contributions are from:
• Michiel Min
• Attila Juhasz
• Adriana Pohl
• Rahul Shetty
• Farzin Sereshti
• Thomas Peters
• Benoit Commercon
• Alexandros Ziampras
The code proﬁted from testing, feedback and bug reports from (incomplete list):
• Daniel Harsono
• Rainer Rolffs
• Laszlo Szucs
• Sean Andrews
• Stella Offner
1.3. Version tracker
3

radmc3d, Release 2.0
• Chris Beaumont
• Katrin Rosenfeld
• Soren Frimann
• Jon Ramsey
• Seokho Lee
• Blake Hord
• Tilman Birnstiel
and others.
1.6 Disclaimer
IMPORTANT NOTICE 1: I/We reject all responsibility for the use of this package. The package is provided as-
is, and we are not responsible for any damage to hardware or software, nor for incorrect results that may result
from the software. The user is fully responsible for any results from this code, and we strongly recommend
thorough testing of the code before using its results in any scientiﬁc papers.
IMPORTANT NOTICE 2: Any publications which involve the use of this software must mention the name of
this software package and cite the accompanying paper once it is published (Dullemond et al.in prep), or before
that the above mentioned web site.
4
Chapter 1. Introduction

CHAPTER
TWO
QUICKSTARTING WITH RADMC-3D
In general I recommend reading the manual fully, but it is often useful to get a quick impression of the package with a
quick-start. To make your ﬁrst example model, this is what you do:
1. When you read this you have probably already unzipped this package, or cloned the git repository. You should
ﬁnd, among others, a src/ directory and a examples/ directory. Go into the src/ directory.
2. Edit the src/Makefile ﬁle, and make sure to set the FF variable to the Fortran-90 compiler you have installed
on your system.
3. Type make. If all goes well, this should compile the entire code and create an executable called radmc3d.
4. Type make install. If all goes well this should try to create a link to radmc3d in your $HOME/bin/
directory, where $HOME is your home directory. If this $HOME/bin/ directory does not exist, it will ask to
make one.
5. Make sure to have the $HOME/bin/ directory in your path. If you use, for instance, the bash shell, you do this
by setting the PATH variable by adding a line like export PATH=$HOME/bin:\$PATH to your $HOME/
.bashrc ﬁle. If you change these things you may have to open a new shell to make sure that the shell now
recognizes the new path.
6. Check if the executable is OK by typing radmc3d in the shell. You should get a small welcoming message by
the code.
7. Now enter the directory examples/run_simple_1/. This is the simplest example model.
8. Type python problem_setup.py (Note: you must have a working Python distribution on your computer,
which is reasonably up to date, with numpy and matplotlib libraries included). This will create a series of
input ﬁles for RADMC-3D.
9. Type radmc3d mctherm. This should let the code do a Monte Carlo run. You should see Photon nr
1000, followed by Photon nr 2000, etc until you reach Photon nr 1000000. The Monte Carlo mod-
eling for the dust temperatures has now been done. A ﬁle dust_temperature.dat should have been
created.
10. Type radmc3d image lambda 1000 incl 60 phi 30. This should create an image with the camera
at inclination 60 degrees (from pole-on), and rotated 30 degrees (along the polar axis, clockwise, i.e.the object
rotating counter-clockwise), at wavelength 𝜆= 1000 𝜇m (i.e. at 1 millimeter wavelength). The ﬁle that contains
the image is image.out. It is a text ﬁle that can be read with the simpleread.py tool in the directory
python/radmc3d_tools/.
If you experience troubles with the above steps, and you cannot ﬁx it, please read the next chapters for more details.
5

radmc3d, Release 2.0
6
Chapter 2. Quickstarting with RADMC-3D

CHAPTER
THREE
OVERVIEW OF THE RADMC-3D PACKAGE
3.1 Introduction
The RADMC-3D code is written in fortran-90 and should compile with most f90 compilers without problems. It needs
to be compiled only once for each platform.
The executable is called radmc3d and it performs all the model calculations of the RADMC-3D package, for instance
the Monte Carlo simulations, ray-tracing runs (images, spectra), etc. There is also a set of useful subroutines written
in the Python language to use the radmc3d code, but radmc3d can also run without it. In that case the user will
have to write his/her own pre- and post-processing subroutines.
3.2 Requirements
The following pre-installed software is required:
1. Operating system: Unix-like (e.g. Linux or MacOSX)
This package runs under Unix-like environment (e.g. Linux or MacOSX), but has not been tested under Win-
dows. There is no particular reason why it should not also run under Windows, but it would require different
ways of ﬁle handling. In this manual we always assume a Unix-like environment, in which we will make use of
a bash command-line interface (CLI). We will call this the shell.
2. make or gmake
This is the standard tool for compiling packages on all Unix/Linux/MacOS-based systems.
3. perl
This is a standard scripting language available on most or all Unix/Linux-based systems. If you are in doubt:
type which perl to ﬁnd the location of the perl executable. See http://www.perl.org/ for details on perl,
should you have any problems. But on current-day Unix-type operating systems perl is nearly always installed
in the /usr/bin/ directory. If you do not have Perl installed, you can also do without. Its sole use is to
copy the executables into your home $HOME/bin/ directory for quick access from the Unix/Linux/MacOS
command line. You can work around that, if necessary.
4. A fortran-90 compiler
Preferably the gfortran compiler (which the current installation assumes is present on the system). Website:
http://gcc.gnu.org/fortran/. Other compilers may work, but have not been tested yet.
5. An OpenMP-fortran-90 compiler (optional)
Only needed if you want to use the parallelized OpenMP version for the thermal Monte Carlo (for faster exe-
cution). Preferably the GNUOpenMP/GOMP compiler which is an implementation of OpenMP for the Fortran
7

radmc3d, Release 2.0
compiler in the GNU Compiler Collection. Websites: http://openmp.org/wp and http://gcc.gnu.org. Other com-
pilers may work, but we give no guarantee.
6. Python version 3 with standard libraries
The core RADMC-3D code radmc3d (written in Fortran-90) is the raw workhorse code that reads some input
ﬁles and produces some output ﬁles. Typically you will not need to worry about the internal workings of the
RADMC-3D code. All you need to do is produce the proper input ﬁles, run radmc3d, and read the output
ﬁles for post-processing (such as displaying and analyzing the results). This pre- and post-processing is done in
Python. This RADMC-3D distribution provides you with the Python tools you need, though you will likely want
to program your own additional Python code to adjust the models to your own needs. To use the Python tools
provided in this RADMC-3D distribution, you need Python version 3 (though most things should also work
with the depricated Python 2), with a set of standard libraries such as numpy and matplotlib. Typically we
will assume that Python is used as a Python or iPython command-line interface, which we shall call the Python
command line (as opposed to the shell). The user can, of course, also use Jupyter Notebooks instead. But for
the sake of clarity, in this manual we assume the use of Python the Python command line.
Note that the Monte Carlo code RADMC-3D itself (radmc3d) is in Fortran-90. Only the creation of the input
ﬁles (and hence the problem deﬁnition) and the analysis of the output ﬁles is done in Python. The user is of course
welcome to use other ways to create the input ﬁles for RADMC-3D if he/she is not able or willing to use Python for
whatever reason. Therefore Python is not strictly required for the use of this code. However, all examples and support
infrastructure is provided in Python.
3.3 Contents of the RADMC-3D package
3.3.1 RADMC-3D package as a .zip archive
If you obtain RADMC-3D from its website, it will be packed in a zip archive called radmc-3d_v*.*_dd.mm.
yy.zip where the *.* is the version number and dd.mm.yy is the date of this version. To unpack on a linux, unix
or Mac OS X machine you type:
unzip <this archive file>
i.e. for example for radmc-3d_v2.0_25.08.20.zip you type:
unzip radmc-3d_v2.0_25.08.20.zip
3.3.2 RADMC-3D package from the github repository
If you obtain RADMC-3D by cloning its github repository, you will get a copy of the full git repository of RADMC-
3D. In principle this is not much different from unzipping the .zip archive. But it is more powerful: You can more
easily stay up to date with the latest bugﬁxes, and you can see the entire development history of this version of the
code. See https://git-scm.com/book/en/v2 for an extensive documentation of how to use git.
The way to produce a clone of RADMC-3D in the directory where your shell is currently is, is like this:
git clone https://github.com/dullemond/radmc3d-2.0.git
This will create the directory radmc3d-2.0/. At any time you can pull the latest version from the repository like
this:
cd radmc3d-2.0/
git pull
8
Chapter 3. Overview of the RADMC-3D package

radmc3d, Release 2.0
Keep in mind, however, that while the repository is always the very latest version, this comes with a (small) risk that
some new features may not have been tested well, or (new) bugs may have been introduced. Overall, however, we
advise to use the github repository instead of the .zip archive from the website.
3.3.3 Contents of the package
The RADMC-3D package has the following subdirectory structure:
src/
python/
examples/
run_simple_1/
run_simple_1_userdef/
run_simple_1_userdef_refined/
.
.
.
opac/
manual/
plus some further directories.
The ﬁrst directory, src/, contains the fortran-90 source code for RADMC-3D. The second directory, python/,
contains two sets of Python modules that are useful for model preparation and post-processing. One is a directory
called radmc3d_tools/, which contains some simple Python tools that might be useful. The other is a directory
called radmc3dPy/, which is a high-level stand-alone Python library developed by Attila Juhasz for RADMC-3D.
The third directory contains a series of example models. The fourth directory, opac/ contains a series of tools and
data for creating the opacity ﬁles needed by RADMC-3D (though the example models all have their own opacity data
already included), The ﬁfth directory contains this manual.
3.4 Units: RADMC-3D uses CGS units
The RADMC-3D package is written such that all units are in CGS (length in cm, time in sec, frequency in Hz, energy
in erg, angle in steradian). There are exceptions:
• Wavelength is usually written in micron
• Sometimes angles are in degrees (internally in radian, but input as degrees)
3.4. Units: RADMC-3D uses CGS units
9

radmc3d, Release 2.0
10
Chapter 3. Overview of the RADMC-3D package

CHAPTER
FOUR
INSTALLATION OF RADMC-3D
Although the RADMC-3D package contains a lot of different software, the main code is located in the src/ directory,
and is written in Fortran-90. The executable is radmc3d. Here we explain how to compile the fortran-90 source codes
and create the executable radmc3d.
4.1 Compiling the code with ‘make’
To compile the code, enter the src/ directory in your shell. You now may need to edit the Makefile in this directory
using your favorite text editor and replace the line
FF = gfortran -fopenmp
with a line specifying your own compiler (and possibly OpenMP directive, if available). If, of course, you use gfortran,
you can keep this line. But if you use, e.g., ifort, then replace the above line by
FF = ifort -openmp
(note the slightly different OpenMP directive here, too). If you save this ﬁle, and you are back in the shell, you can
compile the radmc3d code by typing
make
in the shell. If all goes well, you have now created a ﬁle called radmc3d in the src/ directory.
If, for whatever reason, the OpenMP compilation does not work, you can also compile the code in serial mode. Simply
remove the -fopenmp directive.
4.2 The install.perl script
If instead of typing just make you type
make install
(or you ﬁrst type make and then make install, it is the same), then in addition to creating the executable, it also
automatically executes a perl script called install.perl (located also in the src/ directory). This PERL script
installs the code in such a way that it can be conveniently used in any directory. What it does is:
• It checks if a bin/ directory is present in your home directory (i.e. a $HOME/bin/ directory). If not, it asks
if you want it to automatically make one.
11

radmc3d, Release 2.0
• It checks if the $HOME/bin/ directory is in the path of the currently used shell. This is important to allow the
computer to look for the program radmc3d in the $HOME/bin/ directory. If you use a bash shell, then you
can add the following line to your $HOME/.bashrc:
export PATH=/myhomedirectory/bin/python:$PATH
• It creates a ﬁle radmc3d in this $HOME/bin/ directory with the correct executable permissions. This ﬁle is
merely a dummy executable, that simply redirects everything to the true radmc3d executable located in your
current src/ directory. When you now open a new shell, the path contains the $HOME/bin/ directory, and
the command radmc3d is recognized. You can also type source $HOME/.bashrc followed by rehash.
This also makes sure that your shell recognizes the radmc3d command.
• It checks if a python/ subdirectory exists in the above mentioned bin/ directory, i.e.a $HOME/bin/
python/ directory. If not, it asks if you want it to automatically create one.
• If yes, then it will copy all the ﬁles ending with .py in the python/radmc3d_tools/ directory of the
distribution to that $HOME/bin/python/radmc3d_tools/ directory. This is useful to allow you to make
an PYTHONPATH entry to allow python to ﬁnd these python scripts automatically.
Note that this perl script installs the code only for the user that installs it. A system-wide installation is not useful,
because the code package is not very big and it should remain in the control of the user which version of the code
he/she uses for each particular problem.
If all went well, then the perl.install script described here is called automatically once you type make
install following the procedure in Section Compiling the code with ‘make’.
Before the installation is recognized by your shell, you must now either type rehash in the shell or simply open a
new shell.
How do you know that all went OK? If you type radmc3d in the shell the RADMC-3D code should now be executed
and give some comments. It should write:
================================================================
WELCOME TO RADMC-3D: A 3-D CONTINUUM AND LINE RT SOLVER
VERSION 2.0
(c) 2008-2020 Cornelis Dullemond
Please feel free to ask questions. Also please report
bugs and/or suspicious behavior without hestitation.
The reliability of this code depends on your vigilance!
dullemond@uni-heidelberg.de
To keep up-to-date with bug-alarms and bugfixes, register to
the RADMC-3D forum:
http://radmc3d.ita.uni-heidelberg.de/phpbb/
Please visit the RADMC-3D home page at
http://www.ita.uni-heidelberg.de/~dullemond/software/radmc-3d/
================================================================
Nothing to do... Use command line options to generate action:
mctherm
: Do Monte Carlo simul of thermal radiation
mcmono
: Do Monte Carlo simul only for computing mean intensity
spectrum
: Make continuum spectrum
image
: Make continuum image
on the screen (or for newer versions of RADMC-3D perhaps some more or different text). This should also work from
any other directory.
12
Chapter 4. Installation of RADMC-3D

radmc3d, Release 2.0
4.3 What to do if this all does not work?
In case the above compilation and installation does not work, here is a proposed procedure to do problem hunting:
1. First, answer the following questions:
• Did you type make install in the src/ directory? I mean, did you not forget the install part?
• Did you put $HOME/bin/ in your path (see above)?
• If you just added $HOME/bin/ to your path, did you follow the rest of the procedure (either closing the
current shell and opening a new shell or typing the source and rehash commands as described above)?
If this does not help, then continue:
2. Close the shell, open a new shell.
3. Go to the RADMC-3D src/ directory.
4. Type ./radmc3d. This should give the above message. If not, then make sure that the compilation went right
in the ﬁrst place:
5. Type rm -f radmc3d, to make sure that any old executable is not still present.
6. Type make clean. This should return the sentence OBJECT and MODULE files removed.
7. In case the problem lies with the OpenMP parallellization, you could do cp Makefile_normal
Makefile, which switches off the OpenMP compilation.
8. Then type make.
This should produce a set of lines, each representing a compilation of a module, e.g.
gfortran -c -O2 ./amr_module.f90 -o amr_module.o, etc. The ﬁnal line should be some-
thing like gfortran -O2 main.o ..... gascontinuum_module.o -o radmc3d.
If instead
there is an error message, then do the following:
• Check if the compiler used (by default gfortran) is available on your computer system.
• If you use an other compiler, check if the compiler options used are recognized by your compiler.
• Check if the executable radmc3d is now indeed present. If it is not present, then something
must have gone wrong with the compilation. So then please check the compilation and linking
stage again carefully.
If you followed all these procedures, but you still cannot get even the executable in the src/ direc-
tory to run by typing (in the src/ directory) ./radmc3d (don’t forget the dot slash!), then please
contact the author.
9. At this point we assume that the previous point worked. Now go to another directory (any one), and type
radmc3d. This should also give the above message. If not, but the radmc3d executable was present, then
apparently the shell path settings are wrong. Do this:
• Check if, in the current directory (which is now not src/) there is by some accident another copy of the
executable radmc3d. If yes, please remove it.
• Type which radmc3d to ﬁnd out if it is recognized at all, and if yes, to which location it points.
• Did you make sure that the shell path includes the $HOME/bin/ directory, as it should? Otherwise the
shell does not know where to ﬁnd the $HOME/bin/radmc3d executable (which is a perl link to the
src/radmc3d executable).
• Does the ﬁle $HOME/bin/radmc3d perl ﬁle exist in the ﬁrst place? If no, check why not.
4.3. What to do if this all does not work?
13

radmc3d, Release 2.0
• Type less $HOME/bin/radmc3d and you should see a text with ﬁrst line being #!/usr/bin/
perl and the second line being someting like system("/Users/user1/radmc-3d/version_2.
0/src/radmc3d @ARGV"); where the /Users/user1 should of course be the path to your home
directory, in fact to the directory in which you installed RADMC-3D.
If this all brings you no further, please ﬁrst ask your system administrators if they can help. If not, then please contact
the author.
4.4 Installing the simple Python analysis tools
RADMC-3D offers (in addition to the model setup scripts in the examples/ subdirectories) two Python support
libraries:
1. python/radmc3d_tools/
This library contains only some bare-bones small Python scripts.
2. python/radmc3dPy/
This library is a sophisticated stand-alone library developed by Attila Juhasz, and further maintained together
with the RADMC-3D main author.
4.4.1 How to install and use the python/radmc3d_tools/
The installation of the python/radmc3d_tools should be automatic when you type make install in the
src/ code directory (see above). It will copy the ﬁles to the bin/python/radmc3d_tools/ directory in your
home directory. If this directory does not exist, you will be asked if you want it to be created. If you conﬁrm (typing
‘y’), then the ﬁles from the python/radmc3d_tools/ directory will be copied into the $HOME/bin/python/
radmc3d_tools/ directory.
Now you need to make sure that Python knows that these tools are there. In Python here are two ways how you can
make sure that Python automatically ﬁnds these scripts:
1. Under Unix/Linux/MacOSX you can set the PYTHONPATH directly in your .bashrc ﬁle. For example: in
.bashrc (if you use the bash shell) you can write:
export PYTHONPATH=$HOME/bin/python:$PYTHONPATH
(where $HOME is your home directory name).
1. Alternatively you can set the PYTHONPATH directly from within Python with the python command:
import os
import sys
home = os.environ["HOME"]
sys.path.append(home+'/bin/python')
If all goes well, if you now start Python you should be able to have access to the basic Python tools of RADMC-3D
directly. To test this, try typing from radmc3d_tools.simpleread import * in Python. If this gives an
error message that simpleread.py cannot be found, then please ask your system administrators how to solve this.
You may ask why ﬁrst copy these ﬁles to $HOME/bin/python/radmc3d_tools/ and not point PYTHONPATH
directly to the python/radmc3d_tools in your RADMC-3D distribution? The reason is that if you have multiple
versions of RADMC-3D on your computer system, you always are assured that Python ﬁnds the python routines
belonging to the latest installation of RADMC-3D (note: only assured if that latest compilation was done with make
install).
14
Chapter 4. Installation of RADMC-3D

radmc3d, Release 2.0
Now you should be ready to use the tools. The most important one would be the simpleread.py tool, which
contains a set of functions for reading typical RADMC-3D input and output ﬁles (though only for regular model grid,
not for octree grids). In a Python command line interface you can import them by:
from radmc3d_tools import simpleread
And you can then, for instance, read the dust density ﬁle with:
d = simpleread.read_dustdens()
Here, d is now an object containing a d.grid subobject (which contain information about the grid) and the dust
density array d.rhodust. Have a look at the various functions in simpleread, to see what is available.
4.4.2 How to install and use the python/radmc3dPy library
The installation of the python/radmc3dPy package is described in the python/radmc3dPy/README ﬁle. In
short, by going into the python/radmc3dPy/ directory and typing in the shell:
python setup.py install --user
it should install itself right into your Python distribution. For instance, if you have anaconda3 on a Mac, it would
copy the ﬁles into the directory
$HOME/.local/lib/python3.7/site-packages/radmc3dPy/
Python knows where to ﬁnd it there.
Now you should be ready to use radmc3dPy, by importing it:
import radmc3dPy
radmc3dPy consists of several sub libraries such as radmc3dPy.analyze and radmc3dPy.image. For in-
stance, to read the dust density distribution, you could do this:
from radmc3dPy import analyze
d = readData(ddens=True)
The d.rhodust array now contains the dust density.
For more information, please consult the radmc3dPy documentation in the python/radmc3dPy/doc/ directory.
4.5 Making special-purpose modiﬁed versions of RADMC-3D (op-
tional)
For most purposes it should be ﬁne to simply compile the latest version of RADMC-3D once-and-for-all, and simply
use the resulting radmc3d executable for all models you make. Normally there is no reason to have to modify the
code, because models can be deﬁned quite ﬂexibly by preparing the various input ﬁles for RADMC-3D to your needs.
So if you are an average user, you can skip to the next subsection without problem.
But sometimes there is a good reason to want to modify the code. For instance to allow special behavior for a particular
model. Or for a model setup that is simply easier made internally in the code rather than by preparing large input ﬁles.
One can imagine some analytic model setup that might be easier to create internally, so that one can make use of the
full AMR machinery to automatically reﬁne the grid where needed. Having to do so externally from the code would
require you to set up your own AMR machinery, which would be a waste of time.
4.5. Making special-purpose modiﬁed versions of RADMC-3D (optional)
15

radmc3d, Release 2.0
The problem is that if the user would modify the central code for each special purpose, one would quickly lose track
of which modiﬁcation of the code is installed right now.
Here is how this problem is solved in RADMC-3D:
• For most purposes you can achieve your goals by only editing the ﬁle userdef_module.f90. This is a
set of standard subroutines that the main code calls at special points in the code, and the user can put anything
he/she wants into those subroutines. See Chapter Modifying RADMC-3D: Internal setup and user-speciﬁed
radiative processes for more information about these standard subroutines. This method is the safest way to
create special-purpose codes. It means (a) that you know that your modiﬁcation cannot do much harm unless
you make really big blunders, because these subroutines are meant to be modiﬁed, and (b) you have all your
modiﬁcations only in one single ﬁle, leaving the rest of the code untouched.
• You can create a local version of the code, without touching the main code. Suppose you have a model directory
run_mymodel and for this model you want to make a special-purpose version of the code. This is what you
do:
1. Copy the Makeﬁle from the src/ directory into run_mymodel.
2. Copy the .f90 ﬁle(s) you want to modify from the src/ directory into run_mymodel. Usually you
only want to modify the userdef_module.f90 ﬁle, but you can also copy any other ﬁle if you want.
3. In the run_mymodel/Makefile replace the SRC = . line with SRC = XXXXXX, where XXXXXX
should be the full path to the src/ directory. An example line is given in the Makeﬁle, but is commented
out.
4. In the run_mymodel/Makefile make sure that all the .f90 ﬁles that should remain as they are have
a $(SRC)/ in front of the name, and all the .f90 ﬁles that you want to modify (and which now have
a copy in the run_mymodel directory) have a ./ in front of the name. By default all .f90 ﬁles have
$(SRC)/ in front of the name, except the userdef_module.f90 ﬁle, which has a ./ in front of the
name because that is the ﬁle that is usually the one that is going to be edited by you.
5. Now edit the local .f90 ﬁles in the run_mymodel directory in the way you want. See Chapter Modifying
RADMC-3D: Internal setup and user-speciﬁed radiative processes for more details.
6. Now inside the run_mymodel directory you can now type make and you will create your own local
radmc3d executable. NOTE: Do not type make install in this case, because it should remain a local
executable, only inside the run_mymodel directory.
7. If you want (though this is not required) you can clean up all the local .o and .mod ﬁles by typing make
clean, so that your run_mymodel directory is not ﬁlled with junk.
8. You can now use this special purpose version of radmc3d by simply calling on the command line: ./
radmc3d, with any command-line options you like. Just beware that, depending on the order in which
you have your paths set (in tcsh or bash) typing just radmc3d may instead use the global version (that you
may have created in the src/ directory with make install). So to be sure to use the local version,
just put the ./ in front of the radmc3d.
Note: In chapter Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes there is more informa-
tion on how to set up models internally in the code using the method described here.
Note: You can use make clean to remove all the .o and .mod ﬁles from your model directory, because they can be
annoying to have hanging around. By typing make cleanmodel you remove, in addition to the .o and .mod ﬁles,
also all model input and output ﬁles, with the exception of dust opacity or molecular data ﬁles (because these latter
ﬁles are usually not created locally by the problem_setup.py script). By typing make cleanall you remove
everything except the basic ﬁles such as the Makefile, any .f90 ﬁles, any .py ﬁles, the dust opacity or molecular
data ﬁles and README ﬁles.
16
Chapter 4. Installation of RADMC-3D

CHAPTER
FIVE
BASIC STRUCTURE AND FUNCTIONALITY
RADMC-3D is a very versatile radiative transfer package with many possibilities. As a consequence it is a rather
complex package. However, we have tried to keep it still as easy as possible to use as a ﬁrst-time user. We tried to do
so by keeping many of the sophisticated options ‘hidden’ and having many default settings already well-chosen. The
idea is that one can already use the code at an entry level, and then gradually work oneself into the more fancy options.
RADMC-3D is a general-purpose package, so there are no ‘built-in’ models inside the radmc3d executable (Except
if you insert one yourself using the userdef module, see Chapter Modifying RADMC-3D: Internal setup and user-
speciﬁed radiative processes). For instance, if you want to model a protoplanetary disk, then you would have to design
the grid and density structure of the disk on this grid yourself. To make it easier for the user, we have provided several
Python-scripts as examples. Among these examples is indeed a protoplanetary disk model. So this is as close as we
go to ‘built-in’ models: we provide, for some cases, already well-developed example models that you, the user, can
use out-of-the-box, or that you can adapt to your needs.
In this chapter we give an overview of the rough functionality of the code in its simplest form: ignoring all the hidden
fancy options and possibilities. For the details we then refer to the chapters ahead.
5.1 Basic dataﬂow
Let us ﬁrst clarify the basic philosophy of the code package (details will be done later). When we talk about RADMC-
3D we talk about the fortran-90 program. The source codes are in the directory src/ and the executable is called
radmc3d. This is the code that does all the main calculations. You can call the code from the bash shell (in
Unix/Linux/MacOSX systems) and you can specify command-line options to tell RADMC-3D what you want it to do.
The code RADMC-3D is in a way just a dumb computational engine. It has no physical data (such as opacities or
material properties) implemented, nor does it have any model implemented. It is totally dependent on input ﬁles of
various kinds. These input ﬁles have ﬁlenames that end in .inp, or .binp, dependent on whether the data in ASCII,
or binary form. You, the user, will have to create these input ﬁles. RADMC-3D will simply look if an .inp, or a
.binp ﬁle is present, and will switch to ASCII, dependent on which ﬁle-extension it ﬁnds.
After you run RADMC-3D (by calling radmc3d with the appropriate command-line options) you will see that the
code will have produced one or more output ﬁles, with ﬁlenames ending in .out or .bout. Whether RADMC-3D
produces ASCII or binary ﬁles, depends on a ﬂag called rto_style that you can set (see Chapter Binary I/O ﬁles).
IMPORTANT NOTE: In this manual we will mostly refer to the ASCII form of input and output ﬁles for convenience.
But each time we refer to an *.inp, *.dat or *.out ﬁle, we implicitly assume that this could also be a *.binp, *.bdat or
*.bout ﬁle.
This basic dataﬂow is shown in Fig. Pictographic representation of the basic dataﬂow of RADMC-3D. The user
produces the input ﬁles; RADMC-3D reads them, performs the calculation, and produces output ﬁles. The user can
then analyze the output ﬁles..
Not always can RADMC-3D produce its output ﬁles in one go. Sometimes it has to use a two-stage procedure: For
dust continuum radiative transfer the dust temperatures are computed ﬁrst (stage 1), and the images and/or spectra
17

radmc3d, Release 2.0
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
radiative transfer
calculation
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Fig. 5.1: Pictographic representation of the basic dataﬂow of RADMC-3D. The user produces the input ﬁles; RADMC-
3D reads them, performs the calculation, and produces output ﬁles. The user can then analyze the output ﬁles.
are rendered after that (stage 2). Between stage 1 and stage 2 an intermediate ﬁle is then produced (with ﬁlename
ending in .dat or .bdat), which in the case of dust continuum radiative transfer is dust_temperature.dat
(or *.bdat).
This basic dataﬂow is shown in Fig. Pictographic representation of the dataﬂow of RADMC-3D for the case of a
2-stage procedure, such as for dust continuum transfer. An intermediate ﬁle is produced that will be used by stage 2,
but of course the user can also analyze the intermediate ﬁle itself..
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
stage 1 calculation
(e.g. "mctherm")
Intermediate data files,
possible data formats:
***.dat (ascii), or
***.bdat (binary)
RADMC-3D
stage 2 calculation
(e.g. "image" 
or "spectrum")
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Fig. 5.2: Pictographic representation of the dataﬂow of RADMC-3D for the case of a 2-stage procedure, such as for
dust continuum transfer. An intermediate ﬁle is produced that will be used by stage 2, but of course the user can also
analyze the intermediate ﬁle itself.
Several of these input ﬁles contain large tables, for instance of the density at each grid point, or the stellar ﬂux at each
wavelength bin. It is, of course, impossible to create these dataﬁles by hand. The idea is that you design a program
(in any language you like) that creates these dataﬁles. In that program you essentially ‘program the model’. We have
provided a number of example model setups in the examples/ directory. For these examples models the setup
programs were written in Python (their ﬁlenames all start with problem_ and end with .py). For you as the user it
is therefore the easiest to start from one of these examples and modify the Python code to your needs. However, if you
prefer to use another language, you can use the examples to see how the input ﬁles were generated and then program
this in another programming language.
Note: The Python ﬁles called problem_*.py are meant to be edited and changed by you! They are templates from
which you can create your own models.
For the analysis of the output ﬁles created by RADMC-3D you can use your own favorite plotting or data-analysis
software. But also here we provide some tools in Python. These Python routines are in the python/ directory.
Typically you will create your own program, e.g. plot_model.py or so, that will use these subroutines, e.g. by
putting in the ﬁrst line: from radmc3dPy import *. In this way Python is used also as a post-processing tool.
But again: this can also be done in another language.
This procedure is shown in Fig. Pictographic representation of how the Python programs in the example directories
are used to create the input ﬁles of RADMC-3D. for the single-stage dataﬂow and in Fig. Pictographic representation
of the dataﬂow of RADMC-3D for the case of a 2-stage procedure, such as for dust continuum transfer. An intermediate
ﬁle is produced that will be used by stage 2, but of course the user can also analyze the intermediate ﬁle itself. for the
two-stage dataﬂow.
18
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
radiative transfer
calculation
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Python
Create model and
write the input files
Python
Read output files,
and analyze / display
results
Fig. 5.3: Pictographic representation of how the Python programs in the example directories are used to create the
input ﬁles of RADMC-3D.
Input data files, in two 
possible data formats:
***.inp (ascii), or
***.binp (binary)
RADMC-3D
stage 1 calculation
(e.g. "mctherm")
Intermediate data files,
possible data formats:
***.dat (ascii), or
***.bdat (binary)
RADMC-3D
stage 2 calculation
(e.g. "image" 
or "spectrum")
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
Python
Create model and
write the input files
Python
Read output files,
and analyze / display
results
Python
(optional)
Read intermediate files,
and analyze / display
to check if they are ok
Fig. 5.4: Pictographic representation of the dataﬂow of RADMC-3D for the case of a 2-stage procedure, such as for
dust continuum transfer. An intermediate ﬁle is produced that will be used by stage 2, but of course the user can also
analyze the intermediate ﬁle itself.
5.2 Radiative processes
Currently RADMC-3D handles the following radiative processes:
• Dust thermal emission and absorption
RADMC-3D can compute spectra and images in dust continuum. The dust temperature must be known in
addition to the dust density. In typical applications you will know the dust density distribution, but not the dust
temperature, because the latter is the results of a balance between radiative absorption and re-emission. So in
order to make spectra and images of a dusty object we must ﬁrst calculate the dust temperature consistently.
This can be done with RADMC-3D by making it perform a ‘thermal Monte Carlo’ simulation (see Chapter Dust
continuum radiative transfer). This can be a time-consuming computation. But once this is done, RADMC-3D
writes the resulting dust temperatures out to the ﬁle dust_temperature.dat, which it can then later use
for images and spectra. We can then call RADMC-3D again with the command to make an image or a spectrum
(see Chapter Dust continuum radiative transfer). To summarize: a typical dust continuum radiative transfer
calculation goes in two stages:
1. A thermal Monte Carlo simulation with RADMC-3D to compute the dust temperatures.
2. A spectrum or image computation using ray-tracing with RADMC-3D.
• Dust scattering
Dust scattering is automatically included in the thermal Monte Carlo simulations described above, as well as in
the production of images and spectra. For more details, consult Chapter Dust continuum radiative transfer.
• Gas atomic/molecular lines
RADMC-3D can compute spectra and images in gas lines (see Chapter Line radiative transfer). The images are
also known as channel maps. To compute these, RADMC-3D must know the population densities of the various
atomic/molecular levels. For now there are the following options how to let RADMC-3D know these values:
5.2. Radiative processes
19

radmc3d, Release 2.0
– Tell RADMC-3D to assume that the molecules or atoms are in Local Thermodynamic Equilibrium (LTE),
and specify the gas temperature at each location to allow RADMC-3D to compute these LTE level pop-
ulations. Note that in principle one is now faced with the same problem as with the dust continuum: we
need to know the gas temperature, which we typically do not know in advance. However, computing the
gas temperature self-consistently is very difﬁcult, because it involves many heating and cooling processes,
some of which are very complex. That is why most line radiative transfer codes assume that the user gives
the gas temperature as input. We do so as well. If you like, you can tell RADMC-3D to use the (previously
calculated) dust temperature as the gas temperature, for convenience.
– Deliver RADMC-3D an input ﬁle with all the level populations that you have calculated youself using
some method.
– Tell RADMC-3D to compute the level populations according to some simple local non-LTE prescription
such as the Sobolev approximation (Large Velocity Gradient method) or the Escape Probability Method.
Currently RADMC-3D does not have a full non-local non-LTE computation method implemented. The reason
is that it is very costly, and for many applications presumably not worth the computational effort.
5.3 Coordinate systems
With RADMC-3D you can specify your density distribution in two coordinate systems:
• Cartesian coordinates: 3-D
The simplest coordinate system is the Cartesian coordinate system (𝑥, 𝑦, 𝑧). For now each model must be 3-D
(i.e. you must specify the densities and other quantities as a function of 𝑥, 𝑦and 𝑧).
• Cartesian coordinates: 1-D plane-parallel
This is like the normal cartesian coordinates, but now the 𝑥- and 𝑦- directions are inﬁnitely extended. Only the
𝑧-direction has ﬁnite-size cells, and hence the grid is only in 𝑧-direction. This mode is the usual plane-parallel
mode of radiative transfer. See Section 1-D Plane-parallel models for more details on this mode.
• Cartesian coordinates: 2-D pencil-parallel
This is the intermediate between full 3-D cartesian and 1-D plane-parallel. In this mode only the 𝑥-direction is
inﬁnitely extended and a ﬁnite grid is in both 𝑦and 𝑧directions. This mode is only useful in very special cases,
and is much less familiar to most - so use only when you are conﬁdent.
• Spherical coordinates
You can also specify your model in spherical coordinates (𝑟, 𝜃, 𝜑). These coordinates are related to the cartesian
ones by:
𝑥= 𝑟sin 𝜃cos 𝜑
𝑦= 𝑟sin 𝜃sin 𝜑
𝑧= 𝑟cos 𝜃
This means that the spatial variables (density, temperature etc) are all speciﬁed as a function of (𝑟, 𝜃, 𝜑). How-
ever, the location of the stars, the motion and direction of photon packages etc. are still given in cartesian
coordinates (𝑥, 𝑦, 𝑧). In other words: any function of space 𝑓(⃗𝑥) will be in spherical coordinates 𝑓(𝑟, 𝜃, 𝜑),
but any point-like speciﬁcation of position ⃗𝑥will be given as Cartesian coordinates ⃗𝑥= (𝑥, 𝑦, 𝑧). This hybrid
method allows us to do all physics in cartesian coordinates: photon packages or rays are treated always in carte-
sian coordinates, and so is the physics of scattering, line emission etc. Only if RADMC-3D needs to know what
the local conditions are (dust temperature, gas microturbulence, etc) RADMC-3D looks up which coordinates
(𝑟, 𝜃, 𝜑) belong to the current (𝑥, 𝑦, 𝑧) and looks up the value of the density, microturbulence etc.at that location
in the (𝑟, 𝜃, 𝜑) grid. And the same is true if RADMC-3D updates or calculates for instance the dust temperature:
it will compute the (𝑟, 𝜃, 𝜑) belong to the current (𝑥, 𝑦, 𝑧) and update the temperature in the cell belonging to
20
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
(𝑟, 𝜃, 𝜑). For the rest, all the physics is done in the Cartesian coordinate system. This has the major advantage
that we do not need different physics modules for cartesian and spherical coordinates. Most parts of the code
don’t care which coordinate system is used: they will do their own work in Cartesian coordinates. When using
spherical coordinates, please read Section Separable grid reﬁnement in spherical coordinates (important!).
5.4 The spatial grid
To specify the density or temperature structure (or any other spatial variable) as a function of spatial location we must
have a grid. There are two basic types of grids:
The standard gridding is a simple rectangular grid.
• Cartesian coordinates
When cartesian coordinates are used, this simply means that each cell is deﬁned as 𝑥𝑙< 𝑥< 𝑥𝑟, 𝑦𝑙< 𝑦< 𝑦𝑟
and 𝑧𝑙< 𝑧< 𝑧𝑟, where 𝑙and 𝑟stand for the left and right cell walls respectively.
• Spherical coordinates
When spherical coordinates are used, this simply means that each cell is deﬁned as 𝑟𝑙< 𝑟< 𝑟𝑟, 𝜃𝑙< 𝜃< 𝜃𝑟
and 𝜑𝑙< 𝜑< 𝜑𝑟. Note therefore that the shape of the cells in spherical coordinates is (in real space) curved.
For spherical coordinates the following four modes are available:
– 1-D Spherical symmetry:
All spatial functions depend only on 𝑟.
– 2-D Axial symmetry:
All spatial functions depend only on 𝑟and 𝜃.
– 2-D Axial symmetry with mirror symmetry:
All spatial functions depend only on 𝑟and 𝜃, where the 𝜃grid only covers the part above the 𝑧= 0 plane.
Internally it is in this mode assumed that all quantities below the 𝑧= 0 plane are equal to those above
the plane by mirror symmetry in the 𝑧= 0 plane. This saves a factor of two in computational effort for
Monte Carlo calculations, as well as in memory useage. Note that also the resulting output ﬁles such as
dust_temperature.dat will only be speciﬁed for 𝑧> 0.
– 3-D:
All spatial functions depend on all three variables 𝑟, 𝜃and 𝜑.
– 3-D with mirror symmetry:
All spatial functions depend on all three variables 𝑟, 𝜃and 𝜑, but like in the 2-D case only the upper part
of the model needs to be speciﬁed: the lower part is assumed to be a mirror copy.
When using spherical coordinates, please read Section Separable grid reﬁnement in spherical coordinates (im-
portant!).
In all cases these structured grids allow for oct-tree-style grid reﬁnement, or its simpliﬁed version: the layer-style grid
reﬁnement. See Section INPUT (required): amr_grid.inp and Chapter More information about the gridding for more
information about the gridding and the (adaptive) mesh reﬁnement (AMR).
5.4. The spatial grid
21

radmc3d, Release 2.0
5.5 Computations that RADMC-3D can perform
The code RADMC-3D (i.e. the executable radmc3d) is one code for many actions. Depending on which command-
line arguments you give, RADMC-3D can do various actions. Here is a list:
1. Compute the dust temperature:
With radmc3d mctherm you call RADMC-3D with the command of performing a thermal Monte Carlo
simulation to compute the dust temperature under the assumption that the dust is in radiative equilibrium with
its radiation ﬁeld. This is normally a prerequisite for computing SEDs and images from dusty objects (see
computing spectra and images below). The output ﬁle of this computation is dust_temperature.dat
which contains the dust temperature everywhere in the model.
2. Compute a spectrum or SED:
With radmc3d sed you call RADMC-3D with the command of performing a ray-tracing computation to
compute the spectral energy distribution (SED) for the model at hand.
Typically you ﬁrst need to have
called radmc3d mctherm (see above) beforehand to compute dust temperatures (unless you have cre-
ated the ﬁle dust_temperature.dat yourself because you have a special way of computing the dust
temperature). With radmc3d sed the spectrum is computed for the wavelengths points given in the ﬁle
wavelength_micron.inp, which is the same wavelength grid that is used for radmc3d mctherm.
If you want to compute the spectrum at wavelength other than those used for the thermal Monte Carlo
simulation, you should instead call radmc3d spectrum, and you have the full freedom to choose the
spectral wavelengths points at will, and you can specify these in various ways described in Section Spec-
ifying custom-made sets of wavelength points for the camera.
Most easily you can create a ﬁle called
camera_wavelength_micron.inp (see Section INPUT (optional): camera_wavelength_micron.inp)
and call RADMC-3D using radmc3d spectrum loadlambda. In all these cases the vantage point (where
is the observer) can of course be set as well, see Section Making SEDs, spectra, images for dust continuum and
Chapter Making images and spectra.
3. Compute an image:
With radmc3d image you call RADMC-3D with the command of performing a ray-tracing computation to
compute an image. You must specify the wavelength(s) at which you want the image by, for instance, calling
RADMC-3D as radmc3d image lambda 10, which makes the image at 𝜆= 10𝜇m. But there are other
ways by which the wavelength(s) can be set, see Section Specifying custom-made sets of wavelength points for
the camera. In all these cases the vantage point (where is the observer) can of course be set as well, see Section
Making SEDs, spectra, images for dust continuum and Chapter Making images and spectra.
4. Compute the local radiation ﬁeld inside the model:
With radmc3d mcmono you call RADMC-3D with the command of performing a wavelength-by-
wavlength monochromatic Monte Carlo simulation (at the wavelengths that you specify in the ﬁle
mcmono_wavelength_micron.inp). The output ﬁle of this computation is mean_intensity.out
which contains the mean intensity 𝐽𝜈as a function of the (𝑥, 𝑦, 𝑧) (cartesian) or (𝑟, 𝜃, 𝜑) (spherical) co-
ordinates at the frequencies 𝜈𝑖≡104𝑐/𝜆𝑖where 𝜆𝑖are the wavelengths (in 𝜇m) speciﬁed in the ﬁle
mcmono_wavelength_micron.inp. The results of this computation can be interesting for, for instance,
models of photochemistry. But if you use RADMC-3D only for computing spectra and images, then you will
not use this.
In addition to the above main methods, you can ask RADMC-3D to do various minor things as well, which will be
described throughout this manual.
22
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
5.6 How a model is set up and computed: a rough overview
A radiative transfer code such as RADMC-3D has the task of computing synthetic images and spectra of a model that
you specify. You tell the code what the dust and/or gas density distribution in 3-D space is and where the star(s) are,
and the code will then tell you what your cloud looks like in images and/or spectra. That’s basically it. That’s the main
task of RADMC-3D.
First you have to tell RADMC-3D what 3-D distribution of dust and/or gas you want it to model. For that you must
specify a coordinate system (cartesian or spherical) and a spatial grid. For cartesian coordinates this grid should be
3-D (although there are exceptions to this), while for spherical coordinates it can be 1-D (spherical symmetry), 2-D
(axial symmetry) or 3-D (no symmetry). RADMC-3D is (for most part) a cell-based code, i.e. your grid devides space
in cells and you have to tell RADMC-3D what the average densities of dust and/or gas are in these cells.
The structure of the grid is speciﬁed in a ﬁle amr_grid.inp (see Section INPUT (required): amr_grid.inp). All the
other data, such as dust density and/or gas density are speciﬁed in other ﬁles, but all assume that the grid is given by
amr_grid.inp.
We can also specify the locations and properties of one or more stars in the model. This is done in the stars.inp
(see Section INPUT (mostly required): stars.inp) ﬁle.
Now suppose we want to compute the appearance of our model in dust continuum. We will describe this in detail
in Chapter Dust continuum radiative transfer, but let us give a very rough idea here. We write, in addition to the
amr_grid.inp and stars.inp ﬁles, a ﬁle dust_density.inp which speciﬁes the density of dust in each cell
(see Section INPUT (required for dust transfer): dust_density.inp). We also must write the main input ﬁle radmc3d.
inp (see Section INPUT: radmc3d.inp), but we can leave it empty for now. We must give RADMC-3D a dust opacity
table in the ﬁles dustopac.inp and for instance dustkappa_silicate.inp (see Section INPUT (required
for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp). And ﬁnally, we
have to give RADMC-3D a table of discrete wavelengths in the ﬁle wavelength_micron.inp that it will use to
perform its calculations on. We then call the radmc3d code with the keyword mctherm (see Chapter Dust continuum
radiative transfer) to tell it to perform a Monte Carlo simulation to compute dust temperatures everywhere. RADMC-
3D will write this to the ﬁle dust_temperature.dat. If we now want to make a spectral energy distribution, for
instance, we call radmc3d sed (see Section Making spectra) and it will write a ﬁle called spectrum.out which
is a list of ﬂuxes at the discrete wavelengths we speciﬁed in wavelength_micron.inp. Then we are done: we
have computed the spectral energy distribution of our model. We could also make an image at wavelength 10 𝜇m
for instance with radmc3d image lambda 10 (see Section Basics of image making with RADMC-3D). This will
write out a ﬁle image.out containing the image data (see Section OUTPUT: image.out or image_****.out).
As you see, RADMC-3D reads all its information from tables in various ﬁles. Since you don’t want to make large
tables by hand, you will have to write a little computer program that generates these tables automatically. You can do
this in any programming language you want. But in the example models (see Section Running the example models)
we use the programming language Python (see Section Requirements) for this. It is easiest to indeed have a look at the
example models to see how this is (or better: can be) done.
We will explain all these things in much more detail below, and we will discuss also many other radiative transfer
problem types. The above example is really just meant to give an impression of how RADMC-3D works.
5.6. How a model is set up and computed: a rough overview
23

radmc3d, Release 2.0
5.7 Organization of model directories
The general philosophy of the RADMC-3D code package is the following. The core of everything is the fortran code
radmc3d. This is the main code which does the hard work for you: it makes the radiative transfer calculations, makes
images, makes spectra etc. Normally you compile this code just once-and-for-all (see Chapter Installation of RADMC-
3D), and then simply use the executable radmc3d for all models. There is an exception to this ‘once-and-for-all’ rule
described in Section Making special-purpose modiﬁed versions of RADMC-3D (optional), but in the present chapter
we will not use this (see Chapter Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes for this
instead). So we will stick here to the philosophy of compiling this code once and using it for all models.
So how to set up a model? The trick is to present radmc3d with a set of input ﬁles in which the model is described
in all its details. The procedure to follow is this:
1. The best thing to do (to avoid a mess) is to make a directory for each model: one model, one directory. Since
radmc3d reads multiple input ﬁles, and also outputs a number of ﬁles, this is a good way to keep organized
and we recommend it strongly. So if we wish to make a new model, we make a new directory, or copy an old
directory to a new name (if we merely want to make small changes to a prior model).
2. In this directory we generate the input ﬁles according to their required format (see Chapter Main input and
output ﬁles of RADMC-3D). You can create these input ﬁles in any way you want. But since many of these
input ﬁles will/must contain huge lists of numbers (for instance, giving the density at each location in your
model), you will typically want to write some script or program in some language (be it either C, C++, Fortran,
IDL, GDL, perl, python, you name it) that automatically creates these input ﬁles. We recommend using Python,
because we provide examples and standard subroutines in the programming language Python; see below for
more details. Section Running the example models describes how to use the example Python scripts to make
these input ﬁles with Python.
3. When all the input ﬁles are created, and we make sure that we are inside the model directory, we call radmc3d
with the desired command-line options (see Chapter Command-line options). This will do the work for us.
4. Once this is done, we can analyze the results by reading the output ﬁles (see Chapter Main input and output ﬁles
of RADMC-3D). To help you reading and analyzing these output ﬁles you can use a set of Python routines that
we created for the user (see Chapter Python analysis tool set and Section Installing the simple Python analysis
tools). But here again, you are free to use any other plotting software and/or data postprocessing packages.
5.8 Running the example models
Often the fastest and easiest way to learn a code is simply to analyze and run a set of example models. They are listed
in the examples directory. Each model occupies a separate directory. This is also the style we normally recommend:
each model should have its own directory. Of course there are also exceptions to this rule, and the user is free to
organize her/his data in any way he/she pleases. But in all the examples and throughout this manual each model has
its own directory.
To run an example model, go into the directory of this model, and follow the directions that are written in the README
ﬁle in each of these directories. This is under the assumption that you have a full Python distribution installed on your
system, including Numpy and Matplotlib.
Let us do for instance run_simple_1/:
cd examples/run_simple_1
Now we must create all the input ﬁles for this model. These input ﬁles are all described in chapter Main input and
output ﬁles of RADMC-3D, but let us here just ‘blindly’ follow the example. In this example most (all except one) of
the input ﬁles are created using a Python script called problem_setup.py. To execute this script, this is what you
do on the shell:
24
Chapter 5. Basic structure and functionality

radmc3d, Release 2.0
python problem_setup.py
This Python script has now created a whole series of input ﬁles, all ending with the extension .inp. To see which
ﬁles are created, type the following in the shell:
ls -l *.inp
There is one ﬁle that this example does not create, and that is the ﬁle dustkappa_silicate.inp. This is a ﬁle that
contains the dust opacity in tabulated form. This is a ﬁle that you as the user should provide to the RADMC-3D code
package. The ﬁle dustkappa_silicate.inp is merely an example, which is an amorphous spherical silicate
grain with radius 0.1 micron. But see Section INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp
or dustkapscatmat_*.inp or dust_optnk_*.inp for more information about the opacities.
Now that the input ﬁles are created, we must run radmc3d:
radmc3d mctherm
This tells RADMC-3D to do the thermal Monte Carlo simulation. This may take some time. When the model is ready,
the prompt of the shell returns. To see what ﬁles have been created by this run of the code, type:
ls -l *.dat
You will ﬁnd the dust_temperature.dat containing the dust temperature everywhere in the model. See again
chapter Main input and output ﬁles of RADMC-3D for details of these ﬁles. To create a spectral energy distribution
(SED):
radmc3d sed incl 45.
This will create a ﬁle spectrum.out. To analyze these data you can use the Python routines delivered with the
code (see Chapter Python analysis tool set and Section Installing the simple Python analysis tools).
There is a ﬁle Makefile in the directory. This is here only meant to make it easy to clean the directory. Type make
cleanmodel to clean all the output from the radmc3d code. Type make cleanall to clean the directory back to
basics.
Let us now do for instance model run_simple_1_userdef/:
cd examples/run_simple_1_userdef
This is the same model as above, but now the grid and the dust density are set up inside radmc3d, using the ﬁle
userdef_module.f90 which is present in this directory. See Chapter Modifying RADMC-3D: Internal setup
and user-speciﬁed radiative processes for details and follow the directions in the README ﬁle.
In short: ﬁrst
edit the variable SRC in the Makefile to point to the src/ directory. Then type make. Then type python
problem_setup.py on the shell command line (which now only sets up the frequency grid, the star and the
radmc3d.inp ﬁle and some small stuff). Now you can run the model.
Please read the README ﬁle in each of the example model directories. Everything is explained there, including how
to make the relevant plots.
5.8. Running the example models
25

radmc3d, Release 2.0
26
Chapter 5. Basic structure and functionality

CHAPTER
SIX
DUST CONTINUUM RADIATIVE TRANSFER
Many of the things related to dust continuum radiative transfer have already been said in the previous chapters. But
here we combine these things, and expand with more in-depth information.
Most users simply want RADMC-3D to compute images and spectra from a model. This is done in a two-stage
procedure:
1. First compute the dust temperature everywhere using the thermal Monte Carlo computation (Section The thermal
Monte Carlo simulation: computing the dust temperature).
2. Then making the images and/or spectra (Section Making SEDs, spectra, images for dust continuum).
You can then view the output spectra and images with the Python tools or use your own plotting software.
Some expert users may wish to use RADMC-3D for something entirely different: to compute the local radiation ﬁeld
{em inside} a model, and use this for e.g. computing photochemistry rates of a chemical model or so. This is described
in Section Special-purpose feature: Computing the local radiation ﬁeld.
You may also use the thermal Monte Carlo computation of the dust temperature to help estimating the {em gas}
temperature for the line radiative transfer. See Chapter Line radiative transfer for more on line transfer.
6.1 The thermal Monte Carlo simulation: computing the dust temper-
ature
RADMC-3D can compute the dust temperature using the Monte Carlo method of Bjorkman & Wood (2001, ApJ 554,
615) with various improvements such as the continuous absorption method of Lucy (1999, A&A 344, 282). Once a
model is entirely set up, you can ask radmc3d to do the Monte Carlo run for you by typing in a shell:
radmc3d mctherm
if you use the standard radmc3d code, or
./radmc3d mctherm
if you have created a local version of radmc3d (see Section Making special-purpose modiﬁed versions of RADMC-3D
(optional)).
What the method does is the following: First all the netto sources of energy (or more accurately: sources of luminosity)
are identiﬁed. The following net sources of energy can be included:
• Stars: You can specify any number of individual stars: their position, and their spectrum and luminosity (See
Section INPUT (mostly required): stars.inp). This is the most commonly used source of luminosity, and as a
beginning user we recommend to use only this for now.
27

radmc3d, Release 2.0
• Continuum stellar source: For simulations of galaxies it would require by far too many individual stars to
properly include the input of stellar light from the billions of stars in the galaxy. To overcome this problem you
can specify a continuously spatially distributed source of stars. NOTE: Still in testing phase.
• Viscous heating / internal heating: Sometimes the dust grains acquire energy directly from the gas, for instance
through viscous heating of the gas or adiabatic compression of the gas. This can be included as a spatially
distributed source of energy. NOTE: Still in progress... Not yet working.
To compute the dust temperature we must have at least one source of luminosity, otherwise the equilibrium dust
temperature would be everywhere 0.
The next step is that this total luminosity is divided into nphot packages, where nphot is 100000 by default, but can
be set to any value by the user (see the ﬁle radmc3d.inp described in Section INPUT: radmc3d.inp). Then these
photon packages are emitted by these sources one-by-one. As they move through the grid they may scatter off dust
grains and thus change their direction. They may also get absorbed by the dust. If that happens, the photon package
is immediately re-emitted in another direction and with another wavelength. The wavelength is chosen according to
the recipe by Bjorkman & Wood (2001, ApJ 554, 615). The luminosity fraction that each photon package represents
remains, however, the same. Each time a photon package enters a cell it increases the ‘energy’ of this cell and thus
increases the temperature of the dust of this cell. The recipe for this is again described by Bjorkman & Wood (2001,
ApJ 554, 615), but contrary to that paper we increase the temperature of the dust always when a photon package enters
a cell, while Bjorkman & Wood only increase the dust temperature if a discrete absorption event has taken place. Each
photon package will ping-pong through the model and never gets lost until it escapes the model through the outer edge
of the grid (which, for cartesianl coordinates, is any of the grid edges in 𝑥, 𝑦or 𝑧, and for spherical coordinates is the
outer edge of 𝑟). Once it escapes, a new photon package is launched, until also it escapes. After all photon packages
have been launched and escaped, the dust temperature that remains is the ﬁnal answer of the dust temperature.
One must keep in mind that the temperature thus computed is an equilibrium dust temperature. It assumes that each
dust grain acquires as much energy as it radiates away. This is for most cases presumably a very good approximation,
because the heating/cooling time scales for dust grains are typically very short compared to any time-dependent dy-
namics of the system. But there might be situations where this may not be true: in case of rapid compression of gas,
near shock waves or in extremely optically thick regions.
NOTE: Monte Carlo simulations are based on pseudo-random numbers. The seed for the random number generator is
by default set to -17933201. If you want to perform multiple identical simulations with a different random sequence
you will need to set the seed by hand. This can be done by adding a line
iseed = -5415
(where -5415 is to be replaced by the value you want) to the radmc3d.inp ﬁle.
6.1.1 Modiﬁed Random Walk method for high optical depths
As you will soon ﬁnd out: very optically thick models make the RADMC-3D thermal Monte Carlo simulations to be
slow. This is because in the thermal Monte Carlo method a photon package is never destroyed unless it leaves the
system. A photon package can thus ‘get lost’ deep inside an optically thick region, making millions (or even billions)
of absorption+reemission or scattering events. Furthermore, you will notice that in order to get the temperatures in
these very optically thick regions to be reliable (i.e. not too noisy) you may need a very large number of photon
packages for your simulation, which slows down the simulation even more. It is hard to prevent such problems. Min,
Dullemond, Dominik, de Koter & Hovenier (2009) A&A 497, 155 discuss two methods of dealing with this problem.
One is a diffusion method, which we will not discuss here. The other is the ‘Modiﬁed Random Walk’ (MRW) method,
based on the method by Fleck & Canﬁeld (1984) J.Comput.Phys. 54, 508. Note that Robitaille (2010) A&A 520, 70
presented a simpliﬁcation of this method. Min et al. ﬁrst implemented this method into the MCMax code. It is also
implemented in RADMC-3D, in Robitaille’s simpliﬁed form.
The crucial idea of the method is that if a photon package ‘gets lost’ deep inside a single ultra-optically-thick cell, we
can use the analytical solutions of the diffusion equation in a constant-density medium to predict where the photon
28
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
package will go next. This thus allows RADMC-3D to make a single large step of the photon package which actually
corresponds to hundreds or thousands of absorption+reemission or scattering events.
The method works best if the optically thick cells are as large as possible. This is because the analytical solutions
are only valid within a single cell, and thus the ‘large step’ can not be larger than a single cell size. Moreover, cell
crossings will reduce the step length again to the physical mean free path, so the more cell crossings are made, the less
effective the MRW becomes.
NOTE: The MRW is by default switched off. The reason is that it is, after all, an approximation. However, if RADMC-
3D thinks that the MRW may help speed up the thermal Monte Carlo, it will make the suggestion to the user to switch
on the MRW method.
You can switch on the MRW by adding the following line to the radmc3d.inp ﬁle:
modified_random_walk = 1
6.2 Making SEDs, spectra, images for dust continuum
You can use RADMC-3D for computing spectra and images in dust continuum emission. This is described in detail
in Chapter Making images and spectra. RADMC-3D needs to know not only the dust spatial distribution, given in the
ﬁle dust_density.inp, but also the dust temperature, given in the ﬁle dust_temperature.dat (see Chapter
Binary I/O ﬁles for the binary version of these ﬁles, which are more compact, and which you can use instead of the
ascii versions). The dust_temperature.dat is normally computed by RADMC-3D itself through the thermal
Monte Carlo computation (see Section The thermal Monte Carlo simulation: computing the dust temperature). But
if you, the user, wants to specify the dust temperature at each location in the model youself, then you can simply
create your own ﬁle dust_temperature.dat and skip the thermal Monte Carlo simulation and go straight to the
creation of images or spectra.
The
basic
command
to
make
a
spectrum
at
the
global
grid
of
wavelength
(speciﬁed
in
the
ﬁle
wavelength_micron.inp, see Section INPUT (required): wavelength_micron.inp) is:
radmc3d sed
You can specify the direction of the observer with incl and phi:
radmc3d sed incl 20 phi 80
which means: put the observer at inclination 20 degrees and 𝜑-angle 80 degrees.
You can also make a spectrum for a given grid of wavelength (independent of the global wavelength grid). You ﬁrst
create a ﬁle camera_wavelength_micron.inp, which has the same format as wavelength_micron.inp.
You can put any set of wavelengths in this ﬁle without modifying the global wavelength grid (which is used by the
thermal Monte Carlo computation). Then you type
radmc3d spectrum loadlambda
and it will create the spectrum on this wavelength grid. More information about making spectra is given in Chapter
Making images and spectra.
For creating an image you can type
radmc3d image lambda 10
which creates an image at wavelength 𝜆mu`m. More information about making images is given in Chapter Making
images and spectra.
6.2. Making SEDs, spectra, images for dust continuum
29

radmc3d, Release 2.0
Important note: To handle scattering of light off dust grains, the ray-tracing is preceded by a quick Monte Carlo run
that is specially designed to compute the ‘scattering source function’. This Monte Carlo run is usually much faster
than the thermal Monte Carlo run, but must be done at each wavelength. It can lead, however, to slight spectral noise,
because the random photon paths are different for each wavelength. See Section More about scattering of photons off
dust grains for details.
6.3 OpenMP parallelized Monte Carlo
Depending on the model properties and the number of photon packages used in the simulation the Monte Carlo
calculation (in particular the thermal Monte Carlo, but under some conditions also the scattering Monte Carlo) can be
a time-consuming computation when executed only in a serial mode. To improve this, these Monte Carlo calculations
can be done in OpenMP parallel mode. The loop over photon packages is then distributed amongst the different
threads, where each thread adopts a speciﬁc number of loop iterations following the order of the thread identiﬁcation
number. To this end the random number generator was modiﬁed. The important point for the parallel version is that
different threads must not share the same random seed initially. To be certain that each thread is assigned a different
seed at the beginning, the thread identity number is added to the initial seed.
The default value for the number of threads in the parallel version is set to one, so that the program is identical with
the serial version, except for the random generator’s initial seed. The user can change the value by either typing
setthreads <nr>, where <nr> is the number of requested threads (integer value) in the command line or by
adding a corresponding line to the radmc3d.inp ﬁle. If the chosen number of threads is larger than the available
number of processor cores, the user is asked to reduce it.
For example, you can ask radmc3d to do the parallelized Monte Carlo run for you by typing in a shell:
radmc3d mctherm setthreads 4
or by adding the following keyword to the radmc3d.inp ﬁle:
setthreads = 4
which means that four threads are used for the thermal Monte Carlo computation.
For the image or spectrum you can do the same: just add setthreads 4 or so on the command line or put
setthreads = 4 into the radmc3d.inp ﬁle.
Make sure that you have included the -fopenmp keyword in the Makefile and have compiled the whole radmc3d
source code with this additional command before using the OpenMP parallelized thermal Monte Carlo version (cf.
Section Compiling the code with ‘make’).
6.4 Overview of input data for dust radiative transfer
In order to perform any of the actions described in Sections The thermal Monte Carlo simulation: computing the dust
temperature, Special-purpose feature: Computing the local radiation ﬁeld or Making SEDs, spectra, images for dust
continuum, you must give RADMC-3D the following data:
• amr_grid.inp: The grid ﬁle (see Section INPUT (required): amr_grid.inp).
• wavelength_micron.inp:
The global wavelength ﬁle (see Section INPUT (required):
wave-
length_micron.inp).
• stars.inp: The locations and properties of stars (see Section INPUT (mostly required): stars.inp).
• dust_density.inp: The spatial distribution of dust on the grid (see Section INPUT (required for dust
transfer): dust_density.inp).
30
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
• dustopac.inp: A ﬁle with overall information about the various species of dust in the model (see Sec-
tion INPUT (required for dust transfer):
dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or
dust_optnk_*.inp). One of the main pieces of information here is (a) how many dust species are included
in the model and (b) the tag names of these dust species (see dustkappa_XXX.inp below).
The ﬁle
dust_density.inp must contain exactly this number of density distributions: one density distribution for
each dust species.
• dustkappa_XXX.inp: One or more dust opacity ﬁles (where XXX should in fact be a tag name you de-
ﬁne, for instance dustkappa_silicate.inp). The labels are listed in the dustopac.inp ﬁle. ee
Section INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or dustkapscatmat_*.inp or
dust_optnk_*.inp for more information.
• camera_wavelength_micron.inp (optional): This ﬁle is only needed if you want to create a spec-
trum at a special set of wavelengths (otherwise use radmc3d sed).
• mcmono_wavelength_micron.inp (optional): This ﬁle is only needed if you want to compute the
radiation ﬁeld inside the model by calling radmc3d mcmono (e.g. for photochemistry).
Other input ﬁles could be required in certain cases, but you will then be asked about it by RADMC-3D.
6.5 Special-purpose feature: Computing the local radiation ﬁeld
If you wish to use RADMC-3D for computing the radiation ﬁeld inside the model, for instance for computing photo-
chemical rates in a chemical model, then RADMC-3D can do so by calling RADMC-3D in the following way:
radmc3d mcmono
This computes the mean intensity
𝐽𝜈= 1
4𝜋
∮︁
𝐼𝜈(Ω)𝑑Ω
(in units of erg s−1 cm−2 Hz−1 ster−1) as a function of the (𝑥, 𝑦, 𝑧) (cartesian) or (𝑟, 𝜃, 𝜑) (spherical) co-
ordinates at frequencies 𝜈𝑖
≡
104𝑐/𝜆𝑖where 𝜆𝑖are the wavelengths (in 𝜇m) speciﬁed in the ﬁle
mcmono_wavelength_micron.inp (same format as the ﬁle wavelength_micron.inp which is described
in Section INPUT (required): wavelength_micron.inp). The results of this computation can be interesting for, for
instance, models of photochemistry.
The ﬁle that is produced by radmc3d mcmono is called mean_intensity.out and has the following form:
iformat
<=== Typically 2 at present
nrcells
nfreq
<=== Nr of frequencies
freq_1 freq_2 ... freq_nfreq
<=== List of frequencies in Hz
meanint[1,icell=1]
meanint[1,icell=2]
...
meanint[1,icell=nrcells]
meanint[2,icell=1]
meanint[2,icell=2]
...
meanint[2,icell=nrcells]
...
...
...
meanint[nfreq,icell=1]
(continues on next page)
6.5. Special-purpose feature: Computing the local radiation ﬁeld
31

radmc3d, Release 2.0
(continued from previous page)
meanint[nfreq,icell=2]
...
meanint[nfreq,icell=nrcells]
The list of frequencies will, in fact, be the same as those listed in the ﬁle mcmono_wavelength_micron.inp.
Note that if your model is very large, the computation of the radiation ﬁeld on a large set of wavelength could easily
overload the memory of the computer. However, often you are in the end not interested in the entire spectrum at
each location, but just in integrals of this spectrum over some cross section. For instance, if you want to compute
the degree to which dust shields molecular photodissociation lines in the UV, then you only need to compute the total
photodissociation rate, which is an integral of the photodissociation cross section times the radiation ﬁeld. In Section
Using the userdef module to compute integrals of J_\nu it will be explained how you can create a userdef subroutine
(see Chapter Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes) that will do this for you
in a memory-saving way.
There is an important parameter for this Monochromatic Monte Carlo that you may wish to play with:
• nphot_mono The parameter nphot_mono sets the number of photon packages that are used for the
Monochromatic Monte Carlo simulation. It has as default 100000, but that may be too little for 3-D models.
You can set this value in two ways:
– In the radmc3d.inp ﬁle as a line nphot_mono = 1000000 for instance.
– On the command-line by adding nphot_mono 1000000.
6.6 More about scattering of photons off dust grains
Photons can not only be absorbed and re-emitted by dust grains: They can also be scattered. Scattering does nothing
else than change the direction of propagation of a photon, and in case polarization is included, its Stokes parameters.
Strictly speaking it may also slightly change its wavelength, if the dust grains move with considerable speed they may
Doppler-shift the wavelength of the outgoing photon (which may be relevant, if at all, when dust radiative transfer
is combined with line radiative transfer, see chapter Line radiative transfer), but this subtle effect is not treated in
RADMC-3D. For RADMC-3D scattering is just the changing of direction of a photon.
6.6.1 Five modes of treating scattering
RADMC-3D has ﬁve levels of realism of treatment of scattering, starting with scattering_mode=1 (simplest) to
scattering_mode=5 (most realistic):
• No scattering (scattering_mode=0):
If either the dustkappa_XXX.inp ﬁles do not contain a scattering opacity or scattering is switched off
by setting scattering_mode_max to 0 in the radmc3d.inp ﬁle, then scattering is ignored. It is then
assumed that the dust grains have zero albedo.
• Isotropic scattering (scattering_mode=1):
If either the dustkappa_XXX.inp ﬁles do not contain information about the anisotropy of the scattering or
anisotropic scattering is switched off by setting scattering_mode_max to 1 in the radmc3d.inp ﬁle,
then scattering is treated as isotropic scattering. Note that this can be a bad approximation.
• Anisotropic scattering using Henyey-Greenstein (scattering_mode=2):
If the dustkappa_XXX.inp ﬁles contain the scattering opacity and the 𝑔parameter of anisotropy (the
Henyey-Greenstein 𝑔parameter which is equal, by deﬁnition, to 𝑔= ⟨cos 𝜃⟩, where 𝜃is the scattering de-
32
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
ﬂection angle), and scattering_mode_max is set to 2 or higher in the radmc3d.inp ﬁle then anisotropic
scattering is treated using the Henyey-Greenstein approximate formula.
• Anisotropic scattering using tabulated phase function (scattering_mode=3):
To treat scattering using a tabulated phase function,
you must specify the dust opacities using
dustkapscatmat_XXX.inp ﬁles instead of the simpler dustkappa_XXX.inp ﬁles (see Section The
dustkapscatmat_*.inp ﬁles). You must also set scattering_mode_max is set to 3 or higher.
• Anisotropic scattering with polarization for last scattering (scattering_mode=4):
To
treat
scattering
off
randomly
oriented
particles
with
the
full
polarization
you
need
to
set
scattering_mode_max is set to 4 or higher, and you must specify the full dust opacity and scattering ma-
trix using the dustkapscatmat_XXX.inp ﬁles instead of the simpler dustkappa_XXX.inp ﬁles (see
Section The dustkapscatmat_*.inp ﬁles). If scattering_mode=4 the full polarization is only done upon
the last scattering before light reaches the observer (i.e. it is only treated in the computation of the scattering
source function that is used for the images, but it is not used for the movement of the photons in the Monte
Carlo simulation). See Section Polarization, Stokes vectors and full phase-functions for more information about
polarized scattering.
• Anisotropic scattering with polarization, full treatment (scattering_mode=5):
For the full treatment of polarized scattering off randomly oriented particles,
you need to set
scattering_mode_max is set to 5, and you must specify the full dust opacity and scattering matrix us-
ing the dustkapscatmat_XXX.inp ﬁles instead of the simpler dustkappa_XXX.inp ﬁles (see Section
The dustkapscatmat_*.inp ﬁles). See Section Polarization, Stokes vectors and full phase-functions for more
information about polarized scattering. end{enumerate} Please refer to Sections Scattering phase functions
and Polarization, Stokes vectors and full phase-functions for more information about these different scattering
modes.
So in summary: the dust opacity ﬁles themselves tell how detailed the scattering is going to be included. If no scat-
tering information is present in these ﬁles, RADMC-3D has no choice but to ignore scattering. If they only contain
scattering opacities but no phase information (no 𝑔-factor), then RADMC-3D will treat scattering in the isotropic ap-
proximation. If the 𝑔-factor is also included, then RADMC-3D will use the Henyey-Greenstein formula for anisotropic
scattering. If you specify the full scattering matrix (using the dustkapscatmat_XXX.inp ﬁles instead of the
dustkappa_XXX.inp ﬁles) then you can use tabulated scattering phase functions, and even polarized scattering.
If scattering_mode_max is not set in the radmc3d.inp ﬁle, it is by default 9999, meaning: RADMC-3D will
always use the maximally realistic scattering mode that the dust opacities allow.
BUT you can always limit the realism of scattering by setting the scattering_mode_max to 4, 3, 3, 1 or 0 in the
ﬁle radmc3d.inp. This can be useful to speed up the calculations or be sure to avoid certain complexities of the
full phase-function treatment of scattering.
At the moment there are some limitations to the full anisotropic scattering treatment:
• Anisotropic scattering in 1-D and 2-D Spherical coordinates:
For 1-D spherical coordinates there is currently no possibility of treating anisotropic scattering in the image-
and spectrum-making. The reason is that the scattering source function (see Section Scattered light in images
and spectra: The ‘Scattering Monte Carlo’ computation) must be stored in an angle-dependent way. However,
for 2-D spherical coordinates, this has been implemented, and for each grid ‘cell’ (actually an annulus) the
scattering source function is now stored for an entire sequence of angles.
• Full phase functions and polarization only for randomly-oriented particles:
Currently RADMC-3D cannot handle scattering off ﬁxed-oriented non-spherical particles, because it requires a
much more detailed handling of the angles. It would require at least 3 scattering angles (for axially-symmetric
particles) or more (for completely asymmetric particles), which is currently beyond the scope of RADMC-3D.
6.6. More about scattering of photons off dust grains
33

radmc3d, Release 2.0
6.6.2 Scattering phase functions
As mentioned above, for the different scattering_mode settings you have different levels of realism of treating
scattering.
The transfer equation along each ray, ignoring polarization for now, is:
𝑑𝐼𝜈
𝑑𝑠= 𝑗therm
𝜈
+ 𝑗scat
𝜈
−(𝛼abs
𝜈
+ 𝛼scat
𝜈
)𝐼𝜈
where 𝛼abs
𝜈
and 𝛼scat
𝜈
are the extinction coefﬁcients for absorption and scattering. Let us assume, for convenience of
notation, that we have just one dust species with density dstribution 𝜌, absorption opacity 𝜅abs
𝜈
and scattering opacity
𝜅scat
𝜈
. We then have
𝛼abs
𝜈
≡𝜌𝜅abs
𝜈
𝛼scat
𝜈
≡𝜌𝜅scat
𝜈
𝑗therm
𝜈
= 𝛼abs
𝜈
𝐵𝜈(𝑇)
where 𝐵𝜈(𝑇) is the Planck function. The last equation is an expression of Kirchhoff’s law.
For isotropic scattering (scattering_mode=1) the scattering source function 𝑗scat
𝜈
is given by
𝑗scat
𝜈
= 𝛼scat
𝜈
1
4𝜋
∮︁
𝐼𝜈𝑑Ω
where the integral is the integral over solid angle. In this case 𝑗scat
𝜈
does not depend on solid angle.
For anisotropic scattering (scattering_mode>1) we must introduce the scattering phase function Φ(nin, nout),
where nin is the unit direction vector for incoming radiation and nout is the unit direction vector for the scattered
radiation. The scattering phase function is normalized to unity:
1
4𝜋
∮︁
Φ(nin, nout)𝑑Ωout = 1
4𝜋
∮︁
Φ(nin, nout)𝑑Ωin = 1
where we integrated over all possible nout or nin. Then the scattering source function becomes:
𝑗scat
𝜈
(nout) = 𝛼scat
𝜈
1
4𝜋
∮︁
𝐼𝜈(nin)Φ(nin, nout)𝑑Ωin
which is angle-dependent. The angular dependence means: a photon package has not completely forgotten from which
direction it came before hitting the dust grain.
If we do not include the polarization of radiation and we have randomly oriented particles, then the scattering phase
function will only depend on the scattering (deﬂection) angle 𝜃deﬁned by
cos 𝜃≡𝜇= nout · nin
We will thus be able to write
Φ(nin, nout) ≡Φ(𝜇)
where Φ(𝜇) is normalized as
1
2
∫︁+1
−1
Φ(𝜇)𝑑𝜇= 1
34
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
If we have scattering_mode=2 then the phase function is the Henyey-Greenstein phase function deﬁned as
Φ(𝜇) =
1 −𝑔2
(1 + 𝑔2 −2𝑔𝜇)3/2
where the value of the anisotropy parameter 𝑔is taken from the dust opacity ﬁle. Note that for 𝑔= 0 you get Φ(𝜇) = 1
which is the phase function for isotropic scattering.
If we have scattering_mode=3 then the phase function is tabulated by you.
You have to provide the
tabulated phase function as the 𝑍11(𝜃) scattering matrix element for a tabulated set of 𝜃𝑖values, and this is
done in a ﬁle dustkapscatmat_xxx.inp (see Section The dustkapscatmat_*.inp ﬁles and note that for
scattering_mode=3 the other 𝑍𝑖𝑗elements can be kept 0 as they are of no consequence). The relation between
𝑍11(𝜃) and Φ(𝜇) is:
Φ(𝜇) ≡Φ(cos(𝜃)) =
4𝜋
𝜅scat
𝑍11(𝜃)
(which holds at each wavelength individually).
If we have scattering_mode=4 then the scattering in the Monte Carlo code is done according to the tabulated
Φ(𝜇) mode mentioned above, but for computing the scattering source function the full polarized scattering matrix is
used. See Section Polarization, Stokes vectors and full phase-functions.
If we have scattering_mode=5 then the scattering phase function is not only dependent on 𝜇but also on the other
angle. And it depends on the polarization state of the input radiation. See Section Polarization, Stokes vectors and full
phase-functions.
6.7 Scattering of photons in the Thermal Monte Carlo run
So how is scattering treated in practice? In the thermal Monte Carlo model (Section The thermal Monte Carlo simu-
lation: computing the dust temperature) the scattering has only one effect: it changes the direction of propagation of
the photon packages whenever such a photon package experiences a scattering event. This may change the results for
the dust temperatures subtly. In special cases it may even change the dust temperatures more strongly, for instance if
scattering allows ‘hot’ photons to reach regions that would have otherwise been in the shadow. It may also increase
the optical depth of an object and thus change the temperatures accordingly. But this is all there is to it.
If you include the full treatment of polarized scattering (scattering_mode=5), then a photon package also gets
polarized when it undergoes a scattering event. This can affect the phase function for the next scattering event. This
means that the inclusion of the full polarized scattering processes (as opposed to using non-polarized photon packages)
can, at least in principle, have an effect on the dust temperatures that result from the thermal Monte Carlo computation.
This effect is, however, rather small in practice.
6.8 Scattering of photons in the Monochromatic Monte Carlo run
For the monochromatic Monte Carlo calculation for computing the mean intensity radiation ﬁeld (Section Special-
purpose feature: Computing the local radiation ﬁeld) the scattering has the same effect as for the thermal Monte
Carlo model: it changes the direction of photon packages. In this way ‘hot’ radiation may enter regions which would
otherwise have been in a shadow. And by increasing the optical depth of regions, it may increase the local radiation
ﬁeld by the greenhouse effect or decrease it by preventing photons from entering it. As in the thermal Monte Carlo
model the effect of scattering in the monochromatic Monte Carlo model is simply to change the direction of motion
of the radiation ﬁeld, but for the rest nothing differs to the case without scattering. Also here the small effects caused
by polarized scattering apply, like in the thermal Monte Carlo case.
6.7. Scattering of photons in the Thermal Monte Carlo run
35

radmc3d, Release 2.0
6.8.1 Scattered light in images and spectra: The ‘Scattering Monte Carlo’ compu-
tation
For making images and spectra with the ray-tracing capabilities of RADMC-3D (see Section Making SEDs, spectra,
images for dust continuum and Chapter Making images and spectra) the role of scattering is a much more complex one
than in the thermal and monochromatic Monte Carlo runs. The reason is that the scattered radiation will eventually
end up on your images and spectra.
If we want to make an image or a spectrum, then for each pixel we must integrate Eq. (eq-ray-tracing-rt) along
the 1-D ray belonging to that pixel. If we performed the thermal Monte Carlo simulation beforehand (or if we speciﬁed
the dust temperatures by hand) we know the thermal source function through Eq. (eq-thermal-source-function). But
we have, at that point, no information yet about the scattering source function. The thermal Monte Carlo calculation
{em could} have also stored this function at each spatial point and each wavelength and each observer direction, but
that would require gigantic amounts of memory (for a typical 3-D model it might be many Gbytes, going into the
Tbyte regime). So in RADMC-3D the scattering source function is {em not} computed during the thermal Monte
Carlo run.
In RADMC-3D the scattering source function 𝑗scat
𝜈
(Ω′) is computed {em just prior to} the ray-tracing through a
brief ‘Scattering Monte Carlo’ run. This is done {em automatically} by RADMC-3D, so you don’t have to worry
about this. Whenever you ask RADMC-3D to make an image (and if the scattering is in fact included in the model,
see Section Five modes of treating scattering), RADMC-3D will automatically realize that it requires knowledge of
𝑗scat
𝜈
(Ω′), and it will start a brief single-wavelength Monte Carlo simulation for computing 𝑗scat
𝜈
(Ω′). This single-
wavelength ‘Scattering Monte Carlo’ simulation is relatively fast compared to the thermal Monte Carlo simulation,
because photon packages can be destroyed by absorption. So photon packages do not bounce around for long, as
they do in the thermal Monte Carlo simulation. This Scattering Monte Carlo simulation is in fact very similar to
the monochromatic Monte Carlo model described in Section Special-purpose feature: Computing the local radiation
ﬁeld. While the monochromatic Monte Carlo model is called speciﬁcally by the user (by calling RADMC-3D with
radmc3d mcmono), the Scattering Monte Carlo simulation is not something the user must specify him/her-self: it
is automatically done by RADMC-3D if it is needed (which is typically before making an image or during the making
of a spectrum). And while the monochromatic Monte Carlo model returns the mean intensity inside the model, the
Scattering Monte Carlo simulation provides the raytracing routines with the scattering source function but does not
store this function in a ﬁle.
You can see this happen if you have a model with scattering opacity included, and you make an image with RADMC-
3D, you see that it prints 1000, 2000, 3000, ... etc., in other words, it performs a little Monte Carlo simulation
before making the image.
There is an important parameter for this Scattering Monte Carlo that you may wish to play with:
• nphot_scat
The parameter nphot_scat sets the number of photon packages that are used for the Scattering Monte Carlo
simulation. It has as default 100000, but that may be too little for 3-D models and/or cases where you wish
to reduce the ‘streaky’ features sometimes visible in scattered-light images when too few photon packages are
used. You can set this value in two ways:
– In the radmc3d.inp ﬁle as a line nphot_scat = 1000000 for instance.
– On the command-line by adding nphot_scat 1000000.
In Figure Fig. 6.1 you can see how the quality of an image in scattered light improves when increasing
nphot_scat.
• nphot_spec
The parameter nphot_spec is actually exactly the same as nphot_scat, but is used (and used only!) for
the creation of spectra. The default is 10000, i.e. substantially smaller than nphot_scat. The reason for this
separate parameter is that if you make spectra, you integrate over the image to obtain the ﬂux (i.e. the value of
the spectrum at that wavelength). Even if the scattered light image may look streaky, the integral may still be
36
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
accurate. We can thus afford much fewer photon packages when we make spectra than when we make images,
and can thus speed up the calculation of the spectrum. You can set this value in two ways:
– In the radmc3d.inp ﬁle as a line nphot_spec = 100000 for instance.
– On the command-line by adding nphot_spec 100000.
NOTE: It may be possible to get still very good results with even smaller values of nphot_spec than the
default value of 10000. That might speed up the calculation of the spectrum even more in some cases. On
the other hand, if you notice ‘noise’ on your spectrum, you may want to increase nphot_spec. If you are
interested in an optimal balance between accuracy (high value of nphot_spec) and speed of calculation (low
value of nphot_spec) then it is recommended to experiment with this value. If you want to be on the safe
side, then set nphot_spec to a high value (i.e. set it to 100000, as nphot_spec).
Nphot=1000000
Nphot=1000
Nphot=10000
Nphot=100000
Fig. 6.1: The effect of nphot_scat on the image quality when the image is dominated by scattered light. The images
show the result of model examples/run_simple_2_scatmat at 𝜆= 0.84𝜇m in which polarized scattering with
the full scattering phase function and scattering matrix is used. See Section Polarization, Stokes vectors and full phase-
functions about the scattering matrices for polarized scattering. See Section Single-scattering vs. multiple-scattering
for a discussion about the ‘scratches’ seen in the top two panels.
WARNING: At wavelengths where the dominant source of photons is thermal dust emission but scattering is still
important (high albedo), it cannot be excluded that the ‘scattering monte carlo’ method used by RADMC-3D produces
very large noise. Example: a very optically thick dust disk consisting of large grains (10 𝜇m size), producing thermal
dust emission in the near infrared in its inner disk regions. This thermal radiation can scatter off the large dust grains at
large radii (where the disk is cold and where the only ‘emission’ in the near-infrared is thus the scattered light) and thus
reveal the outer disk in scattered light emerging from the inner disk. However, unless nphot_scat is huge, most
thermally emitted photons from the inner disk will be emitted so deeply in the disk interior (i.e. below the surface)
that they will be immediately reabsorbed and lost. This means that that radiation that does escape is extremely noisy.
The corresponding scattered light source function at large radii is therefore very noisy as well, unless nphot_scat
is taken to be huge. Currently no elegant solution is found, but maybe there will in the future. Stay tuned...
NOTE: Monte Carlo simulations are based on pseudo-random numbers. The seed for the random number generator is
by default set to -17933201. If you want to perform multiple identical simulations with a different random sequence
you will need to set the seed by hand. This can be done by adding a line
6.8. Scattering of photons in the Monochromatic Monte Carlo run
37

radmc3d, Release 2.0
iseed = -5415
(where -5415 is to be replaced by the value you want) to the radmc3d.inp ﬁle.
6.8.2 Single-scattering vs. multiple-scattering
If scattering is included in the images and spectra, the Monte Carlo run computes the full multiple-scattering prob-
lem. Photon packages are followed as they scatter and change their direction (possibly many times) until they es-
cape to inﬁnity or until they are extincted by many orders of magnitude (the exact extinction limit can be set by
mc_scat_maxtauabs, which by default is set to 30, meaning a photon package is considered extincted when it has
travelled an absorption optical depth of 30).
Important note: In many (most?) cases this default value of mc_scat_maxtauabs=30 is overly conservative.
Especially when the scattering Monte Carlo is very time-consuming, you may want to experiment with a lower value.
Try adding a line to the radmc3d.inp with:
mc_scat_maxtauabs = 5
This may speed up the scattering Monte Carlo by up to a factor of 6, while still yielding reasonable results.
It can be useful to ﬁgure out how important the effect of multiple scattering in an image is compared to single scattering.
For instance: a protoplanetary disk with a ‘self-shadowed’ geometry will show some scattering even in the shadowed
region because some photon packages scatter {em into} the shadowed region and then scatter into the line of sight. To
ﬁgure out if this is indeed what happens, you can make two images: one normal image with
radmc3d image lambda 1.0
cp image.out image_fullscat.out
and then another image which only treats single scattering:
radmc3d image lambda 1.0 maxnrscat 1
cp image.out image_singlescat.out
The command-line option maxnrscat 1 tells RADMC-3D to stop following photon packages once they hit their
ﬁrst discrete scattering event. You can also check out the effect of single- and double-scattering (but excluding triple
and higher order scattering) with: maxnrscat 2, etc.
Note that multiple scattering may require a very high number of photon packages (i.e. setting nphot_scat to a very
high number). For single scattering with too low nphot_scat you typically see radial ‘rays’ in the image emanating
from each stellar source of photons. For multiple scattering, when taking too low nphot_scat small you would see
strange non-radial ‘scratches’ in the image (see Fig. Fig. 6.1, top two images). It looks as if someone has used a pen
and randomly added some streaks. These streaks are the double-scattering events which, in that case, apparently are
rare enough that they show up as individual streaks. To test whether these streaks are indeed such double scattering
events, you can use maxnrscat 1, and they should disappear. If the streaks are indeed very few, it may turn out
that the single-scattering image (maxnrscat 1) is almost already the correct image. The double scattering is then
only a minor addition to the image, but due to the ﬁnite Monte Carlo noise it would yield annoying streaks which ruin
a nice image. If you are {em very sure} that the second scattering and higher-order scattering are only a very minor
effect, then you might use the maxnrscat 1 image as the ﬁnal image. By comparing the ﬂux in the images with
full scattering and single scattering you can estimate how important the multiple-scattering contribution is compared
to single scattering. But of course, it is always safer to simply increase nphot_scat and patiently wait until the
Monte Carlo run is ﬁnished.
38
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.8.3 Simpliﬁed single-scattering mode (spherical coordinates)
If you are sure that multiple scattering is rare (low albedo and/or low optical depth), then you may be interested in
using a simpler (non-Monte-Carlo) mode for including scattering in your images. But please ﬁrst read Section Single-
scattering vs. multiple-scattering and test if multiple scattering is indeed unimportant. If so, and if you are using
spherical coordinates, a single star at the center which is point-like, and if you are conﬁdent that at the wavelength you
are interested in the thermal dust emission is not strong enough to be a considerable source of light that can be scattered
into the line-of-sight (i.e. all scattered light is scattered star light), then you can use the simpliﬁed single-scattering
mode.
This mode does not use the Monte Carlo method to compute the scattering source function, but instead uses direct
integration of the starlight through the grid. It is much faster than Monte Carlo, and it does not contain noise.
By adding simplescat to the command line when making an image or spectrum, you switch this mode on. Please
compare ﬁrst to the single-scattering Monte Carlo method (see Section Single-scattering vs. multiple-scattering; it
should yield very similar result, but without noise) and then to the full multiple scattering Monte Carlo. The full
multiple scattering case will likely produce more ﬂux. If the difference is large, then you should not use the simple
single scattering mode. However, if the difference is minor, then the single scattering approximation is reasonable.
6.8.4 Warning when using an-isotropic scattering
An important issue with anisotropic scattering is that if the phase function is very forward-peaked, then you may get
problems with the spatial resolution of your model: it could then happen that one grid cell may be too much to the
left to ‘beam’ the scattered light into your line of sight, while the next grid point will be too much to the right. A
proper treatment of strongly anisotropic scattering therefore requires also a good check of the spatial resolution of
your model. There are, however, also two possible tricks (approximations) to prevent problems. They both involve
slight modiﬁcations of the dust opacity ﬁles:
• You can simply assure in the opacity ﬁles that the forward peaking of the phase function has some upper limit.
• Or you can simply treat extremely forward-peaked scattering as no scattering at all (simply setting the scattering
opacity to zero at those wavelengths).
Both ‘tricks’ are presumably reasonable and will not affect your results, unless you concentrate in your modeling very
much on the angular dependence of the scattering.
6.8.5 For experts: Some more background on scattering
The inclusion of the scattering source function in the images and spectra is a non-trivial task for RADMC-3D because
of memory constraints. If we would have inﬁnite random access memory, then the inclusion of scattering in the images
and spectra would be relatively easy, as we could then store the entire scattering source function 𝑗scat(𝑥, 𝑦, 𝑧, 𝜈, Ω) and
use what we need at any time. But as you see, this function is a 6-dimensional function: three spatial dimensions, one
frequency and one angular direction (which consists of two angles). For any respectable model this function is far too
large to be stored. So nearly all the ‘numerical logistic’ complexity of the treatment of scattering comes from various
ways to deal with this problem. In principle RADMC-3D makes the choices of which method to use itself, so the user
is not bothered with it. But depending on which kind of model the user sets up, the performance of RADMC-3D may
change as a result of this issue.
So here are a few hints as to the internal workings of RADMC-3D in this regard. You do not have to read this, but it
may help understanding the performance of RADMC-3D in various cases.
• Scattering in spectra and multi-wavelength images
If no scattering is present in the model (see Section Five modes of treating scattering), then RADMC-3D
can save time when making spectra and/or multi-wavelength images. I will then do each integration of Eq.
(eq-ray-tracing-rt) directly for all wavelengths at once before going to the next pixel. This saves some
6.8. Scattering of photons in the Monochromatic Monte Carlo run
39

radmc3d, Release 2.0
time because RADMC-3D then has to calculate the geometric stuff (how the ray moves through the model) just
once for each ray. If, however, scattering is included, the scattering source function must be computed using the
Scattering Monte Carlo computation. Since for large models it would be too memory consuming (in particular
for 3-D models) to store this function for all positions and all wavelengths, it must do this calculation one-by-
one for each wavelength, and calculate the image for that wavelength, and then go off to the next wavelength.
This means that for each ray (pixel) the geometric computations (where the ray moves through the model) has
to be redone for each new wavelength. This may slow down the code a bit.
• Anisotropic scattering and multi-viewpoint images
Suppose we wish to look at an object at one single wavelength, but from a number of different vantage points. If
we have {em isotropic} scattering, then we need to do the Scattering Monte Carlo calculation just once, and we
can make multiple images at different vantage points with the same scattering source function. This saves time,
if you use the ‘movie’ mode of RADMC-3D (Section Multiple vantage points: the ‘Movie’ mode). However,
if the scattering is anisotropic, then the source function would differ for each vantage point. In that case the
scattering source function must be recalculated for each vantage point. There is, deeply hidden in RADMC-3D,
a way to compute scattering source functions for multiple vantage points within a single Scattering Monte Carlo
run, but for the moment this is not yet activated. end{itemize}
6.9 Polarization, Stokes vectors and full phase-functions
The module in RADMC-3D that deals with polarization (polarization_module.f90) is based on code de-
veloped by Michiel Min for his MCMAX code, and has been used and modiﬁed for use in RADMC-3D with his
permission.
Radiative transfer of polarized radiation is a relatively complex issue. A good and extensive review on the details of
polarization is given in the book by Mishchenko, Travis & Lacis, ‘Scattering, Absorption and Emission of Light by
Small Particles’, 2002, Cambridge University Press (also electronically available on-line). Another good book (and a
classic!) is the book by Bohren & Huffman ‘Absorption and scattering of light by small particles’, Wiley-VCH. Finally,
the ultimate classic is the book by van de Hulst ‘Light scattering by small particles’, 1981. For some discussions on
how polarization can be built in into radiative transfer codes, see e.g. Wolf, Voshchinnikov & Henning (2002, A&A
385, 365).
When we wish to include polarization in our model we must follow not just the intensity 𝐼of light (or equivalently,
the energy 𝐸of a photon package), but the full Stokes vector (𝐼, 𝑄, 𝑈, 𝑉) (see review above for deﬁnitions, or any
textbook on radiation processes). If a photon scatters off a dust grain, then the scattering angular probability density
function depends not only on the scattering angle 𝜇, but also on the input state of polarization, i.e. the values of
(𝐼, 𝑄, 𝑈, 𝑉). And the output polarization state will be modiﬁed. Moreover, even if we would not be interested in
polarization at all, but we {em do} want to have a correct scattering phase function, we need to treat polarization,
because a ﬁrst scattering will polarize the photon, which will then have different angular scattering probability in the
next scattering event. Normally these effects are very small, so if we are not particularly interested in polarization, one
can usually ignore this effect without too high a penalty in reliability. But if one wants to be accurate, there is no way
around a full treatment of the (𝐼, 𝑄, 𝑈, 𝑉).
Interaction between polarized radiation with matter happens through so-called Müller matrices, which are 4 × 4
matrices that can be multiplied by the (𝐼, 𝑄, 𝑈, 𝑉) vector. More on this later.
It is important to distinguish between two situations:
1. The simplest case (and fortunately applicable in many cases) is if all dust particles are randomly oriented,
and there is no preferential helicity of the dust grains (i.e. for each particle shape there are equal numbers
of particles with that shape and with its mirror copy shape). This is also automatically true if all grains are
spherically symmetric. In this case the problem of polarized radiative transfer simpliﬁes in several ways:
• The scattering Müller matrix simpliﬁes, and contains only 6 independent matrix elements (see later). More-
over, these matrix elements depend only on a single angle: the scattering angle 𝜃, and of course on the
40
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
wavelength. This means that the amount of information is small enough that these Müller matrix elements
can be stored in computer memory in tabulated form, so that they do not have to be calculated real-time.
• The total scattering cross section is independent of the input polarization state. Only the output radiation
(i.e. in which direction the photon will scatter) depends on the input polarization state.
• The absorption cross section is the same for all components of the (𝐼, 𝑄, 𝑈, 𝑉)-vector. In other words: the
absorption Müller matrix is the usual scalar absorption coefﬁcient times the unit matrix.
The last two points assure that most of the structure of the RADMC-3D code for non-polarized radiation can
remain untouched. Only for computing the new direction and polarization state of a photon after a scattering
event in the Monte Carlo module, as well as for computing the scattering source function in the Monte Carlo
module (for use in the camera module) we must do extra work. Thermal emission and thermal absorption remain
the same, and computing optical depths remains also the same.
2. A (much!) more complex situation arises if dust grains are non-spherical and are somehow aligned due to
external forces. For instance, particles tend to align themselves in the interstellar medium if strong enough
magnetic ﬁelds are present. Or particles tend to align themselves due to the combination of gravity and friction
if they are in a planetary/stellar atmosphere. Here are the ways in which things become more complex:
• All the scattering Müller matrix components will become non-zero and independent. We will thus get 16
independent variables.
• The matrix elements will depend on four angles, of which one can, in some cases, be removed due to
symmetry (e.g. if we have gravity, there is still a remaining rotational symmetry; same is true of particles
are aligned by a ⃗𝐵-ﬁeld; but if both gravity and a ⃗𝐵-ﬁeld are present, this symmetry may get lost). It will
in most practical circumstances not be possible to precalculate the scattering Müller matrix beforehand
and tabulate it, because there are too many variables. The matrix must be computed on-the-ﬂy.
• The total scattering cross section now does depend on the polarization state of the input photon, and on the
incidence angle. This means that scattering extinction becomes anisotropic.
• Thermal emission and absorption extinction will also no longer be isotropic. Moreover, they are no longer
scalar: they are described by a non-trivial Müller matrix.
The complexity of this case is rather large. As of version 0.41 we have included polarized thermal emission by
aligned grains (see Section Polarized emission and absorption by aligned grains), and we will implement more
of the above mentioned aspects of aligned grains step by step.
6.9.1 Deﬁnitions and conventions for Stokes vectors
There are different conventions for how to set up the coordinate system and deﬁne the Stokes vectors. Our deﬁnition
follows the IAU 1974 deﬁnition as described in Hamaker & Bregman (1996) A&AS 117, pp.161.
In this convention the 𝑥′ axis points to the north on the sky, while the 𝑦′ axis points to the east on the sky (but see
the ‘important note’ below). The 𝑧′ axis points to the observer. This coordinate system is positively right-handed.
The radiation moves toward positive 𝑧′. Angles in the (𝑥′, 𝑦′) plane are measured counter-clockwise (angle=0 means
positive 𝑥′ direction, angle=𝜋/2 means positive 𝑦′ direction).
In the following we will (still completely consistent with the IAU deﬁnitions above, see the ‘important note’ below)
deﬁne “up” to be positive 𝑦′ and “right” to be positive 𝑥′. So, the (𝑥′, 𝑦′) coordinates are in a plane perpendicular to
the photon propagation, and oriented as seen by the observer of that photon. So the direction of propagation is toward
you, while 𝑦′ points up and 𝑥′ points to the right, just as one would normally orient it.
Important Note: This is fully equivalent to adjusting the IAU 1974 deﬁnition to have 𝑥′ pointing west and 𝑦′ pointing
north, which is perhaps more intuitive, since most images in the literature have this orientation. So for convenience of
communication, let us simply adjust the IAU 1974 deﬁnition to have positive 𝑥′ (‘right’) pointing west and positive 𝑦′
(‘up’) pointing north. It will have no further consequences for the deﬁnitions and internal workings of RADMC-3D
because RADMC-3D does not know what ‘north’ and ‘east’ are.
6.9. Polarization, Stokes vectors and full phase-functions
41

radmc3d, Release 2.0
The (𝑄, 𝑈) deﬁnition (linear polarization) is such that a linearly polarized ray with 𝑄= +𝐼, 𝑈= 𝑉= 0 has the
electric ﬁeld in the (𝑥′, 𝑦′) = (1, 0) direction, while 𝑄= −𝐼, 𝑈= 𝑉= 0 has the electric ﬁeld in the (𝑥′, 𝑦′) = (0, 1)
direction. If we have 𝑄= 0, 𝑈= +𝐼, 𝑉= 0 then the E-ﬁeld points in the 𝑥′ = 𝑦′ direction, while 𝑄= 0, 𝑈= −𝐼,
𝑉= 0 the E-ﬁeld points in the 𝑥′ = −𝑦′ direction (see Figure 1 of Hamaker & Bregman 1996).
The (𝑉) deﬁnition (circular polarization) is such that (quoting directly from the Hamaker & Bregman paper): For
right-handed circularly polarized radiation, the position angle of the electric vector at any point increases with time;
this implies that the 𝑦′ component of the ﬁeld lags the 𝑥′ component. Also the electric vectors along the line of sight
form a left-handed screw. The Stokes 𝑉is positive for right-handed circular polarization.
Angle>0 definition
+x’
−x’
+y’
−y’
Q=0, U=+I, V=0
+x’
+y’
−y’
Q=+I, U=0, V=0
Q=0, U=0, V=+I
−x’
+x’
−x’
+y’
−y’
+x’
−x’
+y’
−y’
α
Fig. 6.2: The deﬁnition of the Stokes parameters used in RADMC-3D, which is consistent with the IAU 1974 deﬁ-
nitions (see Hamaker & Bregman (1996) A&AS 117, pp.161). First panel shows that positive angle means counter-
clockwise. In the second to fourth panels the fat lines show how the tip of the real electric ﬁeld vector goes as a
function of time for an observer at a ﬁxed location in space watching the radiation. The radiation moves toward the
reader. We call the second panel (𝑄= +𝐼) ‘horizontally polarized’, the third panel (𝑈= +𝐼) ‘diagonally polar-
ized by +45 degrees’ and the fourth panel (𝑉= +𝐼) ‘right-handed circularly polarized’. In the images produced by
RADMC-3D (image.out, see Section OUTPUT: image.out or image_****.out and Fig. Fig. 8.1) the 𝑥′ direction
is the horizontal direction and the 𝑦′ direction is the vertical direction.
We can put these deﬁnitions into the standard formulae:
𝑄= 𝐼cos(2𝛽) cos(2𝜒)
𝑈= 𝐼cos(2𝛽) sin(2𝜒)
𝑉= 𝐼sin(2𝛽)
The angle 𝜒is the angle of the E-ﬁeld in the (𝑥′, 𝑦′) coordinates, measured counter-clockwise from 𝑥′ (consistent with
our deﬁnition of angles). Example: 𝜒= 45 deg = 𝜋/4, then cos(2𝜒) = 0 and sin(2𝜒) = 1, meaning that 𝑄= 0 and
𝑈/𝐼= +1. Indeed this is consistent with the above deﬁnition that 𝑈/𝐼= +1 is 𝐸′
𝑥= 𝐸′
𝑦.
The angle 2𝛽is the phase difference between the 𝑦′-component of the E-ﬁeld and the 𝑥′-component of the E-ﬁeld such
that for 0 < 𝛽< 𝜋/2 the E-ﬁeld rotates in a counter-clockwise sense. In other words: the 𝑦′-wave lags 2𝛽behind the
𝑥′ wave. Example: if we have 𝛽= 𝜋/4, i.e. 2𝛽= 𝜋/2, then cos(2𝛽) = 0 and sin(2𝛽) = 1, so we have 𝑄= 𝑈= 0
and 𝑉/𝐼= +1. This corresponds to the 𝑦′ wave being lagged 𝜋/2 behind the 𝑥′ wave, meaning that we have a counter-
clockwise rotation. If we use the right-hand-rule and point the thumb into the direction of propagation (toward us)
then the ﬁngers indeed point in counter-rotating direction, meaning that 𝑉/𝐼= +1 is righthanded polarized radiation.
In terms of the real electric ﬁelds of a plane monochromatic wave:
𝐸′
𝑥(𝑡) = 𝐸ℎcos(𝜔𝑡−∆ℎ)
𝐸′
𝑦(𝑡) = 𝐸𝑣cos(𝜔𝑡−∆𝑣)
(with 𝐸ℎ> 0 and 𝐸𝑣> 0 and ∆ℎ,𝑣are the phase lags of the components with respect to some arbitrary phase) we
42
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
can write the Stokes components as:
𝐼= 𝐸2
ℎ+ 𝐸2
𝑣
𝑄= 𝐸2
ℎ−𝐸2
𝑣
𝑈= 2𝐸ℎ𝐸𝑣cos(∆)
𝑉= 2𝐸ℎ𝐸𝑣sin(∆)
with ∆= ∆𝑣−∆ℎ= 2𝛽.
In terms of the {em complex} electric ﬁelds of a plane monochromatic wave (the sign before the 𝑖𝜔𝑡is important):
𝐸′
𝑥(𝑡) = 𝐸ℎ𝑒𝑖(Δℎ−𝜔𝑡)
𝐸′
𝑦(𝑡) = 𝐸𝑣𝑒𝑖(Δ𝑣−𝜔𝑡)
(with 𝐸ℎ> 0 and 𝐸𝑣> 0 real numbers and ∆ℎ,𝑣are the phase lags of the components with respect to some arbitrary
phase) we can write the Stokes components as:
𝐼= ⟨𝐸𝑥′𝐸*
𝑥′ + 𝐸𝑦′𝐸*
𝑦′⟩
𝑄= ⟨𝐸𝑥′𝐸*
𝑥′ −𝐸𝑦′𝐸*
𝑦′⟩
𝑈= ⟨𝐸𝑥′𝐸*
𝑦′ + 𝐸𝑦′𝐸*
𝑥′⟩
𝑉= 𝑖⟨𝐸𝑥′𝐸*
𝑦′ −𝐸𝑦′𝐸*
𝑥′⟩
6.9.2 Our conventions compared to other literature
The IAU 1974 deﬁnition is different from the deﬁnitions used in the Planck mission, for instance. So be careful. There
is something said about this on the website of the healpix software http://healpix.jpl.nasa.gov/html/intronode12.htm .
Our deﬁnition is also different from the Mishchenko book and papers (see below).
Compared to the books of
Mishchenko and Bohren & Huffman, our deﬁnitions are:
𝐼ours = 𝐼mishch = 𝐼bohrenhuffman
𝑄ours = 𝑄mishch = 𝑄bohrenhuffman
𝑈ours = −𝑈mishch = −𝑈bohrenhuffman
𝑉ours = −𝑉mishch = −𝑉bohrenhuffman
As you see: only the 𝑈and 𝑉change sign. For a 4 × 4 Müller matrix 𝑀this means that the 𝑀𝐼𝐼, 𝑀𝐼𝑄, 𝑀𝑄𝐼, 𝑀𝑄𝑄,
as well as the 𝑀𝑈𝑈, 𝑀𝑈𝑉, 𝑀𝑉𝑈, 𝑀𝑉𝑉stay the same, while 𝑀𝐼𝑈, 𝑀𝐼𝑉, 𝑀𝑄𝑈, 𝑀𝑄𝑉, as well as 𝑀𝑈𝐼, 𝑀𝑈𝑄, 𝑀𝑉𝐼,
𝑀𝑉𝑄components would ﬂip sign.
Compared to Mishchenko, Travis & Lacis book, what we call 𝑥′ they call 𝜃and what we call 𝑦′ they call 𝜑. In their
Figure 1.3 (which describes the deﬁnition of the Stokes parameters) they have the 𝜃direction pointing downward,
rather than toward the right, i.e. rotated by 90 degrees clockwise compared to RADMC-3D. However, since RADMC-
3D does not know what ‘right’ or ‘down’ are (only what 𝑥′ and 𝑦′ are) this rotation is merely a difference in how
we plot things in a ﬁgure, and has no consequences for the results, as long as we deﬁne how 𝑥′ and 𝑦′ are oriented
compared to our model (see Fig. Fig. 8.1 where 𝑥image is our 𝑥′ here and likewise for 𝑦′).
Bohren & Huffman have the two unit vectors plotted in the following way: e‖ is plotted horizontally to the left and e⊥
is plotted vertically upward. Compared to us, our 𝑥′ points toward {em minus} their e‖, while our 𝑦′ points toward
their e⊥, but since they plot their e‖ to the left, the orientation of our plot and their plots are consistent (i.e. if they say
‘pointing to the right’, they mean the same direction as we). But their deﬁnition of ‘right-handed circular polarization’
(clockwise when seen toward the source of the radiation) is our ‘left handed’.
The book by Wendisch & Yang ‘Theory of Atmospheric Radiative Transfer’ uses the same conventions as Bohren &
Huffman, but their basis vector e‖ is plotted vertically and e⊥is plotted horizontally to the right. This only affects
what they call ‘horizontal’ and ‘vertical’ but the math stays the same.
6.9. Polarization, Stokes vectors and full phase-functions
43

radmc3d, Release 2.0
Our deﬁnition is identical to the one on the English Wikipedia page on Stokes parameters http://en.wikipedia.org/wiki/
Stokes_parameters (on 2 January 2013), with the only exception that what they call ‘righthanded’ circularly polarized,
we call ‘lefthanded’. This is just a matter of nomenclature of what is right/left-handed, and since RADMC-3D does not
know what ‘right/lefthanded’ is, this difference has no further consequences. Note, however, that the same Wikipedia
page in different languages use different conventions! For instance, the German version of the page (on 2 January
2013) has the same Q and U deﬁnitions, but has the sign of V ﬂipped.
Note that in RADMC-3D we have no global deﬁnition of the orientation of 𝑥′ and 𝑦′ (see e.g. Section Deﬁning
orientation for non-observed radiation). If we make an image with RADMC-3D, then the horizontal (x-) direction in
the image corresponds to 𝑥′ and the vertical (y-) direction corresponds to 𝑦′, just as one would expect. So if you obtain
an image from RADMC-3D and all the pixels in the image have 𝑄= 𝐼and 𝑈= 𝑉= 0, then the electric ﬁeld points
horizontally in the image.
6.9.3 Deﬁning orientation for non-observed radiation
To complete our description of the Stokes parameters we still need to deﬁne in which direction we let 𝑥′ and 𝑦′ point
if we do not have an obvious observer, i.e. for radiation moving through our object of interest which may never reach
us. In the Monte Carlo modules of RADMC-3D, when polarization is switched on, any photon package does not only
have a wavelength 𝜆and a direction of propagation n associated with it, but also a second unit vector S, which is
always assured to obey:
|S| = 1
and
S · n = 0
This leaves, for a given n, one degree of freedom (any direction as long as it is perpendicular to n). It is irrelevant
which direction is chosen for this, but whatever choice is made, it sets the deﬁnitions of the 𝑥′ and 𝑦′ directions. The
deﬁnitions are:
𝑥′ =
points in the direction
S × n
𝑦′ =
points in the direction
S
𝑧′ =
points in the direction
n
So for 𝑄= −𝐼, 𝑈= 𝑉= 0 the electric ﬁeld points in the direction of S, while for 𝑄= +𝐼, 𝑈= 𝑉= 0 it is
perpendicular to both n and S.
However, if you are forced to change the direction of S for whatever reason, the Stokes components will also change.
This coordinate transformation works as follows. We can transform from a ‘-basis to a ‘’-basis by rotating the S-vector
counter-clockwise (as seen by the observer watching the radiation) by an angle 𝛼. Any vector (𝑥′, 𝑦′) in the ‘-basis
will become a vector (𝑥′′, 𝑦′′) in a ‘’-basis, given by the transformation:
(︂𝑥′′
𝑦′′
)︂
=
(︂cos(𝛼)
sin(𝛼)
−sin(𝛼)
cos(𝛼)
)︂(︂𝑥′
𝑦′
)︂
NOTE: We choose (𝑥′, 𝑦′) to be the usual counter-clockwise basis for the observer seeing the radiation. Rotating
the basis in counter-clockwise direction means rotating the vector in that basis in clockwise direction, hence the sign
convention in the matrix.
If we have (𝐼, 𝑄, 𝑈, 𝑉) in the ‘-basis (which we might have written as (𝐼′, 𝑄′, 𝑈′, 𝑉′) but by convention we drop the
‘), the (𝐼′′, 𝑄′′, 𝑈′′, 𝑉′′) in the ‘’-basis becomes
⎛
⎜
⎜
⎝
𝐼′′
𝑄′′
𝑈′′
𝑉′′
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
1
0
0
0
0
cos(2𝛼)
sin(2𝛼)
0
0
−sin(2𝛼)
cos(2𝛼)
0
0
0
0
1
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠
44
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.9.4 Polarized scattering off dust particles: general formalism
Suppose we have one dust particle of mass 𝑚grain and we place it at location x. Suppose this particle is exposed to
a plane wave of electromagnetic radiation pointing in direction nin with a ﬂux Fin = 𝐹in nin. This radiation can be
polarized, so that 𝐹in actually is a Stokes vector:
𝐹in =
⎛
⎜
⎜
⎝
𝐹𝐼,in
𝐹𝑄,in
𝐹𝑈,in
𝐹𝑉,in
⎞
⎟
⎟
⎠
This particle will scatter some of this radiation into all directions. What will the ﬂux of scattered radiation be, as
observed at location y ̸= x? Let us deﬁne the vector
r = y −x
its length
𝑟= |r|
and the unit vector
e𝑟= r
𝑟
We will assume that 𝑟≫𝑎where 𝑎is the particle size. We deﬁne the {em scattering matrix elements} 𝑍𝑖𝑗(with 𝑖, 𝑗
= 1, 2, 3, 4) such that the measured outgoing ﬂux from the particle at y is
Fout = 𝐹oute𝑟
𝐹out =
⎛
⎜
⎜
⎝
𝐹𝐼,out
𝐹𝑄,out
𝐹𝑈,out
𝐹𝑉,out
⎞
⎟
⎟
⎠= 𝑚grain
𝑟2
⎛
⎜
⎜
⎝
𝑍11
𝑍12
𝑍13
𝑍14
𝑍21
𝑍22
𝑍23
𝑍24
𝑍31
𝑍32
𝑍33
𝑍34
𝑍41
𝑍42
𝑍43
𝑍44
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐹𝐼,in
𝐹𝑄,in
𝐹𝑈,in
𝐹𝑉,in
⎞
⎟
⎟
⎠
The values 𝑍𝑖𝑗depend on the direction into which the radiation is scattered (i.e. e𝑟) and on the direction of the
incoming ﬂux (i.e. n), but not on 𝑟: the radial dependence of the outgoing ﬂux is taken care of through the 1/𝑟2 factor
in the above formula.
Some notes about our conventions are useful at this place. In many books the ‘scattering matrix’ is written as 𝐹𝑖𝑗
instead of 𝑍𝑖𝑗, and is deﬁned as the 𝑍𝑖𝑗for the case when radiation comes from one particular direction: n = (0, 0, 1).
In this manual and in the RADMC-3D code, however, we will always write 𝑍𝑖𝑗, because the symbol 𝐹can be confused
with ﬂux. The normalization of these matrix elements is also different in different books. In our case it has the
dimension cm2 gram−1 ster−1. The conversion from the conventions of other books is (where 𝑘= 2𝜋/𝜆is the wave
number in units of 1/cm):
𝑍𝑖𝑗,RADMC−3D = 𝑍𝑖𝑗,Mishchenko
𝑚grain
= 𝑆𝑖𝑗,BohrenH
𝑘2𝑚grain
except that for the 𝑍13, 𝑍14, 𝑍23, 𝑍24, 𝑍31, 𝑍41, 𝑍32, 𝑍42 elements (if non-zero) there must be a minus sign before the
𝑍𝑖𝑗,RADMC−3D because of the opposite 𝑈and 𝑉sign conventions (see Section Our conventions compared to other
literature).
Note that the 𝑆𝑖𝑗,BohrenH are the matrix elements obtained from the famous BHMIE.F code from the Bohren &
Huffman book (see Chapter Acquiring opacities from the WWW).
6.9. Polarization, Stokes vectors and full phase-functions
45

radmc3d, Release 2.0
6.9.5 Polarized scattering off dust particles: randomly oriented particles
In the special case in which we either have spherical particles or we average over a large number of randomly oriented
particles, the 𝑍𝑖𝑗elements are no longer dependent on both e𝑟and n but only on the angle between them:
cos 𝜃= n · e𝑟
So we go from 𝑍𝑖𝑗(n, e𝑟), i.e. a four-angle dependence, to 𝑍𝑖𝑗(𝜃), i.e. a one-angle dependence.
Now let us also assume that there is no netto helicity of the particles (they are either axisymmetric or there exist equal
amounts of particles as their mirror symmetric counterparts). In that case (see e.g. Mishchenko book) of the 16 matrix
elements only 6 are non-zero and independent:
𝐹out =
⎛
⎜
⎜
⎝
𝐹𝐼,out
𝐹𝑄,out
𝐹𝑈,out
𝐹𝑉,out
⎞
⎟
⎟
⎠= 𝑚grain
𝑟2
⎛
⎜
⎜
⎝
𝑍11
𝑍12
0
0
𝑍12
𝑍22
0
0
0
0
𝑍33
𝑍34
0
0
−𝑍34
𝑍44
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐹𝐼,in
𝐹𝑄,in
𝐹𝑈,in
𝐹𝑉,in
⎞
⎟
⎟
⎠
This is the case for scattering in RADMC-3D. Note that in Mie scattering the number of independent matrix elements
reduces to just 4 because then 𝑍22 = 𝑍11 and 𝑍44 = 𝑍33. But RADMC-3D also allows for cases where 𝑍22 ̸= 𝑍11
and 𝑍44 ̸= 𝑍33, i.e. for opacities resulting from more detailed calculations such as DDA or T-matrix calculations.
Now, as described above, the Stokes vectors only have meaning if the directions of 𝑥′ and 𝑦′ are well-deﬁned. For Eq.
(eq-scatmat-for-randorient-nohelic) to be valid (and for the correct meaning of the 𝑍𝑖𝑗elements) the following deﬁni-
tion is used: Before the scattering, the S-vector of the photon package is rotated (and the Stokes vectors accordingly
transformed) such that the new S-vector is perpendicular to both n and e𝑟. In other words, the scattering angle 𝜃is a
rotation of the photon propagation around the (new) S-vector. The sign convention is such that
(n × e𝑟) · S = sin(𝜃)
In other words, if we look into the incoming light (with 𝑧′ pointing toward us), then for sin(𝜃) > 0 the photon is
scattered into the 𝑥′ > 0, 𝑦′ = 0 direction (i.e. for us it is scattered to the right). The S vector for the outgoing photon
remains unchanged, since the new n is also perpendicular to it.
So what does this all mean for the opacity? The scattering opacity tells us how much of the incident radiation is
removed and converted into outgoing scattered radiation. The absorption opacity tells us how much of the incident
radiation is removed and converted into heat. For randomly oriented particles without netto helicity both opacities are
independent of the polarization state of the radiation. Moreover, the thermal emission is unpolarized in this case. This
means that in the radiative transfer equation the extinction remains simple:
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼𝐼
𝐼𝑄
𝐼𝑈
𝐼𝑉
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
𝑗emis,𝐼
0
0
0
⎞
⎟
⎟
⎠+
⎛
⎜
⎜
⎝
𝑗scat,𝐼
𝑗scat,𝑄
𝑗scat,𝑈
𝑗scat,𝑉
⎞
⎟
⎟
⎠−𝜌(𝜅abs + 𝜅scat)
⎛
⎜
⎜
⎝
𝐼𝐼
𝐼𝑄
𝐼𝑈
𝐼𝑉
⎞
⎟
⎟
⎠
where 𝐼𝐼, 𝐼𝑄, 𝐼𝑈, 𝐼𝑉are the intensities (erg s−1 cm−2 Hz−1 ster−1) for the four Stokes parameters, and likewise
for 𝑗emis and 𝑗scat, and ﬁnally, 𝑠the path length along the ray under consideration. Note that if we would allow for
ﬁxed-orientation dust particles (which we don’t), Eq. (eq-radtrans-randomorient) would become considerably more
complex, with extinction being matrix-valued and thermal emission being polarized.
Since 𝜅scat converts incoming radiation into outgoing scattered radiation, it should be possible to calculate 𝜅scat from
angular integrals of the scattering matrix elements. For randomly oriented non-helical particles we indeed have:
𝜅scat =
∮︁
𝑍11𝑑Ω= 2𝜋
∫︁+1
−1
𝑍11(𝜇)𝑑𝜇
46
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
where 𝜇= cos 𝜃. In a similar exercise we can calculate the anisotropy factor 𝑔from the scattering matrix elements:
𝑔=
2𝜋
𝜅scat
∫︁+1
−1
𝑍11(𝜇)𝜇𝑑𝜇
This essentially completes the description of scattering as it is implemented in RADMC-3D.
We can precalculate the 𝑍𝑖𝑗(𝜃) for every wavelength and for a discrete set of values of 𝜃, and store these in a table.
This is indeed the philosophy of RADMC-3D: You have to precompute them using, for instance, the Mie code of
Bohren and Huffman (see Chapter Acquiring opacities from the WWW for RADMC-3D compliant wrappers around
that code), and then provide them to RADMC-3D through a ﬁle called dustkapscatmat_xxx.inp (where xxx
is the name of the dust species) which is described in Section The dustkapscatmat_*.inp ﬁles. This ﬁle provides not
only the matrix elements, but also the 𝜅abs, 𝜅scat and 𝑔(the anisotropy factor). RADMC-3D will then internally check
that Eqs.(eq-scatmat-selfconsist-kappa, eq-scatmat-selfconsist-g) are indeed fulﬁlled. If not, an error message will
result.
One more note: As mentioned in Section Deﬁnitions and conventions for Stokes vectors, the sign conventions of the
Stokes vector components we use (the IAU 1974 deﬁnition) are different from the Bohren & Huffman and Mishchenko
books. For randomly oriented particles, however, the sign conventions of the 𝑍-matrix elements are not affected,
because those matrix elements that would be affected are those that are in the upper-right and lower-left quadrants of
the matrix, and these elements are anyway zero. So we can use, for randomly oriented particles, the matrix elements
from those books and their computer codes without having to adjust the signs.
6.9.6 Scattering and axially symmetric models
In spherical coordinates it is possible in RADMC-3D to set up axially symmetric models. The trick is simply to set the
number of 𝜑coordinate points nphi to 1 and to switch off the 𝜑-dimension in the grid (see Section INPUT (required):
amr_grid.inp). For isotropic scattering this mode has always been implemented. But for anisotropic scattering things
become more complex. For such a model the scattering remains a fully 3-D problem: the scattering source function
has to be stored not only as a function of 𝑟and 𝜃, but also as a function of 𝜑(for a given observer vantage point). The
reason is that anisotropic scattering {em does} care about viewing angle (in contrast to isotropic scattering). So even
though for an axisymmetric model the density and temperature functions only depend on 𝑟and 𝜃(and are therefore
mathematically 2-D), the scattering source function depends on 𝑟, 𝜃and 𝜑.
For this reason anisotropic scattering was, until version 0.40, not allowed for 2-D axisymmetric models. As of version
0.41 it is now possible to use the full polarized scattering mode (scattering_mode=5) also for 2-D axisymmet-
ric models. The intermediate scattering modes (scattering_mode=2, 3, 4) remain incompatible with 2-D
axisymmetry. Isotropic scattering remains, as before, fully compatible with 2-D axisymmetry.
One note of explanation: the way the full scattering is now implemented into the case of 2-D axisymmetry is the
following: internally we compute not just the scattering source function for one angle, but for a whole set of 𝜑angles
(even though the grid has no 𝜑-points). Each time a photon in the scattering Monte Carlo simulation enters a cell
(which in 2-D axisymmetry is an annulus), a loop over 360 𝜑angles is performed, and the scattering source function is
computed for all of these angles. {em This makes the code rather slow for each photon package!} But one needs fewer
photon packages to get sufﬁciently high signal-to-noise ratio. You can experiment with fewer 𝜑angles by adding, in
radmc3d.inp, the following line (as an example):
dust_2daniso_nphi = 60
in which case instead of 360 the model will only use 60 𝜑points. That will speed up the code signiﬁcantly, but of
course will treat the 𝜑-dependence of the scattering source function with lower precision.
For now the 2-D axisymmetric version of full scattering is only possible with ﬁrst-order integration.
6.9. Polarization, Stokes vectors and full phase-functions
47

radmc3d, Release 2.0
6.10 More about photon packages in the Monte Carlo simulations
In the ‘standard’ Monte Carlo approach, the input energy (e.g. starlight or, for the scattering Monte Carlo, the thermal
emission of dust) is divided into 𝑁equal energy packages of photons, which then travel through the model and
eventually either escape or get destroyed. This equal division scheme is, however, problematic for some model setups.
For instance, if you have stars with vastly different luminosity in the model, then the brightest of these stars will
dominate, by far, the number of output photon packages. This means that the material around low-brightness stars
(which, by their proximity to these low-brightness stars, are still dominated by heating by these low-brightness stars)
will experience very bad photon statistics.
To avoid this problem, RADMC-3D has, by default, its ‘weighted photon package mode’ switched on. This will make
sure that each source of energy (i.e. each star, but also each other type of source) emits the same amount of photons.
Only: bright stars will emit more energetic photon packages than dim stars.
The ‘weighted photon package mode’ will also solve another problem. Suppose a star lies far outside of the grid. It
will emit most of its photons in directions that completely miss the grid. This means that RADMC-3D would waste
a lot of time drawing random numbers for photons that will anyway not affect the model. Also here the ‘weighted
photon package mode’ solves the problem: It will focus the photon packages toward the model grid, and lower their
energy to compensate for their favorable focusing toward the grid.
NOTE: You can switch the mode off by setting mc_weighted_photons=0 in the radmc3d.inp ﬁle.
6.11 Polarized emission and absorption by aligned grains
NOTE: This mode is still in the testing phase
Grain alignment and its effects on radiative transfer is a complex topic. A review is e.g. Andersson, B.G., Lazarian,
A., & Vaillancourt, J.E. (2015) ‘Interstellar Dust Grain Alignment’, Annual Review of Astronomy and Astrophysics,
53(1), 501–539. In RADMC-3D grain alignment is included only in a limited form. First and foremost: RADMC-3D
does not know about the physics {em causing} the grain alignment. You, the user, will have to tell how the grain are
aligned by giving the code a directional vector ﬁeld and for each wavelength the degree to which the grain is aligned
to that directional vector (more on this later). This is according to the RADMC-3D philosophy of doing {em only}
the radiative transfer and leaving the physics of the material to the user.
6.11.1 Basics
Suppose we have ﬂattened (oblate) ellipsoidal grains with one axis of symmetry and no helicity. (While helicity may
be needed to radiatively spin up grains, we assume that on average the helicity of the grains is zero.). Let us assume that
they are aligned with that symmetry axis along the 𝑦-axis. We view radiation from the point where the 𝑧-axis points
toward us. Horizontally polarized light (which has 𝐸-ﬁeld in horizontal direction, i.e. in 𝑥-direction) has 𝑄/𝐼= +1,
vertically polarized light (with the ⃗𝐸vector aligned with the symmetry axis of the grain) has 𝑄/𝐼= −1. We can then
assume that the dust has different extinction coefﬁcients for the horizontal and vertical axis. Let us call these:
𝛼abs,𝜈,h ≡𝜌𝑑𝜅abs,𝜈,h
𝛼abs,𝜈,v ≡𝜌𝑑𝜅abs,𝜈,v
We can deﬁne 𝐼, 𝑄, 𝑈and 𝑉in terms of the electric ﬁeld components 𝐸𝑥and 𝐸𝑦. The electric ﬁeld components for
a perfectly coherent wave can be written as
𝐸𝑥= 𝐸𝑥,0 cos(𝜔𝑡−∆𝑥)
𝐸𝑦= 𝐸𝑦,0 cos(𝜔𝑡−∆𝑦)
where ∆𝑥and ∆𝑦are phase lags. The phase lag between the 𝑦and 𝑥-ﬁelds is ∆= ∆𝑦−∆𝑥, meaning that for positive
∆the 𝑦-ﬁeld lags behind the 𝑥-ﬁeld. We then deﬁne the Stokes components as:
48
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
𝐼= 𝐸2
𝑥,0 + 𝐸2
𝑦,0
𝑄= 𝐸2
𝑥,0 −𝐸2
𝑦,0
𝑈= 2𝐸𝑥,0𝐸𝑦,0 cos ∆
𝑉= 2𝐸𝑥,0𝐸𝑦,0 sin ∆
Note that for 𝑉= 𝐼(∆= 𝜋/2, i.e. the 𝐸𝑦lags 𝜋/2 behind 𝐸𝑥) we have right-handed circularly polarized light,
meaning that the tip of the ⃗𝐸ﬁeld at a ﬁxed point in space, when looking into the light (the propagation of light is
toward the reader) rotates counter-clockwise (when the 𝑥-coordinate points right, and the 𝑦-coordinate points up). The
3-D helix of his ﬁeld will be {em left-handed} (when the z-coordinate points into the propagation direction of the light,
i.e. toward the reader, i.e. a right-handed coordinate system). For 𝑄= 𝐼we have linearly polarized light in which the
⃗𝐸-ﬁeld lies in the 𝑥-direction. For 𝑈= 𝐼we have linearly polarized light in which ⃗𝐸lies along the 𝑥= 𝑦line (when
looking into the light). These deﬁnitions are consistent with the IAU 1974 deﬁnitions (Hamaker & Bregman 1996,
A&AS 117, pp.161).
The 𝐸𝑥and 𝐸𝑦get absorbed in the following way:
𝐸′
𝑥,0 = 𝐸𝑥,0𝑒−1
2 𝛼abs,𝜈,h𝑠
𝐸′
𝑦,0 = 𝐸𝑦,0𝑒−1
2 𝛼abs,𝜈,v𝑠
where 𝑠is a length along the ray.
For this kind of problem it is convenient to introduce the so-called modiﬁed Stokes parameters 𝐼h and 𝐼v:
𝐼h = 1
2(𝐼+ 𝑄)
𝐼v = 1
2(𝐼−𝑄)
so that we have
𝐼= 𝐼h + 𝐼v
𝑄= 𝐼h −𝐼v
so that one can say, for perfectly coherent light,
𝐼h = 𝐸2
𝑥,0
𝐼v = 𝐸2
𝑦,0
With this we get the following extinction law:
𝐼′
h = 𝐼h𝑒−𝛼abs,𝜈,h𝑠
𝐼′
v = 𝐼v𝑒−𝛼abs,𝜈,v𝑠
How do 𝑈and 𝑉extinct? If we use Eqs. (eq-def-stokes-u, eq-def-stokes-v), and assume that the phase lag ∆will not
change during the extinction, then
𝑈′ = 𝑈𝑒−1
2 𝛼abs,𝜈,h𝑠𝑒−1
2 𝛼abs,𝜈,v𝑠
= 𝑈𝑒−1
2 (𝛼abs,𝜈,h+𝛼abs,𝜈,v)𝑠
This means that
𝛼abs,𝜈,uv = 1
2 (𝛼abs,𝜈,h + 𝛼abs,𝜈,v)
6.11. Polarized emission and absorption by aligned grains
49

radmc3d, Release 2.0
and
𝐼′
u = 𝐼u𝑒−𝛼abs,𝜈,uv𝑠
𝐼′
v = 𝐼v𝑒−𝛼abs,𝜈,uv𝑠
In matrix notation
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼h
𝐼v
𝑈
𝑉
⎞
⎟
⎟
⎠= −
⎛
⎜
⎜
⎝
𝛼h
0
0
0
0
𝛼v
0
0
0
0
𝛼uv
0
0
0
0
𝛼uv
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐼h
𝐼v
𝑈
𝑉
⎞
⎟
⎟
⎠
If we translate this to the usual Stokes components we get
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠= −
⎛
⎜
⎜
⎝
𝛼1
𝛼2
0
0
𝛼2
𝛼1
0
0
0
0
𝛼1
0
0
0
0
𝛼1
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠
with
𝛼1 = 1
2 (𝛼abs,𝜈,h + 𝛼abs,𝜈,v) = 𝛼abs,𝜈,uv
𝛼2 = 1
2 (𝛼abs,𝜈,h −𝛼abs,𝜈,v)
The emission will be also independently in horizontal and vertical direction. But nothing will be emitted in U or
V direction. So it is most convenient to express the emission/absorption process in terms of the modiﬁed Stokes
parameters:
𝑑𝐼𝜈,h
𝑑𝑠
= 𝛼abs,𝜈,h(1
2𝐵𝜈(𝑇) −𝐼𝜈,h)
𝑑𝐼𝜈,v
𝑑𝑠
= 𝛼abs,𝜈,v(1
2𝐵𝜈(𝑇) −𝐼𝜈,v)
𝑑𝑈𝜈
𝑑𝑠= −𝛼abs,𝜈,uv𝑈𝜈
𝑑𝑉𝜈
𝑑𝑠= −𝛼abs,𝜈,uv𝑉𝜈
In terms of matrix notation this becomes
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼h
𝐼v
𝑈
𝑉
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
1
2𝛼h𝐵𝜈(𝑇)
1
2𝛼v𝐵𝜈(𝑇)
0
0
⎞
⎟
⎟
⎠−
⎛
⎜
⎜
⎝
𝛼h
0
0
0
0
𝛼v
0
0
0
0
𝛼uv
0
0
0
0
𝛼uv
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐼h
𝐼v
𝑈
𝑉
⎞
⎟
⎟
⎠
In terms of the normal Stokes parameters this becomes
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
𝛼1𝐵𝜈(𝑇)
𝛼2𝐵𝜈(𝑇)
0
0
⎞
⎟
⎟
⎠−
⎛
⎜
⎜
⎝
𝛼1
𝛼2
0
0
𝛼2
𝛼1
0
0
0
0
𝛼1
0
0
0
0
𝛼1
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠
or written slightly differently:
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
𝛼1
𝛼2
0
0
𝛼2
𝛼1
0
0
0
0
𝛼1
0
0
0
0
𝛼1
⎞
⎟
⎟
⎠
⎡
⎢⎢⎣
⎛
⎜
⎜
⎝
𝐵𝜈(𝑇)
0
0
0
⎞
⎟
⎟
⎠−
⎛
⎜
⎜
⎝
𝐼
𝑄
𝑈
𝑉
⎞
⎟
⎟
⎠
⎤
⎥⎥⎦
So to sum things up: We need only the absorption opacity for light with ⃗𝐸perpencidular to the symmetry axis
(𝜅abs,𝜈,ℎ) and the absorption opacity for light with ⃗𝐸parallel to the symmetry axis (𝜅abs,𝜈,𝑣).
50
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.11.2 Implementation in RADMC-3D
Polarized emission in the images and spectra
When creating images (and spectra) the camera module of RADMC-3D performs a ray-tracing calculation (‘volume
rendering’) through the grid. Normally (for randomly oriented grains) the extinction along the line of sight is always
unpolarized, i.e. each Stokes component is extincted equally much. The thermal emission along the line of sight is
also unpolarized.
Now, however, we wish to include the effect of grain alignment in the ray-tracing. We assume that at position ⃗𝑥in
the grid our oblate grain is aligned such that the minor axis points in the direction of the orientation vector ⃗𝑛align(⃗𝑥).
If the grain is prolate, we assume that it spins along one of its minor axes such that this spin axis is pointing along
⃗𝑛align(⃗𝑥), so that, in effect, it acts as if it were an oblate grain again. In practice the alignment vector ⃗𝑛align(⃗𝑥) does
not lie always in the plane of the sky of the observer. Instead it will have an angle 𝜃with the line-of-sight direction
vector ⃗𝑛los (note that this 𝜃angle is different from the scattering angle 𝜃), deﬁned as
cos 𝜃≡= |⃗𝑛align · ⃗𝑛los|
Here we assume that the grains have top/bottom symmetry so that we only have to concern ourselves with the positive
values of cos 𝜃, hence the ||. If cos 𝜃= 1 then we see the oblate grain from the top or the bottom, so that we do not
expect any polarized emission. The strongest polarized emission is expected when cos 𝜃= 0, which means that the
oblate grain is seen edge-on.
We can now deﬁne the ‘projected alignment vector’ ⃗𝑛align,proj, which is the alignment vector projected into the image
plane:
⃗𝑛align,proj = ⃗𝑛align −(⃗𝑛align · ⃗𝑛los) ⃗𝑛los
To use the equations from Section Basics we must ﬁrst rotate our image plane coordinates (𝑥, 𝑦) to new coordinates
(𝑥′, 𝑦′) such that the 𝑦′ (vertical) direction points along the ⃗𝑛align,proj vector while the 𝑥′ (horizontal) direction points
perpendicular to it. Let us write the Stokes vector of the radiation along the line of sight (𝐼in, 𝑄in, 𝑈in, 𝑉in), where we
implicitly know that these are also a function of frequency 𝜈. This Stokes vector is deﬁned with respect to the vector ⃗𝑆
which is perpendicular to the line-of-sight direction vector ⃗𝑛los and deﬁnes the direction in which the 𝑦-coordinate of
the image plane points. We must now express this incoming radiation (at the start of the segment) in the new (𝑥′, 𝑦′)
image plane coordinates, i.e. with respect to the new vector ⃗𝑆′ that points along ⃗𝑛align,proj (i.e. ⃗𝑆′ is the normalized
version of ⃗𝑛align,proj). This rotation is performed using
⎛
⎜
⎜
⎝
𝐼′
𝑄′
𝑈′
𝑉′
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
1
0
0
0
0
cos(2𝛼)
sin(2𝛼)
0
0
−sin(2𝛼)
cos(2𝛼)
0
0
0
0
1
⎞
⎟
⎟
⎠
⎛
⎜
⎜
⎝
𝐼in
𝑄in
𝑈in
𝑉in
⎞
⎟
⎟
⎠
where 𝛼is the angle between ⃗𝑆′ and ⃗𝑆such that if (as seen by the observer) ⃗𝑆′ lies counter-clockwise from ⃗𝑆, 𝛼is
positive (the usual deﬁnition). With this new Stokes vector (𝐼′, 𝑄′, 𝑈′, 𝑉′) we will now use the equations of Section
Basics.
To be able to perform this rotation in a uniquely deﬁned way, it is necessary that along each segment along the line
of sight this new (𝑥′, 𝑦′) orientation stays ﬁxed (but can vary from segment to segment). As the line-of-sight ray
enters a cell and leaves it again, this line element (segment) will have its image-plane coordinates rotated according
to the alignment vector of that cell. As a result, the integration must be done ﬁrst order (assuming all source terms to
be constant along the segment). In principle second order integration would also be possible, but then the trick with
the rotation of the image coordinate plane such that 𝑦′ points along the orientation vector does no longer work, and
the integration of the formal transfer equation would become much more complex, involving the full Müller matrix
formulation. We will not do this, so we will stick to ﬁrst order integration of Eq. eq-formal-rt-emisabs-in-rotated-
system.
6.11. Polarized emission and absorption by aligned grains
51

radmc3d, Release 2.0
For convenience we will leave out the primes (‘) from here on, so while we write (𝐼, 𝑄, 𝑈, 𝑉) we mean in fact
(𝐼′, 𝑄′, 𝑈′, 𝑉′). We now compute 𝐼h and 𝐼v using Eqs. (eq-modif-stokes-h, eq-modif-stokes-v). Now, along this
segment of the ray, we can write Eq. eq-formal-rt-emisabs-in-rotated-system in the following form:
𝑑
𝑑𝑠
⎛
⎜
⎜
⎝
𝐼h
𝐼v
𝑈
𝑉
⎞
⎟
⎟
⎠=
⎛
⎜
⎜
⎝
𝛼h
0
0
0
0
𝛼v
0
0
0
0
𝛼uv
0
0
0
0
𝛼uv
⎞
⎟
⎟
⎠
⎡
⎢⎢⎣
⎛
⎜
⎜
⎝
1
2𝐵𝜈(𝑇)
1
2𝐵𝜈(𝑇)
0
0
⎞
⎟
⎟
⎠−
⎛
⎜
⎜
⎝
𝐼h
𝐼v
𝑈
𝑉
⎞
⎟
⎟
⎠
⎤
⎥⎥⎦
It becomes clear that it is easy to perform the ﬁrst order integration of this equation along this ray segment:
𝐼h,end = 𝑒−𝜏ℎ𝐼h,start + 1
2𝑒−𝜏ℎ𝐵𝜈(𝑇)
𝐼v,end = 𝑒−𝜏𝑣𝐼v,start + 1
2𝑒−𝜏𝑣𝐵𝜈(𝑇)
𝑈end = 𝑒−𝜏𝑢𝑣𝑈start
𝑉end = 𝑒−𝜏𝑢𝑣𝑉start
where ‘start’ stands for the start of the ray segment, and ‘end’ the end of the ray segment (which becomes the start of
the next ray segment), and 𝜏ℎ= 𝛼h∆𝑠, 𝜏𝑣= 𝛼v∆𝑠and 𝜏𝑢𝑣= 𝛼uv∆𝑠, with ∆𝑠being the length of the segment.
We now compute 𝐼end and 𝑄end, and rotate back to the (𝑥, 𝑦) image plane coordinate system (i.e. using ⃗𝑆instead
of ⃗𝑆′ to deﬁne the Stokes parameters) by applying Eq. eq-rot-stokes-align but now with 𝛼→−𝛼, and we have the
values of the Stokes parameter at the end of the ray segment. Now we repeat this whole procedure for the next ray
segment.
Polarized emission as source term in the Monte Carlo simulation
The polarization effects and anisotropic emission by aligned grains will also affect the Monte Carlo simulations.
For the thermal Monte Carlo (see Section The thermal Monte Carlo simulation: computing the dust temperature) this
effect is not included. In principle it should be included, but it would slow the code down, and it is unlikely to play
a signiﬁcant role for the dust temperature, in particular since the anisotropy of thermal emission is not expected to be
so strong (and the polarization state is irrelevant for computing the dust temperature). It is clear that we make a small
error here, but we believe that this is well within the much stronger uncertainties of the dust opacities.
For the scattering Monte Carlo (see Section Scattered light in images and spectra: The ‘Scattering Monte Carlo’
computation), however, this effect may be important! The polarization caused by scattering of light off dust grains
yields of course different results if the incident light is unpolarized or if it is already strongly polarized through, for
instance, polarized thermal emission. In RADMC-3D this is therefore built into the scattering Monte Carlo. This will
not slow down the code much because (in contrast to the thermal Monte Carlo) the polarized thermal emission only
has to be computed at the start of each photon path, if the photon is emitted by the dust.
The way this is included is that when a photon is emitted by the dust inside a cell, RADMC-3D ﬁrst randomly
chooses which of the dust species emits the photon (the probabilities are weighted by the contribution each dust
species makes to the emissivity at the given wavelength). Then the emission direction is randomly chosen, based
on the 𝜃-dependent probability function (where 𝜃is the angle with the alignment direction) given by the average of
the orthogonal (horizontal) and parallel (vertical) absorption opacities. Once the emission direction is chosen, the
polarization state of the photon package is computed based on the orthogonal and parallel absorption opacities. Then
the photon package is sent on its way.
Note that if alignment_mode = -1 then the polarized (and anisotropic) thermal emission by aligned grains is
only included in the ray-tracing for images and spectra, while for alignment_mode = 1 it is also included in the
scattering Monte Carlo computation.
52
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.11.3 Consistency with other radiative processes
The above equations assume that the absorption/emission is the only radiative process included. However, in practice
we also have other processes involved, such as line emission/absorption or the scattering source function. The way this
can be treated here is to simply add these additional opacities to all four components of the extinction matrix of Eq.
(eq-formal-rt-emisabs-in-rotated-system) and to add the additional emissivities to the vector with the Planck functions
in Eq. (eq-formal-rt-emisabs-in-rotated-system). For the scattered light emissivity (which is a Stokes vector) we must
also ﬁrst perform a rotation from ⃗𝑆to ⃗𝑆′ using the Stokes rotation formula of Eq. (eq-rot-stokes-align) before we add
this emissivity to the equation. If we include the effect of alignment on the scattering (see Section Effect of aligned
grains on the scattering) then also the scattering extinction will be different for the orthogonal (horizontal) and parallel
(vertical) Stokes components. That is easy to include in this formalism.
6.11.4 Input ﬁles for RADMC-3D for aligned grains
In RADMC-3D we implement the functions 𝜅abs,𝜈,ℎand 𝜅abs,𝜈,𝑣as a function of angle 𝜃which the alignment axis
makes with the light of sight. For 𝜃we see the oblate grain from the top (face-on), so that there is no asymmetry
between horizontal (orthogonal to the alignment orientation vector) and vertical (parallel to the alignment orientation
vector). Then we will have 𝜅abs,𝜈,ℎ= 𝜅abs,𝜈,𝑣. For 𝜃= 90∘we will have the maximum difference between 𝜅abs,𝜈,ℎ
and 𝜅abs,𝜈,𝑣. We write
𝜅abs,𝜈,ℎ(𝜃) = 𝜅abs,𝜈𝑘𝜈,ℎ(𝜃)
𝜅abs,𝜈,𝑣(𝜃) = 𝜅abs,𝜈𝑘𝜈,𝑣(𝜃)
where 𝑘𝜈,ℎ(𝜃) and 𝑘𝜈,𝑣(𝜃) are dimensionless functions, and where we take 𝜃∈[0, 90] (in degrees), or equivalently
cos(𝜃) ∈[0, 1]. We impose the condition that if we randomly orient this grain, the average opacity becomes the one
we computed for the randomly oriented grains:
∫︁∞
0
1
2 [𝜅abs,𝜈,ℎ(𝜃) + 𝜅abs,𝜈,𝑣(𝜃)] 𝑑𝜇= 𝜅abs,𝜈
This yields the following integration condition on the dimensionless 𝑘𝜈,ℎand 𝑘𝜈,𝑣:
∫︁∞
0
1
2 [𝑘𝜈,ℎ(𝜃) + 𝑘𝜈,𝑣(𝜃)] 𝑑𝜇= 1
If we set, for all values of 𝜃, 𝑘𝜈,ℎ(𝜃) = 𝑘𝜈,𝑣(𝜃) = 1 then we retrieve the result for spherical grains.
In RADMC-3D the functions 𝑘𝜈,ℎ(𝜃) and 𝑘𝜈,𝑣(𝜃) are read in via the ﬁle dustkapalignfact_*.inp. This ﬁle
has the following structure:
# Any amount of arbitrary
# comment lines that tell which opacity this is.
# Each comment line must start with an # or ; or ! character
iformat
<=== Typically 1 at present
nlam
<=== Nr of wavelengths
nmu
<=== Nr of angles sampled
lambda[1]
<=== Wavelength grid in micron
...
lambda[nlam]
theta[1]
<=== Angle grid in degrees
...
theta[nmu]
k_orth[1,1]
k_para[1,1]
<=== The arrays k_orth and k_para
...
(continues on next page)
6.11. Polarized emission and absorption by aligned grains
53

radmc3d, Release 2.0
(continued from previous page)
k_orth[nmu,1]
k_para[nmu,1]
k_orth[1,2]
k_para[1,2]
...
k_orth[nmu,2]
k_para[nmu,2]
...
...
...
k_orth[1,nlam]
k_para[1,nlam]
...
k_orth[nmu,nlam]
k_para[nmu,nlam]
The angles theta are in degrees and must start at 0 and end at 90, or vice versa. The nmu does not have to be the
same (and the angles do not have to be the same) as those in the dustkapscatmat_*.inp ﬁle. But the wavelength
grid must be identical to the one in the dustkapscatmat_*.inp ﬁle.
In order to make RADMC-3D read this ﬁle dustkapalignfact_*.inp the dustopac.inp ﬁle should, for
this particular dust species, have ‘20’ as the way in which this dust species is read (instead of 10 which is used for
polarized scattering with the Z matrix).
In addition, RADMC-3D also needs to know the orientation direction of the grains. This is a vector ﬁeld ⃗𝑝align(⃗𝑥).
The length of these vectors should be between 0 and 1, where 1 means that the grains are perfectly aligned and 0
means they are not aligned at all. The efﬁciency 𝜖align is thus given by
𝜖align(⃗𝑥) = |⃗𝑝align(⃗𝑥)|
The directional unit-vector of alignment ⃗𝑛align(⃗𝑥) is thus
⃗𝑛align(⃗𝑥) =
(︀
𝜖align(⃗𝑥)
)︀−1⃗𝑝align(⃗𝑥)
The
⃗𝑝align(⃗𝑥)
vector
ﬁeld
is
in
the
ﬁle
grainalign_dir.inp
(or
its
binary
formatted
version
grainalign_dir.binp).
The format of this ﬁle is exactly the same as that of the gas velocity ﬁle
gas_velocity.inp. The ascii format looks like:
iformat
<=== Typically 1 at present
nrcells
p_x[1]
p_y[1]
p_z[1]
..
p_x[nrcells] p_y[nrcells] p_z[nrcells]
Note that |⃗𝑝align(⃗𝑥)| should never be > 1. If it is found to be signiﬁcantly > 1 at some point in the grid, then an error
occurs. If it is only a tiny bit above 1, due to rounding errors, it will be normalized to 1.
The way in which partial alignment (0 < 𝜖align < 1) is treated in RADMC-3D is to treat the opacities and emissivities
as simple linear sums of fully aligned and non aligned versions. For instance, Eqs. (eq-align-kappa-k-h, eq-align-
kappa-k-v) then become
𝜅abs,𝜈,ℎ(𝜃) = 𝜅abs,𝜈[𝜖align𝑘𝜈,ℎ(𝜃) + 1 −𝜖align]
𝜅abs,𝜈,𝑣(𝜃) = 𝜅abs,𝜈[𝜖align𝑘𝜈,𝑣(𝜃) + 1 −𝜖align]
In order to tell RADMC-3D that it should include the effect of alignment on the thermal emission of dust grains one
must add a line in the radmc3d.inp ﬁle with:
alignment_mode = 1
The example model in examples/run_simple_1_align/ demonstrates how the input ﬁles have to be made to
have RADMC-3D treat the aligned dust grains for thermal emission.
54
Chapter 6. Dust continuum radiative transfer

radmc3d, Release 2.0
6.11.5 Effect of aligned grains on the scattering
This is, currently, not yet implemented.
6.11. Polarized emission and absorption by aligned grains
55

radmc3d, Release 2.0
56
Chapter 6. Dust continuum radiative transfer

CHAPTER
SEVEN
LINE RADIATIVE TRANSFER
RADMC-3D is capable of modeling radiative transfer in molecular and/or atomic lines. Due to the complexity of line
radiative transfer, and the huge computational and memory requirements of full-scale non-LTE line transfer, RADMC-
3D has various different modes of line transfer. Some modes are very memory efﬁcient, but slower, while others are
faster, but less memory efﬁcient, yet others are more accurate but much slower and memory demanding. The default
mode (and certainly recommended initially) is LTE ray-tracing in the slow but memory efﬁcient way: the simple LTE
mode (see Section Line transfer modes and how to activate the line transfer). Since this is the default mode, you do
not need to specify anything to have this selected.
7.1 Quick start for adding line transfer to images and spectra
Do properly model line transfer requires dedication and experimentation. This is not a simple task. See Section What
can go wrong with line transfer? for an analysis of several pitfalls one may encounter. However, nothing is better than
experimenting and thus gaining hands-on experience. So the easiest and quickest way to start is to start with one of
the simple line transfer test models in the examples/ directory.
So simply visit examples/run_test_lines_1/, examples/run_test_lines_2/ or examples/
run_test_lines_3/ and follow the directions in the README ﬁle. The main features of adding line ray tracing
to a model is to add the following ﬁles into any previously constructed model with dust radiative transfer:
• lines.inp: A control ﬁle for line transfer.
• molecule_co.inp: or any other molecular data ﬁle containing properties of the molecule or atom.
• numberdens_co.inp (or its binary version, see Chapter Binary I/O ﬁles) or that of another molecule: The
number density of that molecule in units of cm−3.
• gas_temperature.inp (or its binary version, see Chapter Binary I/O ﬁles): The gas temperature at each
grid cell.
You do not need to specify this ﬁle if you add the keyword tgas_eq_tdust = 1 into the
radmc3d.inp ﬁle.
7.2 Some deﬁnitions for line transfer
The formal transfer equation is:
𝑑𝐼𝜈(𝜔)
𝑑𝑠
= 𝑗𝜈(𝜔) −𝛼𝜈(𝜔)𝐼𝜈(𝜔)
which is true also for the lines. Here 𝜔is the direction, 𝜈the frequency, 𝐼the intensity. The emissivity 𝑗𝜈and
extinction 𝛼𝜈for each line (given by 𝑖=upper level and 𝑗=lower level) is given by:
57

radmc3d, Release 2.0
𝑗𝑖𝑗(Ω, 𝜈) = ℎ𝜈
4𝜋𝑁𝑛𝑖𝐴𝑖𝑗𝜙𝑖𝑗(𝜔, 𝜈)
𝛼𝑖𝑗(𝜔, 𝜈) = ℎ𝜈
4𝜋𝑁(𝑛𝑗𝐵𝑗𝑖−𝑛𝑖𝐵𝑖𝑗)𝜙𝑖𝑗(𝜔, 𝜈)
Here 𝑁is the number density of the molecule, 𝑛𝑖is the fraction of the molecules that are in level 𝑖, 𝐴𝑖𝑗is the Einstein
coefﬁcient for spontaneous emission from level 𝑖to level 𝑗, and 𝐵𝑖𝑗and 𝐵𝑗𝑖are the Einstein-B-coefﬁcients which
obey:
𝐴𝑖𝑗= 2ℎ𝜈3
𝑖𝑗
𝑐2
𝐵𝑖𝑗, 𝐵𝑗𝑖𝑔𝑗= 𝐵𝑖𝑗𝑔𝑖
where 𝑔are the statistical weights of the levels, ℎthe Planck constant and 𝑐the light speed. The symbol 𝜙𝑖𝑗(𝜔, 𝜈) is
the line proﬁle function. For zero velocity ﬁeld 𝜙𝑖𝑗(𝜔, 𝜈) = ˜𝜙𝑖𝑗(𝜈), i.e. the line proﬁle function is independent of
direction. The tilde is to say that this is the comoving line proﬁle. It is given by
˜𝜙𝑖𝑗(𝜈) =
𝑐
𝑎tot𝜈𝑖𝑗
√𝜋exp
(︃
−𝑐2(𝜈−𝜈𝑖𝑗)2
𝑎2
tot𝜈2
𝑖𝑗
)︃
where 𝜈𝑖𝑗is the line-center frequency for the line and 𝑎tot is the line width in units of cm/s. For pure thermal broadning
we have
𝑎tot = 𝑎therm =
√︂
2𝑘𝑇gas
𝑚mol
where 𝑚mol is the weight of the molecule in gram, 𝑘is the Boltzmann constant, 𝑇gas the gas temperature in K. As we
shall discuss in Section INPUT: The local microturbulent broadening (optional): we can also add ‘microturbulent line
broadning’ 𝑎turb, also in cm/s:
𝑎tot =
√︁
𝑎2
turb + 𝑎2
therm =
√︂
𝑎2
turb + 2𝑘𝑇gas
𝑚mol
When we have macroscopic velocities in our model, then the line proﬁle becomes angle-dependent (at a given lab-
frame frequency):
𝜙𝑖𝑗(𝜔, 𝜈) = ˜𝜙𝑖𝑗
(︀
𝜈(1 −⃗𝜔· ⃗𝑣/𝑐) −𝜈𝑖𝑗
)︀
The radiative transfer equation for non overlapping lines is then
𝑑𝐼𝑖𝑗(𝜔, 𝜈)
𝑑𝑠
= 𝑗𝑖𝑗(𝜔, 𝜈) −𝛼𝑖𝑗(𝜔, 𝜈)𝐼𝑖𝑗(𝜔, 𝜈) .
But RADMC-3D naturally includes overlapping lines, at least in the ray-tracing (for spectra and images). For non-LTE
modes the line overlapping is not yet (as of December 2011) included.
7.3 Line transfer modes and how to activate the line transfer
Line transfer can be done in various different ways. This is controlled by the global variable lines_mode (see
below) and by the nature of the molecular/atomic data (see discussion in Section INPUT: The line.inp ﬁle).
58
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
7.3.1 Two different atomic/molecular data ﬁle types
Let us start with the latter: RADMC-3D does not have any atomic or molecular data hard-coded inside. It reads these
data from data ﬁles that you provide. There are two fundamentally different ways to feed atomic/molecular data into
RADMC-3D:
• Files containing the full level and line information (named molecule_XXX.inp, where XXX is the name of
the molecule or atom). Atoms or molecules for which this data is provided can be treated in LTE as well as in
non-LTE.
• Files containing only a line list (named linelist_XXX.inp, where XXX is the name of the molecule or
atom). Atoms or molecules for which this data is provided can only be treated in LTE.
7.3.2 The different line modes (the lines_mode parameter)
For the atoms or molecules for which the full data are speciﬁed (the molecule_XXX.inp ﬁles) RADMC-3D has
various different line transfer modes, including different treatments of LTE or non-LTE. Which of the modes you want
RADMC-3D to use can be speciﬁed in the radmc3d.inp ﬁle by setting the variable lines_mode, for instance,
by adding the following line to radmc3d.inp:
lines_mode = 3
for LVG + Escape Probability populations. If no option is given, then the LTE mode (lines_mode=1) is used.
The various line modes are:
• LTE mode (=default mode): [lines_mode=1]
In this mode the line radiative transfer is done under LTE assumptions.
• User-deﬁned populations: [lines_mode=2]
This calls the routine userdef_compute_levelpop() to compute the level populations. This allows the
user to specify the populations of the levels of the molecules freely.
• Large Velocity Gradient (Sobolev) populations: [lines_mode=3]
This is one of the non-LTE modes of RADMC-3D. This mode calculates the angle-averaged velocity gradient,
and uses this to compute the level populations according to the Large Velocity Gradient method (also often
called Sobolev’s method). This method is like an escape probability method, where the escape probability is
calculated based on the velocity gradient. For this mode to work, the velocity ﬁeld has to be read in, as well as
at least one of the number densities of the collision partners of the molecule. See Section Non-LTE Transfer:
The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method.
• Optically Thin non-LTE level populations method: [lines_mode=4]
This is one of the non-LTE modes of RADMC-3D. This mode calculates the non-LTE level populations under
the assumption that all emitted line radiation escapes and is not reabsorbed. For this mode to work, at least one
of the number densities of the collision partners of the molecule. See Section Non-LTE Transfer: The optically
thin line assumption method.
• User-deﬁned populations: [lines_mode=-10]
This calls the routine userdef_general_compute_levelpop() on-the-ﬂy during the ray-tracing. This
is very much like userdef_compute_levelpop(), except that it leaves the entire line-related stuff to the
user: It does not read the molecular data from a ﬁle. NOTE: This is a rather tricky mode, to be used only if you
know very well what you are doing...
• Full non-LTE modes: {bf Not yet ready}
7.3. Line transfer modes and how to activate the line transfer
59

radmc3d, Release 2.0
The default of the lines_mode variable is lines_mode=1.
NOTE 1: Line emission is automatically included in the images and spectra if RADMC-3D ﬁnds the ﬁle lines.inp
in the model directory. You can switch off the lines with the command-line option 'noline'.
NOTE 2: If you are very limited by memory, and if you use LTE, LVG+EscProb or optically thin populations, you
can also ask RADMC-3D to not precalculate the level populations before the rendering, but instead compute them on-
the-ﬂy. This makes the code slower, but requires less memory. You can do this by choosing e.g. lines_mode=-3
instead of lines_mode=3 (for LVG+EscProb).
7.4 The various input ﬁles for line transfer
7.4.1 INPUT: The line transfer entries in the radmc3d.inp ﬁle
Like all other modules of radmc3d, also the line module can be steered through keywords in the radmc3d.inp
ﬁle. Here is a list:
• tgas_eq_tdust (default: 0)
Normally you must specify the gas temperature at each grid cell using the gas_temperature.inp ﬁle
(or directly in the userdef_module.f90, see Chapter Modifying RADMC-3D: Internal setup and user-
speciﬁed radiative processes). But sometimes you may want to compute ﬁrst the dust temperature and then set
the gas temperature equal to the dust temperature. You can do this obviously by hand: read the output dust
temperature and create the equivalent gas temperature input ﬁle from it. But that is cumbersome. By setting
tgas_eq_tdust=1 you tell radmc3d to simply read the dust_temperature.inp ﬁle and then equate
the gas temperature to the dust temperature. If multiple dust species are present, only the ﬁrst species will be
used.
7.4.2 INPUT: The line.inp ﬁle
Like with the dust (which has this dustopac.inp master ﬁle, also the line module has a master ﬁle: lines.inp.
It speciﬁes which molecules/atoms are to be modeled and in which ﬁle the molecular/atomic data (such as the energy
levels and the Einstein 𝐴coefﬁcients) are to be found
iformat
<=== Put this to 2
N
Nr of molecular or atomic species to be
˓→modeled
molname1 inpstyle1 iduma1 idumb1 ncol1
Which molecule used as species 1 + other info
.
.
.
molnameN inpstyleN idumaN idumbN ncolN
Which molecule used as species N + other info
The N is the number of molecular or atomic species you wish to model. Typically this is 1. But if you want to
simultaneously model for instance the ortho-H2O and para-H2O infrared lines, you would need to set this to 2.
The N lines following N (i.e. lines 3 to N+2) specify the molecule or atom, the kind of input ﬁle format (explained
below), and two integers which, at least for now, can be simply set to 0 (see Section For experts: Selecting a subset of
lines and levels ‘manually’ for the meaning of these integers - for experts only), plus ﬁnally third integer, which has
to do with non-LTE transfer: the number of collision partners (set to 0 if you only intend to do LTE transfer).
The molecule name can be e.g.
co for carbon monoxide.
The ﬁle containing the data should then be called
molecule_co.inp (even if it is an atom rather than a molecule; I could not ﬁnd a good name which means both
molecule or atom). This ﬁle should be either generated by the user, or (which is obviously the preferred option) taken
from one of the databases of molecular/atomic radiative properties. Since there are a number of such databases and I
60
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
want the code to be able to read those ﬁles without the need of casting them into some special RADMC-3D format,
radmc3d allows the user to select which kind of ﬁle the molecule_co.inp (for CO) ﬁle is. At present only one
format is supported: the Leiden database. But more will follow. To specify to radmc3d to use the Leiden style, you
put the inpstyle to ‘leiden’. So here is a typical example of a lines.inp ﬁle:
2
1
co
leiden
0
0
0
This means: one molecule will be modeled, namely CO (and thus read from the ﬁle molecule_co.inp), and the
data format is the Leiden database format.
NOTE: Since version 0.26 the ﬁle format number of this ﬁle lines.inp has increased. It is now 2, because in each
line an extra integer is added.
NOTE: The ﬁles from the Leiden LAMDA database (see Section INPUT: Molecular/atomic data:
The
molecule_XXX.inp ﬁle(s)) are usually called something like co.dat.
You will have to simply rename to
molecule_co.inp.
Most molecular data ﬁles have, in addition to the levels and radiative rates, also the collision rates listed. See Section
INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s). For non-LTE radiative transfer this is essential infor-
mation. The number densities of the collision partners (the particles with which the molecule can collide and which
can collisionally excited or de-excite the molecule) are given in number density ﬁles with the same format as those of
the molecule itself (see Section INPUT: The number density of collision partners (for non-LTE transfer)). However,
we must tell RADMC-3D to which collision partner particle the rate tables listed in the molecule_co.inp are as-
sociated (see Section INPUT: The number density of collision partners (for non-LTE transfer) for a better explanation
of the issue here). This can be done with the last of the integers in each line. Example: if the lines.inp ﬁle reads:
2
1
co
leiden
0
0
2
p-h2
o-h2
this means that the ﬁrst collision rate table (starting with the number 3.2e-11 in the example of Section INPUT:
Molecular/atomic data: The molecule_XXX.inp ﬁle(s)) is for collisions with particles for which the number density is
given in the ﬁle numberdens_p-h2.inp and the second collision rate table (starting with the number 4.1e-11 in
the example of Section INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s)) is for collisions with particles
for which the number density is given in the ﬁle numberdens_o-h2.inp.
We could also decide to ignore the difference between para-H2 and ortho-H2, and simply use the ﬁrst table (starting
with the number 3.2e-11 in the example of Section INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s)),
which is actually for para-H2 only, as a proxy for the overall mixture of H2 molecules. After all: The collision rate for
para-H2 and ortho-H2 are not so very different. In that case we may simply ignore this difference and only provide a
ﬁle numberdens_h2.inp, and link that to the ﬁrst of the two collision rate tables:
2
1
co
leiden
0
0
1
h2
(Note: we cannot, in this way, link this to the second of the two tables, only to the ﬁrst). But if we would do this:
2
1
co
leiden
0
0
3
p-h2
(continues on next page)
7.4. The various input ﬁles for line transfer
61

radmc3d, Release 2.0
(continued from previous page)
o-h2
h
we would get an error, because only two collision rate tables are provided in molecule_co.inp.
Finally, as we will explain in Section INPUT: Molecular/atomic data: The linelist_XXX.inp ﬁle(s), there is an alterna-
tive way to feed atomic/molecular data into RADMC-3D: By using linelists. To tell RADMC-3D to read a linelist ﬁle
instead of a Leiden-style molecular/atomic data ﬁle, just write the following in the lines.inp ﬁle:
2
1
h2o
linelist 0
0
0
(example here is for water). This will make RADMC-3D read the linelist_h2o.inp ﬁle as a linelist ﬁle (see
Section INPUT: Molecular/atomic data: The linelist_XXX.inp ﬁle(s)). Note that lines from a linelist will always be in
LTE.
You can also have multiple species, for which some are of Leiden-style and some are linelist style. For instance:
2
2
co
leiden
0
0
2
p-h2
o-h2
h2o
linelist 0
0
0
Here the CO lines can be treated in a non-LTE manner (depending on what you put for lines_mode, see Section
Line transfer modes and how to activate the line transfer), and the H2O is treated in LTE.
7.4.3 INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s)
As mentioned in Section INPUT: The line.inp ﬁle the atomic or molecular fundamental data such as the level di-
agram and the radiative decay rates (Einstein A coefﬁcients) are read from a ﬁle (or more than one ﬁles) named
molecule_XXX.inp, where the XXX is to be replaced by the name of the molecule or atom in question. For these
ﬁles RADMC-3D uses the Leiden LAMDA database format. Note that, instead of a molecule_XXX.inp ﬁle you
can also give a linelist ﬁle, but this will be discussed in Section INPUT: Molecular/atomic data: The linelist_XXX.inp
ﬁle(s).
The precise format of the Leiden database data ﬁles is of course described in detail on their web page http://www.strw.
leidenuniv.nl/~moldata/ . Here we only give a very brief overview, based on an example of CO in which only the ﬁrst
few levels are speciﬁed (taken from the LAMDA database):
!MOLECULE (Data from the LAMDA database)
CO
!MOLECULAR WEIGHT
28.0
!NUMBER OF ENERGY LEVELS
5
!LEVEL + ENERGIES(cm^-1) + WEIGHT + J
1
0.000000000
1.0
0
2
3.845033413
3.0
1
3
11.534919938
5.0
2
4
23.069512649
7.0
3
5
38.448164669
9.0
4
!NUMBER OF RADIATIVE TRANSITIONS
(continues on next page)
62
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
(continued from previous page)
4
!TRANS + UP + LOW + EINSTEINA(s^-1) + FREQ(GHz) + E_u(K)
1
2
1
7.203e-08
115.2712018
5.53
2
3
2
6.910e-07
230.5380000
16.60
3
4
3
2.497e-06
345.7959899
33.19
4
5
4
6.126e-06
461.0407682
55.32
The ﬁrst few lines are self-explanatory. The ﬁrst of the two tables is about the levels. Column one is simply a
numbering. Column 2 is the energy of the level 𝐸𝑘, speciﬁed in units of 1/cm. To get the energy in erg you multiply
this number with ℎ𝑐/𝑘where ℎis the Planck constant, 𝑐the light speed and 𝑘the Boltzmann constant. Column 3 is
the degeneration number, i.e. the the 𝑔parameter of the level. Column 4 is redundant information, not used by the
code.
The second table is the line list. Column 1 is again a simple counter. Column 2 and 3 specify which two levels the line
connects. Column 4 is the radiative decay rate in units of 1/s, i.e. the Einstein 𝐴coefﬁcient. The last two columns are
redundant information that can be easily derived from the other information.
If you are interested in LTE line transfer, this is enough information. However, if you want to use one of the non-LTE
modes of RADMC-3D, you must also have the collisional rate data. An example of a molecule_XXX.inp ﬁle that
also contains these data is:
!MOLECULE (Data from the LAMDA database)
CO
!MOLECULAR WEIGHT
28.0
!NUMBER OF ENERGY LEVELS
10
!LEVEL + ENERGIES(cm^-1) + WEIGHT + J
1
0.000000000
1.0
0
2
3.845033413
3.0
1
3
11.534919938
5.0
2
4
23.069512649
7.0
3
5
38.448164669
9.0
4
!NUMBER OF RADIATIVE TRANSITIONS
9
!TRANS + UP + LOW + EINSTEINA(s^-1) + FREQ(GHz) + E_u(K)
1
2
1
7.203e-08
115.2712018
5.53
2
3
2
6.910e-07
230.5380000
16.60
3
4
3
2.497e-06
345.7959899
33.19
4
5
4
6.126e-06
461.0407682
55.32
!NUMBER OF COLL PARTNERS
2
!COLLISIONS BETWEEN
2 CO-pH2 from Flower (2001) & Wernli et al. (2006) + extrapolation
!NUMBER OF COLL TRANS
10
!NUMBER OF COLL TEMPS
7
!COLL TEMPS
5.0
10.0
20.0
30.0
50.0
70.0
100.0
!TRANS + UP + LOW + COLLRATES(cm^3 s^-1)
1
2
1
3.2e-11 3.3e-11 3.3e-11 3.3e-11 3.4e-11 3.4e-11 3.4e-11
2
3
1
2.9e-11 3.0e-11 3.1e-11 3.2e-11 3.2e-11 3.2e-11 3.2e-11
3
3
2
7.9e-11 7.2e-11 6.5e-11 6.1e-11 5.9e-11 6.0e-11 6.5e-11
4
4
1
4.8e-12 5.2e-12 5.6e-12 6.0e-12 7.1e-12 8.4e-12 1.2e-11
5
4
2
4.7e-11 5.0e-11 5.1e-11 5.1e-11 5.1e-11 5.1e-11 5.1e-11
6
4
3
9.0e-11 7.9e-11 7.1e-11 6.7e-11 6.5e-11 6.6e-11 7.2e-11
(continues on next page)
7.4. The various input ﬁles for line transfer
63

radmc3d, Release 2.0
(continued from previous page)
7
5
1
2.8e-12 3.1e-12 3.4e-12 3.7e-12 4.0e-12 4.4e-12 4.0e-12
8
5
2
8.0e-12 9.6e-12 1.1e-11 1.2e-11 1.4e-11 1.6e-11 2.2e-11
9
5
3
5.9e-11 6.2e-11 6.2e-11 6.1e-11 6.0e-11 5.9e-11 5.8e-11
10
5
4
8.5e-11 8.2e-11 7.5e-11 7.1e-11 6.9e-11 6.9e-11 7.3e-11
!COLLISIONS BETWEEN
3 CO-oH2 from Flower (2001) & Wernli et al. (2006) + extrapolation
!NUMBER OF COLL TRANS
10
!NUMBER OF COLL TEMPS
7
!COLL TEMPS
5.0
10.0
20.0
30.0
50.0
70.0
100.0
!TRANS + UP + LOW + COLLRATES(cm^3 s^-1)
1
2
1
4.1e-11 3.8e-11 3.4e-11 3.3e-11 3.4e-11 3.5e-11 3.9e-11
2
3
1
5.8e-11 5.6e-11 5.2e-11 5.0e-11 4.7e-11 4.7e-11 6.2e-11
3
3
2
7.5e-11 7.1e-11 6.6e-11 6.2e-11 6.1e-11 6.2e-11 7.1e-11
4
4
1
6.6e-12 7.1e-12 7.3e-12 7.5e-12 8.1e-12 9.0e-12 1.3e-11
5
4
2
7.9e-11 8.3e-11 8.1e-11 7.8e-11 7.4e-11 7.3e-11 8.5e-11
6
4
3
8.0e-11 7.5e-11 7.0e-11 6.8e-11 6.7e-11 6.9e-11 7.7e-11
7
5
1
5.8e-12 6.1e-12 6.1e-12 6.1e-12 6.2e-12 6.3e-12 7.8e-12
8
5
2
1.0e-11 1.2e-11 1.4e-11 1.4e-11 1.6e-11 1.8e-11 2.2e-11
9
5
3
8.3e-11 8.9e-11 9.0e-11 8.8e-11 8.3e-11 8.1e-11 8.7e-11
10
5
4
8.0e-11 7.9e-11 7.5e-11 7.2e-11 7.1e-11 7.1e-11 7.6e-11
As you see, the ﬁrst part is the same. Now, however, there is extra information. First, the number of collision partners,
for which these collisional rate data is speciﬁed, is given. Then follows the reference to the paper containing these data
(this is not used by RADMC-3D; it is just for information). Then the number of collisional transitions that are tabulated
(since collisions can relate any level to any other level, this number should ideally be nlevels*(nlevels-1)/2,
but this is not strictly enforced). Then the number of temperature points at which these collisional rates are tabulated.
Then follows this list of temperatures. Finally we have the table of collisional transitions. Each line consists of, ﬁrst,
the ID of the transition (dummy), then the upper level, then the lower level, and then the 𝐾up,low collisional rates in
units of [cm3/𝑠]. The same is again repeated (because in this example we have two collision partners: the para-H2
molecule and the ortho-H2 molecule).
To get the collision rate 𝐶up,low per molecule (in units of [1/s]) for the molecule of interest, we must multiply 𝐾up,low
with the number density of the collision partner (see Section INPUT: The number density of collision partners (for
non-LTE transfer)). So in this example, the 𝐶up,low becomes:
𝐶up,low = 𝑁p−H2𝐾p−H2
up,low + 𝑁o−H2𝐾o−H2
up,low
The rates tabulated in this ﬁle are always the downward collision rate. The upward rate is internally computed by
RADMC-3D using the following formula:
𝐶low,up = 𝐶up,low
𝑔up
𝑔low
exp
(︂
−∆𝐸
𝑘𝑇
)︂
where the 𝑔factors are the statistical weights of the levels, ∆𝐸is the energy difference between the levels, 𝑘is the
Boltzmann constant and 𝑇the gas temperature.
Some notes:
• When doing LTE transfer and you make RADMC-3D read a separate ﬁle with the partition function (Section
INPUT for LTE line transfer: The partition function (optional)), you can limit the molecule_XXX.inp ﬁles
to just the levels and lines you are interested in. But again: You must then read the partition function separately,
and not let RADMC-3D compute it internally based on the molecule_XXX.inp ﬁle.
• When doing non-LTE transfer and/or when you let RADMC-3D compute the partition function internally you
must make sure to include all possible levels that might get populated, otherwise you may overpredict the
strength of the lines you are interested in.
64
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
• The association of each of the collision partners in this ﬁle to ﬁles that contain their spatial distribution is a bit
complicated. See Section INPUT: The number density of collision partners (for non-LTE transfer).
7.4.4 INPUT: Molecular/atomic data: The linelist_XXX.inp ﬁle(s)
In many cases molecular data are merely given as lists of lines (e.g. the HITRAN database, the Kurucz database, the
Jorgensen et al. databases etc.). These line lists contain information about the line wavelength 𝜆0, the line strength
𝐴ud, the statistical weights of the lower and upper level and the energy of the lower or upper level. Sometimes also
the name or set of quantum numbers of the levels, or additional information about the line proﬁle shapes are speciﬁed.
These line lists contain no direct information about the level diagram, although this information can be extracted from
the line list (if it is complete). These lines lists also do not contain any information about collisional (de-)excitation,
so they cannot be used for non-LTE line transfer of any kind. They only work for LTE line transfer. But such line lists
are nevertheless used often (and thus LTE is then assumed).
RADMC-3D can read the molecular data in line-list-form (ﬁles named linelist_XXX.inp). RADMC-3D can
in fact use both formats mixed (the line list one and the ‘normal’ one of Section INPUT: Molecular/atomic data:
The molecule_XXX.inp ﬁle(s)). Some molecules may be speciﬁed as line lists (linelist_XXX.inp) while simul-
taneously others as full molecular ﬁles (molecule_XXX.inp, see Section INPUT: Molecular/atomic data: The
molecule_XXX.inp ﬁle(s)). For the ‘linelist molecules’ RADMC-3D will then automatically use LTE, while for the
other molecules RADMC-3D will use the mode according to the lines_mode value. This means that you can use
this to have mixed LTE and non-LTE species of molecules/atoms within the same model, as long as the LTE ones have
their molecular/atomic data given in a line list form. This can be useful to model situations where most of the lines are
in LTE, but one (or a few) are non-LTE.
Now coming back to the linelist data. Here is an example of such a ﬁle (created from data from the HITRAN database):
! RADMC-3D Standard line list
! Format number:
1
! Molecule name:
h2o
! Reference: From the HITRAN Database (see below for more info)
! Molecular weight (in atomic units)
18.010565
! Include table of partition sum? (0=no, 1=yes)
1
! Include additional information? (0=no, 1=yes)
0
! Nr of temperature points for the partition sum
2931
!
Temp [K]
PartSum
7.000000E+01
2.100000E+01
7.100000E+01
2.143247E+01
7.200000E+01
2.186765E+01
7.300000E+01
2.230553E+01
....
....
....
2.997000E+03
1.594216E+04
2.998000E+03
1.595784E+04
2.999000E+03
1.597353E+04
3.000000E+03
1.598924E+04
! Nr of lines
37432
! ID
Lambda [mic]
Aud [sec^-1]
E_lo [cm^-1]
E_up [cm^-1]
g_lo
g_up
1
1.387752E+05
5.088000E-12
1.922829E+03
1.922901E+03
11.
9.
(continues on next page)
7.4. The various input ﬁles for line transfer
65

radmc3d, Release 2.0
(continued from previous page)
2
2.496430E+04
1.009000E-09
1.907616E+03
1.908016E+03
21.
27.
3
1.348270E+04
1.991000E-09
4.465107E+02
4.472524E+02
33.
39.
4
1.117204E+04
8.314000E-09
2.129599E+03
2.130494E+03
27.
33.
5
4.421465E+03
1.953000E-07
1.819335E+03
1.821597E+03
21.
27.
....
....
....
37429
3.965831E-01
3.427000E-05
7.949640E+01
2.529490E+04
15.
21.
37430
3.965250E-01
1.508000E-04
2.121564E+02
2.543125E+04
21.
27.
37431
3.964335E-01
5.341000E-05
2.854186E+02
2.551033E+04
21.
27.
37432
3.963221E-01
1.036000E-04
3.825169E+02
2.561452E+04
27.
33.
The ﬁle is pretty self-explanatory. It contains a table for the partition function (necessary for LTE transfer) and a
table with all the lines (or any subset you wish to select). The lines table columns are as follows: ﬁrst column is
just a dummy index. Second column is the wavelength in micron. Third is the Einstein-A-coefﬁcient (spontaneous
downward rate) in units of s−1. Fourth and ﬁfth are the energies above the ground state of the lower and upper levels
belonging to this line in units of cm−1. Sixth and seventh are the statistical weights (degenracies) of the lower and
upper levels belonging to this line.
Note that you can tell RADMC-3D to read linelist_h2o.inp (instead of search for molecule_h2o.inp) by
specifying linelist instead of leiden in the lines.inp ﬁle (see Section INPUT: The line.inp ﬁle).
7.4.5 INPUT: The number density of each molecular species
For the line radiative transfer we need to know how many molecules of each species are there per cubic centimeter.
For molecular/atom species XXX this is given in the ﬁle numberdens_XXX.inp (see Chapter Binary I/O ﬁles for
the binary version of this ﬁle, which is more compact, and which you can use instead of the ascii version). For
each molecular/atomic species listed in the lines.inp ﬁle there must be a corresponding numberdens_XXX.
inp ﬁle. The structure of the ﬁle is very similar (though not identical) to the structure of the dust density input ﬁle
dust_density.inp (Section INPUT (required for dust transfer): dust_density.inp). For the precise way to address
the various cells in the different AMR modes, we refer to Section INPUT (required for dust transfer): dust_density.inp,
where this is described in detail.
For formatted style (numberdens_XXX.inp):
iformat
<=== Typically 1 at present
nrcells
numberdensity[1]
..
numberdensity[nrcells]
The number densities are to be speciﬁed in units of molecule per cubic centimeter.
7.4.6 INPUT: The gas temperature
For line transfer we need to know the gas temperature. You specify this in the ﬁle gas_temperature.inp (see
Chapter Binary I/O ﬁles for the binary version of these ﬁles, which are more compact, and which you can use instead
of the ascii versions). The structure of this ﬁle is identical to that described in Section INPUT: The number density
of each molecular species, but of course with number density replaced by gas temperature in Kelvin. For the precise
way to address the various cells in the different AMR modes, we refer to Section INPUT (required for dust transfer):
dust_density.inp, where this is described in detail.
Note: Instead of literally specifying the gas temperature you can also tell radmc3d to copy the dust temperature (if it
know it) into the gas temperature. See the keyword tgas_eq_tdust described in Section INPUT: The line transfer
66
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
entries in the radmc3d.inp ﬁle.
7.4.7 INPUT: The velocity ﬁeld
Since gas motions are usually the main source of Doppler shift or broadening in astrophysical settings, it is obligatory
to specify the gas velocity. This can be done with the ﬁle gas_velocity.inp (see Chapter Binary I/O ﬁles for
the binary version of these ﬁles, which are more compact, and which you can use instead of the ascii versions). The
structure is again similar to that described in Section INPUT: The number density of each molecular species, but now
with three numbers at each grid point instead of just one. The three numbers are the velocity in 𝑥, 𝑦and 𝑧direction
for Cartesian coordinates, or in 𝑟, 𝜃and 𝜑direction for spherical coordinates. Note that both in cartesian coordinates
and in spherical coordinates all velocity components have the same dimension of cm/s. For spherical coordinates the
conventions are: positive 𝑣𝑟points outwards, positive 𝑣𝜃points downward (toward larger 𝜃) for 0 < 𝜃< 𝜋(where
‘downward’ is toward smaller 𝑧), and positive 𝑣𝜑means velocity in counter-clockwise direction in the 𝑥, 𝑦-plane.
For the precise way to address the various cells in the different AMR modes, we refer to Section INPUT (required for
dust transfer): dust_density.inp, where this is described in detail.
7.4.8 INPUT: The local microturbulent broadening (optional)
The radmc3d code automatically includes thermal broadening of the line. But sometimes it is also useful to specify a
local (spatially unresolved) turbulent width. This is not obligatory (if it is not speciﬁed, only the thermal broadening is
used) but if you want to specify it, you can do so in the ﬁle microturbulence.inp (see Chapter Binary I/O ﬁles
for the binary version of these ﬁles, which are more compact, and which you can use instead of the ascii versions).
The ﬁle format is the same structure as described in Section INPUT: The number density of each molecular species.
For the precise way to address the various cells in the different AMR modes, we refer to Section INPUT (required for
dust transfer): dust_density.inp, where this is described in detail.
Here is the way it is included into the line proﬁle:
𝑎2
linewidth = 𝑎2
turb + 2𝑘𝑇gas
𝜇
where 𝑇gas is the temperature of the gas, 𝜇the molecular weight, 𝑘the Boltzmann constant and 𝑎turb the microturbu-
lent line width in units of cm/s. The 𝑎linewidth is then the total (thermal plus microturbulent) line width.
7.4.9 INPUT for LTE line transfer: The partition function (optional)
If you use the LTE mode (either lines_mode=-1 or lines_mode=1), then the partition function is required to
calculate, for a given temperature the populations of the various levels. Since this involves a summation over all levels
of all kinds that can possibly be populated, and since the molecular/atomic data ﬁle may not include all these possible
levels, it may be useful to look the partition function up in some literature and give this to radmc3d. This can be
done with the ﬁle partitionfunction_XXX.inp, where again XXX is here a placeholder for the actual name
of the molecule at hand. If you do not have this ﬁle in the present model directory, then radmc3d will compute the
partition function itself, but based on the (maybe limited) set of levels given in the molecular data ﬁle. The structure
of the partitionfunction_XXX.inp ﬁle is:
iformat
; The usual format number, currently 1
ntemp
; The number of temperatures at which it is specified
temp(1)
pfunc(1)
temp(2)
pfunc(2)
.
.
.
.
.
.
temp(ntemp)
pfunc(ntemp)
7.4. The various input ﬁles for line transfer
67

radmc3d, Release 2.0
NOTE: RADMC-3D assumes the partition function to be deﬁned in the following way:
𝑍(𝑇) =
∑︁
𝑖=1
𝑔𝑖𝑒−(𝐸𝑖−𝐸1)/𝑘𝑇
In other words: the ﬁrst level is assumed to be the ground state. This is done so that one can also use an energy
deﬁnition in which the ground state energy is non-zero (example: Hydrogen 𝐸1 = −13.6 eV). If you use molecular
line dataﬁles that contain only a subset of levels (which is in principle no problem for LTE calculations) then it is
essential that the ground state is included in this list, and that it is the ﬁrst level (ilevel=1).
7.4.10 INPUT: The number density of collision partners (for non-LTE transfer)
For non-LTE line transfer (see e.g. Sections Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape Prob-
ability (EscProb) method, Non-LTE Transfer: The optically thin line assumption method) the molecules can be colli-
sionally excited. The collision rates for each pair of molecule + collision partner are given in the molecular input data
ﬁles (Section INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s)). To ﬁnd how often a molecular level of a
single molecule is collisionally excited to another level we also need to know the number density of the collision part-
ner molecules. In the example in Section INPUT: Molecular/atomic data: The molecule_XXX.inp ﬁle(s) these were
para-H2 and ortho-H2. We must therefore somehow tell RADMC-3D what the number densities of these molecules
are. This is done by reading in the number densities for this(these) collision partner(s). The ﬁle for this has exactly the
same format as that for the number density of any molecule (see Section INPUT: The number density of each molec-
ular species). So for our example we would thus have two ﬁles, which could be named numberdens_p-h2.inp
and numberdens_o-h2.inp respectively. See Section INPUT: The number density of each molecular species for
details.
However, how does RADMC-3D know that the ﬁrst collision partner of CO is called p-h2 and the second o-h2?
In principle the ﬁle molecule_co.inp give some information about the name of the collision partners. But this
is often not machine-readable. Example, in molecule_co.inp of Section INPUT: Molecular/atomic data: The
molecule_XXX.inp ﬁle(s) the line that should tell this reads:
2 CO-pH2 from Flower (2001) & Wernli et al. (2006) + extrapolation
for the ﬁrst of the two (which is directly from the LAMDA database). This is hard to decipher for RADMC-3D.
Therefore you have to tell this explicitly in the ﬁle lines.inp, and we refer to Section INPUT: The line.inp ﬁle for
how to do this.
7.5 Making images and spectra with line transfer
Making images and spectra with/of lines works in the same way as for the continuum. RADMC-3D will check if the
ﬁle lines.inp is present in your directory, and if so, it will automatically switch on the line transfer. If you insist on
not having the lines switched on, in spite of the presence of the lines.inp ﬁle, you can add the option noline to
radmc3d on the command line. If you don’t, then lines are normally automatically switched on, except in situations
where it is obviously not required.
You can just make an image at some wavelength and you’ll get the image with any line emission included if it is there.
For instance, if you have the molecular data of CO included, then:
radmc3d image lambda 2600.757
will give an image right at the CO 1-0 line center. The code will automatically check if (and if yes, which) line(s) are
contributing to the wavelength of interest. Also it will include all the continuum emission (and absorption) that you
would usually obtain.
There is, however, an exception to this automatic line inclusion: If you make a spectral energy distribution (with the
command sed, see Section Making spectra), then lines are not included. The same is true if you use the loadcolor
68
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
command. But for normal spectra or images the line emission will automatically be included. So if you make a
spectrum at wavelength around some line, you will get a spectrum including the line proﬁle from the object, as well
as the dust continuum.
It is not always convenient to have to know by heart the exact wavelengths of the lines you are interested in. So
RADMC-3D allows you to specify the wavelength by specifying which line of which molecule, and at which velocity
you want to render:
radmc3d image iline 2 vkms 2.4
If you have CO as your molecule, then iline 2 means CO 2-1 (the second line in the rotational ladder).
By default the ﬁrst molecule is used (if you have more than one molecule), but you can also specify another one:
radmc3d image imolspec 2 iline 2 vkms 2.4
which would select the second molecule instead of the ﬁrst one.
If you wish to make an entire spectrum of the line, you can do for instance:
radmc3d spectrum iline 1 widthkms 10
which produces a spectrum of the line with a passband going from -10 km/s to +10 km/s. By default 40 wavelength
points are used, and they are evenly spaced. You can set this number of wavelengths:
radmc3d spectrum iline 1 widthkms 10 linenlam 100
which would make a spectrum with 100 wavelength points, evenly spaced around the line center. You can also shift
the passband center:
radmc3d spectrum iline 1 widthkms 10 linenlam 100 vkms -10
which would make the wavelength grid 10 kms shifted in short direction.
Note that you can use the widthkms and linenlam keywords also for images:
radmc3d image iline 1 widthkms 10 linenlam 100
This will make a multi-color image, i.e. it will make images at 100 wavelenths points evenly spaced around the line
center. In this way you can make channel maps.
For more details on how to specify the spectral sampling, please read Section Specifying custom-made sets of wave-
length points for the camera. Note that keywords such as incl, phi, and any other keywords specifying the camera
position, zooming factor etc, can all be used in addition to the above keywords.
7.5.1 Speed versus realism of rendering of line images/spectra
As usual with numerical modeling: including realism to the modeling goes at the cost of rendering speed. A ‘fully
realistic’ rendering of a model spectrum or image of a gas line involves (assuming the level populations are already
known):
1. Doppler-shifted emission and absorption.
2. Inclusion of dust thermal emission and dust extinction while rendering the lines.
3. Continuum emission scattered by dust into the line-of-sight
4. Line emission from (possibly obscured) other regions is allowed to scatter into the line-of-sight by dust grains
(see Section Line emission scattered off dust grains).
7.5. Making images and spectra with line transfer
69

radmc3d, Release 2.0
RADMC-3D always includes the Doppler shifts. By default, RADMC-3D also includes dust thermal emission and
extinction, as well as the scattered continuum radiation.
For many lines, however, dust continuum scattering is a negligible portion of the ﬂux, so you can speed things up
by not including dust scattering! This can be easily done by adding the noscat option on the command-line when
you issue the command for a line spectrum or multi-frequency image. This way, the scattering source function is not
computed (is assumed to be zero), and no scattering Monte Carlo runs are necessary. This means that the ray-tracer
can now render all wavelength simultaneously (each ray doing all wavelength at the same time), and the local level
populations along each ray can now be computed once, and be used for all wavelengths. This may speed up things
drastically, and for most purposes virtually perfectly correct. Just beware that when you render short-wavelength lines
(optical) or you use large grains, i.e. when the scattering albedo at the wavelength of the line is not negligible, this
may result in a mis-estimation of the continuum around the line.
7.5.2 Line emission scattered off dust grains
NOTE: The contents of this subsection may not be 100% implemented yet.
Also any line emission from obscured regions that get scattered into the line of sight by the dust (if dust scattering is
included) will be included. Note, however, that any possible Doppler shift induced by this scattering is not included.
This means that if line emission is scattered by a dust cloud moving at a very large speed, then this line emission will
be scattered by the dust, but no Doppler shift at the projected velocity of the dust will be added. Only the Doppler
shift of the line-emitting region is accounted for. This is rarely a problem, because typically the dust that may scatter
line emission is located far away from the source of line emission and moves at substantially lower speed.
7.6 Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape
Probability (EscProb) method
The assumption that the energy levels of a molecule or atom are always populated according to a thermal distribution
(the so-called ‘local thermodynamic equilibrium’, or LTE, assumption) is valid under certain circumstances. For
instance for planetary atmospheres in most cases. But in the dilute interstellar medium this assumption is very often
invalid. One must then compute the level populations consistent with the local density and temperature, and often
also consistent with the local radiation ﬁeld. Part of this radiation ﬁeld might even be the emission from the lines
themselves, meaning that the molecules radiatively inﬂuence their neighbors. Solving the level populations self-
consistently is called ‘non-LTE radiative transfer’. A full non-LTE radiative transfer calculation is, however, in most
cases (a) too numerically demanding and sometimes (b) unnecessary. Sometimes a simple approximation of the non-
LTE effects is sufﬁcient.
One such approximation method is the ‘Large Velocity Gradient’ (LVG) method, also called the ‘Sobolev approxima-
tion’. Please read for instance the paper by Ossenkopf (1997) ‘The Sobolev approximation in molecular clouds’, New
Astronomy, 2, 365 for more explanation, and a study how it works in the context of molecular clouds. The LVG mode
of RADMC-3D has been used for the ﬁrst time by Shetty et al. (2011, MNRAS 412, 1686), and a description of the
method is included in that paper. The nice aspect of this method is that it is, for most part, local. The only slightly
non-local aspect is that a velocity gradient has to be computed by comparing the gas velocity in one cell with the gas
velocity in neighboring cells.
As of RADMC-3D Version 0.33 the LVG method is combined with an escape probability (EscProb) method. In fact,
LVG is a kind of escape probability method itself. It is just that for the classic EscProb method the photons can escape
due to the ﬁnite size of the object, and thus the ﬁnite optical depth in the lines. In the LVG the object size is not the
issue, but the gradient of the velocity. The line width combined with the velocity gradient give a length scale over
which a photon can escape.
In the LVG + EscProb method the line-integrated mean intensity 𝐽𝑖𝑗is given by
70
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
𝐽𝑖𝑗= (1 −𝛽𝑖𝑗)𝑆𝑖𝑗+ 𝛽𝑖𝑗𝐽bg
𝑖𝑗
where 𝐽bg
𝑖𝑗is the mean intensity of the background radiation ﬁeld at frequency 𝜈= 𝜈𝑖𝑗(default is blackbody at 2.73
K, but this temperature can be varied with the lines_tbg variable in radmc3d.inp), while 𝛽𝑖𝑗is the escape
probability for line 𝑖→𝑗. This is given by
𝛽𝑖𝑗= 1 −exp(−𝜏𝑖𝑗)
𝜏𝑖𝑗
where 𝜏𝑖𝑗is the line-center optical depth in the line.
For the LVG method this optical depth is given by the velocity gradient:
𝜏LVG
𝑖𝑗
= 𝑐ℎ
4𝜋
𝑁molec
1.064 |∇⃗𝑣| [𝑛𝑗𝐵𝑗𝑖−𝑛𝑖𝐵𝑖𝑗]
=
𝑐3
8𝜋𝜈3
𝑖𝑗
𝐴𝑖𝑗𝑁molec
1.064 |∇⃗𝑣|
[︂𝑔𝑖
𝑔𝑗
𝑛𝑗−𝑛𝑖
]︂
(see e.g. van der Tak et al. 2007, A&A 468, 627), where 𝑛𝑖is the fractional level population of level 𝑖, 𝑁molec the
total number density of the molecule, |∇⃗𝑣| the absolute value of the velocity gradient, 𝑔𝑖the statistical weight of level
𝑖and 𝜈𝑖𝑗the line frequency for transition 𝑖→𝑗. In comparing to Eq. 21 of van der Tak’s paper, note that their 𝑁mol
is a column density (cm−2) and their ∆𝑉is the line width (cm/s), while our 𝑁molec is the number density (cm−3) and
|∇⃗𝑣| is the velocity gradient (s−1). Their formula is thus in fact EscProb while ours is LVG.
For the EscProb method without velocity gradients, we need to be able to compute the total column depth Σmolec in
the direction where this Σmolec is minimal. This is something that, at the moment, RADMC-3D cannot yet do. But
this is something that can be estimated based on a ‘typical length scale’ 𝐿, such that
Σmolec ≃𝑁molec 𝐿
RADMC-3D allows you to specify 𝐿separately for each cell (in the ﬁle escprob_lengthscale.inp or its binary
version). The simplest would be to set it to a global value equal to the typical size of the object we are interested in.
Then the line-center optical depth, assuming a Gaussian line proﬁle with width 𝑎linewidth, is
𝜏EscProb
𝑖𝑗
=
ℎ𝑐Σmolec
4𝜋√𝜋𝑎linewidth
[𝑛𝑗𝐵𝑗𝑖−𝑛𝑖𝐵𝑖𝑗]
because 𝜑(𝜈= 𝜈𝑖𝑗) = 𝑐/(𝑎𝜈𝑖𝑗
√𝜋).
The optical depth of the combined LVG + EscProb method is then:
𝜏𝑖𝑗= min
(︀
𝜏LVG
𝑖𝑗
, 𝜏EscProb
𝑖𝑗
)︀
This is then the 𝜏𝑖𝑗that needs to be inserted into Eq. (eq-escprob-beta-formula) for obtaining the escape probability
𝛽𝑖𝑗(which includes escape due to LVG as well as the ﬁnite length scale 𝐿).
The LVG+EscProb method solves at each location the following statistical equilibrium equation:
∑︁
𝑗>𝑖
[︁
𝑛𝑗𝐴𝑗𝑖+ (𝑛𝑗𝐵𝑗𝑖−𝑛𝑖𝐵𝑖𝑗)𝐽𝑗𝑖
]︁
−
∑︁
𝑗<𝑖
[︁
𝑛𝑖𝐴𝑖𝑗+ (𝑛𝑖𝐵𝑖𝑗−𝑛𝑗𝐵𝑗𝑖)𝐽𝑖𝑗
]︁
+
∑︁
𝑗̸=𝑖
[︀
𝑛𝑗𝐶𝑗𝑖−𝑛𝑖𝐶𝑖𝑗
]︀
= 0
7.6. Non-LTE Transfer: The Large Velocity Gradient (LVG) + Escape Probability (EscProb) method71

radmc3d, Release 2.0
Replacing 𝐽𝑖𝑗(and similarly 𝐽𝑗𝑖) with the expression of Eq. (eq-linemeanint-escp) and subsequently replacing 𝑆𝑖𝑗
with the well-known expression for the line source function
𝑆𝑖𝑗=
𝑛𝑖𝐴𝑖𝑗
𝑛𝑗𝐵𝑗𝑖−𝑛𝑖𝐵𝑖𝑗
leads to
∑︁
𝑗>𝑖
[︁
𝑛𝑗𝐴𝑗𝑖𝛽𝑗𝑖+ (𝑛𝑗𝐵𝑗𝑖−𝑛𝑖𝐵𝑖𝑗)𝛽𝑗𝑖𝐽bg
𝑗𝑖
]︁
−
∑︁
𝑗<𝑖
[︁
𝑛𝑖𝐴𝑖𝑗𝛽𝑖𝑗+ (𝑛𝑖𝐵𝑖𝑗−𝑛𝑗𝐵𝑗𝑖)𝛽𝑖𝑗𝐽bg
𝑖𝑗
]︁
+
∑︁
𝑗̸=𝑖
[︀
𝑛𝑗𝐶𝑗𝑖−𝑛𝑖𝐶𝑖𝑗
]︀
= 0
A few iteration steps are necessary, because the 𝛽𝑖𝑗depends on the optical depths, which depend on the populations.
But since this is only a weak dependence, the iteration should converge rapidly.
To use the LVG+EscProb method, the following has to be done:
• Make sure that you use a molecular data ﬁle that contains collision rate tables (see Section INPUT: Molecu-
lar/atomic data: The molecule_XXX.inp ﬁle(s)).
• Make
sure
to
provide
ﬁle(s)
containing
the
number
densities
of
the
collision
partners,
e.g.
numberdens_p-h2.inp (see Section INPUT: The number density of collision partners (for non-LTE
transfer)).
• Make sure to link the rate tables to the number density ﬁles in lines.inp (see Section INPUT: The line.inp
ﬁle).
• Set the lines_mode=3 in the radmc3d.inp ﬁle.
• You may want to also specify the maximum number of iterations for non-LTE iterations, by setting
lines_nonlte_maxiter in the radmc3d.inp ﬁle. The default is 100 (as of version 0.36). If con-
vergence is not reached within lines_nonlte_maxiter iterations, RADMC-3D stops.
• You
may
want
to
also
specify
the
convergence
criterion
for
non-LTE
iterations,
by
setting
lines_nonlte_convcrit in the radmc3d.inp ﬁle.
The default is 1d-2 (which is not very strict!
Smaller values may be necessary).
• Specify the gas velocity vector ﬁeld in the ﬁle gas_velocity.inp (or .binp), see Section INPUT: The
velocity ﬁeld. If this ﬁle is not present, the gas velocity will be assumed to be 0 everywhere, meaning that you
have pure escape probability.
• Specify the ‘typical length scale’ 𝐿at each cell in the ﬁle escprob_lengthscale.inp (or .binp). If this
ﬁle is not present, then the length scale is assumed to be inﬁnite, meaning that you are back at pure LVG. The
format of this ﬁle is identical to that of the gas density.
Note that having no escprob_lengthscale.inp nor gas_velocity.inp ﬁle in your model directory means
that the photons cannot escape at all, and you should ﬁnd LTE populations (always a good test of the code).
Note that it is essential, when using the Large Velocity Gradient method without specifying a length scale, that the
gradients in the velocity ﬁeld (given in the ﬁle gas_velocity.inp, see Section INPUT: The velocity ﬁeld) are
indeed sufﬁciently large. If they are zero, then this effectively means that the optical depth in all the lines is assumed
to be inﬁnite, which means that the populations are LTE again. If you use LVG but also specify a length scale in the
escprob_lengthscale.inp ﬁle, then this danger of unphysically LTE populations is avoided.
NOTE: Currently this method does not yet include radiative exchange with the dust continuum radiation ﬁeld.
NOTE: Currently this method does not yet include radiative pumping by stellar radiation. Will be included soon.
72
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
7.7 Non-LTE Transfer: The optically thin line assumption method
An even simpler non-LTE method is applicable in very dilute media, in which the lines are all optically thin. This
means that a photon that is emitted by the gas will never be reabsorbed. If this condition is satisﬁed, then the non-
LTE level populations can be computed even easier than in the case of LVG (Section Non-LTE Transfer: The Large
Velocity Gradient (LVG) + Escape Probability (EscProb) method). No iteration is then required. So to activate this,
the following has to be done:
• Make sure that you use a molecular data ﬁle that contains collision rate tables (see Section INPUT: Molecu-
lar/atomic data: The molecule_XXX.inp ﬁle(s)).
• Make
sure
to
provide
ﬁle(s)
containing
the
number
densities
of
the
collision
partners,
e.g.
numberdens_p-h2.inp (see Section INPUT: The number density of collision partners (for non-LTE
transfer)).
• Make sure to link the rate tables to the number density ﬁles in lines.inp (see Section INPUT: The line.inp
ﬁle).
• Set the lines_mode=4 in the radmc3d.inp ﬁle (see Section INPUT: radmc3d.inp).
NOTE: Currently this method does not yet include radiative pumping by stellar radiation.
NOTE: This mode does not *make a model optically thin. Only the populations of the levels are computed under the
{bf assumption} that the lines are optically thin. If you subsequently make a spectrum or image of your model, all
absorption effects are again included.*
7.8 Non-LTE Transfer: Full non-local modes (FUTURE)
In the near future RADMC-3D will hopefully also feature full non-LTE transfer, in which the level populations are
coupled to the full non-local radiation ﬁeld. Methods such as lambda iteration and accelerated lambda iteration will
be implemented. For nomenclature we will call these ‘non-local non-LTE modes’.
For these non-local non-LTE modes the level population calculation is done separately from the image/spectrum ray-
tracing: You will run RADMC-3D ﬁrst for computing the non-LTE populations. RADMC-3D will then write these
to ﬁle. Then you will call RADMC-3D for making images/spectra. This is very similar to the dust transfer, in which
you ﬁrst call RADMC-3D for the Monte Carlo dust temperature computation, and after that for the ray-tracing. It
is, however, different from the local non-LTE modes, where the populations are calculated automatically before any
image/spectrum ray-tracing, and the populations do not have to be written to ﬁle (only if you want to inspect them:
Section Non-LTE Transfer: Inspecting the level populations).
For now, however, RADMC-3D still does not have the non-local non-LTE modes.
7.9 Non-LTE Transfer: Inspecting the level populations
When doing line radiative transfer it is often useful to inspect the level populations. For instance, you may want to
inspect how far from LTE your populations are, or just check if the results are reasonable. There are two ways to do
this:
1. When making an image or spectrum, add the command-line option writepop, which will make RADMC-3D
create output ﬁles containing the level population values. Example:
radmc3d image lambda 2300 writepop
2. Just calling radmc3d with the command-line option calcpop, which will ask RADMC-3D to compute the
populations and write them to ﬁle, even without making any images or spectra. Example:
7.7. Non-LTE Transfer: The optically thin line assumption method
73

radmc3d, Release 2.0
radmc3d calcpop
NOTE: For (future) non-local non-LTE modes (Section Non-LTE Transfer: Full non-local modes (FUTURE)) these
level populations will anyway be written to a ﬁle, irrespective of the writepop command.
The resulting ﬁles will have names such as levelpop_co.dat (for the CO molecule). The structure is as follows:
iformat
<=== Typically 1 at present
nrcells
nrlevels_subset
level1
level2 .....
<=== The level subset selection
popul[level1,1]
popul[level2,1] .....
<=== Populations (for subset) at cell 1
popul[level1,2]
popul[level2,2] .....
<=== Populations (for subset) at cell 2
.
.
popul[level1,nrcells]
popul[level2,nrcells] ....
The ﬁrst number is the format number, which is simply for RADMC-3D to be backward compatible in the future, in
case we decide to change/improve the ﬁle format. The nrcells is the number of cells.
Then follows the number of levels (written as nrlevels_subset above). Note that this is not necessarily equal
to the number of levels found in the molecule_co.inp ﬁle (for our CO example). It will only be equal to that if
the ﬁle has been produced by the command radmc3d calcpop. If, however, the ﬁle was produced after making
an image or spectrum (e.g. through the command radmc3d image lambda 2300 writepop), then RADMC-
3D will only write out those levels that have been used to make the image or spectrum. See Section Background
information: Calculation and storage of level populations for more information about this. It is for this reason that the
ﬁle in fact contains a list of levels that are included (the level1 level 2 ... in the above ﬁle format example).
After these header lines follows the actual data. Each line contains the populations at a spatial cell in units of cm−3.
This ﬁle format is a generalization of the standard format which is described for the example of dust density in Section
INPUT (required for dust transfer): dust_density.inp. Please read that section for more details, and also on how the
format changes if you use ‘layers’.
Also the unformatted style is described in Section INPUT (required for dust transfer): dust_density.inp. We have,
however, here the extra complication that at each cell we have more than one number. Essentially this simply means
that the length of the data per cell is larger, so that fewer cells ﬁt into a single record.
7.10 Non-LTE Transfer: Reading the level populations from ﬁle
Sometimes you may want to make images and/or spectra of lines based on level populations that you calculated
using another program (or calculated using RADMC-3D at some earlier time). You can ask RADMC-3D to read
these populations from ﬁles with the same name and same format as, for example, levelpop_co.dat (for CO) as
described in Section Non-LTE Transfer: Inspecting the level populations. The way to do this is to add a line:
lines_mode = 50
to the radmc3d.inp ﬁle.
You can test that it works by calculating the populations using another lines_mode and calling radmc3d
calcpop writepop (which will produce the levelpop_xxx.dat ﬁle); then change lines_mode to 50, and
call radmc3d image iline 1. You should see a message that RAMDC-3D is actually reading the populations
(and it may, for 3-D models, take a bit of time to read the large ﬁle).
Because of the rather lage size of these ﬁles for 3-D models, it might be worthwhile to make sure to reduce the number
of levels of the molecule_xx.inp ﬁles to only those you actually need.
74
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
7.11 What can go wrong with line transfer?
Even the simple task of performing a ray-tracing line transfer calculation with given level populations (i.e. the so-
called formal transfer equation) is a non-trivial task in complex 3-D AMR models with possibly highly supersonic
motions. I recommend the user to do extensive and critical experimentation with the code and make many simple tests
to check if the results are as they are expected to be. In the end a result must be understandable in terms of simple
argumentation. If weird effects show up, please do some detective work until you understand why they show up, i.e.
that they are either a real effect or a numerical issue. There are many numerical artifacts that can show up that are not a
bug in the code. The code simply does a numerical integration of the equations on some spatial- and wavelength-grid.
If the user chooses these grids unwisely, the results may be completely wrong even if the code is formally OK. These
possible pitfalls is what this section is about.
So here is a list of things to check:
1. Make sure that the line(s) you want to model are indeed in the molecular data ﬁle you use. Also make sure that
it/they are included in the line selection (if you are using this option; by default all lines and levels from the
molecular/atomic data ﬁles are included; see Section Background information: Calculation and storage of level
populations).
2. If you do LTE line transfer, and you do not let radmc3d read in a special ﬁle for the partition function, then the
partition function will be computed internally by radmc3d. The code will do so based on the levels speciﬁed
in the molecule_XXX.inp ﬁle for molecule XXX. This requires of course that all levels that may be excited
at the temperatures found in the model are in fact present in the molecule_XXX.inp ﬁle. If, for instance,
you model 1.3 mm and 2.6 mm rotational lines of CO gas of up to 300 K, and your ﬁle molecule_co.inp
only contains the ﬁrst three levels because you think you only need those for your 1.3 and 2.6 mm lines, and
you don’t specify the partition function explicitly, then radmc3d will compute the partition function for all
temperatures including 300 K based on only the ﬁrst three levels. This is evidently wrong. The nasty thing is:
the resulting lines won’t be totally absurd. They will just be too bright. But this can easily go undetected by
you as the user. So please keep this always in mind. Note that if you make a selection of the ﬁrst three levels
(see Section For experts: Selecting a subset of lines and levels ‘manually’) but the ﬁle molecule_XXX.inp
contains many more levels, then this problem will not appear, because the partition function will be calculated
on the original data from the molecule_XXX.inp ﬁle, not from the selected levels. Of course it is safer
to specify the true partition function directly through the ﬁle partitionfunction_XXX.inp (see Section
INPUT for LTE line transfer: The partition function (optional)).
3. If you have a model with non-zero gas velocities, and if these gas velocities have cell-to-cell differences that are
larger than or equal to the intrinsic (thermal+microturbulent) line width, then the ray-tracing will not be able to
pick up signals from intermediate velocities. In other words, because of the discrete gridding of the model, only
discrete velocities are present, which can cause numerical problems. See Fig. Fig. 7.2-Left for a pictographic
representation of this problem. There are two possible solutions. One is the wavelength band method described
in Section Heads-up: In reality wavelength are actually wavelength bands. But a more systematic method is
the ‘doppler catching’ method described in Section Preventing doppler jumps: The ‘doppler catching method’
(which can be combined with the wavelength band method of Section Heads-up: In reality wavelength are
actually wavelength bands to make it even more perfect).
7.11. What can go wrong with line transfer?
75

radmc3d, Release 2.0
7.12 Preventing doppler jumps: The ‘doppler catching method’
If the local co-moving line width of a line (due to thermal/fundamental broadning and/or local subgrid ‘microturbu-
lence’) is much smaller than the typical velocity ﬁelds in the model, then a dangerous situation can occur. This can
happen if the co-moving line width is narrower than the doppler shift between two adjacent cells. When a ray is traced,
in one cell the line can then have a doppler shift substantially to the blue of the wavelength-of-sight, while in the next
cell the line suddenly shifted to the red side. If the intrinsic (= thermal + microturbulent) line width is smaller than
these shifts, neither cell gives a contribution to the emission in the ray. See Fig. Fig. 7.1 for a pictographic represen-
tation of this problem. In reality the doppler shift between these two cells would be smooth, and thus the line would
smoothly pass over the wavelength-of-sight, and thus make a contribution. Therefore the numerical integration may
thus go wrong.
cell i
cell i−1
cell i+1
cell i+2
velocity/c
≅(ν−ν0)/ν0
position
along
ray
Fig. 7.1: Pictographic representation of the doppler jumping problem with ray-tracing through a model with strong
cell-to-cell velocity differences.
cell i
velocity/c
≅(ν−ν0)/ν0
position
along
ray
cell i−1
cell i+1
cell i+2
Fig. 7.2: Right: Pictographic representation of the doppler catching method to prevent this problem: First of all,
second order integration is done instead of ﬁrst order. Secondly, the method automatically detects a possibly dangerous
doppler jump and makes sub-steps to neatly integrate over the line that shifts in- and out of the wavelength channel of
interest.
The problem is described in more detail in Section Heads-up: In reality wavelength are actually wavelength bands,
76
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
and one possible solution is proposed there. But that solution does not always solve the problem.
RADMC-3D has a special method to catch situations like the above, and when it detects one, to make sub-steps in
the integration of the formal transfer equation so that the smooth passing of the line through the wavelength-of-sight
can be properly accounted for. Here this is called ‘doppler catching’, for lack of a better name. The technique was
discussed in great detail in Pontoppidan et al. (2009, ApJ 704, 1482). The idea is that the method automatically tests
if a line might ‘doppler jump’ over the current wavelength channel. If so, it will insert substeps in the integration at
the location where this danger is present. See Fig. Fig. 7.2 for a pictographic representation of this method. Note
that this method can only be used with the second order ray-tracing (see Section Second order ray-tracing (Important
information!)); in fact, as soon as you switch the doppler catching on, RADMC-3D will automatically also switch on
the second order ray-tracing.
To switch on doppler catching, you simply add the command-line option doppcatch to the image or spectrum
command. For instance:
radmc3d spectrum iline 1 widthkms 10 doppcatch
(again: you do not need to add secondorder, because it is automatic when doppcatch is used).
The Doppler catching method will assure that the line is integrated over with small enough steps that it cannot ac-
cidently get jumped over. How ﬁne these steps will be can be adjusted with the catch_doppler_resolution
keyword in the radmc3d.inp ﬁle. The default value is 0.2, meaning that it will make the integration steps small
enough that the doppler shift over each step is not more than 0.2 times the local intrinsic (thermal+microturbulent) line
width. That is usually enough, but for some problems it might be important to ensure that smaller steps are taken. By
adding a line:
catch_doppler_resolution = 0.05
to the radmc3d.inp ﬁle you will ensure that steps are small enough that the doppler shift is at most 0.05 times the
local line width.
So why is doppler catching an option, i.e. why would this not be standard? The reason is that doppler catching requires
second order integration, which requires RADMC-3D to ﬁrst map all the cell-based quantities to the cell-corners. This
requires extra memory, which for very large models can be problematic. It also requires more CPU time to calculate
images/spectra with second order integration. So if you do not need it, i.e. if your velocity gradients are not very steep
compared to the intrinsic line width, then it saves time and memory to not use doppler catching.
It is, however, important to realize that doppler catching is not the golden bullet. Even with doppler catching it might
happen that some line ﬂux is lost, but this time as a result of too low image resolution. This is less likely to happen
in problems like ISM turbulence, but it is pretty likely to happen in models of rotating disks. Suppose we have a
very thin local line width (i.e. low gas temperature and no microturbulence) in a rotating thin disk around a star. In
a given velocity channel (i.e. at a given observer-frame frequency) a molecular line in the disk emits only in a very
thin ‘ear-shaped’ ring or band in the image. The thinner the intrinsic line width, the thinner the band on the image.
See Pontoppidan et al. (2009, ApJ 704, 1482) and Pavlyuchenkov et al. (2007, ApJ 669, 1262) for example. If the
pixel-resolution of the image is smaller than that of this band, the image is simply underresolved. This has nothing
to do with the doppler jumping problem, but can be equally devastating for the results if the user is unaware of this.
There appears to be only one proper solution: assure that the pixel-resolution of the image is sufﬁciently ﬁne for the
problem at hand. This is easy to ﬁnd out: The image would simply look terribly noisy if the resolution is insufﬁcient.
However, if you are not interested in the images, but only in the spectra, then some amount of noisiness in the image
(i.e. marginally sufﬁcient resolution) is OK, since the total ﬂux is an integral over the entire image, smearing out much
of the noise. It requires some experimentation, though.
Here are some additional issues to keep in mind:
• The doppler catching method uses second order integration (see Section Second order ray-tracing (Important
information!)), and therefore all the relevant quantities ﬁrst have to be interpolated from the cell centers to the
cell corners. Well inside the computational domain this amounts to linear interpolation. But at the edges of the
domain it would require extra polation. In 1-D this is more easily illustrated, because there the cell corners are in
7.12. Preventing doppler jumps: The ‘doppler catching method’
77

radmc3d, Release 2.0
fact cell interfaces. Cells 𝑖and 𝑖+1 share cell interface 𝑖+1/2. If we have 𝑁cells, i.e. cells 𝑖= 1, · · · , 𝑁, then
we have 𝑁+ 1 interfaces, i.e. interfaces 𝑖= 1
2, · · · , 𝑁+ 1
2. To get physical quantities from the cell centers to
cell interfaces 𝑖= 3
2, · · · , 𝑁−1
2 requires just interpolation. But to ﬁnd the physical quantities at cell interfaces
𝑖= 1
2 and 𝑖= 𝑁+ 1
2 one has to extrapolate or simply take the values at the cell centers 𝑖= 1 and 𝑖= 𝑁.
RADMC-3D does not do extrapolation but simply takes the average values of the nearest cells. Also the gas
velocity is treated like this. This means that over the edge cells the gradient in the gas velocity tends to be (near)
0. Since for the doppler catching it is the gradient of the velocity that matters, this might yield some artifacts in
the spectrum if the density in the border cells is high enough to produce substantial line emission. Avoiding this
numerical artifact is relatively easy: One should then simply put the number density of the molecule in question
to zero in the boundary cells.
• If you are using RADMC-3D on a 3-D (M)HD model which has strong shocks in its domain, then one must
be careful that (magneto-)hydrodynamic codes tend to smear out the shock a bit. This means that there will be
some cells that have intermediate density and velocity in the smeared out region of the shock. This is unphysical,
but an intrinsic numerical artifact of numerical hydrodynamics codes. This might, under some conditions, lead
to unphysical signal in the spectrum, because there would be cells at densities, temperatures and velocities that
would be in between the values at both sides of the shock and would, in reality, not be there. It is very difﬁcult to
avoid this problem, and even to ﬁnd out if this problem is occurring and by how much. One must simply be very
careful of models containing strong shocks and do lots of testing. One way to test is to use the doppler catching
method and vary the doppler catching resolution (using the catch_doppler_resolution keyword in
radmc3d.inp).
• If using line transfer in spherical coordinates using doppler catching, the linear interpolation of the line shift
between the beginning and the end of a segment may not always be enough to accurately prevent doppler jumps.
This is because in addition to the physical gradient of gas velocity, the projected gas velocity along a ray changes
also along the ray due to the geometry (the use of spherical coordinates). Example: a spherically symmetric
radially outﬂowing wind with constant outward velocity 𝑣𝑟= is constant, the 3-D vector ⃗𝑣is not constant, since
it always points outward. A ray through this wind will thus have a varying ⃗𝑛· ⃗𝑣along the ray. In the cell where
the ray reaches its closest approach to the origin of the coordinate system the ⃗𝑛· ⃗𝑣will vary the strongest. This
may be such a strong effect that it could affect the reliability of the code. As of version 0.41 of this code a
method is in place to prevent this. It is switched on by default, but it can be switched off manually for testing
purposes. See Section Second order integration in spherical coordinates: a subtle issue for details.
7.13 Background information: Calculation and storage of level popu-
lations
If RADMC-3D makes an image or a spectrum with molecular (or atomic) lines included, then the level populations
of the molecules/atoms have to be computed. In the standard method of ray-tracing of images or spectra, these level
populations are ﬁrst calculated in each grid cell and stored in a global array. Then the raytracer will render the image
or spectrum.
The storage of the level populations is a tricky matter, because if this is done in the obvious manner, it might require
a huge amount of memory. This would then prevent us from making large scale models. For instance: if you have a
molecule with 100 levels in a model with 256x256x256 ≃1.7 × 107 cells, the global storage for the populations alone
(with each number in double precision) would be roughly 100x8x256x256x256 ≃13 Gigabyte.
However, if you intend to make a spectrum in just 1 line, you do not need all these level populations. To stick to the
above example, let us take the CO 1-0 line, which is then line 1 and which connects levels 𝐽= 1 and 𝐽= 0, which
are levels 2 and 1 in the code (if you use the Leiden database CO data ﬁle). Once the populations have been computed,
we only need to store the levels 1 and 2. This would then require 2x8x256x256x256 ≃0.26 Gigabyte, which would
be much less memory-costly.
As of version 0.29 RADMC-3D automatically ﬁgures out which levels have to be stored in a global array, in order to
be able to render the images or the spectrum properly. RADMC-3D will go through all the lines of all molecules and
78
Chapter 7. Line radiative transfer

radmc3d, Release 2.0
checks if they contribute to the wavelength(s), of the image(s) or the spectrum. Once it has assembled a list of ‘active’
lines, it will make a list of ‘active’ levels that belong to these lines. It will then declare this to be the ‘subset’ of levels
for which the populations will be stored globally.
In other words: RADMC-3D now takes care of the memory-saving storage of the populations automatically.
How does RADMC-3D decide whether a line contributes to some wavelength 𝜆? A line 𝑖with line center 𝜆𝑖is
considered to contribute to an image at wavelength 𝜆if
|𝜆𝑖−𝜆| ≤𝐶margin∆𝜆𝑖
where ∆𝜆𝑖is the line width (including all contributions) and 𝐶margin is a constant. By default
𝐶margin = 12
But you can change this to another value, say 24, by adding in the radmc3d.inp ﬁle a line containing, e.g.
lines_widthmargin = 24.
You can in fact get a dump of the level populations that have been computed and used for the image(s)/spectrum you
created, by adding writepop on the command line. Example:
radmc3d spectrum iline 1 widthkms 10 writepop
This then creates (in addition to the spectrum) a ﬁle called (for our example of the CO molecule) levelpop_co.
dat. Here is how you can read this data in Python:
from radmc3d_tools import simpleread
data = simpleread.read_levelpop()
The data object then contains data.pop and data.relpop, which are the level populations in 1/𝑐𝑚3 and in
normalized form.
If, for some reason, you want always all levels to be stored (and you can afford to do so with the size of your computer’s
memory), you can make RADMC-3D do so by adding noautosubset as a keyword to the command line, or by
adding lines_autosubset = 0 to the radmc3d.inp ﬁle. However, for other than code testing purposes, it
seems unlikely you will wish to do this.
7.14 In case it is necessary: On-the-ﬂy calculation of populations
There might be rare circumstances in which you do not want to have to store the level populations in a global array. For
example: you are making a spectrum of the CO bandhead, in which case you have many tens of lines in a single spec-
trum. If your model contains 256x256x256 cells (see example in Section Background information: Calculation and
storage of level populations) then this might easily require many Gigabytes of memory just to store the populations.
For the LTE, LVG and optically thin level population modes there is a way out: You can force RADMC-3D to compute
the populations on-the-ﬂy during the ray-tracing, which does not require a global storage of the level populations.
The way to do this is simple:
Just make the lines_mode negative.
So for on-the-ﬂy LTE mode use
lines_mode=-1, for on-the-ﬂy user-deﬁned populations mode use lines_mode=-2, for on-the-ﬂy LVG mode
use lines_mode=-3 and for on-the-ﬂy optically thin populations use lines_mode=-4.
NOTE: The drawback of this method is that, under certain circumstances, it can slow down the code dramatically.
This slow-down happens if you use e.g. second-order integration (Section Second order ray-tracing (Important infor-
mation!)) and/or doppler catching (Section Preventing doppler jumps: The ‘doppler catching method’) together with
non-trivial population solving methods like LVG. So please use the on-the-ﬂy method only when you are forced to do
so (for memory reasons).
7.14. In case it is necessary: On-the-ﬂy calculation of populations
79

radmc3d, Release 2.0
7.15 For experts: Selecting a subset of lines and levels ‘manually’
As explained in Section Background information: Calculation and storage of level populations, RADMC-3D auto-
matically makes a selection of levels for which it will allocate memory for the global level population storage.
If, for some reason, you wish to make this selection yourself ‘by hand’, this can also be done. However, please be
informed that there are very few circumstances under which you may want to do this. The automatic subset selection
of RADMC-3D is usually sufﬁcient!
If you decided to really want to do this, here is how:
1. Switch off the automatic subset selection by adding noautosubset as a keyword to the command line, or by
adding lines_autosubset = 0 to the radmc3d.inp ﬁle.
2. In the lines.inp ﬁle, for each molecule, modify the ‘0 0’ (the ﬁrst two zeroes after ‘leiden’) in the way
described below.
In Section INPUT: The line.inp ﬁle you can see that each molecule has a line like:
co
leiden
0
0
0
or so (here for the example of CO). In Section INPUT: The line.inp ﬁle we explained the meaning of the third number,
but we did not explain the meaning of the ﬁrst and second ones. These are meant for this subset selection. If we want
to store only the ﬁrst 10 levels of the CO molecule, then replace the above line with:
co
leiden
0
10
0
If you want to select speciﬁc levels (let us choose the ilevel=3 and ilevel=4 levels of the above example), then
write:
co
leiden
1
2
0
3 4
The ‘1’ says that a list of levels follows, the ‘2’ says that two levels will be selected and the next line with ‘3’ and ‘4’
say that levels 3 and 4 should be selected.
80
Chapter 7. Line radiative transfer

CHAPTER
EIGHT
MAKING IMAGES AND SPECTRA
Much has already been said about images and spectra in the chapters on dust radiative transfer and line radiative
transfer. But here we will combine all this and go deeper into this material. So presumably you do not need to read
this chapter if you are a beginning user. But for more sophisticated users (or as a reference manual) this chapter may
be useful and presents many new features and more in-depth insight.
8.1 Basics of image making with RADMC-3D
Images and spectra are typically made after the dust temperature has been determined using the thermal Monte Carlo
run (see Chapter Dust continuum radiative transfer). An image can now be made with a simple call to radmc3d:
radmc3d image lambda 10
This makes an image of the model at wavelength 𝜆= 10𝜇.
We refer to Section OUTPUT: image.out or im-
age_****.out for details of this ﬁle and how to interpret the content. See Chapter Python analysis tool set for an
extensive Python tools that make it easy to read and handle these ﬁles. The vantage point is at inﬁnity at a default
inclination of 0, i.e. pole-on view. You can change the vantage point:
radmc3d image lambda 10 incl 80 phi 30
which now makes the image at inclination 80 degrees away from the z-axis (i.e. almost edge-on with respect to the x-y
plane), and rotates the location of the observer by 30 degrees clockwise around the z-axis (Here clockwise is deﬁned
with the z-axis pointing toward you, i.e. with respect to the observer the model is rotated counter-clockwise around
the z-axis by 30 degrees).
You can also rotate the camera in the image plane with
radmc3d image lambda 10 incl 45 phi 30 posang 20
which rotates the camera by 20 degrees clockwise (i.e. the image rotates counter-clockwise). Figures Fig. 8.1 and Fig.
8.2 show the deﬁnitions of all three angles. Up to now the camera always pointed to one single point in space: the
point (0,0,0). You can change this:
radmc3d image lambda 10 incl 45 phi 30 posang 20 pointau 3.2 0.1 0.4
which now points the camera at the point (3.2,0.1,0.4), where the numbers are in units of AU. The same can be done
in units of parsec:
radmc3d image lambda 10 incl 45 phi 30 posang 20 pointpc 3.2 0.1 0.4
Note that pointau and pointpc are always 3-D positions speciﬁed in cartesian coordinates. This remains also
true when the model-grid is in spherical coordinates and/or when the model is 2-D (axisymmetric) or 1-D (spherically
symmetric): 3-D positions are always speciﬁed in x,y,z.
81

radmc3d, Release 2.0
y
z
φobs
iobs
x
ximage
yimage
Fig. 8.1: Figure depicting how the angles ‘incl’ and ‘phi’ place the camera for images and spectra made with RADMC-
3D. The code uses a right-handed coordinate system. The ﬁgure shows from which direction the observer is looking
at the system, where 𝑖obs is the ‘incl’ keyword and 𝜑obs is the ‘phi’ keyword. The 𝑥image and 𝑦image are the horizontal
(left-to-right) and vertical (bottom-to-top) coordinates of the image. For 𝑖obs = 0 and 𝜑obs = 0 the 𝑥image aligns with
the 3-D 𝑥-coordinate and 𝑦image aligns with the 3-D 𝑦-coordinate.
posang = 20
image
yimage
x
x
yimage
image
posang = 0
Fig. 8.2: This ﬁgure shows the way the camera can be rotated in the image plane using ‘posang’. Positive ‘posang’
means that the camera is rotated clockwise, so the object shown is rotated counter-clockwise with respect to the image
coordinates.
82
Chapter 8. Making images and spectra

radmc3d, Release 2.0
Let’s now drop the pointing again, and also forget about the posang, and try to change the number of pixels used:
radmc3d image lambda 10 incl 45 phi 30 npix 100
This will make an image of 100x100. You can also specify the x- and y- direction number of pixels separately:
radmc3d image lambda 10 incl 45 phi 30 npixx 100 npixy 30
Now let’s forget again about the number of pixels and change the size of the image, i.e. which zooming factor we
have:
radmc3d image lambda 10 incl 45 phi 30 sizeau 30
This makes an image which has 30 AU width and 30 AU height (i.e. 15 AU from the center in both directions). Same
can be done in units of parsec
radmc3d image lambda 10 incl 45 phi 30 sizepc 30
Although strictly speaking redundant is the possibility to zoom-in right into a selected box in this image:
radmc3d image lambda 10 incl 45 phi 30 zoomau -10 -4. 0 6
which means that we zoom in to the box given by −10 ≤𝑥≤−4 AU and 0 ≤𝑦≤6 AU on the original image (note
that zoomau -15 15 -15 15 gives the identical result as sizeau 30). This possibility is strictly speaking
redundant, because you could also change the pointau and sizeau to achieve the same effect (unless you want to
make a non-square image, in which case this is the only way). But it is just more convenient to do any zooming-in
this way. Please note that when you make non-square images with zoomau or zoompc, the code will automatically
try to keep the pixels square in shape by adapting the number of pixels in x- or y- direction in the image and adjusting
one of the sizes a tiny bit to assure that both x- and y- size are an integer times the pixel size. These are very small
adjustments (and only take place for non-square zoom-ins). If you want to force the code to take exactly the zoom
area, and you don’t care that the pixels then become slightly non-square, you can force it with truezoom:
radmc3d image lambda 10 incl 45 phi 30 sizeau 30 zoomau -10 -4. 0 3.1415 truezoom
If you do not want the code to adjust the number of pixels in x- and y- direction in its attempt to keep the pixels square:
radmc3d image lambda 10 incl 45 phi 30 sizeau 30 zoomau -10 -4. 0 3.1415 npixx 100
˓→npixy 4 truepix
Now here are some special things. Sometimes you would like to see an image of just the dust, not including stars
(for stars in the image: see Section Stars in the images and spectra). So blend out the stars in the image, you use the
nostar option:
radmc3d image lambda 10 incl 45 phi 30 nostar
Another special option is to get a ‘quick image’, in which the code does not attempt assure ﬂux conservation in the
image (see Section The issue of ﬂux conservation: recursive sub-pixeling for the issue of ﬂux conservation). Doing
the image with ﬂux conservation is slower than if you make it without ﬂux conservation. Making an image without
ﬂux conservation can be useful if you want to have a ‘quick look’, but is strongly discouraged for actual scientiﬁc use.
But for a quick look you can do:
radmc3d image lambda 10 incl 45 phi 30 nofluxcons
If you want to produce images with a smoother look (and which also are more accurate), you can ask RADMC-3D to
use second order integration for the images:
8.1. Basics of image making with RADMC-3D
83

radmc3d, Release 2.0
radmc3d image lambda 10 incl 45 phi 30 secondorder
NOTE: The resulting intensities may be slightly different from the case when ﬁrst order integration (default) is used, in
particular if the grid is somewhat course and the objects of interest are optically thick. Please consult Section Second
order ray-tracing (Important information!) for more information.
Important for polarized radiative transfer: If you use polarized scattering, then you may want to creat images with
polarization information in them. You have to tell RADMC-3D to do this by adding stokes to the command line:
radmc3d image lambda 10 incl 45 phi 30 stokes
The deﬁnitions of the Stokes parameters (orientation etc) can be found in Section Deﬁnitions and conventions for
Stokes vectors and the format of image.out in this case can be found in Section OUTPUT: image.out or im-
age_****.out.
Note: All the above commands call radmc3d separately. If it needs to load a large model (i.e. a model with many
cells), then the loading may take a long time. If you want to make many images in a row, this may take too much
time. Then it is better to call radmc3d as a child process and pass the above commands through the biway pipe (see
Chapter chap-child-mode).
8.2 Making multi-wavelength images
Sometimes you want to have an image of an object at multiple wavelength simultaneously. Rather than calling
RADMC-3D separately to make an image for each wavelength, you can make all images in one command. The
only thing you have to do is to tell RADMC-3D which wavelengths it should take. There are various different ways
you can tell RADMC-3D what wavelengths to take. This is described in detail in Section Specifying custom-made
sets of wavelength points for the camera. Here we will focus as an example on just one of these methods. Type, for
instance,
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
This will create 10 images at once, all with the same viewing perspective, but at 10 wavelengths regularly distributed
between 5 𝜇mu`m. All images are written into a single ﬁle, image.out (See Section OUTPUT: image.out or
image_****.out for its format).
In Python you simply type:
from radmc3dPy import image
a=image.readImage()
and you will get all images at once. To plot one of them:
image.plotImage(image=a,ifreq=3)
which will plot image number 3 (out of images number 0 to 9). To ﬁnd out which wavelength this image is at:
print(a.wav[3])
which will return 7.9370053 in this example.
Note that all of the commands in Section Basics of image making with RADMC-3D are of course also applicable to
multi-wavelength images, except for the lambda keyword, as this conﬂicts with the other method(s) of specifying
the wavlengths of the images. Now please turn to Section Specifying custom-made sets of wavelength points for the
camera for more information on how to specify the wavelengths for the multiple wavelength images.
84
Chapter 8. Making images and spectra

radmc3d, Release 2.0
8.3 Making spectra
The standard way of making a spectrum with radmc3d is in fact identical to making 100x100 pixel images with
ﬂux conservation (i.e. recursive sub-pixeling, see Section The issue of ﬂux conservation: recursive sub-pixeling) at
multiple frequencies. You can ask radmc3d to make a spectral energy distribution (SED) with the command
radmc3d sed incl 45 phi 30
This will put the observer at inclination 45 degrees and angle phi 30 degrees, and make a spectrum with wavelength
points equal to those listed in the wavelength_micron.inp ﬁle.
The output will be a ﬁle called spectrum.out (see Section OUTPUT: spectrum.out).
You can also make a spectrum on a set of wavelength points of your own choice. There are multiple ways by which
you can specify the set of frequencies/wavelength points for which to make the spectrum: they are described in Section
Specifying custom-made sets of wavelength points for the camera. If you have made your selection in such a way, you
can make the spectrum at this wavelength grid by
radmc3d spectrum incl 45 phi 30 <COMMANDS FOR WAVELENGTH SELECTION>
where the last stuff is telling radmc3d how to select the wavelengths (Section Specifying custom-made sets of wave-
length points for the camera). An example:
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20. nlam 100
will make a spectrum with a regular wavelength grid between 5 and 20 𝜇m and 100 wavelength points. But see Section
Specifying custom-made sets of wavelength points for the camera for more details and options.
The output ﬁle spectrum.out will have the same format as for the sed command.
Making a spectrum can take RADMC-3D some time, especially in the default mode, because it will do its best to shoot
its rays to pick up all cells of the model (see Section The solution: recursive sub-pixeling). In particularly in spherical
coordinates RADMC-3D can be perhaps too conservative (and thus slow). For spherical coordinates there are ways
to tell RADMC-3D to be somewhat less careful (and thereby faster): see Section Recursive sub-pixeling in spherical
coordinates.
Note that you can adjust the ﬁne-ness of the images from which the spectrum is calculated using npix:
radmc3d sed incl 45 phi 30 npix 2
What this does is use a 2x2 pixel image instead of a 100x100 pixel image as the starting resolution. Of course, if it
would really be just a 2x2 pixel image, the ﬂux would be entirely unreliable and useless. However, using the above
mentioned ‘sub-pixeling’ (see Section The solution: recursive sub-pixeling) it will automatically try to recursively
reﬁne these pixels until the required level of reﬁnement is reached. So under normal circumstances even npix=2 is
enough, and in earlier versions of RADMC-3D this 2x2 top-level image resolution was in fact used as a starting point.
But for safety reasons this has now been changed to the standard 100x100 resolution which is also the default for
normal images. If 100x100 is not enough, try e.g.:
radmc3d sed incl 45 phi 30 npix 400
which may require some patience.
8.3. Making spectra
85

radmc3d, Release 2.0
8.3.1 What is ‘in the beam’ when the spectrum is made?
As mentioned above, a spectrum is simply made by making a rectangular image at all the wavelengths points, and
integrating over these images. The resulting ﬂuxes at each wavelength point is then the spectral ﬂux at that wavelength
point. This means that the integration area of ﬂux for the spectrum is (a) rectangular and (b) of the same size at all
wavelengths.
So, what is the size of the image that is integrated over? The answer is: it is the same size as the default size of an
image. In fact, if you make a spectrum with
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20. nlam 10
then this is the same as if you would type
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
and read in the ﬁle image.out in into Python (see Section Making multi-wavelength images) or your favorite other
data language, and integrate the images to obtain ﬂuxes. In other words: the command spectrum is effectively the
same as the command image but then instead of writing out an image.out ﬁle, it will integrate over all images and
write a spectrum.out ﬁle.
If you want to have a quick look at the area over which the spectrum is to be computed, but you don’t want to compute
all the images, just type e.g.:
radmc3d image lambda 10 incl 45 phi 30
then you see an image of your source at 𝜆= 10𝜇m, and the integration area is precisely this area - at all wavelengths.
Like with the images, you can specify your viewing area, and thus your integration area. For instance, by typing
radmc3d image lambda 10 incl 45 phi 30 zoomau -2 -1 -0.5 0.5
makes an image of your source at 𝜆= 10𝜇m at inclination 45 degrees, and orientation 30 degrees, and zooms in at an
are from -2 AU to -1 AU in x-direction (in the image) and from -0.5 AU to 0.5 AU in y-direction (in the image). To
make an SED within the same integration area:
radmc3d sed incl 45 phi 30 zoomau -2 -1 -0.5 0.5
In this case we have an SED with a ‘beam size’ of 1 AU diameter, but keep in mind that the ‘beam’ is square, not
circular.
8.3.2 Can one specify more realistic ‘beams’?
Clearly, a wavelength-independent beam size is unrealistic, and also the square beam is unrealistic. So is there a way
to do this better? In reality one should really know exactly how the object is observed and how the ﬂux is measured.
If you use an interferometer, for instance, maybe your ﬂux is meant to be the ﬂux in a single synthesized beam. For
a spectrum obtained with a slit, the precise ﬂux is dependent on the slit width: the wider the slit, the more signal you
pick up, but it is a signal from a larger area.
So if you really want to be sure that you know exactly what you are doing, then the best method is to do this youself
by hand. You make multi-wavelength images:
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
and integrate over the images in the way you think best mimics the actual observing procedure. You can do so,
for instance, in Python. See Section Making multi-wavelength images for more information about multi-wavelength
images.
86
Chapter 8. Making images and spectra

radmc3d, Release 2.0
But to get some reasonable estimate of the effect of the wavelength-dependent size and circular geometry of a ‘beam’,
RADMC-3D allows you to make spectra with a simplistic circular mask, the radius of which can be speciﬁed as a
function of wavelength in the ﬁle aperture_info.inp (see Section INPUT: aperture_info.inp). This ﬁle should
contain a table of mask radii at various wavelengths, and when making a spectrum with the command-line keyword
useapert the mask radii will be found from this table by interpolation. In other words: the wavelength points of the
aperture_info.inp ﬁle do not have to be the same as those used for the spectrum. But their range must be larger
or equal than the range of the wavelengths used for the spectrum, because otherwise interpolation does not work. In
the most extreme simplistic case the aperture_info.inp ﬁle contains merely two values: one for a very short
wavelength (shorter than used in the spectrum) and one for a very long wavelength (longer than used in the spectrum).
The interpolation is then done double-logarithmically, so that a powerlaw is used between sampling points. So if you
use a telescope with a given diameter for the entire range of the spectrum, two sampling points would indeed sufﬁce.
You can now make the spectrum with the aperture in the following way:
radmc3d sed useapert dpc 100
The keyword dpc 100 is the distance of the observer in units of parsec, here assumed to be 100. This distance is
necessary because the aperture information is given in arcseconds, and the distance is used to convert this is image
size.
Important note: Although you specify the distance of the observer here, the spectrum.out ﬁle that is produced is
still normalized to a distance of 1 parsec.
Note also that in the above example you can add any other keywords as shown in the examples before, as long as you
add the useapert keyword and specify dpc.
A ﬁnal note: the default behavior of RADMC-3D is to use the square ﬁeld approach described before. You can
explicitly turn off the use of apertures (which may be useful in the child mode of RADMC-3D) with the keyword
noapert, but normally this is not necessary as it is the default.
8.4 Specifying custom-made sets of wavelength points for the cam-
era
If you want to make a spectrum at a special grid of wavelengths/frequencies, with the spectrum command (see
Section Making spectra), you must tell radmc3d which wavelengths you want to use. Here is described how to do
this in various ways.
8.4.1 Using lambdarange and (optionally) nlam
The simplest way to choose a set of wavelength for a spectrum is with the lambdarange and (optionally) nlam
command line options. Here is how to do this:
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20.
This will make a spectrum between 5 and 20 𝜇mu`m. You can change the number of wavelength points as well:
radmc3d spectrum incl 45 phi 30 lambdarange 5. 20. nlam 1000
This will do the same, but creates a spectrum of 1000 wavelength points.
You can use the lambdarange and nlam options also for multi-wavelength images:
radmc3d image incl 45 phi 30 lambdarange 5. 20. nlam 10
8.4. Specifying custom-made sets of wavelength points for the camera
87

radmc3d, Release 2.0
but it is wise to choose nlam small, because otherwise the output ﬁle, containing all the images, would become too
large.
8.4.2 Using allwl
You can also tell RADMC-3D to simply make an image at all of the wavelengths in the wavelength_micron.inp
ﬁle:
radmc3d image incl 45 phi 30 allwl
The keyword allwl stands for ‘all wavelengths’.
8.4.3 Using loadcolor
By giving the command loadcolor on the command line, radmc3d will search for the ﬁle color_inus.inp.
This ﬁle contains integers selecting the wavelengths from the ﬁle wavelength_micron.inp. The ﬁle is described
in Section The color_inus.inp ﬁle (required with comm-line option ‘loadcolor’).
8.4.4 Using loadlambda
By
giving
the
command
loadlambda
on
the
command
line,
radmc3d
will
search
for
the
ﬁle
camera_wavelength_micron.inp. This ﬁle contains a list of wavelengths in micron which constitute the
grid in wavelength. This ﬁle is described in Section INPUT (optional): camera_wavelength_micron.inp.
8.4.5 Using iline, imolspec etc (for when lines are included)
By adding for instance iline 3 to the command line you specify a window around line number 3 (by default of
molecule 1). By also specifying for instance imolspec 2 you select line 3 of molecule 2. By adding widthkms
3 you specify how wide the window around the line should be (3 km/s in this example). With vkms 2 you set
the window offset from line center by 2 km/s in this example. By adding linenlam 30 you set the number of
wavelength points for this spectrum to be 30 in this example. So a complete (though different) example is:
radmc3d spectrum incl 45 phi 30 iline 2 imolspec 1 widthkms 6.0 vkms 0.0 linenlam 40
8.5 Heads-up: In reality wavelength are actually wavelength bands
In a radiative transfer program like RADMC-3D the images or spectral ﬂuxes are calculated at exact wavelengths. This
would correspond to making observations with inﬁnitely narrow ﬁlters, i.e. ﬁlters with ∆𝜆= 0. This is not how
real observations work. In reality each wavelength channel has a ﬁnite width ∆𝜆and the measured ﬂux (or image
intensity) is an average over this range. To be even more precise, each wavelength channel 𝑖has some proﬁle Φ𝑖(𝜆)
deﬁned such that
∫︁∞
0
Φ𝑖(𝜆)𝑑𝜆= 1
For wide ﬁlters such as the standard photometric systems (e.g. UVBRI in the optical and JHK in the near infrared) these
proﬁles span ranges with a width of the order of 𝜆itself. Many instruments have their own set of ﬁlters. Usually one
can download these proﬁles as digital tables. It can, under some circumstances, be important to include a treatment of
88
Chapter 8. Making images and spectra

radmc3d, Release 2.0
these proﬁles in the model predictions. As an example take the N band. This is a band that includes the 10 𝜇lambda_i`
for 1 ≤𝑖≤𝑛, where 𝑛is the number of wavelength samples, and then compute the ﬁlter-averaged ﬂux with:
𝐹𝑏𝑎𝑛𝑑=
∫︁∞
0
Φ𝑖(𝜆)𝐹(𝜆)𝑑𝜆=
𝑛
∑︁
𝑖=1
Φ𝑖𝐹𝑖𝛿𝜆
where 𝛿𝜆is the wavelength sampling spacing used. The same is true for image intensities. RADMC-3D will not do
this automatically. You have to tell it the 𝜆𝑖sampling points, let it make the images or ﬂuxes, and you will then have
to perform this sum yourself. Note that this will not always be necessary! In many (most?) cases the dust continuum
is not expected to change so dramatically over the width of the ﬁlter that such degree of accuracy is required. So you
are advised to think carefully: ‘do I need to take care of this or can I make do with a single wavelength sample for
each ﬁlter?’. If the former, then do the hard work. If the latter: then you can save time.
8.5.1 Using channel-integrated intensities to improve line channel map quality
When you make line channel maps you may face a problem that is somehow related to the above issue of single-
𝜆-sampling versus ﬁlter-integrated ﬂuxes/intensities. If the model contains gas motion, then doppler shift will shift
the line proﬁle around. In your channel map you may see regions devoid of emission because the lines have doppler
shifted out of the channel you are looking at. However, as described in Section What can go wrong with line transfer?,
if the intrinsic line width of the gas is smaller than the cell-to-cell velocity differences, then the channel images may
look very distorted (they will look ‘blocky’, as if there is a bug in the code). Please refer to Section What can go wrong
with line transfer? for more details and updates on this important, but difﬁcult issue. It is not a bug, but a general
problem with ray-tracing of gas lines in models with large velocity gradients.
As one of the 𝛽-testers of RADMC-3D, Rahul Shetty, has found out, this problem can often be alleviated a lot if you
treat the ﬁnite width of a channel. By taking multiple 𝜆𝑖points in each wavelength channel (i.e. multiple 𝑣𝑖points in
each velocity channel) and simply averaging the intensities (i.e. assuming a perfectly square Φ function) and taking
the width of the channels to be not smaller (preferably substantially wider) than the cell-to-cell velocity differences,
this ‘blocky noise’ sometimes smoothes out well. However, it is always safer to use the ‘doppler catching’ mode (see
Section Preventing doppler jumps: The ‘doppler catching method’) to automatically prevent such problems (though
this mode requires more computer memory).
8.6 The issue of ﬂux conservation: recursive sub-pixeling
8.6.1 The problem of ﬂux conservation in images
If an image of nx×ny pixels is made simply by ray-tracing one single ray for each pixel, then there is the grave
danger that certain regions with high reﬁnement (for instance with AMR in cartesian coordinates, or near the center
of the coordinate system for spherical coordinates) are not properly ‘picked up’. An example: suppose we start with
a circumstellar disk ranging from 0.1 AU out to 1000 AU. Most of the near infrared ﬂux comes from the very inner
regions near 0.1 AU. If an image of the disk is made with 100x100 pixels and image half-size of 1000 AU, then none
of the pixels in fact pass through these very bright inner regions, for lack of spatial resolution. The problem is then that
the image, when integrated over the entire image, does not have the correct ﬂux. What should be is that the centermost
pixels contain the ﬂux from this innermost region, even if these pixels are much larger than the entire bright region. In
other words, the intensity of these pixels must represent the average intensity, averaged over the entire pixel. Strictly
speaking one should trace an inﬁnite continuous 2-D series of rays covering the entire pixel and then average over all
these rays; but this is of course not possible. In practice we should ﬁnd a way to estimate the average intensity with
only a ﬁnite number of rays.
8.6. The issue of ﬂux conservation: recursive sub-pixeling
89

radmc3d, Release 2.0
8.6.2 The solution: recursive sub-pixeling
In RADMC-3D what we do is to use some kind of ‘adaptive grid reﬁnement’ of the pixels of the image. For each pixel
in the image the intensity is computed through a call to a subroutine called camera_compute_one_pixel(). In
this subroutine a ray-tracing is performed for a ray that ends right in the middle of our pixel. During the ray-tracing,
however, we check if we pass regions in the model grid that have grid cells with sizes 𝑆that are smaller than the
pixel size divided by some factor 𝑓ref (where pixel size is, like the model grid size S itself, measured in centimeters.
If this is found not to be true, then the pixel size was apparently ok, and the intensity resulting from the ray-tracing
is now returned as the ﬁnal intensity of this pixel. If, however, this condition is found to be true, then the result of
this ray is rejected, and instead 2x2 sub-pixels are computed by calling the camera_compute_one_pixel()
subroutine recursively. We thus receive the intensity of each of these four sub-pixels, and we return the average of
these 4 intensities.
Note, by the way, that each of these 2x2 subpixels may be split even further into 2x2 sub-pixels etc until the desired
resolution is reached, i.e. until the condition that 𝑆is larger or equal to the pixel size divided by 𝑓ref is met. This
is illustrated in Fig. Fig. 8.3. By this recursive calling, we always end up at the top level with the average intesity
of the entire top-level pixel. This method is very similar to quad-tree mesh reﬁnement, but instead of retaining and
returning the entire complex mesh structure to the user, this method only returns the ﬁnal average intensity of each (by
deﬁnition top level) pixel in the image. So the recursive sub-pixeling technique described here is all done internally
in the RADMC-3D code, and the user will not really notice anything except that this sub-pixeling can of course be
computationally more expensive than if such a method is not used.
Fig. 8.3: Pictographic representation of how the recursive sub-pixeling for images works. Pixels are recursively split in
2x2 subpixels as far as needed to resolve the 3-D grid structure of the model. But at the end, the ﬂuxes of all subpixels
are summed up such that the resulting image has a regular grid again.
Note that the smaller we choose 𝑓ref the more accurate our image becomes. In the radmc3d.inp ﬁle the value
of 𝑓ref can be set by setting the variable camera_refine_criterion to the value you want 𝑓ref to be. Not
setting this variable means RADMC-3D will use the default value which is reasonable as a choice (default is 1.0). The
smaller you set camera_refine_criterion, the more accurate and reliable the results become (but the heavier
the calculation becomes, too).
NOTE: The issue of recursive sub-pixeling becomes tricky when stars are treated as spheres, i.e. non-point-like (see
Section Stars in the images and spectra and Chapter More information about the treatment of stars).
90
Chapter 8. Making images and spectra

radmc3d, Release 2.0
8.6.3 A danger with recursive sub-pixeling
It is useful to keep in mind that for each pixel the recursive sub-pixeling is triggered if the ray belonging to that pixel
encounters a cell that is smaller than the pixel size. This normally works well if 𝑓ref is chosen small enough. But
if there exist regions in the model where one big non-reﬁned cell lies adjacent to a cell that is reﬁned, say, 4 times
(meaning the big cell has neighbors that are 16 times smaller!), then if the ray of the pixel just happens to miss the small
cells and only passes the big cell, it won’t ‘notice’ that it may need to reﬁne to correctly capture the tiny neighboring
cells accurarely.
Such a problem only happens if reﬁnement levels jump by more than 1 between adjacent cells. If so, then it may be
important to make 𝑓ref correspondingly smaller (by setting camera_refine_criterion in radmc3d.inp to
the desired value). A bit of experimentation may be needed here.
8.6.4 Recursive sub-pixeling in spherical coordinates
In spherical coordinates the recursive sub-pixeling has a few issues that you may want to be aware of. First of all,
in 1-D spherical coordinates each cell is in fact a shell of a certain thickness. In 2-D spherical coordinates cells are
rings. In both cases the cells are not just local boxes, but have 2 or 1 (respectively) extended dimensions. RADMC-
3D takes care to still calculate properly how to deﬁne the recursive sub-pixeling scale. But for rays that go through
the central cavity of the coordinate system there is no uniquely deﬁned pixel resolution to take. The global variable
camera_spher_cavity_relres (with default value 0.05) deﬁnes such a relative scale. You can change this
value in the radmc3d.inp ﬁle.
A second issue is when the user introduces extreme ‘separable reﬁnement’ (see Section Separable grid reﬁnement
in spherical coordinates (important!) and Figure Fig. 9.3) in the 𝑅, Θ or Φ coordinate. This may, for instance, be
necessary near the inner edge of a dusty disk model in order to keep the ﬁrst cell optically thin. This may lead,
however, to extremely deep sub-pixeling for rays that skim the inner edge of the grid. This leads to a huge slow-down
of the ray-tracing process although it is likely not to give much a different result. By default RADMC-3D plays it safe.
If you wish to prevent this excessive sub-pixeling (at your own risk) then you can set the following variables in the
radmc3d.inp ﬁle:
• camera_min_drr which sets a lower limit to the ∆𝑅/𝑅taken into account for the sub-pixeling (region ‘B’
in Figure Fig. 9.2). The default is 0.003. By setting this to e.g. 0.03 you can already get a strong speed-up for
models with strong 𝑅-reﬁnement.
• camera_min_dangle which sets a lower limit to ∆Θ (region ‘C’ in Figure Fig. 9.2) and/or ∆Φ. The default
is 0.05. By setting this to e.g. 0.1 you can already get some speed-up for models with e.g. strong Θ-reﬁnement.
It is important to keep in mind that the smaller you make this number, the more accurate and reliable the results. It
may be prudent to experiment with smaller values of camera_min_drr for models with extremely optically thick
inner edges, e.g. a protoplanetary disk with an abrupt inner edge and a high dust surface density. For a disk model
with a very thin vertical extent it will be important to choose small values of camera_min_dangle, perhaps even
smaller than the default value.
For your convenience: Because it can be sometimes annoying to always have to play with the camera_min_drr,
camera_min_dangle and camera_spher_cavity_relres values, and since it is usually (!) not really
necessary to have such extremely careful subpixeling, RADMC-3D now has a new command line option called
sloppy.
This command-line option will set:
camera_min_drr=0.1, camera_min_dangle=0.1 and
camera_spher_cavity_relres=0.1. So if you have an image like this:
radmc3d image lambda 10 incl 45 phi 30 sloppy
then it will make the image with moderate, but not excessive subpixeling. This may, under some circumstances, speed
up the image-making in spherical coordinates by a large factor. Similar for making spectra. For instance:
8.6. The issue of ﬂux conservation: recursive sub-pixeling
91

radmc3d, Release 2.0
radmc3d sed incl 45 phi 30 sloppy
can be, under some circumstances, very much faster than without the sloppy option.
Note,however,
that
using
the
sloppy
option
and/or
setting
the
values
of
camera_min_drr,
camera_min_dangle and camera_spher_cavity_relres in the radmc3d.inp ﬁle by hand, {bf
is all at your own risk!} It is always prudent to check your results, now and then, against a non-sloppy calculation.
8.6.5 How can I ﬁnd out which pixels RADMC-3D is recursively reﬁning?
Sometimes you notice that the rendering of an image or spectrum takes much more time than you expected. When
recursive sub-pixeling is used for imaging, RADMC-3D will give diagnostic information about how many more pixels
it has rendered than the original image resolution. This factor can give some insight if extreme amount of sub-pixeling
reﬁnement has been used. But it does not say where in the image this occurs. If you want to see exactly which pixels
and subpixels RADMC-3D has rendered for some image, you can use the following command-line option:
radmc3d image lambda 10 diag_subpix
This diag_subpix option will tell RADMC-3D to write a ﬁle called subpixeling_diagnostics.out which
contains four columns: One for the x-coordinate of the (sub-)pixel, one for the y-coordinate of the (sub-)pixel, one
for the x-width of the (sub-)pixel and a ﬁnal one for the y-width of the (sub-)pixel. In Python you can then use, for
instance, the Numpy loadtxt method to read these columns.
If this diagnostic shows that the subpixeling is excessive (which can particularly happen in spherical coordinates) then
you might want to read Section Recursive sub-pixeling in spherical coordinates.
8.6.6 Alternative to recursive sub-pixeling
As an alternative to using this recursive sub-pixeling technique to ensure ﬂux conservation for images, one can simply
enhance the spatial resolution of the image, for instance
radmc3d image lambda 10 npix 400
Or even 800 or so. This has the clear advantage that the user gets the complete information of the details in the image
(while in the recursive sub-pixeling technique only the averages are retained). The clear disadvantages are that one
may need rediculously high-resolution images (i.e. large data sets) to resolve all the details and one may waste a lot of
time rendering parts of the image which do not need that resolution. The latter is typically an issue when images are
rendered from models that use AMR techniques.
8.7 Stars in the images and spectra
Per default, stars are still treated as point sources. That means that none of the rays of an image can be intercepted
by a star. Starlight is included in each image as a post-processing step. First the image is rendered without the stars
(though with of course all the emission of dust, lines etc induced by the stars) and then for each star a ray tracing is
done from the star to the observer (where only extinction is taken into account, because the emission is already taken
care of) and the ﬂux is then added to the image at the correct position. You can switch off the inclusion of the stars in
the images or spectra with the nostar command line option.
However, as of version 0.17, stars can also be treated as the ﬁnite-size spheres they are. This is done with setting
istar_sphere = 1 in radmc3d.inp. However, this mode can slow down the code a bit or even substantially.
And it may still be partly under development, so the code may stop if it is required to handle a situation it cannot
handle yet. See Chapter More information about the treatment of stars for details.
92
Chapter 8. Making images and spectra

radmc3d, Release 2.0
8.8 Second order ray-tracing (Important information!)
Ideally we would like to assure that the model grid is sufﬁciently ﬁnely spaced everywhere. But in many cases of
interest one does not have this luxury. One must live with the fact that, for memory and/or computing time reasons,
the grid is perhaps a bit coarser than would be ideal. In such a case it becomes important to consider the ‘order’ of
integration of the transfer equation. By default, for images and spectra, RADMC-3D uses ﬁrst order integration: The
source term and the opacity in each cell are assumed to be constant over the cell. This is illustrated in Fig. Fig. 8.4.
A
B
D
C
A
B
C
D
position
along ray 
jν
Fig. 8.4: Pictographic representation of the ﬁrst order integration of the transfer equation along a ray (red line with
arrow head) through an AMR grid (black lines). The grid cuts the ray into ray segments A, B, C and D. At the bottom
it is shown how the integrands are assumed to be along these four segments. The emissivity function 𝑗𝜈and extinction
function 𝛼𝜈are constant within each cell and thus constant along each ray segment.
The integration over each cell proceeds according to the following formula:
𝐼result = 𝐼start𝑒−𝜏+ (1 −𝑒−𝜏)𝑆
where 𝑆= 𝑗/𝛼is the source function, assumed constant throughout the cell, 𝜏= 𝛼∆𝑠is the optical depth along the
path that the ray makes through the cell, and 𝐼start is the intensity upon entering the cell. This is the default used by
RADMC-3D because the Monte Carlo methods also treat cells as having constant properties over each cell. This type
of simple integration is therefore the closest to how the Monte Carlo methods (thermal MC, scattering MC and mono
MC) ‘see’ the grid. However, with ﬁrst order integration the images look somewhat ‘blocky’: you can literally see
the block structure of the grid cells in the image, especially if you make images at angles aligned with the grid. For
objects with high optical depths you may even see grid patterns in the images.
RADMC-3D can also use second order integration for its images and spectra. This is illustrated in Fig. Fig. 8.5.
This is done with a simple secondorder option added on the command line, for instance:
radmc3d image lambda 10 secondorder
The integration now follows the formula (Olson et al. 1986):
𝐼result = 𝐼start𝑒−𝜏+ (1 −𝑒−𝜏−𝛽)𝑆start + 𝛽𝑆end
8.8. Second order ray-tracing (Important information!)
93

radmc3d, Release 2.0
A
B
D
C
A
B
C
D
position
along ray 
jν
Fig. 8.5: Pictographic representation of the second order integration of the transfer equation along a ray (red line
with arrow head) through an AMR grid (black lines). The grid cuts the ray into ray segments A, B, C and D. At the
bottom it is shown how the integrands are assumed to be along these four segments. The emissivity function 𝑗𝜈and
extinction function 𝛼𝜈are given at the cell corners (solid blue circles), and linearly interpolated from the cell corners
to the locations where the ray crosses the cell walls (open blue circles). Then, along each ray segment the emissivity
and extinction functions are assumed to be linear functions, so that the integration result is quadratic.
94
Chapter 8. Making images and spectra

radmc3d, Release 2.0
with
𝛽= 𝜏−1 + 𝑒−𝜏
𝜏
and
𝜏= 𝛼start + 𝛼end
2
∆𝑠
For 𝜏→0 we have the limit 𝛽→𝜏/2, while for 𝜏→∞we have the limit 𝛽→1.
The values of 𝛼, 𝑆etc., at the ‘start’ position are obtained at the cell interface where the ray enters the cell. The values
at the ‘end’ position are obtained at the cell interface where the ray leaves the cell. The above formulas represent
the exact solution of the transfer equation along this ray-section if we assume that all variables are linear functions
between the ‘start’ and ‘end’ positions.
The next question is: How do we determine the physical variables at the cell interfaces (‘start’ and ‘end’)? After all,
initially all variables are stored for each cell, not for each cell interface or cell corner. The way that RADMC-3D does
this is:
• First create a ‘grid of cell corners’, which we call the vertex grid (see the solid blue dots in Fig. Fig. 8.5). The
cell grid already implicitly deﬁnes the locations of all the cell corners, but these corners are, by default, not
explicitly listed in computer memory. When the secondorder option is given, however, RADMC-3D will
explicitly ﬁnd all cell corners and assign an identity (a unique integer number) to each one of them. NOTE:
Setting up this vertex grid costs computer memory!
• At each vertex (cell corner) the physical variables of the (up to) 8 cells touching the vertex are averaged with
equal weight for each cell. This now maps the physical variables from the cells to the vertices.
• Whenever a ray passes through a cell wall, the physical variables of the 4 vertices of the cell wall are interpolated
bilinearly onto the point where the ray passes through the cell wall (see the open blue circles in Fig. Fig. 8.5).
This gives the values at the ‘start’ or ‘end’ points.
• Since the current ‘end’ point will be the ‘start’ point for the next ray segment, the physical variables need only
be obtained once per cell wall, as they can be recycled for the next ray segment. Each set of physical variables
will thus be used twice: once for the ‘end’ and once for the ‘start’ of a ray segment (except of course at the very
beginning and very end of the ray).
If you compare the images or spectra obtained with ﬁrst order integration (default, see Figs. Fig. 8.8 and Fig. 8.9) or
second order integration (see Figs. Fig. 8.8 and Fig. 8.9) you see that with the ﬁrst order method you still see the cell
structure of the grid very much. Also numerical noise in the temperature due to the Monte Carlo statistics is much
more prominent in the ﬁrst order method. The second order method makes much smoother results.
For line transfer the second order mode can be even improved with the ‘doppler catching method’, see Section Pre-
venting doppler jumps: The ‘doppler catching method’.
WARNING: Second order integration for the images and spectra from dust continuum emission can in some cases
lead to overestimation of the ﬂuxes. This is because the dust temperature calculated using the thermal Monte Carlo
algorithm assumes the temperature to be constant over each cell. The second order integration for the images and
spectra will, however, smear the sources a bit out. This then leads to ‘leaking’ of emissivity from optically thick cells
into optically thin cells. These optically thin cells can then become too bright.
8.8. Second order ray-tracing (Important information!)
95

radmc3d, Release 2.0
Fig. 8.6: First-order integration of transfer equation in ray-tracing seen at inclination 4 degrees.
Fig. 8.7: First-order integration of transfer equation in ray-tracing seen at inclination 60 degrees.
96
Chapter 8. Making images and spectra

radmc3d, Release 2.0
Fig. 8.8: Second-order integration of transfer equation in ray-tracing seen at inclination 4 degrees.
Fig. 8.9: Second-order integration of transfer equation in ray-tracing seen at inclination 60 degrees.
8.8. Second order ray-tracing (Important information!)
97

radmc3d, Release 2.0
8.8.1 Second order integration in spherical coordinates: a subtle issue
The second order integration (as well as the doppler-catching method, see Section Preventing doppler jumps: The
‘doppler catching method’) work in cartesian coordinates as well as in spherical coordinates. In spherical coordinates
in 1-D (spherical symmetry) or 2-D (axial symmetry) there is, however, a very subtle issue that can lead to inaccuracies,
in particular with line transfer. The problem arises in the cell where a ray reaches its closest approach to the origin
of the coordinate system (or closest approach to the symmetry axis). There the ray segment can become fairly long,
and its angle with respect to the symmetry axis and/or the origin can drastically change within this single ray-segment.
This can sometimes lead to inaccuracies.
As of version 0.41 of RADMC-3D a new global variable is introduced, camera_maxdphi, which has as default the
value 0.1, but which can be set to another value in the radmc3d.inp ﬁle. It sets the maximum angle (in radian)
which a ray segment in spherical coordinates is allowed to span with respect to the origin of the coordinate system. If
a ray segment spans an angle larger than that, the ray-segment is cut into smaller segments. This means that in that
cell the ray will consist of more than one segment.
If camera_maxdphi=0 this segment cutting is switched off (for backward compatibility to earlier versions of
RADMC-3d).
8.9 Circular images
RADMC-3D offers (optionally!) an alternative to the usual x-y rectangular pixel arrangement of images: circular
images. Here the pixels are not arranged in rows that are vertically stacked (𝑥, 𝑦), but in concentric circles (𝑟, 𝜑). Such
a pixel arrangement is, of course, radically different from what we usually consider “an image”, and it is therefore
not possible to view such an image with the usual image viewing methods (such as Python’s plt.imshow()). Or
more precisely: if you would use plt.imshow() on a circular image you would see something that you would not
recognize as the image it should represent.
So what is the purpose? It is useful for models created on a spherical coordinate system. Such models can have
structure at a huge range of scales, from very tiny (at the small-end side of the radius coordinate 𝑟) to very large (at the
large-end side of the radius coordinate 𝑟). If you make a normal image, you have to pick the right “zoom factor”: are
you interested to see the outer regions or more interested in the inner regions? If you choose a “zoomed out” image,
you will under-resolve the inner regions. If you choose a “zoomed in” image, you will not see the outer regions (they
are beyond the edge of the image). One solution could be to choose a huge number of pixels, but that would create
huge image ﬁles.
Circular images solve this dilemma. By arranging the pixels not in (𝑥, 𝑦) but instead of (𝑟, 𝜑), the 𝑟coordinate grid
of the image will automatically be adapted to the 𝑟coordinate grid of the spherical coordinate system. If the latter is
logarithmically spaced, so will the circular image.
Here is how it works: Assuming you have a model in spherical coordinates, you can create a circular image as follows:
radmc3d image circ lambda 10
which creates a circular image at wavelength 𝜆= 10𝜇𝑚.
Using radmc3dPy you can read this image as follows:
from radmc3dPy import image
im = image.readcircimage()
The data is now in im.image. A radial plot of the intensity at a given angle 𝜑could be made as follows:
import matplotlib.pyplot as plt
plt.loglog(im.rc,im.image[:,0,0,0])
(continues on next page)
98
Chapter 8. Making images and spectra

radmc3d, Release 2.0
(continued from previous page)
plt.xlabel('r [cm]')
plt.ylabel(r'$I_\nu [erg\, cm^{-2}\, s^{-1}\, Hz^{-1}\, ster^{-1}]$')
The result will look like shown in Fig. Fig. 8.10 .
1013
1014
1015
r [cm]
10
19
10
17
10
15
10
13
10
11
10
9
I [erg cm
2 s
1 Hz
1 ster
1]
Fig. 8.10: Example of a circular image of a 1-D spherical model (the model in the examples/run_spher1d_1/
directory).
If you have 2-D or 3-D models in spherical coordinates, the circular images (should) have not only a grid in 𝑟, but
also 𝜑grid points. A simple plot such as Fig. Fig. 8.10 will only show the intensity for a single 𝑝ℎ𝑖choice. There
is no “right” or “wrong” way of displaying such an image. It depends on your taste. You could, of course, remap
onto a “normal” image, but that would defeat the purpose of circular images. You could also display the (𝑟, 𝜑) image
directly with e.g. plt.imshow(), which simply puts the 𝑟axis horizontally on the screen, and the 𝜑axis vertically,
essentially creating a ‘heat map’ of the intensity as a function of 𝑟and 𝜑.
This is illustrated in the model examples/run_spher2d_1/. Fig. Fig. 8.11 shows the circular image (as a ‘heat
map’) at a wavelength of 𝜆= 10 𝜇𝑚. For comparison, the same image is shown as a ‘normal’ image in Fig. Fig. 8.12.
With a bit of “getting used to” one will ﬁnd that the circular images will reveal a lot of information.
Note: Fig.
:numﬁg:`ﬁg-circ-image-2d` shows an effect similar to what is shown in Fig.
Fig. 15.1.
This in-
dicates that near the inner radius of the model, the radial grid is under-resolved in example model examples/
run_spher2d_1/: see Section Careful: Things that might go wrong, point ‘Too optically thick cells at the surface
or inner edge’. So, to improve the reliability of model examples/run_spher2d_1/, one would need to reﬁne
the radial grid near the inner edge and/or smooth the density there.
8.9. Circular images
99

radmc3d, Release 2.0
0
50
100
150
200
250
300
350
[deg]
0.0
0.5
1.0
1.5
10log(r) [AU]
= 10 m
16
15
14
13
12
11
10
10log(I ) [erg cm
2 s
1 Hz
1 ster
1 ]
Fig. 8.11: Example of a circular image of a 2-D spherical model (the model in the examples/run_spher2d_1/
directory).
100
Chapter 8. Making images and spectra

radmc3d, Release 2.0
100
50
0
50
100
X [AU]
100
75
50
25
0
25
50
75
100
Y [AU]
=10.00000 m
16
15
14
13
12
11
log(I  [erg/s/cm/cm/Hz/ster])
Fig. 8.12: The rectangular (‘normal’) version of the image of Fig. Fig. 8.11. As one can see: the inner regions of this
image are not well-resolved.
8.9. Circular images
101

radmc3d, Release 2.0
8.10 Visualizing the 𝜏= 1 surface
To be able to interpret the outcome of the radiative transfer calculations it is often useful to ﬁnd the spatial location of
the 𝜏= 1 surface (or, for that matter, the 𝜏= 0.1 surface or any 𝜏= 𝜏𝑠surface) as seen from the vantage point of the
observer. This makes it easier to understand where the emission comes from that you are seeing. RADMC-3D makes
this possible. Thanks to Peter Schilke and his team, for suggesting this useful option.
The idea is to simply replace the command-line keyword image with tausurf 1.0. The 1.0 stands for 𝜏𝑠= 1.0,
meaning we will ﬁnd the 𝜏= 1.0 surface. Example: Normally you might make an image with e.g. the following
command:
radmc3d image lambda 10 incl 45 phi 30
Now you make a 𝜏= 1 surface with the command:
radmc3d tausurf 1.0 lambda 10 incl 45 phi 30
or a 𝜏= 0.2 surface with
radmc3d tausurf 0.2 lambda 10 incl 45 phi 30
The image output ﬁle image.out will now contain, for each pixel, the position along the ray in centimeters where
𝜏= 𝜏𝑠. The zero point is the surface perpendicular to the direction of observation, going through the pointing position
(which is, by default (0, 0, 0), but see the description of pointau in Section Basics of image making with RADMC-
3D). Positive values mean that the surface is closer to the observer than the plane, while negative values mean that the
surface is behind the plane.
If, for some pixel, there exists no 𝜏= 𝜏𝑠point because the total optical depth of the object for the ray belonging to
that pixel is less than 𝜏𝑠, then the value will be -1e91.
You can also get the 3-D (i.e. 𝑥, 𝑦, 𝑧) positions of each of these points on the 𝜏= 𝜏𝑠surface. They are stored in the
ﬁle tausurface_3d.out.
Note that if you make multi-frequency images, you will also get multi-frequency 𝜏= 𝜏𝑠surfaces. This can be
particularly useful if you want to understand the sometimes complex origins of the shapes of molecular/atomic lines.
You can also use this option in the local observer mode, though I am not sure how useful it is. Note, however, that in
that mode the value stored in the image.out ﬁle will describe the distance in centimeter to the local observer. The
larger the value, the farther away from the observer (contrary to the case of observer-at-inﬁnity).
Example usage:
radmc3d tausurf 1 lambda 10 incl 45 phi 30
8.11 For public outreach work: local observers inside the model
While it may not be very useful for scientiﬁc purposes (though there may be exceptions), it is very nice for public
outreach to be able to view a model from the inside, as if you, as the observer, were standing right in the middle of the
model cloud or object. One can then use physical or semi-physical or even completely ad-hoc opacities to create the
right ‘visual effects’. RADMC-3D has a viewing mode for this purpose. You can use different projections:
• Projection onto ﬂat screen:
The simplest one is a projection onto a screen in front (or behind) the point-location of the ob-
server.
This gives an image that is good for viewing in a normal screen.
This is the default
(camera_localobs_projection=1).
102
Chapter 8. Making images and spectra

radmc3d, Release 2.0
• Projection onto a sphere:
Another projection is a projection onto a sphere, which allow ﬁelds of view that are equal or larger than
2𝜋of the sky.
It may be useful for projection onto an OMNIMAX dome.
This is projection mode
camera_localobs_projection=2.
You can set the variable camera_localobs_projection to 1 or 2 by adding on the command line
projection 2 (or 1), or by setting it in the radmc3d.inp as a line camera_localobs_projection =
2 (or 1).
To use the local projection mode you must specify the following variables on the command line:
• sizeradian: This sets the size of the image in radian (i.e. the entire width of the image). Setting this will
make the image width and height the same (like setting sizeau in the observer-at-inﬁnity mode, see Section
Basics of image making with RADMC-3D).
• zoomradian: Instead of sizeradian you can also specify zoomradian, which is the local-observer
version of zoomau or``zoompc`` (see Section Basics of image making with RADMC-3D).
• posang: The position angle of the camera. Has the same meaning as in the observer-at-inﬁnity mode.
• locobsau or locobspc: Specify the 3-D location of the local observer inside the model in units of AU or
parsec. This requires 3 numbers which are the x, y and z positions (also when using spherical coordinates for
the model setup: these are still the cartesian coordinates).
• pointau or pointpc: These have the same meaning as in the observer-at-inﬁnity model. They specify the
3-D location of the point of focus for the camera (to which point in space is the camera pointing) in units of AU
or parsec. This requires 3 numbers which are the x, y and z positions (also when using spherical coordinates for
the model setup: these are still the cartesian coordinates).
• zenith (optional): For Planetarium Dome projection (camera_localobs_projection=2) it is useful
to make the pointing direction not at the zenith (because then the audience will always have to look straight up)
but at, say, 45 degrees. You can facilitate this (optionally) by adding the command line option zenith 45 for
a 45 degrees offset. This means that if you are sitting under the OMNIMAX dome, then the camera pointing
(see pointau above) is 45 degrees in front of you rather than at the zenith. This option is highly recommended
for dome projections, but you may need to play with the angle to see which gives the best effect.
Setting sizeradian, zoomradian, locobsau or locobspc on the command line automatically switches to
the local observer mode (i.e. there is no need for an extra keyword setting the local observer mode on). To switch back
to observer-at-inﬁnity mode, you specify e.g. incl or phi (the direction toward which the observer is located in the
observer-at-inﬁnity mode). Note that if you accidently specify both e.g. sizeradian and incl, you might end up
with the wrong mode, because the mode is set by the last relevant entry on the command line.
The images that are produced using the local observer mode will have the x- and y- pixel size speciﬁcations in radian
instead of cm. The ﬁrst line of an image (the format number of the ﬁle) contains then the value 2 (indicating local
observer image with pixel sizes in radian) instead of 1 (which indicates observer-at-inﬁnity image with pixel sizes in
cm).
NOTE: For technical reasons dust scattering is (at least for now) not included in the local observer mode! It is
discouraged to use the local observer mode for scientiﬁc purposes.
8.11. For public outreach work: local observers inside the model
103

radmc3d, Release 2.0
8.12 Multiple vantage points: the ‘Movie’ mode
It can be useful, both scientiﬁcally and for public outreach, to make movies of your model, for instance by showing
your model from different vantage points or by ‘travelling’ through the model using the local observer mode (Section
For public outreach work: local observers inside the model). For a movie one must make many frames, each frame
being an image created by RADMC-3D’s image capabilities. If you call radmc3d separately for each image, then
often the reading of all the large input ﬁles takes up most of the time. One way to solve this is to call radmc3d in
‘child mode’ (see Chapter chap-child-mode). But this is somewhat complicated and cumbersome. A better way is to
use RADMC-3D’s ‘movie mode’. This allows you to ask RADMC-3D to make a sequence of images in a single call.
The way to do this is to call radmc3d with the movie keyword:
radmc3d movie
This will make radmc3d to look for a ﬁle called movie.inp which contains the information about each image it
should make. The structure of the movie.inp ﬁle is:
iformat
nframes
<<information for frame 1>>
<<information for frame 2>>
<<information for frame 3>>
...
<<information for frame nframes>>
The iformat is an integer that is described below. The nframes is the number of frames. The <<information
for frame xx>> are lines containing the information of how the camera should be positioned for each frame of
the movie (i.e. for each imag). It is also described below.
There are multiple ways to tell RADMC-3D how to make this sequence of images. Which if these ways RADMC-3D
should use is speciﬁed by the iformat number. Currently there are 2, but later we may add further possibilities.
Here are the current possibilities
• iformat=1: The observer is at inﬁnity (as usual) and the <<information for frame xx>> consists
of the following numbers (separated by spaces):
pntx pnty pntz hsx hsy pa incl phi
These 8 numbers have the following meaning:
– pntx,pnty,pntz: These are the x, y and z coordinates (in units of cm) of the point toward which the
camera is pointing.
– hsx,hsy: These are the image half-size in horizontal and vertical direction on the image (in units of cm).
– pa: This is the position angle of the camera in degrees. This has the same meaning as for a single image.
– incl,phi: These are the inclination and phi angle toward the observer in degrees. These have the same
meaning as for a single image.
• iformat=-1: The observer is local (see Section For public outreach work: local observers inside the model)
and the <<information for frame xx>> consists of the following numbers (separated by spaces):
pntx pnty pntz hsx hsy pa obsx obsy obsz
These 9 numbers have the following meaning:
– pntx,pnty,pntz,hsx,hsy,pa: Same meaning as for iformat=1.
– obsx,obsy,obsz: These are the x, y and z position of the local observer (in units of cm).
104
Chapter 8. Making images and spectra

radmc3d, Release 2.0
Apart from the quantities that are thus set for each image separately, all other command-line options still remain valid.
Example, let us make a movie of 360 frames of a model seen at inﬁnity while rotating the object 360 degrees, and as
seen at a wavelength of 𝜆= 10𝜇ﬁle:
1
360
0. 0. 0. 1e15 1e15 0. 60.
1.
0. 0. 0. 1e15 1e15 0. 60.
2.
0. 0. 0. 1e15 1e15 0. 60.
3.
.
.
.
0. 0. 0. 1e15 1e15 0. 60.
358.
0. 0. 0. 1e15 1e15 0. 60.
359.
0. 0. 0. 1e15 1e15 0. 60.
360.
We now call RADMC-3D in the following way:
radmc3d movie lambda 10. npix 200
This will create image ﬁles image_0001.out, image_0002.out, all the way to image_0360.out. The
images will have a full width and height of 2 × 1015phi`-angle.
Another example: let us move through the object (local observer mode), approaching the center very closely, but not
precisely:
-1
101
0. 0. 0. 0.8 0.8 0. 6.e13 -1.0000e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13 -0.9800e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13 -0.9600e15 0.
.
.
0. 0. 0. 0.8 0.8 0. 6.e13 -0.0200e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
0.0000e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
0.0200e15 0.
.
.
0. 0. 0. 0.8 0.8 0. 6.e13
0.9600e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
0.9800e15 0.
0. 0. 0. 0.8 0.8 0. 6.e13
1.0000e15 0.
Here the camera automatically rotates such that the focus remains on the center, as the camera ﬂies by the center of
the object at a closest-approach to the center of 6 × 1013 cm. The half-width of the image is 0.8 radian.
Important note: If you have scattering switched on, then every rendering of an image makes a new scattering Monte
Carlo run. Since Monte Carlo produces noise, this would lead to a movie that is very jittery (every frame has a new
noise set). It is of course best to avoid this by using so many photon packages that this is not a concern. But in practice
this may be very CPU-time consuming. You can also ﬁx the noise in the following way: add resetseed to the
command-line call:
radmc3d movie resetseed
and it will force each new scattering Monte Carlo computation to start with the same seed, so that the photons will
exactly move along the same trajectories. Now only the scattering phase function will change because of the different
vantage points, but not the Monte Carlo noise. You can in fact set the actual value of the initial seed in the radmc3d.
inp ﬁle by adding a line
8.12. Multiple vantage points: the ‘Movie’ mode
105

radmc3d, Release 2.0
iseed = -5415
(where -5415 is to be replaced by the value you want) to the radmc3d.inp ﬁle. Note also that if your movie goes
through different wavelengths, the resetseed will likely not help ﬁxing the noisiness, because the paths of photons will
change for different wavelengths, even with the same initial seed.
106
Chapter 8. Making images and spectra

CHAPTER
NINE
MORE INFORMATION ABOUT THE GRIDDING
We already discussed the various types of grids in Section The spatial grid, and the grid input ﬁle structure is described
in Section INPUT (required): amr_grid.inp. In this chapter let us take a closer look at the gridding possibilities and
things to take special care of.
9.1 Regular grids
A regular grid is called ‘grid style 0’ in RADMC-3D. It can be used in Cartesian coordinates as well as in spherical
coordinates (Section Coordinate systems).
A regular grid, in our deﬁnition, is a multi-dimensional grid which is separable in 𝑥, 𝑦and 𝑧(or in spherical coordinates
in 𝑟, 𝜃and 𝜑). You specify a 1-D monotonically increasing array of values 𝑥1, 𝑥2, · · · , 𝑥nx+1 which represent the cell
walls in 𝑥−𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛. You do the same for the other directions: 𝑦1, 𝑦2, · · · , 𝑦ny+1 and 𝑧1, 𝑧2, · · · , 𝑧nz+1. The value
of, say, 𝑥2 is the same for every position in 𝑦and 𝑧: this is what we mean with ‘separable’.
In Cartesian coordinates RADMC-3D enforces perfectly cubic grid cells (i.e. linear grids). But that is only to make the
image sub-pixeling easier (see Section The solution: recursive sub-pixeling). For spherical grids this is not enforced,
and in fact it is strongly encouraged to use non-linear grids in spherical coordinates. Please read Section Separable
grid reﬁnement in spherical coordinates (important!) if you use spherical coordinates!
In a regular grid you specify the grids in each direction separately. For instance, the x-grid is given by specifying
the cell walls in x-direction. If we have, say, 10 cells in x-direction, we must specify 11 cell wall positions. For
instance: 𝑥𝑖= {−5, −4, −3, −2, −1, 0, 1, 2, 3, 4, 5}. For the 𝑦-direction and 𝑧-direction likewise. Fig. Fig. 9.1 shows
an example of a 2-D regular grid of 4x3 cells.
yc[2]
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
Fig. 9.1: Example of a regular 2-D grid with nx=4 and ny=3.
107

radmc3d, Release 2.0
In Cartesian coordinates we typically deﬁne our model in full 3-D. However, if your problem has translational sym-
metries, you might also want to consider the 1-D plane-parallel mode (see Section 1-D Plane-parallel models).
In full 3-D Cartesian coordinates the cell sizes must be perfectly cubical, i.e. the spacing in each direction must be the
same. If you need a ﬁner grid in some location, you can use the AMR capabilities discussed below.
In spherical coordinates you can choose between 1-D spherically symmetric models, 2-D axisymmetric models or
fully 3-D models. In spherical coordinates you do not have restrictions to the cell geometry or grid spacing. You can
choose any set of numbers 𝑟1, · · · , 𝑟nr as radial grid, as long as this set of numbers is larger than 0 and monotonically
increasing. The same is true for the 𝜃-grid and the 𝜑-grid.
The precise way how to set up a regular grid using the amr_grid.inp ﬁle is described in Section Regular grid. The
input of any spatial variables (such as e.g. the dust density) uses the sequence of grid cells in the same order as the
cells are speciﬁed in that amr_grid.inp ﬁle.
For input and output data to ﬁle, for stuff on a regular grid, the order of nested loops over coordinates would be:
do iz=1,amr_grid_nz
do iy=1,amr_grid_ny
do ix=1,amr_grid_nx
<< read or write your data >>
enddo
enddo
enddo
For spherical coordinates we have the following association: 𝑥→𝑟, 𝑦→𝜃, 𝑧→𝜑.
9.2 Separable grid reﬁnement in spherical coordinates (important!)
Spherical coordinates are a very powerful way of dealing with centrally-concentrated problems. For instance, col-
lapsing protostellar cores, protoplanetary disks, disk galaxies, dust tori around active galactic nuclei, accretion disks
around compact objects, etc. In other words: problems in which a single central body dominates the problem, and
material at all distances from the central body matters. For example a disk around a young star goes all the way from
0.01 AU out to 1000 AU, covering 5 orders of magnitude in radius. Spherical coordinates are the easiest way of dealing
with such a huge radial dynamic range: you simply make a radial grid, where the grid spacing 𝑟𝑖+1 −𝑟𝑖scales roughly
with 𝑟𝑖.
This is called a logarithmic radial grid. This is a grid whith a spacing in which (𝑟𝑖+1 −𝑟𝑖)/𝑟𝑖is constant with 𝑟.
In this way you assure that you have always the right spatial resolution in 𝑟at each radius. In spherical coordinates
it is highly recomended to use such a log spacing. But you can also reﬁne the 𝑟grid even more (in addition to the
log-spacing). This is also strongly recommended near the inner edge of a circumstellar shell, for instance. Or at the
inner dust rim of a disk. There you must reﬁne the 𝑟grid (by simply making the spacing smaller as you approach the
inner edge from the outside) to assure that the ﬁrst few cells are optically thin and that there is a gradual transition
from optically thin to optically thick as you go outward. This is particularly important for, for instance, the inner rim
of a dusty disk.
In spherical coordinates you can vary the spacing in 𝑟, 𝜃and 𝜑completely freely. That means: you could have for
instance 𝑟to be spaced as 1.00, 1.01, 1.03, 1.05, 1.1, 1.2, 1.35, · · ·. There is no restriction, as long as the coordinate
points are monotonically increasing. In Figs Fig. 9.2 and Fig. 9.3 this is illustrated.
Note that in addition to separable reﬁnement, also AMR reﬁnement is possible in spherical coordinates. See Section
Oct-tree Adaptive Mesh Reﬁnement.
For models of accretion disks it can, for instance, be useful to make sure that there are more grid points of 𝜃near
the equatorial plane 𝜃= 𝜋/2. So the grid spacing between 𝜃= 0.0 and 𝜃= 1.0 may be very coarse while between
𝜃= 1.0 and 𝜃= 𝜋/2 you may put a ﬁner grid. All of this ‘grid reﬁnement’ can be done without the ‘AMR’ reﬁnement
technique: this is the ‘separable’ grid reﬁnement, because you can do this separately for 𝑟, for 𝜃and for 𝜑.
108
Chapter 9. More information about the gridding

radmc3d, Release 2.0
coordinates
A
B
C
Separable
grid refinement
in spherical
Fig. 9.2: Example of a spherical 2-D grid in which the radial and 𝜃grids are reﬁned in a ‘separable’ way. In radial
direction the inner cells are reﬁned (‘B’ in the right ﬁgure) and in 𝜃direction the cells near the equatorial plane are
reﬁned (‘C’ in the right ﬁgure). This kind of grid reﬁnement does not require oct-tree AMR: the grid remains separable.
For models in which the inner grid edge is also the inner model edge (e.g. a simple model of a protoplanetary disk
with a sharp inner cut-off) this kind of separable grid reﬁnement in 𝑅-direction may be essential to avoid problems
with optically thick inner cells (see e.g. Fig. Fig. 15.1 for an example of what could go wrong if you do not do this).
Separable grid reﬁnement in Θ-direction is typically important for protoplanetary disk models, where the midplane
and surface layers of the disk need to have sufﬁcient resolution, but any possible surrounding spherical nebula may
not.
9.2. Separable grid reﬁnement in spherical coordinates (important!)
109

radmc3d, Release 2.0
for images and spectra
High−res sub−pixels
High−res sub−pixels
High−res sub−pixels
Arrangement of rays
Fig. 9.3: When making an image, RADMC-3D will automatically make ‘sub-pixels’ to ensure that all structure of the
model as projected on the sky of the observer are spatially resolved. Extreme grid reﬁnement leads thus to extreme
sub-pixeling. See Section Recursive sub-pixeling in spherical coordinates for details, and ways to prevent excessive
sub-pixeling when this is not necessary.
Sometimes, however, separable reﬁnement may not help you to reﬁne the grid where necessary. For instance: if you
model a disk with a planet in the disk, then you may need to reﬁne the grid around the planet. You could reﬁne the grid
in principle in a separable way, but you would then have a large redundancy in cells that are reﬁned by far away from
the planet. Or if you have a disk with an inner rim that is not exactly at 𝑟= 𝑟rim, but is a rounded-off rim. In these
cases you need reﬁnement exactly located at the region of interest. For that you need the ‘AMR’ reﬁnement (Sections
Oct-tree Adaptive Mesh Reﬁnement and Layered Adaptive Mesh Reﬁnement).
Important note: When using strong reﬁnement in one of the coordinates 𝑟, 𝜃or 𝜑, image-rendering and spectrum-
rendering can become very slow, because of the excessive sub-pixeling this causes. There are ways to limit the
sub-pixeling for those cases. See the Section on sub-pixeling in spherical coordinate: Section Recursive sub-pixeling
in spherical coordinates.
9.3 Oct-tree Adaptive Mesh Reﬁnement
An oct-tree reﬁnened grid is called ‘grid style 1’ in RADMC-3D. It can be used in Cartesian coordinates as well as in
spherical coordinates (Section Coordinate systems).
You start from a normal regular base grid (see Section Regular grids), possibly even with ‘separable reﬁnement’ (see
Section Separable grid reﬁnement in spherical coordinates (important!)). You can then split some of the cells into
2x2x2 subcells (or more precisely: in 1-D 2 subcells, in 2-D 2x2 subcells and in 3-D 2x2x2 subcells). If necessary,
each of these 2x2x2 subcells can also be split into further subcells. This can be repeated as many times as you wish
until the desired grid reﬁnement level is reached. Each reﬁnement step reﬁnes the grid by a factor of 2 in linear
dimension, which means in 3-D a factor of 8 in volume. In this way you get, for each reﬁned cell of the base grid, a
tree of reﬁnement. The base grid can have any size, as long as the number of cells in each direction is an even number.
For instance, you can have a 6x4 base grid in 2-D, and reﬁne cell (1,2) by one level, so that this cell splits into 2x2
subcells.
110
Chapter 9. More information about the gridding

radmc3d, Release 2.0
Note that it is important to set which dimensions are ‘active’ and which are ‘non-active’. For instance, if you have
a 1-D model with 100 cells and you tell RADMC-3D (see Section Oct-tree-style AMR grid) to make a base grid of
100x1x1 cells, but you still keep all three dimensions ‘active’ (see Section Oct-tree-style AMR grid), then a reﬁnement
of cell 1 (which is actually cell (1,1,1)) will split that cell into 2x2x2 subcells, i.e. it will also reﬁne in y and z direction.
Only if you explicitly switch the y and z dimensions off the AMR will split it into just 2 subcells.
Oct-tree mesh reﬁnement is very powerful, because it allows you to reﬁne the grid exactly there where you need it.
And because we start from a regular base grid like the grid speciﬁed in Section Regular grids, we can start designing
our model on a regular base grid, and then reﬁne where needed. See Fig. Fig. 9.4.
yc[2]
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
Fig. 9.4: Example of a 2-D grid with oct-tree reﬁnement. The base grid has nx=4 and ny=3. Three levels of
reﬁnement are added to this base grid.
The AMR stand for ‘Adaptive Mesh Reﬁnement’, which may suggest that RADMC-3D will reﬁne internally. At the
moment this is not yet the case. The ‘adaptive’ aspect is left to the user: he/she will have to ‘adapt’ the grid such that
it is sufﬁciently reﬁnened where it is needed. In the future we may allow on-the-ﬂy adaption of the grid, but that is not
yet possible now.
One problem with oct-tree AMR is that it is difﬁcult to handle such grids in external plotting programs, or even in
programs that set up the grid. While it is highly ﬂexible, it is not very user-friendly. Typically you may use this
oct-tree reﬁnement either because you import data from a hydrodynamics code that works with oct-tree reﬁnement
(e.g. FLASH, RAMSES), or when you internally reﬁne the grid using the userdef_module.f90 (see Chapter
Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes). In the former case you are anyway
forced to manage the complexities of AMR, while in the latter case you can make use of the AMR modules of
RADMC-3D internally to handle them. But if you do not need to full ﬂexibility of oct-tree reﬁnement and want to
use a simpler kind of reﬁnement, then you can use RADMC-3D’s alternative reﬁnement mode: the layer-style AMR
described in Section Layered Adaptive Mesh Reﬁnement below.
The precise way how to set up such an oct-tree grid using the amr_grid.inp ﬁle is described in Section Oct-tree-
style AMR grid. The input of any spatial variables (such as e.g. the dust density) uses the sequence of grid cells in the
same order as the cells are speciﬁed in that amr_grid.inp ﬁle.
9.3. Oct-tree Adaptive Mesh Reﬁnement
111

radmc3d, Release 2.0
9.4 Layered Adaptive Mesh Reﬁnement
A layer-style reﬁnened grid is called ‘grid style 10’ in RADMC-3D. It can be used in Cartesian coordinates as well as
in spherical coordinates (Section Coordinate systems).
This is an alternative to the full-ﬂedged oct-tree reﬁnement of Section Oct-tree Adaptive Mesh Reﬁnement. The main
advantage of the layer-style reﬁnement is that it is far easier to handle by the human brain, and thus easier for model
setup and the analysis of the results.
The idea here is that you start again with a regular grid (like that of Section Regular grids), but you can now specify a
rectangular region which you want to reﬁne by a factor of 2. The way you do this is by choosing the starting indices
of the rectangle and specifying the size of the rectangle by setting the number of cells in each direction from that
starting point onward. For instance, setting the starting point at (2,3,1) and the size at (1,1,1) will simply reﬁne just
cell (2,3,1) of the base grid into a set of 2x2x2 sub-cells. But setting the starting point at (2,3,1) and the size at (2,2,2)
will split cells (2,3,1), (3,3,1), (2,4,1), (3,4,1), (2,3,2), (3,3,2), (2,4,2) and (3,4,2) each into 2x2x2 subcells. This in fact
is handled as a 4x4x4 regular sub-grid patch. And setting the starting point at (2,3,1) and the size at (4,6,8) will make
an entire regular sub-grid patch of 8x12x16 cells. Such a sub-grid patch is called a layer.
The nice thing of these layers is that each layer (i.e. subgrid patch) is handled as a regular sub-grid. The base grid is
layer number 0, and the ﬁrst layer is layer number 1, etc. Each layer (including the base grid) can contain multiple
sub-layers. The only restriction is that each layer ﬁts entirely inside its parent layer, and layers with the same parent
layer should not overlap. Each layer can thus have one or more sub-layers, each of which can again be divided into
sub-layers. This builds a tree structure, with the base layer as the trunk of the tree (this is contrary to the oct-tree
structure, where each base grid cell forms the trunk of its own tree). In Fig. Fig. 9.5 an example is shown of two layers
with the same parent (= layer 0 = base grid), while in Fig. Fig. 9.6 an example is shown of two nested layers.
iy=6
iy=5
xi[1]
yi[1]
ix=1
ix=2
ix=3
ix=4
xc[1]
xi[2]
xc[2]
xi[3]
xc[3]
xi[4]
xc[4]
xi[5]
ix=5
ix=6
ix=7
ix=8
xi[6]
xi[7]
xi[8]
xc[6]
xc[7]
xc[8]
xc[5]
xi[9]
yc[1]
iy=1
iy=2
iy=3
yi[2]
yc[2]
yi[3]
yc[3]
yi[4]
yi[5]
yi[6]
yi[7]
yc[4]
yc[5]
yc[6]
iy=4
Fig. 9.5: Example of a 2-D base grid with nx=4 and ny=3, with two AMR-layers added to it. This example has just
one level of reﬁnement, as the two layers (brown and green) are on the same level (they have the same parent layer =
layer 0).
If you now want to specify data on this grid, then you simply specify it on each layer separately, as if each layer
is a separate entity. Each layer is treated as a regular grid, irrespective of whether it contains sub-layers or not. So
if we have a base grid of 4x4x4 grid cells containing two layers: one starting at (1,1,1) and having (2,2,2) size and
another starting at (3,3,3) and having (1,1,2) size, then we ﬁrst specify the data on the 43 = 64 base grid, then on the
(2×2)3 = 64 grid cells of the ﬁrst layer and then on the 2x2x4=16 cells of the second layer. Each of these three layers
are regular grids, and the data is inputted/outputted in the same way as if these are normal regular grids (see Section
Regular grids). But instead of just one such regular grid, now the data ﬁle (e.g. dust_density.inp) will contain
three successive lists of numbers, the ﬁrst for the base grid, the second for the ﬁrst layer and the last for the second
layer. You may realize at this point that this will introduce a redundancy. See Subsection On the ‘successively regular’
112
Chapter 9. More information about the gridding

radmc3d, Release 2.0
iy=6
iy=5
xi[1]
yi[1]
ix=1
ix=2
ix=3
ix=4
xc[1]
xi[2]
xc[2]
xi[3]
xc[3]
xi[4]
xc[4]
xi[5]
ix=5
ix=6
ix=7
ix=8
xi[6]
xi[7]
xi[8]
xc[6]
xc[7]
xc[8]
xc[5]
xi[9]
yc[1]
iy=1
iy=2
iy=3
yi[2]
yc[2]
yi[3]
yc[3]
yi[4]
yi[5]
yi[6]
yi[7]
yc[4]
yc[5]
yc[6]
iy=4
Fig. 9.6: Example of a 2-D base grid with nx=4 and ny=3, with two nested AMR-layers added to it. This example
has two levels of reﬁnement, as layer 1 (brown) is the parent of layer 2 (green).
kind of data storage, and its slight redundancy for a discussion of this redundancy.
The precise way how to set up such an oct-tree grid using the amr_grid.inp ﬁle is described in Section Layer-style
AMR grid. The input of any spatial variables (such as e.g. the dust density) uses the sequence of grid cells in the same
order as the cells are speciﬁed in that amr_grid.inp ﬁle.
9.4.1 On the ‘successively regular’ kind of data storage, and its slight redundancy
With the layered grid reﬁnement style there will be redundant data in the data ﬁles (such as e.g. the dust_density.
inp ﬁle. Each layer is a regular (sub-)grid and the data will be speciﬁed in each of these grid cells of that regular
(sub-)grid. If then some of these cells are overwritten by a higher-level layer, these data are then redundant. We could
of course have insistent that only the data in those cells that are not reﬁned by a layer should be written to (or read
from) the data ﬁles. But this would require quite some clever programming on the part of the user to a-priori ﬁnd out
where the layers are and therefore which cells should be skipped. We have decided that it is far easier to just insist
that each layer (including the base grid, which is layer number 0) is simply written to the data ﬁle as a regular block
of data. The fact that some of this data will be not used (because they reside in cells that are reﬁned) means that we
write more data to ﬁle than really exists in the model. This makes the ﬁles larger than strictly necessary, but it makes
the data structure by far easier. Example: suppose you have a base grid of 8x8x8 cells and you replace the inner 4x4x4
cells with a layer of 8x8x8 cells (each cell being half the size of the original cells). Then you will have for instance a
dust_density.inp ﬁle containing 1024 values of the density: 83=512 values for the base grid and again 83=512
values for the reﬁnement layer. Of the ﬁrst 83=512 values 43=64 values are ignored (they could have any value as they
will not be used). The ﬁle is thus 64 values larger than strictly necessary, which is a redundancy of 64/1024=0.0625. If
you would have used the oct-tree reﬁnement style for making exactly the same grid, you would have only 1024-64=960
values in your ﬁle, making the ﬁle 6.25% smaller. But since 6.25% is just a very small difference, we decided that this
is not a major problem and the simplicity of our ‘successively regular’ kind of data format is more of an advantage
than the 6.25% redundance is a disadvantage.
9.4. Layered Adaptive Mesh Reﬁnement
113

radmc3d, Release 2.0
9.5 Unstructured grids
In a future version of RADMC-3D we will include unstructured gridding as a possibility. But at this moment such a
gridding is not yet implemented.
9.6 1-D Plane-parallel models
Sometimes it can be useful to make simple 1-D plane parallel models, for instance if you want to make a simple 1-D
model of a stellar atmosphere. RADMC-3D is, however, by nature a 3-D code. But as of version 0.31 it features
a genuine 1-D plane-parallel mode as well. This coordinate type has the number 10. In this mode the 𝑥- and 𝑦-
coordinates are the in-plane coordinates, while the 𝑧-coordinate is the 1-D coordinate. We thus have a 1-D grid in the
𝑧-coordinate, but no grid in 𝑥- or 𝑦-directions.
You can make a 1-D plane-parallel model by setting some settings in the amr_grid.inp ﬁle. Please consult Section
INPUT (required): amr_grid.inp for the format of this ﬁle. The changes/settings you have to do are (see example
below): (1) set the coordinate type number to 10, (2) set the 𝑥and 𝑦dimensions to non-active and (3) setting the cell
interfaces in 𝑥to -1d90, +1d90, and likewise for 𝑦. Here is then how it looks:
1
<=== Format number = 1
0
<=== Grid style (0=regular grid)
10
<=== Coordinate type (10=plane-parallel)
0
<=== (obsolete)
0
0
1
<=== x and y are non-active, z is active
1
1
100
<=== x and y are 1 cell, in z we have 100 cells
-1e90 1e90
<=== cell walls in x are at "infinity"
-1e90 1e90
<=== cell walls in y are at "infinity"
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
The other input ﬁles are for the rest as usual, as in the 3-D case.
You can now make your 1-D model as usual. For 1-D plane-parallel problems it is often useful to put a thermal
boundary at the bottom of the model. For instance, if the model is a stellar atmosphere, you may want to cap the grid
from below with some given temperature. See Section Thermal boundaries in Cartesian coordinates for details on
how to set up thermal boundaries.
In the 1-D plane-parallel mode some things work a bit different than in the “normal” 3-D mode:
• Images are by default 1x1 pixels, because in a plane-parallel case it is useless to have multiple pixels.
• Spectra cannot be made, because “spectrum” is (in RADMC-3D ‘language’) the ﬂux as a function of frequency
as seen at a very large distance of the object, so that the object is in the “far ﬁeld”. Since the concept of “far-ﬁeld”
is no longer meaningful in a plane-parallel case, it is better to make frequency-dependent 1x1 pixel images. This
gives you the frequence-dependent intensity, which is all you should need.
• Stars are not allowed, as they have truly 3-D positions, which is inconsistent with the plane-parallel assumption.
But for the rest, most stuff works similarly to the 3-D version. For instance, you can compute dust temperatures with
radmc3d mctherm
as usual.
114
Chapter 9. More information about the gridding

radmc3d, Release 2.0
9.6.1 Making a spectrum of the 1-D plane-parallel atmosphere
As mentioned above, the ‘normal’ 3-D way of making a spectrum of the 1-D plane-parallel atmosphere is not possible,
because formally the atmosphere is inﬁnitely extended. Instead you can obtain a spectrum in the form of an intensity
(erg s−1 cm−2 Hz−1 ster−1) as a function of wavelength. To do this you ask RADMC-3D to make a multi-wavelength
image of the atmosphere under a certain inclination (inclination 0 meaning face-on), e.g.:
radmc3d image allwl incl 70
This make an SED at 𝜆= 10 𝜇m for the observer seeing the atmosphere at an inclination of 70 degrees. This produces
a ﬁle image.out, described in Section OUTPUT: image.out or image_****.out. The image is, in fact, a 1x1 pixel
multi-wavelength image. The allwl (which stands for ‘all wavelengths’) means that the spectral points are the same
as those in the wavelength_micron.inp ﬁle (see Section INPUT (required): wavelength_micron.inp). You can
also specify the wavelengths in a different way, e.g.:
radmc3d image lambdarange 5 20 nlam 10
In fact, see Section Making multi-wavelength images and Section Specifying custom-made sets of wavelength points
for the camera for details.
9.6.2 In 1-D plane-parallel: no star, but incident parallel ﬂux beams
In 1-D plane-parallel geometry it is impossible to include meaningful stars as sources of photons. This is not a technical
issue, but a mathematical truth: a point in 1-D is in reality a plane in 3-D. As a replacement RADMC-3D offers (only
in 1-D plane-parallel geometry) the possibility of illuminating the 1-D atmosphere from above with a ﬂux, incident
onto the atmosphere in a prescribed angle. This allows you to model, e.g., the Earth’s atmosphere being illuminated by
the sun at a given time of the day. This is done by providing an ascii ﬁle called illum.inp which has the following
form (similar, but not identical, to the stars.inp ﬁle, see Section INPUT (mostly required): stars.inp):
iformat
<=== Put this to 2 !
nillum
nlam
theta[1]
phi[1]
.
.
.
.
theta[nillum] phi[nillum]
lambda[1]
.
.
lambda[nlam]
flux[1,illum=1]
.
.
flux[nlam,illum=1]
flux[1,illum=2]
.
.
flux[nlam,illum=2]
.
.
.
.
flux[nlam,illum=nstar]
Here nillum is the number of illuminating beams you want to specify. Normally this is 1, unless you have, e.g., a
planet around a double star. The theta is the angle (in degrees) under which the beam impinges onto the atmosphere.
9.6. 1-D Plane-parallel models
115

radmc3d, Release 2.0
If you have theta=0, then the ﬂux points vertically downward (sun at zenith). If you have theta=89, then the ﬂux
points almost parallel to the atmosphere (sunset). It is not allowed to put theta=90.
You can, if you wish, also put the source behind the slab, i.e. theta>90. Please note, however, that if you compute
the spectrum of the plane-parallel atmosphere the direct ﬂux from these illumination beams does not get picked up in
the spectrum.
9.6.3 Similarity and difference between 1-D spherical and 1-D plane-parallel
Note that this 1-D plane-parallel mode is only available in 𝑧-direction, and only for cartesian coordinates! For spherical
coordinates, a simple switch to 1-D yields spherically symmetric 1-D radiative transfer, which is, however, geometri-
cally distinct from 1-D plane-parallel radiative transfer. However, you can also use a 1-D spherically symmetric setup
to ‘emulate’ 1-D plane parallel problems: You can make, for instance, a radial grid in which 𝑟nr/𝑟1 −1 ≪1. An
example: 𝑟= {10000.0, 10000.1, 10000.2, · · · , 10001.0}. This is not perfectly plane-parallel, but sufﬁciently much
so that the difference is presumably indiscernable. The spectrum is then automatically that of the entire large sphere,
but by dividing it by the surface area, you can recalculate the local ﬂux. In fact, since a plane-parallel model usually
is meant to approximate a tiny part of a large sphere, this mode is presumably even more realistic than a truly 1-D
plane-parallel model.
9.7 Thermal boundaries in Cartesian coordinates
By default all boundaries of the computational domain are open, in the sense that photons can move out freely. The
only photons that move into the domain from the outside are those from the interstellar radiation ﬁeld (see Section The
interstellar radiation ﬁeld: external source of energy) and from any stars that are located outside of the computational
domain (see Section INPUT (mostly required): stars.inp). For some purposes it might, however, be useful to have
one or more of the six boundaries in 3-D to be closed. RADMC-3D offers the possibility, in cartesian coordinates, to
convert the boundaries (each of the six separately) to a thermal boundary, i.e. a blackbody emitter at some user-seciﬁed
temperature. If you want that the left X-boundary is a thermal wall at T=100 Kelvin, then you add the following line
to the radmc3d.inp ﬁle:
thermal_boundary_xl = 100
and similarly for xr (right X-boundary), yl, yr, zl and/or zr. You can set this for each boundary separately, and
particularly you can choose to set just one or just two of the boundaries to thermal boundaries. Note that setting
thermal_boundary_xl=0 is equivalent to switching off the thermal boundary.
Note that if you now make an image of the box, the ray-tracer will show you still the inside of the box, through
any possible thermal boundary. In other words: for the imaging or spectra these thermal boundaries are opaque
for radiation entering the grid, while they are transparent for radiation exiting the grid. In other words, we see the
blackbody emission from the backside walls, but not of the frontside walls. In this way we can have a look inside the
box in spite of the thermal walls.
116
Chapter 9. More information about the gridding

CHAPTER
TEN
MORE INFORMATION ABOUT THE TREATMENT OF STARS
How stars are treated in RADMC-3D is perhaps something that needs some more background information. This is the
structure:
1. Stars as individual objects:
The most standard way of injecting stellar light into the model is by putting one or more individual stars in the
model. A star can be placed anywhere, both inside the grid and outside. The main input ﬁle specifying their
location and properties is: stars.inp. The stars can be treated in two different ways, depending on the setting
of the variable istar_sphere that can be set to 0 or 1 in the ﬁle radmc3d.inp ﬁle.
• The default is to treat stars as zero-size point sources. This is the way it is done if (as is the default)
istar_sphere=0. The stars are then treated as point sources in spite of the fact that their radius is
speciﬁed as non-zero in the stars.inp ﬁle. This default mode is the easiest and quickest. For most
purposes it is perfectly ﬁne. Only if you have material very close to a stellar surface it may be important
to treat the ﬁnite size(s) of the star(s).
• If istar_sphere=1 in the radmc3d.inp ﬁle, then all stars are treated as spheres, their radii being
the radii speciﬁed in the stars.inp ﬁle. This mode can be tricky, so please read Section Stars treated
as spheres.
2. Smooth distributions of zillions of stars:
For modeling galaxies or objects of that size scale, it is of course impossible and unnecessary to treat each star
individually. So in addition to the individual stars you can specify spatial distributions of stars, assuming that
the number of stars is so large that there will always be a very large number of them in each cell. Please note
that using this possibility does not exclude the use of individual stars as well. For instance, for a galaxy you
may want to have distributions of unresolved stars, but one single ‘star’ for the active nucleus and perhaps a few
individual ‘stars’ for bright star formation regions or O-star clusters or so. The distribution of stars is described
in Section Distributions of zillions of stars.
3. An external ‘interstellar radiation ﬁeld’:
Often an object is affected not only by the stellar radiation from the stars inside the object itself, but also by the
diffuse radiation from the many near and far stars surrounding the object. This ‘Interstellar Radiation Field’ can
be treated by RADMC-3D as well. This is called the ‘external source’ in RADMC-3D. It is described in Section
The interstellar radiation ﬁeld: external source of energy.
117

radmc3d, Release 2.0
10.1 Stars treated as point sources
By default the stars are treated as point-sources. Even if the radius is speciﬁed as non-zero in the stars.inp ﬁle,
they are still treated as points. The reason for this is that it is much easier and faster for the code to treat them as
point-sources. Point sources cannot occult anything in the background, and nothing can partly occult them (they are
only fully or not occulted, of course modulo optical depth of the occulting object). This approximation is, however,
not valid if the spatial scales you are interested in are not much larger (or even the same or smaller) than the size of the
star. For instance, if we are interested in modeling the radiative transfer in a disk around a Brown Dwarf, where dust
can survive perhaps even all the way down to the stellar surface, we must take the non-point-like geometry of the star
into account. This is because due to its size, the star can shine down onto the disk, which would not be possible if the
star is treated as a point source. However, for a dust disk arounda Herbig Ae star, where the dust evaporation radius is
at about 0.5 AU, the star can be treated as a point-source without problems.
So if you just use RADMC-3D as-is, or if you explicitly set istar_sphere=0 in the ﬁle radmc3d.inp, then the
stars are all treated as point sources.
10.2 Stars treated as spheres
For problems in which the ﬁnite geometrical size of the star (or stars) is/are important, RADMC-3D has a mode by
which the stars are treated as spheres. This can be necessary for instance if you model a disk around a Brown Dwarf,
where the dusty disk goes all the way down to the stellar surface. The ﬁnite size of the star can thus shine down onto
the disk, but only if its ﬁnite size is treated as such. In the default point-source approximation the surface layers of
such a disk would be too cold, because this ‘shining down onto the disk’ phenomenon is not treated.
You can switch this mode on by setting istar_sphere=1 in the ﬁle radmc3d.inp. Note that no limb darkening
or brightening is included in this mode, and currently RADMC-3D does not have such a mode available.
This mode is, however, somewhat complex. A sphere can partly overlap the grid, while being partly outside the grid.
A sphere can also overlap multiple cells at the same time, engulﬁng some cells entirely, while only partly overlapping
others. The correct and fast treatment of this makes the code a bit slower, and required some complex programming.
So the user is at the moment advised to use this mode only if necessary and remain aware of possible errors for now
(as of version 0.17).
For the Monte Carlo simulations the ﬁnite star size means that photon packages are emitted from the surface of the
sphere of the star. It also means that any photon that re-enters the star during the Monte Carlo simulation is assumed
to be lost.
10.3 Distributions of zillions of stars
For models of galaxies it is important to be able to have distributed stellar sources instead of individual stars. The way
to implement this in a model for RADMC-3D is to
1. Prepare one or more template stellar spectra, for instance, one for each stellar type you wish to include.
These must be speciﬁed in the ﬁle stellarsrc_templates.inp (see Section INPUT (optional): stel-
larsrc_templates.inp). Of course the more templates you have, the more memory consuming it becomes, which
is of particular concern for models on large grids. You can of course also take a sum of various stellar types as
a template. For instance, if we wish to include a ‘typical’ bulge stellar component, then you do not need to treat
each stellar type of bulge stars separately. You can take the ‘average spectrum per gram of average star’ as the
template and thus save memory.
2. For each template you must specify the spatial distribution, i.e. how many stars of each template star are there
per unit volume in each cell. The stellar density is, in fact, given as gram-of-star/cm3 (i.e. not as number density
118
Chapter 10. More information about the treatment of stars

radmc3d, Release 2.0
of stars). The stellar spatial densities are speciﬁed in the ﬁle stellarsrc_density.inp (see Section
INPUT (optional): stellarsrc_density.inp).
Note that if you have a ﬁle stellarsrc_templates.inp in your model directly, then the stellar sources are
automatically switched on. If you do not want to use them, then you must delete this ﬁle.
The smooth stellar source distributions are nothing else than source functions for the radiative transfer with the spectral
shape of the template stellar spectra from the stellarsrc_templates.inp. You will see that if you make
a spectrum of your object, then even if the dust temperature etc is zero everywhere, you still see a spectrum: that
of the stellar template(s). In the Monte Carlo simulations these stellar templates act as net sources of photons, that
subsequently move through the grid in a Monte Carlo way.
Note that the smooth stellar source distributions assume that the zillions of stars that they represent are so small that
they do not absorb any appreciable amount of radiation. They are therefore pure sources, not sinks.
10.4 The interstellar radiation ﬁeld: external source of energy
You can include an isotropic interstellar radiation ﬁeld in RADMC-3D. This will take effect both in the making of
spectra and images, as well as in the Monte Carlo module.
The way to activate this is to make a ﬁle external_source.inp and ﬁll it with the information needed (see
Section INPUT (optional): external_source.inp).
10.4.1 Role of the external radiation ﬁeld in Monte Carlo simulations
For the Monte Carlo simulations this means that photons may be launched from outside inward. The way that this
is done is that RADMC-3D will make a sphere around the entire grid, just large enough to ﬁt in the entire grid but
not larger. Photon packages can freely leave this sphere. But if necessary, photon packages can be launched from
this sphere inward. RADMC-3D will then calculate the total luminosity of this sphere, which is 𝐿= 4𝜋2𝐼𝑟2
sphere
where 𝐼is the intensity. For monochromatic Monte Carlo it is simply 𝐼= 𝐼𝜈, while for the thermal Monte Carlo it
is 𝐼=
∫︀∞
0
𝐼𝜈𝑑𝜈, where 𝐼𝜈is the intensity as speciﬁed in the ﬁle external_source.inp. Note that if the sphere
would have been taken larger, then the luminosity of the external radiation ﬁeld would increase. This may seem anti-
intuitive. The trick, however, is that if the sphere is larger, then also more of these interstellar photons never enter the
grid and are lost immediately. That is why it is so important that RADMC-3D makes the sphere as small as possible,
so that it limits the number of lost photon packages. It also means that you, the user, would make the grid much larger
than the object you are interested in, then RADMC-3D is forced to make a large sphere, and thus potentially many
photons will get lost: they may enter the outer parts of the grid, but there they will not get absorbed, nor will they do
much.
In fact, this is a potential difﬁculty of the use of the external sources: since the photon packages are lauchned from
outside-inward, it may happen that only few of them will enter in the regions of the model that you, the user, are
interested in. For instance, you are modeling a 3-D molecular cloud complex with a few dense cold starless cores.
Suppose that no stellar sources exist in this model, only the interstellar radiation ﬁeld. The temperature in the centers of
these starless cores will be determined by the interstellar radiation ﬁeld. But since the cores are very small compared
to the total model (e.g. you have used AMR to reﬁne the grid around/in these cores), the chance of each external
photon package to ‘hit’ the starless core is small. It means that the larger the grid or the smaller the starless core, the
more photon packages (nphot, see Section The thermal Monte Carlo simulation: computing the dust temperature)
one must use to make sure that at least some of them enter the starless cores. If you choose phot too small in this
case, then the temperature in these cores would remain undetermined (i.e. they will be zero in the results).
10.4. The interstellar radiation ﬁeld: external source of energy
119

radmc3d, Release 2.0
10.4.2 Role of the external radiation ﬁeld in images and spectra
The interstellar radiation ﬁeld also affects the images and spectra that you make. Every ray will start at minus-inﬁnity
with the intensity given by the external radiation ﬁeld, instead of 0 as it would be if no external radiation ﬁeld is
speciﬁed. If you make an image, the background of your object will then therefore not be black. You can even make
silhouette images like those of the famous silhouette disks in Orion.
But there is a danger: if you make spectra, then also the background radiation is inside the beam, and will thus
contribute to the spectrum. In fact, the larger you make the beam the more you will pick up of the background. This
could thus lead to the spectrum of your source to be swamped by the background if you do not specify a beam in the
spectrum.
10.5 Internal heat source
Sometimes the gas and dust inside the object of interest gets heated up by some internal process such as friction,
magnetic reconnection, chemical reactions, etc. A nice example is the ‘viscous heating’ inside an accretion disk.
This net heat source can be included in RADMC-3D by creating a ﬁle heatsource.inp. The format of the ﬁle is
described in Section INPUT (optional): heatsource.inp. It is the same as for other scalar ﬁelds.
With this input ﬁle you have to specify in each cell how much energy per second per cubic centimeter is released in the
form of heat. This energy will then be emitted as radiation by the dust. The way the code does this in the Bjorkman
& Wood algorithm is that it will launch photon packages from these cells. The difference with the stellar energy input
(see Section Distributions of zillions of stars) is that the energy is ﬁrst injected into the dust of the cell, and then
emitted as thermal dust emission. The launching of the photon package is therefore always a thermal dust emission. In
contrast, in the stellar energy input method of Section Distributions of zillions of stars the photon package is launched
directly, with a wavelength randomly drawn from the local stellar spectrum shape. The difference between these two
methods will be most apparent for optically thin models. For very optically thick cases, where the heat source is
released deep inside an optically thick object, both methods will presumably yield the same result. Nevertheless, it is
recommended to use the heat source method for cases such as chemical or viscous heating of the gas and dust, even
for optically thick cases.
A note of caution: in spite of the fact that this heat source method allows you to add additional energy sources,
the object of study must still be in local thermodynamic equilibrium (LTE). If the gas+dust mixture is ﬂowing and
experiences signiﬁcant adiabatic heating and cooling events, then the LTE condition is no longer met and RADMC-
3D will not be able to give reliable answers. Sometimes one may be able to fudge this in some clever way, but one
should always be aware that strictly speaking the Bjorkman & Wood Monte Carlo method only works if in each cell all
energy input (be it radiative absorption or an internal heat source) is balanced exactly by the same amount of radiative
energy output. The algorithm computes the dust temperature on that assumption: it computes how much energy the
cell gains (by the heat source or by absorbing photons) and then it requires that the temperature of the dust is such that
precisely the same amount of radiative energy is emitted.
10.5.1 Slow performance of RADMC-3D with heat source
For very optically thick models, such as the inner regions of actively accreting dusty protoplanetary disks, the use of
this heat source can lead to extremely slow performance. The reason is that all photons originating from this heat
source will start their journey right in the middle of the most optically thick regions, requiring these photons to make
gazillions of absorption/re-emission events before ﬁnally diffusing out. It should in principle work if the code runs
long enough. But one must have some patience. The use of the Modiﬁed Random Walk method (see Section Modiﬁed
Random Walk method for high optical depths) would then be useful to speed things up, but still it can take time.
A few things might be useful to consider. One is that protoplanetary disks only have such insane optical depths
(𝜏≳105) if none of the dust has coagulated to bigger grains. This might be the correct assumption, especially in
the very early phases of protoplanetary disk evolution. But dust coagulation is known to be quick, so it might equally
120
Chapter 10. More information about the treatment of stars

radmc3d, Release 2.0
well be that, say, 90% of the small grain dust has already grown to larger grains, which have less opacity. This is of
course just a pure guess. Another thing is that many MHD models of disk turbulence show that most of the energy is
not released near the midplane, but instead at one or two scale heights above the midplane. Both considerations would
lower the optical depth for the energy to get out of the disk, speeding up the calculation. And the outcoming spectrum
or image it will presumably not be affected that much, because at the end of the day the effective temperature of the
disk surface must anyway be such that it radiates away the internal heat, independent of how deep inside the disk this
heat is released.
10.5. Internal heat source
121

radmc3d, Release 2.0
122
Chapter 10. More information about the treatment of stars

CHAPTER
ELEVEN
MODIFYING RADMC-3D: INTERNAL SETUP AND USER-SPECIFIED
RADIATIVE PROCESSES
It has been mentioned several times before that as an alternative to the standard compile once-and-for-all’ philosophy,
one can also use RADMC-3D by modifying the code directly so that ``radmc3d` will have new functionality that might
be of use for you. We refer to Section Making special-purpose modiﬁed versions of RADMC-3D (optional) for an
in-depth description of how to modify the code in a way that is non-invasive to the main code. We urge the reader to
read Section Making special-purpose modiﬁed versions of RADMC-3D (optional) ﬁrst before continuing to read this
chapter. In all of the following we assume that the editings to the fortran ﬁles are done in the local way described
in Section Making special-purpose modiﬁed versions of RADMC-3D (optional) so that the original source ﬁles in the
src/ directory stay unaffected, and only local copies are edited.
11.1 Setting up a model inside of RADMC-3D
The most common reason for editing the code itself is for setting up the model internally rather than reading in all
data via input ﬁles. For a list of advantages and disadvantages of setting models up internally as opposed to the
standard way, see Section Some caveats and advantages of internal model setup below. Setting up a model within
RADMC-3D is done by making a local copy of the ﬁle userdef_module.f90 and editing it (see Section Making
special-purpose modiﬁed versions of RADMC-3D (optional)). This ﬁle contains a set of standard subroutines that
are called by the main program at special points in the code. Each subroutine has a special purpose which will be
described below. By keeping a subroutine empty, nothing is done. By ﬁlling it with your own code lines, you can set
up the density, temperature or whatever needs to be set up for the model. In addition to this you can do the following
as well:
• Add new variables or arrays in the module header (above the contains command), which you can use in the
subroutines of the userdef_module.f90 module. You are completely free to add any new variables you
like. A small tip: it may be useful (though not required) to start all their names with e.g. userdef_ to make
sure that no name conﬂicts with other variables in the code happen.
• Add new subroutines at will (below the contains command) which you can call from within the standard
subroutines.
• Introduce your own radmc3d command-line options (see Section The pre-deﬁned subroutines of the
userdef_module.f90).
• Introduce your own radmc3d.inp namelist variables (see Section The pre-deﬁned subroutines of the
userdef_module.f90).
Often you still want some of the input data to be still read in in the usual way, using input ﬁles. For instance, you may
want to still read the dustopac.inp and the opacities using the dustkappa_xxx.inp ﬁles. This is all possible.
Typically, you simply keep the ﬁles you still want RADMC-3D to read, and omit the ﬁles that contain data that you
allocate and set in the userdef_module.f90. This is all a bit complicated, so the best way to learn how to do this
is to start from the example directories in which a model is set up with the userdef_module.f90 method.
123

radmc3d, Release 2.0
Input data files. Only the
data not set by userdef.
Optionally (radmc3d.inp)
also parameters of your
user-defined model.
***.inp or ***.binp
RADMC-3D
radtrans calculation
Output data files, in two 
possible data formats:
***.out (ascii), or
***.bout (binary)
userdef_module.f90
internal model setup
Fig. 11.1: Pictographic representation of the dataﬂow for the case when you deﬁne your model internally using the
userdef_module.f90.
In Fig. Fig. 11.1 the dataﬂow for the user-deﬁned model setup is graphically depicted.
11.2 The pre-deﬁned subroutines of the userdef_module.f90
The idea of the userdef_module.f90 is that it contains a number of standard pre-deﬁned subroutines that are
called from the main.f90 code (and only from there). Just browse through the main.f90 ﬁle and search for the
sequence calluserdef_ and you will ﬁnd all the points where these standard routines are called. It means that at
these points you as the user have inﬂuence on the process of model setup. Here is the list of standard routines and how
they are used. They are ordered roughly in chronological order in which they are called.
• userdef_defaults()
This subroutine allows you to set the default value of any new parameters you may have introduced. If neither
on the command line nor in the radmc3d.inp ﬁle the values of these parameters are set, then they will simply
retain this default value.
• userdef_commandline(buffer,numarg,iarg,fromstdi,gotit)
This subroutine allows you to add your own command-line options for radmc3d. The routine has a series
of standard arguments which you are not allowed to change. The buffer is a string containing the current
command line option that is parsed. You will check here if it is an option of your module, and if yes, activate it.
An example is listed in the code. You an also require a second argument, for which also an example is listed in
the original code.
• userdef_commandline_postprocessing()
After the command line options have been read, it can be useful to check if the user has not asked for conﬂicting
things. Here you can do such checks.
• userdef_parse_main_namelist()
Here you can add your own namelist parameters that read from the radmc3d.inp ﬁle. An example is provided
in the original code.
• userdef_main_namelist_postprocessing()
Also here, after the entire radmc3d.inp ﬁle has been read and interpreted, you can do some consistency
checks and postprocessing here.
• userdef_prep_model()
This routine can be used if you wish to set up the grid not from input ﬁles but internally. You will have to know
how to deal with the amr_module.f90 module. You can also set your own global frequency grid here. And
ﬁnally, you can set your own stellar sources here. In all cases, if you set these things here (which requires you
to make the proper memory allocations, or in case of the gridding, let the amr_module.f90 do the memory
allocations for you) the further course of radmc3d will skip any of its own settings (it will simply detect if
these arrays are allocated already, and if yes, it will simply not read or allocate them anymore).
124
Chapter 11. Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes

radmc3d, Release 2.0
• userdef_setup_model()
This is the place where you can actually make your own model setup. By the time this subroutine is called, all
your parameters have been read in, as well as all of the other parameters from the original radmc3d code. So
you can now set up the dust density, or the gas velocity or you name it. For all of these things you will have
to allocate the arrays youself (!!!). Once you did this, the rest of the radmc3d code won’t read those data
anymore, because it detects that the corresponding arrays have already been allocated (by you). This allows you
to completely circumvent the reading of any of the following ﬁles by making these data yourself here at this
location:
– amr_grid.inp or in the future the input ﬁles for any of the other griding types.
– dust_density.inp
– dust_temperature.dat
– gas_density.inp
– gas_temperature.inp
– gas_velocity.inp
– microturbulence.inp
– levelpop_XXX.dat
– numberdens_XXX.inp
To learn how to set up a model in this way, we refer you for now to the ioput_module.f90 or
lines_module.f90 and search for the above ﬁle names to see how the arrays are allocated and how the
data are inserted. I apologise for not explaining this in more detail at this point. But examples are or will be
given in the examples/ directory.
• userdef_dostuff()
This routine will be called by the main routine to allow you to do any kind of calculation after the main calcu-
lation (for instance after the monte carlo simulation). This is done within the execution-loop.
• userdef_compute_levelpop()
This is a subroutine that can be called by the camera module for on-the-ﬂy calculation of level populations
according to your own recipe. This may be a bit tricky to use, but I hope to be able to provide some example(s)
in the near future.
• userdef_srcalp()
This subroutine allows you to add any emission/absorption process you want, even fake ones. For instance,
you could use this to create nicely volume-rendered images of your 3-D models with fake opacities, which are
chosen to make the image look nice and/or insight-giving. You can also use this to add physical processes that are
not yet implemented in RADMC-3D. This subroutine allows you full freedom and ﬂexibility to add emissivity
and extinction whereever/however you like. To activate it you must set incl_userdef_srcalp=1 in the
radmc3d.inp ﬁle.
• userdef_writemodel()
This allows the user to dump any stuff to ﬁle that the user computed in this module. You can also use this routine
to write out ﬁles that would have been used normally as input ﬁle (like amr_grid.inp or dust_density.
inp) so that the Python routines can read them if they need. In particular the grid information may be needed
by these external analysis tools. Here is a list of standard subroutines you can call for writing such ﬁles:
– write_grid_file()
– write_dust_density()
– . . .more to come...
11.2. The pre-deﬁned subroutines of the userdef_module.f90
125

radmc3d, Release 2.0
For now this is it, more routines will be included in the future.
Note that the userdef_compute_levelpop() subroutine, in contrast to all the others, is called not from the
main.f90 program but from the camera_module.f90 module. This is why the camera module is the only
module that is higher in compilation ranking than the userdef module (i.e. the userdef module will be compiled before
the camera module). For this reason the userdef module has no access to the variables of the camera module. For the
rest, the userdef module has access to the variables in all other modules.
Note also that not all input data is meant to be generated in this way. The following types of data are still supposed to
be read from ﬁle:
• Dust opacity data
• Molecular fundamental data
Please have a look in the examples/ directory for models which are set up in this internal way.
11.3 Some caveats and advantages of internal model setup
Setting up the models internally has several advantages as well as disadvantages compared to the standard way of
feeding the models into radmc3d via ﬁles. The advantages are, among others:
• You can modify the model parameters in radmc3d.inp and/or in the command line options (depending on
how you allow the user to set these parameters, i.e. in the userdef_parse_main_namelist() routine
and/or in the userdef_commandline() routine. You then do not need to run Python anymore (except for
setting up the basic ﬁles; see examples). Some advantages of this:
– It allows you, for instance, to create a version of the radmc3d code that acts as if it is a special-purpose
model. You can specify model parameters on the command line (rather than going through the cumbersome
Python stuff).
– It is faster: even a large model is built up quickly and does not require a long read from large input ﬁles.
• You can make use of the AMR module routines such as the amr_branch_refine() routine, so you can
adaptively reﬁne the grid while you are setting up the model.
Some of the disadvantages are:
• The model needs to be explicitly written out to ﬁle and read into Python or any other data plotting package
before you can analyze the density structure to test if you’ve done it right. You can explicitly ask ./radmc3d
to call the userdef_writemodel() subroutine (which is supposed to be writing out all essential data; but
that is the user’s responsibility) by typing ./radmc3dwritemodel.
• Same is true for the grid, and this is potentially even more dangerous if not done. You can explicitly ask
./radmc3d to write out the grid ﬁle by typing ./radmc3dwritegridfile. Note that if you call the
write_grid_file() subroutine from within userdef_writemodel(), then you do not have to ex-
plicitly type ./radmc3dwritegridfile as well. Note also that radmc3d will automatically call the
write_grid_file() subroutine when it writes the results of the thermal Monte Carlo computation, if it has
its grid from inside (i.e. it has not read the grid from the ﬁle amr_grid.inp.
• It requires a bit more knowledge of the internal workings of the radmc3d code, as you will need to directly
insert code lines in the userdef_module.f90 ﬁle.
126
Chapter 11. Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes

radmc3d, Release 2.0
11.4 Using the userdef module to compute integrals of 𝐽𝜈
With the monochromatic Monte Carlo computation (see Section Special-purpose feature: Computing the local radia-
tion ﬁeld) we can calculate the mean intensity 𝐽𝜈at every location in the model at a user-deﬁned set of wavelengths.
However, as mentioned before, for large models and large numbers of wavelengths this could easily lead to a data
volume that is larger than what the computer can handle. Since typically the main motivation for computing 𝐽𝜈is to
compute some integral of the the form:
𝑄=
∫︁∞
0
𝐽𝜈𝐾𝜈𝑑𝜈
where 𝐾𝜈is some cross section function or so, it may not be necessary to store the entire function 𝐽as a function of
𝑛𝑢. Instead we would then only by interested in the result of this integral at each spatial location.
So it would be useful to allow the user to do this computation internally. We should start by initializing 𝑄(𝑥, 𝑦, 𝑧) = 0
(or 𝑄(𝑟, 𝜃, 𝜑) = 0 if you use spherical coordinates). Then we call the monochromatic Monte Carlo routine for the
ﬁrst wavelength we want to include, and multiply the resulting mean intensities with an appropriate ∆𝜈and add this
to 𝑄(𝑥, 𝑦, 𝑧). Then we do the monochromatic Monte Carlo for the next wavelength and again add to 𝑄everywhere.
We repeat this until our integral (at every spatial location on the grid) is ﬁnished, and we are done. This saves a huge
amount of memory.
Since
this
is
somewhat
hard
to
explain
in
this
PDF
document,
we
refer
to
the
example
model
run_example_jnu_integral/.
STILL IN PROGRESS.
11.5 Some tips and tricks for programming user-deﬁned subroutines
Apart from the standard subroutines that must be present in the userdef_module.f90 ﬁle (see Section The pre-
deﬁned subroutines of the userdef_module.f90), you are free to add any subroutines or functions that you want, which
you can call from within the predeﬁned subroutines of Section The pre-deﬁned subroutines of the userdef_module.f90.
You are completely free to expand this module as you wish. You can add your own variables, your own arrays, allocate
arrays, etc.
Sometimes
you
may
need
to
know
‘where
you
are’
in
the
grid.
For
instance,
the
subroutine
userdef_compute_levelpop() is called with an argument index. This is the index of the current cell from
within which the subroutine has been called. You can now address, for instance, the dust temperature at this location:
temp = dusttemp(1,index)
(for the case of a single dust species). You may also want to know the coordinates of the center of the cell. For this,
you must ﬁrst get a pointer to the AMR-tree structure of this cell. The pointer b is declared as
type(amr_branch), pointer :: b
Then you can point the pointer to that cell structure
b => amr_index_to_leaf(index)%link
And now you can get the x,y,z-coordinates of the center of the cell:
xc = amr_finegrid_xc(b%ixyzf(1),1,b%level)
yc = amr_finegrid_xc(b%ixyzf(2),2,b%level)
zc = amr_finegrid_xc(b%ixyzf(3),3,b%level)
Or the left and right cell walls:
11.4. Using the userdef module to compute integrals of 𝐽𝜈
127

radmc3d, Release 2.0
xi_l = amr_finegrid_xi(b%ixyzf(1),1,b%level)
yi_l = amr_finegrid_xi(b%ixyzf(2),2,b%level)
zi_l = amr_finegrid_xi(b%ixyzf(3),3,b%level)
xi_r = amr_finegrid_xi(b%ixyzf(1)+1,1,b%level)
yi_r = amr_finegrid_xi(b%ixyzf(2)+1,2,b%level)
zi_r = amr_finegrid_xi(b%ixyzf(3)+1,3,b%level)
11.6 Creating your own emission and absorption processes
RADMC-3D Allows you to add your own physics to the ray-tracing images and spectra.
At every point dur-
ing the ray-tracing process, when it computes the emissivity and extinction coefﬁcients 𝑗𝜈and 𝛼𝜈it calls the
userdef_srcalp() subroutine, giving it the index in which cell we are, the frequencies of the different im-
age channels and the src and alp arrays which are for resp.𝑗𝜈and 𝛼𝜈. You can add any process by
src(:) = src(:) + .....
alp(:) = alp(:) + .....
where . . . . . . is your formula. You can ﬁnd the local variables like density and temperature using the index, e.g.:
rho_g = gasdens(index)
You can be completely free in your choices. If you need some information that is not usually read into RADMC-3D,
you can add read commands in the userdef_setup_model() subroutine, e.g.:
call read_gas_density(1)
See the example directory examples/run_simple_userdefsrc for more ideas.
128
Chapter 11. Modifying RADMC-3D: Internal setup and user-speciﬁed radiative processes

CHAPTER
TWELVE
PYTHON ANALYSIS TOOL SET
While the code RADMC-3D is written in fortran-90, there is an extensive set of tools written in Python that make it
easier for the user to set up models and interpret results. See Section Installing the simple Python analysis tools for
where they are and how they can be properly installed so that they are easy to use.
The RADMC-3D package has two support-libraries:
1. python/tools/simpleread.py
The python/tools/simpleread.py is a set of functions to read the most important data ﬁles used by
RADMC-3D. However, the simpleread.py module is very simple, and does not read all RADMC-3D ﬁles
in all formats. It can therefore only be used for certain (simple) models, and is primarily useful as a didactical
tool.
2. python/radmc3dPy
The radmc3dPy package is a stand-alone Python package, written by Attila Juhasz, meant for the pre- and
post-processing of RADMC-3D ﬁles.
It has its own manual, and has to be installed using e.g.~Python’s
pipinstall method. This is described in the README ﬁle in that package.
12.1 The simpleread.py library
For the most rudimentary analysis of the output (or input) ﬁles of RADMC-3D you can use the simpleread.py
ﬁle, which you can ﬁnd in the python/tools/ directory. If everything has been installed correctly, you should be
able to use it within Python like this:
from radmc3d_tools.simpleread import *
Examples of data ﬁles you can read:
d = read_dustdens()
d = read_dusttemp()
d = read_image()
d = read_spectrum()
d = read_dustkappa()
d = read_gastemp()
d = read_gasvelocity()
d = read_molnumdens('co')
d = read_mollevelpop('co')
Of course each one only if the corresponding ﬁle is present. Note that ‘co’ is just an example molecule. In all these
reading functions, except the ones for images and spectra, the reading function automatically calls:
129

radmc3d, Release 2.0
grid = read_grid()
which reads the information about the spatial grid. This is then put inside the d object like this: d.grid.
Here is an example of how you can plot the data (let us take the examples/run_simple_1/ model, after we ran
radmc3d mctherm and radmc3d image incl 60 phi 30 lambda 1000):
import matplotlib.pyplot as plt
from radmc3d_tools.simpleread import *
import radmc3d_tools.natconst as nc
tm = read_dusttemp()
plt.figure()
plt.plot(tm.grid.x/nc.au,tm.dusttemp[:,16,16])
plt.xlabel('x [au]')
plt.ylabel('T [K]')
im = read_image()
plt.figure()
plt.imshow(im.image[:,:,0],vmax=3e-14)
plt.show()
Important: These reading functions are rather basic. At the moment, no binary ﬁle support is included (though this
may change), no AMR octree grids can be read, and several other limitations. For more sophisticated Python tools,
use the radmc3dPy library.
12.2 The radmc3dPy library
The radmc3dPy library is a sophisticated Python library that you can use for the in-depth analysis of the output
(or input) ﬁles of RADMC-3D. It supports most in/output formats of RADMC-3D, including octree grids, binary ﬁle
formats etc.
The package is stand-alone, and has its own bitbucket repository:
https://bitbucket.org/at_juhasz/radmc3dpy/
But you can ﬁnd a copy of this package also inside the RADMC-3D package, in the directory python/radmc3dPy/
.
The radmc3dPy package has its own manual, so we will not reiterate it here. Instead, please simply open the html
manual in that package with a browser. The entry ﬁle of that manual is the doc/html/index.html. On a Mac you
can simply type opendoc/html/index.html on the command line when you are in the radmc3dPy directory.
To install radmc3dPy please consult the README ﬁle in the radmc3dPy directory.
Once it is installed, you can use radmc3dPy in Python in the following way:
1. Make sure to start Python 3 using {small ipython –matplotlib} if you start Python from the command line. If
you instead use a Jupyter notebook, make sure that as a ﬁrst line you use %matplotlibinline to get the
plots inside the notebook. These are standard Python things, so if you have trouble, ask your python friends or
system manager.
2. Once you are inside Python you can include radmc3dPy using a simple fromradmc3dPyimport*. This
loads a series of radmc3dPy sub-libraries, including analyze, image and several others.
We give here a very concise overview of the radmc3dPy package. Please refer to the above mentioned stand-alone
documentation for more details.
130
Chapter 12. Python analysis tool set

radmc3d, Release 2.0
12.3 Model creation from within radmc3dPy
Several of the example models of the RADMC-3D examples/ directory have been implemented as part of the
radmc3dPy package. This allows you to launch these models straight from within radmc3dPy. But this is merely
optional. You can equally well use the models in the examples/ directory in the RADMC-3D package, and post-
process the results with radmc3dPy.
To use one of the radmc3dPy-internal models, create a directory (e.g. mymodel), go into it, and go into iPython.
Then type fromradmc3dPyimport*. By typing models.getModelNames() you get a list of available mod-
els. Suppose we choose the model ‘ppdisk’, then we would go about like this (for example):
from radmc3dPy import *
analyze.writeDefaultParfile('ppdisk')
setup.problemSetupDust('ppdisk', mdisk='1e-5*ms', gap_rin='[10.0*au]', gap_rout='[40.
˓→*au]', gap_drfact='[1e-5]', nz='0')
This example will set up a protoplanetary disk model in 2-D (𝑟, 𝜃), with a gap between 10 and 40 au. You can now
run RADMC-3D to compute the dust temperature structure, by calling (on the Linux shell):
radmc3d mctherm
An image can be created with (again on the Lunix shell):
radmc3d image lambda 1000 incl 60
And the image can be displayed (in Python) by
import matplotlib.pyplot as plt
from matplotlib import cm
from radmc3dPy import *
im=image.readImage()
image.plotImage(im,vmax=3e-3,au=True,cmap=cm.gist_heat)
12.4 Diagnostic tools in radmc3dPy
No matter whether you use the radmc3dPy-internal model set, or you create your own model setup, you can use
the extensive tool set inside radmc3dPy to analyze the model itself, and the results of RADMC-3D calculations. In
everything below, we assume that you use fromradmc3dPyimport* beforehand.
12.4.1 Read the amr_grid.inp ﬁle
Use grid=analyze.readGrid() to read the information about the spatial and wavelength grid.
12.3. Model creation from within radmc3dPy
131

radmc3d, Release 2.0
12.4.2 Read all the spatial data
Using data=analyze.readData() you read the entire spatial structure of the model: The dust density, dust
temperature, velocity etc.
12.4.3 Read the image.out ﬁle
Using im=image.readImage() you read the image.out ﬁle created by RADMC-3D (if you call radmc3d for
creating an image). You can use the image.plotImage() function to display the image with the proper axes and
color bar.
12.4.4 Read the spectrum.out ﬁle
Any spectrum you create (a ﬁle called spectrum.out can be read using s=analyze.readSpectrum().
132
Chapter 12. Python analysis tool set

CHAPTER
THIRTEEN
ANALYSIS TOOLS INSIDE OF RADMC3D
There are also some special purpose features in the Fortran-90 radmc3d code that can be useful for analyzing complex
AMR-gridded models.
13.1 Making a regularly-spaced datacube (‘subbox’) of AMR-based
models
Because handling AMR-based models in Python or other data analysis packages can be rather cumbersome, we de-
cided that it would be useful to create the possibility in radmc3d to generate 1-D, 2-D or 3-D regularly spaced
‘cut-outs’ or ‘sub-boxes’ (whatever you want to call them) of any variable of the model.
13.1.1 Creating and reading a subbox
You can call radmc3d directly from the shell asking it to make the subbox. Here is an example:
./radmc3d subbox_dust_temperature subbox_nxyz 64 64 64 subbox_xyz01 -2.d15 2.d15 -2.
˓→d15 2.d15 -2.d15 2.d15
An example for the level populations would be:
./radmc3d subbox_levelpop subbox_nxyz 64 64 64 subbox_xyz01 -2.d15 2.d15 -2.d15 2.d15
˓→-2.d15 2.d15
Note about subbox for level populations: By default all level populations will be written out. However, if you would
add the subbox_levelpop keyword in a call to RADMC-3D for making an image or spectrum, then it will only
write out the level populations that have been used for that image. Example:
./radmc3d image lambda 2600 subbox_levelpop subbox_nxyz 64 64 64 subbox_xyz01 -2.d15
˓→2.d15 -2.d15 2.d15 -2.d15 2.d15
would give a much smaller 'levelpop_co_subbox.out' ﬁle, because only the ﬁrst two levels are included
(remember that 𝜆= 2600 𝜇for more information on how RADMC-3D automatically selects a subset of levels for
storage in the global array (and thus also for writing out to ﬁle).
133

radmc3d, Release 2.0
13.1.2 Format of the subbox output ﬁles
All the ﬁles produced by the subbox method have the following format:
iformat
<=== Typically 2 at present
nx ny nz nv
<=== Box of nx*ny*nz cells, each with nv
˓→values
x0 x1 y0 y1 z0 z1
<=== The x, y and z boundaries of the box
phi1 theta phi2
<=== Three rotation angles of the box
<=== Empty line
1 2 3 4 ....
<=== Identifications of the nv values
<=== Empty line
data[ix=1,iy=1,iz=1,iv=1]
data[ix=2,iy=1,iz=1,iv=1]
.
.
data[ix=nx,iy=1,iz=1,iv=1]
data[ix=1,iy=2,iz=1,iv=1]
.
.
.
data[ix=nx,iy=ny,iz=nz,iv=1]
<=== Empty line between components
data[ix=1,iy=1,iz=1,iv=2]
.
.
data[ix=nx,iy=ny,iz=nz,iv=2]
<=== Empty line between components
.
.
.
<=== Empty line between components
data[ix=1,iy=1,iz=1,iv=nv]
.
.
data[ix=nx,iy=ny,iz=nz,iv=nv]
and they are always in ascii format. For a subbox of the level populations the identiﬁcation numbers are the levels.
For instance, if only the populations of levels 4 and 8 are in this ﬁle, then nv=2 and the line with the identiﬁcation
numbers will be 48. For all other quantities (dust density, dust temperature) this line of identiﬁcation numbers is
simply 123 etc.
13.2 Alternative to subbox: arbitrary sampling of AMR-based models
For some purposes it is useful to sample values of various quantities at arbitrary positions in the grid. The idea is very
much like the subbox method of Section Making a regularly-spaced datacube (‘subbox’) of AMR-based models, but
instead of a regular subbox grid the user provides a list of 3-D points where he/she wants to sample the variables of
the model. Here is how to do this. First you must produce a ﬁle containing the list of 3-D positions. The ﬁle is called
sample_points.inp and is an ascii ﬁle that looks as follows:
iformat
<=== Typically 1 at present
npt
<=== Nr of 3-D sampling points
xpt[1]
ypt[1]
zpt[1]
<=== 3-D coordinates of point 1
xpt[2]
ypt[2]
zpt[2]
<=== 3-D coordinates of point 2
xpt[3]
ypt[3]
zpt[3]
<=== 3-D coordinates of point 3
(continues on next page)
134
Chapter 13. Analysis tools inside of radmc3d

radmc3d, Release 2.0
(continued from previous page)
...
...
An example for the case in which you want to sample at just one point:
1
1
1.49d13
4.02d14
1.03d12
If you want to let RADMC-3D do the sampling of the dust density and temperature, type (after you have calculated
the temperature using radmc3dmctherm):
radmc3d sample-dustdens sample-dusttemp
You can also do the dust temperature calculation and the sampling in one go:
radmc3d mctherm sample-dustdens sample-dusttemp
You can also do only sample-dusttemp or only sample-dustdens.
The output is written to ﬁles
dust_density_sample.out resp.dust_temperature_sample.out. The format of these ﬁles is (take
dust density as example):
iformat
<=== Typically 2 at present
npt
nv
<=== Nr of point and size of datavector
<=== Empty line
1 2 3 4 ....
<=== Identifications of the nv values
<=== Empty line
dustdensity[ipt=1,iv=1]
dustdensity[ipt=2,iv=1]
...
dustdensity[ipt=npt,iv=1]
<=== Empty line between components
dustdensity[ipt=1,iv=2]
...
dustdensity[ipt=npt,iv=2]
<=== Empty line between components
...
<=== Empty line between components
dustdensity[ipt=npt,iv=nv]
where nv is in this case the nr of species of dust and iv=``ispecies``.
For a sample of the level populations the identiﬁcation numbers are the levels. For instance, if only the populations
of levels 4 and 8 are in this ﬁle, then nv=2 and the line with the identiﬁcation numbers will be 48. For all other
quantities (dust density, dust temperature) this line of identiﬁcation numbers is simply 123 etc.
Later we will add other possible arrays to sample (at the moment it is only dust density, dust temperature and level
populations). But you can also implement this yourself. Search in the following ﬁles for the following parts to add
your own sampling:
• In rtglobal_module.f90:
Search for do_sample_dustdens and add your own variable, e.g.
o_sample_myvariable.
• In main.f90: Search for do_sample_dustdens and you will ﬁnd all places where you have to add your
own stuff, i.e. where you will have to add statements like if(do_sample_myvariable) or where you
have to set do_sample_myvariable=.true. or reset do_sample_myvariable=.false. etc.
That should do it.
13.2. Alternative to subbox: arbitrary sampling of AMR-based models
135

radmc3d, Release 2.0
136
Chapter 13. Analysis tools inside of radmc3d

CHAPTER
FOURTEEN
VISUALIZATION WITH VTK TOOLS (E.G. PARAVIEW OR VISIT)
Since 3-D models can be very hard to visualize, and since RADMC-3D is not made for quick rendering, it can be very
useful to make use of a number of freely available 3-D rendering tools, for example:
• Paraview www.paraview.org
• VisIt visit.llnl.gov
RADMC-3D can create data ﬁles for use with these tools. The ﬁle format is VTK (Visual Tool Kit), which is a simple
ascii ﬁle format which is used by various programs. Those tools are not only useful for visualizing the 3-D structure
of the model, but also for visualizing the structure of the grid which can be, when using AMR, rather complex.
The ﬁle that RADMC-3D writes is called model.vtk. You should be able to open it directly from within e.g.
paraview. Figures Fig. 14.1 and Fig. 14.2 gives an example of how you can analyze a complex geometry with AMR
reﬁnement with Paraview. The ﬁle {em always} includes the information about the grid. In addition you can also
make RADMC-3D add scalar ﬁelds or vector ﬁelds.
To create a VTK ﬁle for viewing the grid only, type:
radmc3d vtk_grid
To create a VTK ﬁle for viewing the gas density (this ﬁle then also includes the grid of course) type:
radmc3d vtk_gas_density
Since density can span a huge range, the 10-log of the density (in units of gram/cm3) is written instead. For the gas
temperature:
radmc3d vtk_gas_temperature
which is written in Kelvin (and linearly, not log). For the dust density of dust species 1:
radmc3d vtk_dust_density 1
and for dust species 2:
radmc3d vtk_dust_density 2
Also these densities are 10-log. RADMC-3D typically computes the dust temperature using a Monte Carlo approach.
By typing
radmc3d vtk_dust_temperature 1
RADMC-3D will try to read the dust temperature from the ﬁle dust_temperature.dat (if this ﬁle has been
created earlier by a radmc3d mctherm call) and then create the VTK ﬁle. You can also let RADMC-3D compute
the temperature directly and write it out to VTK right afterward:
137

radmc3d, Release 2.0
radmc3d mctherm vtk_dust_temperature 1
If you are doing line transfer you may wish to visualize the number density of the molecules (or atoms):
radmc3d vtk_molspec 1
(for molecular species 1). This number density (in cm−3) is also written in 10-log form. You may also wish to
visualize the polulations of level 1 (ground state) of molecule 2:
radmc3d vtk_levelpop 2 1
The gas velocity ﬁeld can be written to VTK ﬁle by
radmc3d vtk_velocity
This is a vector ﬁeld.
Note: The VTK mode works for 3-D cartesian and 3-D spherical coordinates (thanks, Attila Juhasz, for the 3-D
spherical mode!).
Fig. 14.1: Example of image created with Paraview, using the VTK output of RADMC-3D. The model shown here is
a warped disk model by Katherine Rosenfeld, in 3-D cartesian coordinates with oct-tree AMR reﬁnement.
138
Chapter 14. Visualization with VTK tools (e.g. Paraview or VisIt)

radmc3d, Release 2.0
Fig. 14.2: Example of image created with Paraview, using the VTK output of RADMC-3D. The model shown here
is a warped disk model by Attila Juhasz, in 3-D spherical coordinates with separable reﬁnement, but without AMR
reﬁnement. The model is kept low-resolution on purpose, to show the grid structure better.
139

radmc3d, Release 2.0
140
Chapter 14. Visualization with VTK tools (e.g. Paraview or VisIt)

CHAPTER
FIFTEEN
TIPS, TRICKS AND PROBLEM HUNTING
15.1 Tips and tricks
RADMC-3D is a large software package, and the user will in all likelihood not understand all its internal workings. In
this section we will discuss some issues that might be useful to know when you do modeling.
• Things that can drastically slow down ray-tracing:
When you create images or spectra, radmc3d will perform a ray-tracing calculation. You may notice that
sometimes this can be very fast, but for other problems it can be very slow. This is because, depending on
which physics is switched on, different ray-tracing strategies must be followed. For instance, if you use a dust
opacity without scattering opacity (or if you switch dust scattering off by setting scattering_mode_max to
0 in the radmc3d.inp ﬁle), and you make dust continuum images, or make SEDs, this may go very rapidly:
less than a minute on a modern computer for grids of 256x256x256. However, when you include scattering,
it may go slower. Why is that? That is because at each wavelength radmc3d will now have to make a quick
Monte Carlo scattering model to compute the dust scattering source function. This costs time. And it will cost
more time if you have nphot_scat set to a high value in the radmc3d.inp ﬁle, although it will create
better images. Furthermore, if you also include gas lines using the simple LTE or simple LVG methods, then
things become even slower, because each wavelength channel image is done after each other, and each time
all the populations of the molecular levels have to be re-computed. If dust scattering would be switched off
(which is for some wavelength domains presumably not a bad approximation; in particular for the millimeter
domain), then no scattering Monte Carlo runs have to be done for each wavelength. Then the code can ray-
trace all wavelength simultaneously: each ray is traced only once, for all wavelength simultaneously. Then the
LTE/LVG level populations have to be computed only once at each location along the ray. So if you use dust
and lines simultaneously, it can be advantageous for speed if you can afford to switch off the dust scattering,
for instance, if you model sub-millimeter lines in regions with dust grains smaller than 10 micron or so. If you
must include scattering, but your model is not so big that you may get memory limitation problems, then you
may also try the fast LTE or fast LVG modes: in those modes the level populations are pre-computed before the
ray-tracing starts, which saves time. But that may require much memory.
15.2 Bug hunting
Although we of course hope that radmc3d will not run into troubles or crash, it is nevertheless possible that it will.
There are several ways by which one can hunt for bugs, and we list here a few obvious ones:
• In principle the Makefile should make sure that all dependencies of all modules are correct, so that the most
dependent modules are compiled last. But during the further development of the code perhaps this may be not
100% guaranteed. So try do makeclean followed by make (or makeinstall) to assure a clean make.
• In the Makefile you can add (or uncomment) the line BCHECK=-fbounds-check, if you use gfortran.
Find the array boundary check switch on your own compiler if it is not gfortran.
141

radmc3d, Release 2.0
• Make sure that in the main.f90 code the variable debug_check_all is set to 1. This will do some on-the-
ﬂy checks in the code.
15.3 Some tips for avoiding troubles and for making good models
Here is a set of tips that we recommend you to follow, in order to avoid troubles with the code and to make sure that
the models you make are OK. This list is far from complete! It will be updated as we continue to develop the code.
1. Make a separate directory for each model. This avoids confusion with the many input and output ﬁles from the
models.
2. When experimenting: regularly keep models that work, and continue experimenting with a fresh model direc-
tory. If things go wrong later, you can always fall back on an older model that did work well.
3. Keep model directories within a parent directory of the code, just like it is currently organized. This ensures that
each model is always associated to the version of the code for which it was developed. If you update to a new
version of the code, it is recommended to simply copy the models you want to continue with to the new code
directory (and edit the SRC variable in the Makefile if you use the techniques described in Section Making
special-purpose modiﬁed versions of RADMC-3D (optional) and Chapter Modifying RADMC-3D: Internal setup
and user-speciﬁed radiative processes).
4. If you make a new model, try to start with as clean a directory as possible. This avoids that you accidently have a
old ﬁles hanging around, their presence of which may cause troubles in your new model. So if you make a model
update, make a new directory and then copy only the ﬁles that are necesary (for instance, problem_setup.
py, dustkappa_silicate.inp, Makefile and other necessary ﬁles). One way of doing this easily is to
write a little perl script or csh script that does this for you.
5. In the example model directories there is always a Makefile present, even if no local *.f90 ﬁles are present.
The idea is that by typing {small make cleanall} you can safely clean up the model directory and restore it to
pre-model status. This can be useful for safely cleaning model directories so that only the model setup ﬁles
remain there. It may save enormous amounts of disk space. But of course, it means that if you revisit the model
later, you would need to redo the Monte Carlo simulations again, for instance. It is a matter of choice between
speed of access to results on the one hand and disk space on the other hand.
6. If you use LVG or escape probability to compute the level populations of molecules, please be aware that you
must include all levels that could be populated, not only the levels belonging to the line you are interested in.
15.4 Careful: Things that might go wrong
In principle RADMC-3D should be ﬁne-tuned such that it produced reliable results in most circumstances. But radia-
tive transfer modeling, like all kinds of modeling, is not an entirely trivial issue. Extreme circumstances can lead to
wrong results, if the user is not careful in doing various sanity checks. This section gives some tips that you, the user,
may wish to do to check that the results are ok. This is not an exhaustive list! So please remain creative yourself in
coming up with good tests and checks.
1. Too low number of photon packages for thermal Monte Carlo
If the number of photon packages for the thermal Monte Carlo simulation (Section The thermal Monte Carlo
simulation: computing the dust temperature) is too low, the dust temperatures are going to be very noisy. Some
cells may even have temperature zero. This may not only lead to noisy images and spectra, but also simply
wrong results. However, deep inside optically thick clouds (or protoplanetary disks) it will be hard to avoid this
problem. Since those regions are very deep below the 𝜏= 1 surface, it might not be always too critical in that
case. A bit of experimenting might be necessary.
142
Chapter 15. Tips, tricks and problem hunting

radmc3d, Release 2.0
2. Too low number of photon packages for scattering
When making images or spectra in which dust scattering is important, the scattered light emissivity is computed
by a quick Monte Carlo simulation before the ray-tracing (see Section Scattered light in images and spectra:
The ‘Scattering Monte Carlo’ computation). This requires the setting of the number of photon packages used
for this (the variable nphot_scat for images and equivalently nphot_spec for spectra, both can be set in
the radmc3d.inp ﬁle). If you see too much ‘noise’ in your scattering image, you can improve this by setting
nphot_scat to a larger value (default = 100000). If your spectrum contains too much noise, try setting
nphot_spec to a larger value (default = 10000).
3. Too optically thick cells at the surface or inner edge
You may want to experiment with grid resolution and reﬁnement. Strictly speaking the transition from optically
thin to optically thick, as seen both by the radiation entering the object and by the observer, has to occur over
more than one cell. That is for very optically thick models, one may need to introduce grid reﬁnement in various
regions. As an example: an optically thick protoplanetary disk may have an extremely sharp thin-thick transition
near the inner edge. To get the spectra and images right, it is important that these regions are resolved by the grid
(note: once well inside the optically thick interior, it is no longer necessary to resolve individual optical mean
free paths, thankfully). It should be said that in practice it is often impossible to do this in full strictness. But
you may want to at least experiment a bit with reﬁning the grid (using either ‘separable reﬁnement’, see Section
Separable grid reﬁnement in spherical coordinates (important!), or AMR reﬁnement, see Section Oct-tree-style
AMR grid). An example how wrong things can go at the inner edge of a protoplanetary disk, if the inner cells
are not assured to be optically thin through grid reﬁnement (and possibly additionally a bit of smoothing of the
density proﬁle too) is given in Fig. Fig. 15.1.
Fig. 15.1: Example of what can go wrong with radiative transfer if the inner cells of a model are optically thick (i.e.if
no grid reﬁnement is used, see Section Separable grid reﬁnement in spherical coordinates (important!)). Shown here
are scattered light images at 𝜆= 0.7𝜇Delta R/R=0.04`. Left image: the inner cells are marginally optically thin
∆𝜏≃1, creating a bright inner ring, as is expected. Right image: ten times higher optical depth, making the inner
cells optically thick with roughly ∆𝜏≃10, resulting in a wrong image in which the emission near the midplane is
strongly reduced. The reason for that is that the scattering source function, due to photons scattering at the inner 10%
of the inner cell, is diluted over the entire cell, making the scattered light brighness 10x lower than it should be.
4. Model does not ﬁt onto the grid (or onto the reﬁned part of the grid)
The grid must be large enough to contain the entire 𝜏𝜆= 1 surface of a model at all relevant wavelengths. If you
use grid reﬁnement, the same is true for the 𝜏𝜆= 1 surface being within the reﬁnened part of the grid. This is not
trivial! If you, for instance, import a 3-D hydrodynamic model into RADMC-3D, then it is a common problem
15.4. Careful: Things that might go wrong
143

radmc3d, Release 2.0
that the 𝜏𝜆= 1 surface ‘wants’ to be outside of the grid (or outside of the higher-resolution part of the 𝜃-grid
if you use separable grid reﬁnement: see Fig. ﬁg-spher-sep-ref). For example: if you make a * hydrodynamic*
model of a protoplanetary disk in 𝑅, Θ and Φ coordinates, you typically want to model only the lower 2 pressure
scale heights of the disk, since that contains 99.5% of the mass of the disk. However, for radiative transfer this
may not be enough, since if the disk has an optical depth of 𝜏= 103, the optically thin surface layer is less
than 0.1% of the disk mass, meaning that you need to model the lower 3 (not 2!) pressure scale heights. Simply
inserting the hydrodynamics model with the ﬁrst 2 scale heights would lead to an artiﬁcal cut-off of the disk. In
other words, the real 𝜏𝜆= 1 surface ‘wants’ to be outside of the grid (or outside of the reﬁned part of the grid).
This leads to wrong results.
15.5 Common technical problems and how to ﬁx them
When using a complex code such as RADMC-3D there are many ways you might encounter a problem. Here is a list
of common issues and tips how to ﬁx them.
1. After updating RADMC-3D to a new version, some setups don’t work anymore.
This problem can be due to several things:
• When your model makes a local radmc3d executable (see Section Making special-purpose modiﬁed
versions of RADMC-3D (optional)), for instance when you use the userdef_module.f90 to set up
the model, then you may need to edit the SRC variable in the Makefile again to point to the new code
directory, and type makeclean followed by make.
• Are you sure to have recompiled radmc3d again and installed it (by going in src/ and typing
makeinstall)?
• Try going back to the old version and recheck that the model works well there. If that works, and the above
tricks don’t ﬁx the problem, then it may be a bug. Please contact the author.
2. After updating RADMC-3D to a new version: the new features are not present/working.
Maybe again the Makefile issue above.
3. After updating RADMC-3D to a new version: model based on userdef_module fails to compile
If you switch to a new version of the code and try to ‘make’ an earlier model that uses the userdef_module.f90,
it might sometimes happen that the compilation fails because some subroutine userdef_*** is not known
(here *** is some name). Presumably what happened is that a new user-deﬁned functionality has been added to
the code, and the corresponding subroutine userdef_*** has been added to the userdef_module.f90.
If, however, in your own userdef_module.f90 this subroutine is not yet built in, then the compiler can’t
ﬁnd this subroutine and complains. Solution: just add a dummy subroutine to your userdef_module.f90
with that name (have a look at the userdef_module.f90 in the src/ directory). Then recompile and it
should now work.
4. While reading an input ﬁle, RADMC-3D says ‘Fortran runtime error: End of ﬁle’
This can of course have many reasons. Some common mistakes are:
• In amr_grid.inp you may have speciﬁed the coordinates of the nx*ny*nz grid centers instead of
(nx+1)*(ny+1)*(nz+1) grid cell interfaces.
• You may have no line feed at the end of one of the ascii input ﬁles. Some fortran compilers can read only
lines that are ofﬁcially ended with a return or line feed. Solution: Just write an empty line at the end of
such a ﬁle.
5. My changes to the main code do not take effect
Did you type, in the src/ directory, the full makeinstall? If you type just make, then the code is compiled
but not installed as the default code.
144
Chapter 15. Tips, tricks and problem hunting

radmc3d, Release 2.0
6. My userdef_module.f90 stuff does not work
If you run radmc3d with own userdeﬁned stuff, then you must make sure to run the right executable. Just
typing radmc3d in the shell might cause you to run the standard compilation instead of your special-purpose
one. Try typing ./radmc3d instead, which forces the shell to use the local executable.
7. When I make images from the command line, they take very long
If you make images with radmc3dimage (plus some keywords) from the command line, the default is that
a ﬂux-conserving method of ray-tracing is used, which is called recursive sub-pixeling (see Section The issue
of ﬂux conservation: recursive sub-pixeling). You can make an image without sub-pixeling with the command-
line option nofluxcons. That goes much faster, and also gives nice images, but the ﬂux (the integral over the
entire image) may not be accurate.
8. My line channel maps (images) look bad
If you have a model with non-zero gas velocities, and if these gas velocities have cell-to-cell differences that
are larger than or equal to the intrinsic (thermal+microturbulent) line width, then the ray-tracing will not be able
to pick up signals from intermediate velocities. In other words, because of the discrete gridding of the model,
only discrete velocities are present, which can cause numerical problems. There are two possible solutions
to this problem. One is the wavelength band method described in Section Heads-up: In reality wavelength
are actually wavelength bands. But a more systematic method is the ‘doppler catching’ method described in
Section Preventing doppler jumps: The ‘doppler catching method’ (which can be combined with the wavelength
band method of Section Heads-up: In reality wavelength are actually wavelength bands to make it even more
perfect).
9. My line spectra look somewhat noisy
If you include dust continuum scattering (Section More about scattering of photons off dust grains) then the
ray-tracer will perform a scattering Monte Carlo simulation at each wavelength. If you look at lines where
dust scattering is still a strong source of emission, and if nphot_scat (Section Scattered light in images and
spectra: The ‘Scattering Monte Carlo’ computation) is set to a low value, then the different random walks of
the photon packages in each wavelength channel may cause slightly different resulting ﬂuxes, hence the noise.
10. My dust continuum images look very noisy/streaky: many ‘lines’ in the image
There are two possible reasons:
1. Photon noise in the thermal Monte Carlo run: If you have too few photon packages for the thermal Monte
Carlo computation (see Chapter Dust continuum radiative transfer), then the dust temperatures are simply
not well computed. This may give these effects. You must then increase nphot in the radmc3d.inp
ﬁle to increase the photon statistics for the thermal Monte Carlo run.
2. Photon noise in the scattering Monte Carlo run: If you are making an image at a wavelength at which
the disk is not emitting much thermal radiation, then what you will see in the image is scattered light.
RADMC-3D makes a special Monte Carlo run for scattered light before each image. This Monte Carlo
run has its own variable for setting the number of photon packages: nphot_scat. If this value is set
too low, then you can see individual ‘photon’-trajectories in the image, making the image look bad. It
is important to note that this can only be remedied by increasing nphot_scat (in the radmc3d.inp
ﬁle, see Section Scattered light in images and spectra: The ‘Scattering Monte Carlo’ computation), not
by setting nphot (which is the number of photon packages for the thermal Monte Carlo computation).
Please also read Section Single-scattering vs. multiple-scattering for a detailed discussion about the effects
of multiple scattering and the possibility of it leading to streaks in the images.
However, it might also mean that something is wrong with the setup. A few common setup-errors that could
cause these issues are:
• Accidently created a way too massive object. Let us discuss this with an example of a protoplanetary
disk: suppose you created, in spherical coordinates, not a protoplanetary disk with 𝑀disk = 0.01 𝑀⊙
but accidently one with 𝑀disk = 10 𝑀⊙. In such a case a lot of things will go wrong. First of all the
15.5. Common technical problems and how to ﬁx them
145

radmc3d, Release 2.0
inner edge of the disk will almost certainly behave strangely (see Fig. Example of what can go wrong
with radiative transfer if the inner cells of a model are optically thick (i.e.if no grid reﬁnement is used,
see Section sec-separable-reﬁnement). Shown here are scattered light images at \lambda=0.7\muDelta
R/R=0.04`. Left image: the inner cells are marginally optically thin \Delta\tau\simeq 1, creating a bright
inner ring, as is expected. Right image: ten times higher optical depth, making the inner cells optically
thick with roughly \Delta\tau\simeq 10, resulting in a wrong image in which the emission near the midplane
is strongly reduced. The reason for that is that the scattering source function, due to photons scattering
at the inner 10% of the inner cell, is diluted over the entire cell, making the scattered light brighness 10x
lower than it should be.). Secondly, the surface of the disk will almost certainly be cut-off in the way
decribed in Section Careful: Things that might go wrong, in which case the surface of the disk will be
hardly illuminated by the star, because the disk surface is then exactly conical (i.e.starlight will not be able
to impinge on the surface). This will lead to very low photon statistics at the surface.
146
Chapter 15. Tips, tricks and problem hunting

CHAPTER
SIXTEEN
MAIN INPUT AND OUTPUT FILES OF RADMC-3D
RADMC-3D is written in fortran-90. It is written in such a way that the user prepares input ﬁles (ending in .inp) for
the program and then calls radmc3d with some command-line options. The program then reads the input ﬁles, and
based on the command-line options will perform a certain calculation, and ﬁnally outputs the results to output ﬁles
(ending in .out) or intermediate ﬁles (ending in .dat) which need further processing. In principle the user therefore
needs to compile the program only once, and can then use the executable from that point onward. In this chapter we
will describe the various input/output and intermediate ﬁles and their formats. Just for clarity: the Python routines in
the python/ directory are only meant to make it easier for the user to prepare the .inp ﬁles, and to make sense of
the .out and .dat ﬁles. They are not part of the main code radmc3d.
A few comments on RADMC-3D input and output ﬁles:
• Most (though not all) ﬁles start with a format number. This number simply keeps track of the version of the
way the information is stored the ﬁle. The idea is that if new versions of RADMC-3D come out in the future, it
would be good to have the possibility that new information is added to the ﬁles. The format number is there to
tell RADMC-3D whether a ﬁle is the new version or still an older version.
• RADMC-3D has four types of I/O ﬁles:
1. Files ending with .inp or .binp are input ﬁles that allow the user to specify to RADMC-3D which
problem to solve.
2. Files ending with .dat or .bdatare intermediate ﬁles that are typically created by RADMC-3D itself,
but can also be read by RADMC-3D for further processing. For instance, the dust temperature is computed
by the Monte Carlo method, but can also be read in later for ray-tracing.
3. Files ending with .out or .bout are ﬁnal products of RADMC-3D, such as an image or spectrum.
4. File ending with .info are small ﬁles containing some numbers that are useful to better interpret the
output ﬁles of RADMC-3D. They are typically not very important for every-day use.
• For many of the I/O ﬁles RADMC-3D can read and write formatted (i.e. text style: ascii) ﬁles, or binary ﬁles
(i.e. C-style unformatted). This is speciﬁed by the ﬁle extension. See Chapter Binary I/O ﬁles for more details.
16.1 INPUT: radmc3d.inp
The radmc3d.inp ﬁle is a namelist ﬁle with the main settings for RADMC-3D. The namelist is not a standard
Fortran namelist style, but a simple name = value list. If a name is not speciﬁed, the default values are taken. So if
the radmc3d.inp ﬁle is empty, then all settings are standard. Note that some of these settings can be overwritten by
command-line options! Here is a non-exhaustive list of the variables that can be set.
• incl_dust (default: depends on which input ﬁles are present)
147

radmc3d, Release 2.0
Normally RADMC-3D will recognize automatically whether dust continuum emission, absorption and scatter-
ing must be included: if e.g. a ﬁle called dustopac.inp is present, it assumes that the dust must be included.
But with this ﬂag you can explicitly tell RADMC-3D whether it must be included (1) or not (0).
• incl_lines (default: depends on which input ﬁles are present)
Normally RADMC-3D will recognize automatically whether line emission and absorption must be included: if
e.g. a ﬁle called lines.inp is present, it assumes that molecular/atomic lines must be included. But with this
ﬂag you can explicitly tell RADMC-3D whether it must be included (1) or not (0).
• nphot or nphot_therm (default: 100000)
The number of photon packages used for the thermal Monte Carlo simulation.
• nphot_scat (default: 100000)
The number of photon packages for the scattering Monte Carlo simulations, done before image-rendering.
• nphot_spec (default: 10000)
The number of photon packages for the scattering Monte Carlo simulations, done during spectrum-calculation.
This is actually the same functionality as for nphot_scat, but it is used (and only used) for the spectrum and
SED calculations. The reason to have a separate value for this is that for spectra you may not need as many
photon packages as for imaging, because you anyway integrate over the images. Many of the annoying ‘stripe
noise’ in images when using insufﬁciently large nphot_scat will cancel each other out in the ﬂux calculation.
So nphot_spec is usually taken smaller than nphot_scat.
• nphot_mono (default: 100000)
The number of photon packages for the Monte Carlo simulations for the mcmono calculation (see Section
Special-purpose feature: Computing the local radiation ﬁeld).
• iseed (default: -17933201) [Fine-tuning only]
A starting value of the random seed for the Monte Carlo simulation.
• ifast (default: 0) [Fine-tuning only]
By setting this to 1 or 2 you will get a faster Monte Carlo simulation, at the cost of being less accurate.
• enthres (default: 0.01) [Fine-tuning only]
This is the fraction by which the energy in each cell may increase before the temperature is recalculated in the
Monte Carlo simulation. The smaller this value, the more accurate the thermal Monte Carlo simulation, but the
more computationally costly. 0.01 has proven to be ﬁne.
• itempdecoup (default: 1)
If set to 0, then the temperatures of all coexisting dust species are always forced to be the same. If 1, then each
dust species is thermally independent of the other.
• istar_sphere (default: 0)
If 0 (=default), then all stars are treated as point-sources. If 1, then all stars are treated as ﬁnite-size spheres.
This mode is more accurate and more realistic, but the applications are a bit more restricted. Such ﬁnite-size
stars are (for technical reasons) not always allowed anywhere in the model. But for problems of circumstellar
disks and envelopes in spherical coordinates, it is recommended to set this to 1. Typically, if a star is outside the
grid (in spherical coordinates this can also be at the origin of the coordinate system, as long as the inner radius
of the coordinate system is larger than the stellar radius!) the use of the ﬁnite-size star mode is always possible.
But if the star is on the grid, there are technical limitations.
• ntemp (default: 1000) [Fine-tuning only]
148
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
The temperatures are determined in the Monte Carlo method using tabulated pre-computed integrals. This saves
time. This is the number of temperatures for which this is precalculated. The temperatures are sampled in a
logarithmic way, i.e. log(temp) is linearly equally spaced between log(temp0) and log(temp1), see below.
• temp0 (default: 0.01) [Fine-tuning only]
The lowest pre-calculated temperature.
• temp1 (default: 1e5) [Fine-tuning only]
The highest pre-calculated temperature.
• scattering_mode_max
When radmc3d reads the dust opacity ﬁles it checks if one or more of the opacity ﬁles has scattering opacity
included. If yes, the scattering_mode will automatically be set to 1. It will also check if one or more
includes anisotropic scattering. If yes, the scattering_mode will automatically be set to 2. But the user
may nevertheless want to exclude anisotropic scattering or exclude scattering altogether (for instance for testing
purposes, or if the user knows from experience that the scattering or anisotropic nature of scattering is not
important for the problem at hand). Rather than editing the opacity ﬁles to remove the scattering and/or Henyey-
Greenstein 𝑔-factors, you can limit the value that radmc3d is allowed to make scattering_mode by setting
the variable scattering_mode_max. If you set scattering_mode_max=0 then no matter what opacity
ﬁles you have, scattering will not be treated. If you set scattering_mode_max=1, then no matter what
opacity ﬁles you have, scattering will be treated in an isotropic way.
• unformatted (Obsolete)
• rto_style (default=1)
This determines whether the output of space-dependent data will be in ASCII form (rto_style=1), f77-
unformatted form (rto_style=2, obsolete) or binary form (rto_style=3). See Chapter Binary I/O ﬁles
for details.
• camera_tracemode (default: 1)
If camera_tracemode=-1, the images that are rendered by RADMC-3D will instead by the column depth
traced along each ray. If camera_tracemode=-2, the images that are rendered by RADMC-3D will instead
by the continuum optical depth traced along each ray. By default camera_tracemode=1, which is the normal
mode, where real images are being created.
• camera_nrrefine (default: 100)
For images: to assure that ﬂux is correctly sampled, the image pixels will not just be rendered one ray per pixel.
Instead, if necessary, a pixel will spawn 2x2 sub-pixels recursively (each of which can split again into 2x2 until
the required resolution is obtained) so as to assure that the ﬂux in each pixel is correct. camera_nrrefine
tells how deep RADMC-3D is allowed to recursively reﬁne. 100 is therefore effectively inﬁnite. Putting this to
0 means that you go back to 1 ray per pixel, which is fast, but may seriously misrepresent the ﬂux in each pixel.
See Section The issue of ﬂux conservation: recursive sub-pixeling for more details.
• camera_refine_criterion (default: 1.0) [Fine-tuning only]
Setting this value to smaller than 1 means that you reﬁne the recursive pixeling until a tighter criterion is met.
The smaller this value, the more accurate the ﬂuxes in each pixel, but the longer it takes to render. See Section
The issue of ﬂux conservation: recursive sub-pixeling for more details.
• camera_incl_stars (default: 1)
If 0, then only the interstellar/circumstellar material is rendered for the images and spectra. If 1, then also the
stellar ﬂux is included in the spectra and images.
• camera_starsphere_nrpix (default: 20) [Fine-tuning only]
16.1. INPUT: radmc3d.inp
149

radmc3d, Release 2.0
For rectangular images and for the spectra/SEDs (but not for spectra/SEDs created with circular pixel arrange-
ments, see Section Circular images), this number tells RADMC-3D how much it should do sub-pixeling over
the stellar surface. That is: 20 means that at least 20 sub-pixels are assured over the stellar surface. This is
important for ﬂux conservation (see Section The issue of ﬂux conservation: recursive sub-pixeling).
• camera_spher_cavity_relres (default: 0.05) [Fine-tuning only]
Determines the size of sub-pixels inside the inner grid radius of spherical coordinates.
• camera_localobs_projection (default: 1)
(Only for local observer mode) The type of projection on the sphere of observation.
• camera_min_dangle (default 0.05) [Fine-tuning only]
Fine-tuning parameter for recursive subpixeling (see Section The solution: recursive sub-pixeling), for spherical
coordinates, assuring that not too ﬁne subpixeling would slow down the rendering of images or spectra too
much.
• camera_max_dangle (default 0.3) [Fine-tuning only]
Fine-tuning parameter for recursive subpixeling (see Section The solution: recursive sub-pixeling), for spherical
coordinates, preventing that too coarse subpixeling would reduce the accuracy.
• camera_min_dr (default 0.003) [Fine-tuning only]
Fine-tuning parameter for recursive subpixeling, for spherical coordinates, assuring that not too ﬁne subpixeling
would slow down the rendering of images or spectra too much.
• camera_diagnostics_subpix (default: 0)
Setting this to 1 forces RADMC-3D to write out a ﬁle called subpixeling_diagnostics.out which
contains four columns, for respectivly: px,py,pdx,pdy, i.e. the pixel position and its size. This is for
all pixels, including the sub-pixels created during the recursive subpixeling procedure (Section The solution:
recursive sub-pixeling). This allows the user to ﬁnd out if the recursive subpixeling went well or if certain areas
were over/under-resolved. This is really only meant as a diagnostic.
• camera_secondorder (default: 0)
If set to 1, RADMC-3D will interpolate all emission/absorption quantities to the cell corners, and then use
a second order integration routine with bilinear interpolation of the source terms to integrate the ray-tracing
formal transfer equations. See Section Second order ray-tracing (Important information!) for more information
about the second order integration: It is recommended to read it!
• camera_interpol_jnu (default: 0) [Fine-tuning only]
Fine-tuning parameter for ray-tracing, only used for when second order integration is done (i.e.
if
camera_secondorder=1). If 0 (default), then the source function 𝑆𝜈is the one that is interpolated on
the grid, while if 1, then the emissivity 𝑗𝜈is the one that is interpolated on the grid. The differences are minimal,
but if strange results appear (when using second order integration) then you may want to experiment a bit with
this parameter.
• mc_weighted_photons (default: 1) [Fine-tuning only]
If mc_weighted_photons=1 (default) then in Monte Carlo simulations not all photon packages will have
the same energy (see Section More about photon packages in the Monte Carlo simulations). The energy will be
weighted such that each star or emission mechanism will emit, on average, the same number of photon packages.
As an example: If you have a stellar binary consisting of an O-star surrounded by a Brown Dwarf, but the Brown
Dwarf is surrounded by a disk, then although the O star is much brighter than the O-star, the very inner regions
of the Brown Dwarf disk is still predominantly heated by the Brown Dwarf stellar surface, because it is much
closer to that material. If you do not have weighted photon packages, then statistically the Brown Dwarf would
emit perhaps 1 or 2 photon packages, which makes the statistics of the energy balance in the inner disk very
bad. By mc_weighted_photons=1 both the Brown Dwarf and the O-star will each emit the same number
150
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
of photon packages; just the energy of the photon packages emitted by the Brown Dwarf are much less energetic
than those from the O-star. This now assures a good photon statistics everywhere.
• optimized_motion (default: 0) [Fine-tuning only]
If optimized_motion is set to 1, then RADMC-3D will try to calculate the photon motion inside cells more
efﬁciently. This may save computational time, but since it is still not very well tested, please use this mode with
great care! It is always safer not to use this mode.
• lines_mode (default: 1)
This mode determines how the level populations for line transfer are computed. The default is 1, which means:
Local Thermodynamic Equilibrium (LTE). For other modes, please consult Chapter Line radiative transfer.
• lines_maxdoppler (default: 0.3) [Fine-tuning only]
If the doppler catching mode is used (see Section Preventing doppler jumps: The ‘doppler catching method’),
this parameter tells how ﬁne RADMC-3D must sample along the ray, in units of the doppler width, when a line
is doppler-shifting along the wavelength-of-sight.
• lines_partition_ntempint (default 1000) [Fine-tuning only]
Number of temperature sampling points for the internally calculated partition function for molecular/atomic
lines.
• lines_partition_temp0 (default 0.1) [Fine-tuning only]
Smallest temperature sampling point for the internally calculated partition function for molecular/atomic lines.
• lines_partition_temp1 (default 1E5) [Fine-tuning only]
Largest temperature sampling point for the internally calculated partition function for molecular/atomic lines.
• lines_show_pictograms (default 0)
If 1, then print a pictogram of the levels of the molecules/atoms.
• tgas_eq_tdust (default: 0)
By setting tgas_eq_tdust=1 you tell radmc3d to simply read the dust_temperature.inp ﬁle and
then equate the gas temperature to the dust temperature. If multiple dust species are present, only the ﬁrst species
will be used.
• subbox_nx,subbox_ny,subbox_nz,subbox_x0,subbox_x1,subbox_y0,subbox_y1,
subbox_z0,subbox_z1
Parameters specifying the subbox size for the subbox extraction. See Section Making a regularly-spaced dat-
acube (‘subbox’) of AMR-based models for details.
16.2 INPUT (required): amr_grid.inp
This is the ﬁle that speciﬁes what the spatial grid of the model looks like. See Chapter More information about the
gridding. This ﬁle is essential, because most other .inp and .dat ﬁles are simple lists of numbers which do not
contain any information about the grid. All information about the grid is contained in the amr_grid.inp, also for
non-AMR regular grids. Note that in the future we will also allow for unstructured grids. The corresponding grid ﬁles
will then be named differently.
There are three possible AMR grid styles:
• Regular grid: No mesh reﬁnement. This is grid style 0.
• Oct-tree-style AMR (‘Adaptive Mesh Reﬁnement’, although for now it is not really ‘adaptive’). This is grid
style 1.
16.2. INPUT (required): amr_grid.inp
151

radmc3d, Release 2.0
• Layer-style AMR. This is grid style 10.
16.2.1 Regular grid
For a regular grid, without grid reﬁnement, the amr_grid.inp looks like:
iformat
<=== Typically 1 at present
0
<=== Grid style (regular = 0)
coordsystem
gridinfo
incl_x
incl_y
incl_z
nx
ny
nz
xi[1]
xi[2]
xi[3]
........
xi[nx+1]
yi[1]
yi[2]
yi[3]
........
yi[ny+1]
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
The meaning of the entries are:
• iformat: The format number, at present 1. For unformatted ﬁles this must be 4-byte integer.
• coordsystem: If coordsystem < 100 the coordinate system is cartesian. If 100 <= coordsystem
< 200 the coordinate system is spherical (polar). If 200 <= coordsystem < 300 the coordinate system
is cylindrical. For unformatted ﬁles this must be 4-byte integer.
• gridinfo: If gridinfo==1 there will be abundant grid information written into this ﬁle, possibly useful
for post-processing routines. Typically this is redundant information, so it is advised to set gridinfo=0 to
save disk space. In the following we will assume that gridinfo=0. For unformatted ﬁles this must be 4-byte
integer.
• incl_x,incl_y,incl_z: These are either 0 or 1. If 0 then this dimension is not active (so upon grid
reﬁnement no reﬁnement in this dimension is done). If 1 this dimension is fully active, even if the number of
base grid cells in this direction is just 1. Upon reﬁnement the cell will also be splitted in this dimension. For
unformatted ﬁles these numbers must be 4-byte integer.
• nx,ny,nz: These are the number of grid cells on the base grid in each of these dimensions. For unformatted
ﬁles these numbers must be 4-byte integer.
• xi[1]...xi[nx+1]: The edges of the cells of the base grid in x-direction. For nx grid cells we have nx+1
cell walls, hence nx+1 cell wall positions. For unformatted ﬁles these numbers must be 8-byte reals (=double
precision).
• yi[1]...yi[ny+1]: Same as above, but now for y-direction.
• zi[1]...zi[nz+1]: Same as above, but now for z-direction.
Example of a simple 2x2x2 regular grid in cartesian coordinates:
1
0
1
0
1
1
1
2
2
2
-1.
0. 1.
-1.
0. 1.
-1.
0. 1.
152
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
16.2.2 Oct-tree-style AMR grid
For a grid with oct-tree style grid reﬁnement (see Section Oct-tree Adaptive Mesh Reﬁnement), the amr_grid.inp
looks like:
iformat
<=== Typically 1 at present
1
<=== Grid style (1 = Oct-tree)
coordsystem
gridinfo
incl_x
incl_y
incl_z
nx
ny
nz
levelmax
nleafsmax
nbranchmax
<=== This line only if grid style == 1
xi[1]
xi[2]
xi[3]
........
xi[nx+1]
yi[1]
yi[2]
yi[3]
........
yi[ny+1]
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
(0/1)
<=== 0=leaf, 1=branch (only if amrstyle==1)
...
...
The keywords have the same meaning as before, but in addition we have:
• (0/1): NOTE: Only for amrstyle==1. These are numbers that are either 0 or 1. If 0, this means the current
cell is a leaf (= a cell that is not reﬁned and is therefore a ‘true’ cell). If 1, the current cell is a branch with 2 (in
1-D), 4 (in 2-D) or 8 (in 3-D) daughter cells. In that case the next (0/1) numbers are for these daughter cells.
In other words, we immediately recursively follow the tree. The order in which this happens is logical. In 3-D
the ﬁrst daughter cell is (1,1,1), then (2,1,1), then (1,2,1), then (2,2,1), then (1,1,2), then (2,1,2), then (1,2,2)
and ﬁnally (2,2,2), where the ﬁrst entry represents the x-direction, the second the y-direction and the third the
z-direction. If one or more of the daughter cells is also reﬁned (i.e. has a value 1), then ﬁrst this sub-tree is
followed before continuing with the rest of the daughter cells. If we ﬁnally return to the base grid at some point,
the next (0/1) number is for the next base grid cell (again possibly going into this tree if the value is 1). The order
in which the base grid is scanned in this way is from 1 to nx in the innermost loop, from 1 to ny in the middle
loop and from 1 to nz in the outermost loop. For unformatted ﬁles these numbers must be 4-byte integers, one
record per number.
Example of a simple 1x1x1 grid which is reﬁned into 2x2x2 and for which the (1,2,1) cell is reﬁned again in 2x2x2:
1
1
1
0
1
1
1
1
1
1
10 100 100
-1.
1.
-1.
1.
-1.
1.
1
0
0
(continues on next page)
16.2. INPUT (required): amr_grid.inp
153

radmc3d, Release 2.0
(continued from previous page)
1
0
0
0
0
0
0
0
0
0
0
0
0
0
16.2.3 Layer-style AMR grid
For a grid with layer-style grid reﬁnement (see Section Layered Adaptive Mesh Reﬁnement), the amr_grid.inp
looks like:
iformat
<=== Typically 1 at present
10
<=== Grid style (10 = layer-style)
coordsystem
gridinfo
incl_x
incl_y
incl_z
nx
ny
nz
nrlevels
nrlayers
<=== This line only if grid style == 10
xi[1]
xi[2]
xi[3]
........
xi[nx+1]
yi[1]
yi[2]
yi[3]
........
yi[ny+1]
zi[1]
zi[2]
zi[3]
........
zi[nz+1]
parentid
ix
iy
iz
nx
ny
nz
parentid
ix
iy
iz
nx
ny
nz
parentid
ix
iy
iz
nx
ny
nz
parentid
ix
iy
iz
nx
ny
nz
.
.
.
The keywords have the same meaning as before, but in addition we have:
• nrlevels: How many levels you plan to go, where nrlevels==0 means no reﬁnement, nrlevels==1
means one level of reﬁnement (factor of 2 in resolution), etc.
• nrlayers: How many layers do you have, with nrlayers==0 means no reﬁnement, nrlayers==1 means
one layer of reﬁnement (factor of 2 in resolution), etc.
• parentid: (For each layer) The parent layer for this layer. parentid==0 means parent is base grid. First
layer has id==1.
• ix,iy,iz: (For each layer) The location in the parent layer where the current layer starts.
• nx,ny,nz: (For each layer) The size of the layer as measured in units of the the parent layer. So the actual size
of the current layer will be (in 3-D): 2*nx,2*ny,2*nz. In 2-D, with only the x- and y- dimensions active,
we have a size of 2*nx,2*ny with of course size 1 in z-direction.
As you can see, this is a much easier and more compact way to specify mesh reﬁnement. But it is also less ‘adaptive’, as
it is always organized in square/cubic patches. But it is much easier to handle for the user than full oct-tree reﬁnement.
154
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
Note that this layer-style reﬁnement is in fact, internally, translated into the oct-tree reﬁnement. But you, as the user,
will not notice any of that. The code will input and output entirely in layer style.
NOTE: The layers must be specify in increasing reﬁnement level! So the ﬁrst layer (layer 1) must have the base grid
(layer 0) as its parent. The second layer can have either the base grid (layer 0) or the ﬁrst layer (layer 1) as parent, etc.
In other words: the parent layer must always already have been speciﬁed before.
Example of a simple 2-D 4x4 grid which has a reﬁnement patch in the middle of again 4x4 cells (=2x2 on the parent
grid), and a patch of 2x2 (=1x1 on the parent grid) starting in the upper left corner:
1
100
1
0
1
1
0
4
4
1
1
2
-2. -1. 0. 1. 2.
-2. -1. 0. 1. 2.
-0.5 0.5
0
2
2
1
2
2
1
0
1
1
1
1
1
1
This has just one level of reﬁnement, but two patches at level 1.
Anothe example: two recursive layers. Again start with a 2-D 4x4 grid, now reﬁne it in the middle with again a 4x4
sub-grid (=2x2 on the parent grid = layer 0) and then again a deeper layer of 4x4 (=2x2 on the parent grid = layer 1)
this time starting in the corner:
1
100
1
0
1
1
0
4
4
1
2
2
-2. -1. 0. 1. 2.
-2. -1. 0. 1. 2.
-0.5 0.5
0
2
2
1
2
2
1
1
1
1
1
2
2
1
Note that with this layer-style grid, the input data will have to be speﬁcied layer-by-layer: ﬁrst the base grid, then the
ﬁrst layer, then the second etc. This is worked out in detail for dust_density.inp in Section INPUT (required
for dust transfer): dust_density.inp. This will include redundant data, because you specify the data on the entire base
grid, also the cells that later will be replaced by a layer. Same is true for any layer that has sub-layers. The data that
is speciﬁed in these regions will be simply ignored. But for simplicity we do still require it to be present, so that
irrespective of the deeper layers, the data in any layer (including the base grid, which is layer number 0) is simply
organized as a simple data cube. This redundancy makes the input and output ﬁles larger than strictly necessary, but
it is much easier to handle as each layer is a datacube. For memory/hardisk-friendly storage you must use the oct-tree
reﬁnement instead. The layers are meant to make the AMR much more accessible, but are somewhat more memory
consuming.
16.2. INPUT (required): amr_grid.inp
155

radmc3d, Release 2.0
16.3 INPUT (required for dust transfer): dust_density.inp
This is the ﬁle that contains the dust densities. It is merely a list of numbers. Their association to grid cells is via the
ﬁle amr_grid.inp (see Chapter Binary I/O ﬁles for the binary version of this ﬁle, which is more compact). Each
dust species will have its own density distribution, completely independently of the others. That means that at each
position in space several dust species can exist, and the density of these can be fully freely speciﬁed. The structure of
this ﬁle is as follows. For formatted style (dust_density.inp):
iformat
<=== Typically 1 at present
nrcells
nrspec
density[1,ispec=1]
..
density[nrcells,ispec=1]
density[1,ispec=2]
..
..
..
density[nrcells,ispec=nrspec]
Here nrspec is the number of independent dust species densities that will be given here. It can be 1 or larger. If it is
1, then of course the density[1,ispec=2] and following lines are not present in the ﬁle. The nrcells is the
number of cells. For different kinds of grids this can have different meaning. Moreover, for different kinds of grids the
order in which the density values are given is also different. So let us now immediately make the following distinction
(See Chapter More information about the gridding on the different kinds of grids):
• For regular grid and oct-tree AMR grids:
The value of nrcells denotes the number of true cells, excluding the cells that are in fact the parents of 2x2x2
subcells; i.e. the sum of the volumes of all true cells (=leafs) adds up to the volume of the total grid). The order
of these numbers is always the same ‘immediate recursive subtree entry’ as in the amr_grid.inp (Section
INPUT (required): amr_grid.inp).
• For layer-style AMR grids:
The value of nrcells denotes the number of values that are speciﬁed. This is generally a bit more than the
true number of cells speciﬁed in the oct-tree style AMR (see above). In the layer-style AMR mode you specify
the dust density (or any other value) ﬁrst at all cells of the base grid (whether a cell is reﬁned or not does not
matter), the at all cells of the ﬁrst layer, then the second layer etc. Each layer is a regular (sub-)grid, so the order
of the values is simply the standard order (same as for regular grids). This means, however, that the values of
the density in the regular grid cells that are replaced by a layer are therefore redundant. See Section On the
‘successively regular’ kind of data storage, and its slight redundancy for a discussion of this redundancy. The
main advantage of this layer-style grid reﬁnement is that the input and output always takes place on regular
grids and subgrids (=layers). This is much easier to handle than the complexities of the oct-tree AMR.
16.3.1 Example: dust_density.inp for a regular grid
Now let us look at an example of a dust_density.inp ﬁle, starting with one for the simpliﬁed case of a regular
3-D grid (see Sections Regular grid and Regular grids):
iformat
<=== Typically 1 at present
nrcells
nrspec
density[1,1,1,ispec=1]
density[2,1,1,ispec=1]
(continues on next page)
156
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
..
density[nx,1,1,ispec=1]
density[1,2,1,ispec=1]
..
..
density[nz,ny,nz,ispec=1]
density[1,1,1,ispec=2]
..
..
..
density[nz,ny,nz,ispec=nrspec]
8
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
yc[2]
1
2
3
4
5
7
9
10
11
12
6
Fig. 16.1: Example of a regular 2-D grid with nx=4 and ny=3 (as Fig. Fig. 9.1), with the order of the cells shown as
numbers in the cells.
16.3.2 Example: dust_density.inp for an oct-tree reﬁned grid
For the case when you have an oct-tree reﬁned grid (see Sections Oct-tree-style AMR grid and Oct-tree Adaptive Mesh
Reﬁnement), the order of the numbers is the same as the order of the cells as speciﬁed in the amr_grid.(u)inp
ﬁle (Section INPUT (required): amr_grid.inp). Let us take the example of a simple 1x1x1 grid which is reﬁned into
2x2x2 and for which the (1,2,1) cell is reﬁned again in 2x2x2 (this is exactly the same example as shown in Section
Oct-tree-style AMR grid, and for which the amr_grid.inp is given in that section). Let us also assume that we
have only one dust species. Then the dust_density.inp ﬁle would be:
iformat
<=== Typically 1 at present
15
<=== 2x2x2 - 1 + 2x2x2 = 15
1
<=== Let us take just one dust spec
density[1,1,1]
<=== This is the first base grid cell
(continues on next page)
16.3. INPUT (required for dust transfer): dust_density.inp
157

radmc3d, Release 2.0
(continued from previous page)
density[2,1,1]
density[1,2,1;1,1,1]
<=== This is the first refined cell
density[1,2,1;2,1,1]
density[1,2,1;1,2,1]
density[1,2,1;1,2,1]
density[1,2,1;1,1,2]
density[1,2,1;2,1,2]
density[1,2,1;1,2,2]
density[1,2,1;1,2,2]
<=== This is the last refined cell
density[2,2,1]
density[1,1,2]
density[2,1,2]
density[1,2,2]
density[2,2,2]
<=== This is the last base grid cell
A more complex example is shown in Fig. Example of a 2-D grid with oct-tree reﬁnement (as Fig. ﬁg-oct-tree-amr)
with the order of the cells shown as numbers in the cells.. An unformatted version is also available, in the standard
way (see above).
yc[2]
1
2
5
6
3
4
7
8
9
10
11
12
13
14
15
16
17
18
19
20 21
22 23
26 27
28 29
24
25
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
49
47 48
50
51
52
53
54
55
56
57
58
59
60
61
62
63
ix=1
ix=2
ix=3
ix=4
xi[1]
xi[3]
xi[4]
xi[2]
xi[5]
xc[1]
xc[2]
xc[3]
xc[4]
iy=3
iy=1
iy=2
yi[1]
yi[3]
yi[2]
yi[4]
yc[1]
yc[3]
Fig. 16.2: Example of a 2-D grid with oct-tree reﬁnement (as Fig. Example of a 2-D grid with oct-tree reﬁnement.
The base grid has nx=4 and ny=3. Three levels of reﬁnement are added to this base grid.) with the order of the cells
shown as numbers in the cells.
158
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
16.3.3 Example: dust_density.inp for a layer-style reﬁned grid
For the case when you have an layer-style reﬁned grid (see Sections Layer-style AMR grid and Layered Adaptive Mesh
Reﬁnement) you specify the density in a series of regular boxes (=layers). The ﬁrst box is the base grid, the second
the ﬁrst layer, the third the second layer etc. The value nrcells now tells the combined sizes of the all the boxes.
If we take the second example of Section Layer-style AMR grid: a simple 2-D 4x4 grid which has a reﬁnement patch
(=layer) in the middle of again 4x4 cells, and again one patch of 4x4 this time, however, starting in the upper left
corner (see the amr_grid.inp ﬁle given in Section Layer-style AMR grid), then the dust_density.inp ﬁle
has the following form:
iformat
<=== Typically 1 at present
48
<=== 4x4 + 4x4 + 4x4 = 48
1
<=== Let us take just one dust spec
density[1,1,1,layer=0]
density[2,1,1,layer=0]
density[3,1,1,layer=0]
density[4,1,1,layer=0]
density[1,2,1,layer=0]
density[2,2,1,layer=0]
<=== This a redundant value
density[3,2,1,layer=0]
<=== This a redundant value
density[4,2,1,layer=0]
density[1,3,1,layer=0]
density[2,3,1,layer=0]
<=== This a redundant value
density[3,3,1,layer=0]
<=== This a redundant value
density[4,3,1,layer=0]
density[1,4,1,layer=0]
density[2,4,1,layer=0]
density[3,4,1,layer=0]
density[4,4,1,layer=0]
density[1,1,1,layer=1]
<=== This a redundant value
density[2,1,1,layer=1]
<=== This a redundant value
density[3,1,1,layer=1]
density[4,1,1,layer=1]
density[1,2,1,layer=1]
<=== This a redundant value
density[2,2,1,layer=1]
<=== This a redundant value
density[3,2,1,layer=1]
density[4,2,1,layer=1]
density[1,3,1,layer=1]
density[2,3,1,layer=1]
density[3,3,1,layer=1]
density[4,3,1,layer=1]
density[1,4,1,layer=1]
density[2,4,1,layer=1]
density[3,4,1,layer=1]
density[4,4,1,layer=1]
density[1,1,1,layer=2]
density[2,1,1,layer=2]
density[3,1,1,layer=2]
density[4,1,1,layer=2]
density[1,2,1,layer=2]
density[2,2,1,layer=2]
density[3,2,1,layer=2]
density[4,2,1,layer=2]
density[1,3,1,layer=2]
density[2,3,1,layer=2]
density[3,3,1,layer=2]
density[4,3,1,layer=2]
(continues on next page)
16.3. INPUT (required for dust transfer): dust_density.inp
159

radmc3d, Release 2.0
(continued from previous page)
density[1,4,1,layer=2]
density[2,4,1,layer=2]
density[3,4,1,layer=2]
density[4,4,1,layer=2]
An unformatted version is also available, in the standard way (see above).
It is clear that 48 is now the total number of values to be read, which is 16 values for layer 0 (= base grid), 16 values
for layer 1 and 16 values for layer 2. It is also clear that some values are redundant (they can have any value, does not
matter). But it at least assures that each data block is a simple regular data block, which is easier to handle. Note that
these values (marked as redundant in the above example) must be present in the ﬁle, but they can have any value you
like (typically 0).
Note that if you have multiple species of dust then we will still have 48 as the value of nrcells. The number of
values to be read, if you have 2 dust species, is then simply 2*nrcells = 2*48 = 96.
16.4 INPUT/OUTPUT: dust_temperature.dat
The dust temperature ﬁle is an intermediate result of RADMC-3D and follows from the thermal Monte Carlo simu-
lation. The name of this ﬁle is dust_temperature.dat (see Chapter Binary I/O ﬁles for the binary version of
this ﬁle, which is more compact). It can be used by the user for other purposes (e.g. determination of chemical reac-
tion rates), but also by RADMC-3D itself when making ray-traced images and/or spectra. The user can also produce
his/her own dust_temperature.dat ﬁle (without invoking the Monte Carlo computation) if she/he has her/his
own way of computing the dust temperature.
The structure of this ﬁle is identical to that of dust_density.inp (Section INPUT (required for dust transfer):
dust_density.inp), but with density replaced by temperature. We refer to section INPUT (required for dust transfer):
dust_density.inp for the details.
16.5 INPUT (mostly required): stars.inp
This is the ﬁle that speciﬁes the number of stars, their positions, radii, and spectra. Stars are sources of netto energy.
For the dust continuum Monte Carlo simulation these are a source of photon packages. This ﬁle exists only in formatted
(ascii) style. Its structure is:
iformat
<=== Put this to 2 !
nstars
nlam
rstar[1]
mstar[1]
xstar[1]
ystar[1]
zstar[1]
.
.
.
.
.
.
.
.
.
.
rstar[nstars
mstar[nstars] xstar[nstars] ystar[nstars] zstar[nstars]
lambda[1]
.
.
lambda[nlam]
flux[1,star=1]
.
.
flux[nlam,star=1]
flux[1,star=2]
.
.
(continues on next page)
160
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
flux[nlam,star=2]
.
.
.
.
flux[nlam,star=nstar]
which is valid only if iformat==2. The meaning of the variables:
• iformat: The format number, at present better keep it at 2. If you put it to 1, the list of wavelengths (see
below) will instead be a list of frequencies in Herz.
• nstars: The number of stars you wish to specify.
• nlam: The number of frequency points for the stellar spectra. At present this must be identical to the num-
ber of walvelength points in the ﬁle wavelength_micron.inp (see Section INPUT (required): wave-
length_micron.inp).
• rstar[i]: The radius of star 𝑖in centimeters.
• mstar[i]: The mass of star 𝑖in grams. This is not important for the current version of RADMC-3D, but may
be in the future.
• xstar[i]: The x-coordinate of star 𝑖in centimeters.
• ystar[i]: The y-coordinate of star 𝑖in centimeters.
• zstar[i]: The z-coordinate of star 𝑖in centimeters.
• lambda[i]: Wavelength point 𝑖(where 𝑖∈[1, nlam]) in microns. This must be identical (!) to the equivalent
point in the ﬁle wavelength_micron.inp (see Section INPUT (required): wavelength_micron.inp). If not,
an error occurs.
• flux[i,star=n]: The ﬂux 𝐹𝜈at wavelength point 𝑖for star 𝑛in units of erg cm−2, s−1, Hz−1 as seen from
a distance of 1 parsec = 3.08572 × 1018 cm (for normalization).
Sometimes it may be sufﬁcient to assume simple blackbody spectra for these stars. If for any of the stars the ﬁrst (!)
ﬂux number (flux[1,star=n]) is negative, then the absolute value of this number is taken to be the blackbody
temperature of the star, and no further values for this star are read. Example:
2
1
100
6.96e10
1.99e33
0.
0.
0.
0.1
.
.
1000.
-5780.
will make one star, at the center of the coordinate system, with one solar radius, one solar mass, on a wavelength grid
ranging from 0.1 micron to 1000 micron (100 wavelength points) and with a blackbody spectrum with a temperature
equal to the effective temperature of the sun.
Note: The position of a star can be both inside and outside of the computational domain.
16.5. INPUT (mostly required): stars.inp
161

radmc3d, Release 2.0
16.6 INPUT (optional): stellarsrc_templates.inp
This is the ﬁle that speciﬁes the template spectra for the smooth stellar source distributions. See Section Distributions
of zillions of stars. The ﬁle exists only in formatted (ascii) style. Its structure is:
iformat
<=== Put this to 2 !
ntempl
nlam
lambda[1]
.
.
lambda[nlam]
flux[1,templ=1]
.
.
flux[nlam,templ=1]
flux[1,templ=2]
.
.
flux[nlam,templ=2]
.
.
.
.
flux[nlam,templ=ntempl]
which is valid only if iformat==2. The meaning of the variables:
• iformat: The format number, at present better keep it at 2. If you put it to 1, the list of wavelengths (see
below) will instead be a list of frequencies in Herz.
• ntempl: The number of stellar templates you wish to specify.
• nlam: The number of frequency points for the stellar template spectra. At present this must be identical to
the number of walvelength points in the ﬁle wavelength_micron.inp (see Section INPUT (required):
wavelength_micron.inp).
• lambda[i]: Wavelength point 𝑖(where 𝑖∈[1, nlam]) in microns. This must be identical (!) to the equivalent
point in the ﬁle wavelength_micron.inp (see Section INPUT (required): wavelength_micron.inp). If not,
an error occurs.
• flux[i,templ=n]: The ‘ﬂux’ at wavelength 𝑖for stellar template 𝑛. The units are somewhat tricky. It is
given in units of erg / sec / Hz / gram-of-star. So multiply this by the density of stars in units of gram-of-star /
cm3, and divide by 4*pi to get the stellar source function in units of erg / src / Hz / cm3 / steradian.
Sometimes it may be sufﬁcient to assume simple blackbody spectra for these stellar sources. If for any of the stellar
sources the ﬁrst (!) ﬂux number (flux[1,templ=n]) is negative, then the absolute value of this number is taken to
be the blackbody temperature of the stellar source, and the following two numbers are interpreted as the stellar radius
and stellar mass respectively. From that, RADMC-3D will then internally compute the stellar template. Example:
2
1
100
0.1
.
.
1000.
-5780.
(continues on next page)
162
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
6.9600000e+10
1.9889200e+33
will tell RADMC-3D that there is just one stellar template, assumed to have a blackbody spectrum with solar effective
temperature. Each star of this template has one solar radius, one solar mass.
16.7 INPUT (optional): stellarsrc_density.inp
This is the ﬁle that contains the smooth stellar source densities. If you have the ﬁle stellarsrc_templates.
inp
speciﬁed
(see
Section
INPUT
(optional):
stellarsrc_templates.inp)
then
you
must
also
specify
stellarsrc_density.inp (or its binary form, see Chapter Binary I/O ﬁles). The format of this ﬁle is very
similar to dust_density.inp (Section INPUT (required for dust transfer): dust_density.inp), but instead differ-
ent dust species, we have different templates. For the rest we refer to Section INPUT (required for dust transfer):
dust_density.inp for the format. Just replace ispec (the dust species) with itempl (the template).
16.8 INPUT (optional): external_source.inp
This is the ﬁle that speciﬁes the spectrum and intensity of the external radiation ﬁeld, i.e. the ‘interstellar radiation
ﬁeld’ (see Section The interstellar radiation ﬁeld: external source of energy). Its structure is:
iformat
<=== Put this to 2 !
nlam
lambda[1]
.
.
lambda[nlam]
Intensity[1]
.
.
Intensity[nlam]
which is valid only if iformat==2. The meaning of the variables:
• iformat: The format number, at present better keep it at 2. If you put it to 1, the list of wavelengths (see
below) will instead be a list of frequencies in Herz.
• nlam: The number of frequency points for the stellar template spectra. At present this must be identical to
the number of walvelength points in the ﬁle wavelength_micron.inp (see Section INPUT (required):
wavelength_micron.inp).
• lambda[i]: Wavelength point 𝑖(where 𝑖∈[1, nlam]) in microns. This must be identical (!) to the equivalent
point in the ﬁle wavelength_micron.inp (see Section INPUT (required): wavelength_micron.inp). If not,
an error occurs.
• Intensity[i]: The intensity of the radiation ﬁeld at wavelength 𝑖in units of erg / cm2 / sec / Hz / steradian.
16.7. INPUT (optional): stellarsrc_density.inp
163

radmc3d, Release 2.0
16.9 INPUT (optional): heatsource.inp
This ﬁle, if present (it is an optional ﬁle!), gives the internal heat source of the gas-dust mixture in every cell. For
formatted style (heatsource.inp) the structure of this ﬁle is as follows.:
iformat
<=== Typically 1 at present
nrcells
heatsource[1]
..
heatsource[nrcells]
As with most input/output ﬁles of RADMC-3D, you can also specify the input data in binary form (heatsource.
binp), see Chapter Binary I/O ﬁles.
The physical unit of heatsource is erg cm−3 s−1. The total luminosity of the heat source would then be the sum
over all cells of heatsource times the cell volume.
16.10 INPUT (required): wavelength_micron.inp
This is the ﬁle that sets the discrete wavelength points for the continuum radiative transfer calculations. Note that
this is not the same as the wavelength grid used for e.g. line radiative transfer. See Section INPUT (optional):
camera_wavelength_micron.inp and/or Chapter Line radiative transfer for that. This ﬁle is only in formatted (ascii)
style. It’s structure is:
nlam
lambda[1]
.
.
lambda[nlam]
where
• nlam: The number of frequency points for the stellar spectra.
• lambda[i]: Wavelength point 𝑖(where 𝑖∈[1, nlam]) in microns.
The list of wavelengths can be in increasing order or decreasing order, but must be monotonically increas-
ing/decreasing.
IMPORTANT: It is important to keep in mind that the wavelength coverage must include the wavelengths at which
the stellar spectra have most of their energy, and at which the dust cools predominantly. This in practice means that
this should go all the way from 0.1 𝜇m to 1000 𝜇m, typically logarithmically spaced (i.e. equally spaced in log(𝜆)).
A smaller coverage will cause serious problems in the Monte Carlo run and dust temperatures may then be severely
miscalculated. Note that the 0.1 𝜇m is OK for stellar temperatures below 10000 K. For higher temperatures a shorter
wavelength lower limit must be used.
164
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
16.11 INPUT (optional): camera_wavelength_micron.inp
The wavelength points in the wavelength_micron.inp ﬁle are the global continuum wavelength points. On
this grid the continuum transfer is done. However, there may be various reasons why the user may want to gen-
erate spectra on a different (usually more ﬁnely spaced) wavelength grid, or make an image at a wavelength that
is not available in the global continuum wavelength grid. Rather than redoing the entire model with a different
wavelength_micron.inp, which may involve a lot of reorganization and recomputation, the user can specify
a ﬁle called camera_wavelength_micron.inp. If this ﬁle exists, it will be read into RADMC-3D, and the user
can now ask RADMC-3D to make images in those wavelength or make a spectrum in those wavelengths.
If the user wants to make images or spectra of a model that involves gas lines (such as atomic lines or molecular
rotational and/or ro-vibrational lines), the use of a camera_wavelength_micron.inp ﬁle allows the user to do
the line+dust transfer (gas lines plus the continuum) on this speciﬁc wavelength grid. For line transfer there are also
other ways by which the user can specify the wavelength grid (see Chapter Line radiative transfer), and it is left to the
user to choose which method to use.
The structure of the camera_wavelength_micron.inp ﬁle is identical to that of wavelength_micron.
inp (see Section INPUT (required): wavelength_micron.inp).
Note that there are also various other ways by which the user can let RADMC-3D choose wavelength points, many of
which may be even simpler and more preferable than the method described here. See Section Specifying custom-made
sets of wavelength points for the camera.
16.12 INPUT
(required
for
dust
transfer):
dustopac.inp
and
dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp
These ﬁles specify the dust opacities to be used. More than one can be speciﬁed, meaning that there will be more
than one co-existing dust species. Each of these species will have its own dust density speciﬁed (see Section INPUT
(required for dust transfer): dust_density.inp). The opacity of each species is speciﬁed in a separate ﬁle for each
species. The dustopac.inp ﬁle tells which ﬁle to read for each of these species.
16.12.1 The dustopac.inp ﬁle
The ﬁle dustopac.inp has the following structure, where an example of 2 separate dust species is used:
iformat
<=== Put this to 2
nspec
-----------------------------
inputstyle[1]
iquantum[1]
<=== Put to 0 in this example
<name of dust species 1>
-----------------------------
inputstyle[2]
iquantum[2]
<=== Put to 0 in this example
<name of dust species 2>
where:
• iformat: Currently the format number is 2, and in this manual we always assume it is 2.
• nspec: The number of dust species that will be loaded.
• inputstyle[i]: This number tells in which form the dust opacity of dust species 𝑖is to be read:
– 1 Use the dustkappa_*.inp input ﬁle style (see Section The dustkappa_*.inp ﬁles).
16.11. INPUT (optional): camera_wavelength_micron.inp
165

radmc3d, Release 2.0
– 10 Use the dustkapscatmat_*.inp input ﬁle style (see Section The dustkapscatmat_*.inp ﬁles).
• iquantum[i]: For normal thermal grains this is 0. If, however, this grain species is supposed to be treated as
a quantum-heated grain, then non-zero values are to be speciﬁed. NOTE: At the moment the quantum heating is
not yet implemented. Will be done in the future, if users request it. Until then, please set this to 0!
• <name of dust species i>: This is the name of the dust species (without blank spaces). This name
is then glued to the base name of the opacity ﬁle (see above). For instance, if the name is enstatite, and
inputstyle==1, then the ﬁle to be read is dustkappa_enstatite.inp.
16.12.2 The dustkappa_*.inp ﬁles
If you wish to use dust opacities that include the mass-weighted absorption opacity 𝜅abs, the (optionally) mass-
weighted scattering opacity 𝜅scat, and (optionally) the anisotropy factor 𝑔for scattering, you can do this with a ﬁle
dustkappa_*.inp (set input style to 1 in dustopac.inp, see Section The dustopac.inp ﬁle). With this kind
of opacity input ﬁle, scattering is included either isotropically or using the Henyey-Greenstein function. Using an
opacity ﬁle of this kind does not allow for full realistic scattering phase functions nor for polarization. For that, you
need dustkapscatmat_*.inp ﬁles (see Section The dustkapscatmat_*.inp ﬁles). Please refer to Section More
about scattering of photons off dust grains for more information about how RADMC-3D treats scattering.
If for dust species <name> the inputstyle in the dustopac.inp ﬁle is set to 1, then the ﬁle
dustkappa_<name>.inp is sought and read. The structure of this ﬁle is:
# Any amount of arbitrary
# comment lines that tell which opacity this is.
# Each comment line must start with an # or ; or ! character
iformat
<== This example is for iformat==3
nlam
lambda[1]
kappa_abs[1]
kappa_scat[1]
g[1]
.
.
.
.
.
.
.
.
lambda[nlam]
kappa_abs[nlam]
kappa_scat[nlam]
g[nlam]
The meaning of these entries is:
• iformat: If iformat==1, then only the lambda and kappa_abs colums are present. In that case the scattering
opacity is assumed to be 0, i.e. a zero albedo is assumed. If iformat==2 also kappa_scat is read (third
column). If iformat==3 (which is what is used in the above example) then also the anisotropy factor 𝑔is
included.
• nlam: The number of wavelength points in this ﬁle. This can be any number, and does not have to be the
same as those of the wavelength_micron.inp. It is typically advisable to have a rather large number of
wavelength points.
• lambda[i]: The wavelength point 𝑖in micron. This does not have to be (and indeed typically is not) the same
as the values in the wavelength_micron.inp ﬁle. Also for each opacity this list of wavelengths can be
different (and can be a different quantity of points).
• kappa_abs[i]: The absorption opacity 𝜅abs in units of cm2 per gram of dust.
• kappa_scat[i]: The scattering opacity 𝜅abs in units of cm2 per gram of dust. Note that this column should
only be included if iformat==2 or higher.
• g[ilam]: The mean scattering angle ⟨cos(𝜃)⟩, often called 𝑔. This will be used by RADMC-3D in the Henyey-
Greenstein scattering phase function. Note that this column should only be included if iformat==3 or higher.
Once this ﬁle is read, the opacities will be mapped onto the global wavelength grid of the wavelength_micron.
inp ﬁle. Since this mapping always involve uncertainties and errors, a ﬁle dustkappa_*.inp_used is created
which lists the opacity how it is remapped onto the global wavelength grid. This is only for you as the user, so that you
166
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
can verify what RADMC-3D has internally done. Note that if the upper or lower edges of the wavelength domain of the
dustkappa_*.inp ﬁle is within the domain of the wavelength_micron.inp grid, some extrapolation will
have to be done. At short wavelength this will simply be constant extrapolation while at long wavelength a powerlaw
extrapolation is done. Have a look at the dustkappa_*.inp_used ﬁle to see how RADMC-3D has done this in
your particular case.
16.12.3 The dustkapscatmat_*.inp ﬁles
If you wish to treat scattering in a more realistic way than just the Henyey-Greenstein non-polarized way, then you
must provide RADMC-3D with more information than is present in the dustkappa_xxx.inp ﬁles: RADMC-
3D will need the full scattering Müller matrix for all angles of scattering (see e.g. the books by Mishchenko, or by
Bohren & Huffman or by van de Hulst). For randomly oriented particles only 6 of these matrix elements can be
non-zero: 𝑍11, 𝑍12 = 𝑍21, 𝑍22, 𝑍33, 𝑍34 = −𝑍43, 𝑍44, where 1,2,3,4 represent the I,Q,U,V Stokes parameters.
Moreover, for randomly oriented particles there is only 1 scattering angle involved: the angle between the incoming
and outgoing radiation of the scattering event. This means that we must give RADMC-3D, (for every wavelength
and for a discrete set of scattering angles) a list of values of these 6 matrix elements. These can be provided in a ﬁle
dustkapscatmat_xxx.inp (set input style to 10 in dustopac.inp, see Section The dustopac.inp ﬁle) which
comes * instead of* the dustkappa_xxx.inp ﬁle. Please refer to Section More about scattering of photons off
dust grains for more information about how RADMC-3D treats scattering.
If for dust species <name> the inputstyle in the dustopac.inp ﬁle is set to 10, then the ﬁle
dustkapscatmat_<name>.inp is sought and read. The structure of this ﬁle is:
# Any amount of arbitrary
# comment lines that tell which opacity this is.
# Each comment line must start with an # or ; or ! character
iformat
<== Format number must be 1
nlam
nang
<== A reasonable value is 181 (e.g. angle = 0.0,1.0,...,180.0)
lambda[1]
kappa_abs[1]
kappa_scat[1]
g[1]
.
.
.
.
.
.
.
.
lambda[nlam]
kappa_abs[nlam]
kappa_scat[nlam]
g[nlam]
angle_in_degrees[1]
.
.
angle_in_degrees[nang]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=1]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=2]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=3]
.
.
.
.
.
.
.
.
.
.
.
.
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=1 and iang=nang]
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=2 and iang=1]
.
.
.
.
.
.
.
.
.
.
.
.
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=2 and iang=nang]
....
....
....
(continues on next page)
16.12. INPUT (required for dust transfer): dustopac.inp and dustkappa_*.inp or
dustkapscatmat_*.inp or dust_optnk_*.inp
167

radmc3d, Release 2.0
(continued from previous page)
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=nlam and iang=1]
.
.
.
.
.
.
.
.
.
.
.
.
Z_11
Z_12
Z_22
Z_33
Z_34
Z_44
[all for ilam=nlam and iang=nang]
The meaning of these entries is:
• iformat: For now this value should remain 1.
• nlam: The number of wavelength points in this ﬁle. This can be any number, and does not have to be the
same as those of the wavelength_micron.inp. It is typically advisable to have a rather large number of
wavelength points.
• nang: The number of scattering angle sampling points. This should be large enough that a proper integration
over scattering angle can be carried out reliably. A reasonable value is 181, so that (for a regular grid in scattering
angle 𝜃) you have as scattering angles 𝜃= 0, 1, 2, · · · , 180 (in degrees). But if you have extremely forward- or
backward peaked scattering, then maybe even 181 is not enough.
• lambda[ilam]: The wavelength point ilam in micron. This does not have to be (and indeed typically is not)
the same as the values in the wavelength_micron.inp ﬁle. Also for each opacity this list of wavelengths
can be different (and can be a different quantity of points).
• angle_in_degrees[iang]: The scattering angle sampling point iang in degrees (0 degrees is per-
fect forward scattering, 180 degrees is perfect backscattering). There should be nang such points, where
angle_in_degrees[1] must be 0 and angle_in_degrees[nang] must be 180. In between the angle
grid can be anything, as long as it is monotonic.
• kappa_abs[ilam]: The absorption opacity 𝜅abs in units of cm2 per gram of dust.
• kappa_scat[ilam]: The scattering opacity 𝜅scat in units of cm2 per gram of dust. RADMC-3D can (and
will) in fact calculate 𝜅scat from the scattering matrix elements. It will then check (for every wavelength) if that
is the same as the value listed here. If the difference is small, it will simply adjust the kappa_scat[ilam]
value internally to get a perfect match. If it is larger than 1E-4 then it will, in addition to adjusting, make a
warning. if it is larger than 1E-1, it will abort. Note that the fewer angles are used, the worse the match will be
because the integration over angle will be worse.
• g[ilam]: The mean scattering angle ⟨cos(𝜃)⟩, often called 𝑔. RADMC-3D can (and will) in fact calculate 𝑔
from the scattering matrix elements. Like with kappa_scat[ilam] it will adjust if the difference is not too
large and it will complain or abort if the difference is larger than some limit.
• Z_{xx} These are the scattering matrix elements in units of cm2 g−1 ster−1 (i.e. they are angular differential
cross sections). See Section More about scattering of photons off dust grains for more details.
NOTE: This only allows the treatment of randomly oriented particles. RADMC-3D does not, for now, have the
capability of treating scattering off ﬁxed-oriented particles. In fact, for oriented particles it would be impractical to
use dust opacity ﬁles of this kind, since we would then have at least three scattering angles, which would require huge
table. In that case it would be presumably necessary to compute the matrix elements on-the-ﬂy.
Note that the scattering-angle grid of the dustkapscatmat_xxx.inp ﬁles can be chosen non-regular, e.g. to put
a more ﬁnely spaced grid close to 𝜃= 0 (forward scattering) and 𝜃= 𝜋(backscattering). This can be useful for
large grains and/or short wavelengths, where forward scattering can be extremely strongly peaked. Since multiple
dust species can each have a different scattering 𝜃-grid, it requires you to give an additional ﬁle to RADMC-3D that
represents the scattering 𝜃-grid for all grains. This ﬁle is called scattering_angular_grid.inp. The format
is as follows:
1
<=== Format number, must be 1
181
<=== Nr of theta grid points
0.0
<=== First angle (in degrees). Must be 0
(continues on next page)
168
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
1.0
2.0
...
...
...
179.0
180.0
<=== Last angle (in degrees). Must be 180
NOTE: This ﬁle is not compulsory. If it is not given, then RADMC-3D will make its own internal scattering angle grid.
16.13 OUTPUT: spectrum.out
Any spectrum that is made with RADMC-3D will be either called spectrum.out or spectrum_<somename>.
out and will have the following structure:
iformat
<=== For now this is 1
nlam
lambda[1]
flux[1]
.
.
.
.
lambda[nlam]
flux[nlam]
where:
• iformat: This format number is currently set to 1.
• nlam: The number of wavelength points in this spectrum. This does not necessarily have to be the same as
those in the wavelength_micron.inp ﬁle. It can be any number.
• lambda[i]:
Wavelength in micron.
This does not necessarily have to be the same as those in the
wavelength_micron.inp ﬁle. The wavelength grid of a spectrum ﬁle can be completely independent
of all other wavelength grids. For standard SED computations for the continuum typically these will be indeed
the same as those in the wavelength_micron.inp ﬁle. But for line transfer or for spectra based on the
camera_wavelength_micron.inp they are not.
• flux[i]: Flux in units of erg s−1 cm−2 Hz−1 at this wavelength as measured at a standard distance of 1 parsec
(just as a way of normalization).
NOTE: Maybe in the future a new iformat version will be possible where more telescope information is given in the
spectrum ﬁle.
16.14 OUTPUT: image.out or image_****.out
Any images that are produced by RADMC-3D will be written in a ﬁle called image.out. The ﬁle has the following
structure (for the case without Stokes parameters):
iformat
<=== For now this is 1 (or 2 for local observer mode)
im_nx
im_ny
nlam
pixsize_x
pixsize_y
lambda[1]
......... lambda[nlam+1]
(continues on next page)
16.13. OUTPUT: spectrum.out
169

radmc3d, Release 2.0
(continued from previous page)
image[ix=1,iy=1,img=1]
image[ix=2,iy=1,img=1]
.
.
image[ix=im_nx,iy=1,img=1]
image[ix=1,iy=2,img=1]
.
.
image[ix=im_nx,iy=2,img=1]
image[ix=1,iy=im_ny,img=1]
.
.
.
image[ix=im_nx,iy=im_ny,img=nlam]
image[ix=1,iy=1,img=1]
.
.
.
.
image[ix=im_nx,iy=im_ny,img=nlam]
In most cases the nr of images (nr of wavelengths) is just 1, meaning only one image is written (i.e. the img=2, ....
img=nlam are not there, only the img=1). The meaning of the various entries is:
• iformat: This format number is currently set to 1
for images from an observer at inﬁnity (default) and 2 for a local observer. Note: For full-Stokes images it is 3, but
then also the data changes a bit, see below.
• im_nx,im_ny: The number of pixels in x and in y direction of the image.
• nlam: The number of images at different wavelengths that
are in this ﬁle. You can make a series of images at different wavelengths in one go, and write them in this ﬁle. The
wavelength belonging to each of these images is listed below. The nlam can be any number from 1 to however large
you want. Mostly one typically just makes an images at one wavelength, meaning nlam=1.
• pixsize_x,pixsize_y: The size of the pixels in cm (for an observer at inﬁnity) or radian (for local ob-
server mode). This means that for the observer-at-inﬁnity mode (default) the size is given in model units (dis-
tance within the 3-D model) and the user can, for any distance, convert this into arcseconds: pixel size in arcsec
= ( pixel size in cm / 1.496E13) / (distance in parsec). The pixel size is the full size from the left of the pixel to
the right of the pixel (or from bottom to top).
• lambda[i]: Wavelengths in micron belonging to the various images in this ﬁle. In case nlam=1 there will
be here just a single number. Note that this set of wavelengths can be completely independent of all other
wavelength grids.
• image[ix,iy,img]: Intensity in the image at pixel ix, iy at wavelength img (of the above listed wave-
length points) in units of erg s−1 cm−2 Hz−1 ster−1. Important: The pixels are ordered from left to right (i.e.
increasing 𝑥) in the inner loop, and from bottom to top (i.e. increasing 𝑦) in the outer loop.
You can also make images with full Stokes parameters. For this you must have dust opacities that include the full
scattering matrix, and you must add the keyword stokes to the radmc3dimage command on the command-line.
In that case the image.out ﬁle has the following form:
iformat
<=== For Stokes this is 3
im_nx
im_ny
nlam
(continues on next page)
170
Chapter 16. Main input and output ﬁles of RADMC-3D

radmc3d, Release 2.0
(continued from previous page)
pixsize_x
pixsize_y
lambda[1]
......... lambda[nlam+1]
image_I[ix=1,iy=1,img=1] image_Q[ix=1,iy=1,img=1] image_U[ix=1,iy=1,img=1] image_
˓→V[ix=1,iy=1,img=1]
.
.
image_I[ix=im_nx,iy=1,img=1] (and so forth for Q U and V)
image_I[ix=1,iy=2,img=1] (and so forth for Q U and V)
.
.
image_I[ix=im_nx,iy=2,img=1] (and so forth for Q U and V)
image_I[ix=1,iy=im_ny,img=1] (and so forth for Q U and V)
.
.
.
image_I[ix=im_nx,iy=im_ny,img=nlam] (and so forth for Q U and V)
image_I[ix=1,iy=1,img=1] (and so forth for Q U and V)
.
.
.
.
image_I[ix=im_nx,iy=im_ny,img=nlam] (and so forth for Q U and V)
That is: instead of 1 number per line we now have 4 numbers per line, which are the four Stokes parameters. Note that
iformat=3 to indicate that we have now all four Stokes parameters in the image.
16.15 INPUT: (minor input ﬁles)
There is a number of lesser important input ﬁles, or input ﬁles that are only read under certain circumstances (for
instance when certain command line options are given). Here they are described.
16.15.1 The color_inus.inp ﬁle (required with comm-line option ‘loadcolor’)
The ﬁle color_inus.inp will only be read by RADMC-3D if on the command line the option loadcolor or
color is speciﬁed, and if the main action is image.
iformat
<=== For now this is 1
nlam
ilam[1]
.
.
ilam[nlam]
• iformat: This format number is currently set to 1.
• nlam: Number of wavelength indices speciﬁed here.
• ilam[i]: The wavelength index for image i (the wavelength index refers to the list of wavelengths in the
wavelength_micron.inp ﬁle.
16.15. INPUT: (minor input ﬁles)
171

radmc3d, Release 2.0
16.15.2 INPUT: aperture_info.inp
If you wish to make spectra with wavelength-dependent collecting area, i.e. aperture (see Section Can one specify
more realistic ‘beams’?), then you must prepare the ﬁle aperture_info.inp. Here is its structure:
iformat
<=== For now this is 1
nlam
lambda[1]
rcol_as[1]
.
.
.
.
lambda[nlam]
rcol_as[nlam]
with
• iformat: This format number is currently set to 1.
• nlam: Number of wavelength indices speciﬁed here. This does not have to be the same as the number of
wavelength of a spectrum or the number of wavelengths speciﬁed in the ﬁle wavelength_micron.inp. It
can be any number.
• lambda[i]: Wavelength sampling point, in microns. You can use a course grid, as long as the range of
wavelengths is large enough to encompass all wavelengths you may wish to include in spectra.
• rcol_as[i]: The radius of the circular image mask used for the aperture model, in units of arcsec.
16.16 For developers: some details on the internal workings
There are several input ﬁles that can be quite large. Reading these ﬁles into RADMC-3D memory can take time, so it
is important not to read ﬁles that are not required for the execution of the particular command at hand. For instance,
if a model exists in which both dust and molecular lines are included, but RADMC-3D is called to merely make a
continuum SED (which in RADMC-3D never includes the lines), then it would be a waste of time to let RADMC-3D
read all the gas velocity and temperature data and level population data into memory if they are not used.
To avoid unnecessary reading of large ﬁles the reading of these ﬁles is usually organized in a ‘read when required’
way. Any subroutine in the code that relies on e.g. line data to be present in memory can simply call the routine
read_lines_all(action) with argument action being 1, i.e.:
call read_lines_all(1)
This routine will check if the data are present: if no, it will read them, if yes, it will return without further action. This
means that you can call read_lines_all(1) as often as you want: the line data will be read once, and only once.
If you look through the code you will therefore ﬁnd that many read_*** routines are called abundantly, whenever
the program wants to make sure that certain data is present. The advantage is then that the programmer does not have
to have a grand strategy for when which data must be read in memory: he/she simply inserts a call to the read routines
for all the data she/he needs at that particular point in the program, (always with action=1), and it will organize itself.
If certain data is nowhere needed, they will not be read.
All these read_*** routines with argument action can also be called with action=2. This will force the routine
to (re-)read these data. But this is rarely needed.
172
Chapter 16. Main input and output ﬁles of RADMC-3D

CHAPTER
SEVENTEEN
BINARY I/O FILES
17.1 Overview
By default all input and output ﬁles of RADMC-3D are in ASCII (i.e.text) form. This makes it easier to verify if
the ﬁles are ok. Also, it is easier to produce ﬁles with the right format and read the output of RADMC-3D. The
disadvantage is that ASCII ﬁles are substantially larger than strictly required to store their information content. For
large models, i.e.models with many grid points, this may lead to unpractically large ﬁles.
RADMC-3D supports a more compact data format: binary data. In this form, a double precision variable occupies just
8 bytes, while a single precision variable occupies just 4 bytes.
Unfortunately, Fortran-90 and Fortran-95 did, for a long time, not support true binary ﬁles. Instead they offered
‘f77-unformatted’ ﬁles, which uses ‘records’, and is harder to read than true binary ﬁles. Recently, however, many
Fortran-90 and Fortran-95 compilers have introduced a true binary format, which is called ‘streaming access’. It is,
actually, a Fortran-2003 feature, but has been retroactively implemented into Fortran-90 and Fortran-95. The gfortran
and g95 compilers have it. Also the ifort compiler has it. Presumably others as well.
RADMC-3D offers a binary I/O capability. A ﬁle containing three double precision variables will have a length of
exactly 24 bytes. Files with this format will have extensions such as .binp, .bdat or .bout.
Here is a (presumably incomplete) list of ﬁles that have binary versions:
Name
ascii
binary
dust_density
.inp
.binp
dust_temperature
.inp
.binp
dust_temperature
.dat
.bdat
gas_density
.inp
.binp
gas_temperature
.inp
.binp
electron_numdens
.inp
.binp
ion_numdens
.inp
.binp
levelpop_***
.dat
.bdat
numberdens_***
.inp
.binp
gas_velocity
.inp
.binp
microturbulence
.inp
.binp
stellarsrc_density
.inp
.binp
mean_intensity
.out
.bout
heatsource
.inp
.binp
173

radmc3d, Release 2.0
17.2 How to switch to binary (or back to ascii)
Specifying whether RADMC-3D should use ASCII or binary input is easy: It will simply look which extension each
input ﬁle has, and read it accordingly. If you present RADMC-3D ﬁle input ﬁles with extension .binp, it will read
these ﬁles as binaries.
More tricky is how to tell RADMC-3D to use binary ﬁles on output. By default, RADMC-3D will always write ASCII
style (.out and .dat). However, if you add the following line to the radmc3d.inp ﬁle:
rto_style = 3
it will instead use binary output (.bout and .bdat). And, for completeness (though it is the default anyway), if you
set rto_style=1 RADMC-3D will write output in ASCII form. Note that rto_style = 2 is the old Fortran
unformatted data format, which is deprecated.
For the binary form of output you can also tell RADMC-3D to use single-precision for the main data, to produce
smaller output ﬁles. This is done by adding the following line to the radmc3d.inp ﬁle:
rto_single = 1
By default RADMC-3D will always output double precision in the binary format.
Note: Images are still outputted in ascii even if you have rto_style=3. This is because images are rarely ﬁles of
huge size, and ascii ﬁles are easier to analyze and check. However, sometimes images can be still quite big (e.g.if you
make multi-frequency images). Then it might still be useful to output binary. If you want to also have the images in
binary format, you must set
writeimage_unformatted = 1
in the radmc3d.inp ﬁle, or you add a keyword imageunform.
17.3 Binary I/O ﬁle format of RADMC-3D
The general format of the ﬁles listed in Section Overview is similar to the ASCII versions, just binary this time. There
is one additional number in the binary version: Right after the format number comes an integer that gives the precision
of the main data. This number is either 4, meaning that the main data consists of 4-byte ﬂoating point numbers
(i.e.single precision), or 8, meaning that the main data consists of 8-byte ﬂoating point numbers (i.e.double precision).
Other than that additional number, the order of the data is the same.
The following rules apply:
• With the exception of the amr_grid.binp ﬁle (see below), all integers are 8-byte integers.
• Floating point numbers for the main data (i.e.the data that represents the space-dependent variables) are either
4-byte (single) or 8-byte (double) precision numbers. Which of the two is speciﬁed in the second integer of the
ﬁle (the integer right after the format number, see above).
• All other ﬂoating point numbers are double precision (i.e.8-byte ﬂoats).
• For AMR-grids the amr_grid.binp ﬁle contains a huge list of 0 or 1 numbers (see Section Oct-tree-style
AMR grid). Since it is silly to use 8-byte integers for numbers that are either 0 or 1, the numbers in this list are
1-byte integers (bytes).
Example:
According to Section INPUT (required for dust transfer):
dust_density.inp the ASCII ﬁle
dust_density.inp ﬁle has the following format:
174
Chapter 17. Binary I/O ﬁles

radmc3d, Release 2.0
iformat
<=== Typically 1 at present
nrcells
nrspec
density[1,ispec=1]
..
density[nrcells,ispec=1]
density[1,ispec=2]
..
..
..
density[nrcells,ispec=nrspec]
According to the above listed rules the binary ﬁle dust_density.binp ﬁle then has the following format:
<int8:iformat=1>
<int8:precis=8>
<int8:nrcells>
<int8:nrspec>
<dbl8:density[1,ispec=1]>
..
<dbl8:density[nrcells,ispec=1]>
<dbl8:density[1,ispec=2]>
..
..
..
<dbl8:density[nrcells,ispec=nrspec]>
where the <int8:precis=8> means that this is an 8-byte integer that we call ‘precis’ (the name is irrelevant here),
and it has value 8, and <dbl8:density[1,ispec=1]> means that this is a double-precision number (8-byte
ﬂoat). In other words: the ﬁrst 8 bytes of the ﬁle contain the format number (which is 1 at present). The second 8 bytes
contain the number 8, telling that the main data (i.e.the density data) are double precision variables. The third set of
8 bytes gives the number of cells, while the fourth set gives the number of dust species. The data of density starts
as of the 33rd byte of the ﬁle. If you want to compress the ﬁle even further, and you are satisﬁed with single-precision
data, then the ﬁle would look like:
<int8:iformat=1>
<int8:precis=4>
<int8:nrcells>
<int8:nrspec>
<flt4:density[1,ispec=1]>
..
<flt4:density[nrcells,ispec=1]>
<flt4:density[1,ispec=2]>
..
..
..
<flt4:density[nrcells,ispec=nrspec]>
Another example: According to Section Special-purpose feature: Computing the local radiation ﬁeld RADMC-3D
can compute the mean intensity of radiation at each grid point at a set of pre-deﬁned frequencies, and write this out to
an ASCII ﬁle called mean_intensity.out. The contents of this ﬁle are:
iformat
<=== Typically 2 at present
nrcells
nfreq
<=== Nr of frequencies
freq_1 freq_2 ... freq_nfreq
<=== List of frequencies in Hz
meanint[1,icell=1]
(continues on next page)
17.3. Binary I/O ﬁle format of RADMC-3D
175

radmc3d, Release 2.0
(continued from previous page)
meanint[1,icell=2]
...
meanint[1,icell=nrcells]
meanint[2,icell=1]
meanint[2,icell=2]
...
meanint[2,icell=nrcells]
...
...
...
meanint[nfreq,icell=1]
meanint[nfreq,icell=2]
...
meanint[nfreq,icell=nrcells]
By setting rto_style=3 in the radmc3d.inp ﬁle, however, RADMC-3D will instead produce a binary ﬁle called
mean_intensity.bout, which has the contents:
<int8:iformat=2>
<int8:precis=8>
<int8:nrcells>
<int8:nfreq>
<dbl8:freq_1>
<dbl8:freq_2>
...
<dbl8:freq_nfreq>
<dbl8:meanint[1,icell=1]>
<dbl8:meanint[1,icell=2]>
...
<dbl8:meanint[1,icell=nrcells]>
<dbl8:meanint[2,icell=1]>
<dbl8:meanint[2,icell=2]>
...
<dbl8:meanint[2,icell=nrcells]>
...
...
...
<dbl8:meanint[nfreq,icell=1]>
<dbl8:meanint[nfreq,icell=2]>
...
<dbl8:meanint[nfreq,icell=nrcells]>
If you also set rto_single=1 in the radmc3d.inp ﬁle, then you will get:
<int8:iformat=2>
<int8:precis=4>
<int8:nrcells>
<int8:nfreq>
<dbl8:freq_1>
<dbl8:freq_2>
...
<dbl8:freq_nfreq>
<flt4:meanint[1,icell=1]>
<flt4:meanint[1,icell=2]>
...
<flt4:meanint[1,icell=nrcells]>
(continues on next page)
176
Chapter 17. Binary I/O ﬁles

radmc3d, Release 2.0
(continued from previous page)
<flt4:meanint[2,icell=1]>
<flt4:meanint[2,icell=2]>
...
<flt4:meanint[2,icell=nrcells]>
...
...
...
<flt4:meanint[nfreq,icell=1]>
<flt4:meanint[nfreq,icell=2]>
...
<flt4:meanint[nfreq,icell=nrcells]>
Note that only the mean intensity data (the main data) are single precision ﬂoats.
17.3. Binary I/O ﬁle format of RADMC-3D
177

radmc3d, Release 2.0
178
Chapter 17. Binary I/O ﬁles

CHAPTER
EIGHTEEN
COMMAND-LINE OPTIONS
This chapter deals with all the possible command-line options one can give when calling the radmc3d code.
18.1 Main commands
In addition to the radmc3d.inp ﬁle, which contains many ‘steering’ parameters, one can (and even must) give RADMC-
3D also command-line options. The most important (and compulsory) options are the ‘command’ what RADMC-3D
should do. At the moment you can choose from:
• mctherm: Runs RADMC-3D for computing the dust temperatures using the Monte Carlo method.
• spectrum: Runs RADMC-3D for making a spectrum based on certain settings. This option requires further
command-line speciﬁcations. See chapter Making images and spectra.
• sed: Runs RADMC-3D for making a SED based on certain settings. This option requires further command-
line speciﬁcations. Note that a SED is like a spectrum, but for continuum processes only (no lines). See chapter
Making images and spectra for more details.
• image: Runs RADMC-3D for making an image. This option requires further command-line speciﬁcations.
See chapter Making images and spectra.
• movie: Like image, but now for a series of different vantage points. Useful for making movies in one go,
without having to call RADMC-3D time and again. NOTE: This command is still under development. See
chapter Making images and spectra.
• mcmono: (Only expect use). Runs RADMC-3D for computing the local radiation ﬁeld at each location in the
model. This is only useful for when you wish to couple RADMC-3D to models of chemistry or so, which need
the local radiation ﬁeld. See Section Special-purpose feature: Computing the local radiation ﬁeld.
Example:
radmc3d mctherm
runs the RADMC-3D code for computing the dust temperatures everywhere using the Monte Carlo method.
There are also some additional commands that may be useful for diagnostics:
• subbox_****: where **** is one of the following: dust_density, dust_temperature. But other
quantities will follow in later versions. See Section Making a regularly-spaced datacube (‘subbox’) of AMR-
based models.
• linelist: Write a list of all the lines included in this model.
179

radmc3d, Release 2.0
18.2 Additional arguments: general
Here is a list of command line options, on top of the above listed main commands (Note: We’ll try to be complete, but
as the code develops we may forget to list new options here):
• setthreads [for MC] The next number sets the number of OpenMP parallel threads to be used.
• npix: [for images] The next number speciﬁes the number of pixels in both x and y direction, assuming a square
image.
• npixx: [for images] The next number speciﬁes the number of pixels in x direction only.
• npixy: [for images] The next number speciﬁes the number of pixels in y direction only.
• nrrefine: [for images and spectra] Speciﬁes a maximum depth of reﬁnement of the pixels (see Section The
issue of ﬂux conservation: recursive sub-pixeling).
• fluxcons: [for images and spectra] Puts nrreﬁne (see above) to a large value to assue ﬂux conservation (see
Section The issue of ﬂux conservation: recursive sub-pixeling).
• norefine: [for images and spectra] Puts nrreﬁne (see above) to 0 so that each pixel of the image corre-
sponds only to 1 ray. This is fast but not reliable and therefore not recommended (see Section The issue of ﬂux
conservation: recursive sub-pixeling).
• nofluxcons: [for images and spectra] As norefine above.
• noscat: This option makes RADMC-3D ignore the dust scattering process (though not the scattering extinc-
tion!) in the images, spectra and Monte Carlo simulations. For images and spectra this means that no scattering
Monte Carlo run has to be performed before each image ray tracing (see Section Scattered light in images
and spectra: The ‘Scattering Monte Carlo’ computation). This can speed up the making of images or spectra
enormously. This is even more so if you make images/spectra of gas lines with LTE, LVG or ESCP methods,
because if no scattering Monte Carlo needs to be made, ray-tracing can be done multi-frequency for each ray,
and the populations can be calculated once in each cell, and used for all frequencies. That can speed up the line
rendering enormously – of course at the cost of not including dust scattering. For lines in the infrared and sub-
millimeter, if no large grains are present, this is usually OK, because small grains (smaller than about 1 micron)
have very low scattering albedos in the infrared and submillimeter.
• ilambda or inu: [for images] Specify the index of the wavelength from the wavelength_micron.inp
ﬁle for which a ray-trace image should be made.
• color: [for images] Allows you to make multiple images (each at a different wavelength) in one go. This will
make RADMC-3D read the ﬁle color_inus.inp (see Section INPUT: (minor input ﬁles)) which is a list of
indices i referring to the wavelength_micron.inp ﬁle for which the images should be made. See Section
Specifying custom-made sets of wavelength points for the camera for details.
• loadcolor: [for images] Same as color.
• loadlambda: [for images] Allows you to make multiple images (each at a different wavelength) in one
go. This will make RADMC-3D read the ﬁle camera_wavelength_micron.inp to read the precise
wavelength points at which you wish to make the images. In contrast to loadcolor, which only allows you to
pick from the global set of wavelength used by the Monte Carlo simulation (in the ﬁle wavelength_micron.
inp), with the camera_wavelength_micron.inp ﬁles you can specify any wavelength you want, and
any number of them. See Section Specifying custom-made sets of wavelength points for the camera for details.
• sizeau: [for images and spectra] The next number speciﬁes the image size in model space in units of AU
(=1.496E13 cm). This image size is measured from the image left to right and top to bottom. This gives always
square images. This image size in au is observer distance independent. The corresponding image size in arcsec
is: image size in arcsec = image size in AU / (distance in parsec).
• sizepc: [for images and spectra] Same as sizeau, but now in parsec units.
180
Chapter 18. Command-line options

radmc3d, Release 2.0
• zoomau: [for images and spectra] The next four numbers set the image window precisely by specifying the
xleft, xright, ybottom, ytop of the image in units of AU. The zero point of the image (the direction of the 2-D
image point located at (0.0,0.0) in image coordinates) stays the same (i.e. it aims toward the 3-D point in model
space given by pointau or pointpc). In this way you can move the image window left or with or up or
down without having to change the pointau or pointpc 3-D locations. Also for local perspective images it
is different if you move the image window in the image plane, or if you actually change the direction in which
you are looking (for images from inﬁnity this is the same). Note: If you use this option without the truepix
option RADMC-3D will always make square pixels by adapting npixx or npixy such that together with the
zoomau image size you get approximately square pixels. Furthermore, if truezoom is not set, RADMC-3D
will alleviate the remaining tiny deviation from square pixel shape by slightly (!) adapting the zoomau window
to obtain exactly square pixels.
• zoompc: [for images and spectra] Same as zoomau, but now the four numbers are given in units of parsec.
• truepix: [for images and spectra] If with zoomau or zoompc the image window is not square then when
specifying npix one gets non-square pixels. Without the truepix option RADMC-3D will adapt the npixx
or npixy number, and subsequently modify the zoom window a bit such that the pixels are square. With the
truepix option RADMC-3D will not change npixx nor npixy and will allow non-square pixels to form.
• truezoom: [for images and spectra] If set, RADMC-3D will always assure that the exact zoom window
(speciﬁed with zoomau or zoompc) will be used, i.e. if truepix is not set but truezoom is set, RADMC-
3D will only (!) adapt npixx or npixy to get approximately square pixels.
• pointau: [for images and spectra] The subsequent three numbers specify a 3-D location in model space toward
which the camera is pointing for images and spectra. The (0,0) coordinate in the image plane corresponds by
deﬁnition to a ray going right through this 3-D point.
• pointpc: [for images and spectra] Same as pointau but now in units of parsec.
• incl: [for images and spectra] For the case when the camera is at inﬁnity (i.e. at a large distance so that no
local perspective has to be taken into account) this inclination speciﬁes the direction toward which the camera
for images and spectra is positioned. Incl = 0 means toward the positive 𝑧-axis (in cartesian space), incl=90
means toward a position in the 𝑥-𝑦-plane and incl=180 means toward the negative 𝑧-axis. The angle is given in
degrees.
• phi: [for images and spectra] Like incl, but now the remaining angle, also given in degrees. Examples:
incl=90 and phi=0 means that the observer is located at inﬁnity toward the negative 𝑦axis; incl=90 and
phi=90 means that the observer is located at inﬁnity toward the negative 𝑥axis; incl=90 and phi=180 means
that the observer is located at inﬁnity toward the positive 𝑦axis (looking back in negative 𝑦direction). Rotation
of the observer around the object around the 𝑧-axis goes in clockwise direction. The starting point of this rotation
is such that for incl=0 and phi=0 the (𝑥, 𝑦) in the image plane correspond to the (𝑥, 𝑦) in the 3-D space,
with 𝑥pointing toward the right and 𝑦pointing upward. Examples: if we ﬁx the position of the observer at for
instance incl=0 (i.e. we look at the object from the top from the positive 𝑧-axis at inﬁnity downward), then
increasing phi means rotating the object counter-clockwise in the image plane.
• posang: [for images] This rotates the camera itself around the (0, 0) point in the image plane.
• imageunform: Write out images in binary format
• imageformatted: Write out images in text form (default)
• tracetau: [for images] If this option is set, then instead of ray-tracing a true image, the camera will compute
the optical depth at the wavelength given by e.g. inu and puts this into an image output as if it were a true
image. Can be useful for analysis of models.
• tracecolumn: [for images] Like tracetau but instead of the optical depth the simple column depth is
computed in g/cm2. NOTE: for now only the column depth of the dust.
• tracenormal: [for images: Default] Only if you speciﬁed tracetau or tracecolumn before, and you
are in child mode, you may sometimes want to reset to normal imaging mode.
18.2. Additional arguments: general
181

radmc3d, Release 2.0
• apert or useapert:
[for images/spectra] Use the image-plane aperture information from the ﬁle
aperture_info.inp.
• noapert: [for images/spectra] Do not use an image-plane aperture.
• nphot_therm: [for MC] The nr of photons for the thermal Monte Carlo simulation. But it is better to use
the radmc3d.inp for this (see Section INPUT: radmc3d.inp), because then you can see afterward with which
photon statistics the run was done.
• nphot_scat: [for MC] The nr of photons for the scattering Monte Carlo simulation done before each im-
age (and thus also in the spectrum). But it is better to use the radmc3d.inp for this (see Section INPUT:
radmc3d.inp), because then you can see afterward with which photon statistics the run was done.
• nphot_mcmono: [for MC] The nr of photons for the monochromatic Monte Carlo simulation. But it is better
to use the radmc3d.inp for this (see Section INPUT: radmc3d.inp), because then you can see afterward with
which photon statistics the run was done.
• countwrite: [for MC] The nr of photons between ‘sign of life’ outputs in a Monte Carlo run. Default is 1000.
That means that if you have nrphot=10000000 you will see ten-thousand times something like Photonnr:
19000 on your screen. Can be annoying. By adding countwrite 100000 to the command line, you will
only see a message every 100000 photon packages.
18.3 Switching on/off of radiation processes
You can switch certain radiative processes on or off with the following command-line options (though often the
radmc3d.inp ﬁle also allows this):
• inclstar: [for images and spectra] Include stars in spectrum or images.
• nostar: [for images and spectra] Do not include stars in spectrum or images. Only the circumstellar / inter-
stellar material is imaged as if a perfect coronograph is used.
• inclline: Include line emission and extinction in the ray tracing (for images and spectra).
• noline: Do not include line emission and extinction in the ray tracing (for images and spectra).
• incldust: Include dust emission, extinction and (unless it is switched off) dust scattering in ray tracing (for
images and spectra).
• nodust: Do not include dust emission, extinction and scattering in ray tracing (for images and spectra).
• maxnrscat 0: (if dust is included) Do not include scattering in the images/spectra created by the camera.
With maxnrscat 1 you limit the scattering in the images/spectra to single-scattering. With maxnrscat 2
to double scattering, etc. Can be useful to ﬁgure out the relative importance of single vs multiple scattering.
182
Chapter 18. Command-line options

CHAPTER
NINETEEN
WHICH OPTIONS ARE MUTUALLY INCOMPATIBLE?
For algorithmic reasons not all options / coordinate systems and all grids are compatible with each other. Here is an
overview of which options/methods work when. Note that only options/methods for which this is a possible issue are
listed.
19.1 Coordinate systems
Some coordinate systems exclude certain possibilities. Here is a list.
Option/Method:
Cart 3D
Sph 3D
Sph 2D (axisymm)
Sph 1D
Second order ray-tracing
yes
yes
yes
yes
Isotropic scattering
yes
yes
yes
yes
An-isotropic scattering for thermal Monte Carlo
yes
yes
yes
yes
An-isotropic scattering for monochromatic Monte Carlo
yes
yes
yes
yes
An-isotropic scattering for images and spectra
yes
yes
yes
no
Full Stokes scattering for thermal Monte Carlo
yes
yes
yes
yes
Full Stokes scattering for monochromatic Monte Carlo
yes
yes
yes
yes
Full Stokes scattering for images and spectra
yes
yes
yes
no
Gas lines
yes
yes
yes
yes
Gas lines and Doppler-shift line catching
yes
yes
no
no
19.2 Scattering off dust grains
The inclusion of the effect of scattering off dust grains in images and spectra typically requires a separate Monte Carlo
computation for each image. This is done automatically by RADMC-3D. But it means that there are some technical
limitations.
Option/Method:
No scatter-
ing
Isotropic
approxi-
mation
Full anisotropic/Stokes scat-
tering
Fast multi-frequency ray tracing for spectra
(auto)
yes
no
no
Multiple images at different vantage point
at once
yes
yes
yes
Local observer
yes
yes
no
183

radmc3d, Release 2.0
19.3 Local observer mode
The local observer mode (Sect. For public outreach work: local observers inside the model) is a special mode for
putting the observer in the near-ﬁeld of the object, or even right in the middle of the object. It is not meant to be really
for science use (though it can be used for it, to a certain extent), but instead for public outreach stuff. However, it
is kept relatively basic, because to make this mode compatible with all the functions of RADMC-3D would require
much more development and that is not worth it at the moment. So here are the restrictions:
Option/Method:
Local observer mode
Dust isotropic scattering
yes
Dust an-isotropic scattering
no
Multiple images at different vantage point at once
yes
Second-order ray-tracing
yes
Doppler-catching of lines
no
184
Chapter 19. Which options are mutually incompatible?

CHAPTER
TWENTY
ACQUIRING OPACITIES FROM THE WWW
Opacities are the basic ingredients necessary for any model with RADMC-3D. The example models in this package
contain example opacities, but for professional usage of RADMC-3D it may be necessary to get speciﬁc opacity data
from the web. These opacity data are usually in a wide variety of formats. To enable RADMC-3D to read them usually
requires a conversion into RADMC-3D-readable form (see Section INPUT (required for dust transfer): dustopac.inp
and dustkappa_*.inp or dustkapscatmat_*.inp or dust_optnk_*.inp for dust opacities and Section INPUT: Molecu-
lar/atomic data: The molecule_XXX.inp ﬁle(s) for gas line opacities).
To make it easier for the user to create RADMC-3D-readable input ﬁles from opacity data downloaded from the web,
we now feature a new directory opac/ in the RADMC-3D distribution in which, for several of the most common
WWW databases, we provide Python routines for the conversion. Please read the README_* ﬁles in this directory
and its subdirectories for details.
185

radmc3d, Release 2.0
186
Chapter 20. Acquiring opacities from the WWW

CHAPTER
TWENTYONE
VERSION TRACKER: DEVELOPMENT HISTORY
This version overview is very rough, and has only been started as of version 0.25.
• Version 0.25
– Second order integration, based on a vertex-based grid (as opposed to the usual cell-based grid), imple-
mented. This gives much smoother images, and you don’t see the blocky cell structure anymore in the
images. It requires extra memory, though. See Section Second order ray-tracing (Important information!).
– The number of photons for scattering Monte Carlo (i.e. the small MC run done before each image, if
dust scattering is active) can now be chosen to be smaller for when you make a spectrum instead of an
image. Reason: Since you anyway integrate over the images for a spectrum, you do not need the image
to ‘look nice’, i.e. you can afford more photon noise. You can set this in radmc3d.inp by setting
nphot_spec=10000, for instance. See Section Scattered light in images and spectra: The ‘Scattering
Monte Carlo’ computation.
• Version 0.26
– For line transfer: Added the ‘doppler catching’ method to the code. This prevents bad numerical artifacts in
images/spectra of regions with large velocity gradients, where the doppler-shift between two neighboring
cells exceeds the intrinsic line width of the material in the cell. See Section Preventing doppler jumps:
The ‘doppler catching method’.
– NOTE: Up to, and including, version 0.26_23.02.11 this method (and for that matter any second order
integration of line transfer) was not stable when strong shocks or contact discontinuities were encountered.
This was because interpolation of the source function 𝑆𝜈≡𝑗𝜈/𝛼𝜈was done. Experimentation showed
that interpolation of the emissivity 𝑗𝜈is much more stable. As of version 0.26_27.02.11 this is ﬁxed.
• Version 0.27
– For line transfer: Implemented the possibility to use a Voigt line proﬁle instead of just a Gaussian. This
was implemented by Thomas Peters, and slightly modiﬁed by CPD. It uses the Voigt approximation by
Humlicek JQSRT 27, 437 (1982) as programmed by Schreier, JQSRT 48, 743 (1992). It requires a user-
deﬁned subroutine userdef_compute_lorentz_delta() that sets the value of the Lorentz proﬁle
delta. This implementation is not yet documented, and may still be subject to modiﬁcation.
– Implemented the ‘Large Velocity Gradient’ (LVG) method (also called the Sobolev method) of approxi-
mate non-LTE line transfer.
– Implemented the optically thin populations method.
– Implemented the possibility of reading linelist molecular data instead of full molecular data. Still needs
testing.
– Finally implemented the positive lines_mode modes, i.e. in which the level populations are computed
and stored globally before the ray-tracing. This has been latently in the code somewhat, but unﬁnished.
Now it is implemented. The advantage is: it may be under some conditions much faster than the on-the-ﬂy
187

radmc3d, Release 2.0
computation of the populations during the ray-tracing (the negative lines_mode modes). Also it allows
you to write the populations to ﬁle, so that you can examine them. Disadvantage: It is memory hungry.
– The level subset capacilities are now limited to only the storage of the levels in the global arrays (for
positive lines_mode modes), and to the lines that will appear in images/spectra. For the rest, the full
set of levels are always used from now on.
– Added a directory ‘opac/’ which contains programs for generating your own dust opacities using optical
constants from the web, and for generating your own molecular/atomic input data ﬁles using data from
several web pages. The data from the web are not included, but there are README ﬁles that point you to
the web sites.
– Tested the ‘ﬁsheye’ fulldome (OMNIMAX) projection. It seems to work! Thanks to Mario Flock.
– Several small (and bigger) bugﬁxes
* Fixed bug that showed up when no dust is included.
* Fixed bug that caused RADMC-3D to crash when using no stars.
* Fixed bug that caused RADMC-3D to crash when making images at very short wavelengths with
nearly zero thermal emission.
* Fixed bug in the AMR module when using second order integration or the doppler catching method
with certain kinds of AMR-arrangements of cells.
* Fixed many bugs when using a ‘piece of a cake’ model, i.e. using spherical coordinates in 3-D, but
having the 𝜑-grid going not over the full 0 −2𝜋range but e.g. just from 0 to 𝜋/4. It is rather rare
that one really wants to use such grids (certainly not for real physical models, I presume), but for
visualization of data it might be useful: for instance for visualizing a 3-D disk MHD model, which is
cut open so you can see also to the midplane. Now it works. Thanks to Mario Flock.
* Fixed bug with the aperture mode for spectra. Thanks to Daniel Harsono.
* Fixed many bugs in linelist mode; now it works. Thanks to Attila Juhasz.
* Fixed a bug in LVG mode that caused it to fail when AMR was used. Thanks to Anika Schmiedeke.
* Fixed a tiny bug in idl/radmc3dfits.pro: ﬁlename was unused. Thanks to Stella Offner.
* Retroactive bugﬁx from version 0.28 (see below): LVG and AMR mode.
For details and for smaller bugﬁxes, read the src/Radmc_3D_LOG.txt document.
• Version 0.28
– A number of people complained that even without AMR the code requires a huge amount of memory.
That is because even if no AMR is used, the cells are connected via the AMR tree. Since the AMR cells
contain information about which are the neighboring cells, and each cell has 6 neighbors, and slots for 8
child-cells (which are unused in case of a regular grid) this wastes a lot of memory space. The ﬁrst big
improvement in version 0.28 is that, from now on, the AMR tree is only set up and used if the grid indeed
has reﬁnement. If RADMC-3D notices that the grid is regular, it will not allocate space for the AMR tree,
and everywhere in the code where the cell-management is done the code will switch to regular grid mode.
There is now a ﬂag amr_tree_present that says whether the AMR tree is present or not. Throughout
the code there are now if-statements to switch between using or not-using the AMR tree. This may make
the code a tiny bit slower, but this is only a minor reduction of speed. But as a result it should now be
much easier to load huge regular grid models into memory.
– A small (but potentially nasty) bug was found and ﬁxed for the case when you use LVG mode on a grid with
AMR-reﬁnements. For the regular grid case (even in version 0.27, when it still used the AMR tree) this
bug should not have caused problems, but perhaps you might want to check nevertheless. Note: This bug
is now also retroactively ﬁxed in version 0.27. See, as always, src/Radmc_3D_LOG.txt for details.
188
Chapter 21. Version tracker: Development history

radmc3d, Release 2.0
– Added the possibility to visualize the location (along the line of sight) of the 𝜏= 1 surface (or any 𝜏= 𝜏𝑠
surface for that matter). See new Section Visualizing the \tau=1 surface. This can be very useful for getting
a 3-D feeling for where certain emission comes from.
• Version 0.29
– The big change in this version is that the whole stuff with the global storage of level populations has
been improved. In earlier versions of RADMC-3D, either the populations of all levels of a molecule were
stored globally (potentially requiring huge amounts of memory), or you would have to select a ‘subset’
of levels to store globally. This subset selection had to be done by the user (‘manually’, so to speak).
You would have had to think a-priori which lines you wish to model, and which levels they connect, and
then, in the lines.inp ﬁle you would have to select these levels by hand. That was cumbersome and
prone to error. To avoid having to do this you could use ‘on-the-ﬂy’ calculation of populations (by making
the lines_mode negative), but that sometimes caused the code to become terribly slow. Now this is
dramatically improved: From now on you can forget about the ‘on-the-ﬂy’ calculation of populations. Just
use the ‘normal’ way by which RADMC-3D ﬁrst calculates the populations and then starts the ray-tracing.
The subset-selection is now done automatically by RADMC-3D, based on which wavelengths you want to
make the image(s) or spectra for (see Section Background information: Calculation and storage of level
populations). Now the on-the-ﬂy methods are no longer default and should not be used, unless absolutely
necessary. Also the ‘manual’ subset selection is no longer necessary (though still possible if absolutely
desired).
– Added the subbox and sample capabilities to the level populations. See Sections Making a regularly-
spaced datacube (‘subbox’) of AMR-based models and Alternative to subbox: arbitrary sampling of AMR-
based models. Note that, in order to make it easier to identify which levels were written to ﬁle, the ﬁle
formats of ***_subbox.out and ***_sample.out have been slightly modiﬁed: A list of identiﬁca-
tion numbers is added before the main data. For the dust temperature and dust density this list is simply 1
2 3 4 ... (dust species 1, dust species 2, dust species 3 ...), which is trivial. For the level populations (e.g.
the ﬁle levelpop_co_subbox.out and levelpop_co_sample.out for the CO molecule) this
list is, however, essential when not all levels were computed (see Section Background information: Cal-
culation and storage of level populations). So if only level 4 and level 8 are stored, then the identiﬁcation
list is 4 8.
– Fixed a bug which caused the code to crash when you put a star substantially far outside of the domain and
try to make an image or spectrum. Thanks, Erika Hamden, for the bug report.
– Fixed a bug that prevented the lines_mode=50 mode from working. Now it works, and we can ask
RADMC-3D to read the level populations from ﬁle (rather than calculating them internally). Also a new
section was added to this manual describing this option (Section Non-LTE Transfer: Reading the level
populations from ﬁle).
– Added VTK output options (see chapter Visualization with VTK tools (e.g. Paraview or VisIt)) for allowing
3-D visualization of your model setups using e.g. Paraview, a freely available visualization tool.
– Fixed a bug that occurred sometimes if a spectrum was made at inclination 90 and phi 90. Thanks Stella
Offner for reporting this bug.
• Version 0.30
– Fixed bugs in the Henyey-Greenstein scattering mode.
– Introduced the new binary I/O feature: No more hassle with f77-unformatted records! The new binary
mode is much simpler and more straightforward. This will help reducing the ﬁle sizes for large models.
See Chapter Binary I/O ﬁles.
• Version 0.31
– Added the possibility, in cartesian coordinates, to ‘close the box’, in the sense of making the domain
boundaries thermal walls. Each of the 6 boundaries can be set separately, so you can also have just one
189

radmc3d, Release 2.0
thermall wall. Also the temperatures can be set separately for each of the 6 boundaries. See Section
Thermal boundaries in Cartesian coordinates.
– Added two new coordinate systems:
* Cartesian 1-D plane-parallel (the only remaining active coordinate is 𝑧). The 𝑥and 𝑦dimensions are
inﬁnitely extended and have translational symmetry. The photons can, however, travel in full 3-D as
always. See Section 1-D Plane-parallel models.
* Cartesian 2-D pencil-parallel (the two remaining active coordinate are 𝑦and 𝑧). The 𝑥dimension is
inﬁnitely extended and has translational symmetry. The photons can, however, travel in full 3-D as
always.
* For the 1-D plane-parallel mode it is possible to include parallel beams of radiative ﬂux impinging on
the 1-D atmosphere.
* Attila Juhasz has improved the VTK output: Now it also supports 3-D spherical coordinates. Thanks,
Attila!
• Version 0.32
This is an intermediate version in which some stuff for the near-future modus of polarization is implemented.
• Version 0.33
– Some minor technical changes to the doppler-catching integration of lines (storing the upper and lower
level population instead of the jnubase and anubase variables).
– Added the classical escape probability to the LVG mode (see Section Non-LTE Transfer: The Large Ve-
locity Gradient (LVG) + Escape Probability (EscProb) method for details).
– Sped up the ﬁlling of the matrix of the statistical equilibrium equation.
– Vastly improved the LVG (and esc prob) method: Instead of the simple ‘lambda iteration style’ iteration
as it was before, the 𝐴𝑖𝑘is now multiplied with 𝛽𝑖𝑘(the escape probability of the line i->k) and the 𝐽𝑖𝑘is
replaced by 𝐽background
𝑖𝑘
. This means that the solution is almost instant, requiring only 2 or 3 iterations.
• Version 0.34
Implemented the Modiﬁed Random Walk method, based on Min, Dullemond, Dominik, de Koter & Hovenier
(2009) A&A 497, 155, and simpliﬁed by Robitaille (2010) A&A 520, 70. But beware: Still in the testing phase!
By default it is switched off.
• Version 0.35
– Implemented polarized scattering off randomly oriented particles. But beware: Still in the testing phase!
– Fixed a bug in the modiﬁed random walk method (thanks to Daniel Harsono for spotting the problem and
thanks to Attila Juhasz for ﬁnding the ﬁx!)
– Fixed two bugs that made it impossible to use second order integration with axially symmetric spherical
coordinates and/or a ﬁnite-size star (thanks to Rolf Kuiper for reporting the bug).
– Added the sloppy command line option to spectrum and image making in spherical coordinates. This
was necessary because RADMC-3D is always trying to make 100% sure that all cells are picked up by
the subpixels. In spherical coordinates these cells can be extremely non-cubic (they can be extremely ﬂat
or needle-like), which means that under some projections RADMC-3D feels obliged to do extreme sub-
pixeling, which can make image- and spectrum-making extremely slow. By adding the sloppy keyword
on the command line, RADMC-3D will limit it’s pubpixeling which could speed up the calculation very
much (but of course at your own risk!).
• Version 0.38
– Implemented OpenMP parallellization of the thermal Monte Carlo (by Adriana Pohl). Still beta-version.
190
Chapter 21. Version tracker: Development history

radmc3d, Release 2.0
– Bugﬁx in the mean intensity computation (mcmono) mode (thanks to Gwendoline Stephan).
– Bugﬁx in the mean intensity computation (mcmono) mode (thanks to Seokho Lee).
– Major bugﬁx in aperture mode (thanks to So ren Frimann).
– Unformatted image format is from now on C-style binary instead of F77-style unformatted.
– The viewimage tool is now ported to Qt by Farzin Sereshti, meaning that you can now use viewim-
age without having an IDL license. Viewimage is a very powerful tool to interactively make and view
images of your model at different wavelengths and viewing angles. It can be found in the directory
viewimage_QT_GUI/.
– A Python package for RADMC-3D was developed by Attila Juhasz. It is included as of RADMC-3D
version 0.38 in the directory python/.
• Version 0.39
– Polarization mode is incompatible with mirror mode (in spherical coordinates). An error message is now
included to catch this.
– Minor bugﬁx in pick_randomfreq_db() (thanks to Seokho Lee).
– Optimization of the OpenMP parallellization and extension of the OpenMP parallellization to the Scatter-
ing Monte Carlo computation (both by Farzin Sereshti).
– Bugﬁx in amrray_module.f90: Sometimes one got ‘Photon outside of cell’ error due to a numerical
precision round-off error. This bug is now (mostly?) ﬁxed.
– Bugﬁx in sources_module.f90: When using second order integration (or doppler catching) for line
transfer in spherical coordinates, the line doppler shift was not transformed to spherical coordinates. This
is now ﬁxed.
– Several bugﬁxes in the modiﬁed random walk method by John Ramsey. The method crashed for extreme
optical depth problems due to out-of-cell events. Still not 100% perfect, but better.
– John Ramsey also proposed two small ﬁxes to the Planck function routines so that the events of overﬂow
are caught. Note: This might change the results (in a tiny way: at the machine precision level) to the
extent that a model run by an old version might not yield the same values to machine precision, but the
differences should not matter in any meaningful way.
• Version 0.40
– The RADMC-3D package is now ‘ofﬁcially’ converting from IDL to Python wrappers. The Python mod-
ules were already there since a long time (thanks to Attila Juhasz!). But as of version 0.40 we will no
longer update/maintain the IDL scripts (though they remain there and should remain working), and instead
use python as the main setup and analysis tools for RADMC-3D. The full conversion will still take some
time, but should be ﬁnished by the end of version 0.40.
– Under some circumstances the simple 2x2 pixel plus sub-pixeling method for making spectra (default
method) can be dangerous. For some grid geometries this can lead to under-resolving of the images that
are integrated to obtain the ﬂux, leading to a too low ﬂux. So as of now 15.09.2016 the spectra and SEDs
are always by default made with 100x100 images (and sub-pixeling of course). One can set the number of
pixels with npix. So if you do radmc3dsednostarnpix2 you get the original behavior again.
– Bugﬁx in montecarlo_module.f90: The internal heat source method (which is still being tested)
had a bug. The bug manifested itself for optically thin cells with non-negligible internal heat production.
The energy was not immediately added to the cell. It only got added upon re-absorption of that photon
package. Now this is ﬁxed.
– I now added some documentation for the heat source method, which is useful for e.g. disk viscous accretion
heating.
191

radmc3d, Release 2.0
– Bugﬁx in montecarlo_module.f90: When using mirror symmetry in spherical coordinates in the
𝜃-coordinate (i.e. modeling only the upper part of the disk and letting RADMC-3D assume that the lower
part is identical), the distributed source luminosity was computed only for the top quadrant, and wasn’t
multiplied by 2. For most applications this does not cause problems, but for the heat source (see above),
for continuous stellar sources and for the thermal origin of the isotropic scattering luminosity (for non-
isotropic scattering, mirror symmetry was not allowed anyway), this could lead to a factor of 2 underesti-
mation (only if mirror symmetry was used, i.e. if the 𝜃coordinate was going only up to 𝜋/2). This is now
ﬁxed. To test if the ﬁx works one can simply make the same model again, but now without using mirror
symmetry (and thus using twice as many cells in 𝜃, to cover both the upper and lower half of the object).
This should yield (apart from some Monte Carlo noise) the same results.
– Improved the stability of the Modiﬁed Random Walk (MRW) method a bit further.
– Bug ﬁx: scattering mode 3 (tabulated phase function, but not full polarization) had a bug which caused
images of scattered light to be multiplied by some arbitrary number. Reason: as a phase function it returned
𝑍11 instead of 4𝜋𝑍11/𝜅scat. Most people use either isotropic scattering (scattering mode 1), or Henyey-
Greenstein (scattering mode 2) or full polarization (scattering mode 5), all of which are ok. At any rate:
the problem is now ﬁxed, so scattering mode 3 should now also work.
• Version 0.41
– Implemented a ﬁrst testing version of the aligned grains: only polarized thermal emission so far. Still very
much a testing version.
– Implemented a method to also allow full Stokes vector polarized scattering in the 2-D axisymmetric mode
in spherical coordinates. Until now the full scattering mode (scattering mode 5) was only possible in full
3-D. Note however that anisotropic scattering in 2-D axisymmetric models requires scattering mode 5,
which is the full scattering mode. It is still not possible to use intermediate scattering modes (like henyey-
greenstein or any scattering mode between 2 and 4) in 2-D axisymmetry. But those intermediate modes
are anyway more for testing than for real models, so that should be ok.
– Bugﬁxes to the OpenMP stuff. In particular the OpenMP parallellization of the scattering MC crashed.
This is now ﬁxed. In general the OpenMP stuff was a bit cleaned up.
– Bugﬁx in thermal Monte Carlo with full polarization mode: needed to reset the photon package after each
thermal absorption/re-emission event. Usually the effect is subtle, but had to be ﬁxed.
– Bugﬁx in reading the scattering_angular_grid.inp: the theta angles should be converted
into radian. But this ﬁle was not ofﬁcially offered before anyway.
– Attila Juhasz has made a large improvement of his python package for RADMC-3D. See the python/
directory. This is version 0.29 of his package. This package now also supports reading and writing AMR
grids.
– Bugﬁx in VTK for 3-D spherical coordinates (thanks Attila Juhasz!). Now it should work.
• Version 2.0
Version 2.0 is the version after 0.41. We skip version 1.0, because version 1.0 could be mistaken for the ﬁrst
version of the code. Version 2.0 is mostly the same as 0.41, but with a few differences.
– IDL support is removed permanently. From now on, the front-end functionality is only in Python. We
assume Python 3.
– Version 0.30.2 of the radmc3dPy Python package (written by Attila Juhasz) has been implemented. It is
also being improved, mainly to make its use easier (i.e. with more automatic default behavior).
– A very simple simpleread.py reading library is provided as a ‘light version’ of radmc3dPy. It contains
only some basic reading functions, and only for ascii output (no binary ﬁles).
192
Chapter 21. Version tracker: Development history

radmc3d, Release 2.0
– Some of the standard-output is shortened. You can also call a Monte Carlo run with radmc3d with the
command line options countwrite 100000 to make RADMC-3D write a message only every 105
photon packages instead of every thousand.
– We removed the fortran-unformatted data format from the manual, and will remove it from the code in
later versions. Use either text (ascii) format or binary format.
– The manual is now converted to Sphinx, from which the LaTeX version and the HTML version can be
automatically created.
193

radmc3d, Release 2.0
194
Chapter 21. Version tracker: Development history

CHAPTER
TWENTYTWO
INDICES AND TABLES
• genindex
• modindex
• search
195

