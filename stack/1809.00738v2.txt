arXiv:1809.00738v2  [math.CT]  7 Sep 2018
Categories of Optics
Mitchell Riley
Wesleyan University
mvriley@wesleyan.edu
Abstract
Bidirectional data accessors such as lenses, prisms and traversals are all instances of the same
general ‘optic’ construction. We give a careful account of this construction and show that it extends
to a functor from the category of symmetric monoidal categories to itself. We also show that this
construction enjoys a universal property: it freely adds counit morphisms to a symmetric monoidal
category. Missing in the folklore is a general deﬁnition of ‘lawfulness’ that applies directly to any optic
category. We provide such a deﬁnition and show that it is equivalent to the folklore profunctor optic
laws.
Contents
1
Introduction
1
2
Optics
3
3
Lawful Optics
22
4
Examples
27
5
The Profunctor Encoding
40
6
Future Work
47
1
Introduction
In its most concrete form, a lens S p→A is a pair of maps Get : S →A and Put : S × A →S. From an
engineering standpoint, such a lens allows us to “zoom in” on S to focus on a small part A, manipulate
A in some way, then “zoom out” and have our changes reﬂected in S [FGM+07].
So that our lenses better adhere to this intuitive idea of “zooming in”, we often want them satisfy
some conditions known as the lens laws:
S × A
S
A
Put
π2
Get
PutGet
S
S × A
S
[idS,Get]
idS
Put
GetPut
S × A × A
S × A
S × A
A
Put×A
π1,3
Put
Put
PutPut
We call such lenses lawful. The PutGet law states that any update to A is represented faithfully in S.
The GetPut law states that if A is not changed then neither is S; and ﬁnally, the PutPut law states
that any update to A completely overwrites previous updates.
1

Lenses form a category, with the composition of two lenses (Get1, Put1) : T p→S and (Get2, Put2) :
S p→A as indicated:
Get : T
Get1
−−−→S Get2
−−−→A
Put : T × A
[idT ,Get1]×A
−−−−−−−−−→T × S × A T×Put2
−−−−−→T × S Put1
−−−→T
If the two input lenses are lawful then the composite is as well, so we ﬁnd there is a subcategory of lawful
lenses.
Lenses were discovered to be just one of a hierarchy of data accessors, including prisms, setters,
traversals and more. These are collectively called optics and have been best explored in the widely uesd
Haskell lens library: see [Kme]. Each optic variant has a concrete description as a certain collection of
maps, with attendant laws under which we consider them well-behaved, similar to the pair (Get, Put)
above and the lens laws. We begin in Section 2 by deﬁning the category of optics for a symmetric monoidal
category in a suﬃciently general way to encompass almost all the optic variants in use in the wild, using
lenses as a running example. The category of lenses is precisely the result of this construction when
applied to a symmetric monoidal category where the tensor is given by binary product. Section 3 deﬁnes
the equivalent of the lens laws for a general category of optics. Then in Section 4 we see that these generic
deﬁnitions specialise correctly to the other basic varieties of optic, including the laws.
When implementing optics, library authors often use a form known as the profunctor encoding, which
at ﬁrst glance is completely diﬀerent to that given in Section 2. (The Haskell lens library itself actually
uses a variant called the van Laarhoven encoding, for reasons of eﬃciency and backwards compatibility.)
As this was being written, Milewski [Mil17] and Boisseau and Gibbons [BG18] independently described
the isomorphism between optics and their profunctor encoding. In Section 5 we review this isomorphism
and verify that the folklore profunctor optic laws are equivalent to lawfulness as deﬁned here.
More recently, concrete lenses have found use in compositional game theory [GH18]. The Get function
is thought of as mapping observations on the state of play to choices of what move to make. The Put
function computes the utility of the moves that the players choose. There is interest in generalising this
to a probabilistic setting, but it is not yet clear what the right replacement for concrete lenses is.
Much of what is known about optics is folklore, and careful veriﬁcation of some of their categorical
properties has been lacking, especially when working in categories other than Set (or Set-like categories
such as Hask). The aim of the present paper is to ﬁll this gap, with the hope that a better understanding
of the general structure of these categories will make it easier to generalise optics to new and exotic
settings. This is particularly important with the advent of linear types in Haskell, enabling a new branch
of the lens family tree, and also with the new applications to game theory.
1.1
Contributions
• A careful account of the folklore optic construction in an arbitrary symmetric monoidal category C,
which we show extends to a functor Optic : SymmMonCat →SymmMonCat (Section 2),
• A universal property of the Optic construction as freely adding counits to a category of ‘dualisable
morphisms’ (Section 2.1),
• A deﬁnition of lawfulness for a general optic category that specialises in the correct way to known
cases and allows us to derive concrete laws for new kinds of optic (Section 3),
• Commentary on the optic variants used most frequently in the wild (Section 4),
• A proof that lawfulness as deﬁned here is equivalent to the folklore profunctor optic laws (Section 5).
2

1.2
(Co)ends and Yoneda Reduction
In this paper we will make frequent use of the (co)end calculus. For a comprehensive introduction to ends
and coends, see [Lor15]. We write coprX : F(X, X) →
R X∈M F(X, X) for the structure maps of a coend.
The most important results for us regarding ends and coends are:
Lemma 1.2.1 (Coend as coequaliser). If E is cocomplete and M is small, the coend of P : Mop × M →E
can be calculated as the coequaliser in the diagram
a
M→N
P(N, M)
a
M∈M
P(M, M)
Z M∈M
P(M, M)
Lemma 1.2.2 (Ninja Yoneda Lemma/Yoneda Reduction). For every functor K : Cop →Set and H :
C →Set, we have the following natural isomorphisms:
KX ∼=
Z C∈C
KC × C(X, C)
KX ∼=
Z
C∈C
Set(C(C, X), KC)
HX ∼=
Z C∈C
HC × C(C, X)
HX ∼=
Z
C∈C
Set(C(X, C), HC)
where the isomorphisms are given by inclusion with the identity morphism C(X, X) for the left two, and
evaluation at the identity morphism on the right.
Theorem 1.2.3 (Fubini Theorem). For a functor F : Cop × C × Dop × D →E, there are canonical
isomorphisms
Z C∈C Z D∈D
F(C, C, D, D) ∼=
Z (C,D)∈C×D
F(C, C, D, D) ∼=
Z D∈D Z C∈C
F(C, C, D, D)
Lemma 1.2.4 (Mute coends). Consider a functor F : C →E as a functor Cop × C →E that ignores its
contravariant argument. Then
Z C∈C
F(C) ∼= colim F.
2
Optics
We begin by deﬁning the category of optics for a symmetric monoidal category. This category was ﬁrst
deﬁned in [PS08, Section 6] as the ‘double’ of a monoidal category. There it was used for a completely
diﬀerent purpose—to investigate the relationship between Tambara modules and the ‘center’ of a monoidal
category. Our deﬁnition is almost identical, the only diﬀerences being that we have ﬂipped the direction
of the morphisms to match the existing work on lenses and restricted our attention to the unenriched
setting.
Our deﬁnition of optic has as domain and codomain pairs of objects of C, one of which behaves
covariantly and the other contravariantly. For example, our lenses will be pairs of maps Get : S →A and
Put : S × A′ →S′. This generality is important for the applications to game theory, and in fact helps in
calculations by making the covariant and contravariant positions more diﬃcult to confuse. Readers more
familiar with lenses should ignore the primes.
In this section we work with a ﬁxed symmetric monoidal category (C, ⊗, I), with associator α and uni-
tors λ and ρ. To avoid getting lost in the notation we will use the standard cheat of omitting associativity
morphisms and trust that the dedicated reader could insert them everywhere they are needed.
3

Deﬁnition 2.0.1. Given two pairs of objects of C, say (S, S′) and (A, A′), an optic p : (S, S′) p→(A, A′)
is an element of the set
OpticC((S, S′), (A, A′)) :=
Z M∈C
C(S, M ⊗A) × C(M ⊗A′, S′)
Because this coend takes place in Set, we can use Lemma 1.2.1 to describe OpticC((S, S′), (A, A′))
explicitly. It is the set of pairs (l, r), where l : S →M ⊗A and r : M ⊗A′ →S′, quotiented by the
equivalence relation generated by relations of the form
((f ⊗A)l, r) ∼(l, r(f ⊗A′))
for any l : S →M ⊗A, r : N ⊗A′ →S′ and f : M →N.
For a pair of maps l : S →M ⊗A and r : M ⊗A′ →S′, we write ⟨l | r⟩: (S, S′) p→(A, A′) for their
image in OpticC((S, S′), (A, A′)), and say that the object M is the residual for this representative. Optics
will always be written with a crossed arrow
p→to distinguish them from morphisms of C.
The residual M should be thought of as a kind of ‘scratch space’; information from S that we need to
remember to construct S′. The quotienting imposed by the coend means we cannot inspect this temporary
information, indeed, given an optic S p→A there is not even a canonical choice for the object M in general.
Elements of OpticC((S, S′), (A, A′)) have an appealing interpretation as string diagrams with a “hole”
missing. We draw the pair ⟨l | r⟩as
l
r
S
A
S′
A′
reading left to right, so the portion of the diagram to the left of the line represents l and the right portion
r. The relation expressed by the coend can be drawn graphically as:
l
r
S
A
S′
A′
f
∼
l
r
S
A
S′
A′
f
We will therefore omit the vertical cut between l and r in most subsequent diagrams; any choice yields a
representative of same optic.
A common use of the coend relation is to introduce or cancel isomorphisms. Given l : S →M ⊗A
and r : M ⊗A →S, for any isomorphism f : M →N we have
⟨l | r⟩=

(f −1 ⊗A)(f ⊗A)l | r

=

(f ⊗A)l | r(f −1 ⊗A)

Diagrammatically, this is the equality
l
r
S
A
S′
A′
=
l
r
S
A
S′
A′
f
f −1
4

Example 2.0.2.
(1) For any three objects M, A, A′ ∈C, there is the tautological optic
tM,A,A′ : (M ⊗A, M ⊗A′) p→(A, A′)
given by ⟨idM⊗A | idM⊗A′⟩. This would be drawn as follows:
M
M
A
A
A′
A′
(2) We also have the identity optic id(S,S′) : (S, S′) p→(S, S′), given by

λ−1
S
| λS′
, where λS : I ⊗S →S
is the left unitor for S and similarly for S′.
The identity optic is drawn as
λ−1
S
λS′
S
S
S′
S′
This dashed line above the diagram represents the unit object. It is common in string diagrams to
omit unitors and the unit object unless they are necessary to make sense of the diagram. We therefore
prefer to draw the identity morphism as:
S
S
S′
S′
Optics compose as follows. The easiest interpretation is graphical: composition corresponds to substi-
tuting the ﬁrst optic for the hole of the second:
l
r
S
A
S′
A′
◦
l′
r′
R
S
R′
S′
:=
l′
l
r′
r
A
A′
R
R′
More formally, we wish to construct a map
 Z M∈C
C(S, M ⊗A) × C(M ⊗A′, S′)
!
×
 Z N∈C
C(R, N ⊗S) × C(N ⊗S′, R′)
!
→
Z M∈C
C(R, M ⊗A) × C(M ⊗A′, R′).
5

The product in Set preserves colimits, so in particular coends. Using this fact and the Fubini theorem
for coends, the domain is isomorphic to
Z (M,N)∈C×C
C(S, M ⊗A) × C(M ⊗A′, S′) × C(R, N ⊗S) × C(N ⊗S′, R′).
So by the universal property of coends, it suﬃces to construct maps
C(S, M ⊗A) × C(M ⊗A′, S′) × C(R, N ⊗S) × C(N ⊗S′, R′)
→
Z M∈C
C(R, M ⊗A) × C(M ⊗A′, R′).
natural in M and N. For these we use the composites
C(S, M ⊗A) × C(M ⊗A′, S′) × C(R, N ⊗S) × C(N ⊗S′, R′)
→C(N ⊗S, N ⊗M ⊗A) × C(N ⊗M ⊗A′, N ⊗S′) × C(R, N ⊗S) × C(N ⊗S′, R′)
(functoriality of N ⊗−)
→C(R, N ⊗M ⊗A) × C(N ⊗M ⊗A′, R′)
(composition in C)
→
Z P ∈M
C(R, P ⊗A) × C(P ⊗A′, R′)
(coprN⊗M)
Written equationally, suppose ⟨l′ | r′⟩: (R, R′) p→(S, S′) and ⟨l | r⟩: (S, S′) p→(A, A′) are optics with M
the residual for ⟨l′ | r′⟩. The composite (R, R′) p→(A, A′) is then:
⟨l | r⟩◦

l′ | r′
:=

(M ⊗l)l′ | r′(M ⊗r)

.
Proposition 2.0.3. The above data form a category OpticC.
Proof. In [PS08, Section 6] this is proven abstractly by exhibiting this category as the Kleisli category for
a monad in the bicategory Prof. We prefer a direct proof.
Suppose we have representatives of three optics
⟨l1 | r1⟩: (R, R) p→(S, S′)
⟨l2 | r2⟩: (S, S′) p→(A, A′)
⟨l3 | r3⟩: (A, A′) p→(B, B′),
that have residuals M, N and P respectively. We must choose these representatives simultaneously but,
as in the deﬁnition of composition, this is allowed by the Fubini theorem. Then:
(⟨l3 | r3⟩◦⟨l2 | r2⟩) ◦⟨l1 | r1⟩= ⟨(N ⊗l3)l2 | r2(N ⊗r3)⟩◦⟨l1 | r1⟩
= ⟨(M ⊗((N ⊗l3)l2))l1 | r1(M ⊗(r2(N ⊗r3)))⟩
= ⟨(M ⊗N ⊗l3)(M ⊗l2)l1 | r1(M ⊗r2)(M ⊗N ⊗r3)⟩
= ⟨l3 | r3⟩◦(⟨(M ⊗l2)l1 | r1(M ⊗r2)⟩)
= ⟨l3 | r3⟩◦(⟨l2 | r2⟩◦⟨l1 | r1⟩)
6

For the unit laws, suppose we have ⟨l | r⟩: (S, S′) p→(A, A′) with representative M. We calculate:
idA,A′ ◦⟨l | r⟩=

λ−1
A | λA′
◦⟨l | r⟩
=

(M ⊗λ−1
A )l | r(M ⊗λA′)

=

(ρ−1
M ⊗A)l | r(ρM ⊗A′)

=

l | r(ρM ⊗A′)(ρ−1
M ⊗A′)

= ⟨l | r⟩
⟨l | r⟩◦idS,S′ = ⟨l | r⟩◦

λ−1
S
| λS′
=

(I ⊗l)λ−1
S
| λS′(I ⊗r)

=

(λ−1
M ⊗S)l | r(λM ⊗S′)

=

l | r(λM ⊗S′)(λ−1
M ⊗S′)

= ⟨l | r⟩
In both cases we have used the coend relation to cancel an isomorphism appearing on both sides of an
optic.
Note that the homsets of OpticC are given by a coend indexed by a possibly large category.
If
C is small then these coends always exist, but if C is not small their existence is not guaranteed by the
cocompleteness of Set. Because of this we should be careful to only discuss optic categories where we know
that the coends exist by some other means, e.g., by exhibiting an isomorphism of OpticC((S, S′), (A, A′))
with a set. For all of the examples we give later we provide such a isomorphism.
Proposition 2.0.4. If C is a category with ﬁnite products, then Lens := OpticC is the category of lenses
described in the introduction (so long as we restrict to optics of shape (S, S) p→(A, A)).
Proof. We see that optics correspond to pairs of Get and Put functions via the following isomorphisms:
Lens((S, S′), (A, A′)) =
Z M∈C
C(S, M × A) × C(M × A′, S′)
∼=
Z M∈C
C(S, M) × C(S, A) × C(M × A′, S′)
(universal property of product)
∼= C(S, A) × C(S × A′, S′)
(Yoneda reduction)
This last step deserves some explanation. We are applying the isomorphism KX ∼=
R C∈C C(X, C) × KC
of Lemma 1.2.2 to the case X = S and K = C(S, A) × C(−× A′, S′).
Explicitly the isomorphism states that, given an optic ⟨l | r⟩: (S, S′) p→(A, A′), the corresponding
concrete lens is the pair Get : S →A and Put : S × A′ →S′, where Get = π2l and Put = r(π1l × A).
In the other direction, given (Get, Put), the corresponding optic is represented by ⟨[idS, Get] | Put⟩.
We leave it to the reader to verify that composition in Lens corresponds to ordinary composition of
concrete lenses by using this isomorphism in both directions. (Of course, there is only one sensible way
to compose such a collection of morphisms!)
Proposition 2.0.5. There is a functor ι : C×Cop →OpticC, which on objects is given by ι(S, S′) = (S, S′)
and on morphisms (f, g) : (S, S′) →(A, A′) by ι(f, g) =

λ−1
A f | gλA′
.
Proof. Graphically, this is:
S
f
S
S′
g
S′
7

This preserves identities, as the identity on an object (S, S′) in OpticC is deﬁned to be exactly

λ−1
S
| λS′
. To check functoriality, suppose we have (f, g) : (S, S′) →(A, A′) and (f ′, g′) : (A, A′) →
(B, B′) in C × Cop. Then:
ι(f ′, g′) ◦ι(f, g) =

λ−1
B f ′ | g′λB′
◦

λ−1
A f | gλA′
=

(I ⊗(λ−1
B f ′))λ−1
A f | gλA′(I ⊗(g′λB′))

(By deﬁnition of ◦)
=

(I ⊗λ−1
B )(I ⊗f ′)λ−1
A f | gλA′(I ⊗g′)(I ⊗λB′)

(Functoriality of I ⊗−)
=

(I ⊗λ−1
B )λ−1
B f ′f | gg′λB′(I ⊗λB′)

(Naturality of λ)
=

(λ−1
I
⊗B)λ−1
B f ′f | gg′λB′(λI ⊗B′)

(Unitality of action)
=

λ−1
B f ′f | gg′λB′(λI ⊗B′)(λ−1
I
⊗B′)

(Coend relation)
=

λ−1
B f ′f | gg′λB′
= ι(f ′f, gg′)
Graphically, there is not much to do:
S
f
f ′
B
B′
g′
g
S′
=
S
f ′f
B
B′
gg′
S′
There are some other easy-to-construct optics; speciﬁcally, optics out of and into the monoidal unit
(I, I). Such maps in a monoidal category are sometimes called states and costates [AC09].
Proposition 2.0.6. The set of costates (S, S′) p→(I, I) is isomorphic to C(S, S′).
Proof.
OpticC((S, S′), (I, I)) =
Z M∈C
C(S, M ⊗I) × C(M ⊗I, S′)
∼=
Z M∈C
C(S, M) × C(M, S′)
∼= C(S, S′)
by Yoneda reduction, so a state ⟨l | r⟩: (S, S′) p→(I, I) corresponds to the morphism rl : S →S′, and a
morphism f : S →S′ corresponds to the state

ρ−1
S
| fρS

: (S, S′) p→(I, I)
In particular, for any S ∈C, the identity idS yields an optic cS =

ρ−1
S
| ρS

: (S, S) p→(I, I) that we
call the connector:
S
S
I
I
Proposition 2.0.7. Suppose the monoidal unit I of C is terminal. Then the set of states (I, I) p→(A, A′)
is isomorphic to C(I, A).
Proof. First, note that
OpticC((I, I), (A, A′)) =
Z M∈C
C(I, M ⊗A) × C(M ⊗A′, I)
∼=
Z M∈C
C(I, M ⊗A).
8

as I is terminal. The interior of this coend is mute in the contravariant position, so the coend is equal to
the colimit of the functor C(I, −⊗A) : C →Set by Lemma 1.2.4. But C has terminal object I, so
Z M∈C
C(I, M ⊗A) ∼= colim C(I, −⊗A)
∼= C(I, I ⊗A)
∼= C(I, A)
Explicitly, a state f : I →A in C corresponds to the optic

λ−1
A f |!I×A′
: (I, I) p→(A, A′), where
!I×A′ : I × A′ →I is the unique map.
The remainder of this section comprises a proof of the following fact:
Theorem 2.0.8. The OpticC construction extends to a functor
Optic : SymmMonCat →SymmMonCat,
where SymmMonCat denotes the (1-)category of (small) symmetric monoidal categories and strong
symmetric monoidal functors.
Proposition 2.0.9. A monoidal functor F : C →D induces a functor Optic(F) : OpticC →OpticD,
given on objects by Optic(F)(S, S′) = (FS, FS′) and on morphisms ⟨l | r⟩: (S, S′) →(A, A′) by
Optic(F)(⟨l | r⟩) :=
D
φ−1
M,A(Fl) | (Fr)φM,A′
E
,
where φM,A : FM ⊗FA →F(M ⊗A) and φI : I →FI denote the structure maps of the monoidal functor.
Graphically:
Fl
Fr
FS
φM,A
FA
FS′
φ−1
M,A′
FA′
Proof. This preserves identities:
Optic(F)(id(S,S′))
= Optic(F)(

λ−1
S
| λS′
)
(Deﬁnition of id)
=
D
φ−1
I,S(Fλ−1
S ) | (FλS′)φI,S′
E
(Deﬁnition of Optic(F))
=
D
(φ−1
I
⊗S)φ−1
I,S(Fλ−1
S ) | (FλS′)φI,S′(φI ⊗S)
E
(Introducing isomorphism to both sides)
=

λ−1
F S | λF S′
(F is a monoidal functor)
= id(F S,F S′)
And given two optics ⟨l | r⟩: (S, S′) p→(A, A′) and ⟨l′ | r′⟩: (R, R′) p→(S, S′) with residuals M and M′, it
preserves composition:
Optic(F)(⟨l | r⟩◦

l′ | r′
)
(Deﬁnition of ◦)
= Optic(F)(

(M′ ⊗l)l′ | r′(M′ ⊗r)

)
(Deﬁnition of Optic(F))
9

=
D
φ−1
M′⊗M,AF((M′ ⊗l)l′) | F(r′(M′ ⊗r))φM′⊗M,A′
E
(Functoriality of F)
=
D
φ−1
M′⊗M,AF(M′ ⊗l)(Fl′) | (Fr′)F(M′ ⊗r)φM′⊗M,A′
E
(Introducing isomorphism to both sides)
=
D
(φ−1
M′,M ⊗A)φ−1
M′⊗M,AF(M′ ⊗l)(Fl′) | (Fr′)F(M′ ⊗r)φM′⊗M,A′(φM′,M ⊗A)
E
(Hexagon axiom for F)
=
D
(FM′ ⊗φ−1
M,A)φ−1
M′,M⊗A(F(M′ ⊗l))(Fl′) | (Fr′)(F(M′ ⊗r))φM′,M⊗A′(FM′ ⊗φM,A′)
E
(Naturality of φ)
=
D
(FM′ ⊗φ−1
M,A)(FM′ ⊗Fl)φ−1
M′,S(Fl′) | (Fr′)φM′,S′(FM′ ⊗Fr)(FM′ ⊗φM,A′)
E
(Functoriality of ⊗)
=
D
(FM′ ⊗φ−1
M,A(Fl))(φ−1
M′,S(Fl′)) | ((Fr′)φM′,S′)(FM′ ⊗(Fr)φM,A′)
E
(Deﬁnition of ◦)
=
D
φ−1
M,A(Fl) | (Fr)φM,A′
E
◦
D
φ−1
M′,S(Fl′) | (Fr′)φM′,S′
E
(Deﬁnition of Optic(F))
= Optic(F)(⟨l | r⟩) ◦Optic(F)(

l′ | r′
)
The critical move is adding the isomorphism (φM′,M ⊗A) to both sides of the coend, so that the hexagon
axiom for F may be applied.
Lemma 2.0.10. ι commutes with Optic(F), in the sense that
Optic(F)(ι(f, g)) = ι(Ff, Fg)
Proof. This is a straightforward calculation:
Optic(F)(ι(f, g))
(Deﬁnition of ι)
= Optic(F)(

λ−1
A f | gλA′
)
(Deﬁnition of Optic(F))
=
D
φ−1
I,A(F(λ−1
A f)) | (F(gλA′))φI,A′
E
(Functoriality of F)
=
D
φ−1
I,A(Fλ−1
A )(Ff) | (Fg)(FλA′)φI,A′
E
(Introducing φI to both sides)
=
D
(φ−1
I
⊗FA)φ−1
I,A(Fλ−1
A )(Ff) | (Fg)(FλA′)φI,A′(φI ⊗FA)
E
(F is a monoidal functor)
=

λ−1
F A(Ff) | (Fg)λF A′
(Deﬁnition of ι)
= ι(Ff, Fg)
10

Proposition 2.0.11. ι : C × Cop →OpticC “lifts natural isomorphisms”, in the following sense. Given
monoidal functors F, G : C →D and a monoidal natural isomorphism α : F ⇒G, there is an induced
natural isomorphism Optic(α) : Optic(F) ⇒Optic(G) with components:
Optic(α)(S,S′) : (FS, FS′) →(GS, GS′)
Optic(α)(S,S′) := ι(αS, α−1
S′ )
Proof. Suppose φ and ψ are the structure maps for F and G respectively. We just have to show naturality,
i.e. that for p : (S, S′) p→(A, A′) in D, the equation
Optic(α)(A,A′) ◦Optic(F)(p) = Optic(G)(p) ◦Optic(α)(S,S′)
holds. Suppose p = ⟨l | r⟩with residual M. On the left we have:
Fl
Fr
FS
φM,A
αA
GA
FS′
φ−1
M,A′
α−1
A′
GA′
We use the coend relation to place an α on either side:
Fl
Fr
FS
φM,A
αA
αM
GA
FS′
φ−1
M,A′
α−1
A′
α−1
M
GA′
And then monoidality of α to commute it past φ.
Fl
Fr
FS
αM⊗A
ψM,A
GA
FS′
α−1
M⊗A
ψ−1
M,A′
GA′
Finally, α commutes with Fl and Fr by naturality.
αS
α−1
S′
GS
Gl
ψM,A
GA
GS′
Gr
ψ−1
M,A′
GA′
This is the diagram for Optic(G)(p) ◦Optic(α)(S,S′).
Theorem 2.0.12. OpticC is symmetric monoidal, where (S, S′)⊗(T, T ′) = (S⊗T, S′⊗T ′), the unit object
is (I, I), and the action on a pair of morphisms ⟨l | r⟩: (S, S′) p→(A, A′) and ⟨l′ | r′⟩: (T, T ′) p→(B, B′) is
given by:
11

l
r
S
A
S′
A′
l′
r′
T
B
T ′
B′
Proof. Suppose the two optics have residuals M and N respectively. Written equationally, their tensor
is:
⟨l | r⟩⊗

l′ | r′
:=

(M ⊗sA,N ⊗B)(l ⊗l′) | (r ⊗r′)(M ⊗sA′,N ⊗B′)

This does not depend on the choice of representatives, as demonstrated by the equivalence of the following
diagrams:
l
r
f
S
A
S′
A′
l′
r′
g
T
B
T ′
B′
l
r
f
S
A
S′
A′
l′
r′
g
T
B
T ′
B′
To check functoriality of ⊗, suppose we have optics
⟨l1 | r1⟩: (S1, S′
1) p→(S2, S′
2)
⟨l2 | r2⟩: (S2, S′
2) p→(S3, S′
3)
⟨p1 | q1⟩: (T1, T ′
1) p→(T2, T ′
2)
⟨p2 | q2⟩: (T2, T ′
2) p→(T3, T ′
3).
The string diagram for (⟨l2 | r2⟩◦⟨l1 | r1⟩) ⊗(⟨p2 | q2⟩◦⟨p1 | q1⟩) is:
l1
l2
r1
r2
S3
S′
3
S1
S′
1
p1
p2
q1
q2
T3
T ′
3
T1
T ′
1
12

And for (⟨l2 | r2⟩⊗⟨p2 | q2⟩) ◦(⟨l1 | r1⟩⊗⟨p1 | q1⟩) is:
l1
r1
S1
l2
S′
1
r2
p1
q1
T1
p2
T ′
1
q2
S3
S′
3
T3
T ′
3
These two diagrams are equivalent: we can use the naturality of the symmetry morphism to push l2 and r2
past the crossing to be next to p2 and q2 respectively. This creates two extra twists that can be cancelled
in the center of the diagram.
The structure morphisms are all lifted from the structure morphisms in C × Cop:
α(R,R′),(S,S′),(T,T ′) := ι(αR,S,T , α−1
R′,S′,T ′)
λ(S,S′) := ι(λS, λ−1
S′ )
ρ(S,S′) := ι(ρS, ρ−1
S′ )
s(S,S′),(T,T ′) := ι(sS,T, sT ′,S′)
Note that because ι(S, S′) = (S, S′), the equations required to hold for ι to be a monoidal functor
hold by deﬁnition (although we don’t yet know that OpticC is monoidal). The pentagon and triangle
equations then hold in OpticC, as they are the image of the same diagrams in C × Cop under ι. The only
remaining thing to verify is that these structure maps are natural in OpticC, but this follows from the
previous proposition.
Proposition 2.0.13. For monoidal F : C →D, the induced Optic(F) : OpticC →OpticD is also
monoidal.
Proof. The structure morphisms for monoidality are given by lifting the structure morphisms for F:
φ(S,S′),(T,T ′) := ι(φS,T , φS′,T ′)
: F(S, S′) ⊗F(T, T ′) p→F((S, S′) ⊗(T, T ′))
φ := ι(φ, φ)
: (I, I) p→F(I, I)
The monoidality axioms follow by lifting the axioms for F and naturality follows by Proposition 2.0.11.
Proof of Theorem 2.0.8. The functor is well deﬁned on its domain: if C is small then OpticC exists. The
only property left to check is functoriality, i.e. that for monoidal functors F : C →D and G : D →E we
have
Optic(G) ◦Optic(F) = Optic(G ◦F).
13

On objects this is clear, as Optic(F)(S, S′) = (FS, FS′). On a morphism ⟨l | r⟩: (S, S′) p→(A, A′) in C,
we check:
(Optic(G) ◦Optic(F))(⟨l | r⟩) = Optic(G)
D
φ−1
M,A(Fl) | (Fr)φM,A′
E
=
D
ψ−1
F M,F A(G(φ−1
M,A(Fl))) | (G((Fr)φM,A′))ψF M,F A′
E
=
D
ψ−1
F M,F A(Gφ−1
M,A)(GFl) | (GFr)(GφM,A′)ψF M,F A′
E
= Optic(G ◦F)(⟨l | r⟩)
where φ and ψ denote the structure maps for F and G respectively, and in the last step we use that
(GφM,A′)ψF M,F A′ is by deﬁnition the structure map for G ◦F. Checking that the identity is preserved is
similar.
This doesn’t extend to a strict 2-functor SymmMonCat →SymmMonCat, as there is only an
action of Optic on natural isomorphisms. It is however functorial on natural isomorphisms, giving a
2-functor on the ‘homwise-core’ of SymmMonCat. We do not explore this any further in the present
note.
Proposition 2.0.14. If C is a strict symmetric monoidal category then OpticC is strict, and ι : C×Cop →
OpticC is a strict monoidal functor. For F : C →D a strict monoidal functor, the induced functor
Optic(F) : OpticC →OpticD is also strict.
Proof. The structure maps of OpticC are given by ι applied to the structure maps of C. If the latter are
identities, then so are the former—the identity morphisms in OpticC are by deﬁnition ι(idS, idS′).
That ι is strict is clear, as the structure morphisms in OpticC are exactly the structure morphisms in
C × Cop under ι.
Finally, the structure morphisms of Optic(F) are lifted from F, so if the latter is strict then so is the
former.
2.1
Teleological Categories
In this section we establish a universal property of the Optic construction.
The idea is that every
optic ⟨l | r⟩: (S, S′) p→(A, A′) consists of a morphism S →M ⊗A and the ‘formal dual’ of a morphism
M ⊗A′ →S′, composed with a ‘formal counit’ that traces out the object M:
l
r∗
S
S′
A
A′
M
It will be convenient to equip OpticC with a slightly diﬀerent symmetric monoidal structure:
Deﬁnition 2.1.1. The switched monoidal product on OpticC is given on objects by
(S, S′) ˜⊗(T, T ′) := (S ⊗T, T ′ ⊗S′)
And on morphisms ⟨l | r⟩: (S, S′) p→(A, A′) and ⟨l′ | r′⟩: (T, T ′) p→(B, B′) by:
14

l
r′
l′
r
S
A
T ′
B′
T
B
S′
A′
The universal property for OpticC given in this section is an argument for this being the “morally
correct” tensor, although it does seem a little strange. When we later discuss lawful optics, we are forced
to use the unswitched tensor to maintain the invariant that our objects are of the form (X, X).
Proposition 2.1.2. (OpticC, ˜⊗, (I, I)) is a symmetric monoidal category.
Proof. The proof that (OpticC, ˜⊗, (I, I)) is symmetric monoidal is nearly identical to that for the unswitched
tensor. Note that due to the switching, the structure morphisms are slightly diﬀerent:
α(R,R′),(S,S′),(T,T ′) := ι(αR,S,T , α−1
T ′,S′,R′)
λ(S,S′) := ι(λS, ρ−1
S′ )
ρ(S,S′) := ι(ρS, λ−1
S′ )
s(S,S′),(T,T ′) := ι(sS,T, sS′,T ′)
Remark 2.1.3. Just as in the unswitched case, if C is a strict monoidal category than so is (OpticC, ˜⊗, (I, I)).
We now deﬁne the structure on a symmetric monoidal category universally provided by the Optic
construction.
Deﬁnition 2.1.4 (Compare [Hed17, Deﬁnition 5.1]). A teleological category is a symmetric monoidal
category (T, ⊠, I), equipped with:
• A symmetric monoidal subcategory Td of dualisable morphisms containing all the objects of T, with
an involutive symmetric monoidal functor (−)∗: Td →Top
d , where—not ﬁnding a standard symbol
for such a thing—we mean Top
d
to be the category with both the direction of the arrows and the
order of the tensor ﬂipped: (A ⊠B)∗∼= B∗⊠A∗. Note that there is therefore also a canonical
isomorphism φ : I ∼= I∗
• A symmetric monoidal extranatural family of morphisms εX : X ⊠X∗→I, called counits, natural
with respect to the dualisable morphisms.
Unpacking the deﬁnition, ε being a symmetric monoidal extranatural transformation amounts to the
following diagrams in T commuting:
X ⊠Y ∗
Y ⊠Y ∗
X ⊠X∗
I
f⊠Y ∗
X⊠f∗
εY
εX
X∗⊠X
X ⊠X∗
X∗⊠(X∗)∗
I
s
∼
=
εX
εX∗
X ⊠Y ⊠Y ∗⊠X∗
X ⊠X∗
X ⊠Y ⊠(X ⊠Y )∗
I
X⊠εY ⊠X∗
∼
=
εX
εX⊠Y
I ⊠I∗
I ⊠I
I
I⊠φ
εI
∼
=
15

where f : X →Y is dualisable.
Note that because Td is symmetric monoidal and has the same collection of objects as T, the symmetric
monoidal structure morphisms of T must be contained in Td and so are dualisable.
Example 2.1.5.
(1) Any compact closed category is a teleological category, where every morphism is dualisable and the
unit morphisms have been forgotten.
(2) Any symmetric monoidal category with terminal monoidal unit is trivially teleological, setting the
dualisable morphisms to be all isomorphisms.
This deﬁnition of teleological category diﬀers from the original given in [Hed17], in that the duality
switches the order of the tensor product. We do this so that compact closed categories are teleological,
but the bookkeeping does admittedly become more confusing.
Deﬁnition 2.1.6. A teleological functor F : T →S is a symmetric monoidal functor that restricts to a
functor Fd : Td →Sd on the dualisable subcategories, commutes with the duality via a monoidal natural
isomorphism dX : F(X∗) →(FX)∗, and such that the counits are preserved:
F(X ⊠X∗)
FX ⊠F(X∗)
FX ⊠(FX)∗
FI
I
φX,X∗
F εX
F X⊠dX
εF X
φI
Together we have Tele, the category of teleological categories and teleological functors. There are
evident functors
U : Tele →SymmMonCat
(−)d : Tele →SymmMonCat
that take a teleological category to its underlying symmetric monoidal category and subcategory of dual-
isable morphisms respectively.
The deﬁnition of teleological category suggests a string diagram calculus similar to that for compact
closed categories, but where only counits are allowed and only morphisms known to be dualisable may
be passed around a counit. We have of course not proven that such a calculus is sound for teleological
categories, but we trust that a sceptical reader could verify our arguments equationally.
Proposition 2.1.7. OpticC forms a teleological category, where:
• The dualisable morphisms are all morphisms of the form ι(f, g);
• The involution is given on objects by (S, S′)∗:= (S′, S), and on morphisms by ι(f, g)∗:= ι(g, f);
• The counit ε(S,S′) : (S, S′) ˜⊗(S, S′)∗= (S ⊗S′, S ⊗S′) →(I, I) is given by the connector:
ε(S,S′) := cS⊗S′.
Proof. That morphisms of the form ι(f, g) constitute a symmetric monoidal subcategory is clear, they
are the image of the symmetric monoidal functor ι.
The functor (−)∗is a symmetric monoidal involution, in fact it is strictly so:
 (S, S′) ˜⊗(T, T ′)
∗=
 S ⊗T, T ′ ⊗S′∗
=
 T ′ ⊗S′, S ⊗T

= (T ′, T) ˜⊗(S′, S)
= (T, T ′)∗˜⊗(S, S′)∗
16

To check extranaturality of ε, suppose we have a dualisable optic ι(f, g) : (S, S′) p→(T, T ′), so f : S →T
and g : T ′ →S′. Happily, all the switching in the deﬁnitions cancels out! Extranaturality is witnessed by
the equality of the string diagrams:
S
T
T ′
S′
f
g
I
I
=
S
T
T ′
S′
f
g
I
I
Symmetry of ε by:
S
S
S′
S′
I
I
=
S
S
S′
S′
I
I
And for monoidality of ε there is essentially nothing to do in the graphical calculus:
S
S
T
T
T ′
T ′
S′
S′
I
I
=
S ⊗T
S ⊗T
T ′ ⊗S′
T ′ ⊗S′
I
I
Note that the diagrams that are required to commute in the deﬁnition of teleological category all
terminate with the unit I, so in view of Proposition 2.0.6 we should not be surprised that they correspond
to equality of maps in C.
Proposition 2.1.8. The functor Optic : SymmMonCat →SymmMonCat of Theorem 2.0.8 extends
to a functor to Tele.
Proof. We have seen that OpticC is always teleological. We must show that for a symmetric monoidal
functor F : C →D, the induced functor Optic(F) : OpticC →OpticD is teleological. That Optic(F)
preserves the dualisable morphisms is exactly Lemma 2.0.10. It also preserves the counits:
Optic(F)(ε(S,S′))
= Optic(F)(cS⊗S′)
(Deﬁnition of the counit)
= Optic(F)(

ρ−1
S
| ρS′
)
(Deﬁnition of the c)
=
D
φ−1
S,I(Fρ−1
S ) | (FρS′)φS′,I
E
(Deﬁnition of the Optic(F))
=
D
(FS ⊗φ−1
I )φ−1
S,I(Fρ−1
S ) | (FρS′)φS′,I(FS ⊗φI)
E
(Introduce φI to both sides)
=

ρ−1
F S | ρF S′
(F is monoidal)
= ε(F S,F S′)
(Deﬁnition of the counit)
17

We will establish the universal property in the somewhat contrived case of strict symmetric monoidal
categories and strict monoidal functors, but anticipate that this result could be weakened to non-strict
symmetric monoidal categories at the cost of checking far more coherences.
Deﬁnition 2.1.9. A teleological category is strict if it is strict as a symmetric monoidal category and (−)∗
is a strict monoidal involution, so (A ⊠B)∗= B∗⊠A∗and I∗= I, and also (A∗)∗= A. A teleological
functor is strict if it is strict as a symmetric monoidal functor and strictly preserves the duality and
counits.
We have previously noted that OpticC is strict monoidal if C is, and that in that case the duality is
strict. There are functors
Optic : StrictSymmMonCat →StrictTele
U : StrictTele →StrictSymmMonCat
(−)d : StrictTele →StrictSymmMonCat
The crux is the following proposition that decomposes every optic in a canonical way.
Proposition 2.1.10. Suppose ⟨l | r⟩: (S, S′) p→(A, A′) has residual M. Then
⟨l | r⟩= ((A, I) ˜⊗ε(M,I) ˜⊗(I, A′))(j(sM,Al) ˜⊗j(rsA′,M)∗)
where j : C →OpticC is the functor j(A) := ι(A, I).
The symmetries in the above expression could have been avoided if Optic had been deﬁned as
R M∈C C(S, A ⊗M) × C(A′ ⊗M, S′), but it is too late to change the convention now!
Proof. First note that because C is strict monoidal, the counit ε(M,I) : (M ⊗I, M ⊗I) = (M, M) p→(I, I)
is equal to the connector cM : (M, M) p→(I, I).
Then, up to strictness of the monoidal unit, we are composing the two optics
l
S
A
M
r
S′
A′
M
and
A
M
A′
M
A
A′
so the two pairs of twists cancel, and we are left exactly with the diagram for ⟨l | r⟩.
This also holds for monoidal categories that are not necessarily strict, if the unit object and unitors
are inserted in the appropriate places.
Proposition 2.1.11. Suppose (C, ⊗, I) is a strict symmetric monoidal category and (T, ⊠, I, (−)∗, ε) is a
strict teleological category. Given a strict symmetric monoidal functor F : C →Td, there exists a unique
strict teleological functor K : OpticC →T with the property Kj = F.
18

Proof. We construct K as follows. Note that any object (S, S′) in OpticC can be written uniquely as
j(S) ˜⊗j(S′)∗, so we are forced to deﬁne K(S, S′) = FS ⊠(FS′)∗. Suppose ⟨l | r⟩: (S, S′) p→(A, A′) is an
optic. By the previous Proposition,
⟨l | r⟩= ((A, I) ˜⊗ε(M,I) ˜⊗(I, A′))(j(sM,Al) ˜⊗j(rsA′,M)∗)
So if a K with Kj = F exists, it must hold that
K⟨l | r⟩= K((A, I) ˜⊗ε(M,I) ˜⊗(I, A′))K(j(sM,Al) ˜⊗j(rsA′,M)∗)
(K is monoidal)
= (K(A, I) ⊠Kε(M,I) ⊠K(I, A′))(K(j(sM,Al)) ⊠K(j(rsA′,M)∗))
(K preserves the counit and duality)
= (K(A, I) ⊠εK(M,I) ⊠K(I, A′))(K(j(sM,Al)) ⊠K(j(rsA′,M))∗)
(K satisﬁes Kj = F)
= (FA ⊠εF M ⊠(FA′)∗)(F(sM,Al) ⊠F(rsA′,M)∗)
We therefore take
K⟨l | r⟩= (FA ⊠εF M ⊠(FA′)∗)(F(sM,Al) ⊠F(rsA′,M)∗))
as our deﬁnition of K. The diagram for K⟨l | r⟩in T is as follows:
Fl
Fr∗
FS
FS′∗
FA
FA′∗
It remains to show that K so deﬁned is indeed a strict teleological functor. There are several things to
check:
• Well-deﬁnedness: Suppose we have two optics related by the coend relation:
⟨(f ⊗A)l | r⟩=

l | r(f ⊗A′)

Then well-deﬁnedness is shown by the equivalence of diagrams
Fl
Fr∗
Ff
FS
FS′∗
FA
FA′∗
=
Fl
Fr∗
Ff ∗
FS
FS′∗
FA
FA′∗
using naturality of the symmetry and extranaturality of the counit.
• Functoriality: We have an equivalence of diagrams
19

Fl1
Fr∗
1
FS
FS′∗
Fl2
Fr∗
2
FA
FA′∗
=
Fl1
Fr∗
1
FS
FS′∗
Fl2
Fr∗
2
FA
FA′∗
using naturality of the symmetry and monoidality of the counit.
• Monoidality:
K((S, S′) ˜⊗(T, T ′)) = K(S ⊗T, T ′ ⊗S)
= F(S ⊗T) ⊠F(T ′ ⊗S′)∗
= FS ⊠FT ⊠(FS′)∗⊠(FT ′)∗
= FS ⊠(FS′)∗⊠FT ⊠(FT ′)∗
= K(S, S′) ⊠K(T, T ′)
and
K(I, I) = FI ⊠(FI)∗
= I ⊠I∗
= I
• Preservation of duals:
K((S, S′)∗) = K(S′, S) = FS′ ⊠(FS)∗= (FS ⊠(FS′)∗)∗= (K(S, S′))∗
• Preservation of dualisable morphisms: For a morphism ι(f, g):
K(ι(f, g)) = K(

λ−1
A f | gλA′
)
= (FA ⊠εF I ⊠(FA′)∗)(F(sI,Aλ−1
A f) ⊠(F(gλA′sA′,I))∗)
= (FA ⊠(FA′)∗)(Ff ⊠(Fg)∗)
= Ff ⊠(Fg)∗
and this is dualisable, as dualisability is preserved by taking the monoidal product and duals.
• Preservation of counits:
K(ε(S,S′)) = K(cS⊗S′)
= K(

ρ−1
S⊗S′ | ρS⊗S′
)
= (FI ⊠εF (S⊗S′) ⊠(FI)∗)(F(sS⊗S′,Iρ−1
S⊗S′) ⊠(F(ρS⊗S′sI,S⊗S′))∗)
= (εF (S⊗S′))(F(S ⊗S′) ⊠F(S ⊗S′)∗)
= εF (S⊗S′)
= εF S⊗F S′
= εF S(FS ⊗εF S′ ⊗(FS)∗)
= εF S(FS ⊗εF S′∗⊗(FS)∗)
= εF S⊗F S′∗
= εK(S,S′)
20

The critical move is applying the equality εF S′ = εF S′∗, which follows because ε is a symmetric
monoidal transformation and the duality is strict.
Theorem 2.1.12. Optic : StrictSymmMonCat →StrictTele is left adjoint to the ‘underlying dual-
isable morphisms’ functor (−)d : StrictTele →StrictSymmMonCat.
Proof. Precomposition with j gives a function
StrictTele(OpticC, T) →StrictSymmMonCat(C, Td)
and the previous proposition states that this is a isomorphism.
This is automatically natural in T.
Naturality in C follows by Lemma 2.0.10.
Remark 2.1.13. The above theorem and its proof have much in common with [JSV96, Proposition 5.2],
which gave a similar universal property for their Int construction on traced monoidal categories.
Working with strict monoidal categories made it signiﬁcantly easier to prove the universal property.
There is likely to be a 2-categorical universal property of Optic for non-strict monoidal categories, so
long as we restrict our attention to the sub-2-category SymmMonCathomcore of SymmMonCat that
only contains natural isomorphisms. We leave this to future work:
Deﬁnition 2.1.14. A teleological natural isomorphism α : F ⇒G is a monoidal natural isomorphism
whose components are all dualisable and that is additionally compatible with the dualisation:
(FX)∗
F(X∗)
(GX)∗
G(X∗)
∼
=
(αX)∗
αX∗
∼
=
There is a (strict) 2-category Tele consisting of teleological categories, functors and natural isomorphisms.
Conjecture 2.1.15.
Optic : SymmMonCathomcore →Tele
is left biadjoint to
(−)d : Tele →SymmMonCathomcore
2.2
Optics for a Monoidal Action
To capture more of the optic variants available in the Haskell lens library, we generalise to the case of a
monoidal action of one category on another.
Deﬁnition 2.2.1. Let C be a category and (M, ⊗, I) a monoidal category. An action of M on C is a
monoidal functor a : M →[C, C]. For two objects M ∈M and A ∈C, the action a(M)(A) is abbreviated
M · A.
Given such an action, we deﬁne
OpticM((S, S′), (A, A′)) :=
Z M∈M
C(S, M · A) × C(M · A′, S′)
This subsumes the earlier deﬁnition, taking M = C and having C act on itself via left-tensor:
a : C →[C, C]
X 7→X ⊗−
We henceforth write this case as Optic⊗, to emphasise the action on C that is used.
21

Proposition 2.2.2. We have a category OpticM and a functor ι : C×Cop →OpticM deﬁned analogously
to Propositions 2.0.3 and 2.0.5.
Deﬁnition 2.2.3. Given two categories equipped with monoidal actions (M, C) and (N, D), a morphism
of actions is a monoidal functor F • : M →N and a functor F : C →D that commutes with the actions,
in the sense that there exists a natural isomorphism
φM,A : F(M · A) →(F •M) · (FA)
satisfying conditions analogous to those for a monoidal functor.
Proposition 2.2.4. If F : (M, C) →(N, D) is a morphism of actions, there is an induced functor
Optic(F) : OpticM →OpticN.
For the remainder of the paper we work in this more general setting.
3
Lawful Optics
Typically we want our optics to obey certain laws.
The ‘constant-complement’ perspective suggests
declaring an optic ⟨l | r⟩to be lawful if l and r are mutual inverses. There are a couple of issues with
this deﬁnition.
Firstly, it is not invariant under the coend relation, so the condition holding for one
representative is no guarantee that it holds for any other. Still, we might say that an optic is lawful if
it has some representative that consists of mutual inverses. In our primary example of an optic variant,
lenses in Set, this does indeed correspond to the concrete lens laws. However, this fact relies on some
extra structure possessed by Set: the existence of pullbacks, and that all objects (other than the empty
set) have a global element.
In this section we make a diﬀerent deﬁnition of lawfulness that at ﬁrst seems strange, but which in
the case of lenses corresponds exactly to the three concrete lens laws with no additional assumptions on C
required. As further justiﬁcation for this deﬁnition, in Section 5 we will see an interpretation of (unlawful)
optics as maps between certain comonoid objects. Lawfulness in our sense corresponds exactly to this
map being a comonoid homomorphism.
The optic laws only make sense for optics of the form p : (S, S) p→(A, A). In this section we will
abbreviate OpticM((S, S), (A, A)) as OpticM(S, A) and p : (S, S) p→(A, A) as p : S p→A.
Remark 3.0.1. We use ; to denote composition of C in diagrammatic order. The reason for this is that
the coend relation can be applied simply by shifting the position of | in a representative:
⟨l; (φ · A) | r⟩= ⟨l | (φ · A); r⟩
Let Optic2
M(S, A) denote the set
Z M1,M2∈M
C(S, M1 · A) × C(M1 · A, M2 · A) × C(M2 · A, S).
Using the universal property of the coend, we deﬁne three maps:
outside : OpticM(S, A) →C(S, S)
once, twice : OpticM(S, A) →Optic2
M(S, A)
by
outside(⟨l | r⟩) = l; r
once(⟨l | r⟩) = ⟨l | idM·A | r⟩
twice(⟨l | r⟩) = ⟨l | r; l | r⟩
22

Deﬁnition 3.0.2. An optic p : S p→A is lawful if
outside(p) = idS
once(p) = twice(p)
Returning to ordinary lenses, we can show that this is equivalent to the laws we expect.
Proposition 3.0.3. A concrete lens described by Get and Put is lawful (in our sense) iﬀit obeys the
three concrete lens laws.
Proof. We begin by giving Optic2
×(S, A) the same treatment as we did Optic×(S, A). Using the universal
property of the product and Yoneda reduction twice each, we have:
Optic2
×(S, A) =
Z M1,M2∈C
C(S, M1 × A) × C(M1 × A, M2 × A) × C(M2 × A, S)
∼=
Z M1,M2∈C
C(S, M1) × C(S, A) × C(M1 × A, M2 × A) × C(M2 × A, S)
∼=
Z M2∈C
C(S, A) × C(S × A, M2 × A) × C(M2 × A, S)
∼=
Z M2∈C
C(S, A) × C(S × A, M2) × C(S × A, A) × C(M2 × A, S)
∼= C(S, A) × C(S × A, A) × C(S × A × A, S)
Written equationally, the isomorphism Φ : Optic2
×(S, A) →C(S, A) × C(S × A, A) × C(S × A × A, S) is
given by:
Φ(⟨l | c | r⟩) = (
l; π2,
(l; π1 × A); c; π2,
((l; π1 × A); c; π1 × A); r
)
Now suppose we are given a lens p that corresponds concretely to (Get, Put), so p = ⟨[idS, Get] | Put⟩.
Evaluating outside on this gives:
outside(⟨[idS, Get] | Put⟩) = [idS, Get]; Put
so requiring outside(p) = idS is precisely the GetPut law.
We now have to slog through evaluating Φ(once(p)) and Φ(twice(p)).
Φ(once(⟨[idS, Get] | Put⟩)) = Φ(⟨[idS, Get] | idS×A | Put⟩)
= ( [idS, Get]; π2,
([idS, Get]; π1 × A); idS×A; π2,
(([idS, Get]; π1 × A); idS×A; π1 × A); Put
)
= ( Get,
π2,
π1,3; Put
)
Φ(twice(⟨[idS, Get] | Put⟩)) = Φ(⟨[idS, Get] | Put; [idS, Get] | Put⟩)
= ( [idS, Get]; π2,
([idS, Get]; π1 × A); Put; [idS, Get]; π2,
(([idS, Get]; π1 × A); Put; [idS, Get]; π1 × A); Put
)
23

= ( Get,
(idS × A); Put; Get,
((idS × A); Put × A); Put
)
= ( Get,
Put; Get,
(Put × A); Put
)
So comparing component-wise, Φ(once(p)) being equal to Φ(twice(p)) is exactly equivalent to the PutGet
and PutPut laws holding.
We can also check when some other of our basic optics are lawful.
Proposition 3.0.4. If p = ⟨l | r⟩: S p→A is an optic such that l and r are mutual inverses, then p is
lawful.
Proof. The conditions are easy to check:
outside(⟨l | r⟩) = l; r = idS
twice(⟨l | r⟩) = ⟨l | r; l | r⟩
= ⟨l | idM·A | r⟩
= once(⟨l | r⟩)
Corollary 3.0.5. If f : S →A and g : A →S are mutual inverses, then ι(f, g) : S p→A is a lawful optic,
so ι restricts to a functor ι : Core(C) →LawfulM.
Corollary 3.0.6. For any two objects A ∈C and M ∈M, the tautological optic M · A p→A is lawful.
Proposition 3.0.7. A costate p : (S, S) p→(I, I) corresponding to a morphism f : S →S via Proposi-
tion 2.0.6 is lawful iﬀf = idS.
Proof. The ﬁrst law states that outside(p) = idS, so if p is lawful we have
idS = outside(

ρ−1
S
| ρS; f

) = ρ−1
S ; ρS; f = f
On the other hand, if f = idS then

ρ−1
S
| ρS

is lawful because its components are mutual inverses.
Proposition 3.0.8. There is an subcategory LawfulM of OpticM given by objects of the form (S, S) and
lawful optics between them.
Proof. This will follow from our description of lawful profunctor optics later, but we give a direct proof.
The identity optic is lawful as by deﬁnition it has a representative

λ−1
S
| λS

consisting of mutual inverses.
We just have to show that lawfulness is preserved under composition.
Suppose we have two lawful optics ⟨l | r⟩: R p→S and ⟨l′ | r′⟩: S p→A with residuals M and N
respectively. We must show that ⟨l; (M · l′) | (M · r′); r⟩is also a lawful optic. Showing the ﬁrst law is
straightforward:
outside(

l; (M · l′) | (M · r′); r

) = l; (M · l′); (M · r′); r
= l; (M · l′r′); r
= l; (M · idN·A); r
= l; r
= idS
24

For the second law, we must show that
⟨l; (M · l′) | (M · r′); r; l; (M · l′) | (M · r′); r⟩= ⟨l; (M · l′) | idM·N·A | (M · r′); r⟩.
The idea is that, by the lawfulness of ⟨l | r⟩and ⟨l′ | r′⟩, there are chains of coend relations that prove
⟨l | r; l | r⟩= ⟨l | idM·S | r⟩
⟨l′ | r′; l′ | r′⟩= ⟨l′ | idN·A | r′⟩
The result is achieved by splicing these chains of relations together in the following way.
Consider one of the generating relations ⟨l; (φ · S) | c | r⟩= ⟨l | (φ · S); c | r⟩in Optic2
M(R, S), where
φ : M →M′. By the functoriality of the action, we calculate:
⟨l; (φ · S); (M′ · l′) | (M′ · r′); c; (M · l′) | (M · r′); r⟩
= ⟨l; (M · l′); (φ · N · A) | (M′ · r′); c; (M · l′) | (M · r′); r⟩
(functoriality)
= ⟨l; (M · l′) | (φ · N · A); (M′ · r′); c; (M · l′) | (M · r′); r⟩
(coend relation)
= ⟨l; (M · l′) | (M · r′); (φ · S); c; (M · l′) | (M · r′); r⟩
(functoriality)
And similarly for the other generating relation, ⟨l | c; (φ · S) | r⟩= ⟨l | c | (φ · S); r⟩.
So indeed by replicating the same chain of relations that proves ⟨l | r; l | r⟩= ⟨l | idM·S | r⟩, we see
⟨l; (M · l′) | (M · r′); r; l; (M · l′) | (M · r′); r⟩= ⟨l; (M · l′) | (M · r′); idM·S; (M · l′) | (M · r′); r⟩
= ⟨l; (M · l′) | (M · r′; l′) | (M · r′); r⟩.
Now that the r; l in the center has been cleared away, we turn to the chain of relations prov-
ing ⟨l′ | r′; l′ | r′⟩= ⟨l′ | idN·A | r′⟩.
A generating relation ⟨l′; (ψ · A) | c′ | r′⟩= ⟨l′ | (ψ · A); c′ | r′⟩in
Optic2
M(S, A) implies that
⟨l; (M · l′; ψ · A) | M · c′ | (M · r′); r⟩= ⟨l; (M · l′); (M · ψ · A) | M · c′ | (M · r′); r⟩
= ⟨l; (M · l′) | (M · ψ · A); (M · c′) | (M · r′); r⟩
= ⟨l; (M · l′) | M · ((ψ · A); c′) | (M · r′); r⟩
And similarly for the generating relation on the other side. So again we can replicate the chain of relations
proving ⟨l′ | r′; l′ | r′⟩= ⟨l′ | idM·A | r′⟩to show that
⟨l; (M · l′) | (M · r′; l′) | (M · r′); r⟩= ⟨l; (M · l′) | M(idN·A) | (M · r′); r⟩
= ⟨l; (M · l′) | idM·N·A | (M · r′); r⟩
as required. We conclude that composition preserves lawfulness, so LawfulM is indeed a subcategory of
OpticM.
Proposition 3.0.9. In the case that C is symmetric monoidal and M = C acts by left-tensor, then
Lawful⊗is symmetric monoidal with the unswitched tensor.
This would of course make no sense with the switched tensor, as the tensor of two objects would
typically no longer be of the form (X, X).
Proof. Due to Corollary 3.0.5, the structure maps of OpticM are all lawful. We just have to check that
⊗: OpticM × OpticM →OpticM restricts to a functor on LawfulM.
Given two lawful optics p : S p→A and q : T p→B, the ﬁrst law for p ⊗q follows immediately from
the ﬁrst law for p and q. To prove the second law, we follow the same strategy as used in the previous
proposition: the two chains of relations proving p and q lawful can be combined to prove the law for p⊗q.
25

Proposition 3.0.10. Suppose F : (M, C) →(N, D) is a morphism of actions.
Then Optic(F) :
OpticM →OpticN restricts to a functor LawfulM →LawfulN.
Proof. If p = ⟨l | r⟩is lawful, then verifying the ﬁrst equation is easy:
outside(Optic(F)(⟨l | r⟩)) = outside
D
(Fl); φ−1
M,A | φM,A′; (Fr)
E
= (Fl); φ−1
M,A; φM,A′; (Fr)
= (Fl); (Fr)
= idF S
where φM,A′ : (F •M) · (FA) →F(M · A) is the structure map that commutes F with the actions.
For the second equation, consider a generating relation ⟨l; (ψ · A) | c | r⟩= ⟨l | (ψ · A); c | r⟩. We can
use the naturality of φ to show
⟨F(l; ψ · A); φ−1
M,A | φM,A; Fc; φ−1
N,A | φN,A; Fr⟩= ⟨Fl; F(ψ · A); φ−1
M,A | φM,A; Fc; φ−1
N,A | φN,A; Fr⟩
= ⟨Fl; φ−1
M′,A; (F •ψ) · A | φM,A; Fc; φ−1
N,A | φN,A; Fr⟩
= ⟨Fl; φ−1
M′,A | (F •ψ) · A; φM,A; Fc; φ−1
N,A | φN,A; Fr⟩
= ⟨Fl; φ−1
M′,A | φM′,A; F(ψ · A); Fc; φ−1
N,A | φN,A; Fr⟩
= ⟨Fl; φ−1
M′,A | φM′,A; F(ψ · A; c); φ−1
N,A | φN,A; Fr⟩
Similarly,
⟨Fl; φ−1
M,A | φM,A; Fc; φ−1
N,A | φN,A; F((ψ · A); r)⟩= ⟨Fl; φ−1
M,A | φM,A; F(c; (ψ · A)); φ−1
N,A | φN,A; Fr⟩
If ⟨l | r⟩is lawful, we can therefore replicate the chain of relations proving twice(⟨l | r⟩) = once(⟨l | r⟩)
to show:
twice(Optic(F)(⟨l | r⟩)) = ⟨Fl; φ−1
M,A | φM,A; F(r; l); φ−1
M,A | φM,A; Fr⟩
= ⟨Fl; φ−1
M,A | φM,A; F(idM·A); φ−1
M,A | φM,A; Fr⟩
= ⟨Fl; φ−1
M,A | id(F •M)·(F A) | φM,A; Fr⟩
= once(Optic(F)(⟨l | r⟩))
We end with some commentary on the optic laws. The requirement that once(p) = twice(p) is myste-
rious, but there are suﬃcient conditions that are easier to verify.
Proposition 3.0.11. Let ⟨l | r⟩: S p→A be an optic. If l; r = idS and r; l = φ · A for some φ : M →M
in M, then ⟨l | r⟩is lawful.
Proof. The statement outside(⟨l | r⟩) = l; r = idS is exactly the ﬁrst law. And for the second, we verify:
twice(⟨l | r⟩) = ⟨l | r; l | r⟩
= ⟨l | φ · A | r⟩
(r; l = φ · A)
= ⟨l; (φ · A) | idM·A | r⟩
(coend relation)
= ⟨l; r; l | idM·A | r⟩
(r; l = φ · A again)
= ⟨l | idM·A | r⟩
(l; r = idS)
= once(⟨l | r⟩)
26

Even if r; l = φ · A for some φ, the same is not necessarily true for other representatives of the same
optic. Let inside : OpticM(S, A) →
R M∈M C(M · A, M · A) be the map induced by inside(⟨l | r⟩) = ⟨r; l⟩.
We might ask that instead of requiring r; l = φ·A exactly, we have ⟨r; l⟩= ⟨φ·A⟩in
R M∈M C(M ·A, M ·A).
In fact, this is equivalent:
Proposition 3.0.12. Suppose p : S p→A satisﬁes outside(p) = idS and inside(p) = ⟨φ · A⟩. Then there
exists a representative ⟨l | r⟩such that r; l = ψ · A on the nose for some (possibly diﬀerent) ψ : M →M.
Proof. The generating relation for
R M∈M C(M · A, M · A) is
⟨f; (φ · A)⟩= ⟨(φ · A); f⟩
whenever f : N·A →M·A and φ : M →N. This relation f; (φ·A) ⇝(φ·A); f is not likely to be symmetric
or transitive in general. Note that if f; (φ · A) ⇝(φ · A); f then f; (φ · A); f; (φ · A) ⇝(φ · A); f; (φ · A); f.
More generally, if f ⇝g then f n ⇝gn for any n.
Now let ⟨l | r⟩be a representative for p, so l; r = idS and ⟨r; l⟩= ⟨ψ · A⟩. There therefore exists a
ﬁnite chain of relations r; l = u1 ↭· · · ↭un = ψ · A. Suppose the ﬁrst relation faces rightward, so
there exists a k and φ with r; l = (φ · A); k and u2 = k; (φ · A). Deﬁne l′ = l; (φ · A) and r′ = k; r. Then:

l′ | r′
= ⟨l; (φ · A) | k; r⟩
= ⟨l | (φ · A); k; r⟩
= ⟨l | r; l; r⟩
= ⟨l | r⟩
This new representative satisﬁes
l′; r′ = l; (φ · A); k; r = l; r; l; r = idS
r′; l′ = k; r; l; (φ · A) = k; (φ · A); k; (φ · A) = u2
2
A symmetric argument shows that if instead the relation faces leftward, so lr
⇝
u2, there again exists
l′ and r′ so that ⟨l | r⟩= ⟨l′ | r′⟩, and both l′; r′ = idS and r′; l′ = u2
2.
We can now inductively apply the above argument to the shorter chain
l′r′ = u2
1 ↭· · · ↭u2
n ↭(ψ · A)2 = ψ2 · A,
obtained by squaring each morphism in the original chain, until we are left with a representative ⟨l∗| r∗⟩
such that r∗; l∗= ψN · A, for some N > 0. This pair ⟨l∗| r∗⟩is the required representative.
The above argument has a similar form to those that appear in [Far08], which considered (among
other things) coends of the form
R c∈C C(c, Fc) for an endofunctor F : C →C.
4
Examples
The general pattern is as follows. Once we choose a particular monoidal action M →[C, C], we ﬁnd
an isomorphism between the set of optics (S, S′) p→(A, A′) and a set C((S, S′), (A, A′)) that is easier to
describe. We follow [PGW17] (and others) in calling elements of C concrete optics. There is no canonical
choice for this set; our primary goal is to ﬁnd a way to eliminate the coend so that we no longer have to
deal with equivalence classes of morphisms.
Ideally, we then also ﬁnd a simpliﬁed description C2(S, A) for the set Optic2
C(S, A). We can then
“read oﬀ” what conditions on are needed on a concrete optic to ensure that the corresponding element of
OpticM(S, A) is lawful. We will call these conditions the concrete laws.
It is worth emphasising that once a monoidal action has been chosen and a concrete description of
the corresponding optics found, no further work is needed to show that the result forms a category with
a subcategory of lawful optics. This is especially useful when devising new optic variants, as we do later.
27

4.1
Lenses
The founding example, that of lenses, has already been discussed in the previous sections. We add a
couple of remarks.
Remark 4.1.1. For the category of sets, the functor ι : Set × Setop →Optic× is not faithful. The
problem is the empty set: the functor 0 × (−) is not faithful. Any pair of maps f : 0 →A, g : A′ →S′
yield equivalent optics ι(f, g), as the corresponding Get and Put functions must be the unique maps
from 0.
Remark 4.1.2. In the case that C is cartesian closed, Optic× is monoidal closed via the astonishing
formula
[(S, S′), (A, A′)] := (C(S, A) × C(S × A′, S′), S × A′)
where C(−, −) denotes the internal hom. For a proof see [dP89, Section 1.2]. This cannot be extended to
non-cartesian closed categories, the isomorphism
Lens((S, S′) ⊗(T, T ′), (A, A′)) ∼= Lens((S, S′), [(T, T ′), (A, A′)])
uses the diagonal maps of C in an essential way.
If we ask more of our category C, we can show that a lens S p→A implies the existence of a complement
C with S ∼= C × A. This doesn’t appear to follow purely from the concrete lens laws—an argument that a
deﬁnition of lawfulness based on constant complements is not the correct generalisation. For completeness
we include a proof in our notation.
Proposition 4.1.3 (Generalisation of [JRW10, Corollary 13]). Suppose C has pullbacks and that there is
a morphism x : 1 →A. If p : S p→A is lawful then there exists C ∈C and mutual inverses l : S →C × A
and r : C × A →S so that p = ⟨l | r⟩.
Proof. Set C to be the pullback of Get along x, so there is a map i : C →S with Get i = x!C. There is
also a map j : S →C induced by the following diagram:
S
S × A
C
S
1
A
j
[idS,x!S]
Put
i
⌟
Get
x
which commutes by the PutGet law. Note that ji = idC by the universal property of pullbacks.
Now take l : [j, Get] : S →C × A and r : Put(i × A) : C × A →S. That they are mutual inverses is
easily checked:
Put(i × A)[j, Get] = Put[ij, Get]
= Put[Put[idS, x!S], Get]
(by deﬁnition of j)
= Put[idS, Get]
(by PutPut)
= idS
(by GetPut)
28

and
[j, Get]Put(i × A) = [jPut(i × A), Get Put(i × A)]
(by universal property of product)
= [jPut(i × A), π2(i × A)]
(by PutGet)
= [jPut(i × A), π2]
= [jijPut(i × A), π2]
= [jPut[idS, x!S]Put(i × A), π2]
= [jPut[idS, x!S]π1(i × A), π2]
(by PutPut)
= [jijπ1(i × A), π2]
= [jijiπ1, π2]
= [π1, π2]
= idC×A
Finally, the coend relation gives that
⟨[j, Get] | Put(i × A)⟩= ⟨(i × A)[j, Get] | Put⟩= ⟨[idS, Get] | Put⟩
as elements of OpticM(S, A).
Remark 4.1.4. Much of the work on bidirectional transformations [FGM+07] considers lenses that are
only ‘well-behaved’, not ‘very well-behaved’: they obey the PutGet and GetPut laws but not the
PutPut law.
For example, the “change counter” lens N × A p→A from [FHP15] has Put and Get given by:
Get(n, a) = a
Put((n, a), a′) =
(
(n, a)
if a = a′
(n + 1, a′)
otherwise
This example is typical of (merely) well-behaved lenses: there is metadata stored alongside the target of
a lens that mutates as the lens is used.
Lenses that satisfy only the two laws correspond to pairs ⟨l | r⟩such that rl = idS and π2lr = π2.
This condition seems unavoidably tied to the product structure on C; there is no obvious way generalise
this to other optics variants.
4.2
Prisms
Prisms are dual to lenses:
Deﬁnition 4.2.1. Suppose C has ﬁnite coproducts. The category of prisms is the category of optics with
respect to the coproduct ⊔: Prism := Optic⊔.
Just as optics for × correspond to a pair of maps Get : S →A and Put : S × A →S, optics for ⊔
correspond to pairs of maps Review : A →S and Matching : S →S ⊔A. These names are taken from
the Haskell lens library.
Prism((S, S′), (A, A′)) =
Z M∈C
C(S, M ⊔A) × C(M ⊔A′, S′)
∼=
Z M∈C
C(S, M ⊔A) × C(M, S′) × C(A, S′)
(universal property of coproduct)
∼= C(S, S′ ⊔A) × C(A′, S′)
(Yoneda reduction)
29

If we are given a prism ⟨l | r⟩: (S, S′) p→(A, A′) then associated Review and Matching morphisms are
given by Review = rinr and Matching = (rinl ⊔A)l
The concrete laws for prisms are the obvious duals to the lens laws:
Matching Review = inr
[idS, Review]Matching = idS
(Matching ⊔A)Matching = in1,3 Matching
In the lens library documentation the third law is missing, on account of following:
Proposition 4.2.2. When C = Set, the third law is implied by the other two.
Proof. The key is that for any map f : X →Y in Set, the codomain Y is equal to the union of im f and
its complement. The ﬁrst law implies that Review is injective, so S ∼= C ⊔A for some complement C.
Identifying A with its image in S, the second law implies that if a ∈A ⊂S then Matching(a) = inr(a)
and if c ∈C ⊂S then Matching(c) = inl(c). The third law can then be veriﬁed pointwise by checking
both cases a ∈A ⊂S and c ∈C ⊂S separately.
The following is then exactly the dual of Proposition 3.0.3.
Proposition 4.2.3. If p : S p→A is a lawful prism then the associated Matching and Review functions
satisfy the concrete prism laws.
4.3
Isos
For any category C, there is a unique action of the terminal category 1 on C that ﬁxes every object.
Proposition 4.3.1. The category of optics for this action is isomorphic to C × Cop.
Proof.
Optic1((S, S′), (A, A′)) =
Z M∈1
C(S, M · A) × C(M · A′, S′)
∼= C(S, ⋆· A) × C(⋆· A′, S′)
∼= C(S, A) × C(A′, S′)
where ⋆denotes the object of 1.
Composition in Optic1((S, S′), (A, A′)) does indeed correspond to
composition in C × Cop.
Proposition 4.3.2. An iso ⟨l | r⟩is lawful iﬀ(as expected) l and r are mutual inverses.
Proof. Optic2
M(S, A) specialises in this case to just
C(S, A) × C(A, A) × C(A, S)
The condition outside(⟨l | r⟩) = idS is the claim that rl = idS, and once(⟨l | r⟩) = (l, idA, r) is equal to
twice(⟨l | r⟩) = (l, lr, r) iﬀlr = idA.
30

4.4
Coalgebraic Optics
There is a common pattern in many of the examples to follow: for every object A ∈C, the evaluation-at-A
functor −· A : M →C has a right adjoint, say RA : C →M. To ﬁx notation, let
−→
(−) : C(F · A, S) →M(F, RAS) : ←−
(−)
denote the homset bijection, so the unit and counit are:
ηF : F →RA(F · A)
ηF := −−−→
idF ·A
εS : (RAS) · A →S
εS := ←−−−
idRAS
It is shown in [JK02, Section 6] that, at least in the case M is right closed, to give such an action is
equivalent to giving a “copowered M-category C”. In most cases of interest to us, however, M is not right
closed.
When we have such a right adjoint, we can always ﬁnd a concrete description of an optic:
OpticM((S, S′), (A, A′)) =
Z F ∈M
C(S, F · A) × C(F · A′, S′)
∼=
Z F ∈M
C(S, F · A) × M(F, RA′S′)
∼= C(S, (RA′S′) · A)
A concrete optic is therefore a map Unzip : S →(RA′S′) · A. The above isomorphism sends Unzip to the
element ⟨Unzip | εS′⟩. In the other direction, given ⟨l | r⟩we have Unzip = (−→r · A)l.
Theorem 4.4.1. A concrete optic Unzip : S →(RAS) · A is lawful iﬀit is a coalgebra for the comonad
X 7→(RAX) · A.
Proof. By adjointness and Yoneda reduction we have an isomorphism
Φ : Optic2
M(S, A) →C(S, RA(RAS · A) · A)
given by
Optic2
M(S, A)
=
Z M1,M2∈M
C(S, M1 · A) × C(M1 · A, M2 · A) × C(M2 · A, S)
∼=
Z M1,M2∈M
C(S, M1 · A) × M(M1, RA(M2 · A)) × M(M2, RAS)
∼=
Z M1,M2∈M
C(S, M1 · A) × M(M1, RA(M2 · A)) × M(M2, RAS)
∼=
Z M1∈M
C(S, M1 · A) × M(M1, RA(RAS · A))
∼= C(S, RA(RAS · A) · A)
which evaluated on an element ⟨l | c | r⟩is
Φ(⟨l | c | r⟩) = (
−−−−−→
(−→r · A)c · A)l
So now interpreting the optic laws, we ﬁnd
outside(⟨Unzip | εS⟩) = εS Unzip = idS
31

is exactly the coalgebra counit law, and equality of
Φ(once(⟨Unzip | εS⟩)) = Φ(⟨Unzip | id(RAS)·A | εS⟩)
= (−−−−−−−−−−−−→
(−→
εS · A)id(RAS)·A · A)Unzip
= (−−−−−−−→
(idRAS · A) · A)Unzip
= (−−−−−→
idRAS·A · A)Unzip
= (ηRAS · A)Unzip
Φ(twice(⟨Unzip | εS⟩)) = Φ(⟨Unzip | Unzip εS | εS⟩)
= (−−−−−−−−−−−−−→
(−→
εS · A)(Unzip εS) · A)Unzip
= (−−−−−−−→
(Unzip εS) · A)Unzip
= (RA(Unzip) · A)Unzip
is exactly the coalgebra comultiplication law.
4.5
Setters
Deﬁnition 4.5.1. The category of setters SetterC is the category of optics for the action of [C, C] on C
by evaluation.
To devise the concrete form of a setter, we use the following proposition. This is a generalisation
of [JO15, Proposition 2.2], and helps to explain why the store comonad is so important in the theory of
lenses.
Proposition 4.5.2. If C is powered over Set then the evaluation-at-A functor −A : [C, C] →C has a
right adjoint given by S 7→SC(−,A).
If C is copowered over Set then −A : [C, C] →C has a left adjoint given by S 7→C(A, −) • S, where •
denotes the copower.
Proof. For the ﬁrst, we have
C(FA, S) ∼=
Z
X
Set(C(X, A), C(FX, S))
∼=
Z
X
C(FX, SC(X,A))
∼= [C, C](F, SC(−,A))
and for the second,
C(S, FA) ∼=
Z
X
Set(C(A, X), C(S, FX))
∼=
Z
X
C(C(A, X) • S, FX)
∼= [C, C](C(A, −) • S, F)
Recall that any category with coproducts is copowered over Set and any category with products is
powered over Set.
32

We could immediately use the previous section to give a coalgebraic description of setters and their
laws, but with a little manipulation we get a form that looks more familiar:
SetterC((S, S′), (A, A′)) =
Z F ∈[C,C]
C(S, FA) × C(FA′, S′)
∼=
Z F ∈[C,C]
[C, C](C(A, −) • S, F) × C(FA′, S′)
∼= C(C(A, A′) • S, S′)
∼= Set(C(A, A′), C(S, S′))
In the Haskell lens library, the map C(A, A) →C(S, S) corresponding to a setter is called Over: we
think of a setter as allowing us to apply a morphism A →A over some parts of S. Tracing through
the isomorphisms, the optic corresponding to Over is ⟨l | r⟩where l : S →C(A, A) • S is the inclusion
with the identity morphism idA and r : C(A, A′) • S →S′ is the transpose of Over along the adjunction
deﬁning the copower.
The laws for setters in this form are a kind of functoriality:
Proposition 4.5.3. A setter p : S p→A is lawful iﬀ
Over(idA) = idS
Over(f)Over(g) = Over(fg)
Proof. The key is concretely describing Optic2
[C,C](S, A) as
Set(C(A, A) × C(A, A), C(S, S)).
We leave the veriﬁcation that the conditions are equivalent to the reader.
This characterisation of setters is maybe a little odd, in that we have ended up with a function of
Sets, rather than a description internal to C. If we modify our deﬁnition of Setter, we do get an internal
characterisation. Suppose C is cartesian closed and let StrongC be the category of strong functors on C.
Deﬁnition 4.5.4 ( [Koc72]). A (left) strong functor is a functor F : C →C equipped with a natural
transformation called the strength:
θA,B : A ⊗FB →F(A ⊗B)
such that the strength commutes with the unitor:
I ⊗FA
F(I ⊗A)
FA
FA
θ1,A
∼
=
∼
=
and with associativity:
(A ⊗B) ⊗FC
F((A ⊗B) ⊗C)
A ⊗(B ⊗FC)
A ⊗F(B ⊗C)
F(A ⊗(B ⊗C))
θA⊗B,C
αA,B,F C
F αA,B,F C
A⊗θB,C
θA,B⊗C
A strong natural transformation τ : (F, θ) ⇒(G, θ′) is a natural transformation that respects the strengths.
There is an evident category Strong(C) of strong endofunctors and strong natural transformations, and
a forgetful functor U : Strong(C) →[C, C].
33

Then, again, StrongC acts on C by evaluation. We leave it to the reader to verify there is a natural
isomorphism
C(S, FA) ∼= StrongC(C(A, −) × S, F),
which we can use to describe optics for this action as elements of C(C(A, A′), C(S, S′)).
4.6
Traversals
In this section we work in the case C = Set. Traversals allow us to traverse through a data structure,
accumulating applicative actions as we go.
We begin by reviewing the deﬁnitions of applicative and
traversable functors [JR12].
Deﬁnition 4.6.1. An applicative functor F : C →C is a lax monoidal functor with a strength compatible
with the monoidal structure, in the sense that
A ⊗FB ⊗FC
F(A ⊗B) ⊗FC
A ⊗F(B ⊗C)
F(A ⊗B ⊗C)
θA,B⊗F C
A⊗φB,C
φA⊗B,C
θA,B⊗C
commutes. An applicative natural transformation is one that is both monoidal and strong. Applicative
functors and natural transformations form a monoidal category App with the tensor given by functor
composition.
Deﬁnition 4.6.2. A traversable functor is a functor T : C →C equipped with a distributive law δF :
TF →FT for T over the action of App on C by evaluation.
Explicitly, this means that the diagrams
TF
FT
TG
GT
δF
Tα
Tα
δG
TFG
FGT
FTG
δF G
δF G
F δG
TidC
idCT
idT
δidC
in [C, C] commute.
Deﬁnition 4.6.3. The category Traversal of traversals is the category of optics for the action of
Traversable on Set given by evaluation. (Yes, the names Traversal/Traversable are confusing!)
It is known that traversable functors correspond to coalgebras for a particular parameterised comonad.
See [JO15, Deﬁnitions 4.1 and 4.2], also [Atk09] for the relevant deﬁnitions of parameterised comonads
and coalgebras.
Proposition 4.6.4 ( [JO15, Theorem 4.10, Proposition 5.4]). Traversable structures on a functor T :
Set →Set correspond to parameterised coalgebra structures
tA,B : TA →UR∗
A,B(TB)
where UR∗
X,Y is the parameterised comonad
UR∗
X,Y Z = Σn∈NXn × Set(Y n, Z)
Moreover, this correspondence forms an isomorphism of categories between Traversable and the Eilenberg-
Moore category of coalgebras for UR∗
−,−, which we denote E.
34

Lemma 4.6.5. For any objects A, B ∈Set and traversable functor F,
Set(FA, B) ∼= Traversable(F, Σn(−)n × Set(An, B))
naturally in B and F. In other words, the functor
(B 7→Σn(−)n × Set(An, B)) : Set →Traversable
is right adjoint to the evaluation-at-A functor −A : Traversable →Set.
Proof. By [Atk09, Proposition 6], there is a parameterised adjunction LT ⊣RT , where
LT : Set × E →Set
(X, (F, f)) 7→FX
RT : Set × Set →E
(Y, Z) 7→(UR∗
−,Y Z, ε)
where ε is the counit of UR∗
−,−.
Evaluating these with the ﬁxed parameter A, we get an ordinary
adjunction
LT (A) : E →Set
(F, f) 7→FA
RT (A) : Set →E
Z 7→(UR∗
−,AZ, ε)
But this is exactly the adjunction we were trying to show.
We can then use the coalgebraic pattern from earlier to reach the same concrete description of traversals
as found in [PGW17].
Traversal((S, S′), (A, A′)) ∼= Set(S, ΣnAn × Set(A′n, S′))
The concrete laws for this representation are the coalgebra laws. These laws, however, are not the
ones usually presented for traversals. Instead, versions of the profunctor laws are used, see Section 5.
4.7
Polymorphic Optics
Haskell’s optics allow polymorphic updates, where the type of the codomain of the lens may be changed
by an update, causing a corresponding change in the type of the domain. As an example, we permitted
to use a lens into the first entry of a tuple in the following way:
set first (1, 5) "hello" == ("hello", 5)
This has changed the type from (Int, Int) to (String, Int).
Polymorphic optics can be captured by the coend formalism as follows. Any action of a monoidal
category M × C →C can be extended to act object-wise on a functor category:
M × [D, C] →[D, C]
(M, F) 7→M · (F−)
So in the above example, we have the product × acting pointwise on the functor category Set →Set.
Our example first is then an optic F p→G, where F = (−) × Int and G is the identity functor.
Given such a polymorphic optic in [D, C], we can always ‘monomorphise’ to obtain an ordinary optic
in C.
35

Proposition 4.7.1. There is a functor
mono : D × Dop × Optic[D,C] →OpticC
that sends an object (D, D′) ∈D × Dop and optic ⟨l | r⟩: (F, F ′) p→(G, G′) in Optic[D,C] to the optic
⟨lD | rD′⟩: (FD, F ′D′) p→(GD, G′D′) in OpticC. For ﬁxed (D, D) ∈D × Dop, this functor preserves
lawfulness.
Proof. On an object (D, D′) ∈D × Dop, that we get a functor Optic[D,C] →OpticC is essentially the
same proof as Proposition 2.2.4 but with diﬀerent functors on each side of the lens: the evaluation-at-D
functor [D, C] →C on the left and evaluation-at-D′ on the right.
For functoriality in D × Dop, given (f, g) : (D1, D′
1) →(D2, D′
2) ∈D × Dop and an object (F, F ′) ∈
Optic[D,C], there is an induced lens ι(Ff, F ′g) : (FD1, F ′D′
1) p→(FD2, F ′D′
2). Bifunctoriality of mono is
ensured by the naturality of each l and r in the morphisms of Optic[D,C].
4.8
Linear Lenses
If C is closed monoidal but not necessarily cartesian, we can still deﬁne the category of linear lenses to be
Optic⊗. The internal hom provides a right adjoint to the evaluation-at-A functor, so we have immediately
Optic⊗((S, S′), (A, A′)) ∼= C(S, C(A′, S′) ⊗A)
where C(A′, S′) denotes the internal hom. If C is cartesian, this is of course isomorphic to the set of
(Get, Put) functions discussed earlier.
We cannot possibly use the three Put/Get style lens laws in this setting as we lack projections, but
specialising the coalgebra laws gives us:
Proposition 4.8.1. A linear lens p : S p→A is lawful iﬀthe following two concrete laws for Unzip hold:
evA,S Unzip = idS
(Rezip)
(coevC(A,S),A ⊗A)Unzip = ((Unzip ◦−) ⊗A)Unzip
(ZipZip)
where
Unzip ◦−: C(A, S) →C(A, C(A, S) ⊗A)
denotes internal composition and
coevC(A,S),A : C(A, S) →C(A, C(A, S) ⊗A)
is coevaluation.
We have essentially rederived the result given in [GJ12, Section 3.2] for ordinary lenses, but we note
that cartesianness was not required.
4.9
Eﬀectful Optics
Many proposed deﬁnitions of eﬀectful lenses [ASCG+16] have modiﬁed one or both of Get and Put to
produce results wrapped in a monadic action. There are disadvantages to this approach: it is not obvious
what the laws ought to be and there is no clear generalisation to other optic variants.
The general
deﬁnition of optic given in Section 2 suggests we instead work with the Kleisli category CT of some monad
(T, η, µ) : C →C.
36

Deﬁnition 4.9.1. The Kleisli category CT of a monad T has the same objects as C, with morphisms
X →Y in CT given by morphisms X →TY in C. Identity morphisms are given by the unit of T, and
the composite of two morphisms f : X →Y and g : Y →Z in CT is given by
X
f−→TY
Tg
−−→TTZ
µZ
−−→TZ
For f : X →Y in CT , we write f : X →TY for its underlying morphism in C.
Working in a Kleisli category presents its own set of diﬃculties. The product in C is a monoidal
product in a CT only when the monad in question is commutative, which rules out many monads of
interest. A premonoidal structure [PR97] is not suﬃcient: composition of optics would in that case not
be well deﬁned.
But this does not preclude the existence of monoidal actions on CT . In fact, there is a monoidal action
that has long been used under a diﬀerent guise:
Deﬁnition 4.9.2 ( [Mog91]). A strong monad T : C →C on a monoidal category (C, ⊗, I) is a monad
that is strong as a functor (Deﬁnition 4.5.4), and such that the strength commutes with the unit and
multiplication:
A ⊗B
A ⊗TB
T(A ⊗B)
A×ηB
ηA×B
θA,B
A ⊗T 2B
T(A ⊗TB)
T 2(A ⊗B)
A ⊗TB
T(A × B)
θA,T B
A⊗µB
TθA,B
µA⊗B
θA,B
Proposition 4.9.3. If T : C →C is a strong monad then C acts on CT by X · Y := X ⊗Y .
The crucial diﬀerence between this and a monoidal structure on CT is that we only demand X be
functorial with respect to pure functions in C, whereas Y must be functorial with respect to computations
in CT. We will write this action as X ⋊Y to highlight the diﬀerent roles played by X and Y .
Proof. Suppose T is a strong monad with strength θA,B : A ⊗TB →T(A ⊗B). For A ∈C, we have a
functor A ⊗−: CT →CT which on a morphism f : X →Y in CT is deﬁned to be the composite
A ⊗X
A⊗f
−−−→A ⊗TY
θA,Y
−−−→T(A ⊗Y )
For details, see [PR97, Theorem 4.2]. Our goal is to show this extends to a monoidal functor a : C →
[CT , CT ].
A morphism f : A →B in C induces a natural transformation A ⊗−⇒B ⊗−of functors CT →CT ,
with components A ⊗X →T(B ⊗X) given by composing A ⊗X →B ⊗X with the unit of the monad.
Naturality follows by the naturality of the strength and the unit of T.
Monoidality of a is shown exactly by the commutative diagrams in the deﬁnition of strong functor, i.e.
that the strength commutes with associator and left unitor of C.
Suppose C is a monoidal closed category and T : C →C is a strong monad. Then the evaluation-at-A
functor has a right adjoint:
CT (M ⋊A′, S′) = C(M × A′, TS′)
∼= C(M, C(A′, TS′))
Using the coalgebraic description, we see that concrete eﬀectful lenses consist of a single morphism in C
Munzip : S →T(C(A′, TS′) ⊗A).
The optic laws in this case specialise to:
37

Proposition 4.9.4. A concrete eﬀectful lens is lawful iﬀ
µST(evA,TS) Munzip = ηS
T(ηC(A,TS)⊗AcoevC(A,TS),A ⊗A)Munzip = T((Munzip ◦T −) ⊗A)Munzip
where
Munzip ◦T −: C(A, TS) →C(A, T(C(A, TS) ⊗A))
denotes internal Kleisli composition and
coevC(A,TS),A : C(A, TS) →C(A, C(A, TS) ⊗A)
is coevaluation.
Or, if you prefer do-notation, the two laws are:
do (c, a) <- munzip s
c a
==
return s
do (c, a) <- munzip s
let f a' = do
s' <- c a'
munzip s'
return (f, a)
==
do (c, a) <- munzip s
let f a' = (c, a')
return (f, a)
The inclusion of C into CT preserves the action of C, so there is an induced inclusion Optic⊗→Optic⋊.
If we choose a speciﬁc monad, we can hope to simplify the description of a concrete eﬀectful optic and
its laws.
4.9.1
Writer Lenses
We begin with a simple example. Suppose C has ﬁnite products.
Deﬁnition 4.9.5. The writer monad for a monoid W is deﬁned by
TW X = X × W
The unit, multiplication of TW are given by pairing with the unit and multiplication of W, and the
strength is simply the associativity morphism.
We can ﬁnd a more explicit description of concrete eﬀectful lenses for this monad.
Optic((S, S′), (A, A′)) =
Z M∈C
CTW (S, M ⋊A) × CTW (M ⋊A′, S′)
=
Z M∈C
C(S, M × A × W) × CTW (M ⋊A′, S′)
∼=
Z M∈C
C(S, M) × C(S, A × W) × CTW (M ⋊A′, S′)
∼= CTW (S, A) × CTW (S × A′, S′)
Fortunately, concrete writer lenses correspond to Get and Put functions in the Kleisli category of TW.
38

4.9.2
Stateful Lenses
Suppose C is cartesian closed.
Deﬁnition 4.9.6. The state monad with state Q is deﬁned by
TQX = C(Q, X × Q)
We call optics for the action ⋊: C × CTQ →CTQ stateful lenses. We can ﬁnd a concrete description
that is closer to that for ordinary lenses:
Optic⋊((S, S′), (A, A′)) =
Z M∈C
CTQ(S, M ⋊A) × CTQ(M ⋊A′, S′)
=
Z M∈C
C(S, C(Q, M × A × Q)) × CTQ(M ⋊A′, S′)
∼=
Z M∈C
C(S × Q, M × A × Q) × CTQ(M ⋊A′, S′)
∼=
Z M∈C
C(S × Q, M) × C(S × Q, A × Q) × CTQ(M ⋊A′, S′)
∼= C(S × Q, A × Q) × CTQ((S × Q) ⋊A′, S′)
∼= CTQ(S, A) × CTQ(S × Q × A′, S′)
By analogy with ordinary lenses, let us call these maps MGet and MPut. The induced composition
of eﬀectful lenses is a little intricate, and is possibly best explained in code. The composite MGet is
straightforward, just the composite of MGet1 and MGet2 in the Kleisli category. For MPut however,
there is some curious plumbing of the state into diﬀerent places. Tracing through the isomorphism, two
stateful lenses (MGet1, MPut1) : (T, T ′) p→(S, S′) and (MGet2, MPut2) : (S, S′) p→(A, A′) compose as
follows.
mget t = do
s <- mget1 t
mget2 s
mput t q a = do
start <- getState
s <- mget1 t
q' <- getState
putState start
s' <- mput1 s q' a
mput2 t q s'
Proposition 4.9.7. A stateful lens given by
mget :: s -> State q a
mput :: s -> q -> a -> State q s
is lawful iﬀthe following three laws hold:
do
q <- getState
a <- mget s
mput s q a
==
return s
do s' <- mput s q a
mget s'
==
return a
let (s', q')
= runState (mput s q1 a1) q2
in mput s' q' a2
==
mput s q1 a2
39

By analogy we call these the GetPut, PutGet and PutPut laws.
Of course, this notion of eﬀectful lens may not be useful! It is hard to get intuition for the meaning of
the laws, but they seem to suﬀer from the same deﬁciency that other attempts at eﬀectful lenses do: they
are too strong. The GetPut law here appears easier to satisfy than the MGetPut0 law of [ASCG+16], as
MPut is given access to the original state. However, our PutGet law seems very restrictive: no matter
what auxiliary state is provided, Putting then Getting must leave the state unchanged.
4.10
Further Examples
The dedicated reader may enjoy deriving the concrete representation and laws for the following optic
varieties:
• “Achromatic” Lenses [Boi17, Section 5.2] are lenses that also admit an operation Create : A →S.
These are optics for the action of C on itself by M ·A = (M ⊔1)×A, or equivalently, of the category
of pointed objects of C on C by cartesian product. Concrete achromatic lenses (S, S′) p→(A, A′) are
elements of the set
C(S, C(A′, S′) ⊔1) × C(S, A) × C(A′, S′).
• Aﬃne Traversals [JO15] allow access to a target that may or may not be present. Suppose C is
cartesian closed and has binary coproducts.
Let Aﬀbe the category C × C, equipped with the
monoidal structure
(P ′, Q′) ⊗(P, Q) = (P ′ ⊔(Q′ × P), Q′ × Q)
The category Aﬀacts on C by (P, Q) · A = P ⊔(Q × A), in fact, Aﬀis cooked up to act on C exactly
by the closure of the actions −× A and −⊔A under composition. A concrete aﬃne traversal is an
element of
C(S, S′ ⊔(C(A′, S′) × A)).
Aﬃne traversals are described in the folklore as pairs of maps C(S, A ⊔S′) × C(S × A′, S′). Such a
pair does determine an aﬃne traversal, but gives more information than is necessary: the right-hand
map need not be deﬁned at all S.
• Grates [O’C15] are optics for the contravariant action of a monoidal closed category C on itself by
X · A 7→C(X, A). Concretely these correspond to morphisms
C(C(C(S, A), A′), S′).
5
The Profunctor Encoding
To use optics in practice, one could take the deﬁnition of the optic category and translate it almost
verbatim into code—using an existential type in place of the coend. In Haskell syntax, lenses would be
deﬁned as:
data Lens s s' a a' = forall m. Lens {
l :: s -> (m, a),
r :: (m, a') -> s'
}
40

This not the approach usually taken by implementations!
Instead the somewhat indirect profunctor
encoding is used. (This is not quite true for the Haskell lens library, for a few reasons lens uses the
closely related van Laarhoven encoding, see Section 5.5. The Purescript purescript-profunctor-lenses
library [Fre] does use the profunctor encoding directly.)
The equivalence between the profunctor encoding and optics as described earlier has been explored
in [PGW17] and [Mil17]. We begin by reviewing this equivalence from a categorical perspective before
investigating how the optic laws manifest in this setting.
5.1
Tambara Modules
Let I = C(−, =) : C p→C be the identity profunctor and ⊙be profunctor composition, written in dia-
grammatic order. The following section generalises deﬁnitions that ﬁrst appeared in [PS08, Section 3] for
monoidal categories to the more general case of a monoidal action.
Deﬁnition 5.1.1. Suppose a category C is acted on by (M, ⊗, I) and let P ∈Prof(C, C) be a profunctor.
A Tambara module structure for M on P is a family of maps:
ζA,B,M : P(A, B) →P(M · A, M · B)
natural in A and B, dinatural in M, and such that ζ commutes with the action of M:
P(A, B)
P(M · A, M · B)
P((N ⊗M) · A), (N ⊗M) · B)
P(N · (M · A), N · (M · B))
ζA,B,M
ζA,B,N⊗M
ζM·A,M·B,N
αN,M,A
P(A, B)
P(I · A, I · B)
P(A, B)
ζA,B,I
P (λ−1
A ,λB)
for all A, B ∈C and N, M ∈M.
Note that the identity profunctor I has a canonical Tambara module structure ζA,B,M : C(A, B) →
C(M · A, M · B) for any M, given by functoriality.
If P, Q ∈Prof(C, C) are equipped with module structures ζ and ξ respectively, there is a canonical
module structure on P ⊙Q. Given M ∈M and A, B ∈C, the structure map (ζ ⊙ξ)A,B,M is induced by
P(A, C) × Q(C, B)
ζA,C,M ×ξC,B,M
−−−−−−−−−−→
P(M · A, M · C) × Q(M · C, M · B)
coprM·C
−−−−−→
Z C∈C
P(M · A, C) × Q(C, M · B)
=
(P ⊙Q)(M · A, M · B)
Deﬁnition 5.1.2. There is a category TambM of Tambara modules and natural transformations that
respect the module structure, in the sense that for any l : P →Q, the diagram
P(A, B)
P(M · A, M · B)
Q(A, B)
Q(M · A, M · B)
ζA,B,M
lA,B
lM·A,M·B
ξA,B,M
commutes.
This category is monoidal with respect to ⊙as given above with monoidal unit I. There is an evident
forgetful functor U : TambM →Prof(C, C) that is strong monoidal. This forgetful functor has both a
left and right adjoint; important for us is the left adjoint: (The right adjoint to U is described in [RJ17],
used there to investigate Haskell’s Arrow typeclass.)
41

Deﬁnition 5.1.3 ( [PS08, Section 5]). Let ΦM : Prof(C, C) →TambM be the functor:
ΦM(P) :=
Z M∈M
C(−, M · =) ⊙P ⊙C(M · −, =)
Or, in other words,
ΦM(P)(A, B) :=
Z M∈M Z C,D∈C
C(A, M · C) × P(C, D) × C(M · D, B)
The module structure ζA,B,M : ΦMP(A, B) →ΦMP(M · A, M · B) is induced by the maps
C(A, N · C) × P(C, D) × C(N · D, B)
functoriality
−−−−−−−→
C(M · A, M · N · C) × P(C, D) × C(M · N · D, M · B)
coprM⊗N
−−−−−−→
Z N∈M Z C,D∈C
C(M · A, N · C) × P(C, D) × C(N · D, M · B)
=
ΦMP(M · A, M · B)
for all C, D ∈C and N ∈M. Equationally, this is ζA,B,M(⟨l | p | r⟩) = ⟨M · l | p | M · r⟩.
Proposition 5.1.4. ΦM : Prof(C, C) →TambM is left adjoint to U : TambM →Prof(C, C).
Proof. For any P ∈Prof(C, C), there is a map η : P p→UΦMP, given by η(p) = ⟨idA | p | idB⟩. Suppose
we have an element ⟨l | p | r⟩∈ΦMP(A, B). One can check that this element is equal to
⟨l | p | r⟩= (ΦMP(l, r))ζA,B,M η(p)
where ζA,B,M is the module structure map for ΦMP.
If T ∈TambM is a Tambara module with structure map ξ, we would like to show that for any map
f : P p→UT there exists a unique ˆf : ΦMP p→T so that f factors as
P
η−→UΦMP
U ˆf
−−→UT.
The data of such a map ˆf : ΦMP p→T is a natural transformation between the underlying profunctors.
For the factorisation property to hold we must have that ˆfη(p) = f(p) for any p ∈P(A, B), but then the
action on the remainder of ΦMP(A, B) is ﬁxed:
ˆf(⟨l | p | r⟩) = ˆf(ΦMP(l, r)ζA,B,M η(p))
= T(l, r) ξA,B,N f(p)
This establishes uniqueness. It remains to show that ˆf so deﬁned is actually a Tambara module morphism,
but this is easy:
ˆfζA,B,N(⟨l | p | r⟩) = ˆf(⟨N · l | p | N · r⟩)
(deﬁnition of ζ)
= T(N · l, N · r) ξA,B,N⊗M f(p)
(deﬁnition of ˆf)
= T(N · l, N · r)ξM·A,M·B,N ξA,B,M f(p)
(ξ commutes with tensor in M)
= ξA,B,NT(l, r) ξA,B,M f(p)
(naturality of ξ)
= ξA,B,N ˆf(⟨l | p | r⟩)
(deﬁnition of ˆf)
Corollary 5.1.5. ΦM (and therefore also UΦM) is oplax monoidal.
Proof. This follows from abstract nonsense as ΦM is the left adjoint of a strong monoidal functor,
see [Kel74].
42

5.2
Optics
Deﬁnition 5.2.1. For a pair of objects A, A′ ∈C, the exchange profunctor EA,A′ is deﬁned to be
C(−, A) × C(A′, =).
Given a profunctor, or indeed a Tambara module, we can evaluate it at any two objects of C. This
process is functorial in the choice of Tambara module, giving a functor (U−)(A, A′) : TambM →Set.
Lemma 5.2.2. The functor (U−)(A, A′) : TambM →Set is representable: there is a isomorphism
(U−)(A, A′) ∼= TambM(ΦMEA,A′, −)
Proof. We have the chain of isomorphisms:
(U−)(A, A′)
∼=
Z
X,Y ∈C
Set(C(X, A) × C(A′, Y ), (U−)(X, Y ))
(by Yoneda reduction twice)
=
Z
X,Y ∈C
Set(EA,A′(X, Y ), (U−)(X, Y ))
(by deﬁnition)
∼= Prof(EA,A′, U−)
(natural transformations as ends)
∼= TambM(ΦMEA,A′, −)
(by adjointness)
Note that the value of ΦMEA,A′ at (X, Y ) is precisely the set of optics (X, Y ) p→(A, A′):
ΦMEA,A′(X, Y ) =
Z M∈M Z C,D∈C
C(X, M · C) × EA,A′(C, D) × C(M · D, Y )
=
Z M∈M Z C,D∈C
C(X, M · C) × C(C, A) × C(A′, D) × C(M · D, Y )
∼=
Z M∈M
C(X, M · A) × C(M · A′, Y )
For convenience we identify ΦMEA,A′(X, Y ) with OpticM((X, Y ), (A, A′)).
We can now show that profunctor optics are precisely optics in the ordinary sense.
Proposition 5.2.3 (Profunctor Optics are Optics).
[TambM, Set]((U−)(A, A′), (U−)(S, S′)) ∼= OpticM((S, S′), (A, A′))
Proof. We have the chain of isomorphisms:
[TambM, Set]((U−)(A, A′), (U−)(S, S′))
∼= [TambM, Set](TambM(ΦMEA,A′, −), (U−)(S, S′))
(by Lemma 5.2.2)
∼= (UΦMEA,A′)(S, S′)
(by Yoneda)
= OpticM((S, S′), (A, A′))
For p : (S, S′) p→(A, A′), let ˜p : (U−)(A, A′) ⇒(U−)(S, S′) denote the corresponding natural trans-
formation under this isomorphism, and for t : (U−)(A, A′) ⇒(U−)(S, S′), let ˆt : (S, S′) p→(A, A′) be the
corresponding optic.
Corollary 5.2.4. A profunctor optic t is determined by its component at ΦMEA,A′, and furthermore, this
component is determined by its value on

λ−1
A | λA′
∈(UΦMEA,A′)(A, A′).
43

Proof. This is the content of the ﬁrst two isomorphisms above.
Explicitly, suppose p = ⟨l | r⟩with
l : S →M · A and r : M · A′ →S′. Then for any Tambara module P, the component of ˜p at P is
˜pP = (UP)(l, r)ζA,A′,M
where ζ is the module structure for P. In particular,
˜pΦMEA,A′(

λ−1
A | λA′
) = ⟨l | r⟩
We ﬁnish with one ﬁnal isomorphic description of an optic:
Proposition 5.2.5. OpticM((S, S′), (A, A′)) is isomorphic to TambM(ΦMES,S′, ΦMEA,A′).
Proof. This follows from the previous two propositions and the Yoneda lemma:
OpticM((S, S′), (A, A′))
∼= [TambM, Set]((U−)(A, A′), (U−)(S, S′))
∼= [TambM, Set](TambM(ΦMEA,A′, −), TambM(ΦMES,S′, −))
∼= TambM(ΦMES,S′, ΦMEA,A′)
Explicitly, an optic p = ⟨l | r⟩corresponds to the natural transformation with components:
tX,Y : ΦMES,S′(X, Y ) →ΦMEA,A′(X, Y )
tX,Y (⟨f | g⟩) = ⟨(M · l)f | g(M · r)⟩
where M is the residual for the representative ⟨f | g⟩. This is exactly the formula for optic composition!
5.3
Lawful Profunctor Optics
The next goal is to characterise the profunctor optics that correspond to lawful optics.
The exchange profunctor EA,A, hereafter abbreviated to EA, has a comonoid structure, where the
comultiplication ∆: EA →EA ⊙EA and counit ε : EA →C are given by
∆X,Y : (EA)(X, Y ) →(EA ⊙EA)(X, Y )
∆X,Y (⟨f | g⟩) = ⟨f | idA | g⟩
εX,Y : (EA)(X, Y ) →C(X, Y )
εX,Y (⟨f | g⟩) = gf
respectively. Here we have identiﬁed EA ⊙EA with the profunctor C(−, A) × C(A, A) × C(A, =), via the
isomorphism
EA ⊙EA =
Z Z∈C
EA(−, Z) × EA(Z, =)
=
Z Z∈C
C(−, A) × C(A, Z) × C(Z, A) × C(A, =)
∼= C(−, A) × C(A, A) × C(A, =)
Because ΦM is oplax monoidal, the Tambara module ΦMEA has an induced comonoid structure, in
this case given by
∆X,Y : (ΦMEA)(X, Y ) →(ΦMEA ⊙ΦMEA)(X, Y )
∆(⟨l | r⟩) = ⟨l | idM·A | r⟩
εX,Y : (ΦMEA)(X, Y ) →C(X, Y )
ε(⟨l | r⟩) = rl
The connection with lawfulness is hopefully now evident!
44

Proposition 5.3.1. An optic p : S p→A is lawful iﬀthe corresponding natural transformation ΦMES →
ΦMEA is a comonoid homomorphism.
Proof. For t : ΦMES →ΦMEA to be a comonoid homomorphism means that the following diagrams
commute for every X, Y ∈C:
(ΦMES)(X, Y )
(ΦMEA)(X, Y )
C(X, Y )
C(X, Y )
tX,Y
εX,Y
εX,Y
(ΦMES)(X, Y )
(ΦMEA)(X, Y )
(ΦMES ⊙ΦMES)(X, Y )
(ΦMEA ⊙ΦMEA)(X, Y )
tX,Y
∆X,Y
∆X,Y
(t⊙t)X,Y
Suppose t corresponds to an optic with representative ⟨l | r⟩with residual M and we have an element
⟨f | g⟩: (ΦMES)(X, Y ) with residual N. The left diagram requires that
g(Nr)(Nl)f = gf,
as an element of C(X, Y ). This is certainly true as rl = idS. The right diagram claims that
⟨(N · l)f | idN·M·A | g(N · r)⟩= ⟨(N · l)f | (N · r)(N · l) | g(N · r)⟩
But this holds by exactly the same argument as used in Proposition 3.0.8 to show that the composite of
lawful optics is lawful: by transplanting the relations showing the second optic law for ⟨l | r⟩
For the backward direction, consider the above diagrams specialised to X = Y = S. Tracing the
element

λ−1
S
| λS

∈(ΦMES)(S, S) around the commutative diagrams yields precisely the ﬁrst and
second optic laws respectively.
All that is needed to complete the connection with profunctor optics is the following standard result
in category theory.
Lemma 5.3.2. For an object X in a monoidal category (C, ⊗, I), a comonoid structure (X, ∆, ε) is
equivalent to a lax monoidal structure on the functor C(X, −) : C →Set, considering Set as a monoidal
category with respect to ×.
Further, a morphism (X1, ∆1, ε1) →(X2, ∆2, ε2) is a comonoid homomorphism iﬀthe induced natural
transformation C(X2, −) ⇒C(X1, −) is monoidal.
Proof. This is a follow-your-nose result!
Theorem 5.3.3. p : S p→A is a lawful optic iﬀthe associated natural transformation ˜p : (U−)(A, A) ⇒
(U−)(S, S) is monoidal with respect to the canonical lax monoidal structures on (U−)(A, A) and (U−)(S, S).
Proof.
p : S p→A is lawful
⇔ΦMES →ΦMEA is a comonoid homomorphism
⇔TambM(ΦMEA, −) ⇒TambM(ΦMES, −) is a monoidal natural transformation
⇔(U−)(A, A) ⇒(U−)(S, S) is a monoidal natural transformation
45

5.4
Implementation
We review quickly how the profunctor encoding is translated into code in the Haskell [Kme] and Pure-
script [Fre] libraries. We deﬁne a typeclass for profunctors:
class Profunctor p where
dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
To be considered a valid instance of Profunctor, the function dimap must behave functorially. Now, for
each optic variant we wish to deﬁne, we create a typeclass for the corresponding Tambara module. In the
case of Lenses, this typeclass is named Strong:
class Profunctor p => Strong p where
second :: p a b -> p (c, a) (c, b)
This second function is the equivalent of the structure map ζ for the Tambara module. We require this
map to satisfy the Tambara module coherences, but as with any deﬁnition in Haskell, these equations
must be checked manually.
Now the type of lenses (S, S′) p→(A, A′) is the direct translation of the set of natural transformations
(U−)(A, A′) ⇒(U−)(S, S′):
type Lens s s' a a' = forall p. Strong p => p a a' -> p s s'
where we use parametricity in p as a proxy for naturality. A profunctor lens
l :: forall p. Strong p => p a a -> p s s
is lawful if it is monoidal as a natural transformation. In code this is:
l id == id
l (Procompose p q) == Procompose (l p) (l q)
where
data Procompose p q d c where
Procompose :: p x c -> q d x -> Procompose p q d c
denotes profunctor/Tambara module composition, once equipped with appropriate Profunctor and Strong
instances.
5.5
The van Laarhoven Encoding
Some optic variants can be encoded in a profunctor-like style without requiring the full complexity of
profunctors. Chronologically this development came before profunctor optics, and was ﬁrst introduced
by Twan van Laarhoven [vL09a].
The van Laarhoven encoding for Lenses, Traversals and Setters is:
type Lens s a
= forall f. Functor f
=> (a -> f a) -> (s -> f s)
type Traversal s a = forall f. Applicative f => (a -> f a) -> (s -> f s)
type Setter s a
= forall f. Settable f
=> (a -> f a) -> (s -> f s)
What allows such a description to work for these particular optic variants is that the Tambara module
that characterises them, ΦMEA, can be written in the form C(−, f =) for some f that is an instance of
the corresponding typeclass. This is possible in particular for the optic variants that admit a coalgebraic
description; the ones for which the evaluation-at-A functor has a right adjoint.
46

No expressive power is lost by deﬁning an optic to operate only on functions of the shape a -> f a',
as the entire concrete description of the optic can be extracted from its value on that particular Tambara
module. The same is not true for other optic variants, and indeed in the Haskell lens library, Prisms and
Reviews take a form much closer to the profunctor encoding. (The lens library does not use precisely
the profunctor encoding even here, for backwards compatibility reasons.)
A consequence is that the laws typically given for Traversals actually only need to be checked for
the applicative functor we earlier called UR∗. In Haskell this functor is implemented as FunList [vL09b]
or Bazaar [Kme].
6
Future Work
There are many avenues for future exploration!
6.1
Mixed Optics
One can generalise the deﬁnition of Optic so that the two halves lie in diﬀerent categories. Suppose
CL and CR are categories that are acted on by a common monoidal category M. Write these actions as
L : M →[CL, CL] and
R : M →[CR, CR] respectively.
Deﬁnition 6.1.1. Given two objects of CL×Cop
R , say (S, S′) and (A, A′), a mixed optic p : (S, S′) p→(A, A′)
for
L and
R is an element of the set
Optic L , R ((S, S′), (A, A′)) :=
Z M∈M
CL(S, M L A) × CR(M R A′, S′)
Optic L , R forms a category. It is not so clear what notion of lawfulness is appropriate in this setting.
Examples of mixed optics include the degenerate optics of the lens library: Getters, Reviews and
Folds. The mixed optic formalism also appears able to capture indexed optics such as IndexedLenses
and IndexedTraversals [Mil17].
6.2
Monotonic Lenses
In the bidirectional transformation community, the PutPut law is often considered too strong.
In
particular we have seen that in Set, together with the other laws, it implies that Get must be a projection
from a product.
To overcome this we work in Cat, so that the objects under consideration have internal morphisms
that we think of as updates. We modify Put so that instead of accepting an object a of A to overwrite
the original in S with, it requires a morphism in A of the form Get(s) →a. In this way we are restricted
in what updates we may perform. This is captured in the following deﬁnition:
Deﬁnition 6.2.1 ( [JRW12, Deﬁnition 4.1]). A c-lens S p→A in Cat is a pair of functors
Get : S →A
Put : (Get ↓idA) →S
such that a version of the three lens laws hold, where (Get ↓idA) denotes the comma category construc-
tion.
We can rewrite this in a form that gives hope for a correspondence with some optic category:
Theorem 6.2.2. The data of a c-lens S p→A corresponds to a functor
S →
Z
[(−/A), S]
47

where (−/A) denotes the slice category and
R
denotes (confusingly!) the Grothendieck construction.
Furthermore, a c-lens is lawful iﬀit is a coalgebra for the comonad of the adjunction
[Aop, Cat]
Cat
R
⊥
X7→[(−/A),X]
It is not clear whether there is an action on Cat that generates this description as its concrete optics.
There doesn’t seem to be a natural place for an A′ to appear! We remain optimistic:
Conjecture 6.2.3. c-lenses are the lawful (possibly mixed) optics for some action on Cat.
6.3
Functor and Monad Transformer Lenses
These were considered by Edward Kmett [Kme16] as a method for embedding pieces of a monad trans-
former stack into the whole. There is some debate about the correct categorical description of monad
transformers [JM10,Man12], so we do not attempt to say anything precise, but the perspective given here
could help in a couple of ways.
Kmett considers optics for the operation of composing two monad transformers. The primary test-case
was to embed ReaderT actions into StateT actions, but from the constant-complement perspective, this
is impossible: StateT does not factor as the composite of ReaderT with some other monad transformer.
In this setting the constant-complement laws may be asking too much, the optic laws given here might
be the correct notion of lawfulness for monad transformers.
Also, instead of considering optics within a category of monad transformers, we could instead look at
optics for the action of monad transformers on monads. One can indeed deﬁne an optic State p→Reader
that uses residual StateT. Whether this is lawful or useful is not clear!
6.4
Learners
A recent paper in applied category theory [FST17] describes a compositional approach to machine learning,
with a category whose morphisms describe learning algorithms.
Deﬁnition 6.4.1 ( [FST17, Deﬁnition 2.1]). For A and B sets, a learner A p→B is a tuple (P, I, U, r)
where P is a set, and I, U, and r are functions of shape:
I : P × A →B
U : P × A × B →P
r : P × A × B →A
To form a category, one must consider learners up to an equivalence relation on the sets P. There is
an alternate slick description of the set of learners A p→B, that goes as follows. Note that the data of a
learner is describing an element of the coend
Z P,Q∈Set
Set(P × A, Q × B) × Set(Q × B, P × A)
48

via the isomorphisms
Z P,Q∈Set
Set(P × A, Q × B) × Set(Q × B, P × A)
∼=
Z P,Q∈Set
Set(P × A, Q) × Set(P × A, B) × Set(Q × B, P × A)
∼=
Z P ∈Set
Set(P × A, B) × Set(P × A × B, P × A)
∼=
Z P ∈Set
Set(P × A, B) × Set(P × A × B, P) × Set(P × A × B, A)
Composition of learners can be deﬁned analogously to composition for optics. This perspective explains
the slight fussing around required in dealing with equivalence classes of learners, and suggests a generali-
sation to other monoidal categories.
References
[AC09]
Samson Abramsky and Bob Coecke. Categorical quantum mechanics. In Handbook of quan-
tum logic and quantum structures—quantum logic, pages 261–323. Elsevier/North-Holland,
Amsterdam, 2009.
[ASCG+16] Faris Abou-Saleh, James Cheney, Jeremy Gibbons, James McKinna, and Perdita Stevens.
Reﬂections on monadic lenses. In A list of successes that can change the world, volume 9600
of Lecture Notes in Comput. Sci., pages 1–31. Springer, [Cham], 2016.
[Atk09]
Robert Atkey. Algebras for parameterised monads. In Algebra and coalgebra in computer
science, volume 5728 of Lecture Notes in Comput. Sci., pages 3–17. Springer, Berlin, 2009.
[BG18]
Guillaume Boisseau and Jeremy Gibbons. What you needa know about yoneda: Profunctor
optics and the yoneda lemma (functional pearl). Proc. ACM Program. Lang., 2(ICFP):84:1–
84:27, July 2018.
[Boi17]
Guillaume Boisseau. Understanding Profunctor Optics: a representation theorem. Master’s
thesis, University of Oxford, 2017.
[dP89]
V. C. V. de Paiva.
The Dialectica categories.
In Categories in Computer Science and
Logic (Boulder, CO, 1987), volume 92 of Contemp. Math., pages 47–62. Amer. Math. Soc.,
Providence, RI, 1989.
[Far08]
Emilio Faro.
On the trace of an endofunctor of a small category.
Centre de Recerca
Matem`atica, 2008.
[FGM+07]
J Nathan Foster, Michael B Greenwald, Jonathan T Moore, Benjamin C Pierce, and Alan
Schmitt.
Combinators for bidirectional tree transformations:
A linguistic approach to
the view-update problem.
ACM Transactions on Programming Languages and Systems
(TOPLAS), 29(3):17, 2007.
[FHP15]
Sebastian Fischer, Zhenjiang Hu, and Hugo Pacheco. A clear picture of lens laws: functional
pearl. In Mathematics of program construction, volume 9129 of Lecture Notes in Comput.
Sci., pages 215–223. Springer, Cham, 2015.
[Fre]
Phil
Freeman.
purescript-profunctor-lenses.
Available
from
https://github.com/purescript-contrib/purescript-profunctor-lenses.
With
contributions from: Brian Marick, Lukas Heidemann, Gary Burgess and others.
49

[FST17]
Brendan Fong, David I Spivak, and R´emy Tuy´eras. Backprop as functor: A compositional
perspective on supervised learning. ArXiv e-prints, November 2017.
[GH18]
Neil Ghani and Jules Hedges. Compositional game theory. In IEEE Symposium on Logic in
Computer Science, 2018. (to appear).
[GJ12]
Jeremy Gibbons and Michael Johnson. Relating algebraic and coalgebraic descriptions of
lenses. Electronic Communications of the EASST, 49, 2012.
[Gre17]
Oleg Grenrus. Aﬃne traversal. Available from http://oleg.fi/gists/posts/2017-03-20-affine-tra
March 2017.
[Hed17]
J. Hedges. Coherence for lenses and open games. ArXiv e-prints, April 2017.
[JK02]
G. Janelidze and G. M. Kelly. A note on actions of a monoidal category. Theory Appl. Categ.,
9:61–91, 2001/02. CT2000 Conference (Como).
[JM10]
Mauro Jaskelioﬀand Eugenio Moggi. Monad transformers as monoid transformers. Theoret.
Comput. Sci., 411(51-52):4441–4466, 2010.
[JO15]
Mauro Jaskelioﬀand Russell O’Connor. A representation theorem for second-order function-
als. J. Funct. Programming, 25:e13, 36, 2015.
[JR12]
Mauro Jaskelioﬀand Ondrej Rypacek. An investigation of the laws of traversals. In Proceed-
ings Fourth Workshop on Mathematically Structured Functional Programming, pages 40–49,
2012.
[JRW10]
Michael Johnson, Robert Rosebrugh, and Richard Wood. Algebras and update strategies.
J.UCS, 16(5):729–748, 2010.
[JRW12]
Michael Johnson, Robert Rosebrugh, and R. J. Wood.
Lenses, ﬁbrations and universal
translations. Math. Structures Comput. Sci., 22(1):25–42, 2012.
[JSV96]
Andr´e Joyal, Ross Street, and Dominic Verity.
Traced monoidal categories.
Math. Proc.
Cambridge Philos. Soc., 119(3):447–468, 1996.
[Kel74]
G. M. Kelly. Doctrinal adjunction, pages 257–280. Lecture Notes in Math., Vol. 420. Springer,
Berlin, 1974.
[Kme]
Edward
Kmett.
lens:
Lenses,
folds
and
traversals.
Available
from
https://hackage.haskell.org/package/lens.
With
contributions
from:
Shachaf
Ben-Kiki, Elliott Hird, Johan Kiviniemi, Bas Dirks, Eric Mertens, Michael Sloan, Alexander
Altman, Austin Seipp, Dag Odenhall, Aristid Breitkreuz, Simon Hengel, Lizzie Dixon,
Mike Ledger, Niklas Haas, Adrian Keet, Matvey B. Aksenov, Eyal Lotem, Oliver Charles,
Liyang HU, Carter Schonwald, Mark Wright, Nathan van Doorn, Ville Tirronen, Mikhail
Vorozhtsov, Brent Yorgey, Dan Ros´en, Yair Chuchem, Michael Thompson, John Wiegley,
Jonathan Fischoﬀ, Bradford Larsen, Alex Mason and Ryan Scott.
[Kme16]
Edward Kmett. Monad Transformer Lenses. https://www.youtube.com/watch?v=Bxcz23GOJqc,
July 2016.
[Koc72]
Anders Kock. Strong functors and monoidal monads. Arch. Math. (Basel), 23:113–120, 1972.
[Lor15]
Fosco Loregian. This is the (co)end, my only (co)friend. ArXiv e-prints, January 2015.
50

[Man12]
Oleksandr Manzyuk. Calculating monad transformers with category theory. Available from
https://oleksandrmanzyuk.files.wordpress.com/2012/02/calc-mts-with-cat-th1.pdf,
February 2012.
[Mil17]
Bartosz
Milewski.
Profunctor
optics:
The
categorical
view.
Available
from
https://bartoszmilewski.com/2017/07/07/profunctor-optics-the-categorical-view/,
July 2017.
[Mog91]
Eugenio Moggi. Notions of computation and monads. Inform. and Comput., 93(1):55–92,
1991. Selections from the 1989 IEEE Symposium on Logic in Computer Science.
[O’C15]
Russell
O’Connor.
Grate:
A
new
kind
of
optic.
Available
from
https://r6research.livejournal.com/28050.html, November 2015.
[PGW17]
Matthew Pickering, Jeremy Gibbons, and Nicolas Wu.
Profunctor optics: Modular data
accessors. Programming Journal, 1(2):7, 2017.
[PR97]
John Power and Edmund Robinson. Premonoidal categories and notions of computation.
Math. Structures Comput. Sci., 7(5):453–468, 1997. Logic, domains, and programming lan-
guages (Darmstadt, 1995).
[PS08]
Craig Pastro and Ross Street. Doubles for monoidal categories. Theory Appl. Categ., 21:No.
4, 61–75, 2008.
[RJ17]
Exequiel Rivas and Mauro Jaskelioﬀ. Notions of computation as monoids. J. Funct. Pro-
gramming, 27:e21, 42, 2017.
[vL09a]
Twan
van
Laarhoven.
Cps
based
functional
references.
Available
from
https://www.twanvl.nl/blog/haskell/cps-functional-references, July 2009.
[vL09b]
Twan
van
Laarhoven.
A
non-regular
data
type
challenge.
Available
from
https://twanvl.nl/blog/haskell/non-regular1, April 2009.
51

