48
Recursive Subtyping for All
LITAO ZHOUâˆ—and YAODA ZHOUâˆ—, The University of Hong Kong, China
BRUNO C. D. S. OLIVEIRA, The University of Hong Kong, China
Recursive types and bounded quantification are prominent features in many modern programming languages,
such as Java, C#, Scala or TypeScript. Unfortunately, the interaction between recursive types, bounded
quantification and subtyping has shown to be problematic in the past. Consequently, defining a simple
foundational calculus that combines those features and has desirable properties, such as decidability, transitivity
of subtyping, conservativity and a sound and complete algorithmic formulation has been a long time challenge.
This paper presents an extension of kernel ğ¹â‰¤, called ğ¹ğœ‡
â‰¤, with iso-recursive types. ğ¹â‰¤is a well-known
polymorphic calculus with bounded quantification. In ğ¹ğœ‡
â‰¤we add iso-recursive types, and correspondingly
extend the subtyping relation with iso-recursive subtyping using the recently proposed nominal unfolding
rules. We also add two smaller extensions to ğ¹â‰¤. The first one is a generalization of the kernel ğ¹â‰¤rule for
bounded quantification that accepts equivalent rather than equal bounds. The second extension is the use of so-
called structural folding/unfolding rules, inspired by the structural unfolding rule proposed by Abadi, Cardelli,
and Viswanathan. The structural rules add expressive power to the more conventional folding/unfolding
rules in the literature, and they enable additional applications. We present several results, including: type
soundness; transitivity and decidability of subtyping; the conservativity of ğ¹ğœ‡
â‰¤over ğ¹â‰¤; and a sound and
complete algorithmic formulation of ğ¹ğœ‡
â‰¤. Moreover, we study an extension of ğ¹ğœ‡
â‰¤, called ğ¹ğœ‡
â‰¤â‰¥, which includes
lower bounded quantification in addition to the conventional (upper) bounded quantification of ğ¹â‰¤. All the
results in this paper have been formalized in the Coq theorem prover.
CCS Concepts: â€¢ Theory of computation â†’Type theory; â€¢ Software and its engineering â†’Object
oriented languages.
Additional Key Words and Phrases: Iso-Recursive Subtyping, Bounded Polymorphism, Object Encodings
ACM Reference Format:
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira. 2023. Recursive Subtyping for All. Proc. ACM Program.
Lang. 7, POPL, Article 48 (January 2023), 29 pages. https://doi.org/10.1145/3571241
1
INTRODUCTION
Recursive types and bounded quantification are two prominent features in many modern program-
ming languages, such as Java, C#, Scala or TypeScript. Bounded quantification was introduced
by Cardelli and Wegner [1985] in the Fun language, and has been widely studied [Cardelli et al.
1994; Curien and Ghelli 1992; Pierce 1994]. Bounded quantification addresses the interaction be-
tween parametric polymorphism and subtyping, allowing polymorphic variables to have subtyping
bounds. Recursive types are needed in practically all programming languages to model recursive
data structures (such as lists or trees), or recursive object types in Object-Oriented Programming
âˆ—Both authors contributed equally to this work.
Authorsâ€™ addresses: Litao Zhou; Yaoda Zhou, Department of Computer Science, The University of Hong Kong, Hong Kong,
China, ltzhou@cs.hku.hk, ydzhou@cs.hku.hk; Bruno C. d. S. Oliveira, Department of Computer Science, The University of
Hong Kong, Hong Kong, China, bruno@cs.hku.hk.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
Â© 2023 Copyright held by the owner/author(s).
2475-1421/2023/1-ART48
https://doi.org/10.1145/3571241
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:2
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
(OOP) languages to encode binary methods [Bruce et al. 1995]. For adding recursive types to a
language with subtyping, it is desirable to have recursive subtyping between recursive types. The
first rules for recursive subtyping, due to Cardelli [1985], are the well-known Amber rules. Recursive
subtyping has been studied in two different forms: equi-recursive subtyping [Amadio and Cardelli
1993; Brandt and Henglein 1997; Gapeyev et al. 2003], and iso-recursive subtyping [Bengtson et al.
2011; Ligatti et al. 2017; Zhou et al. 2020, 2022]. In equi-recursive subtyping recursive types and
their unfoldings are considered to be equal. In contrast, in iso-recursive subtyping they are only
isomorphic and explicit fold/unfold operators are necessary to witness the isomorphism.
From the mid-80s and throughout the 90s there was a lot of work on establishing the type-
theoretic foundations for OOP. Both recursive subtyping, as well as bounded quantification played
a major part on this effort. The two features were perceived to be important to model objects
in some forms of object encodings. At that time the key ideas around ğ¹â‰¤[Cardelli et al. 1994;
Cardelli and Wegner 1985; Curien and Ghelli 1992], which is a polymorphic calculus with bounded
quantification (but no recursive types) were reasonably well understood due to the early work on
the Fun language by Cardelli and Wegner. Therefore ğ¹â‰¤-like calculi were being used in foundational
work on OOP. Some landmark papers on the foundations of OOP, which established important
results such as the distinction between inheritance and subtyping [Cook et al. 1989], f-bounded
quantification [Canning et al. 1989], or encodings of objects [Abadi et al. 1996; Bruce et al. 1999;
Cook et al. 1989], essentially assumed some ğ¹â‰¤variant with recursive types. Typically, recursive
subtyping was supported via the Amber rules. However, extensions of ğ¹â‰¤with recursive types had
still not been developed and formally studied when many of those works were published.
After the first formalization of ğ¹â‰¤[Curien and Ghelli 1992], Ghelli [1993] questioned this state-of-
affairs, which implicitly assumed that the extension of ğ¹â‰¤with recursive types was straightforward.
He conducted the first formal study for such an extension, and showed a wide range of negative
results. Most importantly, he showed that equi-recursive types are not conservative over full ğ¹â‰¤. In
other words, adding equi-recursive types to full ğ¹â‰¤changes the expressive power of the subtyping
relation, even when the types being compared do not involve any recursive types. The simple addition
of equi-recursive types allows well-formed, but invalid subtyping statements in ğ¹â‰¤to be valid in
an extension with recursive types. Ghelli also shows that applying equi-recursive types to full ğ¹â‰¤
invalidates transitivity elimination: we cannot drop the transitivity rule without losing expressive
power. In addition, while subtyping in full ğ¹â‰¤is undecidable [Pierce 1994], the change in expressive
power reopens questions about the decidability or undecidability of the system.
Even if we choose the weaker form of bounded quantification present in Fun language and
kernel ğ¹â‰¤, the natural extension of Amadio and Cardelli [1993]â€™s algorithm to kernel ğ¹â‰¤is incom-
plete [Colazzo and Ghelli 2005]. Nevertheless, instead of Amadio and Cardelliâ€™s meet 2 times rules,
Colazzo and Ghelli gave an alternative meet 3 times algorithm, accompanied by a very challenging
correctness proof, showing that the subtyping relation is transitive and complete, but did not
prove conservativity. Based on an earlier draft from Colazzo and Ghelli, Jeffrey [2001] extended the
system and proved it correct and complete. By transferring the polar bisimulations [Sangiorgi and
Milner 1992] technique from concurrency theory, Jeffreyâ€™s system is more general than Colazzo
and Ghelliâ€™s, but it is only partially decidable. It is decidable for kernel ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
, but for full ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
, only
when the algorithm terminates it returns the correct answer, but it may not terminate. Furthermore,
although more powerful, Jeffreyâ€™s full ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
is not conservative over ğ¹â‰¤either.
Table 1 summarizes the results of previous work on extending ğ¹â‰¤with recursive types. Note that,
in the table, the Type System row simply means whether the typing relation of the ğ¹â‰¤extension
with recursive types has been studied/presented in the paper. For properties such as type soundness,
decidability or conservativity, there is a corresponding entry in the table, which states whether the
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:3
Table 1. Comparison among different works.
ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
Kernel ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
Kernel ğ¹ğ‘’ğ‘ğ‘¢ğ‘–
â‰¤
ğ¹ğ‘–ğ‘ ğ‘œ
â‰¤
ğ¹ğœ‡
â‰¤
1993
2005
2001
2001
1996
present work
Transitivity
Ã—
âœ“
âœ“
âœ“
built-in
âœ“
Decidability
âœ“
âœ“âˆ–
âœ“
âœ“
Conservativity
Ã—
Ã—
âœ“
Type System
âœ“
âœ“
Algorithmic Type System
âœ“
Type Soundness
âœ“
Modularity
Ã—
Ã—
Ã—
Ã—
âœ“
Mechanized Proofs
Ã—
Ã—
Ã—
Ã—
Ã—
âœ“
A Ã— symbol denotes a negative result (the property or feature does not hold). A âœ“denotes a positive result,
while âœ“âˆ–denotes a partial result (such as semi-decidability). Whitespace denotes that the property/feature has
not been studied or it is unknown.
property was proved or not. Modularity here means whether the original rules and definitions of
ğ¹â‰¤are the same or they need to be modified. The proofs in all the 4 systems with equi-recursive
types are complex because of the strong recursion. Adding equi-recursive subtyping requires major
changes in existing definitions, rules and proofs compared to ğ¹â‰¤, making most of the existing
metatheory on ğ¹â‰¤not reusable. No prior work has proved the conservativity of ğ¹â‰¤with equi-
recursive types. This result is likely to be hard to prove because of the numerous non-modular
changes in ğ¹â‰¤induced by the introduction of equi-recursive subtyping. Furthermore, in those works
the full type systems are not provided. Perhaps motivated by the technical challenges and negative
results posed by equi-recursive types, some researchers set their sights on iso-recursive types. In
their work on object encodings, Abadi et al. [1996] proposed the ğ¹<:ğœ‡calculus, which supports
bounded universal types, bounded existential types and iso-recursive types via the Amber rules.
However, reflexivity and transitivity are built-in, so the system is not algorithmic. Furthermore,
while they presented the typing, subtyping and reduction rules, they have not proved any properties,
including type soundness or the conservativity over full ğ¹â‰¤. One potential reason for the absence of
technical results is that the iso-recursive Amber rules are hard to work with formally [Backes et al.
2014; Ligatti et al. 2017; Zhou et al. 2020, 2022]: it is difficult to prove results such as transitivity, or
define sound and complete algorithmic formulations.
This paper presents an extension of kernel ğ¹â‰¤, called ğ¹ğœ‡
â‰¤, with iso-recursive types. In ğ¹ğœ‡
â‰¤we add
iso-recursive subtyping using the recently proposed nominal unfolding rules [Zhou et al. 2022].
The nominal unfolding rules have been formally proved to be type sound, and shown to have the
same expressive power as the well-known iso-recursive Amber rules [Cardelli 1985]. Moreover, the
nominal unfolding rules address the difficulties of working formally with the (iso-recursive) Amber
rules. With the nominal unfolding rules, proving transitivity and other properties is easy, also
enabling developing algorithmic formulations of subtyping instead. Furthermore, a nice property of
the nominal unfolding rules is that they are modular, allowing an existing calculus to be extended
with recursive types without major impact on existing definitions and proofs. In other words
they allow reusing most existing metatheory and definitions that existed before the addition of
iso-recursive types. Our work shows that the nominal unfolding rules proposed by Zhou et al. can
be integrated modularly into ğ¹â‰¤, while retaining desirable properties. In particular, we prove, for
the first time, the conservativity of an extension of ğ¹â‰¤with recursive types over the original ğ¹â‰¤.
We also add two smaller extensions to ğ¹â‰¤. The first one is a generalization of the kernel ğ¹â‰¤rule
for bounded quantification that accepts equivalent rather than equal bounds. The second extension
is the use of so-called structural folding/unfolding rules, inspired by the structural unfolding rule
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:4
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
proposed by Abadi et al. [1996]. The structural rules add expressive power to the more conventional
folding/unfolding rules in the literature, and they enable additional applications. In particular, we
illustrate how the structural rules play an important role to model encodings of objects, as well as
encodings of algebraic datatypes with subtyping.
We present several results, including: type soundness; transitivity and decidability of subtyp-
ing; the conservativity of ğ¹ğœ‡
â‰¤over ğ¹â‰¤; and a sound and complete algorithmic formulation of ğ¹ğœ‡
â‰¤.
Moreover, we also present an extension of ğ¹ğœ‡
â‰¤, called ğ¹ğœ‡
â‰¤â‰¥, which has a bottom type and lower
bounded quantification in addition to the conventional (upper) bounded quantification of ğ¹â‰¤. As we
show, lower bounded quantification is particularly interesting to model the subtyping of algebraic
datatypes. All the results in this paper have been formalized in the Coq theorem prover.
In summary the contributions of this paper are:
â€¢ ğ¹ğœ‡
â‰¤: an extension of kernel ğ¹â‰¤with iso-recursive types and subtyping. We prove several
important properties for ğ¹ğœ‡
â‰¤, including: type soundness; transitivity and decidability of subtyping;
and the unfolding lemma.
â€¢ The conservativity of ğ¹ğœ‡
â‰¤over ğ¹â‰¤. Conservativity is an expected, but non-trivial property, that
has eluded past work on the combination of bounded quantification and recursive types. We
show that an extension of kernel ğ¹â‰¤with iso-recursive subtyping based on the nominal unfolding
rules is conservative over kernel ğ¹â‰¤.
â€¢ Type soundness for the structural folding/unfolding rules. We present the first formal type
soundness proof for the structural unfolding rule, and we also present a new structural folding
rule, together with its type soundness.
â€¢ Decidability for a generalization of the kernel ğ¹â‰¤rule for bounded quantification, which
compares the bounds for equivalence. A key property is that equivalent types have equal sizes,
enabling the decidability proof.
â€¢ An extension of ğ¹ğœ‡
â‰¤with both upper and lower bounded quantification: We present an
extended calculus, called ğ¹ğœ‡
â‰¤â‰¥, with both top and bottom types, and both upper and lower bounded
quantification, and illustrate its applicability to encodings of datatypes with subtyping.
â€¢ Coq formalization: We have formalized all the calculi and proofs in this paper in Coq, and
made the formalization available online: https://github.com/juda/Recursive-Subtyping-for-All
2
OVERVIEW
This section provides an overview of our work. We first briefly review basic concepts and some
applications. Then we show our key ideas and results.
2.1
Bounded Quantification and Recursive Subtyping
Bounded Quantification. Bounded quantification allows types to be abstracted by type vari-
ables with a subtyping constraint (or bound). The standard calculus with bounded quantification,
ğ¹â‰¤[Cardelli et al. 1994; Cardelli and Wegner 1985; Curien and Ghelli 1992], has two common
variants when it comes to subtyping universal types. The full ğ¹â‰¤variant [Cardelli et al. 1994; Curien
and Ghelli 1992] compares bounded quantifiers with the following rule:
S-fullall
Î“ âŠ¢A2 â‰¤A1
Î“, ğ›¼â‰¤A2 âŠ¢B â‰¤C
Î“ âŠ¢âˆ€(ğ›¼â‰¤A1). B â‰¤âˆ€(ğ›¼â‰¤A2). C
The most significant characteristic of full ğ¹â‰¤is that it allows two bounded quantifiers to be
contravariant on their bound types ğ´1 and ğ´2 when being compared. However, the rich expressivity
of full ğ¹â‰¤results in an undecidable subtyping relation [Pierce 1994], which is undesirable. In addition,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:5
as Ghelli [1993] demonstrates, the rule S-fullall may even prevent conservative extensions of ğ¹â‰¤
in the presence of additional features.
There are several ways to restrict bounded quantification to a fragment with decidable sub-
typing, such as removing top types, or assuming no bounds when comparing type abstraction
bodies [Castagna and Pierce 1994]. Among those the most widely used variant is the kernel ğ¹â‰¤
calculus. In kernel ğ¹â‰¤bounded quantifiers can only be subtypes when their bound types are
identical [Cardelli and Wegner 1985], which is stated in the rule S-kernelall.
S-kernelall
Î“ âŠ¢A
Î“, ğ›¼â‰¤A âŠ¢B â‰¤C
Î“ âŠ¢âˆ€(ğ›¼â‰¤A). B â‰¤âˆ€(ğ›¼â‰¤A). C
S-eqivall
Î“ âŠ¢A1 â‰¤A2
Î“ âŠ¢A2 â‰¤A1
Î“, ğ›¼â‰¤A2 âŠ¢B â‰¤C
Î“ âŠ¢âˆ€(ğ›¼â‰¤A1). B â‰¤âˆ€(ğ›¼â‰¤A2). C
In the rest of the paper, we will focus on kernel ğ¹â‰¤, in order to achieve decidable subtyping
with iso-recursive subtyping. However, differently from kernel ğ¹â‰¤, we will generalize the rule S-
kernelall to a rule S-eqivall that accepts equivalent bounds instead. The main motivation for
using rule S-eqivall is to enable more subtyping involving records. While typically kernel ğ¹â‰¤
is presented without records, in this paper we include records in the calculus and we wish to
consider types such as {ğ‘¥: nat,ğ‘¦: nat} and {ğ‘¦: nat,ğ‘¥: nat}, to be equivalent (despite being
syntactically different). Note that, while in plain ğ¹â‰¤the subtyping relation is antisymmetric [Baldan
et al. 1999] (i.e. if two types are equivalent then they must be equal), the addition of records breaks
antisymmetry since there are equivalent types that are not equal. The rule S-eqivall is more
general than the kernel rule with identical bounds, but retains decidability, as we shall see in Â§4.2.
Recursive Types. Recursive types ğœ‡ğ›¼. ğ´, can be traced back to Morris [1969]. There are two
basic approaches to recursive types: equi-recursive types and iso-recursive types. The essential
difference between them is how they consider the relationship between a recursive type ğœ‡ğ›¼. ğ´and
its unfoldings [ğ›¼â†¦â†’ğœ‡ğ›¼. ğ´] ğ´. In equi-recursive types, a recursive type is equal to its unfolding. That
is ğœ‡ğ›¼. ğ´= [ğ›¼â†¦â†’ğœ‡ğ›¼. ğ´] ğ´. In other words, recursive types and their unfoldings are interchangeable
in all contexts. In iso-recursive types, a recursive type and its one-step unfolding are not equal but
only isomorphic. To convert between ğœ‡ğ›¼. ğ´and [ğ›¼â†¦â†’ğœ‡ğ›¼. ğ´] ğ´back and forth we need explicit
unfold and fold operators. A fold expression constructs a recursive type, while an unfold expression
opens a recursive type, as rule typing-fold and rule typing-unfold illustrate:
typing-unfold
Î“ âŠ¢e : ğœ‡ğ›¼. A
Î“ âŠ¢unfold [ğœ‡ğ›¼. A] e : [ğ›¼â†¦â†’ğœ‡ğ›¼. A] A
typing-fold
Î“ âŠ¢e : [ğ›¼â†¦â†’ğœ‡ğ›¼. A] A
Î“ âŠ¢ğœ‡ğ›¼. A
Î“ âŠ¢fold [ğœ‡ğ›¼. A] e : ğœ‡ğ›¼. A
Recursive Subtyping. Subtyping between recursive types has been studied for many years [Amadio
and Cardelli 1993; Cardelli 1985; Ligatti et al. 2017]. The most widely used subtyping rules for
recursive types are the Amber rules [Cardelli 1985], which consist of three rules: rule S-amber,
rule S-assmp and rule S-refl.
S-amber
Î“, ğ›¼â‰¤ğ›½âŠ¢A â‰¤B
Î“ âŠ¢ğœ‡ğ›¼. A â‰¤ğœ‡ğ›½. ğµ
S-assmp
ğ›¼â‰¤ğ›½âˆˆÎ“
Î“ âŠ¢ğ›¼â‰¤ğ›½
S-refl
Î“ âŠ¢A â‰¤A
The Amber rules are simple, but their metatheory is troublesome. For example, transitivity is hard
to prove [Bengtson et al. 2011; Zhou et al. 2020, 2022]. Furthermore, due to the reliance on the
reflexivity rule (rule S-refl), the Amber rules are problematic for subtyping relations that are not
antisymmetric [Ligatti et al. 2017]. Recently, Zhou et al. [2020, 2022] proposed a new specification
for iso-recursive subtyping and some equivalent algorithmic variants. For this paper we use one of
those algorithmic variants, called the nominal unfolding rules [Zhou et al. 2022]. The main reason
to choose the nominal unfolding rules is that are easy to work with formally and Zhou et al. have
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:6
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
a full Coq development, including proofs of decidability, that we reuse and extend. The nominal
unfolding rules are:
S-nominal
Î“, ğ›¼âŠ¢[ğ›¼â†¦â†’Ağ›¼] A â‰¤[ğ›¼â†¦â†’Bğ›¼] B
Î“ âŠ¢ğœ‡ğ›¼. A â‰¤ğœ‡ğ›¼. B
S-label
Î“ âŠ¢A â‰¤B
Î“ âŠ¢Ağ›¼â‰¤Bğ›¼
The key intuition for the nominal unfolding rules is that, in order to correctly deal with subtyping
for contravariant occurrences of recursive type variables, we must unfold the recursive bodies
twice to check the validity of the subtyping statement. For instance, the subtyping statement
ğœ‡ğ›¼. ğ›¼â†’nat â‰¤ğœ‡ğ›¼. ğ›¼â†’âŠ¤should be rejected. If we unroll the recursive types twice, we get the
following invalid subtyping statement:
((ğœ‡ğ›¼. ğ›¼â†’nat) â†’nat) â†’nat â‰¤((ğœ‡ğ›¼. ğ›¼â†’âŠ¤) â†’âŠ¤) â†’âŠ¤
which requires both that nat â‰¤âŠ¤(which is true) and âŠ¤â‰¤nat, which is false and is the reason
why the subtyping statement should fail. Note that unrolling this example one time only results in
(ğœ‡ğ›¼. ğ›¼â†’nat) â†’nat â‰¤(ğœ‡ğ›¼. ğ›¼â†’âŠ¤) â†’âŠ¤, which does not expose âŠ¤â‰¤nat and is the reason why
unrolling 1-time only is not enough. The rule S-nominal mimics this double-unrolling process, but
we obtain the following subtyping statement instead:
(ğ›¼â†’nat)ğ›¼â†’nat â‰¤(ğ›¼â†’âŠ¤)ğ›¼â†’âŠ¤
where the recursive types are replaced by ğ›¼(note that ğ›¼â‰¤ğ›¼trivially holds). This statement is
sufficient to trigger enough subtyping comparisons to validate the correctness of the subtyping
statement. In particular, it also requires checking that âŠ¤â‰¤nat, which is false and will reject the
subtyping statement. By using recursive variables instead of the recursive types in the (double)
unfolding process we obtain a terminating procedure. The nominal unfolding rules use labelled
types Ağ›¼, to ensure that we only compare types that arise from unfolding substitutions with
related unfolded types. Labelled types are a syntactic devise used to prevent accepting subtyping
statements such as ğœ‡ğ›¼. nat â†’ğ›¼â‰¤ğœ‡ğ›¼. nat â†’nat â†’âŠ¤, which would be unsound in an iso-
recursive formulation. They also provide a distinct nominal identity to the recursive types being
compared, so that they cannot be compared with other unrelated recursive types. Note that, in the
rule S-nominal, we have reused the recursive variable name for the label ğ›¼. However, we used the
red color to distinguish the label and type variable names. Labels ğ›¼should be the same in both
substitutions, and distinct from any other labels and bound variables used elsewhere. Since in the
paper presentation we use a nominal approach to represent binders, the label ğ›¼should be interpreted
as some unique freshly generated name1. Zhou et al. proved that the nominal unfolding rules are
type sound, and have the same expressive power as the iso-recursive Amber rules. Moreover, unlike
the Amber rules, they are easy to work with formally and they can be easily used in subtyping
relations that are not antisymmetric.
2.2
Applications of Bounded Quantification and Recursive Types
We now turn to applications of bounded quantification and recursive types. In particular the classic
application for both features is encodings of objects [Bruce et al. 1999]. In addition, we also show
that the two features are useful to model encodings of algebraic datatypes with subtyping.
Object Encodings. A simple and well-known typed encoding of objects is the recursive records
encoding [Bruce et al. 1999; Canning et al. 1989; Cook et al. 1989]. In this encoding the idea is that
object types are encoded as recursive record types, and objects are encoded as records. We will use
1In our Coq formalization we use a locally nameless representation [Aydemir et al. 2008], which distinguishes free and
bound variables naturally. With a locally nameless representation we can reuse the free variable name ğ›¼for the label ğ›¼.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:7
a simplified form of the encoding, where we do not deal with self-references. But self-references
could be dealt with in standard ways. For example, we can define a type Point:
Point â‰œğœ‡pnt.{x : Int, y : Int, move : Int â†’Int â†’pnt}
which consists of its coordinates and a move function. We use a recursive type because move should
return an updated point. To implement Point we define some auxiliary functions:
function getX(p : Point) = (unfold [Point] p ). x
function getY(p : Point) = (unfold [Point] p ). y
function moveTo(p : Point, x : Int , y : Int ) = (unfold [Point] p ). move x y
then a constructor mkPoint can be defined as:
function mkPoint(x1 : Int , y1 : Int ) = fold [Point] { x=x1, y=y1, move = ğœ†x2 y2. mkPoint(x2, y2) }
Note that the auxiliary functions above would not be needed in a source language, since a source
language would treat p.x as syntactic sugar for (unfold [Point] p).x. Similarly, the source language
would automatically insert a fold in the object constructor. In other words, in a source language
with iso-recursive subtyping the foldâ€™s and unfoldâ€™s do not need to be explicitly written and are
automatically inserted by the compiler. For instance, this is what Abadi et al. [1996]â€™s translation of
a language with objects into an iso-recursive extension of ğ¹â‰¤does.
With subtyping, we can develop subtypes of Point, such as:
ColorPoint â‰œğœ‡pnt.{x : Int, y : Int, move : Int â†’Int â†’pnt, color : String}
EqPoint â‰œğœ‡pnt.{x : Int, y : Int, move : Int â†’Int â†’pnt, eq : pnt â†’Bool}
Now we wish to translate the coordinates by one unit for a point, but we do not want to write such
a translation function for all subclasses of Point. This is achieved with a polymorphic function:
function translate [P â‰¤Point] (p : P) = (unfold [Point] p ). move (getX p + 1) (getY p + 1)
The type of this translate function is âˆ€(P â‰¤Point). P â†’Point, which is obtained from the following
typing derivation (some parts omitted):
P â‰¤Point, p : P âŠ¢p : P
P â‰¤Point, p : P âŠ¢P â‰¤Point
typing-sub
P â‰¤Point, p : P âŠ¢p : Point
typing-unfold
P â‰¤Point, p : P âŠ¢(unfold [Point] p) :
 x : Int, y : Int,
move : Int â†’Int â†’Point

. . .
âŠ¢translate : âˆ€(P â‰¤Point). P â†’Point
However, this type is unsatisfying because it loses type precision: it returns a Point instead of a
P. The type that we want instead is:
âˆ€(P â‰¤Point). P â†’P
Unfortunately, we cannot obtain this more general type with only bounded quantification, and the
usual unfolding rule typing-unfold. In the rule typing-unfold, the unfold annotation must be a
recursive type. However, if we wish to return P, then we should use unfold with the annotation P,
which is not a recursive type, but a type variable. Some advanced techniques, such as f-bounded
quantification [Canning et al. 1989], address this issue. ğ¹ğœ‡
â‰¤uses a less intrusive approach to obtain
the desired typing for translate via the structural unfolding rules, which we discuss in Â§2.3.
Encoding positive f-bounded quantification. Fortunately, with the structural rules, we can use a
type variable as an annotation for unfold. This enables us to encode forms of f-bounded quantifica-
tion with positive occurrences of recursive variables, which is the case for Point. We can change
the unfold annotation in translate from the recursive type Point to its subtype, the type variable P:
function translate [P â‰¤Point] (p : P) = (unfold [P] p ). move (getX p + 1) (getY p + 1)
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:8
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
In Â§2.3 we discuss the typing of this program via the structural unfolding rule in detail. After this
change the type of translate is âˆ€(P â‰¤Point). P â†’P. Then we can apply translate to Point or any
of its subtypes, without losing static precision. Thus, if we call translate [EqPoint] (mkEqPoint 0
0), then we obtain an EqPoint object at (1, 1). Note also that here mkEqPoint is a constructor for
objects with type EqPoint, which contain a binary method [Bruce et al. 1995] eq.
function mkEqPoint(x1 : Int, y1 : Int ) = fold [EqPoint]
{ x = x1, y = y1, move = ğœ†x2 y2. mkEqPoint(x2, y2), eq = ğœ†p. (getX p == x1) âˆ§(getY p == y1) }
Encodings of Algebraic Datatypes with Subtyping. It is well-known that in the polymorphic lambda
calculus (System F) [Girard 1972; Reynolds 1974], we can use Church [1932] encodings to encode
algebraic datatypes [BÃ¶hm and Berarducci 1985]. However, Church encodings make it hard to
encode some operations, or worst they prevent encoding certain operations with the correct time
complexity. A well-known example [Church 1932] is the encoding of the predecessor function on
natural numbers, which is linear with Church encodings instead of being constant time.
An alternative encoding of datatypes in the untyped lambda calculus, which avoids the issues
of Church encodings, is due to Scott [1962]. Unfortunately, Scott encodings cannot be encoded
in plain System F. However, the addition of recursive types to a polymorphic lambda calculus
allows a typed encoding for Scott encodings [Parigot 1992]. Moreover, in the presence of subtyping,
we can also encode algebraic datatypes with subtyping, enabling certain forms of reuse that are
not possible without subtyping. Oliveira [2009] has shown this assuming a ğ¹â‰¤-like language with
recursive types and records, but he has not formalized such a language. Here we revisit Oliveiraâ€™s
example. A similar encoding for datatypes can be achieved in ğ¹ğœ‡
â‰¤. For example, one may define a
datatype Exp1 for mathematical expressions, with numeric, addition, and subtraction constructors:
data Exp1 = Num Int | Add Exp1 Exp1 | Sub Exp1 Exp1
The encoding in ğ¹ğœ‡
â‰¤of this datatype can be defined as follows:
Exp1 â‰œğœ‡E. âˆ€A. {num : Int â†’A, add : E â†’E â†’A, sub : E â†’E â†’A} â†’A
If we unfold the recursive type, this encoding is a polymorphic higher order function that takes a
record with three fields (num, add and sub) as input. Each field corresponds to a constructor in the
datatype definition. This encoding is particularly useful for case analysis, since the polymorphic
function essentially encodes case analysis directly. To write a function that performs case analysis
on this datatype, one can unfold the recursive type, instantiate A with the result type, and then
provide a record that maps each case to its implementation function that takes the constructor
components as input and returns a result of type A. For example, given an expression e with type
Exp1, a case analysis-based evaluation function can be written as:
function eval (e : Exp1) = (unfold [Exp1] e) [Int]
{ num = ğœ†n. n, add = ğœ†e1 e2. (eval e1 + eval e2), sub = ğœ†e1 e2. (eval e1 âˆ’eval e2) }
where we use [. . .] to represent type instantiation. Here Exp1 is instantiated with the evaluation
result type Int. A record of three functions is supplied to implement case analysis. The num field
implements a function that returns the integer n of the Num constructor directly, while the functions
in add and sub fields perform the evaluation process recursively. To construct concrete instances
of the datatype, each constructor also comes with a corresponding encoding in the calculus:
function Num1 (n: Int) = fold [Exp1] (Î› A. ğœ†e. (e.num n))
function Add1 (e1 : Exp1, e2 : Exp1) = fold [Exp1] (Î› A. ğœ†e. (e.add e1 e2))
function Sub1 (e1 : Exp1, e2 : Exp1) = fold [Exp1] (Î› A. ğœ†e. (e.sub e1 e2))
One can easily check, using rule typing-fold, that the result type of each constructor encoding
becomes Exp1 after a recursive type folding. Therefore, in this encoding, the use of construc-
tors and case analysis functions is natural: one can construct the expression 1 + 2 directly with
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:9
the encoded constructors as Add1 (Num1 1) (Num1 2), and get its evaluation result by calling
eval (Add1 (Num1 1) (Num1 2)).
Subtyping between datatypes. Now consider a larger datatype Exp2, which extends the Exp1
datatype with a new constructor Neg, for denoting negative numbers.
data Exp2 = Num Int | Add Exp2 Exp2 | Sub Exp2 Exp2 | Neg Exp2
This datatype is encoded in ğ¹ğœ‡
â‰¤as:
Exp2 â‰œğœ‡E. âˆ€A. {num : Int â†’A, add : E â†’E â†’A, sub : E â†’E â†’A, neg : E â†’A} â†’A
The datatype Exp2 differs from Exp1 only in the new constructor. However, other constructors are
just the same. To reduce code duplication, polymorphism on datatype constructors is desirable.
Note that Exp2 has more constructors than Exp1, so it should be safe to coerce Exp1 expressions
into Exp2 expressions, i.e. Exp1 â‰¤Exp2. Therefore, we would like the constructor for Add to have
the following type, so that both Exp1 and Exp2 can use this constructor:
Addâˆ€: âˆ€(E â‰¥Exp1). E â†’E â†’E
There are two problems here. Firstly, similarly to the issue that we have faced in the translate
function, we would like to use a type variable in the foldâ€™s of the constructors. This way we can
make the constructors polymorphic. Secondly, as evidenced by the desired type for Add, we need
lower bounded quantification, but in ğ¹ğœ‡
â‰¤(and ğ¹â‰¤) we only have upper bounded quantification.
Polymorphic constructors with lower bounded quantification. For applications such as encodings
of algebraic datatypes, the dual form of bounded quantification (lower bounded quantification)
seems to be more useful. Thus we have an extended system, called ğ¹ğœ‡
â‰¤â‰¥, that also supports lower
bounded quantification. Polymorphic datatype constructors become typeable with the structural
folding rule. For example, we can encode the polymorphic Add constructor as:
function Addâˆ€[E â‰¥Exp1] (e1 : E, e2 : E) = fold [E] (Î› A. ğœ†e. (e.add e1 e2))
Other polymorphic constructors such as Numâˆ€and Subâˆ€can be encoded similarly, enabling more
useful programming patterns. For example, if we want to implement a compiler that uses Exp1 as
its core language, but also want to support richer datatype constructors in a source language like
Exp2 does, we would like to be able to reduce code duplication across the two similar languages.
For instance, if we define a pretty printer function for Exp2
function print (ğ‘’: Exp2) = (unfold [Exp2] ğ‘’) [string] {
num = ğœ†n. ( int_to_string n), add = ğœ†e1 e2. ((print e1) ++ "+" ++ ( print e2)),
sub = ğœ†e1 e2. ((print e1) ++ "âˆ’" ++ ( print e2)), neg = ğœ†e. ("âˆ’" ++ ( print e ))}
we can use this function to print Exp1 expressions as well: all the constructors in Exp1 are also
in Exp2 and have their pretty printing methods defined in the above function. With subtyping
between algebraic datatypes, it holds that Exp1 â‰¤Exp2, so it is safe in our encodings to apply this
print function to values of type Exp1, without another pretty printing function for Exp1.
Suppose also that we wish to implement a simple desugaring function that transforms Exp2 into
Exp1, by transforming negative numbers âˆ’ğ‘›into subtractions 0 âˆ’ğ‘›. This function should do case
analysis on Exp2 and use only the constructors in Exp1 to produce the result, i.e. it should have a
type Exp2 â†’Exp1. The following code, with polymorphic constructors, has the desired typing:
function desugar (ğ‘’: Exp2) = (unfold [Exp2] ğ‘’) [Exp1] {
num = ğœ†n. Numâˆ€[Exp1] n,
add = ğœ†e1 e2. Addâˆ€[Exp1] (desugar e1) (desugar e2),
sub = ğœ†e1 e2. Subâˆ€[Exp1] (desugar e1) (desugar e2),
neg = ğœ†e. Subâˆ€[Exp1] (Numâˆ€[Exp1] 0) (desugar e)}
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:10
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
In contrast, in many practical programming languages this task either involves code duplication
or loss of type precision. In a typical functional language, we can define both Exp1 and Exp2 and
also obtain precise static typing guarantees for the desugar function. But this comes at the cost of
duplication, since the constructors for the two datatypes are different, and many operations, such as
pretty printing need to be essentially duplicated. In ğ¹ğœ‡
â‰¤â‰¥, in addition to polymorphic constructors,
we would just need to define the pretty printer for Exp2, and that function would also work for Exp1.
Alternatively, one could define only Exp2 and type desugar with the imprecise type Exp2 â†’Exp2,
which does not statically guarantee that the Neg constructor has been removed. This solution avoids
the duplication at the cost of static typing guarantees. In ğ¹ğœ‡
â‰¤â‰¥we do not need such compromise:
we can avoid code duplication and preserve the static typing guarantees.
2.3
Key Ideas and Results
As Table 1 shows, no previous calculi with bounded quantification and recursive types are fully
satisfactory in all dimensions. Equi-recursive types are quite problematic, since they can change
the expressive power of the subtyping relation in unexpected ways. More importantly, adding equi-
recursive subtyping to ğ¹â‰¤requires novel algorithms, and the extension is non-modular, requiring
several changes to existing definitions and proofs.
Kernel ğ¹â‰¤with iso-recursive types. Our type system directly combines kernel ğ¹â‰¤and the nominal
unfolding rules together. The addition of the nominal unfolding rules has almost no effect in the
original proofs in kernel ğ¹â‰¤. That is the proofs for important lemmas, such as transitivity, are nearly
the same as those in kernel ğ¹â‰¤, except that we need a new case to deal with recursive types. Thus
proofs that have been very hard in the past, such as transitivity, are very simple in ğ¹ğœ‡
â‰¤.
The more challenging aspect in the metatheory of ğ¹ğœ‡
â‰¤lies in the unfolding lemma:
Î“ âŠ¢ğœ‡ğ›¼. ğ´â‰¤ğœ‡ğ›¼. ğµ
â‡’
Î“ âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ´] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğµ] ğµ
which reveals an important property for iso-recursive types: if two iso-recursive types are subtypes,
then their one-step unfoldings are also subtypes. To prove the unfolding lemma, a generalized
lemma is needed [Zhou et al. 2022]. In ğ¹ğœ‡
â‰¤, we show that the previous generalized approach is
insufficient, due to bounded quantification. Therefore, a more general lemma is proposed.
Another challenge is decidability. Although both kernel ğ¹â‰¤and the nominal unfolding rules
(for simple calculi) have been independently proved decidable, their decidability proofs use very
different measures. A natural combination is problematic, thus we need a new approach.
After overcoming those challenges, as Table 1 shows, ğ¹ğœ‡
â‰¤performs well in various dimensions:
it is transitive, decidable, conservative and modular. Furthermore, there is a simple, sound and
complete algorithmic type system to enable implementations, and to provide important help in the
proofs of results such as conservativity of typing.
Structural folding and unfolding rules. In our work, instead of standard rules for fold/unfold
expressions, we use structural rules:
typing-sunfold
Î“ âŠ¢e : A
Î“ âŠ¢A â‰¤ğœ‡ğ›¼. B
Î“ âŠ¢unfold [A] e : [ğ›¼â†¦â†’A] B
typing-sfold
Î“ âŠ¢e : [ğ›¼â†¦â†’B] A
Î“ âŠ¢ğœ‡ğ›¼. A â‰¤B
Î“ âŠ¢fold [B] e : B
The key point about the structural rules is that the annotations are generalized to be a subtype/super-
type of a recursive type, instead of exactly a recursive type. In particular, this generalization enables
annotating fold/unfold with a bounded type variable, which is a subtype/supertype of a recursive
type. This is forbidden in the traditional rules. In the rule typing-sunfold, it is worthwhile to
mention that when we have ğ´â‰¤ğœ‡ğ›¼. ğµwhere ğ›¼appears negatively in ğµ, then there are very limited
choices to what ğ´can be. Essentially it can be ğœ‡ğ›¼. ğµitself and little else. In other words, negative
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:11
recursive types have very restricted subtyping, which is why the structural unfolding rule can
be type safe. Note also that, since the structural unfolding rules provide almost no flexibility for
negative recursive subtyping, they are insufficient to fully express f-bounded quantification for
negative recursive types.
The structural unfolding rule was presented by Abadi et al. [1996] for supporting structural
update in the object calculus that was being encoded into ğ¹â‰¤with iso-recursive types. In their work,
the structural unfolding rule is presented with an informal explanation. We provide structural rules
for both expressions, together with the formalization of the type soundness for both rules. With the
structural unfolding rule we can, for instance, obtain the desired typing for the translate function.
P â‰¤Point, p : P âŠ¢p : P
P â‰¤Point, p : P âŠ¢P â‰¤Point
typing-sunfold
P â‰¤Point, p : P âŠ¢(unfold [P] p) :
 x : Int, y : Int,
move : Int â†’Int â†’P

. . .
âŠ¢translate : âˆ€(P â‰¤Point). P â†’P
Readers can compare this derivation to the one in Â§2.2, where the conventional unfolding rule
and the subsumption rule are used instead. The use of rule typing-sunfold enables us to give a
more precise type for the translate function.
Lower bounded quantification and ğ¹ğœ‡
â‰¤â‰¥. We have also formalized an extension of ğ¹ğœ‡
â‰¤with both
upper and lower bounded quantification, called ğ¹ğœ‡
â‰¤â‰¥. All the same results that are proved for ğ¹ğœ‡
â‰¤are
also proved for ğ¹ğœ‡
â‰¤â‰¥, including transitivity, decidability and type soundness. The structural folding
rules become more useful in ğ¹ğœ‡
â‰¤â‰¥. With lower bounded quantification and the structural folding
rules we can get the correct typing for the polymorphic Add constructor:
Â· Â· Â·
E â‰¥Exp1, e1 : E, e2 : E âŠ¢Î›A. ğœ†e.(e.add e1 e2) : âˆ€A.
ï£±ï£´ï£´ï£²
ï£´ï£´ï£³
num : Int â†’A,
add : E â†’E â†’A,
sub : E â†’E â†’A
ï£¼ï£´ï£´ï£½
ï£´ï£´ï£¾
â†’A
typing-sfold
E â‰¥Exp1, e1 : E, e2 : E âŠ¢fold [E] (Î›A. ğœ†e. (e.add e1 e2)) : E
. . .
âŠ¢Addâˆ€: âˆ€(E â‰¥Exp1). E â†’E â†’E
3
BOUNDED QUANTIFICATION WITH ISO-RECURSIVE TYPES
This section introduces a full calculus, called ğ¹ğœ‡
â‰¤, with bounded quantification, records and recursive
types. ğ¹ğœ‡
â‰¤is an extension of kernel ğ¹â‰¤[Cardelli and Wegner 1985] with iso-recursive types.
3.1
Syntax and Well-Formedness
Syntax and Well-Formedness. The syntax of types and contexts for ğ¹ğœ‡
â‰¤is shown below.
Types
ğ´, ğµ, . . .
F
nat | âŠ¤| ğ´1 â†’ğ´2 | ğ›¼| ğœ‡ğ›¼. ğ´| ğ´ğ›¼| âˆ€(ğ›¼â‰¤ğ´). ğµ| {ğ‘™ğ‘–: ğ´ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Expressions
ğ‘’
F
ğ‘¥| i | ğ‘’1 ğ‘’2 | ğœ†ğ‘¥: ğ´. ğ‘’| ğ‘’ğ´| Î›(ğ›¼â‰¤ğ´). ğ‘’
| unfold [ğ´] ğ‘’| fold [ğ´] ğ‘’| {ğ‘™ğ‘–= ğ‘’ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›} | ğ‘’.ğ‘™
Values
ğ‘£
F
i | ğœ†ğ‘¥: ğ´. ğ‘’| fold [ğ´] ğ‘£| Î›(ğ›¼â‰¤ğ´). ğ‘’| {ğ‘™ğ‘–= ğ‘£ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Contexts
Î“
F
Â· | Î“, ğ›¼â‰¤ğ´| Î“,ğ‘¥: ğ´
Meta-variables ğ´, ğµ,ğ¶, ğ·range over types. Types consist of: natural numbers (nat), the top type (âŠ¤),
function types (ğ´â†’ğµ), type variables (ğ›¼), recursive types (ğœ‡ğ›¼. ğ´), labelled types (ğ´ğ›¼), universal
types (âˆ€(ğ›¼â‰¤ğ´). ğµ), and record types ({ğ‘™ğ‘–: ğ´ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}). Labelled types are types that are annotated
with a label. They enable distinguishing between otherwise structurally compatible types (equal
types or subtypes). That is if the two types being compared have different labels or one of the types
is unlabelled, then the two types will not be related, even when (ignoring the labels) they would be
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:12
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
Î“ âŠ¢ğ´
(Well-formed Type)
wft-nat
Î“ âŠ¢nat
wft-Top
Î“ âŠ¢âŠ¤
wft-var
ğ›¼â‰¤A âˆˆÎ“
Î“ âŠ¢ğ›¼
wft-all
Î“ âŠ¢A
Î“, ğ›¼â‰¤A âŠ¢B
Î“ âŠ¢âˆ€(ğ›¼â‰¤A). B
wft-arrow
Î“ âŠ¢A1
Î“ âŠ¢A2
Î“ âŠ¢A1 â†’A2
wft-rec
Î“, ğ›¼â‰¤âŠ¤âŠ¢A
Î“ âŠ¢ğœ‡ğ›¼. A
wft-label
Î“ âŠ¢A
Î“ âŠ¢Ağ›¼
wft-rcd
Î“ âŠ¢Ağ‘–
for each ğ‘–
Î“ âŠ¢{ğ‘™ğ‘–: Ağ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Î“ âŠ¢ğ´â‰¤ğµ
(Subtyping)
S-nat
âŠ¢Î“
Î“ âŠ¢nat â‰¤nat
S-top
âŠ¢Î“
Î“ âŠ¢A
Î“ âŠ¢A â‰¤âŠ¤
S-var
âŠ¢Î“
Î“ âŠ¢ğ›¼
Î“ âŠ¢ğ›¼â‰¤ğ›¼
S-arrow
Î“ âŠ¢B1 â‰¤A1
Î“ âŠ¢A2 â‰¤B2
Î“ âŠ¢A1 â†’A2 â‰¤B1 â†’B2
S-rec
Î“, ğ›¼â‰¤âŠ¤âŠ¢[ğ›¼â†¦â†’Ağ›¼] A â‰¤[ğ›¼â†¦â†’Bğ›¼] B
Î“ âŠ¢ğœ‡ğ›¼. A â‰¤ğœ‡ğ›¼. B
S-vartrans
ğ›¼â‰¤B âˆˆÎ“
Î“ âŠ¢B â‰¤A
Î“ âŠ¢ğ›¼â‰¤A
S-eqivall
Î“ âŠ¢A1 â‰¤A2
Î“ âŠ¢A2 â‰¤A1
Î“, ğ›¼â‰¤A2 âŠ¢B â‰¤C
Î“ âŠ¢âˆ€(ğ›¼â‰¤A1). B â‰¤âˆ€(ğ›¼â‰¤A2). C
S-label
Î“ âŠ¢A â‰¤B
Î“ âŠ¢Ağ›¼â‰¤Bğ›¼
S-rcd
âŠ¢Î“
Î“ âŠ¢{ğ‘˜ğ‘—: Ağ‘—ğ‘—âˆˆ1Â·Â·Â·ğ‘š}
{ğ‘™ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›} âŠ†{ğ‘˜ğ‘—ğ‘—âˆˆ1Â·Â·Â·ğ‘š}
ğ‘˜ğ‘—= ğ‘™ğ‘–implies Î“ âŠ¢Ağ‘—â‰¤Bğ‘–
Î“ âŠ¢{ğ‘˜ğ‘—: Ağ‘—ğ‘—âˆˆ1Â·Â·Â·ğ‘š} â‰¤{ğ‘™ğ‘–: Bğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Fig. 1. Well-formedness and subtyping rules.
structurally compatible types. They are used for dealing with subtyping of iso-recursive types as
part of the nominal unfolding approach. Expressions, denoted by meta-variable ğ‘’, include: term
variables (ğ‘¥), natural numbers (i), applications (ğ‘’1 ğ‘’2), abstractions (ğœ†ğ‘¥: ğ´. ğ‘’), type applications (ğ‘’ğ´),
type abstractions (Î›(ğ›¼â‰¤ğ´). ğ‘’), fold expressions (fold [ğ´] ğ‘’), unfold expressions (unfold [ğ´] ğ‘’),
records ({ğ‘™ğ‘–= ğ‘’ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}) and record selection (ğ‘’.ğ‘™). Among them, natural numbers, abstractions and
type abstractions are values. Fold expressions and records can be values if their inner expressions
are also values. The context is used to store type variables with their bounds, and term variables with
their types. Note that it is unnecessary to distinguish recursive variables and universal variables.
The definition of a well-formed environment âŠ¢Î“ is standard, ensuring that all variables in the
environment are distinct and all types in the environment are well-formed. A type is well-formed if
all of its free variables are in the context. The well-formedness rules for types are shown in Figure 1.
3.2
Subtyping
The bottom of Figure 1 shows the subtyping judgement. Our subtyping rules are mostly standard.
The rules essentially include the rules of the algorithmic version of kernel ğ¹â‰¤[Cardelli et al. 1994;
Cardelli and Wegner 1985], but the rule for bounded quantification is generalized. The rules S-
var and S-vartrans are standard ğ¹â‰¤rules. Note that since we do not distinguish universal and
recursive variables, those rules apply also to recursive type variables. The rule for function types
(rule S-arrow) is contravariant on the input types and covariant on the output types.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:13
Subtyping bounded quantification. The rule for bounded quantification is interesting, stating that
two universal types are subtypes if their bounds are equivalent (i.e. they are subtypes of each other)
and the bodies are subtypes. Note that rule S-eqivall is more general than rule S-kernelall
since the latter one requires the bounds are equal. The reason to have the more general rule using
equivalent bounds is that, for records, we wish to accept subtyping statements such as:
âˆ€(ğ›¼â‰¤{ğ‘¥: nat,ğ‘¦: nat}). ğ›¼â†’ğ›¼â‰¤âˆ€(ğ›¼â‰¤{ğ‘¦: nat,ğ‘¥: nat}). ğ›¼â†’ğ›¼
where the bounds can be syntactically different, but equivalent types. In the presence of records
or other features (such as intersection and union types [Barbanera et al. 1995; Coppo et al. 1981;
Pottinger 1980]) we can have such equivalent, but not syntactically equal types. Therefore, we
should generalize the rule for bounded quantification do deal with those cases. This generalization
to equivalent bounds retains decidable subtyping just as kernel ğ¹â‰¤as we shall see in Â§4.2.
Subtyping recursive types. For dealing with iso-recursive subtyping we employ the recent nominal
unfolding rules [Zhou et al. 2022], which have equivalent expressive power to the well-known
(iso-recursive) Amber rules [Cardelli 1985]. The nominal unfolding rules have been discussed in
Â§2.1. The reason to choose the nominal unfolding rules is that they enable us to prove important
metatheoretical results, such as transitivity and develop an algorithmic formulation of subtyping.
We extend the rule S-nominal to the rule S-rec in ğ¹ğœ‡
â‰¤, by bounding recursive variables with
âŠ¤when they are introduced into the context. Therefore, recursive variables are also treated as
universal variables, and we do not need to adjust the form of contexts in ğ¹â‰¤for ğ¹ğœ‡
â‰¤. Apart from
this, no other changes are necessary, making the addition of recursive types mostly non-invasive.
Consequently, the proofs of narrowing, reflexivity and transitivity are the same as the original one
for ğ¹â‰¤, except for the new cases dealing with recursive types and minor adjustments to the rule of
bounded quantification due to the generalization to equivalent bounds.
Lemma 3.1 (Narrowing). If Î“1 âŠ¢ğ¶â‰¤ğ¶â€² and Î“1, ğ›¼â‰¤ğ¶â€², Î“2 âŠ¢ğ´â‰¤ğµthen Î“1, ğ›¼â‰¤ğ¶, Î“2 âŠ¢ğ´â‰¤ğµ.
Theorem 3.2 (Reflexivity). If âŠ¢Î“ and Î“ âŠ¢ğ´then Î“ âŠ¢ğ´â‰¤ğ´.
Theorem 3.3 (Transitivity). If Î“ âŠ¢ğ´â‰¤ğµand Î“ âŠ¢ğµâ‰¤ğ¶then Î“ âŠ¢ğ´â‰¤ğ¶.
The unfolding lemma. Another important lemma is the unfolding lemma, which reveals that: if
two recursive types are subtypes, then their unfoldings are also subtypes. The unfolding lemma is
important for proving preservation in a system with iso-recursive subtyping. A key difficulty in
the formalization of ğ¹ğœ‡
â‰¤is proving the unfolding lemma which, due to the presence of bounded
quantification, requires a different proof technique compared to the proofs by Zhou et al. [2022].
We discuss the proof of the unfolding lemma in Â§4.1.
Lemma 3.4 (Unfolding Lemma). If Î“ âŠ¢ğœ‡ğ›¼. ğ´â‰¤ğœ‡ğ›¼. ğµthen Î“ âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ´] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğµ] ğµ.
3.3
Type Soundness
Figure 2 shows the typing rules and reduction rules. Most rules are standard except for the typing
rule for unfold and fold. For these two expressions we use structural rules instead (rule typing-
sunfold and rule typing-sfold), as we explained in Â§2.3.
Structural unfolding lemma. Since the typing rules that we adopt for fold/unfold expressions are
the structural rules, which generalize the conventional rules, we need a more general form for the
unfolding lemma. The generalization of the lemma is necessary for the type preservation proof
with the structural folding/unfolding rules. We call the new lemma the structural unfolding lemma:
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:14
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
Î“ âŠ¢ğ‘’: ğ´
(Typing)
typing-nat
âŠ¢Î“
Î“ âŠ¢i : nat
typing-var
âŠ¢Î“
ğ‘¥: ğ´âˆˆÎ“
Î“ âŠ¢x : A
typing-sub
Î“ âŠ¢e : A
Î“ âŠ¢A â‰¤B
Î“ âŠ¢e : B
typing-abs
Î“, ğ‘¥: A1 âŠ¢e : A2
Î“ âŠ¢ğœ†x : A1. e : A1 â†’A2
typing-sfold
Î“ âŠ¢e : [ğ›¼â†¦â†’B] A
Î“ âŠ¢ğœ‡ğ›¼. A â‰¤B
Î“ âŠ¢fold [B] e : B
typing-sunfold
Î“ âŠ¢e : A
Î“ âŠ¢A â‰¤ğœ‡ğ›¼. B
Î“ âŠ¢unfold [A] e : [ğ›¼â†¦â†’A] B
typing-app
Î“ âŠ¢e1 : A1 â†’A2
Î“ âŠ¢e2 : A1
Î“ âŠ¢e1 e2 : A2
typing-proj
Î“ âŠ¢e : {ğ‘™ğ‘–: Ağ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Î“ âŠ¢e.ğ‘™ğ‘–: Ağ‘–
typing-tabs
Î“, ğ›¼â‰¤A âŠ¢e : B
Î“ âŠ¢Î›(ğ›¼â‰¤A). e : âˆ€(ğ›¼â‰¤A). B
typing-tapp
Î“ âŠ¢e : âˆ€(ğ›¼â‰¤B1). B2
Î“ âŠ¢A â‰¤B1
Î“ âŠ¢e A : [ğ›¼â†¦â†’A] B2
typing-rcd
for each ğ‘–
Î“ âŠ¢eğ‘–: Ağ‘–
Î“ âŠ¢{ğ‘™ğ‘–= eğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›} : {ğ‘™ğ‘–: Ağ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
ğ‘’1 â†©â†’ğ‘’2
(Reduction)
step-beta
(ğœ†x : A. e1) v2 â†©â†’[ğ‘¥â†¦â†’v2] e1
step-appl
e1 â†©â†’eâ€²
1
e1 e2 â†©â†’eâ€²
1 e2
step-appr
e2 â†©â†’eâ€²
2
v1 e2 â†©â†’v1 eâ€²
2
step-fld
unfold [A] (fold [B] v) â†©â†’v
step-unfold
e â†©â†’eâ€²
unfold [A] e â†©â†’unfold [A] eâ€²
step-fold
e â†©â†’eâ€²
fold [A] e â†©â†’fold [A] eâ€²
step-tapp
e1 â†©â†’e2
e1 A â†©â†’e2 A
step-tabs
(Î›(ğ›¼â‰¤A). e) B â†©â†’[ğ›¼â†¦â†’B] e
step-proj
e â†©â†’eâ€²
e.ğ‘™ğ‘—â†©â†’eâ€².ğ‘™ğ‘—
step-projrcd
{ğ‘™ğ‘–= vğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}.ğ‘™ğ‘—â†©â†’vğ‘—
step-rcd
eğ‘—â†©â†’eâ€²
ğ‘—
{ğ‘™ğ‘–= ğ‘£ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘—âˆ’1, ğ‘™ğ‘—= eğ‘—, ğ‘™ğ‘˜= ğ‘’ğ‘˜ğ‘˜âˆˆğ‘—+1Â·Â·Â·ğ‘›} â†©â†’{ğ‘™ğ‘–= ğ‘£ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘—âˆ’1, ğ‘™ğ‘—= eâ€²
ğ‘—, ğ‘™ğ‘˜= ğ‘’ğ‘˜ğ‘˜âˆˆğ‘—+1Â·Â·Â·ğ‘›}
Fig. 2. Typing and Reduction Rules
Lemma 3.5 (Structural unfolding lemma). If Î“ âŠ¢ğœ‡ğ›¼. ğ´â‰¤ğœ‡ğ›¼. ğ¶â‰¤ğœ‡ğ›¼. ğ·â‰¤ğœ‡ğ›¼. ğµthen Î“ âŠ¢[ğ›¼â†¦â†’
ğœ‡ğ›¼. ğ¶] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ.
In this lemma, in the one-step unfolding the recursive types substituted in the bodies are, respec-
tively, a supertype and a subtype of ğœ‡ğ›¼. ğ´and ğœ‡ğ›¼. ğµ. In contrast, in the unfolding lemma proposed
by Zhou et al., the recursive types that get substituted in the bodies are the same. As Â§4.1 will
discuss, both forms of the unfolding lemma can be proved using a more general lemma.
Type Soundness. To see how the structural unfolding lemma is used in the proof of type preserva-
tion, let us consider an expression unfold[ğ·â€²](fold[ğ¶â€²] ğ‘’). Starting from a closed expression, both
ğ¶â€² and ğ·â€² must be recursive types, thus we assume that ğ¶â€² is ğœ‡ğ›¼. ğ¶and ğ·â€² is ğœ‡ğ›¼. ğ·,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:15
Î“ âŠ¢ğ´â‡‘ğµ
(Upper Exposure)
XA-promote
ğ›¼â‰¤A âˆˆÎ“
Î“ âŠ¢A â‡‘B
Î“ âŠ¢ğ›¼â‡‘B
XA-up
A is not type variable
Î“ âŠ¢A â‡‘A
Î“ âŠ¢ğ´â‡“ğµ
(Lower Exposure)
XA-top
Î“ âŠ¢âŠ¤â‡“ğœ‡ğ›¼. âŠ¤
XA-down
A is not type variable or âŠ¤
Î“ âŠ¢A â‡“A
Î“ âŠ¢ğ‘ğ‘’: ğ´
(Algorithmic Typing)
atyp-app
Î“ âŠ¢a e1 : A
Î“ âŠ¢A â‡‘A1 â†’A2
Î“ âŠ¢a e2 : B
Î“ âŠ¢B â‰¤A1
Î“ âŠ¢a e1 e2 : A2
atyp-tapp
Î“ âŠ¢a e : B
Î“ âŠ¢B â‡‘âˆ€(ğ›¼â‰¤B1). B2
Î“ âŠ¢A â‰¤B1
Î“ âŠ¢a e A : [ğ›¼â†¦â†’A] B2
atyp-sunfold
Î“ âŠ¢a e : A
Î“ âŠ¢B â‡‘ğœ‡ğ›¼. C
Î“ âŠ¢A â‰¤B
Î“ âŠ¢a unfold [B] e : [ğ›¼â†¦â†’B] C
atyp-sfold
Î“ âŠ¢a e : A
Î“ âŠ¢C â‡“ğœ‡ğ›¼. B
Î“ âŠ¢A â‰¤[ğ›¼â†¦â†’C] B
Î“ âŠ¢C
Î“ âŠ¢a fold [C] e : C
Fig. 3. Algorithmic Typing.
Î“ âŠ¢ğ‘’: [ğ›¼â†¦â†’ğ¶â€²] ğ´
Î“ âŠ¢ğœ‡ğ›¼. ğ´â‰¤ğ¶â€²
typing-sfold
Î“ âŠ¢fold[ğ¶â€²] ğ‘’: ğ¶â€²
Î“ âŠ¢ğ¶â€² â‰¤ğ·â€²
typing-sub
Î“ âŠ¢fold[ğ¶â€²] ğ‘’: ğ·â€²
Î“ âŠ¢ğ·â€² â‰¤ğœ‡ğ›¼. ğµ
typing-sunfold
Î“ âŠ¢unfold[ğ·â€²](fold[ğ¶â€²] ğ‘’) : [ğ›¼â†¦â†’ğ·â€²] ğµ
The type of unfold[ğ·â€²](fold[ğ¶â€²] ğ‘’) becomes [ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ, and it should be a subtype of
[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ´, which is the type of reduction result ğ‘’.
The other parts of the type soundness proof are standard, thus we have:
Theorem 3.6 (Preservation). If âŠ¢ğ‘’: ğ´and ğ‘’â†©â†’ğ‘’â€² then âŠ¢ğ‘’â€² : ğ´.
Theorem 3.7 (Progress). If âŠ¢ğ‘’: ğ´then ğ‘’is a value or exists ğ‘’â€²,ğ‘’â†©â†’ğ‘’â€².
3.4
Algorithmic typing
The rules that we have presented in Figure 2 are declarative. The conclusion of the subsumption
rule overlaps with all other rules, making it non-trivial to derive an implementation from the rules.
Figure 3 shows the algorithmic rules for typing. We only present new rules and rules that differ
from Figure 2. Compared with the declarative typing rules, the subsumption rule (typing-sub)
is removed. Besides, application (typing-app), type application (typing-tapp), structural folding
(typing-sfold) and structural unfolding (typing-sunfold) rules are replaced by rules atyp-app,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:16
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
atyp-tapp, atyp-sfold and atyp-sunfold, respectively. In the algorithmic typing rules we take
the standard approach of distributing subtyping checks in appropriate places in the other rules,
thus eliminating the need for the subsumption rule.
One interesting point is the two exposure relations â‡‘and â‡“in ğ¹ğœ‡
â‰¤. In ğ¹â‰¤, there is only the upper
exposure function (Î“ âŠ¢ğ´â‡‘ğµ), which is used to find the least non-variable upper bound for a
variable in the context [Pierce 2002]. Thus the upper exposure function plays an important role
for finding the minimal type with the algorithmic typing rules. To make our rules more general,
we additionally define the lower exposure function (Î“ âŠ¢ğ´â‡“ğµ) to find the greatest non-variable
subtype ğµfor ğ´. For ğ¹ğœ‡
â‰¤, lower exposure only helps to find the correct shape for the recursive type
body to be folded in rule atyp-sfold by mapping âŠ¤to ğœ‡ğ›¼. âŠ¤. The lower exposure function will be
more useful when we have lower bounded variables in the system, as we will see in Â§5.
The algorithmic rules are equivalent (sound and complete) with respect to the declarative rules:
Theorem 3.8 (Soundness of the algorithmic rules). If Î“ âŠ¢ğ‘ğ‘’: ğ´then Î“ âŠ¢ğ‘’: ğ´.
Theorem 3.9 (Completeness of the algorithmic rules). If Î“ âŠ¢ğ‘’: ğ´then there exists a ğµsuch that
Î“ âŠ¢ğ‘ğ‘’: ğµand Î“ âŠ¢ğµâ‰¤ğ´.
Theorem 3.9 implies that our algorithm can always find a minimal type, which is an important
property for ğ¹ğœ‡
â‰¤.
4
METATHEORY OF ğ¹ğœ‡
â‰¤
In this section we discuss the most interesting and difficult aspects of the metatheory of ğ¹ğœ‡
â‰¤in
more detail. We cover three key properties: the unfolding lemma, decidability of subtyping and the
conservativity of ğ¹ğœ‡
â‰¤over the original ğ¹â‰¤. The interaction between iso-recursive types and bounded
quantification requires significant changes in the proofs of the unfolding lemma and decidability.
In addition, conservativity cannot be proved using a declarative formulation of ğ¹ğœ‡
â‰¤, and we need to
employ the algorithmic formulation instead.
4.1
Unfolding Lemma
The unfolding lemma (Lemma 3.4) is a core lemma for the metatheory of a calculus with iso-
recursive subtyping. Though the statement of the unfolding lemma is quite simple and intuitive to
understand, the lemma cannot be proved directly. We will firstly review the previous approach to
prove the unfolding lemma, which does not account for bounded quantification, and then show
how to transfer this approach to a system with bounded quantification.
The previous approach for proving the unfolding lemma. Because the premise of the unfolding
lemma is a subtyping relation between two recursive types ğœ‡ğ›¼. ğ´â‰¤ğœ‡ğ›¼. ğµ, a direct induction on
such subtyping relation is problematic. Thus, we need to prove a generalized lemma first. In Zhou
et al.â€™s work that lemma has the following form:
Lemma 4.1 (The generalized unfolding lemma in Zhou et al. [2022]). If Î“1, ğ›¼, Î“2, âŠ¢ğ´â‰¤ğµand
Î“1 âŠ¢ğœ‡ğ›¼. ğ¶â‰¤ğœ‡ğ›¼. ğ·then
(1) Î“1, ğ›¼, Î“2 âŠ¢[ğ›¼â†¦â†’ğ¶ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğ·ğ›¼] ğµimplies Î“1, Î“2 âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ;
(2) Î“1, ğ›¼, Î“2 âŠ¢[ğ›¼â†¦â†’ğ·ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğ¶ğ›¼] ğµimplies Î“1, Î“2 âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğµ.
Due to the tricky interaction between rule S-var and rule S-arrow, in the generalized unfolding
lemma we need two mutual dependent lemmas: one is used for covariant cases (1) and the other one
is used for contravariant cases (2). The proof for this lemma proceeds by induction on Î“1, ğ›¼, Î“2, âŠ¢ğ´â‰¤
ğµ. In the inductive proof we need to switch between covariance and contravariance. In particular, in
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:17
the rule S-arrow case for functions, we need an induction hypothesis that arises from conclusion
(2) to prove the contravariant premise Î“ âŠ¢ğµ1 â‰¤ğ´1 relating the input types of the function.
For the generalized unfolding lemma in ğ¹ğœ‡
â‰¤, Lemma 4.1 is unfortunately not general enough.
In a setting with bounded quantification, Î“2 may contain bounds with the type variable ğ›¼, and
those variables are not being substituted in Lemma 4.1. Let us consider the effect of adding rule S-
vartrans. In the conclusion of Lemma 4.1, the variable ğ›¼is substituted by another type and tracked
in the context Î“2. In the premises of rule S-vartrans, we need to find the upper bound of variable ğ›¼
in the contexts Î“1 and Î“2. With those two observations, in our new attempt, the context also needs
to do substitutions. Thus, a natural attempt to solve this problem is to reformulate the lemma into
the following form (for the covariant case (1)):
Proposition 4.2 (A first attempt at the generalized unfolding lemma). If Î“1, ğ›¼â‰¤âŠ¤, Î“2 âŠ¢ğ´â‰¤ğµ
and Î“1 âŠ¢ğœ‡ğ›¼. ğ¶â‰¤ğœ‡ğ›¼. ğ·then Î“1, ğ›¼â‰¤âŠ¤, Î“2[ğ›¼â†¦â†’?ğ›¼] âŠ¢[ğ›¼â†¦â†’ğ¶ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğ·ğ›¼] ğµimplies
Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ?] âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ.
Here, the syntax Î“[ğ›¼â†¦â†’ğ‘†] denotes that all the occurrences of ğ›¼in context Î“ will be replaced
by a specified type ğ‘†. However, we do not know yet what type should be filled in the hole ? in
Proposition 4.2, so we leave the hole there for now. Although we omit conclusion (2) in Proposition
4.2, similar reasoning applies to that conclusion.
Let us now consider the effect of adding the rule S-eqivall: Assume that ğ´:= âˆ€(ğ›½â‰¤ğ‘ˆ1). ğ‘‡1
and ğµ:= âˆ€(ğ›½â‰¤ğ‘ˆ2). ğ‘‡2. The goal would look like:
Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ?] âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] âˆ€(ğ›½â‰¤ğ‘ˆ1). ğ‘‡1 â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] âˆ€(ğ›½â‰¤ğ‘ˆ2). ğ‘‡2
After simplification and applying rule S-eqivall, one of the goals becomes:
Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ?], ğ›½â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğ‘ˆ2 âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ‘‡1 â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğ‘‡2
From the above, we would expect that the hole ? is filled with ğ·because all the substitutions in the
context must be the same in order to apply induction hypothesis. Thus, a second attempt at the
generalized unfolding lemma looks like:
Proposition 4.3 (The second attempt at the generalized unfolding lemma (1)). If Î“1, ğ›¼â‰¤âŠ¤, Î“2 âŠ¢ğ´â‰¤ğµ
and Î“1 âŠ¢ğœ‡ğ›¼. ğ¶â‰¤ğœ‡ğ›¼. ğ·then Î“1, ğ›¼â‰¤âŠ¤, Î“2[ğ›¼â†¦â†’ğ·ğ›¼] âŠ¢[ğ›¼â†¦â†’ğ¶ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğ·ğ›¼] ğµimplies
Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ.
Proposition 4.3 deals with rule S-vartrans and S-eqivall successfully. However, the function
case, which is correctly proven in Lemma 4.1, will break. Consider ğ´:= ğ´1 â†’ğ´2 and ğµ:= ğµ1 â†’ğµ2,
and apply rule S-arrow. We need to prove two subgoals:
(1) Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ´2 â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ2;
(2) Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ1 â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğ´1.
Note that we do not have any induction hypothesis for proving subgoal (2) because occurrences of
ğ›¼in Î“2 have been substituted by ğœ‡ğ›¼. ğ·, but we expect the ğ›¼â€™s to have been replaced by ğœ‡ğ›¼. ğ¶for
applying the induction hypothesis. Even if we add the second conclusion back to the Proposition
4.3, we still have problems. For conclusion (2), the type used for the substitution in the context
should be same as the type used for the substitution in the right-hand side of the subtyping. If we
fill the hole ? with ğ¶in Proposition 4.2, the subgoal (1) in case S-arrow will get stuck for a similar
reason. Therefore, the type in the hole ? cannot be the type ğ¶or ğ·.
In summary, in the previous approach by Zhou et al., without bounded quantification, only the
interaction of covariance/contravariance between types has to be considered. In contrast, with
bounded quantification, the interaction of covariance/contravariance among contexts and types
also needs to be considered. Our generalization should be able to deal with all the complications
arising from rule S-var, rule S-vartrans, rule S-arrow and rule S-eqivall.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:18
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
The generalized unfolding lemma for ğ¹ğœ‡
â‰¤. Surprisingly, the generalization is relatively straightfor-
ward. For solving the issue that we mention above, instead of picking type ğ¶or type ğ·, we pick an
intermediate type ğ‘†between ğ¶and ğ·. We need the following auxiliary lemma:
Lemma 4.4. If Î“, ğ›¼â‰¤âŠ¤âŠ¢[ğ›¼â†¦â†’ğ´ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğµğ›¼] ğµthen Î“, ğ›¼â‰¤âŠ¤âŠ¢ğ´â‰¤ğµ.
The generalized unfolding lemma for ğ¹ğœ‡
â‰¤is:
Lemma 4.5 (The generalized unfolding lemma for ğ¹ğœ‡
â‰¤). If (1) Î“1, ğ›¼â‰¤âŠ¤, Î“2 âŠ¢ğ´â‰¤ğµ, (2) Î“1 âŠ¢ğœ‡ğ›¼. ğ¶â‰¤
ğœ‡ğ›¼. ğ‘†and (3) Î“1 âŠ¢ğœ‡ğ›¼. ğ‘†â‰¤ğœ‡ğ›¼. ğ·then
(1) Î“1, ğ›¼â‰¤âŠ¤, Î“2[ğ›¼â†¦â†’ğ‘†ğ›¼] âŠ¢[ğ›¼â†¦â†’ğ¶ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğ·ğ›¼] ğµimplies Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ‘†] âŠ¢[ğ›¼â†¦â†’
ğœ‡ğ›¼. ğ¶] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ·] ğµ;
(2) Î“1, ğ›¼â‰¤âŠ¤, Î“2[ğ›¼â†¦â†’ğ‘†ğ›¼] âŠ¢[ğ›¼â†¦â†’ğ·ğ›¼] ğ´â‰¤[ğ›¼â†¦â†’ğ¶ğ›¼] ğµimplies Î“1, Î“2[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ‘†] âŠ¢[ğ›¼â†¦â†’
ğœ‡ğ›¼. ğ·] ğ´â‰¤[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ¶] ğµ.
By applying Lemma 4.5 with Î“1 = Î“, Î“2 = Â·, ğ‘†= ğ´, ğ¶= ğ´and ğ·= ğµ, we prove the unfolding
lemma (Lemma 3.4). The premises can be obtained by inversion on Î“ âŠ¢ğœ‡ğ›¼. ğ´â‰¤ğœ‡ğ›¼. ğµ, and then
applying Lemma 4.4. Next we give an overview of the key points in the proof of Lemma 4.5 for the
four tricky cases. Assume that we do induction on premise (1).
â€¢ Rule S-var: This case mostly follows the previous approach. The interesting point is that we
cannot obtain ğœ‡ğ›¼. ğ¶â‰¤ğœ‡ğ›¼. ğ·directly from the conditions raised by the goals, but have one extra
step via transitivity (Theorem 3.3).
â€¢ Rule S-vartrans: For this case we need to consider two subcases. If ğ´= ğ›¼then from the context
ğ›¼â‰¤âŠ¤we can easily know that ğµis âŠ¤too. Otherwise, we apply the induction hypothesis directly.
â€¢ Rule S-arrow: This case is surprisingly easy: we can follow the previous approach for dealing
with the contravariant case for subtyping input types of functions, and apply the induction
hypothesis derived from conclusion (2) directly. Note that the key point of avoiding the issue we
discussed before is that, by picking an intermediate type ğ‘†, we decouple the substitution in the
context and in the subtyping relation for the function case. That is, the substitution with type
ğœ‡ğ›¼. ğ‘†is invariant in both subgoals, independent of the substitution in the subtyping relation.
â€¢ Rule S-eqivall: This case is the most interesting one. Assume ğ´= âˆ€(ğ›½â‰¤ğ‘ˆ1). ğ‘‡1 and ğµ= âˆ€(ğ›½â‰¤
ğ‘ˆ2). ğ‘‡2. Let us consider how to prove the goal (1). Doing inversion on condition arising from the
goal, we obtain that [ğ›¼â†¦â†’ğ¶ğ›¼] ğ‘ˆ1 and [ğ›¼â†¦â†’ğ·ğ›¼] ğ‘ˆ2 are equivalent. Meanwhile, we know ğ‘ˆ1
and ğ‘ˆ2 that are equivalent. There are two possibilities: either ğ¶and ğ·are equivalent or ğ›¼is not
in type ğ‘ˆ1 nor ğ‘ˆ2. For the latter case, we can rewrite the substituted types in the contexts for
aligning the contexts, then solve the issue we discussed above. The former case is quite subtle:
since ğ‘†lies in the middle of ğ¶and ğ·, the three types are all equivalent. In other words, we can
change the substituted types arbitrarily and get the equivalent types and contexts. The critical
point is that, although the substitution in the context is indeed affected by the substitution in the
supertype, since the bounds are equivalent, the type ğ‘†will converge into the types ğ¶and ğ·.
As a final note, we cannot apply this technique to full ğ¹â‰¤. In full ğ¹â‰¤, in the context, the type ğ¶
and ğ·will swap due to the contravariance. How to prove the unfolding lemma for full ğ¹â‰¤is not
clear now, and we leave this as the future work.
4.2
Decidability
Decidability is one of the important properties of ğ¹ğœ‡
â‰¤. We first start by reviewing the approaches
to prove decidability in kernel ğ¹â‰¤, and nominal unfoldings, and then describe our approach to
prove decidability. These two previous approaches to prove decidability employ different measures,
which creates a challenge for proving the decidability of ğ¹ğœ‡
â‰¤.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:19
Decidability of kernel ğ¹â‰¤. It is well-known that bounded quantification for full ğ¹â‰¤is undecidable
[Pierce 1994]. However, for kernel ğ¹â‰¤, identical bounds make the system decidable. A common
practice is to define a weight function to compute the size of a type [Pierce 2002]:
ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“(âŠ¤)
=
1
ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“1,ğ›¼â‰¤ğ´,Î“2 (ğ›¼)
=
1 + ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“1(ğ´)
ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“(âˆ€(ğ›¼â‰¤ğ´). ğµ)
=
1 + ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“,ğ›¼â‰¤ğ´(ğµ)
ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“(ğ´â†’ğµ)
=
1 + ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“(ğ´) + ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡Î“(ğµ)
For universal types, we store its bound into a context Î“, and when we meet the universal variable, we
retrieve its bound from the context and compute the size recursively. Since the size of a conclusion
is always greater than any premise, this measure can be used to show that the subtyping algorithm
in kernel ğ¹â‰¤terminates for all inputs.
Decidability of nominal unfoldings. The nominal unfolding rule in simple calculi with subtyping
is also decidable [Zhou et al. 2022]. Compared with kernel ğ¹â‰¤, the decidability proof of nominal
unfoldings is trickier. Based on the substitution of the type body, after every unfolding, the size
of types will increase. Thus a straightforward induction on the size of types does not work. Zhou
et al. choose a size measure based on an over-approximation of the height of the fully unfolded
tree. Concretely, they define a height function:
â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨(âŠ¤)
=
0
â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨(ğ›¼)
=
Î¨(ğ›¼) if ğ›¼âˆˆÎ¨ else 0
â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨(ğ´â†’ğµ)
=
1 + max(â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨(ğ´),â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨(ğµ))
â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨(ğœ‡ğ›¼. ğ´)
=
1 + let ğ‘–= â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨,ğ›¼â†¦â†’0(ğ´) in â„ğ‘’ğ‘–ğ‘”â„ğ‘¡Î¨,ğ›¼â†¦â†’ğ‘–+1(ğ´)
The size measure of a type ğ´is defined as â„ğ‘’ğ‘–ğ‘”â„ğ‘¡(ğ´) where the context is empty. In contrast to
kernel ğ¹â‰¤, the context here is used to store the size of the corresponding recursive variables. Zhou
et al. proved that such height measure will precisely decrease by one for every nominal unfolding.
Decidability of ğ¹ğœ‡
â‰¤. Now consider how to combine these two approaches together. We wish to
extend the measure of nominal unfoldings with the measure of kernel ğ¹â‰¤non-invasively. The
easiest thing to do is to switch the maximum function to addition for the function case in the
measure of nominal unfoldings, which simply widens the over-approximation. Then we consider
the major differences between the two approaches. There are three main challenges:
â€¢ The measures for variables are inconsistent in the two approaches: In the height function,
the type variable case is a base case, while in the weight function we will continue the computation
for a variable by getting its bound from the contexts. In ğ¹ğœ‡
â‰¤, a recursive variable is regarded as a
universal variable, so the new formulation should reflect those two distinct situations.
â€¢ The purposes of contexts are inconsistent in two approaches: The context of the height
function is used to store the pre-computed size of the recursive type body so that measures of
recursive variables are counted in their nominal unfolded form. The context of the weight function
is a straightforward bookkeeping of universal bounds. In later computation, these bounds will be
retrieved and their measure will be computed to serve as the measure of a universal variable.
This is to ensure that the premises in rule S-vartrans have a smaller measure of types than the
conclusion does. We need to treat both designs carefully if we want a unified context.
â€¢ The measure information is lost in the bounded quantification case: Recall that we employ
the rule S-eqivall instead of the standard rule S-kernelall for ğ¹â‰¤. Since we impose equivalent
bounds for kernel ğ¹â‰¤, for the subtyping relation Î“ âŠ¢âˆ€(ğ›¼â‰¤ğ´1). ğµ1 â‰¤âˆ€(ğ›¼â‰¤ğ´2). ğµ2, the measure
would consist of the measures of type ğ´1, ğ´2, ğµ1 and ğµ2. However, the measure for the premise
Î“, ğ›¼â‰¤ğ´2 âŠ¢ğµ1 â‰¤ğµ2 will lose the measure of type ğ´1 because we do not store it.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:20
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
We first show the measure used for the decidability of ğ¹ğœ‡
â‰¤, and then discuss how it addresses
the concerns above. The measure is relatively simple and based on the approach from Zhou et al.
[2022]. Similarly, we define a context Î¨ := Â· | Î¨, ğ›¼â†¦â†’ğ‘–which is used to store the measures of (both
universal and recursive) variables during the measure computation, where ğ‘–represents a natural
number. Then, a measure function ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´), defined on types, is:
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(nat)
=
1
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(âŠ¤)
=
1
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´â†’ğµ)
=
1 + ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´) + ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğµ)
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´ğ›¼)
=
1 + ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´)
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ›¼)
=
1 +
(
Î¨(ğ›¼)
ğ›¼âˆˆÎ¨
0
ğ›¼âˆ‰Î¨
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(âˆ€(ğ›¼â‰¤ğ´). ğµ)
=
let ğ‘–:= ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´) in 1 + ğ‘–+ ğ‘ ğ‘–ğ‘§ğ‘’Î¨,ğ›¼â†¦â†’ğ‘–(ğµ)
ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğœ‡ğ›¼. ğ´)
=
let ğ‘–:= ğ‘ ğ‘–ğ‘§ğ‘’Î¨,ğ›¼â†¦â†’1(ğ´) in 1 + ğ‘ ğ‘–ğ‘§ğ‘’Î¨,ğ›¼â†¦â†’ğ‘–(ğ´)
The formulation of the size function is very similar to the height function. We have an extra rule for
universal types, and slightly adjust the variable and recursive cases. The measure of universal types
is the sum of the measure of the bound and the measure of the body. For variables, one is added
when they are retrieved. Accordingly, we do not need to add one when storing the size of recursive
variables into the context. For atomic constructs, we follow the weight function and measure them
as 1.
We solve the first challenge in a straightforward way: there is no need to distinguish between
recursive and universal variables. The fact that all recursive variables in the context are bounded
by a top type whose measure is simply one fits our needs naturally.
As for the second concern, despite the different purposes of contexts, the key ideas of measuring
types in kernel ğ¹â‰¤and nominal unfoldings are the same: they both relate the measure of a variable
to its true meaning, either its unfolded form or its bound size. A slight modification is made
based on the definition of weight. In the weight function, for a universal variable, its bound is first
retrieved and then the measure is computed. To align with the â€œpre-computationâ€ mechanism of
measuring nominal unfoldings (ğ‘–:= ğ‘ ğ‘–ğ‘§ğ‘’Î¨,ğ›¼â†¦â†’1(ğ´)), we also pre-compute the measure of the bound
(ğ‘–:= ğ‘ ğ‘–ğ‘§ğ‘’Î¨(ğ´)) in the size function, so that we retrieve the measure instead of the type bound from
the context. In a well-formed type, variables are guaranteed to be unique, so we can use a single
context Î¨ to store the measures for both recursive variables and universal variables.
A subtler issue lies on variables in the initial subtyping context. When measuring nominal
unfoldings, the context in a subtyping relation is simply a list of variables, without any bound
information, so variables that occur freely can be counted as 0. In contrast, now the subtyping
context stores the bound information, and the measures of bounds play a role in deciding the
subtyping relation. To address this issue, we need to make sure that the bound information is
pre-computed in the measure function. We transform a subtyping context into an environment
containing measures Î¨, which tracks universal variables. In our decidability proof statement
(Lemma 4.6), Î¨ is computed from the subtyping context Î“ by an evaluation function ğ‘’ğ‘£ğ‘ğ‘™: Î“ â†©â†’Î¨,
defined as:
ğ‘’ğ‘£ğ‘ğ‘™(Â·)
=
Â·
ğ‘’ğ‘£ğ‘ğ‘™(Î“â€², ğ‘¥: ğ´)
=
ğ‘’ğ‘£ğ‘ğ‘™(Î“â€²)
ğ‘’ğ‘£ğ‘ğ‘™(Î“â€², ğ›¼â‰¤ğ´)
=
let Î¨â€² = ğ‘’ğ‘£ğ‘ğ‘™(Î“â€²) in Î¨â€², ğ›¼â†¦â†’ğ‘ ğ‘–ğ‘§ğ‘’Î¨â€²(ğ´)
With both ğ‘’ğ‘£ğ‘ğ‘™and ğ‘ ğ‘–ğ‘§ğ‘’we can then state the decidability theorem:
Lemma 4.6. If ğ‘ ğ‘–ğ‘§ğ‘’ğ‘’ğ‘£ğ‘ğ‘™(Î“) (ğ´) + ğ‘ ğ‘–ğ‘§ğ‘’ğ‘’ğ‘£ğ‘ğ‘™(Î“) (ğµ) â‰¤ğ‘˜then Î“ âŠ¢ğ´â‰¤ğµis either true or not.
Theorem 4.7 (Decidability). Î“ âŠ¢ğ´â‰¤ğµis decidable.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:21
As for the third concern, note that in ğ¹â‰¤, the subtyping relation is antisymmetric [Baldan et al.
1999]. Adding recursive types does not change the property of antisymmetry. However, the addition
of records makes the subtyping relation not antisymmetric: two record types may be syntactically
different. The lack of antisymmetry poses a challenge for our decidability proof, in particular for
rule S-eqivall. However, the fields of two equivalent records must be a permutation of each other.
Therefore, the measures of two equivalent record types are the same. As a result, the measure of
two equivalent bounds ğ´1 and ğ´2 is equal, as Lemma 4.8 describes. The measure information of
type ğ´1 can therefore be reconstructed from type ğ´2, addressing the final concern with decidability.
Lemma 4.8. If Î“ âŠ¢ğ´â‰¤ğµand Î“ âŠ¢ğµâ‰¤ğ´then ğ‘ ğ‘–ğ‘§ğ‘’ğ‘’ğ‘£ğ‘ğ‘™(Î“) (ğ´) = ğ‘ ğ‘–ğ‘§ğ‘’ğ‘’ğ‘£ğ‘ğ‘™(Î“) (ğµ).
4.3
Conservativity
One important feature of ğ¹ğœ‡
â‰¤is that it is conservative over kernel ğ¹â‰¤. Conservativity means that
equivalent ğ¹â‰¤judgments in ğ¹ğœ‡
â‰¤should behave in the same way as in ğ¹â‰¤. For instance, if a subtyping
statement is valid in ğ¹â‰¤, then it should also be valid in ğ¹ğœ‡
â‰¤. Dually, if a subtyping statement over
ğ¹â‰¤-types is invalid in ğ¹â‰¤, then it should also be invalid in ğ¹ğœ‡
â‰¤. In some calculi, including extensions of
ğ¹â‰¤with equi-recursive types [Ghelli 1993], conservativity is lost after the addition of new features.
For avoiding ambiguity, let âŠ¢ğ¹Î“, Î“ âŠ¢ğ¹ğ´, Î“ âŠ¢ğ¹ğ´â‰¤ğµ, âŠ¢ğ¹ğ‘’and Î“ âŠ¢ğ¹ğ‘’: ğ´represent the well-
formedness of environment, well-formedness of types, subtyping, well-formedness of expressions
and the typing relation, respectively, in kernel ğ¹â‰¤. Note that all these judgments are essentially
subsets of the judgments introduced in Â§3, except that the rules involving records and recursive
types are removed, and that the rule S-eqivall is replaced with the rule S-kernelall.
Conservativity of subtyping. Our conservativity result for subtyping is relatively easy to establish:
Lemma 4.9 (Conservativity for subtyping). If âŠ¢ğ¹Î“, Î“ âŠ¢ğ¹ğ´, and Î“ âŠ¢ğ¹ğµthen Î“ âŠ¢ğ¹ğ´â‰¤ğµif and only
if Î“ âŠ¢ğ´â‰¤ğµ.
Here the well-formedness conditions ensure that Î“, ğ´and ğµmust be respectively a valid ğ¹â‰¤
environment, and valid ğ¹â‰¤types. That is they cannot contain recursive types (or record types).
Therefore, the lemma states that for environments and types without recursive types, the two
subtyping relations (for ğ¹â‰¤and ğ¹ğœ‡
â‰¤) are equivalent, accepting the same statements. The only hurdle
is that to establish the correspondence between rule S-eqivall and the rule S-kernelall in
kernel ğ¹â‰¤, we need the antisymmetry property for kernel ğ¹â‰¤[Baldan et al. 1999].
Conservativity of typing. It is straightforward to obtain part of the conservativity result from
a typing relation in ğ¹â‰¤to a typing relation in ğ¹ğœ‡
â‰¤. As for the reverse direction, the situation is
more complicated. If we want to derive Î“ âŠ¢ğ¹ğ‘’: ğ´from Î“ âŠ¢ğ‘’: ğ´, when doing induction, for the
subsumption case (rule typing-sub), we need to guess an intermediate type. However, we do not
know if it involves recursive types or not. Consider the following example:
âŠ¢ğœ†ğ‘¥. ğ‘¥: âŠ¤â†’âŠ¤
âŠ¢âŠ¤â†’âŠ¤â‰¤(ğœ‡ğ›¼. âŠ¤) â†’âŠ¤
typing-sub
âŠ¢ğœ†ğ‘¥. ğ‘¥: (ğœ‡ğ›¼. âŠ¤) â†’âŠ¤
âŠ¢(ğœ‡ğ›¼. âŠ¤) â†’âŠ¤â‰¤âŠ¤
typing-sub
âŠ¢ğœ†ğ‘¥. ğ‘¥: âŠ¤
Although âŠ¢ğœ†ğ‘¥. ğ‘¥: âŠ¤do not involve recursive types, the typing subderivations can contain recursive
types. As a result, the induction hypothesis cannot be applied.
This problem can be addressed by employing the algorithmic formulation of ğ¹ğœ‡
â‰¤, shown in Â§3.4.
With algorithmic typing, we can have more precise information about the types of an expression,
since algorithmic typing always gives the minimum type. Therefore, it can be proved that for
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:22
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
expressions that do not use fold/unfold constructors, their minimum types do not contain recursive
types as well. Conservativity for algorithmic typing is proved as follows:
Lemma 4.10. If âŠ¢ğ¹Î“, Î“ âŠ¢ğ¹ğ´and âŠ¢ğ¹ğ‘’then Î“ âŠ¢ğ‘ğ‘’: ğ´implies Î“ âŠ¢ğ¹ğ‘’: ğ´.
Now, given a typing relation Î“ âŠ¢ğ‘’: ğ´in ğ¹ğœ‡
â‰¤, we first use the minimum typing property (Theorem
3.9) to obtain its minimum type ğµsuch that Î“ âŠ¢ğ‘ğ‘’: ğµand Î“ âŠ¢ğµâ‰¤ğ´. Applying Lemma 4.10 and
Lemma 4.9, we complete the conservativity proof for the declarative version of ğ¹ğœ‡
â‰¤.
Theorem 4.11 (Conservativity). If âŠ¢ğ¹Î“, Î“ âŠ¢ğ¹ğ´and âŠ¢ğ¹ğ‘’then Î“ âŠ¢ğ¹ğ‘’: ğ´if and only if Î“ âŠ¢ğ‘’: ğ´.
5
A CALCULUS WITH LOWER AND UPPER BOUNDED QUANTIFICATION
In this section we introduce an extension of ğ¹ğœ‡
â‰¤, called ğ¹ğœ‡
â‰¤â‰¥, with lower bounded quantification
and a bottom type. While upper bounded quantification has received a lot of attention in previous
research, lower bounded quantification for an ğ¹â‰¤-like language is much less explored, though it
appears in a few works [Amin and Rompf 2017; Oliveira et al. 2020]. We follow the same approach
as Oliveira et al. [2020], where their ğ¹â‰¤extension allows type variables to have either a lower
bound or an upper bound, but not both bounds at once. As discussed in Â§2.2, this extension enables
further applications, such as a form of extensible encodings of datatypes. We have proved all the
same results for ğ¹ğœ‡
â‰¤â‰¥that were proved for ğ¹ğœ‡
â‰¤, including type soundness, decidability, transitivity
and conservativity over ğ¹â‰¤.
5.1
The ğ¹ğœ‡
â‰¤â‰¥Calculus
The syntax of types, expressions, values and contexts for the extended ğ¹ğœ‡
â‰¤â‰¥calculus is shown below.
The main novelties are that bottom types and lower bounded quantification are introduced. The
syntactic additions are highlighted in gray .
Types
ğ´, ğµ, . . .
F
nat | âŠ¤| âŠ¥| ğ´1 â†’ğ´2 | ğ›¼| ğœ‡ğ›¼. ğ´| ğ´ğ›¼
| âˆ€(ğ›¼â‰¤ğ´). ğµ| âˆ€(ğ›¼â‰¥ğ´). ğµ| {ğ‘™ğ‘–: ğ´ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Expressions
ğ‘’
F
ğ‘¥| i | ğ‘’1 ğ‘’2 | ğœ†ğ‘¥: ğ´. ğ‘’| ğ‘’ğ´| Î›(ğ›¼â‰¤ğ´). ğ‘’| Î›(ğ›¼â‰¥ğ´). ğ‘’
| unfold [ğ´] ğ‘’| fold [ğ´] ğ‘’| {ğ‘™ğ‘–= ğ‘’ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›} | ğ‘’.ğ‘™
Values
ğ‘£
F
i | ğœ†ğ‘¥: ğ´. ğ‘’| fold [ğ´] ğ‘£| Î›(ğ›¼â‰¤ğ´). ğ‘’| Î›(ğ›¼â‰¥ğ´). ğ‘’
| {ğ‘™ğ‘–= ğ‘£ğ‘–ğ‘–âˆˆ1Â·Â·Â·ğ‘›}
Contexts
Î“
F
Â· | Î“, ğ›¼â‰¤ğ´| Î“, ğ›¼â‰¥ğ´| Î“,ğ‘¥: ğ´
Subtyping, typing and reduction. Similarly to Â§3.1, the well-formedness for the additional bottom
types and universal types with lower bounds are standard. Figure 4 shows the additional rules of ğ¹ğœ‡
â‰¤â‰¥
with respect to ğ¹ğœ‡
â‰¤for subtyping, typing and reduction. Compared with ğ¹ğœ‡
â‰¤, we add rule S-bot, S-
vartranslb and S-eqivalllb, which are the dual forms of rule S-top, S-vartrans and S-eqivall,
respectively. The rule typing-tapplb and typing-tabslb are the dual forms of rule typing-tapp and
typing-tabs for typing, respectively. The rule step-tabslb rule is the dual form of rule step-tabs
for reduction.
The new subtyping relation is reflexive and transitive:
Theorem 5.1 (Reflexivity for ğ¹ğœ‡
â‰¤â‰¥). If âŠ¢Î“ and Î“ âŠ¢ğ´then Î“ âŠ¢ğ´â‰¤ğ´.
Theorem 5.2 (Transitivity for ğ¹ğœ‡
â‰¤â‰¥). If Î“ âŠ¢ğ´â‰¤ğµand Î“ âŠ¢ğµâ‰¤ğ¶then Î“ âŠ¢ğ´â‰¤ğ¶.
Structural folding and lower bounded quantification. The structural folding rule typing-sfold
on recursive types has already been shown for ğ¹ğœ‡
â‰¤. Note that this rule is not strictly necessary for
ğ¹ğœ‡
â‰¤, because a recursive type can only be a subtype of another recursive type or the âŠ¤type. Thus
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:23
Î“ âŠ¢ğ´â‰¤ğµ
(Subtyping)
S-bot
âŠ¢Î“
Î“ âŠ¢A
Î“ âŠ¢âŠ¥â‰¤A
S-vartranslb
ğ›¼â‰¥B âˆˆÎ“
Î“ âŠ¢A â‰¤B
Î“ âŠ¢A â‰¤ğ›¼
S-eqivalllb
Î“ âŠ¢A1 â‰¤A2
Î“ âŠ¢A2 â‰¤A1
Î“, ğ›¼â‰¥A2 âŠ¢B â‰¤C
Î“ âŠ¢âˆ€(ğ›¼â‰¥A1). B â‰¤âˆ€(ğ›¼â‰¥A2). C
Î“ âŠ¢ğ‘’: ğ´
(Typing)
typing-tapplb
Î“ âŠ¢e : âˆ€(ğ›¼â‰¥B1). B2
Î“ âŠ¢B1 â‰¤A
Î“ âŠ¢e A : [ğ›¼â†¦â†’A] B2
typing-tabslb
Î“, ğ›¼â‰¥A âŠ¢e : B
Î“ âŠ¢Î›(ğ›¼â‰¥A). e : âˆ€(ğ›¼â‰¥A). B
ğ‘’1 â†©â†’ğ‘’2
(Reduction)
step-tabslb
(Î›(ğ›¼â‰¥A). e) B â†©â†’[ğ›¼â†¦â†’B] e
Fig. 4. Additional subtyping, typing and reduction rules for ğ¹ğœ‡
â‰¤â‰¥with respect to ğ¹ğœ‡
â‰¤.
the effect of structural folding in ğ¹ğœ‡
â‰¤, can be subsumed by other subtyping/typing rules. Perhaps
for this reason, Abadi et al. [1996] have only considered a structural unfolding rule. However, in
ğ¹ğœ‡
â‰¤â‰¥, a recursive type can also be a subtype of a type variable. In this case, the structural folding
rule can give the desired typings to the Addâˆ€constructors of the Exp1 and Exp2 datatypes that we
have presented in Â§2.2, while the standard folding rule cannot. The rule typing-sfold has the same
form in ğ¹ğœ‡
â‰¤â‰¥as in ğ¹ğœ‡
â‰¤. Therefore, we believe that the structural folding rule that we have proposed,
together with the structural unfolding lemma in the metatheory, is general.
Type soundness. Our type soundness proof for ğ¹ğœ‡
â‰¤â‰¥is standard, thus we have:
Theorem 5.3 (Preservation for ğ¹ğœ‡
â‰¤â‰¥). If âŠ¢ğ‘’: ğ´and ğ‘’â†©â†’ğ‘’â€² then âŠ¢ğ‘’â€² : ğ´.
Theorem 5.4 (Progress for ğ¹ğœ‡
â‰¤â‰¥). If âŠ¢ğ‘’: ğ´then ğ‘’is a value or exists ğ‘’â€²,ğ‘’â†©â†’ğ‘’â€².
5.2
Metatheory of ğ¹ğœ‡
â‰¤â‰¥
The addition of lower bounded quantification and the bottom type creates some difficulties in the
metatheory of ğ¹ğœ‡
â‰¤â‰¥. The proof strategies for the unfolding lemma, decidability and conservativity,
as we showed in the Â§4 for ğ¹ğœ‡
â‰¤, require some adjustments. In the following, we describe how to
overcome the difficulties. We refer readers to the extended version of the paper for more details.
Unfolding Lemma. A type system that simultaneously allows introducing lower and upper
bounded type variables will break the proof for the unfolding lemma shown in Â§4.1. The interaction
of lower bounds and upper bounds invalidates the following inversion lemma for rule S-vartrans,
which has been used to prove the unfolding lemma:
Lemma 5.5. If ğ›¼â‰¤ğ´âˆˆÎ“, Î“ âŠ¢ğ›¼â‰¤ğµ, and ğ›¼â‰ ğµthen Î“ âŠ¢ğ´â‰¤ğµ.
This lemma holds when the bounds in the context can only have one direction. However, when
we have both kinds of bounds in the context, a counter-example can be found as follows:
ğ‘¥â‰¤âŠ¤,ğ‘¦â‰¥ğ‘¥âŠ¢ğ‘¥â‰¤ğ‘¦
=â‡’
\
ğ‘¥â‰¤âŠ¤,ğ‘¦â‰¥ğ‘¥âŠ¢âŠ¤â‰¤ğ‘¦
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:24
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
For avoiding using this inversion lemma in the proof of unfolding lemma, we need to refine the
generalized unfolding lemma. In Lemma 4.5, there is more than one subtyping statement on the
premises related to type ğ´and ğµ, and we do induction on the premise (1). In the refined generalized
unfolding lemma, we integrate those subtyping statements into one statement, thus the premise (1)
can be induced implicitly. Meanwhile, the context is also refined to be more general. The concrete
generalized unfolding lemma for ğ¹ğœ‡
â‰¤â‰¥is shown in the extended version of the paper. With these
changes we prove:
Lemma 5.6 (Unfolding lemma for ğ¹ğœ‡
â‰¤â‰¥). If Î“ âŠ¢ğœ‡ğ›¼. ğ´â‰¤ğœ‡ğ›¼. ğµthen Î“ âŠ¢[ğ›¼â†¦â†’ğœ‡ğ›¼. ğ´] ğ´â‰¤[ğ›¼â†¦â†’
ğœ‡ğ›¼. ğµ] ğµ.
Decidability. The interaction between bottom types and rule S-eqivall breaks the measure-
based decidability proof in Â§4.2. The bottom type in ğ¹ğœ‡
â‰¤brings a new form of equivalent types:
when ğ›¼â‰¤âŠ¥âˆˆÎ“, one can derive that Î“ âŠ¢ğ›¼â‰¤âŠ¥and Î“ âŠ¢âŠ¥â‰¤ğ›¼, as observed by Pierce [1997].
Simply extending the measure function with ğ‘ ğ‘–ğ‘§ğ‘’Î¨(âŠ¥) = 1 will not work. For type variables, the
measure function will recursively look up its bound in the context, and add one to the measure of
its bound, making a variable equivalent to âŠ¥to have a larger measure than âŠ¥. Therefore, replacing
two equivalent types into the abstracted type body may not produce the same measures. We can
construct derivations of rule S-eqivall that have a larger measure in the premise than that of the
conclusion, which makes the decidability proof fail with the current measure.
We solve this issue by replacing all the type variables who are a subtype of bottom by bottom.
Every time that we compute the size for a variable bounded by an upper bound, we firstly recursively
check whether it is a synonym for bottom, and return the size of bottom if it is. This can be
implemented by an extension to the measure context Î¨. Dually, when we compute the size for a
variable bounded by a lower bound, we recursively check if it is the supertype of top. With this
change the measures work, and we can prove decidability.
Theorem 5.7 (Decidability for ğ¹ğœ‡
â‰¤â‰¥). ğ¹ğœ‡
â‰¤â‰¥is decidable.
Conservativity. The proof of conservativity for ğ¹ğœ‡
â‰¤â‰¥follows the same pattern as the proof for ğ¹ğœ‡
â‰¤.
To prove conservativity of typing, we need the help of the algorithmic typing rules to obtain the
minimum type of an ğ¹â‰¤term. However, the introduction of bottom types requires us to add several
new algorithmic typing rules, since in the declarative system, one can always use the subsumption
rule to transform a term with type âŠ¥to any function type or universal type, and apply it to any
argument, as also observed by Pierce [1997]. We also develop a similar treatment for recursive
types. Moreover, the meanings of the two exposure functions also need to be refined. For example,
the upper exposure function (â‡‘) is now used to find the least non-upper-bounded-variable upper
bound in the context, so it will return the variable itself if the variable is lower bounded. For lower
exposure, we also need a dual form of the rule XA-promote, which finds the non-variable lower
bound for a variable:
XA-downpromote
ğ›¼â‰¥A âˆˆÎ“
Î“ âŠ¢A â‡“B
Î“ âŠ¢ğ›¼â‡“B
The complete set of ğ¹ğœ‡
â‰¤â‰¥algorithmic typing rules can be found in the extended version of the paper.
Theorem 5.8 (Conservativity for ğ¹ğœ‡
â‰¤â‰¥). If âŠ¢ğ¹Î“, Î“ âŠ¢ğ¹ğ´and âŠ¢ğ¹ğ‘’then Î“ âŠ¢ğ¹ğ‘’: ğ´if and only if
Î“ âŠ¢ğ‘’: ğ´.
6
RELATED WORK
Bounded Quantification and Recursive Types. Bounded quantification was firstly introduced by
Cardelli and Wegner [1985] in the language Fun, where their kernel Fun calculus corresponds
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:25
to the kernel version of ğ¹â‰¤. The full variant of ğ¹â‰¤was introduced by Curien and Ghelli [1992]
and Cardelli et al. [1994], where the subtyping for bounds are contravariant. Although full ğ¹â‰¤is
powerful, subtyping is proved to be undecidable [Pierce 1994]. As discussed in Â§1 there are several
attempts to add recursive types to ğ¹â‰¤, such as the work by Ghelli [1993], Colazzo and Ghelli [2005]
and Jeffrey [2001]. Unfortunately, as Table 1 shows, such combinations are not painless, and even
the successful combinations require the significant changes for the subtyping rules.
Ghelli illustrates how the combination of equi-recursive subtyping and full ğ¹â‰¤changes the
expressiveness power of the subtyping relation with a simple example:
ğµ
â‰¡
âˆ€ğ›¼. âˆ’(âˆ€(ğ›¼â€² â‰¤ğ›¼). âˆ’ğ›¼)
ğ´
â‰¡
âˆ€(ğ›½â‰¤ğµ). ğ›½
ğ´â€²
â‰¡
âˆ€(ğ›½â‰¤ğµ). âˆ€(ğ›½â€² â‰¤ğ›½). âˆ’ğ›½
ğ‘…
â‰¡
âˆ€(ğ›½â‰¤ğµ). ğœ‡ğ‘‹. âˆ€(ğ›½â€² â‰¤ğ‘‹). âˆ’ğ‘‹
where âˆ’ğ´stands for ğ´â†’âŠ¤and âˆ€ğ›¼. ğ´is the abbreviation of âˆ€(ğ›¼â‰¤âŠ¤). ğ´. In full ğ¹â‰¤, ğ´â‰¤ğ´â€² does
not hold. However, such system allows ğ´â‰¤ğ‘…and ğ‘…â‰¤ğ´â€² to be derived, which by transitivity, allows
us to conclude that ğ´â‰¤ğ´â€². In Colazzo and Ghelliâ€™s work, there is no independent universal type,
and the shape of recursive types is either ğœ‡ğ›¼.âˆ€(ğ‘¥â‰¤ğ´). ğµor ğœ‡ğ›¼. ğ´â†’ğµ. The recursive variables
and universal variables are distinct, resulting in changes in environments and subtyping rules. For
example, the subtyping environment is defined as Î  := Â· | Î , (ğ‘¥,ğ‘¦) â‰¤(ğ´, ğµ) | Î , (ğ›¼= ğ´, ğ›½= ğµ),
and the rule S-vartrans rule of ğ¹â‰¤is changed to:
(ğ‘¥,ğ‘¦) â‰¤(ğ´â€², ğµâ€²) âˆˆÎ 
âˆ€ğ›¼â€², ğµâ‰ ğ›¼â€²
ğµâ‰ âŠ¤
ğµâ‰ ğ‘¦
Î  âŠ¢ğ´â€² â‰¤ğµ
Î  âŠ¢ğ‘¥â‰¤ğµ
The algorithm proposed by Jeffrey is also complex, and requires major changes. Both recursive
variables and the subtyping algorithm are labelled polarly, and the implementation of ğ›¼-conversion
is not discussed. In contrast, our subtyping rules do not change the contexts, the types are not
restricted, and most importantly, we do not have to change the rules in the original ğ¹â‰¤. This has
the benefit that we can largely reuse the existing metatheory of the original ğ¹â‰¤, and it also enables
our conservativity result. While it is plausible that Jeffreyâ€™s or Colazzo and Ghelliâ€™s work for the
kernel ğ¹â‰¤extensions with recursive types are conservative, this has not been proved. Furthermore,
such proof is likely to be non-trivial because of the major changes introduced by equi-recursive
subtyping.
There are many other extensions to ğ¹â‰¤. Bounded existentials are also studied by Cardelli and
Wegner [1985]. Existential types can be encoded by universal types, thus we can obtain a form
of bounded existentials for free in ğ¹â‰¤[Cardelli and Wegner 1985]. Another important extension
is f-bounded quantification, firstly proposed by Canning et al. [1989], then studied by Baldan
et al. [1999] in terms of the basic theory. In f-bounded quantification, the bounded variables are
allowed to appear in the bound. For example, a bound of the form âˆ€(ğ›¼â‰¤ğ¹[ğ›¼]). ğµ, where ğ¹is a
type-level function applied to ğ›¼, is allowed in f-bounded quantification. We can encode polymorphic
binary methods [Bruce et al. 1995] and methods that have recursive types in their signatures with
f-bounded quantification. For the example that we have showed in Â§2.2, the bound in the translate
function is not Point but would have a form ğ¹[ğ›¼] = {ğ‘¥: Int, ğ‘¦: Int, move : Int â†’Int â†’ğ›¼}.
Therefore, with f-bounded quantification the translate function could have the type:
âˆ€(ğ›¼â‰¤{ğ‘¥: Int, ğ‘¦: Int, move : Int â†’Int â†’ğ›¼}). ğ›¼â†’ğ›¼
Then the ğ›¼can instantiate to Point or subtypes of Point, because Point â‰¤ğ¹[Point]. Note that for
subtyping statements such as ğ›¼â‰¤{ğ‘¥: Int, ğ‘¦: Int, move : Int â†’Int â†’ğ›¼} to hold, they must
be interpreted using equi-recursive subtyping, since the f-bounds are normally records, and an
iso-recursive type cannot be the subtype of a record. This approach is appealing because it can
even deal with binary methods, where recursive types appear in negative positions. For example,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:26
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
with f-bounded quantification we can model bounds such as ğ›¼â‰¤{ğ‘¥: Int, eq : ğ›¼â†’Bool}, and still
have the expected subtyping relations.
Whereas we show that with the structural unfolding rule we can model positive cases of f-bounded
quantification (such as translate) in ğ¹ğœ‡
â‰¤, we can only model a restricted form of negative f-bounded
quantification. For instance in ğ¹ğœ‡
â‰¤we can have the bound ğ›¼â‰¤ğœ‡P. {ğ‘¥: Int, eq : P â†’Bool} and we
can instantiate ğ›¼with ğ‘ƒ(where ğ‘ƒ= ğœ‡P. {ğ‘¥: Int, eq : P â†’Bool}). However, we would not be able
to instantiate ğ›¼with some types that have extra fields, such as ğœ‡Pâ€™. {ğ‘¥: Int, ğ‘¦: Int, eq : Pâ€™ â†’Bool}
for example. In contrast, f-bounded quantification allows such forms of instantiation. Nevertheless,
given the overlap between some of the applications of iso-recursive types in ğ¹ğœ‡
â‰¤and f-bounded
quantification, we believe that it is worthwhile to investigate whether f-bounded quantification
can be avoided to deal with general binary methods.
Dependent Object Types. The interest in languages with bounded quantification and recursive
types has been reignited recently in the research community with the introduction of the dependent
object types (DOT) [Rompf and Amin 2016] calculus. DOT is the foundation of Scala 3 [EPFL 2021],
and also employs a generalized form of bounded quantification and recursive types. The generalized
form of bounded quantification subsumes both upper and lower bounded quantification, which are
present in ğ¹ğœ‡
â‰¤â‰¥. DOT supports both upper and lower bounds at the same time for path selection.
In addition, DOT also supports path-dependent types [Amin et al. 2014] and intersection types
[Barbanera et al. 1995; Coppo et al. 1981; Pottinger 1980]. DOT can encode full ğ¹â‰¤[Rompf and
Amin 2016] and has been shown to be undecidable [Hu and LhotÃ¡k 2020; Mackay et al. 2020]. One
of the limitations for DOT is that transitivity elimination is not possible [Rompf and Amin 2016],
and even the decidable fragments of DOT lack transitivity [Hu and LhotÃ¡k 2020; Mackay et al.
2020]. The research on DOT has been intimately related to ğ¹â‰¤. For instance, Amin and Rompf
[2017] explain many of the features of DOT by incrementally extending ğ¹â‰¤. In addition, there have
been various attempts to prove the undecidability of DOT by a reduction to the undecidability
problem in ğ¹â‰¤. Although, as Hu and LhotÃ¡k [2020] observed, DOT is not conservative over ğ¹â‰¤.
Thus an undecidability result for DOT cannot be proved by reduction to the undecidability of full
ğ¹â‰¤. While ğ¹ğœ‡
â‰¤â‰¥does not have all the features of DOT, our results can potentially help in research in
that area, where the decidable fragments of DOT lack important properties such as transitivity. In
addition ğ¹ğœ‡
â‰¤â‰¥preserves the conservativity over ğ¹â‰¤, while DOT does not.
Object Encodings. Recursive records can encode objects [Bruce et al. 1999; Canning et al. 1989;
Cook et al. 1989]. Alternatively, existential types can also be used to encode objects [Pierce and
Turner 1994], or they can be employed together with recursive types [Bruce 1994]. Pierce and
Turnerâ€™s object encoding is notable in that it requires only ğ¹â‰¤, and does not employ recursive
types. The ORBE encoding, presented by Abadi et al. [1996] consists of recursive types, bounded
existential quantification, records, and the structural unfolding rule. In their work, an interface is
encoded as:
ğ‘‚ğ‘…ğµğ¸(ğ¼) â‰œğœ‡ğ›¼. âˆƒ(ğ›½â‰¤ğ›¼). ğ›½Ã— (ğ›½â†’ğ¼(ğ›½))
As Bruce et al. observe, the ORBE encoding requires full ğ¹â‰¤for the bounded quantification subtyping
rule. When we try to compare two bounds, the type variable will be substituted with the existential
types, which may result in bounds that are not equivalent. The overview paper by Bruce et al. [1999]
makes a detailed comparison among different object encodings. Except for the ORBE encoding,
ğ¹ğœ‡
â‰¤could serve as a target for the existing object encodings. However, no complete formalization
of ğ¹â‰¤with recursive types with desirable properties (such as type soundness and conservativity)
existed at the time. Our work helps to further validate such encodings by providing a complete
formalization of ğ¹â‰¤with recursive types, together with various desirable properties.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:27
Algebraic Datatypes and Subtyping. Algebraic datatypes are a fundamental feature in modern
functional programming languages, such as Haskell [Haskell Development Team 1990] and Ocaml
[INRIA 1987]. However, such languages do not support subtyping between datatypes. Hosoya
et al. [1998] discussed the interaction between mutually recursive datatypes and subtyping. They
presented two variants of ğ¹â‰¤extending ğ¹â‰¤with user-defined datatype declarations. The first variant
has user-defined subtyping declarations between datatypes, and can be viewed as having a form
of nominal subtyping. The second variant allows structural subtyping among the datatypes. One
advantage of employing user-defined datatypes is that it is simple to deal with formally, and that it
allows mutually recursive datatype definitions easily. However, they do not support conventional
recursive types of the form ğœ‡ğ›¼. ğ´as we do in ğ¹ğœ‡
â‰¤. Moreover, they do not consider lower bounded
quantification which, as argued in Â§2.2, seems to be quite useful in a system targeting algebraic
datatypes. There has been some work integrating ML datatypes and OO classes [Bourdoncle and
Merz 1997; Millstein et al. 2004]. In the implementation of hierarchical extensible datatypes, methods
are simulated via functions with dynamic dispatch. Those works are focused on the design of
intermediate languages that have complex constructs such as classes or datatypes. In contrast, we
develop foundational calculi, where more complex constructs can be encoded. Finally, Poll [1998]
investigated the categorical semantics of datatypes with subtyping and a limited form of inheritance
on datatypes, improving our understanding on the relation between categorical datatypes and
object types.
Oliveira [2009] showed encodings of algebraic datatypes with subtyping assuming a variant of
ğ¹â‰¤extended with records, recursive types and higher kinds. He showed that adding subtyping
to datatypes allows solving the Expression Problem [Wadler 1998]. However, as we mentioned
in Â§2.2, he did not formalize the ğ¹â‰¤extension, although he showed a translation of the encoding
into Scala. Moreover, his encoding is more complex than ours because he employs upper bounded
quantification with higher kinds. In Â§2.2, we showed that first-order lower bounded quantification
in ğ¹ğœ‡
â‰¤â‰¥, together with the structural folding rule enables such encodings. Like for encodings of
objects, our work is helpful to further validate such encodings formally.
7
CONCLUSION
Recursive types and bounded quantification are important in many programming languages.
However, although those features are well-studied independently, their interaction has posed a
long term challenge. Our ğ¹ğœ‡
â‰¤calculus illustrates how to integrate iso-recursive types and kernel ğ¹â‰¤.
We obtain a transitive and decidable subtyping relation, while the full calculus is shown to be
conservative over ğ¹â‰¤and is proven to be type-sound. ğ¹ğœ‡
â‰¤and ğ¹ğœ‡
â‰¤â‰¥could serve as a theoretic
foundation for object encodings and encodings of algebraic datatypes with subtyping. With the
renewed interest on recursive types and bounded quantification due to the DOT calculus, we
believe that our work is also helpful to find calculi with most features in DOT, while retaining
desirable properties, such as decidability and transitivity of subtyping, or even conservativity over
ğ¹â‰¤. Investigating extensions of ğ¹ğœ‡
â‰¤with some of the features of DOT is a clear avenue for future
work. In addition, studying the combination of iso-recursive subtyping and full ğ¹â‰¤, could be useful
for modelling the ORBE encoding [Abadi et al. 1996].
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their helpful comments. This work has been sponsored by
Hong Kong Research Grant Council projects number 17209519, 17209520 and 17209821.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:28
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
REFERENCES
MartÃ­n Abadi, Luca Cardelli, and Ramesh Viswanathan. 1996. An interpretation of objects and object types. In Proceedings
of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 396â€“409.
Roberto M. Amadio and Luca Cardelli. 1993. Subtyping recursive types. ACM Transactions on Programming Languages and
Systems (TOPLAS) 15, 4 (1993), 575â€“631.
Nada Amin and Tiark Rompf. 2017. Type soundness proofs with definitional interpreters. In Proceedings of the 44th ACM
SIGPLAN Symposium on Principles of Programming Languages. 666â€“679.
Nada Amin, Tiark Rompf, and Martin Odersky. 2014. Foundations of path-dependent types. Acm Sigplan Notices 49, 10
(2014), 233â€“249.
Brian Aydemir, Arthur CharguÃ©raud, Benjamin C. Pierce, Randy Pollack, and Stephanie Weirich. 2008. Engineering formal
metatheory. Acm sigplan notices 43, 1 (2008), 3â€“15.
Michael Backes, CÄƒtÄƒlin HriÅ£cu, and Matteo Maffei. 2014. Union, intersection and refinement types and reasoning about
type disjointness for secure protocol implementations. Journal of Computer Security 22, 2 (2014), 301â€“353.
Paolo Baldan, Giorgio Ghelli, and Alessandra Raffaeta. 1999. Basic theory of F-bounded quantification. Information and
Computation 153, 2 (1999), 173â€“237.
Franco Barbanera, Mariangiola Dezani-Ciancaglini, and Ugo deâ€™Liguoro. 1995. Intersection and Union Types: Syntax and
Semantics. Information and Computation 119, 2 (June 1995), 202â€“230.
Jesper Bengtson, Karthikeyan Bhargavan, CÃ©dric Fournet, Andrew D. Gordon, and Sergio Maffeis. 2011. Refinement types
for secure implementations. ACM Transactions on Programming Languages and Systems (TOPLAS) 33, 2 (2011), 1â€“45.
Corrado BÃ¶hm and Alessandro Berarducci. 1985. Automatic synthesis of typed Lambda-programs on term algebras.
Theoretical Computer Science 39, 2-3 (1985).
FranÃ§ois Bourdoncle and Stephan Merz. 1997. Type checking higher-order polymorphic multi-methods. In Proceedings of
the 24th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 302â€“315.
Michael Brandt and Fritz Henglein. 1997. Coinductive axiomatization of recursive type equality and subtyping, Vol. 1210.
63â€“81. Full version in Fundamenta Informaticae, 33:309â€“338, 1998.
Kim Bruce, Luca Cardelli, Giuseppe Castagna, Hopkins Objects Group, Gary T Leavens, and Benjamin C. Pierce. 1995. On
binary methods. Theory and Practice of Object Systems 1, 3 (1995), 221â€“242.
Kim B Bruce. 1994. A paradigmatic object-oriented programming language: Design, static typing and semantics. Journal of
Functional Programming 4, 2 (1994), 127â€“206.
Kim B. Bruce, Luca Cardelli, and Benjamin C. Pierce. 1999. Comparing Object Encodings. Information and Computation 155,
1.
Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. 1989. F-Bounded Polymorphism for Object-
Oriented Programming. In Proceedings of the Fourth International Conference on Functional Programming Languages and
Computer Architecture (Imperial College, London, United Kingdom) (FPCA 1989). 8 pages.
Luca Cardelli. 1985. Amber. In LITP Spring School on Theoretical Computer Science. Springer, 21â€“47.
Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. 1994. An extension of system F with subtyping.
Information and computation 109, 1-2 (1994), 4â€“56.
Luca Cardelli and Peter Wegner. 1985. On understanding types, data abstraction, and polymorphism. ACM Computing
Surveys (CSUR) 17, 4 (1985), 471â€“523.
Giuseppe Castagna and Benjamin C. Pierce. 1994. Decidable Bounded Quantification. In Proceedings of the 21st ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (Portland, Oregon, USA) (POPL â€™94). Association
for Computing Machinery, New York, NY, USA, 151â€“162.
Alonzo Church. 1932. A set of postulates for the foundation of logic. 33, 2 (1932), 346â€“366.
Dario Colazzo and Giorgio Ghelli. 2005. Subtyping recursion and parametric polymorphism in kernel fun. Information and
Computation 198, 2 (2005), 71â€“147.
William R. Cook, Walter Hill, and Peter S. Canning. 1989. Inheritance is Not Subtyping. In Proceedings of the 17th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL â€™90). Association for Computing Machinery.
Mario Coppo, Mariangiola Dezani-Ciancaglini, and Betti Venneri. 1981. Functional characters of solvable terms. Mathematical
Logic Quarterly 27, 2-6 (1981), 45â€“58.
Pierre-Louis Curien and Giorgio Ghelli. 1992. Coherence of subsumption, minimum typing and type-checking in Fâ‰¤.
Mathematical structures in computer science 2, 1 (1992), 55â€“91.
EPFL. 2021. Scala 3. https://www.scala-lang.org/
Vladimir Gapeyev, Michael Levin, and Benjamin C. Pierce. 2003. Recursive Subtyping Revealed. Journal of Functional
Programming 12, 6 (2003), 511â€“548. Preliminary version in International Conference on Functional Programming (ICFP),
2000. Also appears as Chapter 21 of Types and Programming Languages by Benjamin C. Pierce (MIT Press, 2002).
Giorgio Ghelli. 1993. Recursive types are not conservative over Fâ‰¤. In International Conference on Typed Lambda calculi and
Applications. Springer, 146â€“162.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:29
Jean-Yves Girard. 1972. InterprÃ©tation fonctionnelle et elimination des coupures de lâ€™arithmÃ©tique dâ€™ordre supÃ©rieur. ThÃ¨se
dâ€™Ã©tat. UniversitÃ© de Paris 7.
Haskell Development Team. 1990. Haskell. https://www.haskell.org/
Haruo Hosoya, Benjamin C. Pierce, and David N. Turner. 1998. Datatypes and subtyping. Unpublished manuscript (1998).
Jason ZS Hu and OndÅ™ej LhotÃ¡k. 2020. Undecidability of D<: and its decidable fragments. Proceedings of the ACM on
Programming Languages 4, POPL (2020), 1â€“30.
INRIA. 1987. OCaml. https://ocaml.org/
Alan Jeffrey. 2001. A symbolic labelled transition system for coinductive subtyping of Fğœ‡â‰¤types. In 2001 IEEE Conference on
Logic and Computer Science (LICS 2001). 323.
Jay Ligatti, Jeremy Blackburn, and Michael Nachtigal. 2017. On subtyping-relation completeness, with an application to
iso-recursive types. ACM Transactions on Programming Languages and Systems (TOPLAS) 39, 1 (2017), 1â€“36.
Julian Mackay, Alex Potanin, Jonathan Aldrich, and Lindsay Groves. 2020. Decidable subtyping for path dependent types.
Proc. ACM Program. Lang. 4, POPL (2020), 66:1â€“66:27.
Todd Millstein, Colin Bleckner, and Craig Chambers. 2004. Modular typechecking for hierarchically extensible datatypes
and functions. ACM Transactions on Programming Languages and Systems (TOPLAS) 26, 5 (2004), 836â€“889.
James Hiram Jr Morris. 1969. Lambda-calculus models of programming languages. Ph.D. Dissertation. Massachusetts Institute
of Technology.
Bruno C. d. S. Oliveira. 2009. Modular visitor components. In European Conference on Object-Oriented Programming. Springer,
269â€“293.
Bruno C. d. S. Oliveira, Shaobo Cui, and Baber Rehman. 2020. The Duality of Subtyping. In 34th European Conference on
Object-Oriented Programming, ECOOP 2020, November 15-17, 2020, Berlin, Germany (Virtual Conference) (LIPIcs), Robert
Hirschfeld and Tobias Pape (Eds.).
Michel Parigot. 1992. Recursive programming with proofs. Theoretical Computer Science 94, 2 (1992), 335â€“356.
Benjamin C. Pierce. 1994. Bounded quantification is undecidable. Information and Computation 112, 1 (1994), 131â€“165.
Benjamin C Pierce. 1997. Bounded quantification with bottom. Technical Report. Citeseer.
Benjamin C. Pierce. 2002. Types and programming languages. MIT press.
Benjamin C Pierce and David N Turner. 1994. Simple type-theoretic foundations for object-oriented programming. Journal
of functional programming 4, 2 (1994), 207â€“247.
Erik Poll. 1998. Subtyping and Inheritance for Categorical Datatypes: Preliminary Report (Type Theory and its Applications
to Computer Systems). Kyoto University Research Information Repository 1023 (1998), 112â€“125.
Garrel Pottinger. 1980. A type assignment for the strongly normalizable ğœ†-terms. To HB Curry: essays on combinatory logic,
lambda calculus and formalism (1980), 561â€“577.
John C. Reynolds. 1974. Towards a theory of type structure. In Colloque sur la Programmation. Springer, 408â€“425.
Tiark Rompf and Nada Amin. 2016. Type soundness for dependent object types (DOT). In Proceedings of the 2016 ACM
SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications. 624â€“641.
Davide Sangiorgi and Robin Milner. 1992. The Problem of â€œWeak Bisimulation up toâ€. In CONCUR, Vol. 630. 32â€“46.
Dana Scott. 1962. A system of functional abstraction. (1962). Lectures delivered at University of California, Berkeley,
California, USA, 1962/63.
Philip Wadler. 1998. The Expression Problem. (1998). discussion on the Java Genericity mailing list.
Yaoda Zhou, Bruno C. d. S. Oliveira, and Jinxu Zhao. 2020. Revisiting Iso-Recursive Subtyping. Proc. ACM Program. Lang. 4,
OOPSLA (2020).
Yaoda Zhou, Jinxu Zhao, and Bruno C. d. S. Oliveira. 2022. Revisiting Iso-Recursive Subtyping. ACM Transactions on
Programming Languages and Systems 44, 4, Article 24 (2022).
Received 2022-07-07; accepted 2022-11-07
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

