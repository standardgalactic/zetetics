48
Recursive Subtyping for All
LITAO ZHOU∗and YAODA ZHOU∗, The University of Hong Kong, China
BRUNO C. D. S. OLIVEIRA, The University of Hong Kong, China
Recursive types and bounded quantification are prominent features in many modern programming languages,
such as Java, C#, Scala or TypeScript. Unfortunately, the interaction between recursive types, bounded
quantification and subtyping has shown to be problematic in the past. Consequently, defining a simple
foundational calculus that combines those features and has desirable properties, such as decidability, transitivity
of subtyping, conservativity and a sound and complete algorithmic formulation has been a long time challenge.
This paper presents an extension of kernel 𝐹≤, called 𝐹𝜇
≤, with iso-recursive types. 𝐹≤is a well-known
polymorphic calculus with bounded quantification. In 𝐹𝜇
≤we add iso-recursive types, and correspondingly
extend the subtyping relation with iso-recursive subtyping using the recently proposed nominal unfolding
rules. We also add two smaller extensions to 𝐹≤. The first one is a generalization of the kernel 𝐹≤rule for
bounded quantification that accepts equivalent rather than equal bounds. The second extension is the use of so-
called structural folding/unfolding rules, inspired by the structural unfolding rule proposed by Abadi, Cardelli,
and Viswanathan. The structural rules add expressive power to the more conventional folding/unfolding
rules in the literature, and they enable additional applications. We present several results, including: type
soundness; transitivity and decidability of subtyping; the conservativity of 𝐹𝜇
≤over 𝐹≤; and a sound and
complete algorithmic formulation of 𝐹𝜇
≤. Moreover, we study an extension of 𝐹𝜇
≤, called 𝐹𝜇
≤≥, which includes
lower bounded quantification in addition to the conventional (upper) bounded quantification of 𝐹≤. All the
results in this paper have been formalized in the Coq theorem prover.
CCS Concepts: • Theory of computation →Type theory; • Software and its engineering →Object
oriented languages.
Additional Key Words and Phrases: Iso-Recursive Subtyping, Bounded Polymorphism, Object Encodings
ACM Reference Format:
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira. 2023. Recursive Subtyping for All. Proc. ACM Program.
Lang. 7, POPL, Article 48 (January 2023), 29 pages. https://doi.org/10.1145/3571241
1
INTRODUCTION
Recursive types and bounded quantification are two prominent features in many modern program-
ming languages, such as Java, C#, Scala or TypeScript. Bounded quantification was introduced
by Cardelli and Wegner [1985] in the Fun language, and has been widely studied [Cardelli et al.
1994; Curien and Ghelli 1992; Pierce 1994]. Bounded quantification addresses the interaction be-
tween parametric polymorphism and subtyping, allowing polymorphic variables to have subtyping
bounds. Recursive types are needed in practically all programming languages to model recursive
data structures (such as lists or trees), or recursive object types in Object-Oriented Programming
∗Both authors contributed equally to this work.
Authors’ addresses: Litao Zhou; Yaoda Zhou, Department of Computer Science, The University of Hong Kong, Hong Kong,
China, ltzhou@cs.hku.hk, ydzhou@cs.hku.hk; Bruno C. d. S. Oliveira, Department of Computer Science, The University of
Hong Kong, Hong Kong, China, bruno@cs.hku.hk.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee
provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and
the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses,
contact the owner/author(s).
© 2023 Copyright held by the owner/author(s).
2475-1421/2023/1-ART48
https://doi.org/10.1145/3571241
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:2
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
(OOP) languages to encode binary methods [Bruce et al. 1995]. For adding recursive types to a
language with subtyping, it is desirable to have recursive subtyping between recursive types. The
first rules for recursive subtyping, due to Cardelli [1985], are the well-known Amber rules. Recursive
subtyping has been studied in two different forms: equi-recursive subtyping [Amadio and Cardelli
1993; Brandt and Henglein 1997; Gapeyev et al. 2003], and iso-recursive subtyping [Bengtson et al.
2011; Ligatti et al. 2017; Zhou et al. 2020, 2022]. In equi-recursive subtyping recursive types and
their unfoldings are considered to be equal. In contrast, in iso-recursive subtyping they are only
isomorphic and explicit fold/unfold operators are necessary to witness the isomorphism.
From the mid-80s and throughout the 90s there was a lot of work on establishing the type-
theoretic foundations for OOP. Both recursive subtyping, as well as bounded quantification played
a major part on this effort. The two features were perceived to be important to model objects
in some forms of object encodings. At that time the key ideas around 𝐹≤[Cardelli et al. 1994;
Cardelli and Wegner 1985; Curien and Ghelli 1992], which is a polymorphic calculus with bounded
quantification (but no recursive types) were reasonably well understood due to the early work on
the Fun language by Cardelli and Wegner. Therefore 𝐹≤-like calculi were being used in foundational
work on OOP. Some landmark papers on the foundations of OOP, which established important
results such as the distinction between inheritance and subtyping [Cook et al. 1989], f-bounded
quantification [Canning et al. 1989], or encodings of objects [Abadi et al. 1996; Bruce et al. 1999;
Cook et al. 1989], essentially assumed some 𝐹≤variant with recursive types. Typically, recursive
subtyping was supported via the Amber rules. However, extensions of 𝐹≤with recursive types had
still not been developed and formally studied when many of those works were published.
After the first formalization of 𝐹≤[Curien and Ghelli 1992], Ghelli [1993] questioned this state-of-
affairs, which implicitly assumed that the extension of 𝐹≤with recursive types was straightforward.
He conducted the first formal study for such an extension, and showed a wide range of negative
results. Most importantly, he showed that equi-recursive types are not conservative over full 𝐹≤. In
other words, adding equi-recursive types to full 𝐹≤changes the expressive power of the subtyping
relation, even when the types being compared do not involve any recursive types. The simple addition
of equi-recursive types allows well-formed, but invalid subtyping statements in 𝐹≤to be valid in
an extension with recursive types. Ghelli also shows that applying equi-recursive types to full 𝐹≤
invalidates transitivity elimination: we cannot drop the transitivity rule without losing expressive
power. In addition, while subtyping in full 𝐹≤is undecidable [Pierce 1994], the change in expressive
power reopens questions about the decidability or undecidability of the system.
Even if we choose the weaker form of bounded quantification present in Fun language and
kernel 𝐹≤, the natural extension of Amadio and Cardelli [1993]’s algorithm to kernel 𝐹≤is incom-
plete [Colazzo and Ghelli 2005]. Nevertheless, instead of Amadio and Cardelli’s meet 2 times rules,
Colazzo and Ghelli gave an alternative meet 3 times algorithm, accompanied by a very challenging
correctness proof, showing that the subtyping relation is transitive and complete, but did not
prove conservativity. Based on an earlier draft from Colazzo and Ghelli, Jeffrey [2001] extended the
system and proved it correct and complete. By transferring the polar bisimulations [Sangiorgi and
Milner 1992] technique from concurrency theory, Jeffrey’s system is more general than Colazzo
and Ghelli’s, but it is only partially decidable. It is decidable for kernel 𝐹𝑒𝑞𝑢𝑖
≤
, but for full 𝐹𝑒𝑞𝑢𝑖
≤
, only
when the algorithm terminates it returns the correct answer, but it may not terminate. Furthermore,
although more powerful, Jeffrey’s full 𝐹𝑒𝑞𝑢𝑖
≤
is not conservative over 𝐹≤either.
Table 1 summarizes the results of previous work on extending 𝐹≤with recursive types. Note that,
in the table, the Type System row simply means whether the typing relation of the 𝐹≤extension
with recursive types has been studied/presented in the paper. For properties such as type soundness,
decidability or conservativity, there is a corresponding entry in the table, which states whether the
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:3
Table 1. Comparison among different works.
𝐹𝑒𝑞𝑢𝑖
≤
Kernel 𝐹𝑒𝑞𝑢𝑖
≤
𝐹𝑒𝑞𝑢𝑖
≤
Kernel 𝐹𝑒𝑞𝑢𝑖
≤
𝐹𝑖𝑠𝑜
≤
𝐹𝜇
≤
1993
2005
2001
2001
1996
present work
Transitivity
×
✓
✓
✓
built-in
✓
Decidability
✓
✓∖
✓
✓
Conservativity
×
×
✓
Type System
✓
✓
Algorithmic Type System
✓
Type Soundness
✓
Modularity
×
×
×
×
✓
Mechanized Proofs
×
×
×
×
×
✓
A × symbol denotes a negative result (the property or feature does not hold). A ✓denotes a positive result,
while ✓∖denotes a partial result (such as semi-decidability). Whitespace denotes that the property/feature has
not been studied or it is unknown.
property was proved or not. Modularity here means whether the original rules and definitions of
𝐹≤are the same or they need to be modified. The proofs in all the 4 systems with equi-recursive
types are complex because of the strong recursion. Adding equi-recursive subtyping requires major
changes in existing definitions, rules and proofs compared to 𝐹≤, making most of the existing
metatheory on 𝐹≤not reusable. No prior work has proved the conservativity of 𝐹≤with equi-
recursive types. This result is likely to be hard to prove because of the numerous non-modular
changes in 𝐹≤induced by the introduction of equi-recursive subtyping. Furthermore, in those works
the full type systems are not provided. Perhaps motivated by the technical challenges and negative
results posed by equi-recursive types, some researchers set their sights on iso-recursive types. In
their work on object encodings, Abadi et al. [1996] proposed the 𝐹<:𝜇calculus, which supports
bounded universal types, bounded existential types and iso-recursive types via the Amber rules.
However, reflexivity and transitivity are built-in, so the system is not algorithmic. Furthermore,
while they presented the typing, subtyping and reduction rules, they have not proved any properties,
including type soundness or the conservativity over full 𝐹≤. One potential reason for the absence of
technical results is that the iso-recursive Amber rules are hard to work with formally [Backes et al.
2014; Ligatti et al. 2017; Zhou et al. 2020, 2022]: it is difficult to prove results such as transitivity, or
define sound and complete algorithmic formulations.
This paper presents an extension of kernel 𝐹≤, called 𝐹𝜇
≤, with iso-recursive types. In 𝐹𝜇
≤we add
iso-recursive subtyping using the recently proposed nominal unfolding rules [Zhou et al. 2022].
The nominal unfolding rules have been formally proved to be type sound, and shown to have the
same expressive power as the well-known iso-recursive Amber rules [Cardelli 1985]. Moreover, the
nominal unfolding rules address the difficulties of working formally with the (iso-recursive) Amber
rules. With the nominal unfolding rules, proving transitivity and other properties is easy, also
enabling developing algorithmic formulations of subtyping instead. Furthermore, a nice property of
the nominal unfolding rules is that they are modular, allowing an existing calculus to be extended
with recursive types without major impact on existing definitions and proofs. In other words
they allow reusing most existing metatheory and definitions that existed before the addition of
iso-recursive types. Our work shows that the nominal unfolding rules proposed by Zhou et al. can
be integrated modularly into 𝐹≤, while retaining desirable properties. In particular, we prove, for
the first time, the conservativity of an extension of 𝐹≤with recursive types over the original 𝐹≤.
We also add two smaller extensions to 𝐹≤. The first one is a generalization of the kernel 𝐹≤rule
for bounded quantification that accepts equivalent rather than equal bounds. The second extension
is the use of so-called structural folding/unfolding rules, inspired by the structural unfolding rule
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:4
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
proposed by Abadi et al. [1996]. The structural rules add expressive power to the more conventional
folding/unfolding rules in the literature, and they enable additional applications. In particular, we
illustrate how the structural rules play an important role to model encodings of objects, as well as
encodings of algebraic datatypes with subtyping.
We present several results, including: type soundness; transitivity and decidability of subtyp-
ing; the conservativity of 𝐹𝜇
≤over 𝐹≤; and a sound and complete algorithmic formulation of 𝐹𝜇
≤.
Moreover, we also present an extension of 𝐹𝜇
≤, called 𝐹𝜇
≤≥, which has a bottom type and lower
bounded quantification in addition to the conventional (upper) bounded quantification of 𝐹≤. As we
show, lower bounded quantification is particularly interesting to model the subtyping of algebraic
datatypes. All the results in this paper have been formalized in the Coq theorem prover.
In summary the contributions of this paper are:
• 𝐹𝜇
≤: an extension of kernel 𝐹≤with iso-recursive types and subtyping. We prove several
important properties for 𝐹𝜇
≤, including: type soundness; transitivity and decidability of subtyping;
and the unfolding lemma.
• The conservativity of 𝐹𝜇
≤over 𝐹≤. Conservativity is an expected, but non-trivial property, that
has eluded past work on the combination of bounded quantification and recursive types. We
show that an extension of kernel 𝐹≤with iso-recursive subtyping based on the nominal unfolding
rules is conservative over kernel 𝐹≤.
• Type soundness for the structural folding/unfolding rules. We present the first formal type
soundness proof for the structural unfolding rule, and we also present a new structural folding
rule, together with its type soundness.
• Decidability for a generalization of the kernel 𝐹≤rule for bounded quantification, which
compares the bounds for equivalence. A key property is that equivalent types have equal sizes,
enabling the decidability proof.
• An extension of 𝐹𝜇
≤with both upper and lower bounded quantification: We present an
extended calculus, called 𝐹𝜇
≤≥, with both top and bottom types, and both upper and lower bounded
quantification, and illustrate its applicability to encodings of datatypes with subtyping.
• Coq formalization: We have formalized all the calculi and proofs in this paper in Coq, and
made the formalization available online: https://github.com/juda/Recursive-Subtyping-for-All
2
OVERVIEW
This section provides an overview of our work. We first briefly review basic concepts and some
applications. Then we show our key ideas and results.
2.1
Bounded Quantification and Recursive Subtyping
Bounded Quantification. Bounded quantification allows types to be abstracted by type vari-
ables with a subtyping constraint (or bound). The standard calculus with bounded quantification,
𝐹≤[Cardelli et al. 1994; Cardelli and Wegner 1985; Curien and Ghelli 1992], has two common
variants when it comes to subtyping universal types. The full 𝐹≤variant [Cardelli et al. 1994; Curien
and Ghelli 1992] compares bounded quantifiers with the following rule:
S-fullall
Γ ⊢A2 ≤A1
Γ, 𝛼≤A2 ⊢B ≤C
Γ ⊢∀(𝛼≤A1). B ≤∀(𝛼≤A2). C
The most significant characteristic of full 𝐹≤is that it allows two bounded quantifiers to be
contravariant on their bound types 𝐴1 and 𝐴2 when being compared. However, the rich expressivity
of full 𝐹≤results in an undecidable subtyping relation [Pierce 1994], which is undesirable. In addition,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:5
as Ghelli [1993] demonstrates, the rule S-fullall may even prevent conservative extensions of 𝐹≤
in the presence of additional features.
There are several ways to restrict bounded quantification to a fragment with decidable sub-
typing, such as removing top types, or assuming no bounds when comparing type abstraction
bodies [Castagna and Pierce 1994]. Among those the most widely used variant is the kernel 𝐹≤
calculus. In kernel 𝐹≤bounded quantifiers can only be subtypes when their bound types are
identical [Cardelli and Wegner 1985], which is stated in the rule S-kernelall.
S-kernelall
Γ ⊢A
Γ, 𝛼≤A ⊢B ≤C
Γ ⊢∀(𝛼≤A). B ≤∀(𝛼≤A). C
S-eqivall
Γ ⊢A1 ≤A2
Γ ⊢A2 ≤A1
Γ, 𝛼≤A2 ⊢B ≤C
Γ ⊢∀(𝛼≤A1). B ≤∀(𝛼≤A2). C
In the rest of the paper, we will focus on kernel 𝐹≤, in order to achieve decidable subtyping
with iso-recursive subtyping. However, differently from kernel 𝐹≤, we will generalize the rule S-
kernelall to a rule S-eqivall that accepts equivalent bounds instead. The main motivation for
using rule S-eqivall is to enable more subtyping involving records. While typically kernel 𝐹≤
is presented without records, in this paper we include records in the calculus and we wish to
consider types such as {𝑥: nat,𝑦: nat} and {𝑦: nat,𝑥: nat}, to be equivalent (despite being
syntactically different). Note that, while in plain 𝐹≤the subtyping relation is antisymmetric [Baldan
et al. 1999] (i.e. if two types are equivalent then they must be equal), the addition of records breaks
antisymmetry since there are equivalent types that are not equal. The rule S-eqivall is more
general than the kernel rule with identical bounds, but retains decidability, as we shall see in §4.2.
Recursive Types. Recursive types 𝜇𝛼. 𝐴, can be traced back to Morris [1969]. There are two
basic approaches to recursive types: equi-recursive types and iso-recursive types. The essential
difference between them is how they consider the relationship between a recursive type 𝜇𝛼. 𝐴and
its unfoldings [𝛼↦→𝜇𝛼. 𝐴] 𝐴. In equi-recursive types, a recursive type is equal to its unfolding. That
is 𝜇𝛼. 𝐴= [𝛼↦→𝜇𝛼. 𝐴] 𝐴. In other words, recursive types and their unfoldings are interchangeable
in all contexts. In iso-recursive types, a recursive type and its one-step unfolding are not equal but
only isomorphic. To convert between 𝜇𝛼. 𝐴and [𝛼↦→𝜇𝛼. 𝐴] 𝐴back and forth we need explicit
unfold and fold operators. A fold expression constructs a recursive type, while an unfold expression
opens a recursive type, as rule typing-fold and rule typing-unfold illustrate:
typing-unfold
Γ ⊢e : 𝜇𝛼. A
Γ ⊢unfold [𝜇𝛼. A] e : [𝛼↦→𝜇𝛼. A] A
typing-fold
Γ ⊢e : [𝛼↦→𝜇𝛼. A] A
Γ ⊢𝜇𝛼. A
Γ ⊢fold [𝜇𝛼. A] e : 𝜇𝛼. A
Recursive Subtyping. Subtyping between recursive types has been studied for many years [Amadio
and Cardelli 1993; Cardelli 1985; Ligatti et al. 2017]. The most widely used subtyping rules for
recursive types are the Amber rules [Cardelli 1985], which consist of three rules: rule S-amber,
rule S-assmp and rule S-refl.
S-amber
Γ, 𝛼≤𝛽⊢A ≤B
Γ ⊢𝜇𝛼. A ≤𝜇𝛽. 𝐵
S-assmp
𝛼≤𝛽∈Γ
Γ ⊢𝛼≤𝛽
S-refl
Γ ⊢A ≤A
The Amber rules are simple, but their metatheory is troublesome. For example, transitivity is hard
to prove [Bengtson et al. 2011; Zhou et al. 2020, 2022]. Furthermore, due to the reliance on the
reflexivity rule (rule S-refl), the Amber rules are problematic for subtyping relations that are not
antisymmetric [Ligatti et al. 2017]. Recently, Zhou et al. [2020, 2022] proposed a new specification
for iso-recursive subtyping and some equivalent algorithmic variants. For this paper we use one of
those algorithmic variants, called the nominal unfolding rules [Zhou et al. 2022]. The main reason
to choose the nominal unfolding rules is that are easy to work with formally and Zhou et al. have
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:6
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
a full Coq development, including proofs of decidability, that we reuse and extend. The nominal
unfolding rules are:
S-nominal
Γ, 𝛼⊢[𝛼↦→A𝛼] A ≤[𝛼↦→B𝛼] B
Γ ⊢𝜇𝛼. A ≤𝜇𝛼. B
S-label
Γ ⊢A ≤B
Γ ⊢A𝛼≤B𝛼
The key intuition for the nominal unfolding rules is that, in order to correctly deal with subtyping
for contravariant occurrences of recursive type variables, we must unfold the recursive bodies
twice to check the validity of the subtyping statement. For instance, the subtyping statement
𝜇𝛼. 𝛼→nat ≤𝜇𝛼. 𝛼→⊤should be rejected. If we unroll the recursive types twice, we get the
following invalid subtyping statement:
((𝜇𝛼. 𝛼→nat) →nat) →nat ≤((𝜇𝛼. 𝛼→⊤) →⊤) →⊤
which requires both that nat ≤⊤(which is true) and ⊤≤nat, which is false and is the reason
why the subtyping statement should fail. Note that unrolling this example one time only results in
(𝜇𝛼. 𝛼→nat) →nat ≤(𝜇𝛼. 𝛼→⊤) →⊤, which does not expose ⊤≤nat and is the reason why
unrolling 1-time only is not enough. The rule S-nominal mimics this double-unrolling process, but
we obtain the following subtyping statement instead:
(𝛼→nat)𝛼→nat ≤(𝛼→⊤)𝛼→⊤
where the recursive types are replaced by 𝛼(note that 𝛼≤𝛼trivially holds). This statement is
sufficient to trigger enough subtyping comparisons to validate the correctness of the subtyping
statement. In particular, it also requires checking that ⊤≤nat, which is false and will reject the
subtyping statement. By using recursive variables instead of the recursive types in the (double)
unfolding process we obtain a terminating procedure. The nominal unfolding rules use labelled
types A𝛼, to ensure that we only compare types that arise from unfolding substitutions with
related unfolded types. Labelled types are a syntactic devise used to prevent accepting subtyping
statements such as 𝜇𝛼. nat →𝛼≤𝜇𝛼. nat →nat →⊤, which would be unsound in an iso-
recursive formulation. They also provide a distinct nominal identity to the recursive types being
compared, so that they cannot be compared with other unrelated recursive types. Note that, in the
rule S-nominal, we have reused the recursive variable name for the label 𝛼. However, we used the
red color to distinguish the label and type variable names. Labels 𝛼should be the same in both
substitutions, and distinct from any other labels and bound variables used elsewhere. Since in the
paper presentation we use a nominal approach to represent binders, the label 𝛼should be interpreted
as some unique freshly generated name1. Zhou et al. proved that the nominal unfolding rules are
type sound, and have the same expressive power as the iso-recursive Amber rules. Moreover, unlike
the Amber rules, they are easy to work with formally and they can be easily used in subtyping
relations that are not antisymmetric.
2.2
Applications of Bounded Quantification and Recursive Types
We now turn to applications of bounded quantification and recursive types. In particular the classic
application for both features is encodings of objects [Bruce et al. 1999]. In addition, we also show
that the two features are useful to model encodings of algebraic datatypes with subtyping.
Object Encodings. A simple and well-known typed encoding of objects is the recursive records
encoding [Bruce et al. 1999; Canning et al. 1989; Cook et al. 1989]. In this encoding the idea is that
object types are encoded as recursive record types, and objects are encoded as records. We will use
1In our Coq formalization we use a locally nameless representation [Aydemir et al. 2008], which distinguishes free and
bound variables naturally. With a locally nameless representation we can reuse the free variable name 𝛼for the label 𝛼.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:7
a simplified form of the encoding, where we do not deal with self-references. But self-references
could be dealt with in standard ways. For example, we can define a type Point:
Point ≜𝜇pnt.{x : Int, y : Int, move : Int →Int →pnt}
which consists of its coordinates and a move function. We use a recursive type because move should
return an updated point. To implement Point we define some auxiliary functions:
function getX(p : Point) = (unfold [Point] p ). x
function getY(p : Point) = (unfold [Point] p ). y
function moveTo(p : Point, x : Int , y : Int ) = (unfold [Point] p ). move x y
then a constructor mkPoint can be defined as:
function mkPoint(x1 : Int , y1 : Int ) = fold [Point] { x=x1, y=y1, move = 𝜆x2 y2. mkPoint(x2, y2) }
Note that the auxiliary functions above would not be needed in a source language, since a source
language would treat p.x as syntactic sugar for (unfold [Point] p).x. Similarly, the source language
would automatically insert a fold in the object constructor. In other words, in a source language
with iso-recursive subtyping the fold’s and unfold’s do not need to be explicitly written and are
automatically inserted by the compiler. For instance, this is what Abadi et al. [1996]’s translation of
a language with objects into an iso-recursive extension of 𝐹≤does.
With subtyping, we can develop subtypes of Point, such as:
ColorPoint ≜𝜇pnt.{x : Int, y : Int, move : Int →Int →pnt, color : String}
EqPoint ≜𝜇pnt.{x : Int, y : Int, move : Int →Int →pnt, eq : pnt →Bool}
Now we wish to translate the coordinates by one unit for a point, but we do not want to write such
a translation function for all subclasses of Point. This is achieved with a polymorphic function:
function translate [P ≤Point] (p : P) = (unfold [Point] p ). move (getX p + 1) (getY p + 1)
The type of this translate function is ∀(P ≤Point). P →Point, which is obtained from the following
typing derivation (some parts omitted):
P ≤Point, p : P ⊢p : P
P ≤Point, p : P ⊢P ≤Point
typing-sub
P ≤Point, p : P ⊢p : Point
typing-unfold
P ≤Point, p : P ⊢(unfold [Point] p) :
 x : Int, y : Int,
move : Int →Int →Point

. . .
⊢translate : ∀(P ≤Point). P →Point
However, this type is unsatisfying because it loses type precision: it returns a Point instead of a
P. The type that we want instead is:
∀(P ≤Point). P →P
Unfortunately, we cannot obtain this more general type with only bounded quantification, and the
usual unfolding rule typing-unfold. In the rule typing-unfold, the unfold annotation must be a
recursive type. However, if we wish to return P, then we should use unfold with the annotation P,
which is not a recursive type, but a type variable. Some advanced techniques, such as f-bounded
quantification [Canning et al. 1989], address this issue. 𝐹𝜇
≤uses a less intrusive approach to obtain
the desired typing for translate via the structural unfolding rules, which we discuss in §2.3.
Encoding positive f-bounded quantification. Fortunately, with the structural rules, we can use a
type variable as an annotation for unfold. This enables us to encode forms of f-bounded quantifica-
tion with positive occurrences of recursive variables, which is the case for Point. We can change
the unfold annotation in translate from the recursive type Point to its subtype, the type variable P:
function translate [P ≤Point] (p : P) = (unfold [P] p ). move (getX p + 1) (getY p + 1)
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:8
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
In §2.3 we discuss the typing of this program via the structural unfolding rule in detail. After this
change the type of translate is ∀(P ≤Point). P →P. Then we can apply translate to Point or any
of its subtypes, without losing static precision. Thus, if we call translate [EqPoint] (mkEqPoint 0
0), then we obtain an EqPoint object at (1, 1). Note also that here mkEqPoint is a constructor for
objects with type EqPoint, which contain a binary method [Bruce et al. 1995] eq.
function mkEqPoint(x1 : Int, y1 : Int ) = fold [EqPoint]
{ x = x1, y = y1, move = 𝜆x2 y2. mkEqPoint(x2, y2), eq = 𝜆p. (getX p == x1) ∧(getY p == y1) }
Encodings of Algebraic Datatypes with Subtyping. It is well-known that in the polymorphic lambda
calculus (System F) [Girard 1972; Reynolds 1974], we can use Church [1932] encodings to encode
algebraic datatypes [Böhm and Berarducci 1985]. However, Church encodings make it hard to
encode some operations, or worst they prevent encoding certain operations with the correct time
complexity. A well-known example [Church 1932] is the encoding of the predecessor function on
natural numbers, which is linear with Church encodings instead of being constant time.
An alternative encoding of datatypes in the untyped lambda calculus, which avoids the issues
of Church encodings, is due to Scott [1962]. Unfortunately, Scott encodings cannot be encoded
in plain System F. However, the addition of recursive types to a polymorphic lambda calculus
allows a typed encoding for Scott encodings [Parigot 1992]. Moreover, in the presence of subtyping,
we can also encode algebraic datatypes with subtyping, enabling certain forms of reuse that are
not possible without subtyping. Oliveira [2009] has shown this assuming a 𝐹≤-like language with
recursive types and records, but he has not formalized such a language. Here we revisit Oliveira’s
example. A similar encoding for datatypes can be achieved in 𝐹𝜇
≤. For example, one may define a
datatype Exp1 for mathematical expressions, with numeric, addition, and subtraction constructors:
data Exp1 = Num Int | Add Exp1 Exp1 | Sub Exp1 Exp1
The encoding in 𝐹𝜇
≤of this datatype can be defined as follows:
Exp1 ≜𝜇E. ∀A. {num : Int →A, add : E →E →A, sub : E →E →A} →A
If we unfold the recursive type, this encoding is a polymorphic higher order function that takes a
record with three fields (num, add and sub) as input. Each field corresponds to a constructor in the
datatype definition. This encoding is particularly useful for case analysis, since the polymorphic
function essentially encodes case analysis directly. To write a function that performs case analysis
on this datatype, one can unfold the recursive type, instantiate A with the result type, and then
provide a record that maps each case to its implementation function that takes the constructor
components as input and returns a result of type A. For example, given an expression e with type
Exp1, a case analysis-based evaluation function can be written as:
function eval (e : Exp1) = (unfold [Exp1] e) [Int]
{ num = 𝜆n. n, add = 𝜆e1 e2. (eval e1 + eval e2), sub = 𝜆e1 e2. (eval e1 −eval e2) }
where we use [. . .] to represent type instantiation. Here Exp1 is instantiated with the evaluation
result type Int. A record of three functions is supplied to implement case analysis. The num field
implements a function that returns the integer n of the Num constructor directly, while the functions
in add and sub fields perform the evaluation process recursively. To construct concrete instances
of the datatype, each constructor also comes with a corresponding encoding in the calculus:
function Num1 (n: Int) = fold [Exp1] (Λ A. 𝜆e. (e.num n))
function Add1 (e1 : Exp1, e2 : Exp1) = fold [Exp1] (Λ A. 𝜆e. (e.add e1 e2))
function Sub1 (e1 : Exp1, e2 : Exp1) = fold [Exp1] (Λ A. 𝜆e. (e.sub e1 e2))
One can easily check, using rule typing-fold, that the result type of each constructor encoding
becomes Exp1 after a recursive type folding. Therefore, in this encoding, the use of construc-
tors and case analysis functions is natural: one can construct the expression 1 + 2 directly with
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:9
the encoded constructors as Add1 (Num1 1) (Num1 2), and get its evaluation result by calling
eval (Add1 (Num1 1) (Num1 2)).
Subtyping between datatypes. Now consider a larger datatype Exp2, which extends the Exp1
datatype with a new constructor Neg, for denoting negative numbers.
data Exp2 = Num Int | Add Exp2 Exp2 | Sub Exp2 Exp2 | Neg Exp2
This datatype is encoded in 𝐹𝜇
≤as:
Exp2 ≜𝜇E. ∀A. {num : Int →A, add : E →E →A, sub : E →E →A, neg : E →A} →A
The datatype Exp2 differs from Exp1 only in the new constructor. However, other constructors are
just the same. To reduce code duplication, polymorphism on datatype constructors is desirable.
Note that Exp2 has more constructors than Exp1, so it should be safe to coerce Exp1 expressions
into Exp2 expressions, i.e. Exp1 ≤Exp2. Therefore, we would like the constructor for Add to have
the following type, so that both Exp1 and Exp2 can use this constructor:
Add∀: ∀(E ≥Exp1). E →E →E
There are two problems here. Firstly, similarly to the issue that we have faced in the translate
function, we would like to use a type variable in the fold’s of the constructors. This way we can
make the constructors polymorphic. Secondly, as evidenced by the desired type for Add, we need
lower bounded quantification, but in 𝐹𝜇
≤(and 𝐹≤) we only have upper bounded quantification.
Polymorphic constructors with lower bounded quantification. For applications such as encodings
of algebraic datatypes, the dual form of bounded quantification (lower bounded quantification)
seems to be more useful. Thus we have an extended system, called 𝐹𝜇
≤≥, that also supports lower
bounded quantification. Polymorphic datatype constructors become typeable with the structural
folding rule. For example, we can encode the polymorphic Add constructor as:
function Add∀[E ≥Exp1] (e1 : E, e2 : E) = fold [E] (Λ A. 𝜆e. (e.add e1 e2))
Other polymorphic constructors such as Num∀and Sub∀can be encoded similarly, enabling more
useful programming patterns. For example, if we want to implement a compiler that uses Exp1 as
its core language, but also want to support richer datatype constructors in a source language like
Exp2 does, we would like to be able to reduce code duplication across the two similar languages.
For instance, if we define a pretty printer function for Exp2
function print (𝑒: Exp2) = (unfold [Exp2] 𝑒) [string] {
num = 𝜆n. ( int_to_string n), add = 𝜆e1 e2. ((print e1) ++ "+" ++ ( print e2)),
sub = 𝜆e1 e2. ((print e1) ++ "−" ++ ( print e2)), neg = 𝜆e. ("−" ++ ( print e ))}
we can use this function to print Exp1 expressions as well: all the constructors in Exp1 are also
in Exp2 and have their pretty printing methods defined in the above function. With subtyping
between algebraic datatypes, it holds that Exp1 ≤Exp2, so it is safe in our encodings to apply this
print function to values of type Exp1, without another pretty printing function for Exp1.
Suppose also that we wish to implement a simple desugaring function that transforms Exp2 into
Exp1, by transforming negative numbers −𝑛into subtractions 0 −𝑛. This function should do case
analysis on Exp2 and use only the constructors in Exp1 to produce the result, i.e. it should have a
type Exp2 →Exp1. The following code, with polymorphic constructors, has the desired typing:
function desugar (𝑒: Exp2) = (unfold [Exp2] 𝑒) [Exp1] {
num = 𝜆n. Num∀[Exp1] n,
add = 𝜆e1 e2. Add∀[Exp1] (desugar e1) (desugar e2),
sub = 𝜆e1 e2. Sub∀[Exp1] (desugar e1) (desugar e2),
neg = 𝜆e. Sub∀[Exp1] (Num∀[Exp1] 0) (desugar e)}
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:10
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
In contrast, in many practical programming languages this task either involves code duplication
or loss of type precision. In a typical functional language, we can define both Exp1 and Exp2 and
also obtain precise static typing guarantees for the desugar function. But this comes at the cost of
duplication, since the constructors for the two datatypes are different, and many operations, such as
pretty printing need to be essentially duplicated. In 𝐹𝜇
≤≥, in addition to polymorphic constructors,
we would just need to define the pretty printer for Exp2, and that function would also work for Exp1.
Alternatively, one could define only Exp2 and type desugar with the imprecise type Exp2 →Exp2,
which does not statically guarantee that the Neg constructor has been removed. This solution avoids
the duplication at the cost of static typing guarantees. In 𝐹𝜇
≤≥we do not need such compromise:
we can avoid code duplication and preserve the static typing guarantees.
2.3
Key Ideas and Results
As Table 1 shows, no previous calculi with bounded quantification and recursive types are fully
satisfactory in all dimensions. Equi-recursive types are quite problematic, since they can change
the expressive power of the subtyping relation in unexpected ways. More importantly, adding equi-
recursive subtyping to 𝐹≤requires novel algorithms, and the extension is non-modular, requiring
several changes to existing definitions and proofs.
Kernel 𝐹≤with iso-recursive types. Our type system directly combines kernel 𝐹≤and the nominal
unfolding rules together. The addition of the nominal unfolding rules has almost no effect in the
original proofs in kernel 𝐹≤. That is the proofs for important lemmas, such as transitivity, are nearly
the same as those in kernel 𝐹≤, except that we need a new case to deal with recursive types. Thus
proofs that have been very hard in the past, such as transitivity, are very simple in 𝐹𝜇
≤.
The more challenging aspect in the metatheory of 𝐹𝜇
≤lies in the unfolding lemma:
Γ ⊢𝜇𝛼. 𝐴≤𝜇𝛼. 𝐵
⇒
Γ ⊢[𝛼↦→𝜇𝛼. 𝐴] 𝐴≤[𝛼↦→𝜇𝛼. 𝐵] 𝐵
which reveals an important property for iso-recursive types: if two iso-recursive types are subtypes,
then their one-step unfoldings are also subtypes. To prove the unfolding lemma, a generalized
lemma is needed [Zhou et al. 2022]. In 𝐹𝜇
≤, we show that the previous generalized approach is
insufficient, due to bounded quantification. Therefore, a more general lemma is proposed.
Another challenge is decidability. Although both kernel 𝐹≤and the nominal unfolding rules
(for simple calculi) have been independently proved decidable, their decidability proofs use very
different measures. A natural combination is problematic, thus we need a new approach.
After overcoming those challenges, as Table 1 shows, 𝐹𝜇
≤performs well in various dimensions:
it is transitive, decidable, conservative and modular. Furthermore, there is a simple, sound and
complete algorithmic type system to enable implementations, and to provide important help in the
proofs of results such as conservativity of typing.
Structural folding and unfolding rules. In our work, instead of standard rules for fold/unfold
expressions, we use structural rules:
typing-sunfold
Γ ⊢e : A
Γ ⊢A ≤𝜇𝛼. B
Γ ⊢unfold [A] e : [𝛼↦→A] B
typing-sfold
Γ ⊢e : [𝛼↦→B] A
Γ ⊢𝜇𝛼. A ≤B
Γ ⊢fold [B] e : B
The key point about the structural rules is that the annotations are generalized to be a subtype/super-
type of a recursive type, instead of exactly a recursive type. In particular, this generalization enables
annotating fold/unfold with a bounded type variable, which is a subtype/supertype of a recursive
type. This is forbidden in the traditional rules. In the rule typing-sunfold, it is worthwhile to
mention that when we have 𝐴≤𝜇𝛼. 𝐵where 𝛼appears negatively in 𝐵, then there are very limited
choices to what 𝐴can be. Essentially it can be 𝜇𝛼. 𝐵itself and little else. In other words, negative
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:11
recursive types have very restricted subtyping, which is why the structural unfolding rule can
be type safe. Note also that, since the structural unfolding rules provide almost no flexibility for
negative recursive subtyping, they are insufficient to fully express f-bounded quantification for
negative recursive types.
The structural unfolding rule was presented by Abadi et al. [1996] for supporting structural
update in the object calculus that was being encoded into 𝐹≤with iso-recursive types. In their work,
the structural unfolding rule is presented with an informal explanation. We provide structural rules
for both expressions, together with the formalization of the type soundness for both rules. With the
structural unfolding rule we can, for instance, obtain the desired typing for the translate function.
P ≤Point, p : P ⊢p : P
P ≤Point, p : P ⊢P ≤Point
typing-sunfold
P ≤Point, p : P ⊢(unfold [P] p) :
 x : Int, y : Int,
move : Int →Int →P

. . .
⊢translate : ∀(P ≤Point). P →P
Readers can compare this derivation to the one in §2.2, where the conventional unfolding rule
and the subsumption rule are used instead. The use of rule typing-sunfold enables us to give a
more precise type for the translate function.
Lower bounded quantification and 𝐹𝜇
≤≥. We have also formalized an extension of 𝐹𝜇
≤with both
upper and lower bounded quantification, called 𝐹𝜇
≤≥. All the same results that are proved for 𝐹𝜇
≤are
also proved for 𝐹𝜇
≤≥, including transitivity, decidability and type soundness. The structural folding
rules become more useful in 𝐹𝜇
≤≥. With lower bounded quantification and the structural folding
rules we can get the correct typing for the polymorphic Add constructor:
· · ·
E ≥Exp1, e1 : E, e2 : E ⊢ΛA. 𝜆e.(e.add e1 e2) : ∀A.


num : Int →A,
add : E →E →A,
sub : E →E →A


→A
typing-sfold
E ≥Exp1, e1 : E, e2 : E ⊢fold [E] (ΛA. 𝜆e. (e.add e1 e2)) : E
. . .
⊢Add∀: ∀(E ≥Exp1). E →E →E
3
BOUNDED QUANTIFICATION WITH ISO-RECURSIVE TYPES
This section introduces a full calculus, called 𝐹𝜇
≤, with bounded quantification, records and recursive
types. 𝐹𝜇
≤is an extension of kernel 𝐹≤[Cardelli and Wegner 1985] with iso-recursive types.
3.1
Syntax and Well-Formedness
Syntax and Well-Formedness. The syntax of types and contexts for 𝐹𝜇
≤is shown below.
Types
𝐴, 𝐵, . . .
F
nat | ⊤| 𝐴1 →𝐴2 | 𝛼| 𝜇𝛼. 𝐴| 𝐴𝛼| ∀(𝛼≤𝐴). 𝐵| {𝑙𝑖: 𝐴𝑖𝑖∈1···𝑛}
Expressions
𝑒
F
𝑥| i | 𝑒1 𝑒2 | 𝜆𝑥: 𝐴. 𝑒| 𝑒𝐴| Λ(𝛼≤𝐴). 𝑒
| unfold [𝐴] 𝑒| fold [𝐴] 𝑒| {𝑙𝑖= 𝑒𝑖𝑖∈1···𝑛} | 𝑒.𝑙
Values
𝑣
F
i | 𝜆𝑥: 𝐴. 𝑒| fold [𝐴] 𝑣| Λ(𝛼≤𝐴). 𝑒| {𝑙𝑖= 𝑣𝑖𝑖∈1···𝑛}
Contexts
Γ
F
· | Γ, 𝛼≤𝐴| Γ,𝑥: 𝐴
Meta-variables 𝐴, 𝐵,𝐶, 𝐷range over types. Types consist of: natural numbers (nat), the top type (⊤),
function types (𝐴→𝐵), type variables (𝛼), recursive types (𝜇𝛼. 𝐴), labelled types (𝐴𝛼), universal
types (∀(𝛼≤𝐴). 𝐵), and record types ({𝑙𝑖: 𝐴𝑖𝑖∈1···𝑛}). Labelled types are types that are annotated
with a label. They enable distinguishing between otherwise structurally compatible types (equal
types or subtypes). That is if the two types being compared have different labels or one of the types
is unlabelled, then the two types will not be related, even when (ignoring the labels) they would be
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:12
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
Γ ⊢𝐴
(Well-formed Type)
wft-nat
Γ ⊢nat
wft-Top
Γ ⊢⊤
wft-var
𝛼≤A ∈Γ
Γ ⊢𝛼
wft-all
Γ ⊢A
Γ, 𝛼≤A ⊢B
Γ ⊢∀(𝛼≤A). B
wft-arrow
Γ ⊢A1
Γ ⊢A2
Γ ⊢A1 →A2
wft-rec
Γ, 𝛼≤⊤⊢A
Γ ⊢𝜇𝛼. A
wft-label
Γ ⊢A
Γ ⊢A𝛼
wft-rcd
Γ ⊢A𝑖
for each 𝑖
Γ ⊢{𝑙𝑖: A𝑖𝑖∈1···𝑛}
Γ ⊢𝐴≤𝐵
(Subtyping)
S-nat
⊢Γ
Γ ⊢nat ≤nat
S-top
⊢Γ
Γ ⊢A
Γ ⊢A ≤⊤
S-var
⊢Γ
Γ ⊢𝛼
Γ ⊢𝛼≤𝛼
S-arrow
Γ ⊢B1 ≤A1
Γ ⊢A2 ≤B2
Γ ⊢A1 →A2 ≤B1 →B2
S-rec
Γ, 𝛼≤⊤⊢[𝛼↦→A𝛼] A ≤[𝛼↦→B𝛼] B
Γ ⊢𝜇𝛼. A ≤𝜇𝛼. B
S-vartrans
𝛼≤B ∈Γ
Γ ⊢B ≤A
Γ ⊢𝛼≤A
S-eqivall
Γ ⊢A1 ≤A2
Γ ⊢A2 ≤A1
Γ, 𝛼≤A2 ⊢B ≤C
Γ ⊢∀(𝛼≤A1). B ≤∀(𝛼≤A2). C
S-label
Γ ⊢A ≤B
Γ ⊢A𝛼≤B𝛼
S-rcd
⊢Γ
Γ ⊢{𝑘𝑗: A𝑗𝑗∈1···𝑚}
{𝑙𝑖𝑖∈1···𝑛} ⊆{𝑘𝑗𝑗∈1···𝑚}
𝑘𝑗= 𝑙𝑖implies Γ ⊢A𝑗≤B𝑖
Γ ⊢{𝑘𝑗: A𝑗𝑗∈1···𝑚} ≤{𝑙𝑖: B𝑖𝑖∈1···𝑛}
Fig. 1. Well-formedness and subtyping rules.
structurally compatible types. They are used for dealing with subtyping of iso-recursive types as
part of the nominal unfolding approach. Expressions, denoted by meta-variable 𝑒, include: term
variables (𝑥), natural numbers (i), applications (𝑒1 𝑒2), abstractions (𝜆𝑥: 𝐴. 𝑒), type applications (𝑒𝐴),
type abstractions (Λ(𝛼≤𝐴). 𝑒), fold expressions (fold [𝐴] 𝑒), unfold expressions (unfold [𝐴] 𝑒),
records ({𝑙𝑖= 𝑒𝑖𝑖∈1···𝑛}) and record selection (𝑒.𝑙). Among them, natural numbers, abstractions and
type abstractions are values. Fold expressions and records can be values if their inner expressions
are also values. The context is used to store type variables with their bounds, and term variables with
their types. Note that it is unnecessary to distinguish recursive variables and universal variables.
The definition of a well-formed environment ⊢Γ is standard, ensuring that all variables in the
environment are distinct and all types in the environment are well-formed. A type is well-formed if
all of its free variables are in the context. The well-formedness rules for types are shown in Figure 1.
3.2
Subtyping
The bottom of Figure 1 shows the subtyping judgement. Our subtyping rules are mostly standard.
The rules essentially include the rules of the algorithmic version of kernel 𝐹≤[Cardelli et al. 1994;
Cardelli and Wegner 1985], but the rule for bounded quantification is generalized. The rules S-
var and S-vartrans are standard 𝐹≤rules. Note that since we do not distinguish universal and
recursive variables, those rules apply also to recursive type variables. The rule for function types
(rule S-arrow) is contravariant on the input types and covariant on the output types.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:13
Subtyping bounded quantification. The rule for bounded quantification is interesting, stating that
two universal types are subtypes if their bounds are equivalent (i.e. they are subtypes of each other)
and the bodies are subtypes. Note that rule S-eqivall is more general than rule S-kernelall
since the latter one requires the bounds are equal. The reason to have the more general rule using
equivalent bounds is that, for records, we wish to accept subtyping statements such as:
∀(𝛼≤{𝑥: nat,𝑦: nat}). 𝛼→𝛼≤∀(𝛼≤{𝑦: nat,𝑥: nat}). 𝛼→𝛼
where the bounds can be syntactically different, but equivalent types. In the presence of records
or other features (such as intersection and union types [Barbanera et al. 1995; Coppo et al. 1981;
Pottinger 1980]) we can have such equivalent, but not syntactically equal types. Therefore, we
should generalize the rule for bounded quantification do deal with those cases. This generalization
to equivalent bounds retains decidable subtyping just as kernel 𝐹≤as we shall see in §4.2.
Subtyping recursive types. For dealing with iso-recursive subtyping we employ the recent nominal
unfolding rules [Zhou et al. 2022], which have equivalent expressive power to the well-known
(iso-recursive) Amber rules [Cardelli 1985]. The nominal unfolding rules have been discussed in
§2.1. The reason to choose the nominal unfolding rules is that they enable us to prove important
metatheoretical results, such as transitivity and develop an algorithmic formulation of subtyping.
We extend the rule S-nominal to the rule S-rec in 𝐹𝜇
≤, by bounding recursive variables with
⊤when they are introduced into the context. Therefore, recursive variables are also treated as
universal variables, and we do not need to adjust the form of contexts in 𝐹≤for 𝐹𝜇
≤. Apart from
this, no other changes are necessary, making the addition of recursive types mostly non-invasive.
Consequently, the proofs of narrowing, reflexivity and transitivity are the same as the original one
for 𝐹≤, except for the new cases dealing with recursive types and minor adjustments to the rule of
bounded quantification due to the generalization to equivalent bounds.
Lemma 3.1 (Narrowing). If Γ1 ⊢𝐶≤𝐶′ and Γ1, 𝛼≤𝐶′, Γ2 ⊢𝐴≤𝐵then Γ1, 𝛼≤𝐶, Γ2 ⊢𝐴≤𝐵.
Theorem 3.2 (Reflexivity). If ⊢Γ and Γ ⊢𝐴then Γ ⊢𝐴≤𝐴.
Theorem 3.3 (Transitivity). If Γ ⊢𝐴≤𝐵and Γ ⊢𝐵≤𝐶then Γ ⊢𝐴≤𝐶.
The unfolding lemma. Another important lemma is the unfolding lemma, which reveals that: if
two recursive types are subtypes, then their unfoldings are also subtypes. The unfolding lemma is
important for proving preservation in a system with iso-recursive subtyping. A key difficulty in
the formalization of 𝐹𝜇
≤is proving the unfolding lemma which, due to the presence of bounded
quantification, requires a different proof technique compared to the proofs by Zhou et al. [2022].
We discuss the proof of the unfolding lemma in §4.1.
Lemma 3.4 (Unfolding Lemma). If Γ ⊢𝜇𝛼. 𝐴≤𝜇𝛼. 𝐵then Γ ⊢[𝛼↦→𝜇𝛼. 𝐴] 𝐴≤[𝛼↦→𝜇𝛼. 𝐵] 𝐵.
3.3
Type Soundness
Figure 2 shows the typing rules and reduction rules. Most rules are standard except for the typing
rule for unfold and fold. For these two expressions we use structural rules instead (rule typing-
sunfold and rule typing-sfold), as we explained in §2.3.
Structural unfolding lemma. Since the typing rules that we adopt for fold/unfold expressions are
the structural rules, which generalize the conventional rules, we need a more general form for the
unfolding lemma. The generalization of the lemma is necessary for the type preservation proof
with the structural folding/unfolding rules. We call the new lemma the structural unfolding lemma:
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:14
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
Γ ⊢𝑒: 𝐴
(Typing)
typing-nat
⊢Γ
Γ ⊢i : nat
typing-var
⊢Γ
𝑥: 𝐴∈Γ
Γ ⊢x : A
typing-sub
Γ ⊢e : A
Γ ⊢A ≤B
Γ ⊢e : B
typing-abs
Γ, 𝑥: A1 ⊢e : A2
Γ ⊢𝜆x : A1. e : A1 →A2
typing-sfold
Γ ⊢e : [𝛼↦→B] A
Γ ⊢𝜇𝛼. A ≤B
Γ ⊢fold [B] e : B
typing-sunfold
Γ ⊢e : A
Γ ⊢A ≤𝜇𝛼. B
Γ ⊢unfold [A] e : [𝛼↦→A] B
typing-app
Γ ⊢e1 : A1 →A2
Γ ⊢e2 : A1
Γ ⊢e1 e2 : A2
typing-proj
Γ ⊢e : {𝑙𝑖: A𝑖𝑖∈1···𝑛}
Γ ⊢e.𝑙𝑖: A𝑖
typing-tabs
Γ, 𝛼≤A ⊢e : B
Γ ⊢Λ(𝛼≤A). e : ∀(𝛼≤A). B
typing-tapp
Γ ⊢e : ∀(𝛼≤B1). B2
Γ ⊢A ≤B1
Γ ⊢e A : [𝛼↦→A] B2
typing-rcd
for each 𝑖
Γ ⊢e𝑖: A𝑖
Γ ⊢{𝑙𝑖= e𝑖𝑖∈1···𝑛} : {𝑙𝑖: A𝑖𝑖∈1···𝑛}
𝑒1 ↩→𝑒2
(Reduction)
step-beta
(𝜆x : A. e1) v2 ↩→[𝑥↦→v2] e1
step-appl
e1 ↩→e′
1
e1 e2 ↩→e′
1 e2
step-appr
e2 ↩→e′
2
v1 e2 ↩→v1 e′
2
step-fld
unfold [A] (fold [B] v) ↩→v
step-unfold
e ↩→e′
unfold [A] e ↩→unfold [A] e′
step-fold
e ↩→e′
fold [A] e ↩→fold [A] e′
step-tapp
e1 ↩→e2
e1 A ↩→e2 A
step-tabs
(Λ(𝛼≤A). e) B ↩→[𝛼↦→B] e
step-proj
e ↩→e′
e.𝑙𝑗↩→e′.𝑙𝑗
step-projrcd
{𝑙𝑖= v𝑖𝑖∈1···𝑛}.𝑙𝑗↩→v𝑗
step-rcd
e𝑗↩→e′
𝑗
{𝑙𝑖= 𝑣𝑖𝑖∈1···𝑗−1, 𝑙𝑗= e𝑗, 𝑙𝑘= 𝑒𝑘𝑘∈𝑗+1···𝑛} ↩→{𝑙𝑖= 𝑣𝑖𝑖∈1···𝑗−1, 𝑙𝑗= e′
𝑗, 𝑙𝑘= 𝑒𝑘𝑘∈𝑗+1···𝑛}
Fig. 2. Typing and Reduction Rules
Lemma 3.5 (Structural unfolding lemma). If Γ ⊢𝜇𝛼. 𝐴≤𝜇𝛼. 𝐶≤𝜇𝛼. 𝐷≤𝜇𝛼. 𝐵then Γ ⊢[𝛼↦→
𝜇𝛼. 𝐶] 𝐴≤[𝛼↦→𝜇𝛼. 𝐷] 𝐵.
In this lemma, in the one-step unfolding the recursive types substituted in the bodies are, respec-
tively, a supertype and a subtype of 𝜇𝛼. 𝐴and 𝜇𝛼. 𝐵. In contrast, in the unfolding lemma proposed
by Zhou et al., the recursive types that get substituted in the bodies are the same. As §4.1 will
discuss, both forms of the unfolding lemma can be proved using a more general lemma.
Type Soundness. To see how the structural unfolding lemma is used in the proof of type preserva-
tion, let us consider an expression unfold[𝐷′](fold[𝐶′] 𝑒). Starting from a closed expression, both
𝐶′ and 𝐷′ must be recursive types, thus we assume that 𝐶′ is 𝜇𝛼. 𝐶and 𝐷′ is 𝜇𝛼. 𝐷,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:15
Γ ⊢𝐴⇑𝐵
(Upper Exposure)
XA-promote
𝛼≤A ∈Γ
Γ ⊢A ⇑B
Γ ⊢𝛼⇑B
XA-up
A is not type variable
Γ ⊢A ⇑A
Γ ⊢𝐴⇓𝐵
(Lower Exposure)
XA-top
Γ ⊢⊤⇓𝜇𝛼. ⊤
XA-down
A is not type variable or ⊤
Γ ⊢A ⇓A
Γ ⊢𝑎𝑒: 𝐴
(Algorithmic Typing)
atyp-app
Γ ⊢a e1 : A
Γ ⊢A ⇑A1 →A2
Γ ⊢a e2 : B
Γ ⊢B ≤A1
Γ ⊢a e1 e2 : A2
atyp-tapp
Γ ⊢a e : B
Γ ⊢B ⇑∀(𝛼≤B1). B2
Γ ⊢A ≤B1
Γ ⊢a e A : [𝛼↦→A] B2
atyp-sunfold
Γ ⊢a e : A
Γ ⊢B ⇑𝜇𝛼. C
Γ ⊢A ≤B
Γ ⊢a unfold [B] e : [𝛼↦→B] C
atyp-sfold
Γ ⊢a e : A
Γ ⊢C ⇓𝜇𝛼. B
Γ ⊢A ≤[𝛼↦→C] B
Γ ⊢C
Γ ⊢a fold [C] e : C
Fig. 3. Algorithmic Typing.
Γ ⊢𝑒: [𝛼↦→𝐶′] 𝐴
Γ ⊢𝜇𝛼. 𝐴≤𝐶′
typing-sfold
Γ ⊢fold[𝐶′] 𝑒: 𝐶′
Γ ⊢𝐶′ ≤𝐷′
typing-sub
Γ ⊢fold[𝐶′] 𝑒: 𝐷′
Γ ⊢𝐷′ ≤𝜇𝛼. 𝐵
typing-sunfold
Γ ⊢unfold[𝐷′](fold[𝐶′] 𝑒) : [𝛼↦→𝐷′] 𝐵
The type of unfold[𝐷′](fold[𝐶′] 𝑒) becomes [𝛼↦→𝜇𝛼. 𝐷] 𝐵, and it should be a subtype of
[𝛼↦→𝜇𝛼. 𝐶] 𝐴, which is the type of reduction result 𝑒.
The other parts of the type soundness proof are standard, thus we have:
Theorem 3.6 (Preservation). If ⊢𝑒: 𝐴and 𝑒↩→𝑒′ then ⊢𝑒′ : 𝐴.
Theorem 3.7 (Progress). If ⊢𝑒: 𝐴then 𝑒is a value or exists 𝑒′,𝑒↩→𝑒′.
3.4
Algorithmic typing
The rules that we have presented in Figure 2 are declarative. The conclusion of the subsumption
rule overlaps with all other rules, making it non-trivial to derive an implementation from the rules.
Figure 3 shows the algorithmic rules for typing. We only present new rules and rules that differ
from Figure 2. Compared with the declarative typing rules, the subsumption rule (typing-sub)
is removed. Besides, application (typing-app), type application (typing-tapp), structural folding
(typing-sfold) and structural unfolding (typing-sunfold) rules are replaced by rules atyp-app,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:16
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
atyp-tapp, atyp-sfold and atyp-sunfold, respectively. In the algorithmic typing rules we take
the standard approach of distributing subtyping checks in appropriate places in the other rules,
thus eliminating the need for the subsumption rule.
One interesting point is the two exposure relations ⇑and ⇓in 𝐹𝜇
≤. In 𝐹≤, there is only the upper
exposure function (Γ ⊢𝐴⇑𝐵), which is used to find the least non-variable upper bound for a
variable in the context [Pierce 2002]. Thus the upper exposure function plays an important role
for finding the minimal type with the algorithmic typing rules. To make our rules more general,
we additionally define the lower exposure function (Γ ⊢𝐴⇓𝐵) to find the greatest non-variable
subtype 𝐵for 𝐴. For 𝐹𝜇
≤, lower exposure only helps to find the correct shape for the recursive type
body to be folded in rule atyp-sfold by mapping ⊤to 𝜇𝛼. ⊤. The lower exposure function will be
more useful when we have lower bounded variables in the system, as we will see in §5.
The algorithmic rules are equivalent (sound and complete) with respect to the declarative rules:
Theorem 3.8 (Soundness of the algorithmic rules). If Γ ⊢𝑎𝑒: 𝐴then Γ ⊢𝑒: 𝐴.
Theorem 3.9 (Completeness of the algorithmic rules). If Γ ⊢𝑒: 𝐴then there exists a 𝐵such that
Γ ⊢𝑎𝑒: 𝐵and Γ ⊢𝐵≤𝐴.
Theorem 3.9 implies that our algorithm can always find a minimal type, which is an important
property for 𝐹𝜇
≤.
4
METATHEORY OF 𝐹𝜇
≤
In this section we discuss the most interesting and difficult aspects of the metatheory of 𝐹𝜇
≤in
more detail. We cover three key properties: the unfolding lemma, decidability of subtyping and the
conservativity of 𝐹𝜇
≤over the original 𝐹≤. The interaction between iso-recursive types and bounded
quantification requires significant changes in the proofs of the unfolding lemma and decidability.
In addition, conservativity cannot be proved using a declarative formulation of 𝐹𝜇
≤, and we need to
employ the algorithmic formulation instead.
4.1
Unfolding Lemma
The unfolding lemma (Lemma 3.4) is a core lemma for the metatheory of a calculus with iso-
recursive subtyping. Though the statement of the unfolding lemma is quite simple and intuitive to
understand, the lemma cannot be proved directly. We will firstly review the previous approach to
prove the unfolding lemma, which does not account for bounded quantification, and then show
how to transfer this approach to a system with bounded quantification.
The previous approach for proving the unfolding lemma. Because the premise of the unfolding
lemma is a subtyping relation between two recursive types 𝜇𝛼. 𝐴≤𝜇𝛼. 𝐵, a direct induction on
such subtyping relation is problematic. Thus, we need to prove a generalized lemma first. In Zhou
et al.’s work that lemma has the following form:
Lemma 4.1 (The generalized unfolding lemma in Zhou et al. [2022]). If Γ1, 𝛼, Γ2, ⊢𝐴≤𝐵and
Γ1 ⊢𝜇𝛼. 𝐶≤𝜇𝛼. 𝐷then
(1) Γ1, 𝛼, Γ2 ⊢[𝛼↦→𝐶𝛼] 𝐴≤[𝛼↦→𝐷𝛼] 𝐵implies Γ1, Γ2 ⊢[𝛼↦→𝜇𝛼. 𝐶] 𝐴≤[𝛼↦→𝜇𝛼. 𝐷] 𝐵;
(2) Γ1, 𝛼, Γ2 ⊢[𝛼↦→𝐷𝛼] 𝐴≤[𝛼↦→𝐶𝛼] 𝐵implies Γ1, Γ2 ⊢[𝛼↦→𝜇𝛼. 𝐷] 𝐴≤[𝛼↦→𝜇𝛼. 𝐶] 𝐵.
Due to the tricky interaction between rule S-var and rule S-arrow, in the generalized unfolding
lemma we need two mutual dependent lemmas: one is used for covariant cases (1) and the other one
is used for contravariant cases (2). The proof for this lemma proceeds by induction on Γ1, 𝛼, Γ2, ⊢𝐴≤
𝐵. In the inductive proof we need to switch between covariance and contravariance. In particular, in
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:17
the rule S-arrow case for functions, we need an induction hypothesis that arises from conclusion
(2) to prove the contravariant premise Γ ⊢𝐵1 ≤𝐴1 relating the input types of the function.
For the generalized unfolding lemma in 𝐹𝜇
≤, Lemma 4.1 is unfortunately not general enough.
In a setting with bounded quantification, Γ2 may contain bounds with the type variable 𝛼, and
those variables are not being substituted in Lemma 4.1. Let us consider the effect of adding rule S-
vartrans. In the conclusion of Lemma 4.1, the variable 𝛼is substituted by another type and tracked
in the context Γ2. In the premises of rule S-vartrans, we need to find the upper bound of variable 𝛼
in the contexts Γ1 and Γ2. With those two observations, in our new attempt, the context also needs
to do substitutions. Thus, a natural attempt to solve this problem is to reformulate the lemma into
the following form (for the covariant case (1)):
Proposition 4.2 (A first attempt at the generalized unfolding lemma). If Γ1, 𝛼≤⊤, Γ2 ⊢𝐴≤𝐵
and Γ1 ⊢𝜇𝛼. 𝐶≤𝜇𝛼. 𝐷then Γ1, 𝛼≤⊤, Γ2[𝛼↦→?𝛼] ⊢[𝛼↦→𝐶𝛼] 𝐴≤[𝛼↦→𝐷𝛼] 𝐵implies
Γ1, Γ2[𝛼↦→𝜇𝛼. ?] ⊢[𝛼↦→𝜇𝛼. 𝐶] 𝐴≤[𝛼↦→𝜇𝛼. 𝐷] 𝐵.
Here, the syntax Γ[𝛼↦→𝑆] denotes that all the occurrences of 𝛼in context Γ will be replaced
by a specified type 𝑆. However, we do not know yet what type should be filled in the hole ? in
Proposition 4.2, so we leave the hole there for now. Although we omit conclusion (2) in Proposition
4.2, similar reasoning applies to that conclusion.
Let us now consider the effect of adding the rule S-eqivall: Assume that 𝐴:= ∀(𝛽≤𝑈1). 𝑇1
and 𝐵:= ∀(𝛽≤𝑈2). 𝑇2. The goal would look like:
Γ1, Γ2[𝛼↦→𝜇𝛼. ?] ⊢[𝛼↦→𝜇𝛼. 𝐶] ∀(𝛽≤𝑈1). 𝑇1 ≤[𝛼↦→𝜇𝛼. 𝐷] ∀(𝛽≤𝑈2). 𝑇2
After simplification and applying rule S-eqivall, one of the goals becomes:
Γ1, Γ2[𝛼↦→𝜇𝛼. ?], 𝛽≤[𝛼↦→𝜇𝛼. 𝐷] 𝑈2 ⊢[𝛼↦→𝜇𝛼. 𝐶] 𝑇1 ≤[𝛼↦→𝜇𝛼. 𝐷] 𝑇2
From the above, we would expect that the hole ? is filled with 𝐷because all the substitutions in the
context must be the same in order to apply induction hypothesis. Thus, a second attempt at the
generalized unfolding lemma looks like:
Proposition 4.3 (The second attempt at the generalized unfolding lemma (1)). If Γ1, 𝛼≤⊤, Γ2 ⊢𝐴≤𝐵
and Γ1 ⊢𝜇𝛼. 𝐶≤𝜇𝛼. 𝐷then Γ1, 𝛼≤⊤, Γ2[𝛼↦→𝐷𝛼] ⊢[𝛼↦→𝐶𝛼] 𝐴≤[𝛼↦→𝐷𝛼] 𝐵implies
Γ1, Γ2[𝛼↦→𝜇𝛼. 𝐷] ⊢[𝛼↦→𝜇𝛼. 𝐶] 𝐴≤[𝛼↦→𝜇𝛼. 𝐷] 𝐵.
Proposition 4.3 deals with rule S-vartrans and S-eqivall successfully. However, the function
case, which is correctly proven in Lemma 4.1, will break. Consider 𝐴:= 𝐴1 →𝐴2 and 𝐵:= 𝐵1 →𝐵2,
and apply rule S-arrow. We need to prove two subgoals:
(1) Γ1, Γ2[𝛼↦→𝜇𝛼. 𝐷] ⊢[𝛼↦→𝜇𝛼. 𝐶] 𝐴2 ≤[𝛼↦→𝜇𝛼. 𝐷] 𝐵2;
(2) Γ1, Γ2[𝛼↦→𝜇𝛼. 𝐷] ⊢[𝛼↦→𝜇𝛼. 𝐷] 𝐵1 ≤[𝛼↦→𝜇𝛼. 𝐶] 𝐴1.
Note that we do not have any induction hypothesis for proving subgoal (2) because occurrences of
𝛼in Γ2 have been substituted by 𝜇𝛼. 𝐷, but we expect the 𝛼’s to have been replaced by 𝜇𝛼. 𝐶for
applying the induction hypothesis. Even if we add the second conclusion back to the Proposition
4.3, we still have problems. For conclusion (2), the type used for the substitution in the context
should be same as the type used for the substitution in the right-hand side of the subtyping. If we
fill the hole ? with 𝐶in Proposition 4.2, the subgoal (1) in case S-arrow will get stuck for a similar
reason. Therefore, the type in the hole ? cannot be the type 𝐶or 𝐷.
In summary, in the previous approach by Zhou et al., without bounded quantification, only the
interaction of covariance/contravariance between types has to be considered. In contrast, with
bounded quantification, the interaction of covariance/contravariance among contexts and types
also needs to be considered. Our generalization should be able to deal with all the complications
arising from rule S-var, rule S-vartrans, rule S-arrow and rule S-eqivall.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:18
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
The generalized unfolding lemma for 𝐹𝜇
≤. Surprisingly, the generalization is relatively straightfor-
ward. For solving the issue that we mention above, instead of picking type 𝐶or type 𝐷, we pick an
intermediate type 𝑆between 𝐶and 𝐷. We need the following auxiliary lemma:
Lemma 4.4. If Γ, 𝛼≤⊤⊢[𝛼↦→𝐴𝛼] 𝐴≤[𝛼↦→𝐵𝛼] 𝐵then Γ, 𝛼≤⊤⊢𝐴≤𝐵.
The generalized unfolding lemma for 𝐹𝜇
≤is:
Lemma 4.5 (The generalized unfolding lemma for 𝐹𝜇
≤). If (1) Γ1, 𝛼≤⊤, Γ2 ⊢𝐴≤𝐵, (2) Γ1 ⊢𝜇𝛼. 𝐶≤
𝜇𝛼. 𝑆and (3) Γ1 ⊢𝜇𝛼. 𝑆≤𝜇𝛼. 𝐷then
(1) Γ1, 𝛼≤⊤, Γ2[𝛼↦→𝑆𝛼] ⊢[𝛼↦→𝐶𝛼] 𝐴≤[𝛼↦→𝐷𝛼] 𝐵implies Γ1, Γ2[𝛼↦→𝜇𝛼. 𝑆] ⊢[𝛼↦→
𝜇𝛼. 𝐶] 𝐴≤[𝛼↦→𝜇𝛼. 𝐷] 𝐵;
(2) Γ1, 𝛼≤⊤, Γ2[𝛼↦→𝑆𝛼] ⊢[𝛼↦→𝐷𝛼] 𝐴≤[𝛼↦→𝐶𝛼] 𝐵implies Γ1, Γ2[𝛼↦→𝜇𝛼. 𝑆] ⊢[𝛼↦→
𝜇𝛼. 𝐷] 𝐴≤[𝛼↦→𝜇𝛼. 𝐶] 𝐵.
By applying Lemma 4.5 with Γ1 = Γ, Γ2 = ·, 𝑆= 𝐴, 𝐶= 𝐴and 𝐷= 𝐵, we prove the unfolding
lemma (Lemma 3.4). The premises can be obtained by inversion on Γ ⊢𝜇𝛼. 𝐴≤𝜇𝛼. 𝐵, and then
applying Lemma 4.4. Next we give an overview of the key points in the proof of Lemma 4.5 for the
four tricky cases. Assume that we do induction on premise (1).
• Rule S-var: This case mostly follows the previous approach. The interesting point is that we
cannot obtain 𝜇𝛼. 𝐶≤𝜇𝛼. 𝐷directly from the conditions raised by the goals, but have one extra
step via transitivity (Theorem 3.3).
• Rule S-vartrans: For this case we need to consider two subcases. If 𝐴= 𝛼then from the context
𝛼≤⊤we can easily know that 𝐵is ⊤too. Otherwise, we apply the induction hypothesis directly.
• Rule S-arrow: This case is surprisingly easy: we can follow the previous approach for dealing
with the contravariant case for subtyping input types of functions, and apply the induction
hypothesis derived from conclusion (2) directly. Note that the key point of avoiding the issue we
discussed before is that, by picking an intermediate type 𝑆, we decouple the substitution in the
context and in the subtyping relation for the function case. That is, the substitution with type
𝜇𝛼. 𝑆is invariant in both subgoals, independent of the substitution in the subtyping relation.
• Rule S-eqivall: This case is the most interesting one. Assume 𝐴= ∀(𝛽≤𝑈1). 𝑇1 and 𝐵= ∀(𝛽≤
𝑈2). 𝑇2. Let us consider how to prove the goal (1). Doing inversion on condition arising from the
goal, we obtain that [𝛼↦→𝐶𝛼] 𝑈1 and [𝛼↦→𝐷𝛼] 𝑈2 are equivalent. Meanwhile, we know 𝑈1
and 𝑈2 that are equivalent. There are two possibilities: either 𝐶and 𝐷are equivalent or 𝛼is not
in type 𝑈1 nor 𝑈2. For the latter case, we can rewrite the substituted types in the contexts for
aligning the contexts, then solve the issue we discussed above. The former case is quite subtle:
since 𝑆lies in the middle of 𝐶and 𝐷, the three types are all equivalent. In other words, we can
change the substituted types arbitrarily and get the equivalent types and contexts. The critical
point is that, although the substitution in the context is indeed affected by the substitution in the
supertype, since the bounds are equivalent, the type 𝑆will converge into the types 𝐶and 𝐷.
As a final note, we cannot apply this technique to full 𝐹≤. In full 𝐹≤, in the context, the type 𝐶
and 𝐷will swap due to the contravariance. How to prove the unfolding lemma for full 𝐹≤is not
clear now, and we leave this as the future work.
4.2
Decidability
Decidability is one of the important properties of 𝐹𝜇
≤. We first start by reviewing the approaches
to prove decidability in kernel 𝐹≤, and nominal unfoldings, and then describe our approach to
prove decidability. These two previous approaches to prove decidability employ different measures,
which creates a challenge for proving the decidability of 𝐹𝜇
≤.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:19
Decidability of kernel 𝐹≤. It is well-known that bounded quantification for full 𝐹≤is undecidable
[Pierce 1994]. However, for kernel 𝐹≤, identical bounds make the system decidable. A common
practice is to define a weight function to compute the size of a type [Pierce 2002]:
𝑤𝑒𝑖𝑔ℎ𝑡Γ(⊤)
=
1
𝑤𝑒𝑖𝑔ℎ𝑡Γ1,𝛼≤𝐴,Γ2 (𝛼)
=
1 + 𝑤𝑒𝑖𝑔ℎ𝑡Γ1(𝐴)
𝑤𝑒𝑖𝑔ℎ𝑡Γ(∀(𝛼≤𝐴). 𝐵)
=
1 + 𝑤𝑒𝑖𝑔ℎ𝑡Γ,𝛼≤𝐴(𝐵)
𝑤𝑒𝑖𝑔ℎ𝑡Γ(𝐴→𝐵)
=
1 + 𝑤𝑒𝑖𝑔ℎ𝑡Γ(𝐴) + 𝑤𝑒𝑖𝑔ℎ𝑡Γ(𝐵)
For universal types, we store its bound into a context Γ, and when we meet the universal variable, we
retrieve its bound from the context and compute the size recursively. Since the size of a conclusion
is always greater than any premise, this measure can be used to show that the subtyping algorithm
in kernel 𝐹≤terminates for all inputs.
Decidability of nominal unfoldings. The nominal unfolding rule in simple calculi with subtyping
is also decidable [Zhou et al. 2022]. Compared with kernel 𝐹≤, the decidability proof of nominal
unfoldings is trickier. Based on the substitution of the type body, after every unfolding, the size
of types will increase. Thus a straightforward induction on the size of types does not work. Zhou
et al. choose a size measure based on an over-approximation of the height of the fully unfolded
tree. Concretely, they define a height function:
ℎ𝑒𝑖𝑔ℎ𝑡Ψ(⊤)
=
0
ℎ𝑒𝑖𝑔ℎ𝑡Ψ(𝛼)
=
Ψ(𝛼) if 𝛼∈Ψ else 0
ℎ𝑒𝑖𝑔ℎ𝑡Ψ(𝐴→𝐵)
=
1 + max(ℎ𝑒𝑖𝑔ℎ𝑡Ψ(𝐴),ℎ𝑒𝑖𝑔ℎ𝑡Ψ(𝐵))
ℎ𝑒𝑖𝑔ℎ𝑡Ψ(𝜇𝛼. 𝐴)
=
1 + let 𝑖= ℎ𝑒𝑖𝑔ℎ𝑡Ψ,𝛼↦→0(𝐴) in ℎ𝑒𝑖𝑔ℎ𝑡Ψ,𝛼↦→𝑖+1(𝐴)
The size measure of a type 𝐴is defined as ℎ𝑒𝑖𝑔ℎ𝑡(𝐴) where the context is empty. In contrast to
kernel 𝐹≤, the context here is used to store the size of the corresponding recursive variables. Zhou
et al. proved that such height measure will precisely decrease by one for every nominal unfolding.
Decidability of 𝐹𝜇
≤. Now consider how to combine these two approaches together. We wish to
extend the measure of nominal unfoldings with the measure of kernel 𝐹≤non-invasively. The
easiest thing to do is to switch the maximum function to addition for the function case in the
measure of nominal unfoldings, which simply widens the over-approximation. Then we consider
the major differences between the two approaches. There are three main challenges:
• The measures for variables are inconsistent in the two approaches: In the height function,
the type variable case is a base case, while in the weight function we will continue the computation
for a variable by getting its bound from the contexts. In 𝐹𝜇
≤, a recursive variable is regarded as a
universal variable, so the new formulation should reflect those two distinct situations.
• The purposes of contexts are inconsistent in two approaches: The context of the height
function is used to store the pre-computed size of the recursive type body so that measures of
recursive variables are counted in their nominal unfolded form. The context of the weight function
is a straightforward bookkeeping of universal bounds. In later computation, these bounds will be
retrieved and their measure will be computed to serve as the measure of a universal variable.
This is to ensure that the premises in rule S-vartrans have a smaller measure of types than the
conclusion does. We need to treat both designs carefully if we want a unified context.
• The measure information is lost in the bounded quantification case: Recall that we employ
the rule S-eqivall instead of the standard rule S-kernelall for 𝐹≤. Since we impose equivalent
bounds for kernel 𝐹≤, for the subtyping relation Γ ⊢∀(𝛼≤𝐴1). 𝐵1 ≤∀(𝛼≤𝐴2). 𝐵2, the measure
would consist of the measures of type 𝐴1, 𝐴2, 𝐵1 and 𝐵2. However, the measure for the premise
Γ, 𝛼≤𝐴2 ⊢𝐵1 ≤𝐵2 will lose the measure of type 𝐴1 because we do not store it.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:20
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
We first show the measure used for the decidability of 𝐹𝜇
≤, and then discuss how it addresses
the concerns above. The measure is relatively simple and based on the approach from Zhou et al.
[2022]. Similarly, we define a context Ψ := · | Ψ, 𝛼↦→𝑖which is used to store the measures of (both
universal and recursive) variables during the measure computation, where 𝑖represents a natural
number. Then, a measure function 𝑠𝑖𝑧𝑒Ψ(𝐴), defined on types, is:
𝑠𝑖𝑧𝑒Ψ(nat)
=
1
𝑠𝑖𝑧𝑒Ψ(⊤)
=
1
𝑠𝑖𝑧𝑒Ψ(𝐴→𝐵)
=
1 + 𝑠𝑖𝑧𝑒Ψ(𝐴) + 𝑠𝑖𝑧𝑒Ψ(𝐵)
𝑠𝑖𝑧𝑒Ψ(𝐴𝛼)
=
1 + 𝑠𝑖𝑧𝑒Ψ(𝐴)
𝑠𝑖𝑧𝑒Ψ(𝛼)
=
1 +
(
Ψ(𝛼)
𝛼∈Ψ
0
𝛼∉Ψ
𝑠𝑖𝑧𝑒Ψ(∀(𝛼≤𝐴). 𝐵)
=
let 𝑖:= 𝑠𝑖𝑧𝑒Ψ(𝐴) in 1 + 𝑖+ 𝑠𝑖𝑧𝑒Ψ,𝛼↦→𝑖(𝐵)
𝑠𝑖𝑧𝑒Ψ(𝜇𝛼. 𝐴)
=
let 𝑖:= 𝑠𝑖𝑧𝑒Ψ,𝛼↦→1(𝐴) in 1 + 𝑠𝑖𝑧𝑒Ψ,𝛼↦→𝑖(𝐴)
The formulation of the size function is very similar to the height function. We have an extra rule for
universal types, and slightly adjust the variable and recursive cases. The measure of universal types
is the sum of the measure of the bound and the measure of the body. For variables, one is added
when they are retrieved. Accordingly, we do not need to add one when storing the size of recursive
variables into the context. For atomic constructs, we follow the weight function and measure them
as 1.
We solve the first challenge in a straightforward way: there is no need to distinguish between
recursive and universal variables. The fact that all recursive variables in the context are bounded
by a top type whose measure is simply one fits our needs naturally.
As for the second concern, despite the different purposes of contexts, the key ideas of measuring
types in kernel 𝐹≤and nominal unfoldings are the same: they both relate the measure of a variable
to its true meaning, either its unfolded form or its bound size. A slight modification is made
based on the definition of weight. In the weight function, for a universal variable, its bound is first
retrieved and then the measure is computed. To align with the “pre-computation” mechanism of
measuring nominal unfoldings (𝑖:= 𝑠𝑖𝑧𝑒Ψ,𝛼↦→1(𝐴)), we also pre-compute the measure of the bound
(𝑖:= 𝑠𝑖𝑧𝑒Ψ(𝐴)) in the size function, so that we retrieve the measure instead of the type bound from
the context. In a well-formed type, variables are guaranteed to be unique, so we can use a single
context Ψ to store the measures for both recursive variables and universal variables.
A subtler issue lies on variables in the initial subtyping context. When measuring nominal
unfoldings, the context in a subtyping relation is simply a list of variables, without any bound
information, so variables that occur freely can be counted as 0. In contrast, now the subtyping
context stores the bound information, and the measures of bounds play a role in deciding the
subtyping relation. To address this issue, we need to make sure that the bound information is
pre-computed in the measure function. We transform a subtyping context into an environment
containing measures Ψ, which tracks universal variables. In our decidability proof statement
(Lemma 4.6), Ψ is computed from the subtyping context Γ by an evaluation function 𝑒𝑣𝑎𝑙: Γ ↩→Ψ,
defined as:
𝑒𝑣𝑎𝑙(·)
=
·
𝑒𝑣𝑎𝑙(Γ′, 𝑥: 𝐴)
=
𝑒𝑣𝑎𝑙(Γ′)
𝑒𝑣𝑎𝑙(Γ′, 𝛼≤𝐴)
=
let Ψ′ = 𝑒𝑣𝑎𝑙(Γ′) in Ψ′, 𝛼↦→𝑠𝑖𝑧𝑒Ψ′(𝐴)
With both 𝑒𝑣𝑎𝑙and 𝑠𝑖𝑧𝑒we can then state the decidability theorem:
Lemma 4.6. If 𝑠𝑖𝑧𝑒𝑒𝑣𝑎𝑙(Γ) (𝐴) + 𝑠𝑖𝑧𝑒𝑒𝑣𝑎𝑙(Γ) (𝐵) ≤𝑘then Γ ⊢𝐴≤𝐵is either true or not.
Theorem 4.7 (Decidability). Γ ⊢𝐴≤𝐵is decidable.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:21
As for the third concern, note that in 𝐹≤, the subtyping relation is antisymmetric [Baldan et al.
1999]. Adding recursive types does not change the property of antisymmetry. However, the addition
of records makes the subtyping relation not antisymmetric: two record types may be syntactically
different. The lack of antisymmetry poses a challenge for our decidability proof, in particular for
rule S-eqivall. However, the fields of two equivalent records must be a permutation of each other.
Therefore, the measures of two equivalent record types are the same. As a result, the measure of
two equivalent bounds 𝐴1 and 𝐴2 is equal, as Lemma 4.8 describes. The measure information of
type 𝐴1 can therefore be reconstructed from type 𝐴2, addressing the final concern with decidability.
Lemma 4.8. If Γ ⊢𝐴≤𝐵and Γ ⊢𝐵≤𝐴then 𝑠𝑖𝑧𝑒𝑒𝑣𝑎𝑙(Γ) (𝐴) = 𝑠𝑖𝑧𝑒𝑒𝑣𝑎𝑙(Γ) (𝐵).
4.3
Conservativity
One important feature of 𝐹𝜇
≤is that it is conservative over kernel 𝐹≤. Conservativity means that
equivalent 𝐹≤judgments in 𝐹𝜇
≤should behave in the same way as in 𝐹≤. For instance, if a subtyping
statement is valid in 𝐹≤, then it should also be valid in 𝐹𝜇
≤. Dually, if a subtyping statement over
𝐹≤-types is invalid in 𝐹≤, then it should also be invalid in 𝐹𝜇
≤. In some calculi, including extensions of
𝐹≤with equi-recursive types [Ghelli 1993], conservativity is lost after the addition of new features.
For avoiding ambiguity, let ⊢𝐹Γ, Γ ⊢𝐹𝐴, Γ ⊢𝐹𝐴≤𝐵, ⊢𝐹𝑒and Γ ⊢𝐹𝑒: 𝐴represent the well-
formedness of environment, well-formedness of types, subtyping, well-formedness of expressions
and the typing relation, respectively, in kernel 𝐹≤. Note that all these judgments are essentially
subsets of the judgments introduced in §3, except that the rules involving records and recursive
types are removed, and that the rule S-eqivall is replaced with the rule S-kernelall.
Conservativity of subtyping. Our conservativity result for subtyping is relatively easy to establish:
Lemma 4.9 (Conservativity for subtyping). If ⊢𝐹Γ, Γ ⊢𝐹𝐴, and Γ ⊢𝐹𝐵then Γ ⊢𝐹𝐴≤𝐵if and only
if Γ ⊢𝐴≤𝐵.
Here the well-formedness conditions ensure that Γ, 𝐴and 𝐵must be respectively a valid 𝐹≤
environment, and valid 𝐹≤types. That is they cannot contain recursive types (or record types).
Therefore, the lemma states that for environments and types without recursive types, the two
subtyping relations (for 𝐹≤and 𝐹𝜇
≤) are equivalent, accepting the same statements. The only hurdle
is that to establish the correspondence between rule S-eqivall and the rule S-kernelall in
kernel 𝐹≤, we need the antisymmetry property for kernel 𝐹≤[Baldan et al. 1999].
Conservativity of typing. It is straightforward to obtain part of the conservativity result from
a typing relation in 𝐹≤to a typing relation in 𝐹𝜇
≤. As for the reverse direction, the situation is
more complicated. If we want to derive Γ ⊢𝐹𝑒: 𝐴from Γ ⊢𝑒: 𝐴, when doing induction, for the
subsumption case (rule typing-sub), we need to guess an intermediate type. However, we do not
know if it involves recursive types or not. Consider the following example:
⊢𝜆𝑥. 𝑥: ⊤→⊤
⊢⊤→⊤≤(𝜇𝛼. ⊤) →⊤
typing-sub
⊢𝜆𝑥. 𝑥: (𝜇𝛼. ⊤) →⊤
⊢(𝜇𝛼. ⊤) →⊤≤⊤
typing-sub
⊢𝜆𝑥. 𝑥: ⊤
Although ⊢𝜆𝑥. 𝑥: ⊤do not involve recursive types, the typing subderivations can contain recursive
types. As a result, the induction hypothesis cannot be applied.
This problem can be addressed by employing the algorithmic formulation of 𝐹𝜇
≤, shown in §3.4.
With algorithmic typing, we can have more precise information about the types of an expression,
since algorithmic typing always gives the minimum type. Therefore, it can be proved that for
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:22
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
expressions that do not use fold/unfold constructors, their minimum types do not contain recursive
types as well. Conservativity for algorithmic typing is proved as follows:
Lemma 4.10. If ⊢𝐹Γ, Γ ⊢𝐹𝐴and ⊢𝐹𝑒then Γ ⊢𝑎𝑒: 𝐴implies Γ ⊢𝐹𝑒: 𝐴.
Now, given a typing relation Γ ⊢𝑒: 𝐴in 𝐹𝜇
≤, we first use the minimum typing property (Theorem
3.9) to obtain its minimum type 𝐵such that Γ ⊢𝑎𝑒: 𝐵and Γ ⊢𝐵≤𝐴. Applying Lemma 4.10 and
Lemma 4.9, we complete the conservativity proof for the declarative version of 𝐹𝜇
≤.
Theorem 4.11 (Conservativity). If ⊢𝐹Γ, Γ ⊢𝐹𝐴and ⊢𝐹𝑒then Γ ⊢𝐹𝑒: 𝐴if and only if Γ ⊢𝑒: 𝐴.
5
A CALCULUS WITH LOWER AND UPPER BOUNDED QUANTIFICATION
In this section we introduce an extension of 𝐹𝜇
≤, called 𝐹𝜇
≤≥, with lower bounded quantification
and a bottom type. While upper bounded quantification has received a lot of attention in previous
research, lower bounded quantification for an 𝐹≤-like language is much less explored, though it
appears in a few works [Amin and Rompf 2017; Oliveira et al. 2020]. We follow the same approach
as Oliveira et al. [2020], where their 𝐹≤extension allows type variables to have either a lower
bound or an upper bound, but not both bounds at once. As discussed in §2.2, this extension enables
further applications, such as a form of extensible encodings of datatypes. We have proved all the
same results for 𝐹𝜇
≤≥that were proved for 𝐹𝜇
≤, including type soundness, decidability, transitivity
and conservativity over 𝐹≤.
5.1
The 𝐹𝜇
≤≥Calculus
The syntax of types, expressions, values and contexts for the extended 𝐹𝜇
≤≥calculus is shown below.
The main novelties are that bottom types and lower bounded quantification are introduced. The
syntactic additions are highlighted in gray .
Types
𝐴, 𝐵, . . .
F
nat | ⊤| ⊥| 𝐴1 →𝐴2 | 𝛼| 𝜇𝛼. 𝐴| 𝐴𝛼
| ∀(𝛼≤𝐴). 𝐵| ∀(𝛼≥𝐴). 𝐵| {𝑙𝑖: 𝐴𝑖𝑖∈1···𝑛}
Expressions
𝑒
F
𝑥| i | 𝑒1 𝑒2 | 𝜆𝑥: 𝐴. 𝑒| 𝑒𝐴| Λ(𝛼≤𝐴). 𝑒| Λ(𝛼≥𝐴). 𝑒
| unfold [𝐴] 𝑒| fold [𝐴] 𝑒| {𝑙𝑖= 𝑒𝑖𝑖∈1···𝑛} | 𝑒.𝑙
Values
𝑣
F
i | 𝜆𝑥: 𝐴. 𝑒| fold [𝐴] 𝑣| Λ(𝛼≤𝐴). 𝑒| Λ(𝛼≥𝐴). 𝑒
| {𝑙𝑖= 𝑣𝑖𝑖∈1···𝑛}
Contexts
Γ
F
· | Γ, 𝛼≤𝐴| Γ, 𝛼≥𝐴| Γ,𝑥: 𝐴
Subtyping, typing and reduction. Similarly to §3.1, the well-formedness for the additional bottom
types and universal types with lower bounds are standard. Figure 4 shows the additional rules of 𝐹𝜇
≤≥
with respect to 𝐹𝜇
≤for subtyping, typing and reduction. Compared with 𝐹𝜇
≤, we add rule S-bot, S-
vartranslb and S-eqivalllb, which are the dual forms of rule S-top, S-vartrans and S-eqivall,
respectively. The rule typing-tapplb and typing-tabslb are the dual forms of rule typing-tapp and
typing-tabs for typing, respectively. The rule step-tabslb rule is the dual form of rule step-tabs
for reduction.
The new subtyping relation is reflexive and transitive:
Theorem 5.1 (Reflexivity for 𝐹𝜇
≤≥). If ⊢Γ and Γ ⊢𝐴then Γ ⊢𝐴≤𝐴.
Theorem 5.2 (Transitivity for 𝐹𝜇
≤≥). If Γ ⊢𝐴≤𝐵and Γ ⊢𝐵≤𝐶then Γ ⊢𝐴≤𝐶.
Structural folding and lower bounded quantification. The structural folding rule typing-sfold
on recursive types has already been shown for 𝐹𝜇
≤. Note that this rule is not strictly necessary for
𝐹𝜇
≤, because a recursive type can only be a subtype of another recursive type or the ⊤type. Thus
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:23
Γ ⊢𝐴≤𝐵
(Subtyping)
S-bot
⊢Γ
Γ ⊢A
Γ ⊢⊥≤A
S-vartranslb
𝛼≥B ∈Γ
Γ ⊢A ≤B
Γ ⊢A ≤𝛼
S-eqivalllb
Γ ⊢A1 ≤A2
Γ ⊢A2 ≤A1
Γ, 𝛼≥A2 ⊢B ≤C
Γ ⊢∀(𝛼≥A1). B ≤∀(𝛼≥A2). C
Γ ⊢𝑒: 𝐴
(Typing)
typing-tapplb
Γ ⊢e : ∀(𝛼≥B1). B2
Γ ⊢B1 ≤A
Γ ⊢e A : [𝛼↦→A] B2
typing-tabslb
Γ, 𝛼≥A ⊢e : B
Γ ⊢Λ(𝛼≥A). e : ∀(𝛼≥A). B
𝑒1 ↩→𝑒2
(Reduction)
step-tabslb
(Λ(𝛼≥A). e) B ↩→[𝛼↦→B] e
Fig. 4. Additional subtyping, typing and reduction rules for 𝐹𝜇
≤≥with respect to 𝐹𝜇
≤.
the effect of structural folding in 𝐹𝜇
≤, can be subsumed by other subtyping/typing rules. Perhaps
for this reason, Abadi et al. [1996] have only considered a structural unfolding rule. However, in
𝐹𝜇
≤≥, a recursive type can also be a subtype of a type variable. In this case, the structural folding
rule can give the desired typings to the Add∀constructors of the Exp1 and Exp2 datatypes that we
have presented in §2.2, while the standard folding rule cannot. The rule typing-sfold has the same
form in 𝐹𝜇
≤≥as in 𝐹𝜇
≤. Therefore, we believe that the structural folding rule that we have proposed,
together with the structural unfolding lemma in the metatheory, is general.
Type soundness. Our type soundness proof for 𝐹𝜇
≤≥is standard, thus we have:
Theorem 5.3 (Preservation for 𝐹𝜇
≤≥). If ⊢𝑒: 𝐴and 𝑒↩→𝑒′ then ⊢𝑒′ : 𝐴.
Theorem 5.4 (Progress for 𝐹𝜇
≤≥). If ⊢𝑒: 𝐴then 𝑒is a value or exists 𝑒′,𝑒↩→𝑒′.
5.2
Metatheory of 𝐹𝜇
≤≥
The addition of lower bounded quantification and the bottom type creates some difficulties in the
metatheory of 𝐹𝜇
≤≥. The proof strategies for the unfolding lemma, decidability and conservativity,
as we showed in the §4 for 𝐹𝜇
≤, require some adjustments. In the following, we describe how to
overcome the difficulties. We refer readers to the extended version of the paper for more details.
Unfolding Lemma. A type system that simultaneously allows introducing lower and upper
bounded type variables will break the proof for the unfolding lemma shown in §4.1. The interaction
of lower bounds and upper bounds invalidates the following inversion lemma for rule S-vartrans,
which has been used to prove the unfolding lemma:
Lemma 5.5. If 𝛼≤𝐴∈Γ, Γ ⊢𝛼≤𝐵, and 𝛼≠𝐵then Γ ⊢𝐴≤𝐵.
This lemma holds when the bounds in the context can only have one direction. However, when
we have both kinds of bounds in the context, a counter-example can be found as follows:
𝑥≤⊤,𝑦≥𝑥⊢𝑥≤𝑦
=⇒
\
𝑥≤⊤,𝑦≥𝑥⊢⊤≤𝑦
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:24
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
For avoiding using this inversion lemma in the proof of unfolding lemma, we need to refine the
generalized unfolding lemma. In Lemma 4.5, there is more than one subtyping statement on the
premises related to type 𝐴and 𝐵, and we do induction on the premise (1). In the refined generalized
unfolding lemma, we integrate those subtyping statements into one statement, thus the premise (1)
can be induced implicitly. Meanwhile, the context is also refined to be more general. The concrete
generalized unfolding lemma for 𝐹𝜇
≤≥is shown in the extended version of the paper. With these
changes we prove:
Lemma 5.6 (Unfolding lemma for 𝐹𝜇
≤≥). If Γ ⊢𝜇𝛼. 𝐴≤𝜇𝛼. 𝐵then Γ ⊢[𝛼↦→𝜇𝛼. 𝐴] 𝐴≤[𝛼↦→
𝜇𝛼. 𝐵] 𝐵.
Decidability. The interaction between bottom types and rule S-eqivall breaks the measure-
based decidability proof in §4.2. The bottom type in 𝐹𝜇
≤brings a new form of equivalent types:
when 𝛼≤⊥∈Γ, one can derive that Γ ⊢𝛼≤⊥and Γ ⊢⊥≤𝛼, as observed by Pierce [1997].
Simply extending the measure function with 𝑠𝑖𝑧𝑒Ψ(⊥) = 1 will not work. For type variables, the
measure function will recursively look up its bound in the context, and add one to the measure of
its bound, making a variable equivalent to ⊥to have a larger measure than ⊥. Therefore, replacing
two equivalent types into the abstracted type body may not produce the same measures. We can
construct derivations of rule S-eqivall that have a larger measure in the premise than that of the
conclusion, which makes the decidability proof fail with the current measure.
We solve this issue by replacing all the type variables who are a subtype of bottom by bottom.
Every time that we compute the size for a variable bounded by an upper bound, we firstly recursively
check whether it is a synonym for bottom, and return the size of bottom if it is. This can be
implemented by an extension to the measure context Ψ. Dually, when we compute the size for a
variable bounded by a lower bound, we recursively check if it is the supertype of top. With this
change the measures work, and we can prove decidability.
Theorem 5.7 (Decidability for 𝐹𝜇
≤≥). 𝐹𝜇
≤≥is decidable.
Conservativity. The proof of conservativity for 𝐹𝜇
≤≥follows the same pattern as the proof for 𝐹𝜇
≤.
To prove conservativity of typing, we need the help of the algorithmic typing rules to obtain the
minimum type of an 𝐹≤term. However, the introduction of bottom types requires us to add several
new algorithmic typing rules, since in the declarative system, one can always use the subsumption
rule to transform a term with type ⊥to any function type or universal type, and apply it to any
argument, as also observed by Pierce [1997]. We also develop a similar treatment for recursive
types. Moreover, the meanings of the two exposure functions also need to be refined. For example,
the upper exposure function (⇑) is now used to find the least non-upper-bounded-variable upper
bound in the context, so it will return the variable itself if the variable is lower bounded. For lower
exposure, we also need a dual form of the rule XA-promote, which finds the non-variable lower
bound for a variable:
XA-downpromote
𝛼≥A ∈Γ
Γ ⊢A ⇓B
Γ ⊢𝛼⇓B
The complete set of 𝐹𝜇
≤≥algorithmic typing rules can be found in the extended version of the paper.
Theorem 5.8 (Conservativity for 𝐹𝜇
≤≥). If ⊢𝐹Γ, Γ ⊢𝐹𝐴and ⊢𝐹𝑒then Γ ⊢𝐹𝑒: 𝐴if and only if
Γ ⊢𝑒: 𝐴.
6
RELATED WORK
Bounded Quantification and Recursive Types. Bounded quantification was firstly introduced by
Cardelli and Wegner [1985] in the language Fun, where their kernel Fun calculus corresponds
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:25
to the kernel version of 𝐹≤. The full variant of 𝐹≤was introduced by Curien and Ghelli [1992]
and Cardelli et al. [1994], where the subtyping for bounds are contravariant. Although full 𝐹≤is
powerful, subtyping is proved to be undecidable [Pierce 1994]. As discussed in §1 there are several
attempts to add recursive types to 𝐹≤, such as the work by Ghelli [1993], Colazzo and Ghelli [2005]
and Jeffrey [2001]. Unfortunately, as Table 1 shows, such combinations are not painless, and even
the successful combinations require the significant changes for the subtyping rules.
Ghelli illustrates how the combination of equi-recursive subtyping and full 𝐹≤changes the
expressiveness power of the subtyping relation with a simple example:
𝐵
≡
∀𝛼. −(∀(𝛼′ ≤𝛼). −𝛼)
𝐴
≡
∀(𝛽≤𝐵). 𝛽
𝐴′
≡
∀(𝛽≤𝐵). ∀(𝛽′ ≤𝛽). −𝛽
𝑅
≡
∀(𝛽≤𝐵). 𝜇𝑋. ∀(𝛽′ ≤𝑋). −𝑋
where −𝐴stands for 𝐴→⊤and ∀𝛼. 𝐴is the abbreviation of ∀(𝛼≤⊤). 𝐴. In full 𝐹≤, 𝐴≤𝐴′ does
not hold. However, such system allows 𝐴≤𝑅and 𝑅≤𝐴′ to be derived, which by transitivity, allows
us to conclude that 𝐴≤𝐴′. In Colazzo and Ghelli’s work, there is no independent universal type,
and the shape of recursive types is either 𝜇𝛼.∀(𝑥≤𝐴). 𝐵or 𝜇𝛼. 𝐴→𝐵. The recursive variables
and universal variables are distinct, resulting in changes in environments and subtyping rules. For
example, the subtyping environment is defined as Π := · | Π, (𝑥,𝑦) ≤(𝐴, 𝐵) | Π, (𝛼= 𝐴, 𝛽= 𝐵),
and the rule S-vartrans rule of 𝐹≤is changed to:
(𝑥,𝑦) ≤(𝐴′, 𝐵′) ∈Π
∀𝛼′, 𝐵≠𝛼′
𝐵≠⊤
𝐵≠𝑦
Π ⊢𝐴′ ≤𝐵
Π ⊢𝑥≤𝐵
The algorithm proposed by Jeffrey is also complex, and requires major changes. Both recursive
variables and the subtyping algorithm are labelled polarly, and the implementation of 𝛼-conversion
is not discussed. In contrast, our subtyping rules do not change the contexts, the types are not
restricted, and most importantly, we do not have to change the rules in the original 𝐹≤. This has
the benefit that we can largely reuse the existing metatheory of the original 𝐹≤, and it also enables
our conservativity result. While it is plausible that Jeffrey’s or Colazzo and Ghelli’s work for the
kernel 𝐹≤extensions with recursive types are conservative, this has not been proved. Furthermore,
such proof is likely to be non-trivial because of the major changes introduced by equi-recursive
subtyping.
There are many other extensions to 𝐹≤. Bounded existentials are also studied by Cardelli and
Wegner [1985]. Existential types can be encoded by universal types, thus we can obtain a form
of bounded existentials for free in 𝐹≤[Cardelli and Wegner 1985]. Another important extension
is f-bounded quantification, firstly proposed by Canning et al. [1989], then studied by Baldan
et al. [1999] in terms of the basic theory. In f-bounded quantification, the bounded variables are
allowed to appear in the bound. For example, a bound of the form ∀(𝛼≤𝐹[𝛼]). 𝐵, where 𝐹is a
type-level function applied to 𝛼, is allowed in f-bounded quantification. We can encode polymorphic
binary methods [Bruce et al. 1995] and methods that have recursive types in their signatures with
f-bounded quantification. For the example that we have showed in §2.2, the bound in the translate
function is not Point but would have a form 𝐹[𝛼] = {𝑥: Int, 𝑦: Int, move : Int →Int →𝛼}.
Therefore, with f-bounded quantification the translate function could have the type:
∀(𝛼≤{𝑥: Int, 𝑦: Int, move : Int →Int →𝛼}). 𝛼→𝛼
Then the 𝛼can instantiate to Point or subtypes of Point, because Point ≤𝐹[Point]. Note that for
subtyping statements such as 𝛼≤{𝑥: Int, 𝑦: Int, move : Int →Int →𝛼} to hold, they must
be interpreted using equi-recursive subtyping, since the f-bounds are normally records, and an
iso-recursive type cannot be the subtype of a record. This approach is appealing because it can
even deal with binary methods, where recursive types appear in negative positions. For example,
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:26
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
with f-bounded quantification we can model bounds such as 𝛼≤{𝑥: Int, eq : 𝛼→Bool}, and still
have the expected subtyping relations.
Whereas we show that with the structural unfolding rule we can model positive cases of f-bounded
quantification (such as translate) in 𝐹𝜇
≤, we can only model a restricted form of negative f-bounded
quantification. For instance in 𝐹𝜇
≤we can have the bound 𝛼≤𝜇P. {𝑥: Int, eq : P →Bool} and we
can instantiate 𝛼with 𝑃(where 𝑃= 𝜇P. {𝑥: Int, eq : P →Bool}). However, we would not be able
to instantiate 𝛼with some types that have extra fields, such as 𝜇P’. {𝑥: Int, 𝑦: Int, eq : P’ →Bool}
for example. In contrast, f-bounded quantification allows such forms of instantiation. Nevertheless,
given the overlap between some of the applications of iso-recursive types in 𝐹𝜇
≤and f-bounded
quantification, we believe that it is worthwhile to investigate whether f-bounded quantification
can be avoided to deal with general binary methods.
Dependent Object Types. The interest in languages with bounded quantification and recursive
types has been reignited recently in the research community with the introduction of the dependent
object types (DOT) [Rompf and Amin 2016] calculus. DOT is the foundation of Scala 3 [EPFL 2021],
and also employs a generalized form of bounded quantification and recursive types. The generalized
form of bounded quantification subsumes both upper and lower bounded quantification, which are
present in 𝐹𝜇
≤≥. DOT supports both upper and lower bounds at the same time for path selection.
In addition, DOT also supports path-dependent types [Amin et al. 2014] and intersection types
[Barbanera et al. 1995; Coppo et al. 1981; Pottinger 1980]. DOT can encode full 𝐹≤[Rompf and
Amin 2016] and has been shown to be undecidable [Hu and Lhoták 2020; Mackay et al. 2020]. One
of the limitations for DOT is that transitivity elimination is not possible [Rompf and Amin 2016],
and even the decidable fragments of DOT lack transitivity [Hu and Lhoták 2020; Mackay et al.
2020]. The research on DOT has been intimately related to 𝐹≤. For instance, Amin and Rompf
[2017] explain many of the features of DOT by incrementally extending 𝐹≤. In addition, there have
been various attempts to prove the undecidability of DOT by a reduction to the undecidability
problem in 𝐹≤. Although, as Hu and Lhoták [2020] observed, DOT is not conservative over 𝐹≤.
Thus an undecidability result for DOT cannot be proved by reduction to the undecidability of full
𝐹≤. While 𝐹𝜇
≤≥does not have all the features of DOT, our results can potentially help in research in
that area, where the decidable fragments of DOT lack important properties such as transitivity. In
addition 𝐹𝜇
≤≥preserves the conservativity over 𝐹≤, while DOT does not.
Object Encodings. Recursive records can encode objects [Bruce et al. 1999; Canning et al. 1989;
Cook et al. 1989]. Alternatively, existential types can also be used to encode objects [Pierce and
Turner 1994], or they can be employed together with recursive types [Bruce 1994]. Pierce and
Turner’s object encoding is notable in that it requires only 𝐹≤, and does not employ recursive
types. The ORBE encoding, presented by Abadi et al. [1996] consists of recursive types, bounded
existential quantification, records, and the structural unfolding rule. In their work, an interface is
encoded as:
𝑂𝑅𝐵𝐸(𝐼) ≜𝜇𝛼. ∃(𝛽≤𝛼). 𝛽× (𝛽→𝐼(𝛽))
As Bruce et al. observe, the ORBE encoding requires full 𝐹≤for the bounded quantification subtyping
rule. When we try to compare two bounds, the type variable will be substituted with the existential
types, which may result in bounds that are not equivalent. The overview paper by Bruce et al. [1999]
makes a detailed comparison among different object encodings. Except for the ORBE encoding,
𝐹𝜇
≤could serve as a target for the existing object encodings. However, no complete formalization
of 𝐹≤with recursive types with desirable properties (such as type soundness and conservativity)
existed at the time. Our work helps to further validate such encodings by providing a complete
formalization of 𝐹≤with recursive types, together with various desirable properties.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:27
Algebraic Datatypes and Subtyping. Algebraic datatypes are a fundamental feature in modern
functional programming languages, such as Haskell [Haskell Development Team 1990] and Ocaml
[INRIA 1987]. However, such languages do not support subtyping between datatypes. Hosoya
et al. [1998] discussed the interaction between mutually recursive datatypes and subtyping. They
presented two variants of 𝐹≤extending 𝐹≤with user-defined datatype declarations. The first variant
has user-defined subtyping declarations between datatypes, and can be viewed as having a form
of nominal subtyping. The second variant allows structural subtyping among the datatypes. One
advantage of employing user-defined datatypes is that it is simple to deal with formally, and that it
allows mutually recursive datatype definitions easily. However, they do not support conventional
recursive types of the form 𝜇𝛼. 𝐴as we do in 𝐹𝜇
≤. Moreover, they do not consider lower bounded
quantification which, as argued in §2.2, seems to be quite useful in a system targeting algebraic
datatypes. There has been some work integrating ML datatypes and OO classes [Bourdoncle and
Merz 1997; Millstein et al. 2004]. In the implementation of hierarchical extensible datatypes, methods
are simulated via functions with dynamic dispatch. Those works are focused on the design of
intermediate languages that have complex constructs such as classes or datatypes. In contrast, we
develop foundational calculi, where more complex constructs can be encoded. Finally, Poll [1998]
investigated the categorical semantics of datatypes with subtyping and a limited form of inheritance
on datatypes, improving our understanding on the relation between categorical datatypes and
object types.
Oliveira [2009] showed encodings of algebraic datatypes with subtyping assuming a variant of
𝐹≤extended with records, recursive types and higher kinds. He showed that adding subtyping
to datatypes allows solving the Expression Problem [Wadler 1998]. However, as we mentioned
in §2.2, he did not formalize the 𝐹≤extension, although he showed a translation of the encoding
into Scala. Moreover, his encoding is more complex than ours because he employs upper bounded
quantification with higher kinds. In §2.2, we showed that first-order lower bounded quantification
in 𝐹𝜇
≤≥, together with the structural folding rule enables such encodings. Like for encodings of
objects, our work is helpful to further validate such encodings formally.
7
CONCLUSION
Recursive types and bounded quantification are important in many programming languages.
However, although those features are well-studied independently, their interaction has posed a
long term challenge. Our 𝐹𝜇
≤calculus illustrates how to integrate iso-recursive types and kernel 𝐹≤.
We obtain a transitive and decidable subtyping relation, while the full calculus is shown to be
conservative over 𝐹≤and is proven to be type-sound. 𝐹𝜇
≤and 𝐹𝜇
≤≥could serve as a theoretic
foundation for object encodings and encodings of algebraic datatypes with subtyping. With the
renewed interest on recursive types and bounded quantification due to the DOT calculus, we
believe that our work is also helpful to find calculi with most features in DOT, while retaining
desirable properties, such as decidability and transitivity of subtyping, or even conservativity over
𝐹≤. Investigating extensions of 𝐹𝜇
≤with some of the features of DOT is a clear avenue for future
work. In addition, studying the combination of iso-recursive subtyping and full 𝐹≤, could be useful
for modelling the ORBE encoding [Abadi et al. 1996].
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their helpful comments. This work has been sponsored by
Hong Kong Research Grant Council projects number 17209519, 17209520 and 17209821.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

48:28
Litao Zhou, Yaoda Zhou, and Bruno C. d. S. Oliveira
REFERENCES
Martín Abadi, Luca Cardelli, and Ramesh Viswanathan. 1996. An interpretation of objects and object types. In Proceedings
of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 396–409.
Roberto M. Amadio and Luca Cardelli. 1993. Subtyping recursive types. ACM Transactions on Programming Languages and
Systems (TOPLAS) 15, 4 (1993), 575–631.
Nada Amin and Tiark Rompf. 2017. Type soundness proofs with definitional interpreters. In Proceedings of the 44th ACM
SIGPLAN Symposium on Principles of Programming Languages. 666–679.
Nada Amin, Tiark Rompf, and Martin Odersky. 2014. Foundations of path-dependent types. Acm Sigplan Notices 49, 10
(2014), 233–249.
Brian Aydemir, Arthur Charguéraud, Benjamin C. Pierce, Randy Pollack, and Stephanie Weirich. 2008. Engineering formal
metatheory. Acm sigplan notices 43, 1 (2008), 3–15.
Michael Backes, Cătălin Hriţcu, and Matteo Maffei. 2014. Union, intersection and refinement types and reasoning about
type disjointness for secure protocol implementations. Journal of Computer Security 22, 2 (2014), 301–353.
Paolo Baldan, Giorgio Ghelli, and Alessandra Raffaeta. 1999. Basic theory of F-bounded quantification. Information and
Computation 153, 2 (1999), 173–237.
Franco Barbanera, Mariangiola Dezani-Ciancaglini, and Ugo de’Liguoro. 1995. Intersection and Union Types: Syntax and
Semantics. Information and Computation 119, 2 (June 1995), 202–230.
Jesper Bengtson, Karthikeyan Bhargavan, Cédric Fournet, Andrew D. Gordon, and Sergio Maffeis. 2011. Refinement types
for secure implementations. ACM Transactions on Programming Languages and Systems (TOPLAS) 33, 2 (2011), 1–45.
Corrado Böhm and Alessandro Berarducci. 1985. Automatic synthesis of typed Lambda-programs on term algebras.
Theoretical Computer Science 39, 2-3 (1985).
François Bourdoncle and Stephan Merz. 1997. Type checking higher-order polymorphic multi-methods. In Proceedings of
the 24th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 302–315.
Michael Brandt and Fritz Henglein. 1997. Coinductive axiomatization of recursive type equality and subtyping, Vol. 1210.
63–81. Full version in Fundamenta Informaticae, 33:309–338, 1998.
Kim Bruce, Luca Cardelli, Giuseppe Castagna, Hopkins Objects Group, Gary T Leavens, and Benjamin C. Pierce. 1995. On
binary methods. Theory and Practice of Object Systems 1, 3 (1995), 221–242.
Kim B Bruce. 1994. A paradigmatic object-oriented programming language: Design, static typing and semantics. Journal of
Functional Programming 4, 2 (1994), 127–206.
Kim B. Bruce, Luca Cardelli, and Benjamin C. Pierce. 1999. Comparing Object Encodings. Information and Computation 155,
1.
Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. 1989. F-Bounded Polymorphism for Object-
Oriented Programming. In Proceedings of the Fourth International Conference on Functional Programming Languages and
Computer Architecture (Imperial College, London, United Kingdom) (FPCA 1989). 8 pages.
Luca Cardelli. 1985. Amber. In LITP Spring School on Theoretical Computer Science. Springer, 21–47.
Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. 1994. An extension of system F with subtyping.
Information and computation 109, 1-2 (1994), 4–56.
Luca Cardelli and Peter Wegner. 1985. On understanding types, data abstraction, and polymorphism. ACM Computing
Surveys (CSUR) 17, 4 (1985), 471–523.
Giuseppe Castagna and Benjamin C. Pierce. 1994. Decidable Bounded Quantification. In Proceedings of the 21st ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (Portland, Oregon, USA) (POPL ’94). Association
for Computing Machinery, New York, NY, USA, 151–162.
Alonzo Church. 1932. A set of postulates for the foundation of logic. 33, 2 (1932), 346–366.
Dario Colazzo and Giorgio Ghelli. 2005. Subtyping recursion and parametric polymorphism in kernel fun. Information and
Computation 198, 2 (2005), 71–147.
William R. Cook, Walter Hill, and Peter S. Canning. 1989. Inheritance is Not Subtyping. In Proceedings of the 17th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL ’90). Association for Computing Machinery.
Mario Coppo, Mariangiola Dezani-Ciancaglini, and Betti Venneri. 1981. Functional characters of solvable terms. Mathematical
Logic Quarterly 27, 2-6 (1981), 45–58.
Pierre-Louis Curien and Giorgio Ghelli. 1992. Coherence of subsumption, minimum typing and type-checking in F≤.
Mathematical structures in computer science 2, 1 (1992), 55–91.
EPFL. 2021. Scala 3. https://www.scala-lang.org/
Vladimir Gapeyev, Michael Levin, and Benjamin C. Pierce. 2003. Recursive Subtyping Revealed. Journal of Functional
Programming 12, 6 (2003), 511–548. Preliminary version in International Conference on Functional Programming (ICFP),
2000. Also appears as Chapter 21 of Types and Programming Languages by Benjamin C. Pierce (MIT Press, 2002).
Giorgio Ghelli. 1993. Recursive types are not conservative over F≤. In International Conference on Typed Lambda calculi and
Applications. Springer, 146–162.
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

Recursive Subtyping for All
48:29
Jean-Yves Girard. 1972. Interprétation fonctionnelle et elimination des coupures de l’arithmétique d’ordre supérieur. Thèse
d’état. Université de Paris 7.
Haskell Development Team. 1990. Haskell. https://www.haskell.org/
Haruo Hosoya, Benjamin C. Pierce, and David N. Turner. 1998. Datatypes and subtyping. Unpublished manuscript (1998).
Jason ZS Hu and Ondřej Lhoták. 2020. Undecidability of D<: and its decidable fragments. Proceedings of the ACM on
Programming Languages 4, POPL (2020), 1–30.
INRIA. 1987. OCaml. https://ocaml.org/
Alan Jeffrey. 2001. A symbolic labelled transition system for coinductive subtyping of F𝜇≤types. In 2001 IEEE Conference on
Logic and Computer Science (LICS 2001). 323.
Jay Ligatti, Jeremy Blackburn, and Michael Nachtigal. 2017. On subtyping-relation completeness, with an application to
iso-recursive types. ACM Transactions on Programming Languages and Systems (TOPLAS) 39, 1 (2017), 1–36.
Julian Mackay, Alex Potanin, Jonathan Aldrich, and Lindsay Groves. 2020. Decidable subtyping for path dependent types.
Proc. ACM Program. Lang. 4, POPL (2020), 66:1–66:27.
Todd Millstein, Colin Bleckner, and Craig Chambers. 2004. Modular typechecking for hierarchically extensible datatypes
and functions. ACM Transactions on Programming Languages and Systems (TOPLAS) 26, 5 (2004), 836–889.
James Hiram Jr Morris. 1969. Lambda-calculus models of programming languages. Ph.D. Dissertation. Massachusetts Institute
of Technology.
Bruno C. d. S. Oliveira. 2009. Modular visitor components. In European Conference on Object-Oriented Programming. Springer,
269–293.
Bruno C. d. S. Oliveira, Shaobo Cui, and Baber Rehman. 2020. The Duality of Subtyping. In 34th European Conference on
Object-Oriented Programming, ECOOP 2020, November 15-17, 2020, Berlin, Germany (Virtual Conference) (LIPIcs), Robert
Hirschfeld and Tobias Pape (Eds.).
Michel Parigot. 1992. Recursive programming with proofs. Theoretical Computer Science 94, 2 (1992), 335–356.
Benjamin C. Pierce. 1994. Bounded quantification is undecidable. Information and Computation 112, 1 (1994), 131–165.
Benjamin C Pierce. 1997. Bounded quantification with bottom. Technical Report. Citeseer.
Benjamin C. Pierce. 2002. Types and programming languages. MIT press.
Benjamin C Pierce and David N Turner. 1994. Simple type-theoretic foundations for object-oriented programming. Journal
of functional programming 4, 2 (1994), 207–247.
Erik Poll. 1998. Subtyping and Inheritance for Categorical Datatypes: Preliminary Report (Type Theory and its Applications
to Computer Systems). Kyoto University Research Information Repository 1023 (1998), 112–125.
Garrel Pottinger. 1980. A type assignment for the strongly normalizable 𝜆-terms. To HB Curry: essays on combinatory logic,
lambda calculus and formalism (1980), 561–577.
John C. Reynolds. 1974. Towards a theory of type structure. In Colloque sur la Programmation. Springer, 408–425.
Tiark Rompf and Nada Amin. 2016. Type soundness for dependent object types (DOT). In Proceedings of the 2016 ACM
SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications. 624–641.
Davide Sangiorgi and Robin Milner. 1992. The Problem of “Weak Bisimulation up to”. In CONCUR, Vol. 630. 32–46.
Dana Scott. 1962. A system of functional abstraction. (1962). Lectures delivered at University of California, Berkeley,
California, USA, 1962/63.
Philip Wadler. 1998. The Expression Problem. (1998). discussion on the Java Genericity mailing list.
Yaoda Zhou, Bruno C. d. S. Oliveira, and Jinxu Zhao. 2020. Revisiting Iso-Recursive Subtyping. Proc. ACM Program. Lang. 4,
OOPSLA (2020).
Yaoda Zhou, Jinxu Zhao, and Bruno C. d. S. Oliveira. 2022. Revisiting Iso-Recursive Subtyping. ACM Transactions on
Programming Languages and Systems 44, 4, Article 24 (2022).
Received 2022-07-07; accepted 2022-11-07
Proc. ACM Program. Lang., Vol. 7, No. POPL, Article 48. Publication date: January 2023.

