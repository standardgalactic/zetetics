STAR-RT: Visual attention for real-time video game playing
Iuliia Kotseruba∗
John K. Tsotsos†
Abstract
In this paper we present STAR-RT - the ﬁrst working prototype of Selective Tuning Attention Reference
(STAR) model and Cognitive Programs (CPs). The Selective Tuning (ST) model received substantial support
through psychological and neurophysiological experiments. The STAR framework expands ST and applies it to
practical visual tasks. In order to do so, similarly to many cognitive architectures, STAR combines the visual
hierarchy (based on ST) with the executive controller, working and short-term memory components and ﬁxation
controller. CPs in turn enable the communication among all these elements for visual task execution. To test the
relevance of the system in a realistic context, we implemented the necessary components of STAR and designed
CPs for playing two closed-source video games - Canabalt1 and Robot Unicorn Attack2. Since both games run
in a browser window, our algorithm has the same amount of information and the same amount of time to react
to the events on the screen as a human player would.
STAR-RT plays both games in real time using only
visual input and achieves scores comparable to human expert players. It thus provides an existence proof for
the utility of the particular CP structure and primitives used and the potential for continued experimentation
and veriﬁcation of their utility in broader scenarios.
Keywords: STAR; Cognitive Programs; visual attention; Visual Routines; real-time vision; platform video games;
game AI
1
Introduction
Research in computer vision and related disciplines over the last several decades has led to a rapidly growing number
of algorithms for vision-based tasks and models of visual attention. This is hardly surprising given the demand for
such research for robotics and cognitive systems, and availability of computational resources. However, the problem
of controlling computer vision algorithms and making them useful for general reasoning or motor control remains
largely unsolved.
The Selective Tuning Attention Reference (STAR) [48] model proposes a biologically plausible, general purpose,
model of vision.
It is a theoretical framework designed to control low-level visual processing based on current
task demands. The two major parts of STAR are the Selective Tuning (ST) [47, 46] model of visual attention
and Cognitive Programs (CPs) [48]. ST is a model of visual attention, whose predictions are strongly supported
by experimental data3. Its complex hierarchical system mimics human vision and allows for both top-down (task
driven) and bottom-up (data driven) processes to inﬂuence visual processing. The purpose of Cognitive Programs is
to control the execution of ST by modifying the way it treats inputs based on the current visual task and directing
outputs to appropriate parts of the framework. The Cognitive Programs paper [48] is published in the journal’s
Hypothesis category and thus is explicitly set up for experimental testing.
In this paper we describe STAR-RT, a test of the STAR framework on the domain of real-time video games
(Canabalt and Robot Unicorn Attack).
We chose this particular task because it requires a signiﬁcant amount
of processing (e.g.
search, tracking, object detection) combined with decision-making and reasoning all to be
∗yulia_k@eecs.yorku.ca
†tsotsos@eecs.yorku.ca
1http://adamatomic.com/canabalt/
2http://www.adultswim.com/games/web/robot-unicorn-attack
3Readers interested in the biological plausibility and experimental veriﬁcation of ST may consult the following sources [44, 43, 39,
46, 20, 11]
1
arXiv:1711.09464v1  [cs.CV]  26 Nov 2017

accomplished within real-time performance constraints. As has been noted before [30], modern video games provide
a controlled and visually challenging environment for research in vision and AI.
The concept of Cognitive Programs extends and modernizes the theory of Visual Routines (VRs) [49], which
postulates that any vision task can be decomposed to a series of simpler context-independent subtasks. For the
original VRs, visual processing is described in [49] as a two-stage process in accordance with the inﬂuences at that
time, namely Marr’s theory of vision [26]. The initial base representation (primal sketch and 21/2-D sketch in Marr’s
terms) is a result of the bottom-up processing of the data. It contains local descriptions of depth, orientation, color,
and motion. Various operations (visual routines) are then applied sequentially to the base representation to solve
a task (e.g. line tracing, determining spatial relationships, etc.). Attention is essential for a functional system
of visual routines. For example, attentional mechanisms allow the application of the same routines to diﬀerent
locations, limit the processing to a small region, maintain a list of locations where the focus of attention should
move next and a list of already attended locations to prevent cyclic behavior.
Despite many changes in our understanding of vision and attention since the original publication of the theory in
1984, the idea of subtask sequencing in visual tasks is still supported by modern neurophysiological and psychophys-
iological studies. For example, Roelfsema found neural correlates for visual routines in the cerebral cortex [37], and
Yi and Ballard [55] identiﬁed visual routines for pouring coﬀee and making a peanut butter sandwich by analyzing
3D eye-tracking data from human subjects. In a study by Hayhoe [17] the “change blindness” phenomenon shows
that visual system represents only the information necessary for the immediate visual tasks, again hinting at the
modular structure of vision.
The original publication on visual routines contains a few illustrative examples but leaves out the technical
details on assembly, execution, and storage of visual routines. The gaps in theory were explored and resolved to
some extent by various projects applying visual routines in a variety of domains: playing video games (Pengi [1]
and Sonja [10]), simulated driving [40], graph reasoning (SKETCHY [34]), active vision [35], visuospatial reasoning
(Jeeves [18]), human-robot interaction [36] and robotics (AV-Shell [13], AIBO [15] and trash-collecting mobile robot
[6]). It should be noted that although low-level vision and attention played a major role in the original formulation
of visual routines, it was implemented only in a few projects. For example, Pengi and Sonja obtain data from the
game engine, omitting the low-level vision. In [36] attention state contains a current object of interest, its attributes,
its local context and also a history of previous attention states. However, there is no fovea or explicitly deﬁned
region of interest around the focus of attention.
As was already mentioned, Cognitive Programs retain the main premise of Visual Routines theory but introduce
more precise formulations of the system components and interactions between them. Like visual routines, CPs serve
as means for attentional modulation of the visual system, however the range of possible attentional functions is
signiﬁcantly expanded. In addition to region of interest selection for gaze change, it includes top-down priming,
feedback processing, suppressive surround and potentially even modulation of the operating characteristics of in-
dividual neurons. While the original formulation of VRs implied some memory operations (e.g. indexing) and
decision-making abilities, CPs explicitly include read-write memory access as elemental operations and can also
represent decision-making and setting control signals. Overall, CPs can be seen as a ﬁne-grained version of VRs. A
more detailed account of Visual Routines theory as the precursor of Cognitive Programs can be found in [23, 48].
In addition to designing and implementing CPs, our work on STAR-RT combines ﬁndings from several areas
of research such as computer vision, visual attention, GPU programming and AI. Thus, our model allows us to
integrate noisy low-level processing with symbolic reasoning, which is essential for proper implementation of AI.
While current research in computer vision has made signiﬁcant progress on solving concrete problems like object
detection, classiﬁcation, and tracking, these are generally used for simple applications, such as tagging photos or
surveillance. Similarly, models of visual attention explain separate stages of visual processing and often leave out
the connection to the higher order processes.
To date the most progress on combining these areas has been made in the ﬁeld of cognitive modeling. For
example, a recently introduced cognitive architecture named ARCADIA [4] studies attention as a central mechanism
for perception and cognition. ARCADIA allows both bottom-up and top-down inﬂuences to aﬀect visual processing.
It also implements several types of visual memory (iconic, short-term and long-term) and gaze control. ARCADIA
can accurately model human behavior in several psychophysical experiments: change blindness, multiple object
tracking, and inattentional blindness.
In general, given the importance of perception for general cognition, very few cognitive architectures give
2

it a proper treatment. We found that out of 31 established cognitive architectures listed on cogarch.org and
bicasociety.org, two-thirds omit perception and focus more on high-level cognition (e.g. planning, reasoning,
language comprehension, etc.), which relies on symbolic manipulation and complex knowledge structures. These
are needed for categorical reasoning, playing turn-based games (ticktacktoe, chess, etc.), solving puzzles, etc. Per-
ception is often replaced by symbolic input which can be used directly for reasoning (CAPS [21], Metacat [27],
Teton [51], IMPRINT [29]). It is also common to simulate high-level perception by specifying visual properties
(e.g. color, shape, coordinates) of the objects in the scene (e.g. ACT-R [31], Soar [53], EPIC [28], Homer [52]).
Essentially, treatment of perception as an independent module assumes that switching from a simulated domain to
a real environment can be done by replacing one “black box” with a more sophisticated one.
The architectures that are working with real sensory data provide evidence that perception should be more
tightly integrated with the rest of the system. Some steps in this direction are being undertaken already as there is
a demand for more practical applications for cognitive systems, e.g. robot navigation or autonomous driving. For
instance, the robotic architectures such as RCS [2] and ADAPT [5] process high volumes of sensory data in real
time for autonomous navigation. Even when not explicitly stated, elements of visual attention (selection of areas
of interest or feature selection) are often employed to reduce the computational load. A lot of eﬀort is also spent
on ﬁltering the sensor data and resolving the issues caused by the noise coming both from sensors and changes in
the environment. Because in such systems the perceptual component is dominant, they are restricted to the tasks
that do not require a lot of symbolic processing (e.g. navigation, object recognition, tracking, etc.) and are not
easily extended to other domains. More biologically sound architectures like BECCA [38] and LEABRA [32] are
also limited to recognition or visual tracking, which do not require any reasoning. Both architectures are yet to be
applied to realistic data. Currently, LEABRA recognizes 100 categories of objects from synthetic images with plain
backgrounds and BECCA works on synthetic 144 × 144 images or in high contrast visual environments.
Finally, we would like to address our choice of video games as a testbed for the STAR framework and brieﬂy
discuss relevant research on game AI. In a sense, interaction with computer games is analogous to the interaction
with the physical world, albeit in a simpliﬁed and controlled form. Video games of various genres make a challenging
setting for research in general AI [24]. Currently, game AI focuses on both designing artiﬁcial opponents to the
human players and imitating the human style of playing using classic AI tools (path-planning, ﬁnite state machines)
as well as machine learning techniques.
We consider results of game AI challenges indicative of the best techniques for achieving high scores rather than
due to the theoretical novelty. Since the mid-2000s, game AI challenges have become a noticeable part of the AI
research, many of which are run by universities and as part of conferences. For example, the IEEE Conference on
Computational Intelligence and Games hosted six game AI competitions in 2015.
Most AI research is currently conducted using game simulators, hence the problem of uncertain and noisy
perceptual information is rarely addressed. There are few exceptions such as the Angry Birds AI competition4,
where locations of various objects are found using color segmentation. However, both vision and physics modules
are included with the competition software and participants are not expected to improve them. Generally, in AI
challenges the information about the world is complete and correct.
Super Mario Bros. as one of the most representative platform games, deserves a detailed discussion. As in most
other platform games, in Super Mario, the score depends both on the time it takes to clear a level and bonuses
collected in the process. Thus, playing the game can be viewed as ﬁnding an optimal path through the environment.
This is a typical problem for classic algorithms such as A* search [16]. In this case, the world-state is deﬁned by
the state of Mario, locations of his enemies, bonus items and immobile objects. Possible next states are determined
by the actions (e.g. jumping, moving, ﬁring, etc.), and can be computed precisely by running the physics engine to
simulate the next step. The costs of actions are assigned using heuristic, e.g. actions leading to death are heavily
penalized. Super Mario game turned out to be well suited for this technique. As a result, the A*-based agents
achieved the highest scores for several years in a row in the MarioAI5 competition [42]. For comparison, a purely
rule-based agent for Super Mario performed at ∼75% of the top score achieved by the A*-based agent but was more
than 100 times faster. On the other hand, in the Angry Birds AI 2015 competition, both ﬁnalists were heuristic
agents [7, 19].
4https://aibirds.org/
5www.marioai.org
3

Solutions based on machine learning algorithms performed signiﬁcantly worse than agents based on heuristics,
classic AI (Finite State Automata, behavior trees, A*) and combinations of the two. However, machine learning, in
particular, deep neural networks, can be successfully applied to playing multiple games as demonstrated by Mnih et
al. [30]. Out of 61 Atari games, their system could play more than half better than the human experts. While it is
impressive that control commands for a wide range of game genres can be learned from the screenshots, this model
provides little insight into the cognitive processes that led to its performance. Even though some hidden layers of
the network can be associated with particular parts of certain games, it does not explain, for instance, why Pinball
is the easiest game to play (4500% better than human) and Montezuma’s Revenge is the hardest (cannot be played
at all by the model).
The rest of this paper discusses the STAR framework and Cognitive Programs, followed by the implementation
details of STAR-RT for playing online video games.
2
The STAR model and Cognitive Programs
The STAR model is an executive controller for the Selective Tuning (ST) model of attention. A formulation of
STAR, including Selective Tuning and Cognitive Programs (CPs) is given in [48], and here we only provide a short
overview of the framework (Figure 1a).
The Visual Hierarchy (VH) box in the diagram is based on the Selective Tuning model of attention. ST models a
hierarchy of neurons with connections between neurons in the same layer and layers above and below. The Θ-WTA
(winner-takes-all) algorithm selects features or locations within each layer of the pyramid. Figure 1a shows the
stages of visual processing: 1) priming for the target, 2) feedforward pass, 3) recurrent top-down localization, and
4) another feedforward pass with suppressed units. Not all stages are necessary for every visual task, for example
discrimination and categorization would stop after the feedforward pass 2). Furthermore, the ST hierarchy allows
priming not only for spatial locations where the target is likely to appear but also for particular features (color,
motion, etc.).
The current focus of attention (FOA) is shown as lines within the visual hierarchy. Selected features, current
ﬁxation and other parameters of the VH within the FOA are called an attentional sample. Its size and shape
depends on the parameter Θ in WTA, which in turn can be modiﬁed depending on the task.
The remaining components in the diagram tune and control the execution of ST. Communication between the
components of STAR and parameter setting is done via cognitive programs. CPs are composed of various operations
or other CPs and can be of two types - methods and scripts. Methods are the blueprints of the operations with
unassigned parameters. Scripts are methods with particular values for parameters in place and ready for execution.
For example, a method for visual search would require a target to be speciﬁed.
Fixation Control (FC) plans the gaze change. The next ﬁxation is selected from the history biased priority map
(HBPM) which combines salient items from the central visual ﬁeld (cFOA) and from the peripheral visual ﬁeld.
cFOA is the result of processing by the visual hierarchy. The peripheral visual ﬁeld is represented by the peripheral
priority map (PPM), which is computed in a bottom-up fashion using the AIM saliency algorithm [9].
There are several types of memory in STAR: visual working memory (vWM), task working memory (tWM),
and long-term memory (mLTM).
vWM has two elements - Blackboard (BB) and Fixation History Map (FHM). Every time attention shifts to a
new location, a new attentional sample is generated in VH and saved in blackboard which makes the attentional
sample accessible to other components. FHM keeps track of previous ﬁxations to avoid revisiting previously seen
locations. However, it can also be overridden if needed for the current task.
tWM saves all relevant information about the scripts in progress in Active Script NotePad. In addition, tWM
has access to the attention sample and cFOA stored in vWM.
mLTM is an associative memory store that contains predeﬁned methods and the methods used in the previous
tasks. The required methods are fetched from the long-term memory using the details of the task as indices.
It is worth noting that visual routines were presented in the original paper as chains of functions, where the
output of the every function is fed as input into the next function along the chain. Consequently, there was no need
for the long-term storage for the visual routines themselves, short-term memory for the intermediate results or I/O
functions. On the other hand, all practical implementations of visual routines had some sort of temporary storage,
4

(a) Diagram of the STAR model
(b) Diagram of the STAR-RT for playing video games. Note the changes in visual hierarchy
(VH) and visual attention executive (vAE).
Figure 1: Diagrams of STAR and STAR-RT. Gray boxes show main elements and their internal structure. The directions of black
arrows indicate the direction of information ﬂow within the framework.
5

(a) rocks and debris after the robotic drill
drops down
(b) ﬂocks of birds
(c) shards of glass
(d) collapsing building
Figure 2: Screenshots from Canabalt demonstrating various visual distractions typical for the game
such as registers for saving the indexed locations (surprisingly, none related this to a concept of working memory).
However, none of the existing implementations of visual routines explicitly deﬁned long-term memory or equivalent
structures for storing and retrieval of elementary operations. Similarly, long-term memory is not discussed in the
psychological studies on visual routines.
The two components which control the execution of the cognitive programs within STAR are visual attention
executive (vAE) and visual task executive (vTE). vAE initiates and terminates each stage of VH until the vTE
sends the command that the task is ﬁnished. vTE receives a task description from the user, selects appropriate
methods from the mLTM, tunes them into scripts and runs them using the data stored in tWM.
The aforementioned elements of the STAR framework (with the exception of ST) were published as a hypothesis
in [48]. In this paper we provide a ﬁrst working prototype of STAR and CPs to determine the feasibility of the overall
concept for a challenging visual task. In the following sections we describe an implementation of the STAR-RT
framework and results of its application to the video game domain.
3
STAR-RT and Cognitive Programs for playing video games
Controls and gameplay
The choice of games for a test of our extension to visual routines was very important. Some similar past projects
(e.g. Pengo and Sonja [10, 1]) used the exploration type of games that required a player to interact with various
objects on the screen and solve puzzles. The demand for interaction with multiple objects shifted the focus from
vision and attention to developing complex gameplay strategies and resolving semantic problems. STAR primarily
addresses visual behavior and testing its hypotheses would be best accomplished by fast-paced, visually complex
but conceptually simple games. As a result, we selected two popular browser games for testing STAR-RT: Canabalt
(2009) and its clone, Robot Unicorn Attack (2010). Both are 2D side-scrolling endless runner games featuring an
inﬁnite, procedurally generated, environment. Although the games diﬀer in minor details, the objective in both is
to run as far as possible, while jumping over the gaps and avoiding obstacles. Since the speed of scrolling gradually
increases, reaction time and attention are emphasized over planning.
The player controls the running man in
Canabalt by pressing X key to jump, in Robot Unicorn Attack, Z and X to jump and dash respectively.
Despite minimalist controls and gameplay, these games are not primitive from a visual processing point of view.
The smooth, detailed and endlessly varied graphics is what makes them long-standing hits and also an excellent
testbed for models of visual attention. In Canabalt the oﬃce worker escaping from the robot invasion encounters
debris from collapsing buildings, ﬂocks of doves, abandoned oﬃce furniture, shards of broken glass and robotic
drills dropping from the sky (Figure 2). The distractors in Robot Unicorn Attack are various sparkly artifacts
when bonus points are collected, silver dolphins and exploding stars (Figure 3 and 4). Curved platforms further
complicate visual processing.
6

(a) Dolphins
(b) Sparkles
(c) Curved platform
Figure 3: Examples of visual distractors in Robot Unicorn Attack. Dolphins are inactive game objects that appear at the bottom of
the screen. Their number depends on how many stars have been destroyed in sequence. Sparkling and shiny artifacts are generated
whenever points are earned, e.g. from collecting a fairy or destroying a star. Sparkles are inactive game elements, but they usually
remain on the screen for several frames and can be distracting.
Figure 4: Screenshots showing changes in appearance of the unicorn when dashing through the star. Here the unicorn is invisible
behind the explosion for almost 50 frames.
STAR-RT
STAR-RT has no access to the game engine, therefore all information must be obtained from the screenshots of
the browser window. In order to enable processing of high-resolution images in real time several changes were
introduced to the original formulation of STAR (Figure 1b).
Vision module output consists of the coordinates and properties of the platforms and objects in the scene. VH
is intended as a general purpose model of vision and, naturally, it is the most computationally expensive component
of the framework. We found that implementing even a subset of the full visual hierarchy is infeasible within our
time requirements even with most of the computation moved onto GPU. As a result, VH currently uses only the
bottom level of the pyramid and all processing is done in a feedforward fashion. For example, recognition of multiple
objects in the scene is done in parallel on GPU instead of serial processing with covert gaze change, and recurrent
localization is replaced with the mean shift algorithm [14]. Our implementation represents low- and high-level visual
processing, implements spatial priming, has several adjustable parameters and the same connections to the rest of
the components of STAR.
The primary role of ﬁxation control (FC) is to plan the next move while taking into account the salient objects
in the peripheral priority map (PPM) computed using the bottom-up saliency algorithm AIM [9].
The visual attention executive (vAE) in STAR-RT mainly serves for task priming and controlling the contents
of the visual working memory (vWM). Spatial priming is performed when searching for the character, since its
approximate location is known. Another instance of spatial priming is for the objects, and in this case we use the
fact that objects are located on the top of the platform6. The vWM contains a ﬁxation history map, which saves
ﬁxations in the previous frames and also a blackboard (BB), where the locations of all objects and lines detected
by VH in the current frame are saved and made available for all other elements in the diagram (they represent an
attentional sample for the current frame).
The task working memory (tWM) temporarily stores the locations of the objects and lines from several previous
frames (currently the number of frames is set to 10). As every new frame is processed, new data from the blackboard
is stored in the tWM overwriting the oldest record. An external function is called to determine the speed of scrolling
6Further examples of spatial priming in ST can be found in [46]
7

(a) CPs for Canabalt
(b) CPs for Robot Unicorn Attack
Figure 5: Simpliﬁed diagram of Cognitive Programs for the game playing task. The game playing logic is implemented as a decision
tree: white boxes show methods and gray boxes show calls to external procedures (loading a new frame, pressing a key, changing gaze,
etc.).
and resolve any inconsistencies between the recorded coordinates of the objects and platforms. All temporally
consistent detections are saved in the Active Script NotePad and later used for making game decisions.
The visual task executive (vTE) is responsible for coordinating all these modules. As we mentioned before, it has
three main functions: 1) to read the task speciﬁcation and compose appropriate methods for this task with tuned
parameters, 2) to execute the script and 3) to monitor the execution of the script and modify the progress of the
script when needed. In our case the cognitive programs are hard-coded and there is no need for composing scripts
and tuning them. Hence the script constructor is omitted. The ﬁnite-state machine (FSM) that represents vTE in
STAR-RT accomplishes two out of three functions in the following way: the script monitor has access to the active
script notepad, which contains all information relevant for the execution of the scripts (e.g. coordinates of objects
in the current and several past frames, variables and timer for a key press). The vTE takes the task speciﬁcation, in
this instance a string specifying the name of the game to be played. The pre-programmed methods are then loaded
from mLTM and executed step by step. The vTE also calls several external functions to measure the speed of the
game, compute jump trajectory and determine the duration of key press. Keyboard input is required to control the
character on the screen, however, the original formulation of STAR in [48] does not specify how it interacts with
motor functions. Therefore, we assume that keyboard calls can be done through the vTE.
Cognitive Programs for playing the games
We formulate the task of playing a video game as a decision-making problem, i.e. for each new frame the player
must choose whether to press/release the key given the world state (platform edges, properties of the objects on the
screen, etc). In order to develop a set of rules we conducted a study where we asked 3 subjects7 to play 10 sessions
each of Canabalt and Robot Unicorn Attack while tracking their eye movements with the Pupil Labs eye-tracker8.
Although both games also use audio cues to warn the player about upcoming obstacles, our algorithm does not
use it. Therefore, during the study, all participants played the game with audio muted. Overall, 20+ minutes
of recorded data were collected for each participant. We did not continue with a full study of eye-motion with
naive participants. The study was conducted in order to ﬁnd out if any useful strategy for playing the game can
be extracted from the eye-tracking data. Our analysis of the data was limited to observing videos with overlaid
7Our subjects were one female (the ﬁrst author) and two males, all members of Tsotsos lab. The ﬁrst author was the only expert
player of the game, both other subjects played the game for the ﬁrst time. Participants were not paid for their time.
8https://pupil-labs.com/pupil/
8

Figure 6: Foveated screenshot from Canabalt. The fovea covers only about 1/3 of the frame width. As a result, small details in
peripheral areas are blurred and require less processing.
eye-tracking data and ﬁnding patterns in the eye movements that could be helpful in developing a game playing
logic for the game.
All subjects showed similar patterns of ﬁxations while playing both games. First, they looked at the character
and then moved their gaze to the right along the top of the platform. If an obstacle was found, it was tracked until
a jump could be safely made. Then players immediately started looking for the next obstacle to the right.
Another ﬁnding, based on interviewing the participants after the study, was that the best strategy for jumping
in Canabalt was to plan the landing spot closer to the edge of the platform. However, this required ﬁne control
skills, especially as the game reaches its highest possible speed (which in Canabalt is set to 800 pixels per second
or about 286 km/h9).
Since both games are very fast-paced, planning for more than one step ahead is rarely needed. In fact, when the
games reach their maximum speed, the player has approximately a quarter of a second to make a decision, which
is at the limit of human ability [3]. Nevertheless, in Canabalt there is rarely more than one obstacle present on a
single platform, therefore all decisions about the obstacles are made in FIFO order, one at a time. This is conﬁrmed
by the human eye-tracking data. For instance, if there is a gap followed by a box on the next platform, the gap will
be tracked ﬁrst. Only once the jump is made, the gaze would be shifted to the edge of the next platform and then
to the box on top of it.
We applied observations made from the human player data to the design of the Cognitive Programs for playing
both games. Figure 5 shows diagrams with high-level description of methods (e.g. ’check if the runner is on the
top of the platform’).
Each path within a diagram also represents a method in the CPs terminology.
In our
implementation the vTE acts as a rule-based game AI.
The vTE controls the execution of the task based on the rules and the information within the visual working
memory and the task working memory. For example, while playing Canabalt, to check if the character is found in
the image, the vTE examines the contents of the Active Script NotePad. If the character is not detected and its
previous location is not within fovea, it means that the system is currently tracking an obstacle or looking for the
end of the platform. In this case, the location of the character is assumed to be unchanged. If no obstacles are
found within the fovea and the platform extends beyond it (“is roof end in the fovea?”), then the gaze is gradually
shifted to the right along the current platform as each next frame is loaded. When the platform is very long, it may
span several lengths of the screen. The gaze will eventually reach the edge of the image and will remain there until
the end of the rooftop (or an obstacle) appears. After that, the end of the rooftop (or an obstacle) will be tracked
normally and the decision to jump will be made eventually.
If the runner is found within the fovea and is not performing a jump (“is runner on the roof?”), then the obstacle
locations recorded in the tWM are checked (“is drill/crate on the roof?”). If an obstacle is detected and located
suﬃciently close to the character (the distance depends on the current frame rate and speed), a decision is made
whether to jump over it or not (“jump over?”). If a jump is required, vTE calls an external function to compute
the trajectory of the jump and the duration of the key press and then sets the timer and a ﬂag for the key pressed
in the tWM to true and loads a new frame.
Below we describe what actions within the STAR framework are required to implement the elements in the
diagram. More technical details and pseudo-code can be found in [22].
START. All parameters of the system are reset to the default values, the visual hierarchy is primed to look for
9http://www.gamasutra.com/blogs/AdamSaltsman/20100929/88155/Tuning_Canabalt.php
9

Figure 7: Objects in Canabalt: top row shows several key-frames from the main character animation, and the bottom row shows
various non-lethal objects (crates and oﬃce furniture). The robot drill is the only lethal object in the game (shown on the right).
the character in the left half of the screen, and the gaze location is moved to the left. Since we expect the character
to always be in the left 1/3 of the screen, we set the gaze location at ( 1
2h, 1
3w), where w and h are width and height
of the frame. This way the vision system will have a chance to recognize and localize a character and most of the
scene will also be visible.
LOAD NEW FRAME. A screenshot of the rectangular area within the browser window is taken and resized
from 320 × 920 to 256 × 1024 pixels to improve GPU processing. Next, the image is foveated using the current gaze
location (Figure 6). We reimplemented the BlurredMipmapDemo from Matlab Psychophysics Toolbox [8] on GPU.
First, we build a Gaussian pyramid (without scaling), combine levels of the pyramid so that the fovea contains
pixels from the ﬁrst (not blurred) level, and copy the rest of the pixels from the diﬀerent levels of the pyramid
depending on their distance from the center. Following [41] the fovea diameter is set to 2°. Other parameters were
set according to the conditions of the human study, namely the distance to the monitor of 57 cm and monitor ppi
of 95.77.
FEED-FORWARD PASS. The feed-forward pass in the VH computes line segments and recognizes salient
objects. Localization is done by the mean-shift algorithm [14]. Edges are detected by ﬁltering the foveated image
with a 3 × 3 Sobel operator. To ﬁnd line segments we use the fast Hough transform optimized for GPU [50]. The
line segment endpoints are computed on CPU. As a result, for each frame at most 10 lines with lengths of 100 or
more pixels are detected. If the total length of gaps is more than 15% of the line length, it is discarded.
In order to ﬁnd regions of interest in the image we use a bottom-up saliency algorithm AIM10, which we ported
to OpenCL. We ﬁnd at most 100 salient points11 in the AIM saliency map on CPU by iteratively selecting local
maxima above the threshold (50% of max saliency) and inhibiting a 20 × 20 area around them to avoid tight
clustering.
Around each local maximum, 50 normally distributed points are sampled. These random points are the centers
of 30 × 30 image patches, which are passed to a convolutional neural network (CNN). The GPU implementation
of CNN is based on the DeepLearnToolbox [33]. Only the CNN classiﬁer part of the code runs on GPU, while
training is done in Matlab oﬄine on CPU. CNN must be able to distinguish patches of 4 classes: runner, non-lethal
obstacles (crates), lethal obstacle (drill) and everything else (Figure 7).
Each class has a considerable amount of variation. For example, the runner’s animation is composed of 38
diﬀerent frames, and he sometimes could be confused with shards of glass and ﬂocks of birds. There are also 7
types of non-lethal obstacles - crates, boxes and oﬃce furniture. Robotic drills are the least varied in appearance,
but they also produce a lot of ﬂying debris, which do not aﬀect the runner but occlude the view of the drill itself
and nearby objects. Since template matching and SVMs were not very good at separating these classes, a CNN is
used instead [25].
An architecture for the network was derived experimentally and has 4 layers - 2 convolution and 2 subsampling.
The network was trained for 400 epochs with learning rate parameter (alpha) set to 1.0 and a batch size of 50. The
training data contained 15000 samples for “other” class and 5000 for each of the runner/crate/drill classes. The
10http://www-sop.inria.fr/members/Neil.Bruce/AIM.zip
11Since recognition is performed on the GPU, the structure holding local maxima cannot be dynamically allocated. Therefore, we
gathered statistic over several thousand frames from the game and determined that majority of frames contain only a few objects,
however frames with ﬂocks of birds can have up to 50. In order to ensure that every local maxima is processed, we doubled that number.
10

Figure 8: Fitting a parabola to a jump trajectory. Blue line represents the sampled trajectory of the runner and red line shows an
approximation.
ﬁnal network accuracy is 98%.
Finally, we cluster all points with the same class labels using the mean shift algorithm [14]. This step is needed
because AIM maxima do not necessarily correspond to the centroid of a salient object, and also because objects
larger than 30 × 30 (e.g. drills) may produce several salient points. Clustering is performed on CPU for each class
separately with bandwidth of 20 pixels. Clusters containing more than half of points of “other” class are ignored.
All discovered line segments and centroids of objects are then saved in the Blackboard.
EXTERNAL FUNCTIONS. External functions are called by the vTE to eliminate the false detections for
objects, ﬁnd current platforms, estimate speed, compute jump trajectory and estimate key press duration.
The starting point is the location of the runner, since its location is the most constrained (movement is vertical
with slow drift towards the center of the screen as the speed of the game increases, but at most 200 pixels from
the left edge). The longest edge directly below the runner is assumed to be the current platform. If there are any
objects on the screen, they are used as additional evidence. If the current platform does not extend beyond the
right edge of the frame, we look for lines that begin after the current platform ends and select the top one.
Matching detected objects and ﬁnding displacements are done simultaneously.
Since many of the obstacles
are visually identical, the only way to distinguish between them is by their coordinates. We compute pairwise
displacements between all detected objects in the current and previous frames and select globally the most consistent
one (or a minimum value if all displacements are unique). The fact that the game scrolls from right to left is an extra
constraint used to eliminate incorrect displacements. We also check that the motion of the platforms is consistent
with the object displacements. Here, the speed is estimated using displacements from the past 15 frames.
Jumping is the only action in the game and mistakes in timing or precision aﬀect the ﬁnal game score. The
optimal strategy is to plan the landing spot closer to the edge of the next platform, because it leaves more time to
react to obstacles. The trajectory of the jump is determined by the initial speed, the amount of time the key was
pressed, the location of the runner and the size of the obstacle. Holding the X key maintains vertical acceleration,
and jump height is proportional to the speed. Pressing the key for more than 350 ms has no additional eﬀect.
Typically in the game AI research the future state can be obtained by running the game engine a few steps
forward, which greatly simpliﬁes learning the game behavior. Since both Canabalt and Robot Unicorn Attack are
closed-source, we estimate parameters of the game from noisy data collected over multiple sessions. In Canabalt,
the jump trajectory can be well approximated by a parabola (Figure 8), so we use two parameters as a jump
descriptor. Based on runtime statistics on hundreds of jumps (coordinates of the runner, time stamps, “X” key
on/oﬀ, parameters of the parabola and speed) we also ﬁnd correlations between the height of the jump and key
press duration, and between the speed and maximum height of the jump. All parameters of jump physics are
learned oﬄine. At runtime when the runner is approaching an obstacle, the vTE calls a function to determine
11

Figure 9: Examples of curved platforms in Robot Unicorn Attack
Figure 10: Objects in Robot Unicorn Attack: top row shows several key frames from the unicorn animation. Bottom row shows fairies
and dolphins (inactive game elements). The only lethal game element is the star, shown on the left.
whether a jump can be made given the current speed. If yes, the key press time is returned, if not, it usually means
that the jump was planned too early. In this case, if the runner is still far from the obstacle, the function returns 0
and attempts to jump later. Otherwise, if the obstacle is too close, the biggest possible jump is performed.
The only diﬀerence in visual processing required for Robot Unicorn Attack is the addition of the curve approxi-
mation algorithm, since the shape of platforms in this game is more complex than in Canabalt (Figure 3c). A sketch
of the curve tracing procedure in Cognitive Programs is outlined in [48], however, it was not possible to implement
it in real time within our system. In our implementation we ﬁrst threshold the image at 60% of the intensity to
eliminate the background, resize the image to 64 × 64 pixels and compute connected components as described in
[54]. For all blobs with area of > 20 pixels we ﬁnd contour points12. Next, the Douglas-Peucker algorithm [12] is
applied to the contours to obtain a coarse polygonal approximation of the platforms. This reduces the set of points
by a factor of 15 (Figure 11a). The top of the platform is found by tracing a path from the leftmost to the rightmost
point in the contour set (Figure 11b). Finally, all coordinates are rescaled to the original window size of 512 × 512
pixels. For the classiﬁcation step we follow the same steps as in Canabalt. CNN parameters remained the same
and the network was retrained on the new set of patches representing objects in the Robot Unicorn Attack (Figure
10). The bandwidth for mean shift is increased to 50 to ﬁt larger objects in the game.
We apply a similar technique to learn jump parameters for Robot Unicorn Attack.
Unlike Canabalt, it is
rendered in a square window and since the lookahead is much smaller, most of the jumps are made when the next
platform is not visible. To alleviate this, the game allows the character to ﬂoat in the air if the jump key is pressed
continuously. Our algorithm presses the jump button when the unicorn is close to the edge of the platform and
holds it until the next platform appears in the ﬁeld of view. Once it is visible again, it uses the pre-learned jump
parameters to estimate whether the platform can be reached if the key is released immediately.
The strategy for playing Robot Unicorn Attack is diﬀerent too since ﬁnal score depends both on the distance
traveled and bonus points objects awarded for picking objects (fairies). Simply staying alive brings approximately
12Using the open source library OpenCVBlobsLib http://opencvblobslib.github.io/opencvblobslib/.
12

(a)
(b)
Figure 11: a) Screenshot from the Robot Unicorn Attack with dense contour points (green dots) and a coarse approximation of the
surface after the application of Douglas-Peucker algorithm (red circles). This coarse approximation is used to determine the top of the
platform (shown in b) as a red line).
1000 points per 10 seconds of gameplay. Bonus for destroying the stars starts at 100 and destroying every next
star increments this amount by 100 points. If the sequence is broken, the bonus is reset to the initial 100 points.
For fairies the initial bonus (and increment) is 10. However, trying to collect all stars and fairies is a risky strategy
since often stars are placed on the platform below or above the unicorn and are not easily accessible. The easier
and safer strategy is to collect most of the fairies, which are usually placed along the safest trajectory between the
two platforms. When the star is on the same platform as unicorn, it is destroyed, otherwise it is safer to ignore it.
4
Evaluation
Playing video games has many subjective aspects, such as style, strategy and entertainment value, which are hard
to quantify, but are important factors when judging one’s performance. We also cannot evaluate STAR-RT against
other game AI algorithms. To the best of our knowledge, there is no software that can play Canabalt or Robot
Unicorn Attack, nor can other existing game playing algorithms be easily adapted to this task (mainly because
current approaches require a simulator for training and testing, which is not available for the games we use). Even
though the machine learning approaches such as DeepMind system [30] may eventually learn to play these games,
our goal for this paper was to create a transparent model of human visual system and attention, and to demonstrate
the connections between its multiple components.
Since each game session is randomly generated, it is not possible to directly compare the performance of human
players to our algorithm with respect to jump precision and other elements of gameplay. Therefore, we use the ﬁnal
score as our main evaluation metric and additionally report the performance of the vision module.
Canabalt
Correct identiﬁcation of obstacles is crucial for playing the game. To test the vision module we took 5000 screen-
shots from several recorded games and generated ground truth for locations of the objects in each frame and true
displacements between consecutive frames. The ground truth marks the center of each object as its location. The
runner is correctly detected in 98% of the frames (detection is successful if it is within 1/4 of the runner’s height
from the middle of the character). For crates and robot drills the detection rate is also high at 97%, where detection
is considered successful if it is within the object contour. Most of the misdetections are caused by sudden shakes of
the game screen when a robotic drill falls on the rooftop or a rocket passes in the background.
An average game lasts 48 seconds (approximately 4000 frames). Most of this time the player does not directly
control the character, since running on top of the platform and ﬂying through the air after the jump are done
automatically by the game engine. As a result, only 15 −20% of frames are critical for successfully playing the
game. In particular, the frames immediately before obstacles are needed for speed estimation and pressing the
13

Figure 12: The histogram of key press durations based on 100 games recorded with a human player and STAR-RT playing.
key. In order to determine the correctness of speed estimation, we gathered ground truth data on 5000 frames
by overlaying pairs of consecutive frames, measuring the exact displacement in pixels, and computing the speed
of scrolling from these measurements. Since displacements between the frames are not computed if the platform
spans the whole screen, in that case speed remains ﬁxed at the last estimated value. We take this into account in
evaluation. The measured speed for the 100 frames preceding the decision point was within ±50 pixels per second
from the ground truth, which is negligible, as it has no eﬀect on jump precision.
In order to evaluate the overall performance of STAR-RT we use the recent statistics from the browser version
of Canabalt available at kongregate.com13. The score in the game depends only on the distance traveled and is
measured in meters. The all-time highest score reported for the game on kongregate.com is 30,760 m. The average
score is reset weekly, but is usually around 2500 m. It can be concluded from the statistics that a score of at least
10,000 m is reasonable for an expert player.
We collected the ﬁnal scores of 1000 games played by STAR-RT after the training was ﬁnished. The mean
score was over 3000m and the top score was 25,254 m, making it #18 in the all-time best ranking posted on
kongregate.com. The most common reason for failing was hitting a wall due to the bad jumping trajectory or
timing. As mentioned before, jumping is the essential skill in this game. The best strategy is to land the character
as close as possible to the edge of the platform since it gives the player more time to make the next decision.
However, motor skills play a great role in executing this intention, especially as the game reaches higher speeds
where every millisecond counts. This is demonstrated by the superior performance of STAR-RT, which is tuned to
jump as soon as possible and select the trajectory to land close to the edge of the rooftop and has a better control
over the keyboard than a human player. Figure 12 shows the distributions of key press times for the human player
(the ﬁrst author) and the algorithm: on a physical keyboard the average press time is 180 ms, while the mean for
the algorithm is 92 ms.
Robot Unicorn Attack
Robot Unicorn Attack has more colorful graphics but visually it is simpler than Canabalt: the camera movement is
smooth, there are only 3 types of objects distinct from the background and fewer distractors. The detection accuracy
for the unicorn is at 95% based on 5000 frames collected from several recorded games (successful detections are
within 1/4 of unicorn’s height from the center of the unicorn’s torso). The misdetections mostly happen when the
unicorn is dashing and temporarily disappears behind the explosion, however, it does not aﬀect the performance,
since the controls are inactive at this time.
Speed estimation is easier in this game because many points are
generated for each platform. As a result, speed estimation is within ±20 pixels from the ground truth (generated
by the same procedure as for Canabalt). But in Robot Unicorn Attack platforms are usually farther apart and
the camera moves more than in Canabalt. As a result, frequently no platforms are visible in the frame and speed
estimation is not possible.
Although Robot Unicorn Attack was played over 32 million times on the popular gaming site adultswim.com
13We use only scores recorded from PC version of the game, since releases on other platforms such as Mac OS and Android diﬀer in
input method and have slightly diﬀerent physics.
14

Image loading
3.39 ms
28%
CPU time
1.2 ms
10%
Total GPU time
5.6 ms
47%
GPU overhead
1.8 ms
15%
Total
11.84 ms
Table 1: Processing times per frame
since its release in 2010, highest scores posted online are often fake. Due to the game’s popularity many ways of
tampering with the game are published online. Since many users submitted ﬁnal scores of several billions of points,
the oﬃcial scoreboard lost its meaning and was removed from the site. However, based on the videos of expert
players posted online and our own experience we estimate that top players should achieve around 100,000 points
per run and close to 300,000 per game. Expert players score approximately 80,000-100,000 points per game.
The highest score achieved by STAR-RT is 26,591 points in a single run and 72,697 points per game. We believe
that the results can be further improved by fully utilizing the control mechanisms in the game, e.g., a double jump
(i.e. jumping again in the air to correct the trajectory).
By adding a second game of similar genre but visually very diﬀerent we were able to test the ﬂexibility of
Cognitive Programs.
Few changes were required in order to make the system play a new game.
Namely, the
addition of visual processing routines to handle curved platforms, retraining CNN for diﬀerent types of objects,
and changes in the control function to add an extra key for dashing. Overall, the algorithm’s style of playing both
games is markedly diﬀerent from human players. It makes more precise jumps than would be possible by using the
physical keyboard, has better reaction time and is able to perform consecutive actions in quick succession.
Parameters
In STAR-RT 13 parameters tune various aspects of the system, which include:
• 3 parameters for the foveation set to reﬂect the experimental setup we used for the human players: fovea
radius (set to 2 degrees of visual angle), resolution of the monitor (92 ppi) and the distance from the monitor
(57 cm).
• 7 parameters for the visual hierarchy and WM: number and length of detected lines (10 and 100 px respec-
tively), number of salient points found with AIM (100), threshold for AIM saliency (> 50%), number and size
of patches for classiﬁcation (50 and 30 × 30 px), bandwidth of the mean-shift for ﬁnding object centroids (20
px).
• 3 parameters for external functions: number of previous frames for speed estimation (set to 15) and 2 param-
eters for jump parabola learned from the data.
It should be noted that our system is robust to changes in most of these parameters. The main eﬀects from changing
the values are observed in the running time of the algorithm and aﬀect accuracy less. For instance, in order to
reach the best results in Canabalt, several thousands of jump trajectories were sampled from the past runs of the
algorithm. However, even a few hundred samples were suﬃcient to play the game for some time. In order to
set other parameters, STAR-RT was tested with a range of values and the ones that ensured the required time
performance were selected. For instance, classiﬁcation is one of the more computationally expensive steps, but the
game can be played with the number of samples ranging from 20 to 100, optimal being 50.
Setup and performance
The software for STAR-RT is implemented in C. The kernels for visual processing on GPU are written in OpenCL
1.2. A visual debugger is written in OpenGL 4.3 and GLSL 4.2. STAR-RT runs in a single thread. In addition,
MATLAB scripts were written for training convolutional networks, gathering and analyzing various game-related
data (“Game Over” screenshots, jump trajectories, image patches, etc.).
All experiments were conducted on a
15

desktop running on Ubuntu 12.04.5 LTS with Intel Core i7-3820 @ 3.60GHz CPU, 16 GB of RAM, two AMD
FirePro W7000 (Pitcairn XT GL) video cards (one for visualization and one for computation).
It takes ∼12 ms to process each frame, and the average frame rate is approximately 84 fps. The time for
processing each frame is not ﬁxed and depends on the visual complexity of the scene, hence frame rate ﬂuctuates
between 70 and 90 fps. Table 1 shows the processing time for each major part of STAR-RT. Taking a screenshot of
the browser window takes 1/3 of the total time. Other gameplay related operations such as decision making, ﬁnding
local maxima and mean-shift take negligible amount of time. The GPU overhead is estimated to be ∼15% of the
overall processing time.
5
Conclusions
The main contribution of this work is a positive test of Cognitive Programs and STAR concepts in the domain
of video games, opening the road for more extensive implementations with the ultimate goal of creating a general
purpose visual system that can execute arbitrary tasks formulated in natural language. STAR theory postulates
that this can be accomplished by decoupling the visual system from the task control. To this end, the attention
executive uses scripts, called Cognitive Programs, to tune and guide the visual hierarchy represented by the Se-
lective Tuning model of visual attention. CPs share many similarities with the earlier concept of Visual Routines,
such as decomposition of visual tasks into a set of context-independent atomic operations and various attentional
mechanisms. While past applications of visual routines proved usefulness of this concept in areas from robotics to
computer vision and game AI, many of those works omitted low-level vision and addressed other non-vision related
issues such as developing complex game playing strategies. By choosing games with relatively simple game logic
but visually complex appearance for testing STAR-RT, we were able to focus on low- and intermediate-level vision,
gaze control and integrating visual data with symbolic reasoning. In particular, for our proof-of-concept of STAR
framework, we formulate CPs for playing a game. These consists of multiple tasks, such as ﬁnding a character,
locating the platforms, etc, which in turn can be split into more primitive subtasks, e.g. ﬁnding straight lines,
computing sparse optical ﬂow and reading from and writing to memory. Then we apply these CPs to another game
with similar logic but very diﬀerent visual properties. Since both games (Canabalt and Robot Unicorn Attack) are
closed-source, they cannot be artiﬁcially slowed down or dissected to ﬁnd the internal parameters, which makes the
task more realistic.
Visual attention plays a major role in STAR framework. It includes more than a dozen of diﬀerent attentional
mechanisms [46] that have ample psychological and neurophysiological support. STAR-RT successfully applied a
subset of these, including foveation, gaze control, spatial priming, bottom-up and top-down saliency and inhibition
of return.
In fact, these mechanisms are essential for real-time performance which puts an upper bound on a
computation of < 20 ms per frame.
In order to satisfy the real-time constraints, the original concept of visual hierarchy (as the most computationally
expensive) had to be modiﬁed, even with most of the processing moved on GPU. For instance, the only existing
implementation of ST takes 1 second to process a single low-resolution image (256×256 px). The simpliﬁed version
of the VH used in STAR-RT is much faster but cannot be eﬃcient without multiple attention mechanisms. For
instance, in STAR-RT both foveation and the bottom-up AIM saliency allow reducing the search space to a few
salient regions. Together, the saliency map and FSM provide the bottom-up and top-down guidance respectively
for the next ﬁxations, while inhibiting attended locations in the saliency map prevents the system from cycling
between the most salient locations.
Even though the STAR framework is not yet completely realized, parts of it, such as ﬁxation control, visual
hierarchy (represented by ST) and visual attention executive, have been previously implemented and tested in
isolation with the stimuli typically used for psychophysical experiments. We put together major elements of STAR,
some in simpliﬁed form, to perform a more realistic task of playing a computer game. By that we demonstrated
that the STAR framework is relevant for performing this and similar tasks. This work also identiﬁed the issues
that must be solved by any real-time cognitively plausible implementation and uncovered related theoretical and
engineering challenges, which will inform future eﬀorts to extending STAR to a broader range of tasks. Some of
these issues are discussed below.
While the idea of modular vision routines is supported by neurophysiological and physiological studies, the
16

nature and number of the speciﬁc low-level vision operators remain an open research question. The problem of
decomposing a more abstract task into subtasks and passing it to the visual system for execution is still relatively
unstudied. To date, providing task guidance for visual processing has been limited to relatively simple cases such as
using a class template or label to bias localization (i.e. tasks like “ﬁnd object of class X in the image”) [56, 57]. In
our work we attempted to represent a more complex task of playing the game as a series of generic vision processing
steps (e.g. edge detection/curve tracing, saliency, object recognition, etc.), which could be applied to other visual
tasks as well. For example, in [45] the ﬁrst step proposed for understanding an arbitrary image is two-dimensional
grouping of intensity-location values such as ﬁnding edges, regions and ﬂow vectors.
Finding the right data structures for task description and passing messages within the framework, to the best of
our knowledge, is an open research problem and hard-coding the communication channels remains the only viable
solution for any relatively complex application. Learning new representations, tuning them and combining them
depending on the task presents yet another set of unresolved issues. In particular, past research on visual routines
demonstrates that learning a sequence of actions is a hard problem even in simple cases with only a few parameters.
This is one of the concerns for STAR, where every method can be parametrized during runtime to adapt to changes
in the environment and task requirements.
Since STAR was originally designed to work with static images, one of the initial challenges was adapting the
framework to dynamic stimuli. In our implementation each frame is processed individually and then candidates
for objects and platform locations are recorded in the vWM and tWM. External functions are called to compute
displacements between consecutive frames, match objects, and discard false positives. While our solution was a
compromise, it shows the functional importance of working memory which is also prominent in the human visual
system. In the future, a more biologically plausible solution for moving stimuli is needed.
Currently the STAR diagram shows only static connections between elements and directions of the information
ﬂow, some of these processes should run asynchronously to properly mimic human visual system. STAR-RT runs
on a single thread and avoids this problem by design, but any future implementations would have to address the
synchronization of recurrent processes.
Figure 13: Image of the game screen taken with a Point Grey Flea3 camera (foveation is added at post-processing). Because of the
lens distortion the rooftop surface is slightly bowed inwards. Ghosting is also visible as a replica of the previous frame superimposed
on top of the current frame. In addition, a Moiré interference pattern can be seen in the image.
To date, many of the implementations of Visual Routines and our implementation of Cognitive Programs focused
primarily on the synthetic images. However, for many visual tasks a physical video camera might be required, which
would introduce an additional challenge. For instance, consider the task of playing a game such as Canabalt with
a real camera feed used as input instead of screenshots. Our preliminary experiments show that camera images are
much harder to work with because of the ghosting, motion blur, lens distortions and interference patterns introduced
by the monitor. These artifacts can be clearly seen in the Figure 13. In particular, signiﬁcant motion blur is present
even when ﬁlming at the high frame rate of 60 fps.
In conclusion, STAR-RT implements all major components of STAR such as ﬁxation control, task working
memory, visual working memory with the blackboard, relevant elements of the visual attention executive (excluding
the parts that interact with the full visual hierarchy) and a reasonable approximation of visual hierarchy. These
components are applied to playing two closed-source games in real time using only visual information that would
be available to a human player. Although STAR-RT demonstrates some similarities to human player behavior by
design (e.g. ﬁxation patterns), they may be hard to quantify.
Since all of the components of the system are tightly interconnected, it is not possible to evaluate precisely
how each of them aﬀects the performance of STAR-RT as the removal of any part of the system would lead to the
17

system not being able to play the game. For instance, if AIM saliency is removed, then many more samples would
be passed to the object classiﬁcation stage, which in turn would increase the processing time and add extra noise
due to the classiﬁcation errors.
The possible applications for STAR-RT can be extended beyond what was presented in this paper. For example,
a system based on human vision and provided with the same information as a human player, might be useful to
imitate human player performance. This topic has recently been of interest to the game AI community. Such
system would also make more modern games available for experimentation, since most of AI research has been done
on emulators of outdated console games. Finally, a framework for performing complex visual tasks has a direct
application in mobile robotics, especially for tasks that involve active vision and interaction with the environment
in real time.
Acknowledgment
This research was supported by several sources, through grants to the second author, for which all the authors are
grateful: Air Force Oﬃce of Scientiﬁc Research (FA9550-14-1-0393), Oﬃce of Naval Research (N00178-15-P-4873),
the Canada Research Chairs Program (950-219525), and the Natural Sciences and Engineering Research Council of
Canada (RGPIN/4557-2011).
References
[1] Agre, P. E., Chapman, D., 1987. Pengi: An Implementation of a Theory of Activity. In: Proceedings of the
Sixth National Conference on Artiﬁcial Intelligence. Vol. 278. pp. 268–272.
[2] Albus, J. S., 1995. RCS: A reference model architecture for intelligent systems. In: Working Notes: AAAI
Spring Symposium on Lessons Learned for Implemented Software Architectures for Physical Agents.
[3] Amano, K., Goda, N., Nishida, S., Ejima, Y., Takeda, T., Ohtani, Y., 2006. Estimation of the Timing of
Human Visual Perception from Magnetoencephalography. The Journal of Neuroscience 26 (15), 3981–3991.
[4] Bello, P., Bridewell, W., Wasylyshyn, C., 2016. Attentive and Pre-Attentive Processes in Multiple Object
Tracking: A Computational Investigation Modeling Object Construction and Tracking. In: Proceedings of the
38th Annual Meeting of the Cognitive Science Society.
[5] Benjamin, D. P., Funk, C., Lyons, D., 2013. A cognitive approach to vision for a mobile robot. SPIE Defense,
Security, and Sensing.
[6] Bonasso, R. P., Firby, R. J., Gat, E., Kortenkamp, D., Miller, D. P., Slack, M. G., 1997. Experiences with an
architecture for intelligent, reactive agents. Journal of Experimental & Theoretical Artiﬁcial Intelligence (2-3),
187–202.
[7] Borovička, T., Špetlík, R., Rymeš, K., 2014. DataLab Birds Angry Birds AI.
[8] Brainard, D. H., 1997. The Psychophysics Toolbox. Spatial Vision 10, 433–436.
[9] Bruce, N., Tsotsos, J., 2007. Attention based on information maximization. In: Journal of Vision. Vol. 7. pp.
950–950.
[10] Chapman, D., 1992. Vision, Instruction, and Action. MIT Press, Cambridge, MA.
[11] Corbetta, M., Shulman, G. L., 2002. Control of goal-directed and stimulus-driven attention in the brain. Nature
reviews neuroscience 3 (3), 201–215.
[12] Douglas, D. H., Peucker, T. K., 1973. Algorithms for the Reduction of the Number of Points Required To Rep-
resent a Digitized Line or Its Caricature. Cartographica: The International Journal for Geographic Information
and Geovisualization 10 (2), 112–122.
18

[13] Fayman, J. A., Rivlin, E., Christensen, H. I., 1999. AV-Shell, an Environment for Autonomous Robotic Appli-
cations Using Active Vision. In: Auton Robots. Vol. 6. pp. 21–38.
[14] Fukunaga, K., Hostetler, L., 1975. The estimation of the gradient of a density function, with applications in
pattern recognition. IEEE Transactions on Information Theory 21 (1), 32–40.
[15] Halelamien, N. S., Touretzky, D. S., 2004. Visual Routines for Spatial Cognition on a Mobile Robot. Ph.D.
thesis.
[16] Hart, P. E., Nilsson, N. J., Raphael, B., 1968. A Formal Basis for the Heuristic Determination of Minimum
Cost Paths. IEEE Transactions on Systems Science and Cybernetics 4 (2), 100–107.
[17] Hayhoe, M., 2000. Vision Using Routines: A Functional Account of Vision. Visual Cognition 7 (1997), 43–64.
[18] Horswill, I., 1995. Visual Routines and Visual Search:
A Real-Time Implementation and an Automata-
Theoretic Analysis. In: Proceedings of the Fourteenth International Joint Conference on Artiﬁcial Intelligence.
Vol. 2. pp. 56–63.
[19] Ianni, G., Calimeri, F., Fink, M., Germano, S., Humenberger, A., Redl, C., Stepanova, D., Tucci, A., Wimmer,
A., 2015. Angry-HEX: an Artiﬁcial Player for Angry Birds Based on Declarative Knowledge Bases. IEEE
Transactions on Computational Intelligence and AI in Games 8 (2), 128–139.
[20] Itti, L., Rees, G., Tsotsos, J. K., 2005. Neurobiology of attention. Academic Press.
[21] Just, M. A., Varma, S., 2007. The organization of thinking: What functional brain imaging reveals about the
neuroarchitecture of complex cognition. Cognitive, aﬀective & behavioral neuroscience 7 (3), 153–191.
[22] Kotseruba, I., 2016. Visual Attention in Dynamic Environments and Its Application To Playing Online Games.
Ph.D. thesis, York University.
[23] Kruijne, W., Tsotsos, J. K., 2011. Visuo-cognitive Routines: reinterpreting the theory of visual routines as a
framework for visual cognition. Tech. rep.
[24] Laird, J. E., 2002. Research in human-level ai using computer games. Communications of the ACM 45 (1),
32–35.
[25] LeCun, Y., Bengio, Y., 1998. Convolutional Networks for Images, Wpeech, and Time-Series. In: The handbook
of brain theory and neural networks. MIT Press.
[26] Marr, D., Poggio, T., 1979. A computational theory of human stereo vision. In: Proceedings of the Royal
Society of London. Series B, Biological sciences. Vol. 204. pp. 301–328.
[27] Marshall, J. B., 2006. A self-watching model of analogy-making and perception. Journal of Experimental &
Theoretical Artiﬁcial Intelligence 18 (3), 267–307.
[28] Meyer, D. E., Kieras, D. E., 1997. A Computational Theory of Executive Cognitive Processes and Human
Multiple-Task Performance: Part 1. Basic Mechanisms. Psychological Review 104 (1), 3–65.
[29] Mitchell, D. K., 2003. Advanced Improved Performance Research Integration Tool (IMPRINT) Vetronics Tech-
nology Test Bed Model Development. Tehcnical Report ARL-TN-0208. Army Research Laboratory.
[30] Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M.,
Fidjeland, A. K., Ostrovski, G., Petersen, S., Beattie, C., Sadik, A., Antonoglou, I., King, H., Kumaran, D.,
Wierstra, D., Legg, S., Hassabis, D., 2015. Human-level control through deep reinforcement learning. Nature
518 (7540), 529–533.
[31] Nyamsuren, E., Taatgen, N. A., 2013. Pre-attentive and attentive vision module. Cognitive Systems Research,
211–216.
19

[32] O’Reilly, R. C., Hazy, T. E., Herd, S. A., 2012. The Leabra cognitive architecture: how to play 20 principles
with nature and win! In: The Oxford Handbook of Cognitive Science. pp. 1–31.
[33] Palm, R. B., 2012. Prediction as a candidate for learning deep hierarchical models of data. MSc Thesis. Technical
University of Denmark.
[34] Pisan, Y., 1995. A Visual Routines Based Model of Graph Understanding. In: Proc. 17th Annual Conference
of the Cognitive Science Society.
[35] Rao, R. P. N., Ballard, D. H., 1995. An active vision architecture based on iconic representations. Artiﬁcial
Intelligence 78 (1-2), 461–505.
[36] Rao, S., 1998. Visual Routines and Attention. Ph.D. thesis.
[37] Roelfsema, P. R., 2005. Elemental operations in vision. Trends in Cognitive Sciences 9 (5), 226–233.
[38] Rohrer, B., 2012. BECCA: Reintegrating AI for natural world interaction. In: AAAI Spring Symposium:
Designing Intelligent Robots. AAAI Technical Report SS-12-02.
[39] Rothenstein, A. L., Tsotsos, J. K., 2014. Attentional modulation and selection–an integrated approach. PloS
one 9 (6), e99681.
[40] Salgian, G., 1998. Tactical Driving Using Visual Routines. Ph.D. thesis.
[41] Strasburger, H., Rentschler, I., Jüttner, M., 2011. Peripheral vision and pattern recognition: A review. Journal
of vision 11 (5), 13.
[42] Togelius, J., Shaker, N., Karakovskiy, S., Yannakakis, G. N., 2013. The Mario AI Championship 2009-2012. AI
Magazine 34 (3), 89–92.
[43] Tsotsos, J., Kotseruba, I., Wloka, C., 2016. A focus on selection for ﬁxation. Journal of Eye Movement Research
9 (5).
[44] Tsotsos, J., Womelsdorf, T., 2016. Visual tasks lead to unique sequences of cyclic attentional signals. Journal
of Vision 16 (12).
[45] Tsotsos, J. K., 1992. Image Understanding. In: Encyclopedia of Artiﬁcial Intelligence. pp. 641–663.
[46] Tsotsos, J. K., 2011. A computational perspective on visual attention. MIT Press.
[47] Tsotsos, J. K., Culhane, S. M., Kei Wai, W. Y., Lai, Y., Davis, N., Nuﬂo, F., 1995. Modeling visual attention
via selective tuning. Artiﬁcial Intelligence 78 (1-2), 507–545.
[48] Tsotsos, J. K., Kruijne, W., 2014. Cognitive programs: Software for attention’s executive. Frontiers in Psy-
chology 5, 1–16.
[49] Ullman, S., 2013. Visual routines. Readings in Cognitive Science: A Perspective from Psychology and Artiﬁcial
Intelligence 18 (1-3), 548–579.
[50] Van Den Braak, G. J., Nugteren, C., Mesman, B., Corporaal, H., 2011. Fast Hough transform on GPUs:
Exploration of algorithm trade-oﬀs. In: Lecture Notes in Computer Science (including subseries Lecture Notes
in Artiﬁcial Intelligence and Lecture Notes in Bioinformatics). Vol. 6915 LNCS. pp. 611–622.
[51] VanLehn, K., Ball, W., 1989. Goal Reconstruction: How Teton Blends Situated Action and Planned Action.
Tech. rep., Department of Computer Science and Psychology, Carnegie Mellon University.
[52] Vere, S., Bickmore, T., 1990. A basic agent. Computational Intelligence 6 (1), 41–60.
[53] Wintermute, S., 2009. An Overview of Spatial Processing in Soar/SVS Investigator. Technical Report CCA-
TR-2009-01.
20

[54] Wu, K., Otoo, E., Suzuki, K., 2009. Optimizing two-pass connected-component labeling algorithms. Pattern
Analysis and Applications 12 (2), 117–135.
[55] Yi, W., Ballard, D. H., 1995. Routine based models of anticipation in natural behaviors. In: AAAI Fall
Symposium, From Reactive to Anticipatory Cognitive Embodied Systems.
[56] Zhang, J., Lin, Z., Brandt, J., Shen, X., Sclaroﬀ, S., 2016. Top-down neural attention by excitation backprop.
In: ECCV. pp. 543–559.
[57] Zhou, B., Khosla, A., Lapedriza, A., Oliva, A., Torralba, A., 2016. Learning deep features for discriminative
localization. In: CVPR. pp. 2921–2929.
21

