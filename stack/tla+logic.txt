Computing and Informatics, Vol. 20, 2001, 1–28, V 2003-Sep-3
ON THE LOGIC OF TLA+
Stephan Merz
INRIA Lorraine, LORIA, Nancy
e-mail: Stephan.Merz@loria.fr
Abstract. TLA+ is a language intended for the high-level speciﬁcation of reactive,
distributed, and in particular asynchronous systems. Combining the linear-time
temporal logic TLA and classical set-theory, it provides an expressive speciﬁcation
formalism and supports assertional veriﬁcation.
1 A TASTE OF TLA+
The speciﬁcation language TLA+ has been introduced by Leslie Lamport [22] for
the description of reactive and distributed, especially asynchronous systems.
In
this paper, I describe the semantical base of TLA+, which combines the linear-
time temporal logic TLA and Zermelo-Fr¨ankel set theory. My intention is not to
deﬁne a new or extended formalism nor to explain the use of TLA+ in practice.
Lamport’s original work covers much more material than this paper. In particular,
his recent book [27] includes a tutorial introduction to writing speciﬁcations in
TLA+, formally deﬁnes the language of TLA+, and describes the tools that support
it. In contrast, this presentation of TLA+ emphasizes the mathematical machinery
underlying TLA+, explaining Lamport’s choices from a logical perspective. It is
my hope that it will ﬁnd some use for purposes such as comparing speciﬁcation
formalisms or for constructing new tools to support system development in TLA+.
Before we begin exploring the semantics of TLA+, let us have a look at a simple
example that introduces the typical structure of a TLA+ speciﬁcation. The TLA+
module SyncQueueInternal, shown in ﬁgure 1(b), describes an unbounded FIFO
queue, which is illustrated in ﬁgure 1(a). The external interface consists of an input
channel in and an output channel out. Internally, the FIFO maintains a queue q of
values that have been received via in but have not yet been sent via out.
The module consists of three sections, separated by horizontal bars for better
readability, that contain declarations, deﬁnitions, and assertions. This structure of
a module is conventional, but not mandatory: formally, a module is simply a list of

2
S. Merz
-
in
-
out
q
(a) Pictorial representation.
module SyncQueueInternal
extends Sequences
constant Message
variables in, out, q
NoMsg
∆=
choose x : x /∈Message
Init
∆=
q = ⟨⟩∧in = NoMsg ∧out = NoMsg
Enq(m)
∆=
∧in ̸= m
∧in′ = m ∧q′ = Append(q, m)
∧out′ = out
Deq
∆=
∧q ̸= ⟨⟩
∧out′ = Head(q) ∧q′ = Tail(q)
∧in′ = in
Next
∆=
(∃m ∈Message : Enq(m)) ∨Deq
vars
∆=
⟨in, out, q⟩
FifoI
∆=
Init ∧□[Next]vars ∧WFvars(Deq)
theorem
FifoI ⇒∧□(q ∈Seq(Message))
∧□[Deq ⇒out′ ̸= out]vars
∧∀m ∈Message : in = m ⇝out = m
(b) TLA+ speciﬁcation with the internal behavior exposed.
module SyncQueue
constant Message
variables in, out
Internal(q)
∆=
instance SyncQueueInternal
Fifo
∆=
∃∃∃∃∃∃q : Internal(q)!FifoI
(c) TLA+ interface speciﬁcation.
Fig. 1. A FIFO queue with synchronous communication.

On the Logic of TLA+
3
statements. Any identiﬁer must have been declared or deﬁned exactly once (possibly
in an imported module) before it is used.
The ﬁrst section declares SyncQueueInternal to be based on the standard TLA+
module Sequences, which deﬁnes ﬁnite sequences and associated operations. Next,
we ﬁnd a declaration of the module parameters. The constant parameter Message
intuitively represents the set of messages that are to be sent via the FIFO queue.
The variable parameters in, out, and q represent the current state of the queue as
shown in ﬁgure 1(a); their values will change as messages are received and forwarded.
The second section contains a list of deﬁnitions, which constitute the main body
of the speciﬁcation. The constant NoMsg is deﬁned to equal some value that is not
an element of the set Message (section 4 explains why this deﬁnition is sensible).
The state predicate Init identiﬁes legal initial states of the speciﬁcation: the value
of q should be the empty sequence ⟨⟩, while both in and out should equal the value
NoMsg. For any value m, the formula Enq(m) characterizes state transitions that
correspond to an “enqueue” action1: we require m to be diﬀerent from the current
value of in so that the queue can recognize that the input channel has changed.
(This condition is not essential, but is introduced mainly for expository purposes.
An implementation could for example instantiate the parameter Message by a set of
pairs consisting of the underlying data and an extra bit, which serves to distinguish
two successive enqueue actions for the same data.) The value of the variable in
at the state following the transition, denoted by in′, will be m, and the new value
of q is obtained by appending m at the end of whatever value q contains before
the transition. Finally, we stipulate that the output channel out should not change
during an enqueue action.The deﬁnition of the dequeue action Deq is similar. The
action Next is deﬁned as the disjunction of all enqueue actions Enq(m), for m in
Message, and of the dequeue action Deq.
The main deﬁnition of module SyncQueueInternal is that of the temporal for-
mula FifoI , representing the “internal” speciﬁcation of the FIFO queue. It is written
as a conjunction: the ﬁrst conjunct Init asserts that the ﬁrst state of any behavior
satisfying FifoI must respect the initial condition. The second conjunct speciﬁes
the next-state relation of the queue. More precisely, it asserts that every transi-
tion allowed by FifoI must either respect the formula Next or leave the expression
vars unchanged; the latter is deﬁned as the tuple ⟨in, out, q⟩containing the state
variables of interest. Because the value of a tuple is unchanged if and only if all
its components are unchanged, this formula admits “stuttering steps” that do not
aﬀect the variables of interest. In a larger system that contains the FIFO queue
as a component, such steps may represent actions of diﬀerent components. The
ﬁnal conjunct of formula FifoI asserts a condition of weak fairness concerning the
action Deq. It rules out behaviors where from some state onward, the Deq action
is always enabled, but never occurs. Section 2 explores in more detail the temporal
1 In this formula and throughout the paper, we use a standard TLA+ notation that
displays multi-line conjunctions and disjunctions as a list “bulleted” by the connective.
This layout makes long formulas easier to read and reduces the number of parentheses.

4
S. Merz
logic TLA that underlies TLA+, and discusses the fundamental concept of stuttering
invariance.
The third section of module SyncQueueInternal asserts a theorem: it claims
that the formula shown follows from the deﬁnitions. (In general, a module may state
assumptions about constants, and theorems should then follow from the deﬁnitions
and the stated or imported assumptions.) In a loose reading, the assertion of a
theorem in a module can be regarded merely as a comment that highlights the
speciﬁer’s intuitions. Formally, however, a theorem represents a proof obligation that
must be discharged for the module to be correct, and we will turn to proof rules for
veriﬁcation in section 3. The theorem asserted of module SyncQueueInternal states
that every behavior that satisﬁes formula FifoI has the following properties:
• at every state, the value of the variable q is a ﬁnite sequence whose elements are
contained in Message,
• every Deq step changes the value of the output channel out, and
• every message that appears on the input channel will eventually be output.
The current version of TLA+ described in [27] does not contain a language for
writing proofs, although Lamport advocates a hierarchical proof notation [26].
Like HOL [16] and other logical speciﬁcation languages, TLA+ is declarative:
the names of formulas such as Init, Next or FifoI are formally irrelevant, although
it is good practice to make them meaningful. The meaning of a formula can always
be uniquely and compositionally determined from the meaning of its subformulas,
and how to do this is the main subject of the present paper. As in any logic, there
are many logically equivalent ways to express a speciﬁcation. For example, we could
have replaced the deﬁnitions of Enq and Next by
Enq
∆=
∧in′ ∈Message ∧in′ ̸= in
∧q′ = Append(q, in′) ∧out′ = out
Next
∆=
Enq ∨Deq
without changing the meaning of formula FifoI .
TLA+ does not hide the complexity of a system by using built-in data types; as
we will see in section 4, every value is just a set. Similarly, it does not presuppose
any ﬁxed system model such as shared-variable or message-passing concurrency,
synchronous or asynchronous communication, etc. Its expressiveness comes from
the unfettered use of set theory and the mechanism of deﬁnitional extension. For
our example, we have chosen the internal variable q to change at the same time as the
interface variables in and out, representing a synchronous style of communication.
A speciﬁcation of a FIFO queue using asynchronous communication channels is
presented in Lamport’s book [27, ch. 4].
The speciﬁcations of module SyncQueueInternal describe the behavior of the
FIFO queue in terms of the three variables in, out, and q. One important principle
in writing speciﬁcations is that of information hiding, which requires a component

On the Logic of TLA+
5
speciﬁcation not to reveal the internal structure (or “implementation details”) of
the component. In our example, the variable q is such an implementation detail:
as illustrated by the box in ﬁgure 1(a), only the behavior of the externally visi-
ble variables in and out should be constrained by the queue speciﬁcation. Module
SyncQueue, shown in ﬁgure 1(c), contains an interface speciﬁcation of the FIFO
queue based on the previous speciﬁcation. In fact, it declares in and out as its only
variable parameters. The following line instantiates the previously discussed module
SyncQueueInternal: any operator Op deﬁned in that module can be referenced as
Internal(q)!Op in module SyncQueue. The general form of instantiation in TLA+
allows for substitution of expressions for module parameters; any remaining param-
eters are implicitly instantiated with the identiﬁer of the same name valid at the
point of instantiation; it is an error if that identiﬁer has not been declared or deﬁned.
In our case, the parameters Message, in, and out of module SyncQueueInternal are
instantiated by the corresponding parameters of module SyncQueue, whereas pa-
rameter q is instantiated by the local parameter of the operator Internal.
Module SyncQueue then deﬁnes the formula Fifo, representing the interface
speciﬁcation of the FIFO queue, as the formula obtained from Internal(q)!FifoI by
existential quantiﬁcation over q. This formula is satisﬁed by every behavior where
in and out take the values as described by the internal speciﬁcation, but where q
may take arbitrary values. (The precise semantics is deﬁned in section 2.4.) In this
respect, existential quantiﬁcation represents hiding of internal state components,
and formula Fifo speciﬁes the interface of the FIFO queue.
2 TLA: THE TEMPORAL LOGIC OF ACTIONS
TLA+ combines TLA, the Temporal Logic of Actions [25], and mathematical set
theory.
We now present the semantics of TLA, while sections 3 and 4 explore
the veriﬁcation of temporal formulas and the speciﬁcation of data structures in set
theory. Again, we emphasize that this exposition is aimed at a precise deﬁnition
of TLA as a logical language; it does not attempt to explain how TLA is used to
specify algorithms or systems.
2.1 Rationale
The logic of time has its origins in philosophy and linguistics, where it was in-
tended to formalize temporal references in natural language [21, 34]. Around 1975,
Pnueli [33] and others recognized that such logics could be useful as a basis for
the semantics of computer programs. In particular, traditional formalisms based
on pre- and post-conditions were found to be ill-suited for the description of re-
active systems that are continuously interacting with their environment and that
are not necessarily intended to terminate. Temporal logic, as it came to be called
in computer science, oﬀered an elegant framework to describe safety and liveness
properties [10, 24] of reactive systems. Diﬀerent dialects of temporal logic can be

6
S. Merz
distinguished according to the properties assumed of the underlying model of time
(e.g., discrete or dense) and to the connectives oﬀered to refer to diﬀerent moments
in time (e.g., future vs. past references). For computer science applications, the most
controversial distinction has been between linear-time and branching-time logics. In
the linear-time view, a system is identiﬁed with the set of its executions, modeled
as inﬁnite sequences of states, whereas the branching-time view also considers the
branching structure of a system. Linear-time temporal logics, including TLA, suﬃce
to formulate correctness properties that hold of all the runs of a system, whereas
branching-time temporal logics can also express possibility properties such as the
existence of a path, from every reachable state, to a “reset” state. The discussion of
the relative merits and deﬁciencies of these two kinds of temporal logics is beyond
the scope of this paper, but see, e.g., Vardi [38] for a recent contribution to this
subject, with many references to earlier papers.
Despite initial enthusiasm about the usefulness of temporal logic as a language
to describe individual system properties, attempts to actually write complete system
speciﬁcations in temporal logic revealed that not even a component as simple as a
FIFO queue could be unambiguously speciﬁed [35]. This observation has led many
researchers to propose that reactive systems should be modeled by some variant
of state machines while temporal logic was retained as a high-level language to
describe the correctness properties. A major breakthrough came with the insight
that temporal logic properties are decidable for ﬁnite-state models, and such model
checking techniques [13] are nowadays routine for the debugging of hardware circuits
and communication protocols.
Another weakness of standard temporal logic becomes apparent when one at-
tempts to compare two speciﬁcations of the same system, written at diﬀerent levels
of abstraction. Speciﬁcally, atomic system actions are usually described via a “next-
state” operator, but the “grain of atomicity” typically changes during reﬁnement,
complicating comparisons between speciﬁcations. For example, we might want to
reﬁne the speciﬁcation of the FIFO queue of ﬁgure 1(b) such that the operation
of appending an element to a queue is described as a sequence of more elementary
assignments.
TLA has been designed as a formalism where system speciﬁcations and their
properties are expressed in the same language, and where reﬁnement is reduced
to elementary logic. The problems mentioned above are addressed in the follow-
ing ways: “internal” speciﬁcations are written by deﬁning their initial conditions
and next-state relations, resembling the description of state machines, and are aug-
mented by liveness and fairness conditions. Abstractness in the sense of information
hiding is ensured by quantiﬁcation over state variables. The reﬁnement problem is
solved by systematically allowing for stuttering steps that do not change the val-
ues of the state variables of interest; an implementation is allowed to reﬁne such
high-level stuttering into lower-level state changes. Similar ideas can be found in
Back’s reﬁnement calculus [11] and in more recent versions of Abrial’s B method [9].
However, in order to prevent inﬁnite stuttering, these formalisms require side con-
ditions that are expressed in terms of well-founded orderings. Temporal logic can

On the Logic of TLA+
7
state such requirements more abstractly in terms of high-level fairness conditions
that must be preserved by a reﬁnement, using any combination of fairness conditions
and arguments based on well-founded orderings.
Based on these concepts, TLA provides a uniﬁed logical language to express
system speciﬁcations and their properties. A single set of logical rules is used for
system veriﬁcation and for proving reﬁnement.
2.2 Transition formulas
The language of TLA is two-tiered: the base tier contains formulas that describe
states and state transitions, whereas the top tier consists of temporal formulas that
are evaluated over inﬁnite sequences of states. In this section, we deﬁne the syntax
and semantics of transition formulas, whereas the following sections will consider
temporal formulas. Because transition formulas are just ordinary (untyped, ﬁrst-
order) predicate logic, this section can be quite brief.
Assume a given signature of ﬁrst-order predicate logic, consisting of:
• at most denumerable sets LF and LP of function and predicate symbols, each
symbol equipped with its arity, and
• a denumerable set V of variables, partitioned into denumerable sets VF and VR
of ﬂexible and rigid variables.
These sets should be disjoint from one another; moreover, no variable in V should
be of the form v ′. By VF ′, we denote the set {v ′
|
v ∈VF} of primed ﬂexible
variables, and by VE, the union V ∪VF ′ of primed and unprimed variable symbols.
Transition functions and transition predicates (also called actions) are terms and
formulas built from the symbols in LF and LP, and from the variables in VE. For
example, if f is a ternary function symbol, p is a unary predicate symbol, x ∈VR,
and v ∈VF, then the term e deﬁned as f (v, x, v ′) is a transition function, and the
formula C deﬁned as ∃v ′ : p(f (v, x, v ′))∧¬(v ′ = x) is an action. We omit a formal
inductive deﬁnition of the syntax of transition functions and formulas. Collectively,
we use the term transition formula to refer to transition functions and predicates.
The semantics of transition formulas is also unsurprising. It is based on a ﬁrst-
order interpretation, which deﬁnes a universe of values and interprets each symbol
in LF by a function and each symbol in LP by a relation of appropriate arities.
In preparation for the semantics of temporal formulas, we distinguish between the
valuations of ﬂexible and rigid variables. A state is a mapping of the ﬂexible variables
in VF to values of the universe. Given two states s and t and a valuation ξ of the
rigid variables in VR, we can deﬁne the valuation αs,t,ξ of the variables in VE as the
mapping such that αs,t,ξ(x) = ξ(x) for x ∈VR, αs,t,ξ(v) = s(v) for v ∈VF, and
αs,t,ξ(v ′) = t(v) for v ′ ∈VF ′. The semantics of a transition function or transition
formula E, written JEKξ
s,t, is then simply the standard predicate logic semantics of
E with respect to the extended valuation αs,t,ξ.

8
S. Merz
We say that a transition predicate A is valid for the interpretation iﬀJAKξ
s,t is
true for all states s, t and all valuations ξ. It is satisﬁable iﬀJAKξ
s,t is true for some
s, t, and ξ. Similarly, A is valid (satisﬁable) for a class C of interpretations iﬀit is
valid for all (satisﬁable for some) interpretations in C.
Finally, the notions of free and bound variables in a transition formula are
deﬁned as usual, as is the notion of substitution of a transition function a for a
variable v, written E[a/v]. We assume that capture of free variables in a substitution
is avoided by an implicit renaming of bound variables. For example, the set of free
variables of the transition function e shown above is {x, v, v ′}, and v ′ is a bound
variable of the action C. We emphasize that at the level of transition formulas, we
consider v and v ′ to be distinct, unrelated variables.
State formulas are transition formulas that do not contain free primed ﬂexible
variables. For example, the action C above is actually a state predicate. Because
the semantics of state formulas only depends on a single state, we simply write
JPKξ
s when P is a state formula. The subclass of constant formulas is even more
restrictive in that only free occurrences of rigid variables are allowed; consequently,
their semantics depends only on the valuation ξ. (Arguably, rigid formulas would
be a more appropriate name for this class, but the TLA literature consistently uses
the designation constant formulas.)
TLA introduces some speciﬁc abbreviations at the level of transition formulas. If
E is a state formula then E ′ is the transition formula obtained from E by replacing
each free occurrence of a ﬂexible variable v in E with its primed counterpart v ′
(where bound variables are renamed as necessary). For example, since C is a state
formula, we may build the formula C ′ by substituting v ′ for v. Since v ′ is bound in
C, this results in the formula ∃y : p(f (v ′, x, y)) ∧¬(y = x), up to renaming of the
bound variable.
For an action A, the state formula Enabled A is obtained by existential quan-
tiﬁcation over all primed ﬂexible variables that occur free in A. Thus, JEnabled AKξ
s
holds if JAKξ
s,t holds for some state t, that is, if action A may occur in state s. For
actions A and B, the action A · B is deﬁned as ∃z : A[z/v ′] ∧B[z/v] where v is a
list of all ﬂexible variables v i such that v i occurs free in B or v ′
i occurs free in A,
and z is a corresponding list of fresh variables. It follows that JA · BKξ
s,t holds iﬀ
both JAKξ
s,u and JBKξ
u,t hold for some state u.
Because these abbreviations are deﬁned in terms of quantiﬁcation and substitu-
tion, their interplay can be quite delicate. For example, Enabled P is by deﬁnition
just P for any state predicate P, and therefore (Enabled P)′ equals P ′. On the
other hand, Enabled (P ′) is a constant formula—if P does not contain any rigid
variables then Enabled (P ′) is valid iﬀP is satisﬁable.
For an action A and a state function t we write [A]t to denote A ∨t′ = t, and
⟨A⟩t for A ∧¬(t′ = t). Therefore, [A]t requires A to hold only if t changes value
during a transition, whereas the dual formula ⟨A⟩t strengthens A in requiring that
t changes value while A holds true.

On the Logic of TLA+
9
2.3 Temporal formulas
We now turn to the temporal tier of TLA. Because it is less familiar than ﬁrst-order
predicate logic and because we wish to give precise deﬁnitions, we devote much more
space to its presentation. However, the temporal formulas that one actually writes
in TLA+ speciﬁcations usually follow a standard idiom, and more than 95% of a
typical speciﬁcation consist of deﬁnitions at the transition level.
The (temporal) formulas of TLA are inductively deﬁned as follows:
• Every state formula is a formula.
• Boolean combinations (connectives including ¬, ∧, ∨, ⇒, and ≡) of formulas
are formulas.
• If F is a formula then so is □F (“always F”).
• If A is an action and t is a state function then □[A]t (“always square A sub t”)
is a formula.
• If F is a formula and x is a rigid variable then ∃x : F is a formula.
• If F is a formula and v is a ﬂexible variable then ∃∃∃∃∃∃v : F is a formula.
In particular, an action A by itself is not a temporal formula, not even in the
form [A]t. Actions can occur only in subformulas □[A]t.
To determine free and bound variables at the temporal level, we do not dis-
tinguish between primed and unprimed occurrences of ﬂexible variables, and the
quantiﬁer ∃∃∃∃∃∃binds both kinds of occurrences. More formally, the set of free vari-
ables of a temporal formula is a subset of VF ∪VR. The free occurrences of variables
in a state formula P, considered as a temporal formula, are precisely the free occur-
rences in P, considered as a transition formula. However, variable v ∈VF has a free
occurrence in □[A]t iﬀeither v or v ′ has a free occurence in A or in t. Similarly,
substitution F[e/v] of a state function e for a ﬂexible variable v substitutes both
e for v and e′ for v ′ in the action subformulas of F, again after renaming bound
variables as necessary. For example, substitution of the state function h(v), where
h ∈LF and v ∈VF, for w in the temporal formula
∃∃∃∃∃∃v : p(v, w) ∧□[q(v, f (w, v ′), w ′)]g(v,w)
results in the formula (up to renaming of the bound variable)
∃∃∃∃∃∃u : p(u, h(v)) ∧□[q(u, f (h(v), u′), h(v ′))]g(u,h(v))
Because state formulas do not contain free occurrences of primed ﬂexible variables,
the deﬁnitions of substitutions for transition formulas and for temporal formulas
agree on state formulas. The substitution of a (proper) transition function for a
variable is not allowed as it could result in an expression that is not a well-formed
TLA formula.

10
S. Merz
The semantics of temporal formulas is deﬁned in terms of behaviors, which are
inﬁnite sequences of states, and of valuations of the rigid variables. For a behavior
σ = s0s1 . . ., we write σi to refer to state si, and σ|i to denote the suﬃx sisi+1 . . ..
The following inductive deﬁnition assigns a truth value JFKξ
σ ∈{t, f} to every for-
mula F:
• JPKξ
σ = JPKξ
σ0: state formulas are evaluated at the initial state of the behavior.
• The semantics of Boolean operators is the usual one.
• J□FKξ
σ = t iﬀJFKξ
σ|i = t for all i ∈N: this is the usual clause from linear-time
temporal logic.
• J□[A]tKξ
σ = t iﬀfor all i ∈N, JtKξ
σi = JtKξ
σi+1 or JAKξ
σi,σi+1 = t: such a formula
holds iﬀevery state transition in σ that does not leave t unchanged satisﬁes A.
• J∃x : FKξ
σ = t iﬀJFKη
σ = t for some valuation η such that η(y) = ξ(y) for all
y ∈VR \ {x}: this is again the usual deﬁnition from predicate logic.
• The semantics of formulas ∃∃∃∃∃∃v : F will be deﬁned in section 2.4 below.
Abbreviations for temporal formulas include the universal quantiﬁers ∀and
∀∀∀∀∀∀over rigid and ﬂexible variables.
The formula ♦F (“eventually F”), deﬁned
as ¬□¬F, asserts that F holds of some suﬃx of the behavior; similarly, ♦⟨A⟩t
(“eventually angle A sub t”) is deﬁned as ¬□[¬A]t and asserts that some future
transition satisﬁes A and changes the value of t.
We write F ⇝G (“F leads
to G”) for the formula □(F ⇒♦G), which asserts that every occurrence of F will
eventually be followed by an occurrence of G. Combinations of the “always” and
“eventually” operators express “inﬁnitely often” (□♦) and “almost always” (♦□).
Observe that a formula can be both inﬁnitely often true and inﬁnitely often false,
thus “almost always” is strictly stronger than “inﬁnitely often”. These combinations
are especially important as the building blocks to formulate fairness conditions. In
particular, weak and strong fairness for an action ⟨A⟩t are deﬁned as
WFt(A)
∆=
(□♦¬Enabled ⟨A⟩t) ∨□♦⟨A⟩t
(≡♦□Enabled ⟨A⟩t ⇒□♦⟨A⟩t)
SFt(A)
∆=
(♦□¬Enabled ⟨A⟩t) ∨□♦⟨A⟩t
(≡□♦Enabled ⟨A⟩t ⇒□♦⟨A⟩t)
Weak fairness stipulates that an action ⟨A⟩t occurs inﬁnitely often during a
behavior if it is almost always enabled; strong fairness even requires that the action
must happen inﬁnitely often if it is inﬁnitely often, but not necessarily persistently,
enabled.
2.4 Stuttering invariance and quantiﬁcation
Formulas □[A]t allow for “stuttering”: besides state transitions that satisfy A, they
also admit any transitions that do not change the state function t. In particular,
duplications of states can not be observed by formulas of this form.
Stuttering
invariance is important in connection with reﬁnement and composition [24].

On the Logic of TLA+
11
To formalize this notion, for a set V of ﬂexible variables we deﬁne two states s
and t to be V-equivalent, written s =V t, iﬀs(v) = t(v) for all v ∈V . We deﬁne V-
stuttering equivalence, written ≈V , as the smallest equivalence relation on behaviors
that contains ρ ◦⟨s⟩◦σ and ρ ◦⟨t, u⟩◦σ, for any ﬁnite sequence of states ρ, inﬁnite
sequence of states σ, and V-equivalent states s =V t =V u. Intuitively, V-stuttering
equivalence allows for duplication and deletion of ﬁnite repetitions of V-equivalent
states. In particular, the relation ≈VF, which we also write as ≈, identiﬁes two
behaviors that diﬀer by duplications or deletions of identical states.
The fundamental theorem asserting that TLA is not expressive enough to dis-
tinguish stuttering-equivalent behaviors can now be formally stated as follows:
Theorem 1 (stuttering invariance). Assume that F is a TLA formula whose free
ﬂexible variables are among V, that σ ≈V τ are V-stuttering equivalent behaviors,
and that ξ is a valuation. Then JFKξ
σ = JFKξ
τ.
For TLA formulas without quantiﬁcation over ﬂexible variables, it is not hard
to prove theorem 1 from the semantic clauses of section 2.3 by induction on the
structure of formulas [25, 6]. On the other hand, quantiﬁcation over ﬂexible variables
requires some attention: the “obvious” semantic clause for formulas ∃∃∃∃∃∃v : F would
read J∃∃∃∃∃∃v : FKξ
σ = t iﬀJFKξ
τ = t for some behavior τ whose states τ i agree with
the corresponding states σi on all variables except for v. This deﬁnition, however,
would not preserve stuttering invariance. For example, consider the formula
F
∆=
v = c ∧w = c ∧♦(w ̸= c) ∧□[v ̸= c]w
-
σ
v
w
c
c
d
c
d
d
· · ·
· · ·
that requires that both variables v and w initially equal the constant c, that eventu-
ally, w is diﬀerent from c, and that v must be diﬀerent from c whenever w changes
value. Any behavior σ that satisﬁes F must therefore contain two distinct transi-
tions, the ﬁrst of which changes v from c to some other value (but preserving the
value of w), while the second transition changes w, as indicated in the picture. In
particular, σ1(w) must equal c, hence the above deﬁnition of quantiﬁcation implies
that τ 1(w) must equal c, for any behavior τ satisfying the formula ∃∃∃∃∃∃v : F. How-
ever, the behavior τ obtained from σ by removing the second state (where v equals d
but w equals c) is {w}-stuttering equivalent to σ. Because w is the only free ﬂexible
variable of ∃∃∃∃∃∃v : F, theorem 1 asserts that τ should satisfy ∃∃∃∃∃∃v : F, although τ 1(w)
is diﬀerent from c.
In other words, the deﬁnition of quantiﬁcation over ﬂexible variables must allow
for the removal of transitions that modify only the bound variables. This observation
motivates the following semantic clause for quantiﬁed formulas: for a ﬂexible variable
v, we say that two behaviors σ and τ are equal up to v iﬀσi and τ i agree on all
variables in VF \{v}, for all i ∈N. We say that σ and τ are similar up to v, written
σ ≃v τ iﬀthere exist behaviors σ′ and τ ′ such that
• σ and σ′ are stuttering equivalent (σ ≈σ′),

12
S. Merz
• σ′ and τ ′ are equal up to v, and
• τ and τ ′ are again stuttering equivalent (τ ≈τ ′).
Now, we deﬁne J∃∃∃∃∃∃v : FKξ
σ = t iﬀJFKξ
τ = t holds for some behavior τ similar to
σ up to v. Because the deﬁnition of ≃v explicitly allows for stuttering, theorem 1
is preserved for all TLA formulas.
2.5 Properties, reﬁnement, and composition
As we have seen in the example of the FIFO queue, TLA uses the same formal-
ism of temporal logic to represent system speciﬁcations and properties.
System
speciﬁcations are usually written in the form
∃∃∃∃∃∃x : Init ∧□[Next]v ∧L
where v is the list of all relevant state variables, x is the list of internal (hidden)
variables, Init is a state predicate representing the initial condition, Next is an ac-
tion that describes the next-state relation, usually written as a disjunction of more
elementary actions, and L is a conjunction of formulas WFv(A) or SFv(A) asserting
fairness assumptions of individual disjuncts of Next. However, other forms of spec-
iﬁcations are possible and can occasionally be useful. Asserting that a property F
holds of a speciﬁcation S amounts to saying that every behavior that satisﬁes S must
also satisfy F; in other words, it asserts the validity of the implication S ⇒F. For
example, the theorem asserted in module SyncQueueInternal states three essential
properties of the FIFO queue.
Unlike most other temporal logics, TLA is intended to support stepwise system
development by reﬁnement of speciﬁcations [11]. The basic idea of reﬁnement con-
sists in successively adding implementation detail while preserving the properties
required at an abstract level. In a reﬁnement-based approach to system develop-
ment, one proceeds by writing successive models, each of which introduces some
additional detail while preserving the essential properties of the preceding model.
Fundamental properties of a system can thus be established at high levels of abstrac-
tion, errors can be detected in early phases, and the complexity of formal assurance
is spread over the entire development process. A reﬁnement C preserves all TLA
properties of an abstract speciﬁcation A if and only if for every formula F, if A ⇒F
is valid, then so is C ⇒F. This condition is in turn equivalent to requiring the va-
lidity of C ⇒A. Because C will contain extra variables to represent the lower-level
detail, and because these variables will change in transitions that have no counter-
part at the abstract level, stuttering invariance of TLA formulas is essential to make
validity of implication a reasonable deﬁnition of reﬁnement.
Stuttering invariance is also essential for composition to be representable as
conjunction [18]. In fact, if A and B are TLA speciﬁcations of two components, then
A ∧B describes those behaviors that satisfy both components’ initial conditions,
that allow actions of either process to occur, synchronizing on common variables

On the Logic of TLA+
13
(which represent interfaces between the components), and that satisfy all relevant
liveness properties. In particular, stuttering invariance ensures that each component
may perform local actions without interfering with the speciﬁcation of the other
component.
As a test of these ideas, we might try to prove that two FIFO queues in a row
again implement a FIFO queue. Let us assume that the two queues are connected
by a channel mid, then the above principles seem to imply that the formula2
Fifo[mid/out] ∧Fifo[mid/in] ⇒Fifo
is valid. Unfortunately, this is not true, for the following reason: formula Fifo implies
that the in and out channels never change simultaneously, whereas the conjunction
on the left-hand side allows such changes (if the left-hand queue performs an Enq
action, while the right-hand queue performs a Deq). This technical problem can
be attributed to a design decision taken in the speciﬁcation of the FIFO queue to
disallow simultaneous changes to its input and output interfaces, a speciﬁcation style
known as “interleaving speciﬁcations”. In fact, the argument merely shows that the
composition of two interleaving queues does not implement a interleaving queue.
Choosing an interleaving or a non-interleaving style is an artifact of the model that
represents the actual system; interleaving speciﬁcations are usually easier to write
and to understand. The problem disappears if we explicitly add an “interleaving”
assumption for the composition: the implication
Fifo[mid/out] ∧Fifo[mid/in] ∧□[in′ = in ∨out′ = out]in,out ⇒Fifo
(1)
is valid and its proof will be considered in section 3.5.
2.6 Variations and extensions
We discuss some of the choices that we have made in the presentation of TLA, as
well as possible extensions.
Transition formulas and priming.
Our presentation of TLA is based on stan-
dard ﬁrst-order logic, to the extent possible. In particular, we have deﬁned transition
formulas as formulas of ordinary predicate logic over a large set VE of variables where
v and v ′ are unrelated. An alternative presentation would consider ′ as an operator,
resembling the next-time modality of temporal logic. In fact, this appears to be the
presentation preferred by Lamport [27]. The semantics of temporal formulas is unaf-
fected by the choice of presentation, and the style adopted in this paper corresponds
well to the veriﬁcation rules of TLA, explored in section 3.
2 TLA+ introduces concrete syntax, based on module instantiation, for writing substi-
tutions such as Fifo[mid/out].

14
S. Merz
Compositional veriﬁcation.
We have argued in section 2.5 that composition is
represented in TLA as conjunction. Because components can rarely be expected
to operate correctly in arbitrary environments, their speciﬁcations usually include
some assumptions about the environment. An open system speciﬁcation is one that
does not constrain its environment; it asserts that the component will function cor-
rectly provided that the environment behaves as expected. One way to write such
speciﬁcations is in the form of implications E ⇒M where E describes the environ-
ment assumptions and M , the component speciﬁcation. However, it turns out that
often a stronger form of speciﬁcations is desirable that requires the component to
adhere to its description M for at least as long as the environment has not broken its
obligation E. In particular, when systems are built from “open” component speci-
ﬁcations, this form, written E
+−▷M , allows for a strong composition rule that can
discharge mutual assumptions between components [4, 14]. It can be shown that
the operator
+−▷is actually deﬁnable in TLA, and that the resulting composition
rule can be justiﬁed in terms of an abstract logic of speciﬁcations, supplemented by
principles speciﬁc to TLA [5, 7].
TLA*.
TLA deﬁnes distinct tiers of transition formulas and temporal formulas,
where transition formulas must be guarded by “brackets” to ensure stuttering invari-
ance. Although the separation between the two tiers is natural when writing system
speciﬁcations, it is not a prerequisite to obtaining stuttering invariance. In [32],
I have deﬁned the logic TLA* whose syntax distinguishes the two classes of pure
and impure formulas. Whereas pure formulas of TLA* contain impure formulas in
the same way that temporal formulas of TLA contain transition formulas, impure
formulas generalize transition formulas in that they admit Boolean combinations of
F and dG, where F and G are pure formulas and d is the next-time modality of
temporal logic. For example, the TLA* formula
□

A ⇒d♦⟨B⟩u

t
requires that every ⟨A⟩t action must eventually be followed by ⟨B⟩u. Assuming
appropriate syntactic conventions, TLA* is a generalization of TLA because every
TLA formula is also a TLA* formula, with the same semantics. On the other hand,
it can be shown that every TLA* formula can be expressed in TLA using some
additional quantiﬁers. For example, the TLA* formula above is equivalent to the
TLA formula3
∃∃∃∃∃∃v : ∧□((v = c) ≡♦⟨B⟩u)
∧□[A ⇒v ′ = c]t
where c is a constant and v is a fresh ﬂexible variable. TLA* thus oﬀers a richer
syntax without increasing the expressiveness, allowing high-level requirement spec-
3 Strictly, this equivalence is true only for universes that contain at least two distinct
values; one-element universes are not very interesting.

On the Logic of TLA+
15
iﬁcations to be expressed more directly. On the other hand, the propositional frag-
ment of TLA* admits a rather straightforward axiomatization. (No proof system
is known for propositional TLA, although Abadi [1] proposed a rather involved ax-
iomatization of an early version of TLA that was not invariant under stuttering.)
For example,
□[F ⇒dF]v ⇒(F ⇒□F)
where F is a temporal formula and v is a tuple containing all ﬂexible variables
with free occurrences in F, is a TLA* formulation of the usual induction axiom of
temporal logic; this is a TLA formula only if F is in fact a state formula.
Binary temporal operators.
Unlike standard linear-time temporal logics [30],
TLA does not include binary operators such as until, because they are not necessary
for writing system speciﬁcations, and because they can be confusing, especially when
nested. These operators are, however, deﬁnable in TLA using quantiﬁcation over
ﬂexible variables. For example, suppose that P and Q are state predicates whose
free variables are among w, that v is a ﬂexible variable that does not appear in w,
and that c is a constant. Then P until Q can be deﬁned as the formula
∃∃∃∃∃∃v : ∧(v = c) ≡Q
∧□[(v ̸= c ⇒P) ∧(v ′ = c ≡(v = c ∨Q′))]⟨v,w⟩
∧♦Q
The idea is to use the auxiliary variable v to remember whether Q has already
been true. As long as Q has been false, P is required to hold. For arbitrary TLA
formulas F and G, the formula F until G can be deﬁned along the same lines,
using a technique as shown for the translation of TLA* formulas above.
3 TLA PROOF RULES
Since TLA formulas are used to describe systems as well as their properties, deduc-
tive system veriﬁcation can be based on logical axioms and rules of TLA. More
precisely, a system described by formula Spec has property Prop if and only if
every behavior that satisﬁes Spec also satisﬁes Prop, that is, iﬀthe implication
Spec ⇒Prop is valid over the class of interpretations where the function and predi-
cate symbols have the intended meaning. System veriﬁcation, in principle, therefore
requires reasoning about sets of behaviors. The TLA proof rules are designed to
reduce this temporal reasoning, as far as possible, to the proof of veriﬁcation con-
ditions expressed in the underlying predicate logic, a strategy that is commonly
referred to as assertional reasoning. In this section, we state some typical rules and
illustrate their use; more information can be found elsewhere [25].

16
S. Merz
3.1 Invariants
Invariants characterize the set of states that can be reached during system execution;
they constitute the basic safety properties of interest and are also the starting point
for almost any veriﬁcation attempt. In TLA, an invariant is expressed by a formula
of the form □I where I is a state formula.
A basic rule for proving invariants is given by
I ∧[N ]t ⇒I ′
(INV1)
I ∧□[N ]t ⇒□I
This rule asserts that for every interpretation for which the antecedent I ∧[N ]t ⇒I ′
is a valid transition formula, the consequent I ∧□[N ]t ⇒□I is a valid temporal
formula. The antecedent states that every possible transition (stuttering or not)
preserves I ; thus, if I holds initially it is guaranteed to hold forever. Formally, the
correctness of rule (INV1) is easily established by induction on behaviors. Because
the antecedent is a transition formula, its proof relies on standard axioms and proof
rules of predicate logic, augmented by “data” axioms that characterize the intended
interpretations.
For example, we can use (INV1) to prove the invariant □(q ∈Seq(Message)) of
the FIFO queue speciﬁed in module SyncQueueInternal of ﬁgure 1(b). We have to
prove
FifoI ⇒□(q ∈Seq(Message))
(2)
which, by rule (INV1), the deﬁnition of formula FifoI , and propositional logic can
be reduced to proving
Init
⇒
q ∈Seq(Message)
(3)
q ∈Seq(Message) ∧[Next]vars
⇒
q′ ∈Seq(Message)
(4)
Because the empty sequence is certainly a ﬁnite sequence of messages, (3) follows
from the deﬁnition of Init and appropriate data axioms. Similarly, the proof of (4)
reduces to proving preservation of the invariant under stuttering, Deq, and Enq(m)
actions, for any m ∈Message, all of which are again straightforward.
3.2 Step simulation
The following rule can be used to prove “action invariants”; it relies on a previously
proven state invariant I :
I ∧I ′ ∧[M ]t ⇒[N ]u
(TLA2)
□I ∧□[M ]t ⇒□[N ]u

On the Logic of TLA+
17
In particular, it follows from (TLA2) that the next-state relation can be strengthened
by an invariant:
□I ∧□[M ]t ⇒□[M ∧I ∧I ′]t
Note that the converse of this implication is not valid: the right-hand side holds of
any behavior where t never changes, independently of the value of I .
We may use (TLA2) to prove that the FIFO queue never dequeues the same
value twice in a row:
FifoI ⇒□[Deq ⇒out′ ̸= out]vars
(5)
This proof requires an invariant that in particular asserts that no consecutive ele-
ments of the internal queue are identical:
Inv
∆=
let oq
∆= ⟨out⟩◦q
in
∧in = oq[Len(oq)]
∧∀i ∈1..Len(oq) −1 : oq[i] ̸= oq[i + 1]
We have used some TLA+ syntax in formulating Inv: the local abbreviation oq
denotes the sequence obtained by preﬁxing the current value of the output channel
out to the internal queue q; also, TLA+ represents a sequence s as a function such
that its elements can be accessed as s[1], . . . , s[Len(s)]. Formula Inv asserts that the
current value of the input channel equals the last element of the sequence oq, and
that no two consecutive elements of oq are identical. The proof of FifoI ⇒□Inv
follows the pattern used in proving invariant (2) above, using rule (INV1).
For the proof of (5), rule (TLA2) requires that we show the validity of
Inv ∧Inv ′ ∧[Next]vars ⇒[Deq ⇒out′ ̸= out]vars
(6)
The proof of (6) reduces to the three cases of a stuttering transition, an Enq(m)
action, and a Deq action. Only the last case is non-trivial. Its proof relies on the
deﬁnition of Deq, which implies that q is non-empty and that out′ = Head(q). In
particular, the sequence oq contains at least two elements, and therefore Inv implies
that oq[1], which is just out, is diﬀerent from oq[2], which is Head(q). This suﬃces
to prove out′ ̸= out.
3.3 Liveness properties
Liveness properties, intuitively, assert that something good must eventually hap-
pen [10, 23]. Because formulas □[N ]t are satisﬁed by stuttering behavior and do not
require any progress, the proof of liveness properties must ultimately rely on fairness
properties assumed of the speciﬁcation. TLA provides rules to deduce elementary
liveness properties from the fairness properties assumed of a speciﬁcation; more
complex properties can then be inferred with the help of well-founded orderings.

18
S. Merz
The following rule can be used to prove a leads-to formula from a weak fairness
assumption; a similar rule exists for strong fairness.
I ∧I ′ ∧P ∧[N ]t ⇒P ′ ∨Q′
I ∧I ′ ∧P ∧⟨N ∧A⟩t ⇒Q′
I ∧P ⇒Enabled ⟨A⟩t
(WF1)
□I ∧□[N ]t ∧WFt(A) ⇒(P ⇝Q)
In this rule, P and Q are state predicates, I is again an invariant, [N ]t represents
the next-state relation, and ⟨A⟩t is a “helpful action” [29] for which weak fairness
is assumed. Again, all three premises of (WF1) are transition formulas. To see why
the rule is correct, assume that σ is a behavior satisfying □I ∧□[N ]t ∧WFt(A), and
that P holds of state σi. We have to show that Q holds of some σj with j ≥i. By
the ﬁrst premise, any successor of a state satisfying P has to satisfy P or Q, so P
must hold for as long as Q has not been true. The third premise ensures that in all of
these states, action ⟨A⟩t is enabled, and so the assumption of weak fairness ensures
that eventually ⟨A⟩t occurs, unless Q has become true before, in which case we are
done. Finally, by the second premise, any ⟨A⟩t-successor (which, by assumption, is
in fact an ⟨N ∧A⟩t-successor) of a state satisfying P must satisfy Q, which proves
the claim.
For our running example, we can use rule (WF1) to prove that every message
stored in the queue will eventually move closer to the head of the queue or even to
the output channel. Formally, let the state predicate at(k, x) be deﬁned by
at(k, x)
∆=
k ∈1..Len(q) ∧q[k] = x
We will use (WF1) to prove
FifoI ⇒
 at(k, x) ⇝(out = x ∨at(k −1, x))

(7)
where k and x are rigid variables. The following proof outline illustrates the appli-
cation of rule (WF1), the lower-level steps relying on data axioms are omitted.
1. at(k, x) ∧[Next]vars ⇒at(k, x)′ ∨out′ = x ∨at(k −1, x)′
1.1. at(k, x) ∧m ∈Message ∧Enq(m) ⇒at(k, x)′
1.2. at(k, x) ∧Deq ∧k = 1 ⇒out′ = x
1.3. at(k, x) ∧Deq ∧k > 1 ⇒at(k −1, x)′
1.4. at(k, x) ∧vars′ = vars ⇒at(k, x)′
1.5. Q.E.D.
From steps 1.1–1.4 by the deﬁnitions of Next and at(k, x).
2. at(k, x) ∧⟨Deq ∧Next⟩vars ⇒out′ = x ∨at(k −1, x)′
Follows from steps 1.2 and 1.3 above.
3. at(k, x) ⇒Enabled ⟨Deq⟩vars
For any k, at(k, x) implies that q ̸= ⟨⟩and thus the enabledness condition.

On the Logic of TLA+
19
However, rule (WF1) cannot be used to prove the stronger property that every
input to the queue will eventually be dequeued,
FifoI ⇒∀m ∈Message : in = m ⇝out = m
(8)
because there is no single “helpful action”: the number of Deq actions necessary
to produce the input element on the output channel depends on the length of the
queue. Intuitively, the argument used to establish property (7) must be iterated.
The following rule formalizes this idea as an induction over a well-founded relation
(D, ≻): a binary relation such that there does not exist an inﬁnite descending chain
d 1 ≻d 2 ≻. . . of elements d i ∈D.
(D, ≻) is well−founded
F ⇒∀d ∈D :
 G ⇝(H ∨∃e ∈D : d ≻e ∧G[e/d])

(LATTICE)
F ⇒∀d ∈D : (G ⇝H )
In this rule, d and e are rigid variables such that d does not occur in H and e does
not occur in G. For convenience, we have stated rule (LATTICE) in a language of set
theory where, in particular, ∀x ∈S : F abbreviates the formula ∀x : x ∈S ⇒F.
Unlike the premises of the rules considered so far, the second hypothesis of rule
(LATTICE) is itself a temporal formula that requires that every occurrence of G,
for any value d ∈D, be followed either by an occurrence of H , or again by some
G, for some smaller value e. Because the ﬁrst hypothesis ensures that there cannot
be an inﬁnite descending chain of values in D, eventually H must become true.
In principle, the hypothesis of well-foundedness can itself be expressed in TLA by
asserting the validity of the formula
∧∀d ∈D : ¬(d ≻d)
∧∀∀∀∀∀∀v : □(v ∈D) ∧□[v ≻v ′]v ⇒♦□[false]v
whose ﬁrst conjunct expresses the irreﬂexivity of ≻and whose second conjunct
asserts that any sequence of values in D that can only change by decreasing with
respect to ≻must eventually become stationary. In fact, if this formula is valid over
a given interpretation then ≻is interpreted by a well-founded relation. In system
veriﬁcation, well-foundedness is however usually considered as a “data axiom”.
Choosing (Nat, >), the set of natural numbers with the standard “greater-than”
relation as the well-founded domain, the proof of property (8) follows from property
(7) and the invariant Inv deﬁned in section 3.2 using rule (LATTICE).
Lamport [25] lists further (derived) rules for liveness properties, including intro-
duction rules for proving formulas WFt(A) and SFt(A).
3.4 Simple temporal logic
The proof rules considered so far support the derivation of typical correctness prop-
erties of systems. In addition, TLA satisﬁes standard axioms and rules of linear-time

20
S. Merz
(STL1)
F
□F
(STL4)
□(F ⇒G) ⇒(□F ⇒□G)
(STL2)
□F ⇒F
(STL5)
□(F ∧G) ≡(□F ∧□G)
(STL3)
□□F ≡□F
(STL6)
♦□(F ∧G) ≡(♦□F ∧♦□G)
Fig. 2. Simple temporal logic.
temporal logic that are useful when preparing the application of veriﬁcation rules.
Figure 2 contains the axioms and rules of “simple temporal logic”, adapted from
Lamport [25]. It can be shown that this is just a non-standard presentation of the
modal logic S4.2 [19], implying that these laws by themselves characterize a modal
accessibility relation for □that is reﬂexive, transitive, and locally convex (or con-
ﬂuent). The last condition asserts that for any state s and states t, u that are both
accessible from s there is a state v that is accessible from t and u.
3.5 Quantiﬁer rules
Although we have seen in section 2.4 that the semantics of quantiﬁcation over ﬂexible
variables is non-standard, the elementary proof rules for quantiﬁers are those familiar
from ﬁrst-order logic:
F[c/x] ⇒∃x : F
(∃I)
F ⇒G
(∃E)
(∃x : F) ⇒G
F[t/v] ⇒∃∃∃∃∃∃v : F
(∃∃∃∃∃∃I)
F ⇒G
(∃∃∃∃∃∃E)
(∃∃∃∃∃∃v : F) ⇒G
In these rules, x is a rigid and v is a ﬂexible variable. The elimination rules (∃E)
and (∃∃∃∃∃∃E) require the usual proviso that the bound variable should not be free in
formula G. In the introduction rules, t is a state function, while c is a constant
function. Observe that if we allowed an arbitrary state function in rule (∃I), we
could prove
∃x : □(x = v)
(9)
for any state variable v from the premise □(v = v), provable by (STL1). How-
ever, formula (9) asserts that v remains constant throughout a behavior, which can
obviously not be valid.
Since existential quantiﬁcation over ﬂexible variables corresponds to hiding of
state components, the rules (∃∃∃∃∃∃I) and (∃∃∃∃∃∃E) play a fundamental role in proofs of
reﬁnement for reactive systems.
In this context, the “witness” t is often called
a reﬁnement mapping [2].
For example, the concatenation of the two low-level

On the Logic of TLA+
21
queues provides a suitable reﬁnement mapping to prove the validity of formula (1),
which claimed that two FIFO queues in a row implement a FIFO queue, assuming
interleaving of changes to the input and output channels.
Although the quantiﬁer rules are standard, one should recall from section 2.2
that care has to be taken when substitutions are applied to formulas that are deﬁned
in terms of quantiﬁcation. In particular, the formulas WFt(A) and SFt(A) contain
the subformula Enabled ⟨A⟩t, and therefore, e.g., WFt(A)[e/v] need not be equiv-
alent to the formula WFt[e/v](A[e/v, e′/v ′]). For a more thorough discussion of this
possible pitfall in system veriﬁcation, see Lamport’s original TLA paper [25].
Unfortunately, reﬁnement mappings need not always exist. For example, (∃∃∃∃∃∃I)
cannot be used to prove the valid TLA formula (excluding one-element universes)
∃∃∃∃∃∃v : □♦⟨true⟩v
(10)
that asserts the existence of a ﬂexible variable whose value changes inﬁnitely often.
(Such a variable could be used as an “oscillator”, triggering system transitions.) In
fact, an attempt to prove (10) by rule (∃∃∃∃∃∃I) would require to exhibit a state function
t whose value is certain to change inﬁnitely often in any behavior. However, it is
easy to show by induction on the syntax of state functions that for any t there exists
a behavior such that the value of t remains constant forever.
An approach to solving this problem, advocated in [2], consists in adding aux-
iliary variables such as history and prophecy variables.
Formally, this approach
consists in adding special introduction rules for auxiliary variables. The proof of
G ⇒∃∃∃∃∃∃v : F is then reduced to ﬁrst proving a formula of the form G ⇒∃∃∃∃∃∃a : Gaux
using a rule for auxiliary variables, and then use the rules (∃∃∃∃∃∃E) and (∃∃∃∃∃∃I) above to
prove G ∧Gaux ⇒∃∃∃∃∃∃v : F.
4 FORMALIZED MATHEMATICS: THE ADDED VALUE OF TLA+
The deﬁnitions of the syntax and semantics of TLA in section 2 were generic in
terms of an underlying language of predicate logic and its interpretation. TLA+ in-
stantiates this generic deﬁnition of TLA with a speciﬁc ﬁrst-order language, namely
Zermelo-Fr¨ankel set theory with choice. This adoption of a standard interpretation
enables precise and unambiguous speciﬁcations of the “data structures” on which
speciﬁcations are based; we have seen in the example proofs in section 3 that rea-
soning about the data accounts for most of the steps that need to be proved during
system veriﬁcation. TLA+ also provides facilities for structuring a speciﬁcation as a
hierarchy of modules, for declaring parameters, and most importantly, for deﬁning
operators. These facilities are essential for writing actual speciﬁcations and must
therefore be mastered by any user of TLA+. However, from the foundational point
of view adopted in this paper, they are just syntactic sugar. We will therefore con-
centrate on the set-theoretic foundations, referring the reader to Lamport’s book [27]
for a detailed presentation of the language of TLA+.

22
S. Merz
4.1 Elementary data structures: basic set theory
The signature of the predicate logic underlying TLA+ contains a single binary pred-
icate symbol ∈and no function symbols.4 Terms and formulas at the transition
level are deﬁned as indicated in section 2.2, with an extra term formation rule that
deﬁnes choose x : A to be a transition function whenever x ∈VE is a variable
and A is an action.5 The occurrences of x in the term choose x : A are bound.
To this ﬁrst-order language corresponds a set-theoretic interpretation: every TLA+
value is a set. Moreover, ∈is interpreted as set membership and the interpretation
is equipped with an (unspeciﬁed) choice function ε mapping every non-empty col-
lection C of values to some element ε(C) of C, and mapping the empty collection
to an arbitrary value. The interpretation of a term choose x : P is deﬁned as
Jchoose x : PKξ
s,t
=
ε({d | JPKαs,t,ξ[d/x] = t})
This deﬁnition employs the choice function to return some value satisfying P pro-
vided there is some such value in the universe of set theory. We should remark that
in this semantic clause, the choice function is applied to a collection that need not
be a set (i.e., an element of the universe); in set-theoretic terminology, ε applies to
classes and not just to sets. Because ε is a function, it produces the same value
when applied to equal arguments. It follows that choice satisﬁes the laws
(∃x : P)
≡
P[(choose x : P)/x]
(11)
(∀x : (P ≡Q))
⇒
(choose x : P) = (choose x : Q)
(12)
TLA+ avoids undeﬁnedness by underspeciﬁcation [17], so choose x : P de-
notes a value even if no value satisﬁes P. To ensure that a term involving choice
actually denotes the expected value, the existence of some set satisfying the charac-
teristic predicate should be proven. If there is more than one such value, the expres-
sion is underspeciﬁed, and the user should be prepared to accept any of them. In
particular, any properties will have to be established for all possible values. However,
observe that for a given interpretation, choice is deterministic and not “monotone”:
no relationship can be established between choose x : P and choose x : Q even
when P ⇒Q is valid (unless P and Q are actually equivalent). Therefore, when-
ever some speciﬁcation Spec contains an underspeciﬁed application of choice, any
reﬁnement Ref is bound to make the same choices in order to prove Ref ⇒Spec;
this situation is quite diﬀerent from non-determinism where implementations may
narrow the set of allowed values.
In the following, we will freely use many abbreviations deﬁned by TLA+. For
example, ∃x, y ∈S : P abbreviates ∃x : ∃y : x ∈S ∧y ∈S ∧P, and similar
4 Once again, our presentation deviates somewhat from Lamport [27] who prefers to
treat all subsequent constructs on an equal footing rather than distinguishing between
basic and derived operators.
5 Temporal formulas are deﬁned as indicated in section 2.3; in particular, choose is
never applied to a temporal formula.

On the Logic of TLA+
23
notation applies to ∀and choose. Local declarations are written as let
in
,
and if
then
else
is used for conditional expressions.
union
union S
∆=
choose M : ∀x : (x ∈M ≡∃T ∈S : x ∈T)
binary union
S ∪T
∆=
union {S, T}
subset
S ⊆T
∆=
∀x : (x ∈S ⇒x ∈T)
powerset
subset S
∆=
choose M : ∀x : (x ∈M ≡x ⊆S)
comprehension 1
{x ∈S : P}
∆=
choose M : ∀x : (x ∈M ≡x ∈S ∧P)}
comprehension 2
{t : x ∈S}
∆=
choose M : ∀y : (y ∈M ≡∃x ∈S : y = t)
Table 1. Basic set-theoretic operators.
From membership and choice, one can build up the conventional language of
mathematics [28], and this is the foundation for the expressiveness of TLA+. Table 1
lists some of the basic set-theoretic constructs of TLA+; we write
{e1, . . . , en}
∆=
choose S : ∀x : (x ∈S ≡x = e1 ∨. . . ∨x = en)
to denote set enumeration and assume the additional bound variables in the deﬁning
expressions of table 1 to be chosen such that no variable clashes occur. The two
comprehension schemes act as binders for variable x, which must not have free
occurrences in S. The existence of the sets deﬁned in terms of choice can be justiﬁed
from the axioms of Zermelo-Fr¨ankel set theory [37], which provide the deductive
counterpart to the semantics underlying TLA+.
However, it is well-known that
without proper care, set theory is prone to paradoxes. For example, the expression
choose S : ∀x : (x ∈S ≡x /∈x)
is a well-formed constant formula of TLA+, but the existence of a set S containing
precisely those sets that do not contain themselves would lead to the contradiction
that S ∈S iﬀS /∈S; this is of course Russell’s paradox. Intuitively, S is “too big”
to be a set. More precisely, the universe of set theory does not contain collections
that are in bijection with the collection of all sets. Therefore, when evaluating the
above TLA+ expression, the choice function is applied to the empty collection, and
the result depends on the underlying interpretation. Perhaps unexpectedly, we can
however infer from (12) that
(choose S : ∀x : (x ∈S ≡x /∈x)) = (choose x : x ∈{})
Similarly, a generalized intersection operator dual to the union operator of ta-
ble 1 cannot be sensibly deﬁned, because the intersection of the empty set would
have to produce the set of all sets, which we know cannot exist.
On the positive side, we have exploited the fact that no set can contain all values
in the deﬁnition
NoMsg
∆=
choose x : x /∈Message

24
S. Merz
that appears in ﬁgure 1(b) because NoMsg is guaranteed to denote some value that
is not contained in Message. If a later reﬁnement wanted to ﬁx a speciﬁc “null”
message value null /∈Message, it could do so by restricting the class of admissible
interpretations via an assumption of the form
assume (choose x : x /∈Message) = null
Because all properties established of the original speciﬁcation hold for all possible
choices of NoMsg, they will continue to hold for this restricted choice.
4.2 More data structures
Some sets can conveniently be interpreted as functions. A traditional approach,
followed in Z and B [8, 36], is to construct functions via products and relations.
TLA+ does not prescribe any concrete construction of functions. The set of functions
whose domain equals S and whose codomain is a subset of T is denoted by [S →T],
the domain of a function f is denoted by domain f , and the application of function
f to an expression e is written as f [e]. The expression [x ∈S 7→e] denotes the
function with domain S that maps any x ∈S to e; again, the variable x must not
occur in S and is bound by the function constructor. Thus, any function f obeys
the law
f
= [x ∈domain f 7→f [x]]
(13)
and this equation can in fact serve as a characteristic predicate for functional values.
TLA+ introduces a notation for overriding a function at a certain argument position
(a similar concept underlies Gurevich’s ASM notation [12]). Formally,
[f except ![t] = u]
∆=
[x ∈domain f 7→if x = t then u else f [x]]
where x is a fresh variable.
Combining choice, sets, and function notation, one obtains an expressive lan-
guage for deﬁning mathematical structures. For example, the standard TLA+ mod-
ule introducing natural numbers deﬁnes them as an arbitrary set with constant zero
and successor function satisfying the usual Peano axioms [27, p. 345], and Lamport
goes on to similarly deﬁne the integers and the real numbers, ensuring that the basic
arithmetic operations agree rather than having to overload the operation symbols.
Recursive deﬁnitions can be introduced in terms of choice, e.g.
factorial
∆=
choose f : f = [n ∈Nat 7→if n = 0 then 1 else n ∗f [n −1]]
which TLA+, using some syntactic sugar, allows to write even more concisely as
factorial[n ∈Nat]
∆=
if n = 0 then 1 else n ∗factorial[n −1]

On the Logic of TLA+
25
Of course, as with any construction based on choice, such a deﬁnition should be
justiﬁed by proving the existence of a function that satisﬁes the recursive equation.
Unlike standard semantics of programming languages, TLA+ does not commit to
the least ﬁxed point of a recursively deﬁned function in cases where there are several
solutions.
Tuples are represented in TLA+ as functions:
⟨t1, . . . , tn⟩
∆=
[i ∈1..n 7→if i = 1 then t1 . . . else tn]
where 1..n denotes the set {j ∈Nat : 1 ≤j ∧j ≤n} (and i is a “fresh” variable),
and selection of the i-th element is just function application. Strings are deﬁned
as tuples of characters, and records are represented as functions whose domains are
ﬁnite sets of strings. The update operation on functions can thus be applied to
tuples and records as well. For record selection and update, the concrete syntax
allows to write, for example, acct.balance instead of acct[“balance”].
Seq(S)
∆=
union {[1..n] →S : n ∈Nat}
Len(s)
∆=
choose n ∈Nat : domain s = 1..n
Head(s)
∆=
s[1]
Tail(s)
∆=
[i ∈1..Len(s) −1 7→s[i + 1]]
s ◦t
∆=
[i ∈1..Len(s) + Len(t) 7→
if i ≤Len(s) then s[i] else t[i −Len(s)]]
Append(s, e)
∆=
s ◦⟨e⟩
Fig. 3. Finite sequences.
The standard TLA+ module Sequences imported by the speciﬁcation of the
FIFO queue in ﬁgure 1(b) represents ﬁnite sequences as tuples. The deﬁnitions of
the standard operations, some of which are shown in ﬁgure 3, is therefore quite
simple. However, this simplicity can sometimes be deceptive. For example, these
deﬁnitions do not reveal that the Head and Tail operations are “partial”. They
should be validated by proving the expected properties, such as
∀s ∈Seq(S) : Len(s) ≥1 ⇒s = ⟨Head(s)⟩◦Tail(s)
5 CONCLUSIONS
The design of software systems requires a combination of ingenuity and careful
engineering. While there is no substitute for intuition, the correctness of a proposed
solution can be checked by precise reasoning over a suitable model, and this is the
realm of logics and (formalized) mathematics. The rˆole of a formalism is to help the
user in the diﬃcult and important activity of writing and analysing formal models.
TLA+ builds on the experience of classical mathematics and adds just a thin layer of

26
S. Merz
temporal logic in order to describe executions as sets of traces. A distinctive feature
of TLA is its attention to reﬁnement and composition, reﬂected in the concept of
stuttering invariance.
Whereas the expressiveness of TLA+ undoubtedly helps in writing concise, high-
level models of systems, one may wonder whether it lends itself as well to the analysis
of these models. For example, we have pointed out several times the need to prove
conditions of “well-deﬁnedness” related to the use of the choice operator. On the
other hand, Zermelo-Fr¨ankel set theory with choice is probably the most widely
used foundation of classical mathematics, and there are well-known idioms, such as
primitive-recursive deﬁnitions, that ensure well-deﬁnedness. For the speciﬁcation of
reactive systems, TLA adds some proper idioms that control the delicate interplay
between temporal operators, e.g. in order to ensure that a speciﬁcation is machine
closed [3].
Deductive veriﬁcation of TLA+ speciﬁcations can be supported by proof assis-
tants, and in fact several encodings of TLA in the logical frameworks of diﬀerent
theorem provers have been proposed [15, 20, 31], although no prover has yet been de-
signed to support full TLA+. Perhaps more surprisingly, there has been much recent
activity on developing a toolset based on the tlc model checker and simulator to
aid in validating and debugging TLA+ models [39], and this toolset has been applied
in industrial development projects. Obviously, model checking is possible only for
a sublanguage of TLA+, but interestingly, most real-world speciﬁcations are either
written in this sublanguage or can be translated into it using minor transformations.
The modeling language of tlc is still much more expressive that that of most other
model checkers and therefore helps users to write concise system speciﬁcations.
Acknowledgements.
I am grateful to Leslie Lamport for providing the subject
of this article, for his encouragement of this work, and for detailed comments on
a draft version. Parts of this paper have been adapted from an earlier paper on
TLA, written with Mart´ın Abadi [6]. Helpful comments by J´ulia Zappe and by the
anonymous referees are gratefully acknowledged.
REFERENCES
[1] Mart´ın Abadi. An axiomatization of Lamport’s Temporal Logic of Actions. In Jos
C. M. Baeten and Jan W. Klop, editors, CONCUR ’90, Theories of Concurrency:
Uniﬁcation and Extension, volume 458 of Lecture Notes in Computer Science, pages
57–69, Berlin, 1990. Springer-Verlag.
[2] Mart´ın Abadi and Leslie Lamport. The existence of refinement map-
pings. Theoretical Computer Science, 81(2):253–284, May 1991.
[3] Mart´ın Abadi and Leslie Lamport. An old-fashioned recipe for real
time. ACM Transactions on Programming Languages and Systems, 16(5):1543–1571,
September 1994.

On the Logic of TLA+
27
[4] Mart´ın Abadi and Leslie Lamport. Conjoining specifications. ACM Trans-
actions on Programming Languages and Systems, 17(3):507–534, May 1995.
[5] Mart´ın Abadi and Stephan Merz. An abstract account of composition. In Jiˇr´ı Wie-
dermann and Petr Hajek, editors, Mathematical Foundations of Computer Science,
volume 969 of Lecture Notes in Computer Science, pages 499–508, Prague, Czech
Republic, 1995. Springer-Verlag.
[6] Mart´ın Abadi and Stephan Merz. On TLA as a logic. In Manfred Broy, editor, De-
ductive Program Design, NATO ASI series F, pages 235–272. Springer-Verlag, 1996.
[7] Mart´ın Abadi and Gordon Plotkin. A logical view of composition. The-
oretical Computer Science, 114(1):3–30, June 1993.
[8] J.-R. Abrial. The B-Book: Assigning Programs to Meanings. Cambridge University
Press, 1996.
[9] J.-R. Abrial. Extending B without changing it (for developing distributed systems).
In H. Habrias, editor, 1st Conference on the B method, pages 169–190. IRIN Institut
de recherche en informatique de Nantes, 1996.
[10] Bowen Alpern and Fred B. Schneider. Defining liveness. Information Pro-
cessing Letters, 21(4):181–185, October 1985.
[11] R. Back and J. von Wright. Reﬁnement calculus—A systematic introduction. Springer-
Verlag, 1998.
[12] Egon B¨orger and Robert St¨ark. Abstract State Machines: A Method for High-Level
System Design and Analysis. Springer-Verlag, 2003.
[13] Edmund M. Clarke, Orna Grumberg, and Doron Peled. Model Checking. MIT Press,
Cambridge, Mass., 1999.
[14] W.-P. de Roever, H. Langmaack, and A. Pnueli, editors. Compositionality: The Sig-
niﬁcant Diﬀerence, volume 1536 of Lecture Notes in Computer Science. Springer-
Verlag, 1998.
[15] Urban Engberg, Peter Gronning, and Leslie Lamport. Mechanical veriﬁcation of con-
current systems with TLA. In Fourth Intl. Conf. Computer-Aided Veriﬁcation (CAV
’92), volume 663 of Lecture Notes in Computer Science, pages 44–55. Springer-Verlag,
1992.
[16] M. C. J. Gordon. Mechanizing programming logics in higher-order logic. In
G. Birtwistle and P. A. Subrahmanyam, editors, Current Trends in Hardware Veriﬁ-
cation and Automated Theorem Proving. Springer-Verlag, 1989.
[17] David Gries and Fred B. Schneider. Avoiding the undeﬁned by underspeciﬁcation. In
Jan van Leeuwen, editor, Computer Science Today: Recent Trends and Developments,
volume 1000 of Lecture Notes in Computer Science, pages 366–373. Springer-Verlag,
New York, N.Y., 1995.
[18] C. A. R. Hoare. A theory of conjunction and concurrency. In Parallel Architectures
(Parbase ’90), pages 18–27. IEEE Computer Security Press, 1991.
[19] G. E. Hughes and M. J. Cresswell. A New Introduction to Modal Logic. Routledge,
London, 1996.
[20] Sara Kalvala. A formulation of TLA in Isabelle. Available at ftp://ftp.dcs.
warwick.ac.uk/people/Sara.Kalvala/tla.dvi, March 1995.

28
S. Merz
[21] H. W. Kamp. Tense Logic and the Theory of Linear Order. PhD thesis, Univ. of
California at Los Angeles, 1968.
[22] Leslie Lamport. The TLA home page. http://www.research.microsoft.com/
users/lamport/tla/tla.html.
[23] Leslie Lamport. Proving the correctness of multiprocess programs.
IEEE Transactions on Software Engineering, SE-3(2):125–143, March 1977.
[24] Leslie Lamport. What good is temporal logic? In R. E. A. Mason, editor, Information
Processing 83: Proceedings of the IFIP 9th World Congress, pages 657–668, Paris,
September 1983. IFIP, North-Holland.
[25] Leslie Lamport. The Temporal Logic of Actions. ACM Transactions on
Programming Languages and Systems, 16(3):872–923, May 1994.
[26] Leslie Lamport. How to write a proof. American Mathematical Monthly,
102(7):600–608, 1995.
[27] Leslie Lamport. Specifying Systems. Addison-Wesley, Boston, Mass., 2002.
[28] A. C. Leisenring. Mathematical Logic and Hilbert’s ε-Symbol. University Mathemati-
cal Series. Macdonald & Co. Ltd., London, U.K., 1969.
[29] Zohar Manna and Amir Pnueli. Veriﬁcation of concurrent programs: the temporal
framework. In R.S. Boyer and J.S. Moore, editors, The Correctness Problem in Com-
puter Science, pages 215–273. Academic Press, London, 1982.
[30] Zohar Manna and Amir Pnueli. The temporal logic of reactive and concurrent
systems—Speciﬁcation. Springer-Verlag, New York, 1992.
[31] Stephan Merz. Isabelle/TLA. Available on the WWW at http://isabelle.in.tum.
de/library/HOL/TLA, 1997. Revised 1999.
[32] Stephan Merz. A more complete TLA. In J.M. Wing, J. Woodcock, and J. Davies,
editors, FM’99: World Congress on Formal Methods, volume 1709 of Lecture Notes
in Computer Science, pages 1226–1244, Toulouse, France, 1999. Springer-Verlag.
[33] Amir Pnueli. The temporal logic of programs. In Proceedings of the 18th Annual
Symposium on the Foundations of Computer Science, pages 46–57. IEEE, 1977.
[34] Arthur N. Prior. Past, Present and Future. Clarendon Press, Oxford, U.K., 1967.
[35] A. P. Sistla, E. M. Clarke, N. Francez, and Y. Gurevich. Can message
buffers be characterized in linear temporal logic? Information and Con-
trol, 63:88–112, 1984.
[36] M. Spivey. The Z Notation: A Reference Manual. Prentice Hall, 1992.
[37] Patrick Suppes. Axiomatic Set Theory. Dover Publications, 1972.
[38] Moshe Vardi. Branching vs. linear time—ﬁnal showdown. In T. Margaria and W. Yi,
editors, Tools and Algorithms for the Construction and Analysis of Systems (TACAS
2001), volume 2031 of Lecture Notes in Computer Science, pages 1–22, Genova, Italy,
2001. Springer-Verlag. See http://www.cs.rice.edu/~vardi/papers/ for more re-
cent versions of this paper.
[39] Yuan Yu, Panagiotis Manolios, and Leslie Lamport. Model checking TLA+ speciﬁca-
tions. In L. Pierre and T. Kropf, editors, Correct Hardware Design and Veriﬁcation
Methods (CHARME’99), volume 1703 of Lecture Notes in Computer Science, pages
54–66, Bad Herrenalb, Germany, 1999. Springer-Verlag.

