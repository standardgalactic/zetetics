CODE LISTINGS AND FIGURES

CHAPTER 1
Listing 1.1. The Product  type (C# 1)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
using System.Collections; 
public class Product 
{ 
   string name; 
   public string Name { get { return name; } } 
 
   decimal price; 
   public decimal Price { get { return price; } } 
 
   public Product(string name, decimal price) 
   { 
      this.name = name; 
      this.price = price; 
   } 
 
   public static ArrayList GetSampleProducts() 
   { 
      ArrayList list = new ArrayList(); 
      list.Add(new Product("West Side Story", 9.99m)); 
      list.Add(new Product("Assassins", 14.99m)); 
      list.Add(new Product("Frogs", 13.99m)); 
      list.Add(new Product("Sweeney Todd", 10.99m)); 
      return list; 
   } 
 
   public override string ToString() 
   { 
      return string.Format("{0}: {1}", name, price); 
   } 
 
}
Listing 1.2. Strongly typed collections and private setters (C# 2)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
public class Product 
{ 
   string name; 
   public string Name 
   { 
      get { return name; } 
      private set { name = value; } 
   } 
 
   decimal price; 
   public decimal Price 
   { 
      get { return price; } 
      private set { price = value; } 
   } 
 
   public Product(string name, decimal price) 

18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
   { 
      Name = name; 
      Price = price; 
   } 
 
   public static List<Product> GetSampleProducts() 
   { 
      List<Product> list = new List<Product>(); 
      list.Add(new Product("West Side Story", 9.99m)); 
      list.Add(new Product("Assassins", 14.99m)); 
      list.Add(new Product("Frogs", 13.99m)); 
      list.Add(new Product("Sweeney Todd", 10.99m)); 
      return list; 
   } 
 
   public override string ToString() 
   { 
      return string.Format("{0}: {1}", name, price); 
   } 
}
Listing 1.3. Automatically implemented properties and simpler initialization (C# 3)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
using System.Collections.Generic; 
 
class Product 
{ 
   public string Name { get; private set; } 
   public decimal Price { get; private set; } 
 
   public Product(string name, decimal price) 
   { 
      Name = name; 
      Price = price; 
   } 
 
   Product() {} 
 
   public static List<Product> GetSampleProducts() 
   { 
      return new List<Product> 
      { 
          new Product { Name="West Side Story", Price = 9.99m }, 
          new Product { Name="Assassins", Price=14.99m }, 
          new Product { Name="Frogs", Price=13.99m }, 
          new Product { Name="Sweeney Todd", Price=10.99m} 
      }; 
   } 
 
   public override string ToString() 
   { 
      return string.Format("{0}: {1}", Name, Price); 
   } 
}
Listing 1.4. Named arguments for clear initialization code (C# 4)

Figure 1.1. Evolution of the Product  type, showing greater encapsulation, stronger
typing, and ease of initialization over time
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
using System.Collections.Generic; 
public class Product 
{ 
   readonly string name; 
   public string Name { get { return name; } } 
 
   readonly decimal price; 
   public decimal Price { get { return price; } } 
 
   public Product(string name, decimal price) 
   { 
      this.name = name; 
      this.price = price; 
   } 
 
   public static List<Product> GetSampleProducts() 
   { 
      return new List<Product> 
      { 
         new Product( name: "West Side Story", price: 9.99m), 
         new Product( name: "Assassins", price: 14.99m), 
         new Product( name: "Frogs", price: 13.99m), 
         new Product( name: "Sweeney Todd", price: 10.99m) 
      }; 
   } 
 
   public override string ToString() 
   { 
      return string.Format("{0}: {1}", name, price); 
   } 
}
Listing 1.5. Sorting an ArrayList  using IComparer  (C# 1)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
class ProductNameComparer : IComparer 
{ 
   public int Compare(object x, object y) 
   { 
      Product first = (Product)x; 
      Product second = (Product)y; 
      return first.Name.CompareTo(second.Name); 
 
   } 
} 
... 
ArrayList products = Product.GetSampleProducts(); 
products.Sort(new ProductNameComparer()); 
foreach (Product product in products) 
{ 
   Console.WriteLine (product); 
}
Listing 1.6. Sorting a List<Product>  using IComparer<Product>  (C# 2)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class ProductNameComparer : IComparer<Product> 
{ 
   public int Compare(Product x, Product y) 
   { 
      return x.Name.CompareTo(y.Name); 
   } 
} 
... 
List<Product> products = Product.GetSampleProducts(); 
products.Sort(new ProductNameComparer()); 
foreach (Product product in products) 
{ 
   Console.WriteLine(product); 
}
Listing 1.7. Sorting a List<Product>  using Comparison<Product>  (C# 2)
1
2
3
4
5
6
7
8
9
List<Product> products = Product.GetSampleProducts(); 
 
products.Sort(delegate(Product x, Product y) 
   { return x.Name.CompareTo(y.Name); } 
); 
foreach (Product product in products) 
{ 
   Console.WriteLine(product); 
}
Listing 1.8. Sorting using Comparison<Product>  from a lambda expression (C# 3)

Figure 1.2. Features involved in making sorting easier in C# 2 and 3
1
2
3
4
5
6
List<Product> products = Product.GetSampleProducts(); 
products.Sort((x, y) => x.Name.CompareTo(y.Name)); 
foreach (Product product in products) 
{ 
   Console.WriteLine(product); 
}
Listing 1.9. Ordering a List<Product>  using an extension method (C# 3)
1
2
3
4
5
List<Product> products = Product.GetSampleProducts(); 
foreach (Product product in products.OrderBy(p => p.Name)) 
{ 
   Console.WriteLine (product); 
}
Listing 1.10. Looping, testing, printing out (C# 1)
1
2
3
4
5
6
7
8
ArrayList products = Product.GetSampleProducts(); 
foreach (Product product in products) 
{ 
   if (product.Price > 10m) 
   { 
      Console.WriteLine(product); 
   } 
}
Listing 1.11. Separating testing from printing (C# 2)
1
2
3
4
5
6
7
List<Product> products = Product.GetSampleProducts(); 
 
Predicate<Product> test = delegate(Product p) { return p.Price > 10m; }; 
List<Product> matches = products.FindAll(test); 
 
Action<Product> print = Console.WriteLine; 
matches.ForEach(print);

Figure 1.3. Anonymous methods and lambda expressions in C# 2 and 3 aid separation of
concerns and readability.
Listing 1.12. Separating testing from printing redux (C# 2)
1
2
3
List<Product> products = Product.GetSampleProducts(); 
products.FindAll(delegate(Product p) { return p.Price > 10;}) 
        .ForEach(Console.WriteLine);
Listing 1.13. Testing with a lambda expression (C# 3)
1
2
3
4
5
List<Product> products = Product.GetSampleProducts(); 
foreach (Product product in products.Where(p => p.Price > 10)) 
{ 
   Console.WriteLine(product); 
}
1
2
3
4
5
6
decimal? price; 
public decimal? Price 
{ 
   get { return price; } 
   private set { price = value; } 
}
Listing 1.14. Displaying products with an unknown price (C# 3)
1
2
List<Product> products = Product.GetSampleProducts(); 
foreach (Product product in products.Where(p => p.Price == null)) 

Figure 1.4. Options for working with missing data
3
4
5
{ 
   Console.WriteLine(product.Name); 
}
1
2
3
List<Product> products = Product.GetSampleProducts(); 
products.FindAll(delegate(Product p) { return p.Price == null; }) 
        .ForEach(Console.WriteLine);
1 Product p = new Product("Unreleased product");
1
2
3
4
5
public Product(string name, decimal? price = null) 
{ 
   this.name = name; 
   this.price = price; 
}
Listing 1.15. First steps with query expressions: ×ltering a collection
1
2
3
4
5
6
7
8
List<Product> products = Product.GetSampleProducts(); 
var filtered = from Product p in products 
               where p.Price > 10 
               select p; 
foreach (Product product in filtered) 
{ 
   Console.WriteLine(product); 
}

Listing 1.16. Joining, ×ltering, ordering, and projecting (C# 3)
1
2
3
4
5
6
7
8
9
10
11
12
13
List<Product> products = Product.GetSampleProducts(); 
List<Supplier> suppliers = Supplier.GetSampleSuppliers(); 
var filtered = from p in products 
               join s in suppliers 
                  on p.SupplierID equals s.SupplierID 
               where p.Price > 10 
               orderby s.Name, p.Name 
               select new { SupplierName = s.Name, ProductName = p.Name }; 
foreach (var v in filtered) 
{ 
   Console.WriteLine("Supplier={0}; Product={1}", 
                     v.SupplierName, v.ProductName); 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
<?xml version="1.0"?> 
<Data> 
  <Products> 
    <Product Name="West Side Story" Price="9.99" SupplierID="1" /> 
    <Product Name="Assassins" Price="14.99" SupplierID="2" /> 
    <Product Name="Frogs" Price="13.99" SupplierID="1" /> 
    <Product Name="Sweeney Todd" Price="10.99" SupplierID="3" /> 
  </Products> 
 
  <Suppliers> 
    <Supplier Name="Solely Sondheim" SupplierID="1" /> 
    <Supplier Name="CD-by-CD-by-Sondheim" SupplierID="2" /> 
    <Supplier Name="Barbershop CDs" SupplierID="3" /> 
  </Suppliers> 
</Data>
Listing 1.17. Complex processing of an XML ×le with LINQ to XML (C# 3)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
XDocument doc = XDocument.Load("data.xml"); 
var filtered = from p in doc.Descendants("Product") 
               join s in doc.Descendants("Supplier") 
                  on (int)p.Attribute("SupplierID") 
                  equals (int)s.Attribute("SupplierID") 
               where (decimal)p.Attribute("Price") > 10 
               orderby (string)s.Attribute("Name"), 
                       (string)p.Attribute("Name") 
               select new 
              { 
                   SupplierName = (string)s.Attribute("Name"), 
                   ProductName = (string)p.Attribute("Name") 
              }; 
foreach (var v in filtered) 
{ 
    Console.WriteLine("Supplier={0}; Product={1}", 

17
18
                      v.SupplierName, v.ProductName); 
}
Listing 1.18. Applying a query expression to a SQL database (C# 3)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
using (LinqDemoDataContext db = new LinqDemoDataContext()) 
{ 
var filtered = from p in db.Products 
               join s in db.Suppliers 
                  on p.SupplierID equals s.SupplierID 
               where p.Price > 10 
               orderby s.Name, p.Name 
               select new { SupplierName = s.Name, ProductName = p.Name }; 
foreach (var v in filtered) 
{ 
   Console.WriteLine("Supplier={0}; Product={1}", 
                     v.SupplierName, v.ProductName); 
   } 
}
Listing 1.19. Saving data to Excel using COM (C# 4)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
var app = new Application { Visible = false }; 
Workbook workbook = app.Workbooks.Add(); 
Worksheet worksheet = app.ActiveSheet; 
int row = 1; 
foreach (var product in Product.GetSampleProducts() 
                               .Where(p => p.Price != null)) 
{ 
   worksheet.Cells[row, 1].Value = product.Name; 
   worksheet.Cells[row, 2].Value = product.Price; 
   row++; 
} 
workbook.SaveAs(Filename: "demo.xls", 
                FileFormat: XlFileFormat.xlWorkbookNormal); 
app.Application.Quit();
Listing 1.20. Running IronPython and extracting properties dynamically (C# 4)
1
2
3
4
5
6
7
ScriptEngine engine = Python.CreateEngine(); 
ScriptScope scope = engine.ExecuteFile("FindProducts.py"); 
dynamic products = scope.GetVariable("products"); 
foreach (dynamic product in products) 
{ 
   Console.WriteLine("{0}: {1}", product.ProductName, product.Price); 
}

Listing 1.21. Displaying products in Windows Forms using an asynchronous function
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
private async void CheckProduct(object sender, EventArgs e) 
{ 
   try 
   { 
      productCheckButton.Enabled = false; 
      string id = idInput.Text; 
 
      Task<Product> productLookup = directory.LookupProductAsync(id); 
      Task<int> stockLookup = warehouse.LookupStockLevelAsync(id); 
      Product product = await productLookup; 
      if (product == null) 
      { 
         return; 
      } 
      nameValue.Text = product.Name; 
      priceValue.Text = product.Price.ToString("c"); 
 
      int stock = await stockLookup; 
      stockValue.Text = stock.ToString(); 
      } 
 
   finally 
   { 
   productCheckButton.Enabled = true; 
   } 
}
1
2
3
4
5
6
7
8
static string Reverse(string input) 
{ 
   char[] chars = input.ToCharArray(); 
   Array.Reverse(chars); 
   return new string(chars); 
} 
... 
Console.WriteLine(Reverse("dlrow olleH"));
1
2
3
4
5
6
7
8
9
using System; 
public class Snippet 
{ 
    static string Reverse(string input) 
    { 
       char[] chars = input.ToCharArray(); 
       Array.Reverse(chars); 
       return new string(chars); 
    } 

10
11
12
13
14
15
16
 
    [STAThread] 
    static void Main() 
    { 
       Console.WriteLine(Reverse("dlrow olleH")); 
    } 
}
1
2
3
char[] chars = input.ToCharArray(); 
Array.Reverse(chars); 
return new string(chars);

CHAPTER 2
Figure 2.1. Processing a call to a delegate instance that uses the C# shorthand syntax
1 delegate void StringProcessor(string input);
1
2
3
4
5
void PrintString(string x) 
void PrintInteger(int x) 
void PrintTwoStrings(string x, string y) 
int GetStringLength(string x) 
void PrintObject(object x)
1
2
3
4
StringProcessor proc1, proc2; 
proc1 = new StringProcessor(StaticMethods.PrintString); 
InstanceMethods instance = new InstanceMethods(); 
proc2 = new StringProcessor(instance.PrintString);
1 void Invoke(string input)

Figure 2.2. The transformation process used for the C# shorthand syntax for combining
delegate instances
Listing 2.1. Using delegates in a variety of simple ways
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
using System; 
delegate void StringProcessor(string input);  
class Person  
{  
   string name;  
   public Person(string name) { this.name = name; }  
   public void Say(string message)  
   {  
      Console.WriteLine("{0} says: {1}", name, message);  
   }  
}  
class Background  
{  
   public static void Note(string note) 
   {  
      Console.WriteLine("({0})", note);  
   } 
}  
class SimpleDelegateUse  
{  
   static void Main()  
   {  
      Person jon = new Person("Jon");  
      Person tom = new Person("Tom");  
      StringProcessor jonsVoice, tomsVoice, background;  
      jonsVoice = new StringProcessor(jon.Say);  
      tomsVoice = new StringProcessor(tom.Say);  
      background = new StringProcessor(Background.Note); 
      jonsVoice("Hello, son.");  
      tomsVoice.Invoke("Hello, Daddy!");  
      background("An airplane flies past.");  
   }  
}
1
2
3
4
5
1
2
3
Jon says: Hello, son. 
Tom says: Hello, Daddy! 
(An airplane flies past.)

Table 2.1. An example showing the differences between implicit and explicit typing
Invalid C# 1—implicit typing
Valid C# 1—explicit typing
var s = "hello";
string s = "hello";
var x = s.Length;
int x = s.Length;
var twiceX = x * 2;
int twiceX = x * 2;
1
2
object o = "hello"; 
Console.WriteLine(o.Length);
1
2
object o = "hello"; 
Console.WriteLine(((string)o).Length);
1
2
3
4
o = "hello"; 
 
 
 
 
Console.WriteLine(o.Length);  
o = new string[] {"hi”, "there"}; 
 
Console.WriteLine(o.Length);
1
Listing 2.2. Demonstrating a type-unsafe system with C code
1
2
3
4
5
6
7
#include <stdio.h> 
int main(int argc, char**argv) 
{ 
   char *first_arg = argv[1]; 
   int *first_arg_as_int = (int *)first_arg; 
   printf ("%d", *first_arg_as_int); 
}
Listing 2.3. Demonstration of array covariance and execution-time checking
1
2
3
string[] strings = new string[5];  
object[] objects = strings;  
objects[0] = new Button();
1
2

Figure 2.3. Comparing value type and reference type behaviors, particularly with
regard to assignment
1 object Clone()
public Person Clone()
public Person Clone()  
{ 
[Implementation goes here]
Point p1 = new Point(10, 20); 
Point p2 = p1;
Stream stream = new MemoryStream(); 
MemoryStream memoryStream = (MemoryStream) stream;

void AppendHello(StringBuilder builder) 
{ 
   builder.Append("hello"); 
}
int i = 5; 
object o = i; 
int j = (int) o;
Listing 2.4. Improvements in delegate instantiation brought in by C# 2
static void HandleDemoEvent(object sender, EventArgs e)  
{  
Console WriteLine ("Handled by HandleDemoEvent");
Listing 2.5. Lambda expressions—like improved anonymous methods
Func<int,int,string> func = (x, y) => (x * y).ToString(); 
Console.WriteLine(func(5, 20));
Listing 2.6. Demonstration of anonymous types and implicit typing
var jon = new { Name = "Jon", Age = 31 }; 
var tom = new { Name = "Tom", Age = 4 }; 
Console WriteLine ("{0} is {1}" jon Name jon Age);
string x = "dlrow olleH".Reverse();
Listing 2.7. Dynamic typing in C# 4

dynamic o = "hello"; 
Console.WriteLine(o.Length); 
o = new string[] {"hi" "there"};
Listing 2.8. Demonstration of a variety of nullable type features
int? x = null;                      #1 
x = 5;  
if (x != null)
#2

CHAPTER 3
Figure 3.1. Unbound generic types act as blueprints for constructed types, which then
act as blueprints for actual objects, just as nongeneric types do.
Listing 3.1. Using a Dictionary<TKey,TValue>  to count words in text
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
static Dictionary<string,int> CountWords(string text) 
{ 
   Dictionary<string,int> frequencies; 
   frequencies = new Dictionary<string,int>(); 
   string[] words = Regex.Split(text, @"\W+"); 
   foreach (string word in words) 
   { 
      if (frequencies.ContainsKey(word)) 
      {  
         frequencies[word]++; 
      } 
      else  
      {  
         frequencies[word] = 1; 
      } 
   } 
   return frequencies; 
} 
... 
string text = @"Do you like green eggs and ham? 
                I do not like them, Sam-I-am. 
                I do not like green eggs and ham."; 
Dictionary<string,int> frequencies = CountWords(text); 
foreach (KeyValuePair<string,int> entry in frequencies) 
{ 
   string word = entry.Key; 
   int frequency = entry.Value; 
   Console.WriteLine ("{0}: {1}", word, frequency 
}
1
2
3
4

Table 3.1. Examples of how method signatures in generic types contain placeholders,
which are replaced when the type arguments are speci×ed
Method signature in generic type
Method signature after type parameter
substitution
void Add(TKey key, TValue value)
void Add(string key, int value)
TValue this[TKey key] { get; set; }
int this[string key] { get; set; }
bool ContainsValue(TValue value)
bool ContainsValue(int value)
bool ContainsKey(TKey key)
bool ContainsKey(string key)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
namespace System.Collections.Generic 
{ 
   public class Dictionary<TKey,TValue> 
      : IEnumerable<KeyValuePair<TKey,TValue>> 
   { 
      public Dictionary() { ... } 
      public void Add(TKey key, TValue value) { ... } 
      public TValue this[TKey key] 
      { 
         get { ... } 
         set { ... } 
      } 
      public bool ContainsValue(TValue value) { ... } 
      public bool ContainsKey(TKey key) { ... } 
      [... other members ...] 
   } 
}
1
2
3
4

Figure 3.2. The anatomy of a generic method declaration
1 List<TOutput> ConvertAll<TOutput>(Converter<string,TOutput> converter)
1 List<Guid> ConvertAll(Converter<string,Guid> converter)
Listing 3.2. The List<T>.ConvertAll<TOutput>  method in action
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
static double TakeSquareRoot(int x) 
{ 
   return Math.Sqrt(x); 
} 
... 
List<int> integers = new List<int>(); 
integers.Add(1); 
integers.Add(2);  
integers.Add(3);  
integers.Add(4);  
Converter<int,double> converter = TakeSquareRoot;  
List<double> doubles; 
doubles = integers.ConvertAll<double>(converter); 
foreach (double d in doubles) 
{ 
   Console.WriteLine(d); 
}
1
2
3
Listing 3.3. Implementing a generic method in a nongeneric type
1
2
3
4
5
6
7
static List<T> MakeList<T>(T first, T second) 
{ 
   List<T> list = new List<T>(); 
   list.Add(first); 
   list.Add(second); 
   return list; 
} 

Table 3.2. Examples of conversion type constraints
Declaration
Constructed type examples
class Sample<T> where T : Stream
Valid: Sample<Stream> (identity
conversion) Invalid: Sample<string>
struct Sample<T> where T : IDisposable
Valid: Sample<SqlConnection> (reference
conversion) Invalid:
Sample<StringBuilder>
class Sample<T> where T :
IComparable<T>
Valid: Sample<int> (boxing conversion)
Invalid: Sample<FileInfo>
class Sample<T,U> where T : U
Valid: Sample<Stream,IDisposable>
(reference conversion) Invalid:
Sample<string,IDisposable>
8
9
10
11
12
13
... 
List<string> list = MakeList<string>("Line 1", "Line 2"); 
foreach (string x in list) 
{ 
   Console.WriteLine (x); 
}
1 struct RefSample<T> where T : class
1 class ValSample<T> where T : struct
1
2
3
4
public T CreateInstance<T>() where T : new() 
{ 
   return new T(); 
}

1
2
3
class Sample<T> where T : Stream, 
                          IEnumerable<string>, 
                          IComparable<int>
1
2
3
class Sample<T> where T : Stream, 
                          ArrayList, 
                          IComparable<int>
1
2
3
4
class Sample<T> where T : class, IDisposable, new() 
class Sample<T> where T : struct, IDisposable 
class Sample<T,U> where T : class where U : struct, T 
class Sample<T,U> where T : Stream where U : IDisposable
1
2
3
4
5
6
7
class Sample<T> where T : class, struct 
class Sample<T> where T : Stream, class 
class Sample<T> where T : new(), Stream 
class Sample<T> where T : IDisposable, Stream 
class Sample<T> where T : XmlReader, IComparable, IComparable 
class Sample<T,U> where T : struct where U : class, T 
class Sample<T,U> where T : Stream, U : IDisposable
1
2
3
static List<T> MakeList<T>(T first, T second) 
... 
List<string> list = MakeList<string>("Line 1", "Line 2");
1 List<string> list = MakeList("Line 1", "Line 2");

Listing 3.4. Comparing a given value to the default in a generic way
1
2
3
4
5
6
7
8
9
10
11
static int CompareToDefault<T>(T value) 
   where T : IComparable<T> 
{ 
   return value.CompareTo(default(T)); 
} 
... 
Console.WriteLine(CompareToDefault("x")); 
Console.WriteLine(CompareToDefault(10)); 
Console.WriteLine(CompareToDefault(0)); 
Console.WriteLine(CompareToDefault(-10)); 
Console.WriteLine(CompareToDefault(DateTime.MinValue));
Listing 3.5. Comparisons using ==  and !=  performing reference comparisons
static bool AreReferencesEqual<T>(T first, T second) 
  where T : class 
{ 
  return first == second;  
} 
... 
string name = "Jon"; 
string intro1 = "My name is " + name; 
string intro2 = "My name is " + name; 
Console.WriteLine(intro1 == intro2); 
Console.WriteLine(AreReferencesEqual(intro1, intro2));
Listing 3.6. Generic class representing a pair of values
using System; 
using System.Collections.Generic; 
public sealed class Pair<T1, T2> : IEquatable<Pair<T1, T2>> 
{ 
  private static readonly IEqualityComparer<T1> FirstComparer = 
     EqualityComparer<T1>.Default; 
  private static readonly IEqualityComparer<T2> SecondComparer = 
     EqualityComparer<T2>.Default; 
  private readonly T1 first; 
  private readonly T2 second; 
  public Pair(T1 first, T2 second) 
  { 
     this.first = first; 
     this.second = second; 
  } 
  public T1 First { get { return first; } } 
  public T2 Second { get { return second; } } 
  public bool Equals(Pair<T1, T2> other) 
  { 

     return other != null && 
        FirstComparer.Equals(this.First, other.First) && 
        SecondComparer.Equals(this.Second, other.Second); 
  } 
  public override bool Equals(object o) 
  { 
     return Equals(o as Pair<T1, T2>); 
  } 
  public override int GetHashCode() 
  { 
     return FirstComparer.GetHashCode(first) * 37 + 
        SecondComparer.GetHashCode(second); 
  } 
}
1 Pair<int,string> pair = new Pair<int,string>(10, "value");
Listing 3.7. Using a nongeneric type with a generic method to enable type inference
public static class Pair 
{ 
  public static Pair<T1,T2> Of<T1,T2>(T1 first, T2 second) 
  { 
     return new Pair<T1,T2>(first, second); 
  } 
}
Pair<int,string> pair = Pair.Of(10, "value");
Listing 3.8. Proof that different closed types have different static ×elds
class TypeWithField<T> 
{ 
public static string eld;

Figure 3.3. Visual demonstration of why List<T>  takes up a lot less space than
ArrayList  when storing value types
First: Int32 
Second: String 
Third: DateTime
Listing 3.9. Static constructors with nested generic types
public class Outer<T> 
{ 
public class Inner<U V>
Outer<Int32>.Inner<String,DateTime> 
Outer<String>.Inner<Int32,Int32> 
Outer<Object>.Inner<String,Object> 
Outer<String>.Inner<String,Object> 
Outer<Object>.Inner<Object,String>

IEnumerator<T> GetEnumerator(); 
IEnumerator GetEnumerator();
Listing 3.10. A full generic iterator—of the numbers 0 to 9
class CountingEnumerable: IEnumerable<int> 
{ 
public IEnumerator<int> GetEnumerator()
#1
Listing 3.11. Using the typeof  operator with type parameters
static void DemonstrateTypeof<X>() 
{ 
Console WriteLine(typeof(X));
#1
System.Int32 
System.Collections.Generic.List`1[T] 
System.Collections.Generic.Dictionary`2[TKey,TValue] 
System.Collections.Generic.List`1[System.Int32] 
System.Collections.Generic.Dictionary`2[System.String,System.Int32] 
System.Collections.Generic.List`1[System.Int64] 
System.Collections.Generic.Dictionary`2[System.Int64,System.Guid]
Listing 3.12. Various ways of retrieving generic and constructed Type  objects
string listTypeName = "System.Collections.Generic.List`1"; 
 
Type defByName = Type GetType(listTypeName);

Valid (at compile time)
Invalid
Animal[] animals = new Cat[5]; 
animals[0] = new Turtle();
List<Animal> animals = new List<Cat>(); 
animals.Add(new Turtle());
Figure 3.4. Interfaces for shapes and drawings, and two implementations of each
Listing 3.13. Retrieving and invoking a generic method with reØection
public static void PrintTypeParameter<T>() 
{ 
Console WriteLine(typeof(T));
error CS0029: Cannot implicitly convert type 
      'System.Collections.Generic.List<Cat>' to 
      'System.Collections.Generic.List<Animal>'
T currentValue = iterator.Current;
IEnumerable<IShape> Shapes { get; }

IComparer<IShape> areaComparer = new AreaComparer(); 
List<Circle> circles = new List<Circle>(); 
void Sort<S>(IComparer<S> comparer) where T : S
Listing 3.14. Working around the lack of contravariance with a helper
class ComparisonHelper<TBase, TDerived> : IComparer<TDerived> 
   where TDerived : TBase                                         #1 
{
class AreaComparer<T> : IComparer<T> where T : IShape 
 
class AreaComparer : AreaComparer<IShape>
public T FindMean<T> (IEnumerable<T> data) 
{ 
T sum = default(T);
where T : T operator+ (T, T), T operator/ (T, int)
SomeClass<string> instance = new SomeClass<string><Guid>("x");#1 
int x = instance.SomeProperty<int>; 
byte y = instance SomeIndexer<byte>["key"];
ArrayList<String> strings = new ArrayList<String>(); 
strings.add("hello"); 
String entry = strings.get(0); 
strings.add(new Object());
ArrayList strings = new ArrayList(); 
strings.add("hello"); 

String entry = (String) strings.get(0); 
strings.add(new Object());

CHAPTER 4
Figure 4.1. Sample values of Nullable<int>
Listing 4.1. Using various members of Nullable<T>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
static void Display(Nullable<int> x) 
{ 
   Console.WriteLine("HasValue: {0}", x.HasValue); 
   if (x.HasValue) 
   { 
      Console.WriteLine("Value: {0}", x.Value); 
      Console.WriteLine("Explicit conversion: {0}", (int)x); 
   } 
   Console.WriteLine("GetValueOrDefault(): {0}", 
                     x.GetValueOrDefault()); 
   Console.WriteLine("GetValueOrDefault(10): {0}", 
                     x.GetValueOrDefault(10)); 
   Console.WriteLine("ToString(): \"{0}\"", x.ToString()); 
   Console.WriteLine("GetHashCode(): {0}", x.GetHashCode()); 
   Console.WriteLine(); 
} 
... 
Nullable<int> x = 5;        
x = new Nullable<int>(5); 
Console.WriteLine("Instance with value:"); 
Display(x); 
x = new Nullable<int>(); 
Console.WriteLine("Instance without value:"); 
Display(x);
1
2
3
1
2
3
4
Instance with value: 
HasValue: True 
Value: 5 
Explicit conversion: 5 

Figure 4.2. Results of boxing an instance without a value (top) and with a value (bottom)
5
6
7
8
9
10
11
12
13
14
15
16
GetValueOrDefault(): 5 
GetValueOrDefault(10): 5 
ToString(): "5" 
GetHashCode(): 5 
 
Instance without value: 
HasValue: False 
GetValueOrDefault(): 0 
GetValueOrDefault(10): 10 
 
ToString(): "" 
GetHashCode(): 0
Listing 4.2. Boxing and unboxing behavior of nullable types
1
2
3
4
5
6
7
8
9
10
11
12
Nullable<int> nullable = 5;  
object boxed = nullable;  
Console.WriteLine(boxed.GetType()); 
int normal = (int)boxed;  
Console.WriteLine(normal); 
nullable = (Nullable<int>)boxed; 
Console.WriteLine(nullable); 
nullable = new Nullable<int>(); 
boxed = nullable; 
Console.WriteLine(boxed == null); 
nullable = (Nullable<int>)boxed; 
Console.WriteLine(nullable.HasValue);
1
2
3
4
5

1
2
public static int Compare<T>(Nullable<T> n1, Nullable<T> n2) 
public static bool Equals<T>(Nullable<T> n1, Nullable<T> n2)
1 public static Type GetUnderlyingType(Type nullableType)
Listing 4.3. The same code as 4.2 but using the ?  modi×er
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
int? nullable = 5; 
 
object boxed = nullable; 
Console.WriteLine(boxed.GetType()); 
 
int normal = (int)boxed; 
Console.WriteLine(normal); 
 
nullable = (int?)boxed; 
Console.WriteLine(nullable); 
 
nullable = new int?(); 
 
boxed = nullable; 
Console.WriteLine(boxed == null); 
 
nullable = (int?)boxed; 
Console.WriteLine(nullable.HasValue);
Listing 4.4. Part of a Person  class including calculation of age
1
2
3
4
5
6
7
8
9
10
class Person 
{ 
   DateTime birth; 
   DateTime? death; 
   string name; 
   public TimeSpan Age 
   { 
      get 
      { 
         if (death == null) 
1

Table 4.1. Examples of lifted operators applied to nullable integers
Expression
Lifted operator
Result
-nullInt 
-five 
five + nullInt 
five + five 
nullInt == nullInt 
five == five 
five == nullInt 
five == four 
four < five 
nullInt < five 
five < nullInt 
nullInt < nullInt 
nullInt <= nullInt
int? –(int? x) 
int? –(int? x) 
int? +(int? x, int? y) 
int? +(int? x, int? y) 
bool ==(int? x, int? y) 
bool ==(int? x, int? y) 
bool ==(int? x, int? y) 
bool ==(int? x, int? y) 
bool <(int? x, int? y) 
bool <(int? x, int? y) 
bool <(int? x, int? y) 
bool <(int? x, int? y) 
bool <=(int? x, int? y)
null 
-5 
null 
10 
true 
true 
false 
false 
true 
false 
false 
false 
false
Table 4.2. Truth table for the logical operators AND, inclusive OR, exclusive OR, and
logical negation, applied to the bool?  type
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
         { 
            return DateTime.Now - birth; 
         } 
         else 
         { 
            return death.Value - birth; 
         } 
      } 
   } 
   public Person(string name, 
                 DateTime birth, 
                 DateTime? death) 
   { 
      this.birth = birth; 
      this.death = death; 
      this.name = name; 
   } 
} 
... 
Person turing = new Person("Alan Turing ", 
                           new DateTime(1912, 6, 23), 
                           new DateTime(1954, 6, 7)); 
Person knuth = new Person("Donald Knuth ", 
                          new DateTime(1938, 1, 10), 
                          null);
2
3
4
1
2
3
4
5
int i = 5; 
if (i == null) 
{ 
   Console.WriteLine ("Never going to happen"); 
}

x
y
x & y
x | y
x ^ y
!x
x
y
x & y
x | y
x ^ y
!x
true 
true 
true 
false 
false 
false 
null 
null 
null
true 
false 
null 
true 
false 
null 
true 
false 
null
true 
false 
null 
false 
false 
false 
null 
false 
null
true 
true 
true 
true 
false 
null 
true 
null 
null
false 
true 
null 
true 
false 
null 
null 
null 
null
false 
false 
false 
true 
true 
true 
null 
null 
null
1
2
3
4
5
6
7
8
9
static void PrintValueAsInt32(object o) 
{ 
   int? nullable = o as int?; 
   Console.WriteLine(nullable.HasValue ?  
                     nullable.Value.ToString() : "null"); 
} 
... 
PrintValueAsInt32(5);  
PrintValueAsInt32("some string");
1
2
1
2
3
int? a = 5; 
int b = 10; 
int c = a ?? b;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
DateTime birth; 
DateTime? death; 
 
public TimeSpan Age 
{ 
   get 
   { 
      if (death == null) 
      { 
         return DateTime.Now - birth; 
      } 
      else 
      { 
         return death.Value - birth; 
      } 
   } 
}

1
2
DateTime lastAlive = (death == null ? DateTime.Now : death.Value); 
return lastAlive - birth;
1
2
DateTime lastAlive = death ?? DateTime.Now; 
return lastAlive - birth;
1 return (death ?? DateTime.Now) - birth;
1
2
3
4
5
6
7
8
9
10
Address contact = user.ContactAddress; 
if (contact == null) 
{ 
   contact = order.ShippingAddress; 
   if (contact == null) 
   { 
 
      contact = user.BillingAddress; 
   } 
}
1
2
3
Address contact = user.ContactAddress ?? 
                  order.ShippingAddress ?? 
                  user.BillingAddress;
1
2
3
4
5
6
7
ArrayList list = hash[key]; 
if (list == null) 
{ 
   list = new ArrayList(); 
   hash[key] = list; 
} 
list.Add(newItem);

Listing 4.5. An alternative implementation of the TryXXX  pattern
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
static int? TryParse(string text) 
{ 
   int ret; 
   if (int.TryParse(text, out ret)) 
   { 
      return ret; 
   } 
   else 
   { 
      return null; 
   } 
} 
... 
int? parsed = TryParse("Not valid"); 
if (parsed != null) 
{ 
   Console.WriteLine ("Parsed to {0}", parsed.Value); 
} 
else 
{ 
   Console.WriteLine ("Couldn't parse"); 
}
1
2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
public int Compare(Product first, Product second) 
{ 
   // Reverse comparison of popularity to sort descending 
   int ret = second.Popularity.CompareTo(first.Popularity); 
   if (ret != 0) 
   { 
      return ret; 
   } 
   ret = first.Price.CompareTo(second.Price); 
   if (ret != 0) 
   { 
      return ret; 
   } 
   return first.Name.CompareTo(second.Name); 
}
Listing 4.6. Helper class for providing partial comparisons
1
2
3
4
5
6
7
8
9
10
11
12
public static class PartialComparer 
{ 
   public static int? Compare<T>(T first, T second) 
   { 
      return Compare(Comparer<T>.Default, first, second); 
   } 
 
   public static int? Compare<T>(IComparer<T> comparer, 
                                 T first, T second) 
   { 
      int ret = comparer.Compare(first, second); 
      return ret == 0 ? new int?() : ret; 

13
14
15
16
17
18
19
20
21
22
23
   } 
 
   public static int? ReferenceCompare<T>(T first, T second) 
      where T : class 
   { 
       return first == second ? 0 
            : first == null ? -1 
            : second == null ? 1 
            : new int?(); 
   } 
}
public int Compare(Product first, Product second) 
{ 
  return PC.ReferenceCompare(first, second) ?? 
         // Reverse comparison of popularity to sort descending 
         PC.Compare(second.Popularity, first.Popularity) ?? 
         PC.Compare(first.Price, second.Price) ?? 
         PC.Compare(first.Name, second.Name) ?? 
         0; 
}

CHAPTER 5
Listing 5.1. Subscribing to three of a button’s events
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
static void LogPlainEvent(object sender, EventArgs e) 
{ 
   Console.WriteLine("LogPlain"); 
} 
 
static void LogKeyEvent(object sender, KeyPressEventArgs e) 
{ 
   Console.WriteLine("LogKey"); 
} 
 
static void LogMouseEvent(object sender, MouseEventArgs e) 
{ 
   Console.WriteLine("LogMouse"); 
} 
... 
Button button = new Button(); 
button.Text = "Click me"; 
button.Click      += new EventHandler(LogPlainEvent); 
button.KeyPress   += new KeyPressEventHandler(LogKeyEvent); 
button.MouseClick += new MouseEventHandler(LogMouseEvent); 
 
Form form = new Form(); 
form.AutoSize = true; 
form.Controls.Add(button); 
Application.Run(form);
1 new KeyPressEventHandler(LogKeyEvent)
1 Thread t = new Thread(new ThreadStart(MyMethod));
1 button.KeyPress += LogKeyEvent;
1 Thread t = new Thread(MyMethod);

1
2
void MyMethod() 
void MyMethod(object sender, EventArgs e)
1
2
ThreadStart x = MyMethod; 
EventHandler y = MyMethod;
1
2
Delegate invalid = SomeMethod; 
Delegate valid = (ThreadStart)SomeMethod;
1
2
3
4
5
6
7
8
9
10
static void SimpleInvoke(Control control, 
                         MethodInvoker invoker) 
{ 
   control.Invoke(invoker); 
} 
... 
SimpleInvoke(form, UpdateUI); 
form.Invoke((MethodInvoker)UpdateUI); 
MethodInvoker invoker = UpdateUI;  
form.Invoke(invoker);
1
2
3
1
2
3
void EventHandler(object sender, EventArgs e) 
void KeyPressEventHandler(object sender, KeyPressEventArgs e) 
void MouseEventHandler(object sender, MouseEventArgs e)
Listing 5.2. Demonstration of method group conversions and delegate contravariance
1
2
static void LogPlainEvent(object sender, EventArgs e) 
{ 
1

3
4
5
6
7
8
9
10
11
12
13
14
   Console.WriteLine("An event occurred"); 
} 
... 
Button button = new Button(); 
button.Text = "Click me"; 
button.Click += LogPlainEvent; 
button.KeyPress += LogPlainEvent; 
button.MouseClick += LogPlainEvent;  
Form form = new Form(); 
form.AutoSize = true; 
form.Controls.Add(button); 
Application.Run(form);
2
3
1 delegate Stream StreamFactory();
Listing 5.3. Demonstration of covariance of return types for delegates
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
delegate Stream StreamFactory(); 
static MemoryStream GenerateSampleData()  
{ 
   byte[] buffer = new byte[16]; 
   for (int i = 0; i < buffer.Length; i++) 
   { 
      buffer[i] = (byte) i; 
   } 
   return new MemoryStream(buffer); 
} 
... 
StreamFactory factory = GenerateSampleData; 
using (Stream stream = factory())  
{ 
   int data; 
   while ((data = stream.ReadByte()) != -1) 
   { 
      Console.WriteLine(data); 
   } 
}
1
2
3
4
1
2
EventHandler general = new EventHandler(HandleEvent); 
KeyPressEventHandler key = new KeyPressEventHandler(general);

Listing 5.4. Demonstration of breaking change between C# 1 and C# 2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
delegate void SampleDelegate(string x); 
 
public void CandidateAction(string x) 
{ 
   Console.WriteLine("Snippet.CandidateAction"); 
} 
 
public class Derived : Snippet 
{ 
   public void CandidateAction(object o) 
   { 
      Console.WriteLine("Derived.CandidateAction"); 
   } 
} 
... 
Derived x = new Derived(); 
SampleDelegate factory = new SampleDelegate(x.CandidateAction); 
factory("test");
1 public delegate void Action<T>(T obj)
Listing 5.5. Anonymous methods used with the Action<T>  delegate type
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
Action<string> printReverse = delegate(string text)  
{ 
   char[] chars = text.ToCharArray(); 
   Array.Reverse(chars); 
   Console.WriteLine(new string(chars)); 
}; 
Action<int> printRoot = delegate(int number) 
{ 
   Console.WriteLine(Math.Sqrt(number)); 
}; 
Action<IList<double>> printMean = delegate(IList<double> numbers) 
{ 
   double total = 0; 
   foreach (double value in numbers)  
   {  
      total += value;  
   } 
   Console.WriteLine(total / numbers.Count); 
}; 
printReverse("Hello world"); 
printRoot(2); 
printMean(new double[] { 1.5, 2.5, 3, 4.5 });
1
2
3

Listing 5.6. Extreme example of code compactness. Warning: unreadable code ahead!
1
2
3
4
5
6
7
8
List<int> x = new List<int>(); 
x.Add(5); 
x.Add(10); 
x.Add(15); 
x.Add(20); 
x.Add(25); 
 
x.ForEach(delegate(int n){Console.WriteLine(Math.Sqrt(n));});
1
2
3
4
5
6
7
x.ForEach(delegate(int n) 
   { Console.WriteLine(Math.Sqrt(n)); } 
); 
 
x.ForEach(delegate(int n) { 
   Console.WriteLine(Math.Sqrt(n)); 
});
public delegate bool Predicate<T>(T obj)
Listing 5.7. Returning a value from an anonymous method
Predicate<int> isEven = delegate(int x) { return x % 2 == 0; }; 
 
Console WriteLine(isEven(1));
Listing 5.8. Using anonymous methods to sort ×les simply
static void SortAndShowFiles(string title, Comparison<FileInfo> sortOrder) 
{ 
FileInfo[] les = newDirectoryInfo(@"C:\") GetFiles();

Listing 5.9. Subscribing to events with anonymous methods that ignore parameters
Button button = new Button(); 
button.Text = "Click me"; 
button Click
+= delegate { Console WriteLine("LogPlain"); };
button.Click += delegate(object sender, EventArgs e) { ... };
public event EventHandler Click = delegate {};
public Thread(ParameterizedThreadStart start) 
public Thread(ThreadStart start) 
public Thread(ParameterizedThreadStart start, int maxStackSize) 
public Thread(ThreadStart start, int maxStackSize)
public delegate void ThreadStart() 
public delegate void ParameterizedThreadStart(object obj)
new Thread(delegate()         { Console.WriteLine("t1"); } ); 
new Thread(delegate(object o) { Console.WriteLine("t2"); } ); 
new Thread(delegate           { Console.WriteLine("t3"); } );
Listing 5.10. Examples of variable kinds with respect to anonymous methods
void EnclosingMethod() 
{ 
int outerVariable = 5;
#1
Listing 5.11. Accessing a variable both inside and outside an anonymous method
string captured = "before x is created"; 
 
MethodInvoker x = delegate

int single; 
for (int i = 0; i < 10; i++) 
{ 
   single = 5; 
   Console.WriteLine(single + i); 
}
for (int i = 0; i < 10; i++) 
{ 
   int multiple = 5; 
   Console.WriteLine(multiple + i); 
}
Figure 5.1. Snapshot of multiple captured variable scopes in memory
directly before x is invoked 
changed by x 
before second invocation
List<Person> FindAllYoungerThan(List<Person> people, int limit) 
{ 
   return people.FindAll(delegate (Person person) 
      { return person.Age < limit; } 
   ); 
}
Listing 5.12. Demonstration of a captured variable having its lifetime extended
static MethodInvoker CreateDelegateInstance() 
{ 
int counter = 5;
Listing 5.13. Capturing multiple variable instantiations with multiple delegates
List<MethodInvoker> list = new List<MethodInvoker>(); 
for (int index = 0; index < 5; index++) 
{
Listing 5.14. Capturing variables in different scopes. Warning: nasty code ahead!
MethodInvoker[] delegates = new MethodInvoker[2]; 
int outside = 0;                                              #1 
for (int i = 0; i < 2; i++)


CHAPTER 6
Listing 6.1. Code using the (as yet unimplemented) new collection type
1
2
3
4
5
6
object[] values = {"a", "b", "c", "d", "e"}; 
IterationSample collection = new IterationSample(values, 3); 
foreach (object x in collection) 
{ 
   Console.WriteLine (x); 
}
Listing 6.2. Skeleton of the new collection type, with no iterator implementation
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
using System; 
using System.Collections; 
 
public class IterationSample : IEnumerable 
{ 
   object[] values; 
   int startingPoint; 
 
   public IterationSample(object[] values, int startingPoint) 
   { 
      this.values = values; 
      this.startingPoint = startingPoint; 
   } 
 
   public IEnumerator GetEnumerator() 
   { 
      throw new NotImplementedException(); 
   } 
}
Listing 6.3. Nested class implementing the collection’s iterator
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class IterationSampleIterator : IEnumerator 
{                                                                  
   IterationSample parent; 
   int position;  
   internal IterationSampleIterator(IterationSample parent) 
   { 
      this.parent = parent; 
      position = -1; 
   } 
   public bool MoveNext() 
   { 
      if (position != parent.values.Length)  
      { 
         position++; 
1
2
3
4

15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
      } 
      return position < parent.values.Length; 
   } 
   public object Current 
   { 
      get 
      { 
         if (position == -1 ||  
             position == parent.values.Length) 
         { 
            throw new InvalidOperationException(); 
         } 
         int index = position + parent.startingPoint; 
         index = index % parent.values.Length; 
         return parent.values[index]; 
      } 
   } 
   public void Reset() 
   { 
      position = -1; 
   } 
}
5
6
7
1
2
3
4
public IEnumerator GetEnumerator() 
{ 
   return new IterationSampleIterator(this); 
}
Listing 6.4. Iterating through the sample collection with C# 2 and yield return
1
2
3
4
5
6
7
public IEnumerator GetEnumerator() 
{ 
   for (int index = 0; index < values.Length; index++) 
   { 
      yield return values[(index + startingPoint) % values.Length]; 
   } 
}
Listing 6.5. Showing the sequence of calls between an iterator and its caller
1
2
3
4
5
6
7
static readonly string Padding = new string(' ', 30); 
 
static IEnumerable<int> CreateEnumerable() 
{ 
   Console.WriteLine("{0}Start of CreateEnumerable()", Padding); 
 
   for (int i=0; i < 3; i++) 

8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
   { 
      Console.WriteLine("{0}About to yield {1}", Padding, i); 
      yield return i; 
      Console.WriteLine("{0}After yield", Padding); 
   } 
   Console.WriteLine("{0}Yielding final value", Padding); 
 
   yield return -1; 
 
   Console.WriteLine("{0}End of CreateEnumerable()", Padding); 
} 
... 
IEnumerable<int> iterable = CreateEnumerable(); 
IEnumerator<int> iterator = iterable.GetEnumerator(); 
Console.WriteLine("Starting to iterate"); 
while (true) 
{ 
   Console.WriteLine("Calling MoveNext()..."); 
   bool result = iterator.MoveNext(); 
   Console.WriteLine("... MoveNext result={0}", result); 
   if (!result) 
   { 
      break; 
   } 
   Console.WriteLine("Fetching Current..."); 
   Console.WriteLine("... Current result={0}", iterator.Current); 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
Starting to iterate 
Calling MoveNext()... 
                              Start of CreateEnumerable() 
                              About to yield 0 
... MoveNext result=True 
Fetching Current... 
... Current result=0 
Calling MoveNext()... 
                              After yield 
                              About to yield 1 
... MoveNext result=True 
Fetching Current... 
... Current result=1 
Calling MoveNext()... 
                              After yield 
                              About to yield 2 
... MoveNext result=True 
Fetching Current... 
... Current result=2 
Calling MoveNext()... 
                              After yield 
 
                              Yielding final value 
... MoveNext result=True 
Fetching Current... 
... Current result=-1 
Calling MoveNext()... 
                              End of CreateEnumerable() 
... MoveNext result=False

Listing 6.6. Demonstration of yield break
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
static IEnumerable<int> CountWithTimeLimit(DateTime limit) 
{ 
   for (int i = 1; i <= 100; i++) 
   { 
      if (DateTime.Now >= limit) 
      { 
         yield break; 
      } 
      yield return i; 
   } 
} 
... 
DateTime stop = DateTime.Now.AddSeconds(2); 
foreach (int i in CountWithTimeLimit(stop)) 
{ 
   Console.WriteLine("Received {0}", i); 
   Thread.Sleep(300); 
}
1
Listing 6.7. Demonstration of yield break  working with try / finally
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
static IEnumerable<int> CountWithTimeLimit(DateTime limit) 
{  
   try  
   { 
   for (int i = 1; i <= 100; i++) 
   { 
      if (DateTime.Now >= limit) 
      { 
         yield break; 
      } 
      yield return i; 
   } 
   }  
   finally  
   {  
      Console.WriteLine("Stopping!"); 
   } 
} 
... 
DateTime stop = DateTime.Now.AddSeconds(2); 
foreach (int i in CountWithTimeLimit(stop)) 
{ 
   Console.WriteLine("Received {0}", i); 
   Thread.Sleep(300); 
}
1
1
2
3
4
DateTime stop = DateTime.Now.AddSeconds(2); 
foreach (int i in CountWithTimeLimit(stop)) 
{ 
   Console.WriteLine ("Received {0}", i); 

5
6
7
8
9
10
11
   if (i > 3) 
   { 
      Console.WriteLine("Returning"); 
      return; 
   } 
   Thread.Sleep(300); 
}
1
2
3
4
5
6
Received 1 
Received 2 
Received 3 
Received 4 
Returning 
Stopping!
1
2
3
4
5
6
7
8
9
DateTime stop = DateTime.Now.AddSeconds(2); 
IEnumerable<int> iterable = CountWithTimeLimit(stop); 
IEnumerator<int> iterator = iterable.GetEnumerator(); 
 
iterator.MoveNext(); 
Console.WriteLine("Received {0}", iterator.Current); 
 
iterator.MoveNext(); 
Console.WriteLine("Received {0}", iterator.Current);
1
2
3
for (DateTime day = timetable.StartDate; 
     day <= timetable.EndDate; 
     day = day.AddDays(1))
1 foreach (DateTime day in timetable.DateRange)
1
2
3
4
5
6
7
public IEnumerable<DateTime> DateRange 
{ 
   get 
   { 
      for (DateTime day = StartDate; 
           day <= EndDate; 
           day = day.AddDays(1)) 

8
9
10
11
12
      { 
         yield return day; 
      } 
   } 
}
1
2
3
4
5
6
7
8
using (TextReader reader = File.OpenText(filename)) 
{ 
   string line; 
   while ((line = reader.ReadLine()) != null) 
   { 
      // Do something with line 
   } 
}
Listing 6.8. Looping over the lines in a ×le using an iterator block
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
static IEnumerable<string> ReadLines(string filename) 
{ 
   using (TextReader reader = File.OpenText(filename)) 
   { 
      string line; 
      while ((line = reader.ReadLine()) != null) 
      { 
         yield return line; 
      } 
   } 
} 
... 
foreach (string line in ReadLines("test.txt")) 
{ 
   Console.WriteLine(line); 
}
1 static IEnumerable<string> ReadLines(TextReader reader)
1 public delegate TResult Func<TResult>()

1
2
3
4
5
6
7
8
9
10
11
static IEnumerable<string> ReadLines(Func<TextReader> provider) 
{ 
   using (TextReader reader = provider()) 
   { 
      string line; 
      while ((line = reader.ReadLine()) != null) 
      { 
         yield return line; 
      } 
   } 
}
1
2
3
4
5
6
7
8
9
10
11
static IEnumerable<string> ReadLines(string filename) 
{ 
   return ReadLines(filename, Encoding.UTF8); 
} 
 
static IEnumerable<string> ReadLines(string filename, Encoding encoding) 
{ 
   return ReadLines(delegate { 
      return File.OpenText(filename, encoding); 
   }); 
}
Listing 6.9. Implementing LINQ’s Where  method using iterator blocks
public static IEnumerable<T> Where<T>(IEnumerable<T> source, 
                                     Predicate<T> predicate) 
{ 
  if (source == null || predicate == null)  
  { 
     throw new ArgumentNullException(); 
  } 
  return WhereImpl(source, predicate); 
} 
private static IEnumerable<T> WhereImpl<T>(IEnumerable<T> source, 
                                          Predicate<T> predicate) 
{ 
  foreach (T item in source) 
  { 
     if (predicate(item)) 
     { 
        yield return item; 
     } 
  } 
} 
... 
IEnumerable<string> lines = LineReader.ReadLines("../../FakeLinq.cs"); 
Predicate<string> predicate = delegate(string line) 
  { return line.StartsWith("using"); }; 
foreach (string line in Where(lines, predicate)) 
{ 
  Console.WriteLine(line); 
}

HoldingsValue ComputeTotalStockValue(string user, string password) 
{ 
  Token token = AuthService.Check(user, password); 
  Holdings stocks = DbService.GetStockHoldings(token); 
  StockRates rates = StockService.GetRates(token); 
  return ProcessStocks(stocks, rates); 
}
void StartComputingTotalStockValue(string user, string password) 
{ 
  AuthService.BeginCheck(user, password, AfterAuthCheck, null); 
} 
void AfterAuthCheck(IAsyncResult result) 
{ 
  Token token = AuthService.EndCheck(result); 
  IAsyncResult holdingsAsync = DbService.BeginGetStockHoldings 
     (token, null, null); 
  StockService.BeginGetRates(token, AfterGetRates, holdingsAsync); 
} 
void AfterGetRates(IAsyncResult result) 
{ 
  IAsyncResult holdingsAsync = (IAsyncResult)result.AsyncState; 
  StockRates rates = StockService.EndGetRates(result); 
  Holdings stocks = DbService.EndGetStockHoldings(holdingsAsync); 
  OnRequestComplete(ProcessStocks(stocks, rates)); 
}
static IEnumerator<ITask> ComputeTotalStockVal.(str.user,str.pass) 
{ 
  string token = null; 
  yield return Arbiter.Receive(false, AuthService.CcrCheck(user, pass), 
     delegate(string t) { token = t; }); 
  IEnumerable<Holding> stocks = null; 
  IDictionary<string,decimal> rates = null; 
  yield return Arbiter.JoinedReceive(false, 
     DbService.CcrGetStockHoldings(token), 
     StockService.CcrGetRates(token), 
     delegate(IEnumerable<Holding> s, IDictionary<string,decimal> r) 
       { stocks = s; rates = r; }); 
  OnRequestComplete(ComputeTotal(stocks, rates)); 
}


CHAPTER 7
Figure 7.1. Code in partial types is able to see all of the members of the type, regardless
of which ×le each member is in.
Figure 7.2. Comparison between XAML precompilation and autogenerated entity
classes
Listing 7.1. Demonstration of mixing declarations of a partial type
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
// Example1.cs 
using System; 
partial class Example<TFirst, TSecond> 
   : IEquatable<string> 
   where TFirst : class 
{ 
   public bool Equals(string other) 
   { 
      return false; 
   } 
} 
// Example2.cs 
using System; 
partial class Example<TFirst, TSecond> 
    : EventArgs, IDisposable 
{ 
   public void Dispose() 
   { 
   } 
}
1
2
3
4

Listing 7.2. A partial method called from a constructor
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
// Generated.cs 
using System; 
partial class PartialMethodDemo 
{ 
   public PartialMethodDemo() 
   { 
      OnConstructorStart(); 
      Console.WriteLine("Generated constructor"); 
      OnConstructorEnd(); 
   } 
 
   partial void OnConstructorStart(); 
   partial void OnConstructorEnd(); 
} 
 
// Handwritten.cs 
 
using System; 
partial class PartialMethodDemo 
{ 
   partial void OnConstructorEnd() 
   { 
      Console.WriteLine("Manual code"); 
   } 
}
1 LogEntity(LoadAndCache(id));
1
2
MyEntity entity = LoadAndCache(id); 
LogEntity(entity);

Listing 7.3. A typical C# 1 utility class
1
2
3
4
5
6
7
8
9
10
11
12
public sealed class NonStaticStringHelper 
{ 
    private NonStaticStringHelper()  
    { 
    } 
    public static string Reverse(string input) 
    { 
        char[] chars = input.ToCharArray(); 
        Array.Reverse(chars); 
        return new string(chars); 
    } 
}
1
2
3
Listing 7.4. The same utility class as in listing 7.3, but converted into a C# 2 static class
1
2
3
4
5
6
7
8
9
10
11
using System; 
 
public static class StringHelper 
{ 
   public static string Reverse(string input) 
   { 
      char[] chars = input.ToCharArray(); 
      Array.Reverse(chars); 
      return new string(chars); 
   } 
}
1
2
3
4
5
StringHelper variable = null; 
StringHelper[] array = null; 
public void Method1(StringHelper x) {} 
public StringHelper Method1() { return null; } 
List<StringHelper> x = new List<StringHelper>();
1
2
3
4
5
6
string name; 
 
public string Name 
{ 
   get { return name; } 
   private set 

7
8
9
10
11
   { 
      // Validation, logging etc here 
      name = value; 
   } 
}
Listing 7.5. Using aliases to distinguish between different Button  types
1
2
3
4
5
6
7
8
9
10
11
12
using System; 
using WinForms = System.Windows.Forms; 
using WebForms = System.Web.UI.WebControls; 
 
class Test 
{ 
   static void Main() 
   { 
      Console.WriteLine(typeof(WinForms.Button)); 
      Console.WriteLine(typeof(WebForms.Button)); 
   } 
}
Listing 7.6. Using ::  to tell the compiler to use aliases
1
2
3
4
5
6
7
8
9
10
11
12
13
14
using System; 
using WinForms = System.Windows.Forms; 
using WebForms = System.Web.UI.WebControls; 
 
class WinForms {} 
 
class Test 
{ 
   static void Main() 
   { 
      Console.WriteLine(typeof(WinForms::Button)); 
      Console.WriteLine(typeof(WebForms::Button)); 
   } 
}
Listing 7.7. Use of the global namespace alias to specify the desired type exactly
1
2
3
4
5
6
7
using System; 
 
class Configuration {} 
 
namespace Chapter7 
{ 
   class Configuration {} 

Figure 7.3. Part of the Properties window of Visual Studio 2010, showing an extern alias
of FirstAlias for the First.dll reference
8
9
10
11
12
13
14
15
16
17
18
 
   class Test 
   { 
      static void Main() 
      { 
         Console.WriteLine(typeof(Configuration)); 
         Console.WriteLine(typeof(global::Configuration)); 
         Console.WriteLine(typeof(global::Chapter7.Test)); 
      } 
   } 
}
Listing 7.8. Working with different types of the same type in different assemblies
1
2
3
4
5
6
7
8
9
10
11
12
13
14
// Compile with 
// csc Test.cs /r:FirstAlias=First.dll /r:SecondAlias=Second.dll 
extern alias FirstAlias;  
extern alias SecondAlias; 
using System; 
using FD = FirstAlias::Demo;  
class Test 
{ 
   static void Main() 
   { 
      Console.WriteLine(typeof(FD.Example));  
      Console.WriteLine(typeof(SecondAlias::Demo.Example)); 
   } 
}
1
2
3
4
Listing 7.9. Class containing an unused ×eld

1
2
3
4
public class FieldUsedOnlyByReflection 
{ 
   int x; 
}
1
2
FieldUsedOnlyByReflection.cs(3,9): warning CS0169: 
The private field 'FieldUsedOnlyByReflection.x' is never used
Listing 7.10. Disabling (and restoring) warning CS0169
1
2
3
4
5
6
public class FieldUsedOnlyByReflection 
{ 
#pragma warning disable 0169 
   int x; 
#pragma warning restore 0169 
}
1 #pragma checksum "filename" "{guid}" "checksum bytes"
1 fixed byte data[20];
Listing 7.11. Demonstration of ×xed-size buffers to obtain console color information
1
2
3
4
5
6
7
8
9
10
11
12
using System; 
using System.Runtime.InteropServices; 
 
struct COORD 
{ 
   public short X, Y; 
} 
 
struct SMALL_RECT 
{ 
   public short Left, Top, Right, Bottom; 
} 

13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
 
unsafe struct CONSOLE_SCREEN_BUFFER_INFOEX 
{ 
   public int StructureSize; 
   public COORD ConsoleSize, CursorPosition; 
   public short Attributes; 
   public SMALL_RECT DisplayWindow; 
   public COORD MaximumWindowSize; 
   public short PopupAttributes; 
   public int FullScreenSupported; 
   public fixed int ColorTable[16]; 
} 
 
static class FixedSizeBufferDemo 
{ 
   const int StdOutputHandle = -11; 
 
   [DllImport("kernel32.dll")] 
   static extern IntPtr GetStdHandle(int nStdHandle); 
 
   [DllImport("kernel32.dll")] 
   static extern bool GetConsoleScreenBufferInfoEx 
      (IntPtr handle, ref CONSOLE_SCREEN_BUFFER_INFOEX info); 
 
   unsafe static void Main() 
   { 
      IntPtr handle = GetStdHandle(StdOutputHandle); 
      CONSOLE_SCREEN_BUFFER_INFOEX info; 
      info = new CONSOLE_SCREEN_BUFFER_INFOEX(); 
      info.StructureSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX); 
      GetConsoleScreenBufferInfoEx(handle, ref info); 
 
      for (int i=0; i < 16; i++) 
      { 
 
         Console.WriteLine ("{0:x6}", info.ColorTable[i]); 
      } 
   } 
}
Listing 7.12. Demonstration of friend assemblies
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
// Compiled to Source.dll 
using System.Runtime.CompilerServices; 
[assembly:InternalsVisibleTo("FriendAssembly")] 
public class Source 
{ 
   internal static void InternalMethod() {} 
   public static void PublicMethod() {} 
} 
// Compiled to FriendAssembly.dll 
public class Friend 
{ 
   static void Main() 
   { 
      Source.InternalMethod();  
      Source.PublicMethod(); 
   } 
} 
// Compiled to EnemyAssembly.dll 
public class Enemy 
{ 
   static void Main() 
1
2

22
23
24
25
26
   { 
      // Source.InternalMethod(); 
      Source.PublicMethod();  
   } 
}
3
4
1
2
3
4
5
6
7
8
9
10
11
12
c:\Users\Jon\Test>sn -Tp FriendAssembly.dll 
Microsoft (R) .NET Framework Strong Name Utility Version 3.5.21022.8 
Copyright (c) Microsoft Corporation. All rights reserved. 
Public key is 
0024000004800000940000000602000000240000525341310004000001 
000100a51372c81ccfb8fba9c5fb84180c4129e50f0facdce932cf31fe 
563d0fe3cb6b1d5129e28326060a3a539f287aaf59affc5aabc4d8f981 
e1a82479ab795f410eab22e3266033c633400463ee7513378bb4ef41fc 
0cae5fb03986d133677c82a865b278c48d99dc251201b9c43edd7bedef 
d4b5306efd0dec7787ec6b664471c2 
 
Public key token is 647b99330b7f792c
1
2
3
4
5
6
7
[assembly:InternalsVisibleTo("FriendAssembly,PublicKey=" + 
"0024000004800000940000000602000000240000525341310004000001" + 
"000100a51372c81ccfb8fba9c5fb84180c4129e50f0facdce932cf31fe" + 
"563d0fe3cb6b1d5129e28326060a3a539f287aaf59affc5aabc4d8f981" + 
"e1a82479ab795f410eab22e3266033c633400463ee7513378bb4ef41fc" + 
"0cae5fb03986d133677c82a865b278c48d99dc251201b9c43edd7bedef" + 
"d4b5306efd0dec7787ec6b664471c2")]

CHAPTER 8
Figure 8.1. Transformation of an automatically implemented property
Listing 8.1. Counting instances awkwardly with a static automatic property
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
public class Person 
{ 
   public string Name { get; private set; }  
   public int Age { get; private set; } 
   private static int InstanceCounter { get; set; } 
   private static readonly object counterLock = new object(); 
   public InstanceCountingPerson(string name, int age) 
   { 
       Name = name; 
       Age = age; 
       lock (counterLock) 
       { 
           InstanceCounter++; 
       } 
   }    
}
1
2
3
1
2
3
4
5
public struct Foo 
{ 
   public int Value { get; private set; } 
 
 

Figure 8.2. Hovering over var in Visual Studio displays the type of the declared
variable.
6
7
8
9
10
   public Foo(int value) 
   { 
      this.Value = value; 
   } 
}
1
2
3
4
5
6
7
8
9
public struct Foo 
{ 
   public int Value { get; private set; } 
 
   public Foo(int value) : this() 
   { 
      this.Value = value; 
   } 
}
1 MyType variableName = someInitialValue;
1 var variableName = someInitialValue;
1
2
var stringVariable = "Hello, world."; 
stringVariable = 0;
1

Figure 8.3. Hovering over the use of an implicitly typed local variable displays its type.
1 var starter = delegate() { Console.WriteLine(); };
1
1 var starter = (ThreadStart) delegate() { Console.WriteLine(); };
1 var args = Environment.GetCommandLineArgs();
1
2
3
for (var i = 0; i < 10; i++) 
using (var x = File.OpenText("test.dat")) 
foreach (var s in Environment.GetCommandLineArgs())
1
2
3
var a = 2147483647; 
var b = 2147483648; 
var c = 4294967295; 

4
5
6
var d = 4294967296; 
var e = 9223372036854775807; 
var f = 9223372036854775808;
Listing 8.2. A fairly simple Person  class used for further demonstrations
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
public class Person 
{ 
   public int Age { get; set; } 
   public string Name { get; set; } 
 
   List<Person> friends = new List<Person>(); 
   public List<Person> Friends { get { return friends; } } 
 
   Location home = new Location(); 
   public Location Home { get { return home; } } 
 
   public Person() { } 
 
   public Person(string name) 
   { 
      Name = name; 
   } 
} 
public class Location 
{ 
   public string Country { get; set; } 
   public string Town { get; set; } 
}
1
2
3
4
5
6
Person tom1 = new Person(); 
tom1.Name = "Tom"; 
tom1.Age = 9; 
 
Person tom2 = new Person("Tom"); 
tom2.Age = 9;
1
2
3
Person tom3 = new Person() { Name = "Tom", Age = 9 }; 
Person tom4 = new Person { Name = "Tom", Age = 9 }; 
Person tom5 = new Person("Tom") { Age = 9 };

List<string> names = new List<string>(); 
names.Add("Holly"); 
names.Add("Jon"); 
names.Add("Tom"); 
names.Add("Robin"); 
names.Add("William");
var names = new List<string> 
{ 
   "Holly", "Jon", "Tom", 
   "Robin", "William" 
};
1
2
3
4
5
6
7
8
Person[] family = new Person[] 
{ 
   new Person { Name = "Holly", Age = 36 }, 
   new Person { Name = "Jon", Age = 36 }, 
   new Person { Name = "Tom", Age = 9 }, 
   new Person { Name = "William", Age = 6 }, 
   new Person { Name = "Robin", Age = 6 } 
};
1
2
3
4
Person tom = new Person("Tom"); 
tom.Age = 9; 
tom.Home.Country = "UK"; 
tom.Home.Town = "Reading";
1
2
3
4
5
Person tom = new Person("Tom") 
{ 
   Age = 9, 
   Home = { Country = "UK", Town = "Reading" } 
};
1
2
3
4
5
6
Dictionary<string,int> nameAgeMap = new Dictionary<string,int> 
{ 
   { "Holly", 36 }, 
   { "Jon", 36 }, 
   { "Tom", 9 } 
};
Listing 8.3. Building up a rich object using object and collection initializers
1
2
3
4
5
6
Person tom = new Person  
{ 
   Name = "Tom", 
   Age = 9, 
   Home = { Town = "Reading", Country = "UK" }, 
   Friends =  
1
2
3

7
8
9
10
11
12
13
14
15
16
17
18
   {                                                   
       new Person { Name = "Alberto" }, 
       new Person("Max"),                              
       new Person { Name = "Zak", Age = 7 }, 
       new Person("Ben"), 
       new Person("Alice")                               
       {                                               
           Age = 9,                                    
           Home = { Town = "Twyford", Country = "UK" }    
       }                                               
   } 
};
4
1 string[] names = {"Holly", "Jon", "Tom", "Robin", "William"};
1 MyMethod({"Holly", "Jon", "Tom", "Robin", "William"});
MyMethod(new string[] {"Holly", "Jon", "Tom", "Robin", "William"});
MyMethod(new[] {"Holly", "Jon", "Tom", "Robin", "William"});
new[] { new MemoryStream(), new StringWriter()} #1 
#1 Invalid 
new[] { (IDisposable) new MemoryStream(), new StringWriter() }

Figure 8.4. Hovering over a variable that’s declared (implicitly) to be of an anonymous
type shows the details of that anonymous type.
Listing 8.4. Creating objects of an anonymous type with Name  and Age  properties
var tom= new { Name = "Tom", Age = 9 }; 
var holly = new { Name = "Holly", Age = 36 }; 
var jon = new { Name = "Jon" Age = 36 } ;
Listing 8.5. Populating an array using anonymous types and then ×nding the total age
var family = new[]                                  #1 
{ 
new { Name = "Holly" Age = 36 }
#2
new { Name = person.Name, IsAdult = (person.Age >= 18) }
new { person.Name, IsAdult = (person.Age >= 18) }
Listing 8.6. Transformation from Person  to a name and adulthood Øag
List<Person> family = new List<Person> 
{ 
new Person { Name = "Holly" Age = 36 }

Figure 8.5. Anonymous types allow you to keep just the data you need for a particular
situation, in a form that’s tailored to that situation, without the tedium of writing a fresh
type each time.

CHAPTER 9
1
2
3
4
5
TResult Func<TResult>() 
TResult Func<T,TResult>(T arg) 
TResult Func<T1,T2,TResult>(T1 arg1, T2 arg2) 
TResult Func<T1,T2,T3,TResult>(T1 arg1, T2 arg2, T3 arg3) 
TResult Func<T1,T2,T3,T4,TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
Listing 9.1. Using an anonymous method to create a delegate instance
1
2
3
4
Func<string,int> returnLength; 
returnLength = delegate (string text) { return text.Length; }; 
 
Console.WriteLine(returnLength("Hello"));
1 (explicitly-typed-parameter-list) => { statements }
Listing 9.2. A long-winded ×rst lambda expression, similar to an anonymous method
1
2
3
4
Func<string,int> returnLength; 
returnLength = (string text) => { return text.Length; }; 
 
Console.WriteLine(returnLength("Hello"));
1 (explicitly-typed-parameter-list) => expression

Figure 9.1. Lambda syntax shortcuts
1 (string text) => text.Length
1 (implicitly-typed-parameter-list) => expression
1 (text) => text.Length
1 parameter-name => expression
1 text => text.Length
Listing 9.3. A concise lambda expression
1
2
3
4
Func<string,int> returnLength; 
returnLength = text => text.Length; 
 
Console.WriteLine(returnLength("Hello"));

Listing 9.4. Manipulating a list of ×lms using lambda expressions
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
class Film 
{ 
   public string Name { get; set; } 
   public int Year { get; set; } 
} 
... 
var films = new List<Film> 
{ 
   new Film { Name = "Jaws", Year = 1975 }, 
   new Film { Name = "Singing in the Rain", Year = 1952 }, 
   new Film { Name = "Some like it Hot", Year = 1959 }, 
   new Film { Name = "The Wizard of Oz", Year = 1939 }, 
   new Film { Name = "It's a Wonderful Life", Year = 1946 }, 
   new Film { Name = "American Beauty", Year = 1999 }, 
   new Film { Name = "High Fidelity", Year = 2000 }, 
   new Film { Name = "The Usual Suspects", Year = 1995 } 
}; 
Action<Film> print =  
   film => Console.WriteLine("Name={0}, Year={1}", 
                             film.Name, film.Year); 
films.ForEach(print); 
films.FindAll(film => film.Year < 1960) 
     .ForEach(print);  
films.Sort((f1, f2) => f1.Name.CompareTo(f2.Name)); 
films.ForEach(print);
1
2
3
4
1
2
private static bool SomeAutoGeneratedName(Film film) 
{ 

3
4
   return film.Year < 1960; 
}
1 films.FindAll(new Predicate<Film>(SomeAutoGeneratedName))
Listing 9.5. Logging events using lambda expressions
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
static void Log(string title, object sender, EventArgs e) 
{ 
   Console.WriteLine("Event: {0}", title); 
   Console.WriteLine(" Sender: {0}", sender); 
   Console.WriteLine(" Arguments: {0}", e.GetType()); 
   foreach (PropertyDescriptor prop in 
            TypeDescriptor.GetProperties(e)) 
   { 
      string name = prop.DisplayName; 
      object value = prop.GetValue(e); 
      Console.WriteLine("    {0}={1}", name, value); 
   } 
} 
 
... 
Button button = new Button { Text = "Click me" }; 
button.Click      += (src, e) => Log("Click", src, e); 
button.KeyPress   += (src, e) => Log("KeyPress", src, e); 
button.MouseClick += (src, e) => Log("MouseClick", src, e); 
 
Form form = new Form { AutoSize = true, Controls = { button } }; 
Application.Run(form);
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
Event: Click 
 Sender: System.Windows.Forms.Button, Text: Click me 
 Arguments: System.Windows.Forms.MouseEventArgs 
   Button=Left 
   Clicks=1 
   X=53 
   Y=17 
   Delta=0 
   Location={X=53,Y=17} 
Event: MouseClick 
 Sender: System.Windows.Forms.Button, Text: Click me 
 Arguments: System.Windows.Forms.MouseEventArgs 
   Button=Left 
   Clicks=1 
   X=53 
   Y=17 

Figure 9.2. Graphical representation of the expression tree created by listing 9.6
Figure 9.3. Type hierarchy from Expression<TDelegate>  up to Expression
18    Delta=0 
   Location={X=53,Y=17}
Listing 9.6. A simple expression tree, adding 2 and 3
1
2
3
4
5
Expression firstArg = Expression.Constant(2); 
Expression secondArg = Expression.Constant(3); 
Expression add = Expression.Add(firstArg, secondArg); 
 
Console.WriteLine(add);

Listing 9.7. Compiling and executing an expression tree
1
2
3
4
5
6
Expression firstArg = Expression.Constant(2); 
Expression secondArg = Expression.Constant(3); 
Expression add = Expression.Add(firstArg, secondArg); 
 
Func<int> compiled = Expression.Lambda<Func<int>>(add).Compile(); 
Console.WriteLine(compiled());
Listing 9.8. Using lambda expressions to create expression trees
1
2
3
Expression<Func<int>> return5 = () => 5; 
Func<int> compiled = return5.Compile(); 
Console.WriteLine(compiled());
Listing 9.9. Demonstration of a more complicated expression tree
Expression<Func<string, string, bool>> expression = 
  (x, y) => x.StartsWith(y); 
var compiled = expression.Compile(); 
Console.WriteLine(compiled("First", "Second")); 
Console.WriteLine(compiled("First", "Fir"));
Listing 9.10. Building a method call expression tree in code
1
2
3
4
5
6
7
8
9
10
11
12
13
MethodInfo method = typeof(string).GetMethod 
   ("StartsWith", new[] { typeof(string) });  
var target = Expression.Parameter(typeof(string), "x"); 
var methodArg = Expression.Parameter(typeof(string), "y"); 
Expression[] methodArgs = new[] { methodArg };  
Expression call = Expression.Call(target, method, methodArgs);  
 
var lambdaParameters = new[] { target, methodArg }; 
var lambda = Expression.Lambda<Func<string, string, bool>>  
   (call, lambdaParameters);  
var compiled = lambda.Compile(); 
Console.WriteLine(compiled("First", "Second")); 
Console.WriteLine(compiled("First", "Fir"));
1
2
3

Figure 9.4. Graphical representation of an expression tree that calls a method and uses
parameters from a lambda expression
Figure 9.5. Debugger visualization of an expression tree
Figure 9.6. Both LINQ to Objects and LINQ to SQL start with C# code and end with
query results. The ability to execute the code remotely comes through expression
trees.

serializationContext.AddProperty(x => x.BirthDate);
T runningTotal = initialValue; 
foreach (T item in values) 
{ 
  runningTotal = Operator.Add(runningTotal, item); 
}
Listing 9.11. Example of code requiring the new type inference rules
static void PrintConvertedValue<TInput,TOutput> 
   (TInput input, Converter<TInput,TOutput> converter) 
{
Listing 9.12. Attempting to infer the return type of an anonymous method
delegate T MyFunc<T>();                                 #1 
static void WriteResult<T>(MyFunc<T> function)          #2 
{

Figure 9.7. The two-phase type inference Øow
error CS0411: The type arguments for method 
'Snippet.WriteResult<T>(Snippet.MyFunc<T>)' cannot be inferred from the 
usage. Try specifying the type arguments explicitly.
WriteResult<int>(delegate { return 5; }); 
WriteResult((MyFunc<int>)delegate { return 5; });
Listing 9.13. Code returning an integer or an object depending on the time of day
delegate T MyFunc<T>(); 
static void WriteResult<T>(MyFunc<T> function) 
{
Listing 9.14. Flexible type inference combining information from multiple arguments
static void PrintType<T>(T rst, T second) 
{ 
Console WriteLine(typeof(T));

static void PrintConvertedValue<TInput,TOutput> 
   (TInput input, Converter<TInput,TOutput> converter) 
{ 
   Console.WriteLine(converter(input)); 
} 
... 
PrintConvertedValue("I'm a string", x => x.Length);
Listing 9.15. Multistage type inference
static void ConvertTwice<TInput,TMiddle,TOutput> 
   (TInput input, 
Converter<TInput TMiddle> rstConversion

void Write(int x) 
void Write(double y)
void Write(int x, double y) 
void Write(double x, int y)
Listing 9.16. Sample of overloading choice inØuenced by delegate return type
static void Execute(Func<int> action) 
{ 
Console WriteLine("action returns an int: " + action());

CHAPTER 10
Listing 10.1. A simple utility class to provide extra functionality for streams
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
using System.IO; 
 
public static class StreamUtil 
{ 
   const int BufferSize = 8192; 
 
   public static void Copy(Stream input, Stream output) 
   { 
      byte[] buffer = new byte[BufferSize]; 
      int read; 
      while ((read = input.Read(buffer, 0, buffer.Length)) > 0) 
      { 
         output.Write(buffer, 0, read); 
      } 
   } 
   public static byte[] ReadFully(Stream input) 
   { 
      using (MemoryStream tempStream = new MemoryStream()) 
 
      { 
         Copy(input, tempStream); 
         return tempStream.ToArray(); 
      } 
   } 
}
Listing 10.2. Using StreamUtil  to copy a web response stream to a ×le
1
2
3
4
5
6
7
WebRequest request = WebRequest.Create("http://manning.com"); 
using (WebResponse response = request.GetResponse()) 
using (Stream responseStream = response.GetResponseStream()) 
using (FileStream output = File.Create("response.dat")) 
{ 
   StreamUtil.Copy(responseStream, output); 
}
Listing 10.3. The StreamUtil  class again, but this time with extension methods

Figure 10.1. Hovering over a method call in Visual Studio reveals whether the method
is an extension method.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
public static class StreamUtil 
{ 
   const int BufferSize = 8192; 
 
   public static void CopyTo(this Stream input, Stream output) 
   { 
      byte[] buffer = new byte[BufferSize]; 
      int read; 
      while ((read = input.Read(buffer, 0, buffer.Length)) > 0) 
      { 
         output.Write(buffer, 0, read); 
      } 
   } 
 
   public static byte[] ReadFully(this Stream input) 
   { 
      using (MemoryStream tempStream = new MemoryStream()) 
      { 
         CopyTo(input, tempStream); 
         return tempStream.ToArray(); 
      } 
   } 
}
Listing 10.4. Copying a stream using an extension method
1
2
3
4
5
6
7
WebRequest request = WebRequest.Create("http://manning.com"); 
using (WebResponse response = request.GetResponse()) 
using (Stream responseStream = response.GetResponseStream()) 
using (FileStream output = File.Create("response.dat")) 
{ 
   responseStream.CopyTo(output); 
}
1 input.CopyTo(tempStream);

Listing 10.5. Extension method being called on a null reference
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
using System; 
public static class NullUtil 
{ 
   public static bool IsNull(this object x) 
   { 
      return x == null; 
   } 
} 
public class Test 
{ 
   static void Main() 
   { 
      object y = null; 
      Console.WriteLine(y.IsNull()); 
      y = new object(); 
      Console.WriteLine(y.IsNull()); 
   } 
}
1
2
3
4
public static bool IsNullOrEmpty(this string text) 
{ 
   return string.IsNullOrEmpty(text); 
}
Listing 10.6. Using Enumerable.Range  to print out the numbers 0 to 9
1
2
3
4
5
var collection = Enumerable.Range(0, 10); 
 
foreach (var element in collection) 
{ 

6    Console.WriteLine(element); 
}
Listing 10.7. Reversing a collection with the Reverse  method
1
2
3
4
5
6
7
var collection = Enumerable.Range(0, 10) 
                           .Reverse(); 
 
foreach (var element in collection) 
{ 
   Console.WriteLine(element); 
}
Listing 10.8. Using the Where  method with a lambda expression to ×nd odd numbers
1
2
3
4
5
6
7
var collection = Enumerable.Range(0, 10) 
                           .Where(x => x % 2 != 0) 
                           .Reverse(); 
foreach (var element in collection) 
{ 
   Console.WriteLine(element); 
}
1
2
3
builder = builder.Replace("<", "&lt;") 
                 .Replace(">", "&gt;") 
                 ...
1
2
3
var collection = Enumerable.Range(0, 10); 
collection     = Enumerable.Where(collection, x => x % 2 != 0) 
collection     = Enumerable.Reverse(collection);
1
2
3
4
var collection = Enumerable.Reverse 
                   (Enumerable.Where 
                      (Enumerable.Range(0, 10), 
                         x => x % 2 != 0));

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
public static IEnumerable<T> Where<T>(this  IEnumerable<T> source, 
                                      Func<T, bool> predicate) 
{ 
   if (source == null || predicate == null) 
   { 
      throw new ArgumentNullException(); 
   } 
   return WhereImpl(source, predicate); 
} 
private static IEnumerable<T> WhereImpl<T>(IEnumerable<T> source, 
                                           Func<T, bool>  predicate) 
{ 
   foreach (T item in source) 
   { 
      if (predicate(item)) 
      { 
         yield return item; 
      } 
   } 
}
1
2
3
4
5
foreach (string line in LineReader.ReadLines("../../FakeLinq.cs") 
                                  .Where(line => line.StartsWith("using"))) 
{ 
   Console.WriteLine(line); 
}
Listing 10.9. Projection using a lambda expression and an anonymous type
1
2
3
4
5
6
7
8
9
10
11
var collection = Enumerable.Range(0, 10) 
      .Where(x => x % 2 != 0) 
      .Reverse() 
      .Select(x => new { Original = x, SquareRoot = Math.Sqrt(x) } ); 
 
foreach (var element in collection) 
{ 
   Console.WriteLine("sqrt({0})={1}", 
                     element.Original, 
                     element.SquareRoot); 
}
1
2
3
4
5
sqrt(9)=3 
sqrt(7)=2.64575131106459 
sqrt(5)=2.23606797749979 
sqrt(3)=1.73205080756888 
sqrt(1)=1

Listing 10.10. Ordering a sequence by two properties
1
2
3
4
5
6
7
8
9
var collection = Enumerable.Range(-5, 11) 
      .Select(x => new { Original = x, Square = x * x }) 
      .OrderBy(x => x.Square) 
      .ThenBy(x => x.Original); 
 
foreach (var element in collection) 
{ 
   Console.WriteLine(element); 
}
1
2
3
4
5
6
7
8
9
10
11
{ Original = 0, Square = 0 } 
{ Original = -1, Square = 1 } 
{ Original = 1, Square = 1 } 
{ Original = -2, Square = 4 } 
{ Original = 2, Square = 4 } 
{ Original = -3, Square = 9 } 
{ Original = 3, Square = 9 } 
{ Original = -4, Square = 16 } 
{ Original = 4, Square = 16 } 
{ Original = -5, Square = 25 } 
{ Original = 5, Square = 25 }
company.Departments 
      .Select(dept => new 
      { 
         dept.Name, 
         Cost = dept.Employees.Sum(person => person.Salary) 
      }) 
      .OrderByDescending(deptWithCost => deptWithCost.Cost);
bugs.GroupBy(bug => bug.AssignedTo) 
    .Select(list => new { Developer = list.Key, Count = list.Count() }) 
    .OrderByDescending(x => x.Count);

Figure 10.2. Pulling apart a Øuent interface expression to create a meeting. The time of
the meeting is speci×ed using extension methods to create a TimeSpan  from an
int , and a DateTime  from a TimeSpan .
foreach (DateTime day in 19.June(1976).To(DateTime.Today) 
                                      .Step(1.Days()))

CHAPTER 11
Figure 11.1. A simple query expression broken down into the sequences and
transformations involved
Figure 11.2. Sequence diagram of the execution of a query expression
1
2
3
var adultNames = from person in people 
                 where person.Age >= 18 
                 select person.Name;

Figure 11.3. Class diagram of the SkeetySoft defect data model

1 from element in source
1 select expression
Listing 11.1. Trivial query to print the list of users
1
2
3
4
5
6
var query = from user in SampleData.AllUsers 
            select user; 
foreach (var user in query) 
{ 
   Console.WriteLine(user); 
}

1
2
3
4
5
6
User: Tim Trotter (Tester) 
User: Tara Tutu (Tester) 
User: Deborah Denton (Developer) 
User: Darren Dahlia (Developer) 
User: Mary Malcop (Manager) 
User: Colin Carton (Customer)
Listing 11.2. The query expression of listing 11.1 translated into a method call
1
2
3
4
5
6
var query = SampleData.AllUsers.Select(user => user); 
 
foreach (var user in query) 
{ 
   Console.WriteLine(user); 
}
Listing 11.3. Compiler translation calling methods on a dummy LINQ implementation
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
static class Extensions 
{ 
   public static Dummy<T> Where<T>(this Dummy<T> dummy, 
                                 Func<T,bool> predicate) 
   { 
      Console.WriteLine("Where called"); 
      return dummy; 
   } 
} 
class Dummy<T> 
{ 
   public Dummy<U> Select<U>(Func<T,U> selector)  
   { 
      Console.WriteLine("Select called"); 
      return new Dummy<U>(); 
   } 
} 
class TranslationExample 
{ 
   static void Main() 
   { 
      var source = new Dummy<string>(); 
      var query = from dummy in source  
                  where dummy.ToString() == "Ignored" 
                  select "Anything"; 
   } 
}
1
2
3
4

Figure 11.4. A simple query expression broken down into its constituent parts
1
2
var query = source.Where(dummy => dummy.ToString() == "Ignored") 
                  .Select(dummy => "Anything");
1 SampleData.AllUsers.Select(user => user)
1
2
from user in SampleData.AllUsers 
select person
1 SampleData.AllUsers.Select(user => person)
Listing 11.4. Query selecting just the names of the users
1
2
3
4
5
IEnumerable<string> query = from user in SampleData.AllUsers 
                            select user.Name; 
 
foreach (string name in query) 
{ 

6
7
   Console.WriteLine(name); 
}
1 SampleData.AllUsers.Select(user => user.Name)
1
2
3
static IEnumerable<TResult> Select<TSource,TResult> 
   (this IEnumerable<TSource> source, 
    Func<TSource,TResult> selector)
Listing 11.5. Using Cast  and OfType  to work with weakly typed collections
1
2
3
4
5
6
7
8
9
10
11
12
13
ArrayList list = new ArrayList { "First", "Second", "Third" }; 
IEnumerable<string> strings = list.Cast<string>(); 
foreach (string item in strings) 
{ 
   Console.WriteLine(item); 
} 
 
list = new ArrayList { 1, "not an int", 2, 3 }; 
IEnumerable<int> ints = list.OfType<int>(); 
foreach (int item in ints) 
{ 
   Console.WriteLine(item); 
}
Listing 11.6. Using an explicitly typed range variable to automatically call Cast
1
2
3
4
5
6
7
8
ArrayList list = new ArrayList { "First", "Second", "Third"}; 
var strings = from string entry in list 
              select entry.Substring(0, 3); 
foreach (string start in strings) 
 
{ 
   Console.WriteLine(start); 
}
1 list.Cast<string>().Select(entry => entry.Substring(0,3));

where filter-expression
Listing 11.7. Query expression using multiple where  clauses
User tim = SampleData.Users.TesterTim; 
var query = from defect in SampleData.AllDefects 
           where defect.Status != Status.Closed 
           where defect.AssignedTo == tim 
           select defect.Summary; 
foreach (var summary in query) 
{ 
  Console.WriteLine(summary); 
}
SampleData.AllDefects.Where (defect => defect.Status != Status.Closed) 
                     .Where(defect => defect.AssignedTo == tim) 
                     .Select(defect => defect.Summary)
Installation is slow 
Subtitles only work in Welsh 
Play button points the wrong way 
Webcam makes me look bald 
Network is saturated when playing WAV file
from defect in SampleData.AllDefects 
select defect

SampleData.AllDefects.Select(defect => defect)
from defect in SampleData.AllDefects 
where defect.Status != Status.Closed 
where defect.AssignedTo == SampleData.Users.TesterTim 
select defect
SampleData.AllDefects.Where(defect => defect.Status != Status.Closed) 
                     .Where(defect => defect.AssignedTo == tim)
Listing 11.8. Sorting by the severity of a defect, from high to low priority
User tim = SampleData.Users.TesterTim; 
 
var query = from defect in SampleData AllDefects
Showstopper: Webcam makes me look bald 
Major: Subtitles only work in Welsh 
Major: Play button points the wrong way 
Minor: Network is saturated when playing WAV file 
Trivial: Installation is slow
Listing 11.9. Ordering by severity and then last modi×ed time
User tim = SampleData.Users.TesterTim; 
 
var query = from defect in SampleData AllDefects
Showstopper: Webcam makes me look bald (05/27/2013) 
Major: Play button points the wrong way (05/17/2013) 
Major: Subtitles only work in Welsh (05/23/2013) 
Minor: Network is saturated when playing WAV file (05/31/2013) 
Trivial: Installation is slow (05/15/2013)
SampleData.AllDefects.Where(defect => defect.Status != Status.Closed) 
                     .Where(defect => defect.AssignedTo == tim) 
                     .OrderByDescending(defect => defect.Severity) 
                     .ThenBy(defect => defect.LastModified)
let identifier = expression

Figure 11.5. Sequences involved in listing 11.11, where a let  clause introduces the
length  range variable
Listing 11.10. Sorting by the lengths of user names without a let  clause
var query = from user in SampleData.AllUsers 
            orderby user.Name.Length 
select user Name;
Listing 11.11. Using a let  clause to remove redundant calculations
var query = from user in SampleData.AllUsers 
            let length = user.Name.Length 
orderby length

Figure 11.6. The join from listing 11.12 in graphical form, showing two different
sequences (defects and subscriptions) used as data sources
SampleData.AllUsers 
          .Select(user => new { user, length = user.Name.Length }) 
          .OrderBy(z => z.length) 
          .Select(z => new { Name = z.user.Name, Length = z.length })
[query selecting the left sequence] 
join right-range-variable in right-sequence 
   on left-key-selector equals right-key-selector
Listing 11.12. Joining the defects and noti×cation subscriptions based on project
var query = from defect in SampleData.AllDefects 
            join subscription in SampleData.AllSubscriptions 
on defect Project equals subscription Project
from defect in SampleData.AllDefects 
where defect.Status == Status.Closed 
join subscription in SampleData.AllSubscriptions 

Figure 11.7. Sequences involved in the group join from listing 11.13. The short arrows
indicate embedded sequences within the result entries. In the output, some entries
contain multiple email addresses for the same defect.
   on defect.Project equals subscription.Project 
select new { defect.Summary, subscription.EmailAddress }
from subscription in SampleData.AllSubscriptions 
join defect in (from defect in SampleData.AllDefects 
                where defect.Status == Status.Closed 
                select defect) 
   on subscription.Project equals defect.Project 
select new { defect.Summary, subscription.EmailAddress }
leftSequence.Join(rightSequence, 
                  leftKeySelector, 
                  rightKeySelector, 
                  resultSelector)
static IEnumerable<TResult> Join<TOuter,TInner,TKey,TResult> ( 
   this IEnumerable<TOuter> outer, 
   IEnumerable<TInner> inner, 
   Func<TOuter,TKey> outerKeySelector, 
   Func<TInner,TKey> innerKeySelector, 
   Func<TOuter,TInner,TResult> resultSelector 
)
Listing 11.13. Joining defects and subscriptions with a group join
var query = from defect in SampleData.AllDefects 
            join subscription in SampleData.AllSubscriptions 
on defect Project equals subscription Project

Listing 11.14. Counting the number of defects raised on each day in May
var dates = new DateTimeRange(SampleData.Start, SampleData.End); 
 
var query = from date in dates
05/01/2013: 1 
05/02/2013: 0 
05/03/2013: 2 
05/04/2013: 1 
05/05/2013: 0 
05/06/2013: 1 
05/07/2013: 1
static IEnumerable<TResult> GroupJoin<TOuter,TInner,TKey,TResult>( 
   this IEnumerable<TOuter> outer, 
   IEnumerable<TInner> inner, 
   Func<TOuter,TKey> outerKeySelector, 
   Func<TInner,TKey> innerKeySelector, 

Figure 11.8. Sequences from listing 11.15, cross joining users and projects. All possible
combinations are returned in the results.
   Func<TOuter,IEnumerable<TInner>,TResult> resultSelector 
)
dates.GroupJoin(SampleData.AllDefects, 
                date => date, 
                defect => defect.Created.Date, 
                (date, joined) => new  { Date = date, 
                                         Count = joined.Count() })
Listing 11.15. Cross joining users against projects
var query = from user in SampleData.AllUsers 
            from project in SampleData.AllProjects 
select new { User = user Project = project };
Tim Trotter/Skeety Media Player 
Tim Trotter/Skeety Talk 
Tim Trotter/Skeety Office 
Tara Tutu/Skeety Media Player 
Tara Tutu/Skeety Talk 
Tara Tutu/Skeety Office

Listing 11.16. Cross join where the right sequence depends on the left element
var query = from left in Enumerable.Range(1, 4) 
            from right in Enumerable.Range(11, left) 
select new { Left = left Right = right };
Left=1; Right=11 
Left=2; Right=11 
Left=2; Right=12
static IEnumerable<TResult> SelectMany<TSource,TCollection,TResult>( 
   this IEnumerable<TSource> source, 
   Func<TSource,IEnumerable<TCollection>> collectionSelector, 
   Func<TSource,TCollection,TResult> resultSelector 
)
Enumerable.Range(1, 4) 
          .SelectMany(left => Enumerable.Range(11, left), 
                     (left, right) => new {Left = left, Right = right})

Figure 11.9. Sequences used when grouping defects by assignee. Each entry of the
result has a Key  property and is also a sequence of defect entries.
var query = from file in Directory.GetFiles(logDirectory, "*.log") 
            from line in ReadLines(file) 
            let entry = new LogEntry(line) 
            where entry.Type == EntryType.Error 
            select entry;
group projection by grouping
Listing 11.17. Grouping defects by assignee—trivial projection
var query = from defect in SampleData.AllDefects 
            where defect.AssignedTo != null                         #1 
group defect by defect AssignedTo;
#2
Darren Dahlia 
  (Showstopper) MP3 files crash system 
  (Major) Can't play files more than 200 bytes long 
  (Major) DivX is choppy on Pentium 100 
  (Trivial) User interface should be more caramelly

SampleData.AllDefects.Where(defect => defect.AssignedTo != null) 
                     .GroupBy(defect => defect.AssignedTo)
Listing 11.18. Grouping defects by assignee—projection retains just the summary
var query = from defect in SampleData.AllDefects 
            where defect.AssignedTo != null 
group defect Summary by defect AssignedTo;
SampleData.AllDefects.Where(defect => defect.AssignedTo != null) 
                     .GroupBy(defect => defect.AssignedTo, 
                              defect => defect.Summary)

first-query into identifier 
second-query-body
from identifier in (first-query) 
second-query-body
Listing 11.19. Continuing a grouping with another projection
var query = from defect in SampleData.AllDefects 
            where defect.AssignedTo != null 
group defect by defect AssignedTo into grouped
Darren Dahlia: 14 
Tara Tutu: 5 
Tim Trotter: 5 
Deborah Denton: 9 
Colin Carton: 2
from grouped in (from defect in SampleData.AllDefects 
                 where defect.AssignedTo != null 
                 group defect by defect.AssignedTo) 
select new { Assignee = grouped.Key, Count = grouped.Count() }
SampleData.AllDefects 
          .Where(defect => defect.AssignedTo != null) 
          .GroupBy(defect => defect.AssignedTo) 
          .Select(grouped => new { Assignee = grouped.Key, 
                                   Count = grouped.Count() })
var tmp = from defect in SampleData.AllDefects 
          where defect.AssignedTo != null 
          group defect by defect.AssignedTo; 
 
var query = from grouped in tmp 
            select new { Assignee = grouped.Key, 
                         Count = grouped.Count() };
Listing 11.20. Query expression continuations from group  and select
var query = from defect in SampleData.AllDefects 
            where defect.AssignedTo != null 
group defect by defect AssignedTo into grouped

SampleData.AllDefects 
          .Where(defect => defect.AssignedTo != null) 
          .GroupBy(defect => defect.AssignedTo) 
          .Select(grouped => new { Assignee = grouped.Key, 
                                   Count = grouped.Count() }) 
          .OrderByDescending(result => result.Count);
sequence.Where((item, index) => index % 2 == 0)
sequence.Select((Item, Index) => new { Item, Index }) 
        .OrderBy(x => x.Item.Name)
var adults = from person in people 
             where person.Age >= 18 
             select person;
var adults = people.Where(person => person.Age >= 18);
var adultNames = (from person in people 
                  where person.Age >= 18 
                  select person.Name).ToList();
var adultNames = people.Where(person => person.Age >= 18) 
                       .Select(person => person.Name) 
                       .ToList();
from defect in SampleData.AllDefects 
join subscription in SampleData.AllSubscriptions 
   on defect.Project equals subscription.Project 
select new { defect.Summary, subscription.EmailAddress }
SampleData.AllDefects.Join(SampleData.AllSubscriptions, 
   defect => defect.Project, 
   subscription => subscription.Project, 
   (defect, subscription) => new { defect.Summary, 
                                   subscription.EmailAddress })
orderby item.Rating descending, item.Price, item.Name

.OrderByDescending(item => item.Rating) 
.ThenBy(item => item.Price) 
.ThenBy(item => item.Name)

CHAPTER 12
Figure 12.1. The LINQ to SQL classes designer showing the rearranged and modi×ed
entities
1
2
3
4
5
6
User tim = SampleData.Users.TesterTim; 
 
var query = from defect in SampleData.AllDefects 
            where defect.Status != Status.Closed 
            where defect.AssignedTo == tim 
            select defect.Summary;

Listing 12.1. Querying the database to ×nd all Tim’s open defects
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
using (var context = new DefectModelDataContext()) 
{ 
   context.Log = Console.Out;  
   User tim = context.Users 
                     .Where(user => user.Name == "Tim Trotter") 
                     .Single(); 
   var query = from defect in context.Defects 
               where defect.Status != Status.Closed 
               where defect.AssignedTo == tim 
               select defect.Summary; 
   foreach (var summary in query) 
   { 
      Console.WriteLine(summary); 
   } 
}
1
2
3
4
1
2
3
4
5
6
7
8
9
10
SELECT [t0].[UserID], [t0].[Name], [t0].[UserType] 
FROM [dbo].[DefectUser] AS [t0] 
WHERE [t0].[Name] = @p0 
-- @p0: Input String (Size = 11; Prec = 0; Scale = 0) [Tim Trotter] 
 
SELECT [t0].[Summary] 
FROM [dbo].[Defect] AS [t0] 
WHERE ([t0].[AssignedToUserID] = @p0) AND ([t0].[Status] <> @p1) 
-- @p0: Input Int32 (Size = 0; Prec = 0; Scale = 0) [2] 
-- @p1: Input Int32 (Size = 0; Prec = 0; Scale = 0) [4]
Listing 12.2. Using a let  clause in LINQ to SQL
1
2
3
4
5
6
7
8
9
10
11
12
13
14
using (var context = new DefectModelDataContext()) 
{ 
   context.Log = Console.Out; 
 
   var query = from user in context.Users 
               let length = user.Name.Length 
               orderby length 
               select new { Name = user.Name, Length = length }; 
 
   foreach (var entry in query) 
   { 
      Console.WriteLine("{0}: {1}", entry.Length, entry.Name); 
   } 
}
1
2
3
SELECT [t1].[Name], [t1].[value] 
FROM ( 
   SELECT LEN([t0].[Name]) AS [value], [t0].[Name] 

4
5
6
   FROM [dbo].[DefectUser] AS [t0] 
   ) AS [t1] 
ORDER BY [t1].[value]
1
2
3
SELECT LEN([t0].[Name]) AS [value], [t0].[Name] 
FROM [dbo].[DefectUser] AS [t0] 
ORDER BY [value]
1
2
3
4
5
6
7
8
9
10
11
// Query expression (modified from listing 11.12) 
from defect in context.Defects 
join subscription in context.NotificationSubscriptions 
   on defect.Project equals subscription.Project 
select new { defect.Summary, subscription.EmailAddress } 
 
-- Generated SQL 
SELECT [t0].[Summary], [t1].[EmailAddress] 
FROM [dbo].[Defect] AS [t0] 
INNER JOIN [dbo].[NotificationSubscription] AS [t1] 
ON [t0].[ProjectID] = [t1].[ProjectID]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
// Query expression (modified from listing 11.13) 
from defect in context.Defects 
join subscription in context.NotificationSubscriptions 
   on defect.Project equals subscription.Project 
   into groupedSubscriptions 
select new { Defect = defect, Subscriptions = groupedSubscriptions } 
 
-- Generated SQL 
SELECT [t0].[DefectID] AS [ID], [t0].[Created], 
[t0].[LastModified], [t0].[Summary], [t0].[Severity], 
[t0].[Status], [t0].[AssignedToUserID], 
[t0].[CreatedByUserID], [t0].[ProjectID], 
[t1].[NotificationSubscriptionID], 
[t1].[ProjectID] AS [ProjectID2], [t1].[EmailAddress], 
   (SELECT COUNT(*) 
    FROM [dbo].[NotificationSubscription] AS [t2] 
    WHERE [t0].[ProjectID] = [t2].[ProjectID]) AS [count] 
FROM [dbo].[Defect] AS [t0] 
LEFT OUTER JOIN [dbo].[NotificationSubscription] AS [t1] 
ON [t0].[ProjectID] = [t1].[ProjectID] 
ORDER BY [t0].[DefectID], [t1].[NotificationSubscriptionID]

Figure 12.2. Class diagram of the interfaces involved in IQueryable<T>
1
2
3
4
5
6
7
8
9
// Query expression 
from defect in context.Defects 
select new { defect.Summary, ProjectName = defect.Project.Name } 
 
-- Generated SQL 
SELECT [t0].[Summary], [t1].[Name] 
FROM [dbo].[Defect] AS [t0] 
INNER JOIN [dbo].[Project] AS [t1] 
ON [t1].[ProjectID] = [t0].[ProjectID]
1
2
3
4
5
6
7
8
9
// Query expression 
from defect in context.Defects 
select new { defect.Summary, Assignee = defect.AssignedTo.Name } 
 
-- Generated SQL 
SELECT [t0].[Summary], [t1].[Name] 
FROM [dbo].[Defect] AS [t0] 
LEFT OUTER JOIN [dbo].[DefectUser] AS [t1] 
ON [t1].[UserID] = [t0].[AssignedToUserID]

Listing 12.3. A simple implementation of IQueryable  that logs method calls
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
class FakeQuery<T> : IQueryable<T> 
{ 
   public Expression Expression { get; private set; } 
   public IQueryProvider Provider { get; private set; } 
   public Type ElementType { get; private set; } 
   internal FakeQuery(IQueryProvider provider, 
                      Expression expression) 
   { 
      Expression = expression; 
      Provider = provider; 
      ElementType = typeof(T); 
   } 
   internal FakeQuery() : this(new FakeQueryProvider(), null) 
   { 
      Expression = Expression.Constant(this); 
   } 
   public IEnumerator<T> GetEnumerator() 
   { 
      Logger.Log(this, Expression); 
      return Enumerable.Empty<T>().GetEnumerator();   
   } 
   IEnumerator IEnumerable.GetEnumerator()  
   { 
      Logger.Log(this, Expression); 
      return Enumerable.Empty<T>().GetEnumerator(); 
   } 
   public override string ToString() 
   { 
      return "FakeQuery"; 
   } 
}
1
2
3
4

Figure 12.3. A query taking two paths, depending on whether the data source
implements IQueryable  or only IEnumerable
Listing 12.4. An implementation of IQueryProvider  that uses FakeQuery
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
class FakeQueryProvider : IQueryProvider 
{ 
   public IQueryable<T> CreateQuery<T>(Expression expression) 
   { 
      Logger.Log(this, expression); 
      return new FakeQuery<T>(this, expression); 
   } 
 
   public IQueryable CreateQuery(Expression expression) 
   { 
      Type queryType = typeof(FakeQuery<>).MakeGenericType(expression.Type); 
      object[] constructorArgs = new object[] { this, expression }; 
      return (IQueryable)Activator.CreateInstance(queryType, constructorArgs); 
   } 
 
   public T Execute<T>(Expression expression) 
   { 
      Logger.Log(this, expression); 
      return default(T); 
   } 
 
   public object Execute(Expression expression) 
   { 
      Logger.Log(this, expression); 
      return null; 
   } 
}

Listing 12.5. A simple query expression using the fake query classes
1
2
3
4
var query = from x in new FakeQuery<string>() 
            where x.StartsWith("abc") 
            select x.Length; 
foreach (int i in query) { }
1
2
3
4
5
6
7
8
9
10
FakeQueryProvider.CreateQuery 
Expression=FakeQuery.Where(x => x.StartsWith("abc")) 
 
FakeQueryProvider.CreateQuery 
Expression=FakeQuery.Where(x => x.StartsWith("abc")) 
                    .Select(x => x.Length) 
 
FakeQuery<Int32>.GetEnumerator 
Expression=FakeQuery.Where(x => x.StartsWith("abc")) 
                    .Select(x => x.Length)

Figure 12.4. Class diagram for LINQ to XML, showing the most commonly used types
Listing 12.6. IQueryProvider.Execute
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
var query = from x in new FakeQuery<string>() 
            where x.StartsWith("abc") 
            select x.Length; 
 
double mean = query.Average(); 
 
// Output 
FakeQueryProvider.CreateQuery 
Expression=FakeQuery.Where(x => x.StartsWith("abc")) 
 
FakeQueryProvider.CreateQuery 
Expression=FakeQuery.Where(x => x.StartsWith("abc")) 
                    .Select(x => x.Length) 
 
FakeQueryProvider.Execute 
Expression=FakeQuery.Where(x => x.StartsWith("abc")) 
                    .Select(x => x.Length) 
                    .Average()

1
2
3
XElement noNamespace = new XElement("no-namespace"); 
XNamespace ns = "http://csharpindepth.com/sample/namespace"; 
XElement withNamespace = new XElement(ns + "in-namespace");
1
2
3
4
new XElement("root", 
   new XElement("child", 
      new XElement("grandchild", "text")), 
   new XElement("other-child"));
1
2
3
4
5
6
<root> 
  <child> 
    <grandchild>text</grandchild> 
  </child> 
  <other-child /> 
</root>
Listing 12.7. Creating elements from the sample users
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
var users = new XElement("users", 
    SampleData.AllUsers.Select(user => new XElement("user", 
       new XAttribute("name", user.Name), 
       new XAttribute("type", user.UserType))) 
); 
Console.WriteLine(users); 
 
// Output 
<users> 
  <user name="Tim Trotter" type="Tester" /> 
  <user name="Tara Tutu" type="Tester" /> 
  <user name="Deborah Denton" type="Developer" /> 
  <user name="Darren Dahlia" type="Developer" /> 
  <user name="Mary Malcop" type="Manager" /> 
  <user name="Colin Carton" type="Customer" /> 
</users>
Listing 12.8. Creating elements with text nodes
1
2
3
4
5
6
var developers = new XElement("developers", 
   from user in SampleData.AllUsers 
   where user.UserType == UserType.Developer 
   select new XElement("developer", user.Name) 
); 
Console.WriteLine(developers); 

7
8
9
10
11
12
 
// Output 
<developers> 
  <developer>Deborah Denton</developer> 
  <developer>Darren Dahlia</developer> 
</developers>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
<defect-system> 
  <projects> 
    <project name="..." id="..."> 
      <subscription email="..." /> 
    </project> 
  </projects> 
  <users> 
    <user name="..." id="..." type="..." /> 
  </users> 
  <defects> 
    <defect id="..." summary="..." created="..." project="..." 
            assigned-to="..." created-by="..." status="..." 
            severity="..." last-modified="..." /> 
  </defects> 
</defect-system>
1 XElement root = new XElement("defect-system", projects, users, defects);
Listing 12.9. Displaying the users within an XML structure
1
2
3
4
5
6
7
8
9
10
11
XElement root = XmlSampleData.GetElement(); 
 
var query = root.Element("users").Elements().Select(user => new 
            { 
              Name = (string) user.Attribute("name"), 
              UserType = (string) user.Attribute("type") 
            }); 
foreach (var user in query) 
{ 
   Console.WriteLine ("{0}: {1}", user.Name, user.UserType); 
}
1
2
from project in root.Element("projects").Elements() 
from subscription in project.Elements("subscription") 

Figure 12.5. Mandelbrot image generated on a single thread
3 select subscription
1
2
root.Element("projects").Elements() 
    .SelectMany(project => project.Elements("subscription"))
1 root.Element("projects").Elements().Elements("subscription")
1
2
3
4
root.Element("projects").Elements() 
    .Where(project => ((string) project.Attribute("name")) 
                                       .Contains("Media")) 
    .Elements("subscription")
Listing 12.10. Single-threaded Mandelbrot generation query
1
2
3
4
5
var query = from row in Enumerable.Range(0, Height) 
            from column in Enumerable.Range(0, Width) 
            select ComputeIndex(row, column); 
 
return query.ToArray();

Figure 12.6. Class diagram for Parallel LINQ, including relationship to normal LINQ
interfaces
Listing 12.11. First attempt at a multithreaded Mandelbrot generation query
1
2
3
4
5
6
var query = from row in Enumerable.Range(0, Height) 
                                  .AsParallel() 
            from column in Enumerable.Range(0, Width) 
            select ComputeIndex(row, column); 
 
return query.ToArray();

Figure 12.7. Mandelbrot image generated using an unordered query, resulting in some
sections being incorrectly placed
Figure 12.8. Sequence diagram showing the duality of IEnumerable<T>  and
IObservable<T>
Listing 12.12. Multithreaded Mandelbrot query maintaining ordering
1
2
3
4
5
6
var query = from row in Enumerable.Range(0, Height) 
                                  .AsParallel().AsOrdered() 
            from column in Enumerable.Range(0, Width) 
            select ComputeIndex(row, column); 
 
return query.ToArray();
1
2
3
4
5
6
7
8
9
10
11
public interface IObservable<T> 
{ 
   IDisposable Subscribe(IObserver<T> observer); 
} 
 
public interface IObserver<T> 
{ 
   void OnNext(T value); 
   void OnCompleted(); 
   void OnException(Exception error); 
}

Listing 12.13. First contact with IObservable<T>
1
2
3
4
var observable = Observable.Range(0, 10); 
observable.Subscribe(x => Console.WriteLine("Received {0}", x), 
                     e => Console.WriteLine("Error: {0}", e), 
                     () => Console.WriteLine("Finished"));
1
2
3
4
5
Received 0 
Received 1 
... 
Received 9 
Finished
Listing 12.14. Filtering and projecting in LINQ to Rx
1
2
3
4
5
var numbers = Observable.Range(0, 10); 
var query = from number in numbers 
            where number % 2 == 0 
            select number * number; 
query.Subscribe(Console.WriteLine);
Listing 12.15. Grouping numbers mod 3

1
2
3
4
5
var numbers = Observable.Range(0, 10); 
var query = from number in numbers 
            group number by number % 3; 
query.Subscribe(group => group.Subscribe 
    (x => Console.WriteLine("Value: {0}; Group: {1}", x, group.Key)));
1
2
3
4
5
6
7
8
9
10
11
Value: 0; Group: 0 
Value: 1; Group: 1 
Value: 2; Group: 2 
Value: 3; Group: 0 
 
Value: 4; Group: 1 
Value: 5; Group: 2 
Value: 6; Group: 0 
Value: 7; Group: 1 
Value: 8; Group: 2 
Value: 9; Group: 0
Listing 12.16. SelectMany  producing multiple ranges
1
2
3
4
var query = from x in Observable.Range(1, 3) 
            from y in Observable.Range(1, x) 
            select new { x, y }; 
query.Subscribe(Console.WriteLine);
1
2
3
4
5
6
{ x = 1, y = 1 } 
{ x = 2, y = 1 } 
{ x = 2, y = 2 } 
{ x = 3, y = 1 } 
{ x = 3, y = 2 } 
{ x = 3, y = 3 }
Listing 12.17. Extension method to choose a random element from a sequence
1
2
3
4
5
6
7
8
9
10
public static T RandomElement<T>(this IEnumerable<T> source, 
                                 Random random) 
{ 
   if (source == null) 
   { 
      throw new ArgumentNullException("source"); 
   } 
   if (random == null) 
   { 
      throw new ArgumentNullException("random"); 
1

11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
   } 
   ICollection collection = source as ICollection;  
   if (collection != null) 
   { 
      int count = collection.Count; 
      if (count == 0) 
      { 
         throw new InvalidOperationException("Sequence was empty."); 
      } 
      int index = random.Next(count); 
      return source.ElementAt(index);  
   } 
   using (IEnumerator<T> iterator = source.GetEnumerator())  
   { 
      if (!iterator.MoveNext()) 
      { 
         throw new InvalidOperationException("Sequence was empty."); 
      } 
      int countSoFar = 1; 
      T current = iterator.Current; 
      while (iterator.MoveNext()) 
      { 
         countSoFar++; 
         if (random.Next(countSoFar) == 0)  
         { 
            current = iterator.Current; 
         } 
      } 
      return current; 
   } 
}
2
3
4
5

CHAPTER 13
PARAMETERS AND ARGUMENTS
This section obviously talks about parameters and arguments a lot. In
casual conversation, the two terms are often used interchangeably, but
I’ll use them in line with their formal denitions. Just to remind you, a
parameter (also known as a formal parameter) is the variable that’s part
of the method or indexer declaration. An argument is an expression
used when calling the method or indexer. For example, consider this
snippet:
Here the parameters are x  and y , and the arguments are a  and
20 .
Figure 13.1. Declaring optional parameters
1
2
3
4
5
6
7
void Foo(int x, int y) 
{ 
   // Do something with x and y 
} 
... 
int a = 10; 
Foo(a, 20);
1
2
3
4
5
6
7
8
9
10
public IList<Customer> LoadCustomers(string filename, 
                                     Encoding encoding) 
{ 
   ...  
} 
 
public IList<Customer> LoadCustomers(string filename) 
{ 
   return LoadCustomers(filename, Encoding.UTF8); 
}
1
2

Table 13.1. Valid method parameter lists using optional parameters
Declaration
Notes
Foo(int x, int y = 10)
Numeric literal used for default value
Foo(decimal x = 10)
Implicit built-in conversion from int to
decimal
Foo(string name = "default")
String literal used for default value
Foo(DateTime dt = new DateTime())
Zero value of DateTime
Listing 13.1. Declaring and calling a method with optional parameters
1
2
3
4
5
6
7
8
static void Dump(int x, int y = 20, int z = 30)  
{ 
   Console.WriteLine("x={0} y={1} z={2}", x, y, z); 
} 
... 
Dump(1, 2, 3); 
Dump(1, 2); 
Dump(1);
1
2
3
4
1
2
3
x=1 y=2 z=3 
x=1 y=2 z=30 
x=1 y=20 z=30
1
2
3
4
5
6
7
static void TwoOptionalParameters(int x = 10, 
                                  string y = "default") 
{ 
   Console.WriteLine("x={0} y={1}", x, y); 
} 
... 
TwoOptionalParameters("second parameter");
1

Declaration
Notes
Foo(DateTime dt = default(DateTime))
Alternative syntax for the zero value
Foo<T>(T value = default(T))
Default value operator works with type
parameters
Foo(int? x = null)
Nullable conversion
Foo(int x, int y = 10, params int[] z)
Parameter array after optional
parameters
Table 13.2. Invalid method parameter lists using optional parameters
Declaration (invalid)
Notes
Foo(int x = 0, int y)
Required non-params parameter after
optional parameter
Foo(DateTime dt = DateTime.Now)
Default values must be constants
Foo(XName name = "default")
Conversion from string to XName is
user-dened
Foo(params string[] names = null)
Parameter arrays can’t be optional
Foo(ref string name = "default")
ref/out parameters can’t be optional
Listing 13.2. Using null default values to handle nonconstant situations
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
static void AppendTimestamp(string filename,  
                            string message, 
                            Encoding encoding = null, 
                            DateTime? timestamp = null) 
{ 
   Encoding realEncoding = encoding ?? Encoding.UTF8;  
   DateTime realTimestamp = timestamp ?? DateTime.Now; 
   using (TextWriter writer = new StreamWriter(filename, 
                                               true, 
                                               realEncoding)) 
   { 
      writer.WriteLine("{0:s}: {1}", realTimestamp, message); 
   } 
} 
... 
AppendTimestamp("utf8.txt", "First message");  
AppendTimestamp("ascii.txt", "ASCII", Encoding.ASCII); 
AppendTimestamp("utf8.txt", "Message in the future", null,  
                new DateTime(2030, 1, 1));
1
2
3
4

NAMED ARGUMENTS WITH OUT AND REF
If you want to specify the name of an argument for a ref  or out
parameter, you put the ref  or out  modier after the name and
before the argument. Using int.TryParse  as an example, you might
have code like this:
1
2
MessageBox.Show("Please do not press this button again", // text 
                "Ouch!"); // title
1
2
MessageBox.Show(text: "Please do not press this button again", 
                caption: "Ouch!");
1
2
MessageBox.Show(caption: "Ouch!", 
                text: "Please do not press this button again");
1
2
3
new StreamWriter(path: filename, 
                 append: true, 
                 encoding: realEncoding)
1
2
int number; 
bool success = int.TryParse("10", result: out number);
Listing 13.3. Simple examples of using named arguments
1
2
3
static void Dump(int x, int y, int z) 
{ 
   Console.WriteLine("x={0} y={1} z={2}", x, y, z); 
1

Figure 13.2. Positional and named arguments in the same call
4
5
6
7
8
9
10
} 
... 
Dump(1, 2, 3);  
Dump(x: 1, y: 2, z: 3); 
Dump(z: 3, y: 2, x: 1); 
Dump(1, y: 2, z: 3);  
Dump(1, z: 3, y: 2);
2
3
4
Listing 13.4. Logging argument evaluation
1
2
3
4
5
6
7
8
static int Log(int value) 
{ 
   Console.WriteLine("Log: {0}", value); 
   return value; 
} 
... 
Dump(x: Log(1), y: Log(2), z: Log(3)); 
Dump(z: Log(3), x: Log(1), y: Log(2));
1
2
3
4
5
6
7
8
Log: 1 
Log: 2 
Log: 3 
x=1 y=2 z=3 
Log: 3 
Log: 1 
Log: 2 
x=1 y=2 z=3
Listing 13.5. Abusing argument evaluation order
1
2
3
4
int i = 0; 
Dump(x: ++i, y: ++i, z: ++i); 
i = 0; 
Dump(z: ++i, x: ++i, y: ++i);

Figure 13.3. Mixing named arguments and optional parameters
Listing 13.6. Combining named arguments and optional parameters
static void AppendTimestamp(string filename,  
                           string message, 
                           Encoding encoding = null,  
                           DateTime? timestamp = null) 
{ 
   
} 
... 
AppendTimestamp("utf8.txt", "Message in the future", 
               timestamp: new DateTime(2030, 1, 1));
Message message = new Message { 
  From = "skeet@pobox.com", 
  To = "csharp-in-depth-readers@everywhere.com", 
  Body = "Hope you like the third edition", 
  Subject = "A quick message" 
};
Message message = new Message( 
  "skeet@pobox.com", 
  "csharp-in-depth-readers@everywhere.com", 
  "Hope you like the third edition") 
{ 
  Subject = "A quick message" 
};

Listing 13.7. Using optional parameters and named arguments for immutability
public Message(string from, string to, 
              string body, string subject = null, 
              byte[] attachment = null) 
{ 
} 
... 
Message message = new Message( 
  from: "skeet@pobox.com", 
  to: "csharp-in-depth-readers@everywhere.com", 
  body: "I hope you like the third edition", 
  subject: "A quick message" 
);
static void Foo(int x = 10) {} 
static void Foo(int x = 10, int y = 20) {} 
... 
Foo();  
Foo(1);  
Foo(y: 2);  
Foo(1, 2);
void Method(int x, object y) { ... } 
void Method(object a, int b) { ... } 
void Method(int x, object y) { ... } 
void Method(object a, int b) { ... } 
Listing 13.8. Creating and saving a document in C# 3
object missing = Type.Missing; 
Application app = new Application { Visible = true };          #1 
app Documents Add(ref missing ref missing
#2

Figure 13.4. Linking PIAs in Visual Studio 2010
Listing 13.9. Automating Word using normal C# 4 features
Application app = new Application { Visible = true }; 
app.Documents.Add(); 
Document doc = app ActiveDocument;
comObject.SomeMethod(argument);
object tmp = argument; 
comObject.SomeMethod(ref tmp);
Listing 13.10. Passing arguments by value in COM methods
Application app = new Application { Visible = true }; 
app.Documents.Add(); 
Document doc = app ActiveDocument;
SynonymInfo SynonymInfo[string Word, 
                        ref object LanguageId = Type.Missing]
Listing 13.11. Using the SynonymInfo  indexer to count word meanings
static void ShowInfo(SynonymInfo info) 
{ 
Console WriteLine("{0} has {1} meanings"

csc /l:Path\To\PIA.dll MyCode.cs
namespace Microsoft.Office.Interop.Word 
{ 
   [ComImport, TypeIdentifier, CompilerGenerated, Guid("...")] 
   public interface _Application 
 
   [ComImport, TypeIdentifier, CompilerGenerated, Guid("...")] 
   public interface _Document 
 
   [ComImport, CompilerGenerated, TypeIdentifier, Guid("...")] 
   public interface Application : _Application 
 
   [ComImport, Guid("..."), TypeIdentifier, CompilerGenerated] 
   public interface Document : _Document 
   [ComImport, TypeIdentifier, CompilerGenerated, Guid("...")] 
   public interface Documents : IEnumerable 
 
   [TypeIdentifier("...", "WdSaveFormat"), CompilerGenerated] 
   public enum WdSaveFormat 
}
[ComImport, TypeIdentifier, CompilerGenerated, Guid("...")] 
public interface _Application 
{ 
   void_VtblGap 1_4(); 
   Documents Documents { [...] get; } 
   void_VtblGap2_1(); 
   Document ActiveDocument { [...] get; } 
}

Figure 13.5. Comparing referencing and linking
Application application = (Application) Activator.CreateInstance( 
    Type.GetTypeFromCLSID (new Guid("...")));
interface IFactory<T> 
{ 
   T CreateInstance(); 
}
interface IPrettyPrinter<T> 
{ 
   void Print(T document); 
}
interface IStorage<T> 
{ 
   byte[] Serialize(T value); 
   T Deserialize(byte[] data); 
}
public interface IEnumerable<out T> 
public interface IComparer<in T>

List<Circle> circles = new List<Circle> 
{ 
   new Circle(new Point(0, 0), 15), 
   new Circle(new Point(10, 5), 20), 
}; 
 
List<Square> squares = new List<Square> 
{ 
   new Square(new Point(5, 10), 5), 
   new Square(new Point(-10, 0), 2) 
};
Listing 13.12. Using variance to build a list of general shapes from speci×c lists
List<IShape> shapesByAdding = new List<IShape>();                          #1 
shapesByAdding.AddRange(circles); 
shapesByAdding AddRange(squares);
Listing 13.13. Sorting circles using a general-purpose comparer and contravariance
class AreaComparer : IComparer<IShape>                      #1 
{ 
public int Compare(IShape x IShape y)
delegate T Func<out T>() 
delegate void Action<in T>(T obj)
Listing 13.14. Using variance with simple Func<T>  and Action<T>  delegates
Func<Square> squareFactory = () => new Square(new Point(5, 5), 10); 
Func<IShape> shapeFactory = squareFactory;                                #1 
Listing 13.15. Demonstrating covariance and contravariance with a single type
Converter<object, string> converter = x => x.ToString();             #1 
Converter<string, string> contravariance = converter; 
Converter<object object> covariance = converter;
delegate Func<T> FuncFunc<out T>(); 
delegate void ActionAction<out T>(Action<T> action); 
delegate void ActionFunc<in T>(Func<T> function); 
delegate Action<T> FuncAction<in T>();

IComparer<IEnumerable<object>> objectsComparer = ...; 
IComparer<IEnumerable<string>> stringsComparer = objectsComparer;
delegate bool TryParser<T>(string input, out T value)
Func<string> stringFunc = () => ""; 
Func<object> objectFunc = () => new object(); 
Func<object> combined = objectFunc + stringFunc;
Func<string> stringFunc = () => ""; 
Func<object> defensiveCopy = new Func<object>(stringFunc); 
Func<object> objectFunc = () => new object(); 
Func<object> combined = objectFunc + defensiveCopy;
List<Shape> shapes1 = new ArrayList<Shape>(); 
List<? super Square> squares = shapes1;                     #1 
squares add(new Square(10 10 20 20));
lock (listLock) 
{ 
   list.Add("item"); 
}
object tmp = listLock;                  #1 
Monitor.Enter(tmp);                     #2 
try
bool acquired = false; 
object tmp = listLock; 
try
public event EventHandler Click;

CHAPTER 14
1 books.FindByAuthor("Joshua Bloch")
1 books.Find("Author", "Joshua Bloch")
Listing 14.1. Using dynamic  to iterate through a list, concatenating strings
1
2
3
4
5
6
7
8
dynamic items = new List<string> { "First", "Second", "Third" }; 
dynamic valueToAdd = "!"; 
foreach (dynamic item in items) 
{ 
   string result = item + valueToAdd; 
   Console.WriteLine(result); 
 
}
Listing 14.2. Adding integers to strings dynamically
1
2
3
4
5
6
7
dynamic items = new List<string> { "First", "Second", "Third" }; 
dynamic valueToAdd = 2; 
foreach (dynamic item in items) 
{ 
   string result = item + valueToAdd;  
   Console.WriteLine(result); 
}
1
Listing 14.3. Adding integers to integers
1
2
3
4
dynamic items = new List<int> { 1, 2, 3 }; 
dynamic valueToAdd = 2; 
foreach (dynamic item in items) 
{ 

5
6
7
   string result = item + valueToAdd;  
   Console.WriteLine(result); 
}
1
1
2
3
4
5
6
7
8
Unhandled Exception: 
   Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: 
Cannot implicitly convert type 'int' to 'string' 
   at CallSite.Target(Closure , CallSite , Object ) 
   at System.Dynamic.UpdateDelegates.UpdateAndExecute1[T0,TRet] 
          (CallSite site, T0 arg0) 
 
   ...
Listing 14.4. Adding integers to integer—but without the exception
1
2
3
4
5
6
dynamic items = new List<int> { 1, 2, 3 }; 
dynamic valueToAdd = 2; 
foreach (dynamic item in items) 
{ 
   Console.WriteLine(item + valueToAdd); 
}
1
Listing 14.5. Setting a range of values with static typing
1
2
3
4
5
6
7
var app = new Application { Visible = true }; 
app.Workbooks.Add(); 
Worksheet worksheet = (Worksheet) app.ActiveSheet; 
Range start = (Range) worksheet.Cells[1, 1]; 
Range end = (Range) worksheet.Cells[1, 20]; 
worksheet.Range[start, end].Value = Enumerable.Range(1, 20)  
                                              .ToArray();
1
2
3
Listing 14.6. Using implicit conversions from dynamic  in Excel
1
2
3
4
5
6
7
var app = new Application { Visible = true }; 
app.Workbooks.Add(); 
Worksheet worksheet = app.ActiveSheet; 
Range start = worksheet.Cells[1, 1]; 
Range end = worksheet.Cells[1, 20]; 
worksheet.Range[start, end].Value = Enumerable.Range(1, 20) 
                                              .ToArray();

Listing 14.7. Using dynamic  everywhere
1
2
3
4
5
6
7
var app = new Application { Visible = true }; 
app.Workbooks.Add(); 
dynamic worksheet = app.ActiveSheet; 
dynamic start = worksheet.Cells[1, 1]; 
dynamic end = worksheet.Cells[1, 20]; 
worksheet.Range[start, end].Value = Enumerable.Range(1, 20) 
                                              .ToArray();
Listing 14.8. Printing hello, world  twice using Python embedded in C#
ScriptEngine engine = Python.CreateEngine(); 
engine.Execute("print 'hello, world'"); 
engine.ExecuteFile("HelloWorld.py");
Listing 14.9. Passing information between a host and a script using ScriptScope
string python = @" 
text = 'hello'                                           #1 
output = input + 1
scope.SetVariable("num", 20) 
double x = scope.GetVariable<double>("num")             #1 
double y = (double) scope GetVariable("num");
#2
Listing 14.10. Calling a function declared in a ScriptScope
string python = @" 
def sayHello(user): 
print 'Hello %(name)s' % {'name' : user}

static Configuration LoadConfiguration() 
{ 
   ScriptEngine engine = Python.CreateEngine(); 
   ScriptScope scope = engine.CreateScope(); 
   engine.ExecuteFile("configuration.py", scope); 
   return Configuration.FromScriptScope(scope); 
}
agentThreads = System.Environment.ProcessorCount 
agentThreadName = 'Processing agent'
agentThreads = 1 
agentThreadName = 'Processing agent (single thread only)'
Listing 14.11. Using dynamic type inference
private static bool AddConditionallyImpl<T>(IList<T> list, T item) 
{ 
if (list Count < 10)
#1
Listing 14.12. Summing an arbitrary sequence of elements dynamically
public static T DynamicSum<T>(this IEnumerable<T> source) 
{ 
dynamic total = default(T);
#1
Listing 14.13. Summing a list of TimeSpan  elements dynamically
var times = new List<TimeSpan> 
{ 
2 Hours() 25 Minutes() 30 Seconds()
Listing 14.14. Accessing a Count  property with duck typing
static void PrintCount(IEnumerable collection) 
{ 
dynamic d = collection;

Figure 14.1. How the components of .NET 4 ×t together, allowing static and dynamic
languages to execute on the same underlying platform
Figure 14.2. Lifecycle of a dynamic expression
Listing 14.15. Counting different types ef×ciently using multiple dispatch
private static int CountImpl<T>(ICollection<T> collection) 
{ 
return collection Count;

Figure 14.3. Relationships between dynamic caches and call sites
d.Foo(10);
CallSite<Action<CallSite, object, int>>.Create(Binder.InvokeMember( 
  CSharpBinderFlags.ResultDiscarded, "Foo", null, typeof(Test), 
  new CSharpArgumentInfo[] { 
   CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null), 
   CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.Constant | 
                             CSharpArgumentInfoFlags.UseCompileTimeType, 
                             null) }));

callSite.Target(callSite, d, 10);
Listing 14.16. Experimenting with method overloading and dynamic values
static void Execute(string x) 
{ 
Console WriteLine("String overload");
dynamic d = 0; 
string x = "text"; 
var array = new[] { d, x };
dynamic d = GetValueDynamically(); 
string x = d as string;
dynamic d = GetValueDynamically(); 
SomeType x = new SomeType(d);
string text = "text to cut"; 
dynamic startIndex = 2; 
string substring = text.Substring(startIndex);
Listing 14.17. The results of compiling dynamic code
[CompilerGenerated] 
private static class <Main>o__SiteContainer0 {                            #1 
public static CallSite<Func<CallSite object string>> <>p
Site1;

Listing 14.18. Dynamic overload resolution within a single type
static void Execute(dynamic x, string y) 
{ 
Console WriteLine("dynamic string");
Listing 14.19. Dynamic overload resolution within a class hierarchy
class Base 
{ 
public void Execute(object x)
Listing 14.20. Catching errors in dynamic calls at compile time
string text = "cut me up"; 
dynamic guid = Guid.NewGuid(); 
text Substring(guid);
Listing 14.21. Generic type inference with mixed static and dynamic values
void Execute<T>(T rst, T second, string other) where T : struct 
{ 
}
Listing 14.22. Calling extension methods with dynamic arguments
dynamic size = 5; 
var numbers = Enumerable.Range(10, 10); 
var error = numbers Take(size);
#1
Listing 14.23. Dynamic types and lambda expressions
dynamic badMethodGroup = Console.WriteLine; 
dynamic goodMethodGroup = (Action<string>) Console.WriteLine; 
void Method(Action<string> action, string value) 
{ 
action(value);

Listing 14.24. Querying a collection of dynamic elements
var list = new List<dynamic> { 50, 5m, 5d }; 
var query = from number in list 
where number > 4
Listing 14.25. Storing and retrieving values with ExpandoObject
dynamic expando = new ExpandoObject(); 
IDictionary<string, object> dictionary = expando; 
expando First = "value set dynamically";
Listing 14.26. Faking methods on an ExpandoObject  with delegates
dynamic expando = new ExpandoObject(); 
expando.AddOne = (Func<int, int>) (x => x + 1); 
Console Write(expando AddOne(10));
<root> 
  <branch> 
    <leaf /> 
  </branch> 
</root>
dynamic leaf = root.branch.leaf;
Listing 14.27. Implementing a simplistic XML DOM conversion with ExpandoObject
public static dynamic CreateDynamicXml(XElement element) 
{ 
dynamic expando = new ExpandoObject();
<books> 
  <book name="Mortal Engines"> 
    <author name="Philip Reeve" /> 
  </book> 
  <book name="The Talisman"> 
    <author name="Stephen King" /> 
    <author name="Peter Straub" /> 
  </book> 
  <book name="Rose"> 
    <author name="Holly Webb" /> 
    <excerpt> 
      Rose was remembering the illustrations from 

Figure 14.4. Tree structure of sample XML ×le
      Morally Instructive Tales for the Nursery. 
    </excerpt> 
  </book> 
</books>
Listing 14.28. Using a dynamic DOM created from expandos
XDocument doc = XDocument.Load("books.xml"); 
dynamic root = CreateDynamicXml(doc.Root); 
Console WriteLine(root book author ToXml());
<author name="Philip Reeve" /> 
Rose was remembering the illustrations from 
Morally Instructive Tales for the Nursery
Listing 14.29. Skeleton of DynamicXElement
public class DynamicXElement : DynamicObject 
{ 
private readonly XElement element;
#1

Figure 14.5. Selecting data using DynamicXElement
Table 14.1. Virtual TryXXX  methods in DynamicObject
Name
Type of call represented (where x is the dynamic object)
TryBinaryOperation
Binary operation, such as x + y
TryConvert
Conversions, such as (Target) x
TryCreateInstance
Object creation expressions; no equivalent in C#
TryDeleteIndex
Indexer removal operation; no equivalent in C#
TryDeleteMember
Property removal operation; no equivalent in C#
TryGetIndex
Indexer getter, such as x[10]
TryGetMember
Property getter, such as x.Property
TryInvoke
Direct invocation treating x like a delegate, such as x(10)
TryInvokeMember
Invocation of a member, such as x.Method()
TrySetIndex
Indexer setter, such as x[10] = 20
TrySetMember
Property setter, such as x.Property = 10
Listing 14.30. Adding nondynamic members to DynamicXElement
public override string ToString()                       #1 
{ 
return element ToString();

Name
Type of call represented (where x is the dynamic object)
TryUnaryOperation
Unary operation, such as !x or -x
Figure 14.6. Visual Studio 2010 displaying dynamic properties of a
DynamicXElement
public virtual bool TryInvokeMember(InvokeMemberBinder binder, 
   object[] args, out object result)
Listing 14.31. Implementing a dynamic property with TryGetMember()
public override bool TryGetMember(GetMemberBinder binder, 
                                  out object result) 
{
Listing 14.32. Testing DynamicXElement
XDocument doc = XDocument.Load("books.xml"); 
dynamic root = DynamicXElement.CreateInstance(doc.Root); 
Console WriteLine(root book[2]["name"]);
Listing 14.33. Implementing GetDynamicMemberNames  in DynamicXElement
public override IEnumerable<string> GetDynamicMemberNames() 
{ 
return element Elements()
Listing 14.34. The ×nal aim: calling methods dynamically until you hit the right name

dynamic x = new Rumpelstiltskin("Hermione"); 
x.Harry(); 
x Ron();
Listing 14.35. The Rumpelstiltskin  type, without its meta-object code
public sealed class Rumpelstiltskin : IDynamicMetaObjectProvider 
{ 
private readonly string name;
Listing 14.36. The real dynamic guts of Rumpelstiltskin —its meta-object
private class MetaRumpelstiltskin : DynamicMetaObject 
{ 
private static readonly MethodInfo RightGuessMethod =
#1

CHAPTER 15
Listing 15.1. Displaying a page length asynchronously
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
class AsyncForm : Form 
{ 
   Label label; 
   Button button; 
   public AsyncForm() 
   { 
      label = new Label { Location = new Point(10, 20),  
                          Text = "Length" }; 
      button = new Button { Location = new Point(10, 50),  
                            Text = "Click" }; 
      button.Click += DisplayWebSiteLength;  
      AutoSize = true; 
      Controls.Add(label); 
      Controls.Add(button); 
   } 
   async void DisplayWebSiteLength(object sender, EventArgs e) 
   { 
      label.Text = "Fetching..."; 
      using (HttpClient client = new HttpClient())  
      {                                             
         string text =  
               await client.GetStringAsync("http://csharpindepth.com");  
         label.Text = text.Length.ToString(); 
      } 
   } 
} 
... 
Application.Run(new AsyncForm());
1
2
3
1
2
3
4
5
6
7
8
9
10
11
async void DisplayWebSiteLength(object sender, EventArgs e) 
{ 
   label.Text = "Fetching..."; 
   using (HttpClient client = new HttpClient()) 
   { 
      Task<string> task = 
         client.GetStringAsync("http://csharpindepth.com"); 
      string text = await task; 
      label.Text = text.Length.ToString(); 
   } 
}
1
2
Console.WriteLine("First"); 
Console.WriteLine("Second");

Figure 15.1. Async model
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
static async Task<int> GetPageLengthAsync(string url) 
{ 
   using (HttpClient client = new HttpClient()) 
   { 
      Task<string> fetchTextTask = client.GetStringAsync(url); 
      int length = (await fetchTextTask).Length; 
      return length; 
   } 
} 
 
static void PrintPageLength() 
{ 
   Task<int> lengthTask = 
      GetPageLengthAsync("http://csharpindepth.com"); 
   Console.WriteLine(lengthTask.Result); 
}
1
2
3
4
public static async Task<int> FooAsync() { ... } 
public async static Task<int> FooAsync() { ... } 
async public Task<int> FooAsync() { ... } 
public async virtual Task<int> FooAsync() { ... }
1
2
3
4
5
6
private async void LoadStockPrice(object sender, EventArgs e) 
{ 
   string ticker = tickerInput.Text; 
   decimal price = await stockPriceService.FetchPriceAsync(ticker); 
   priceDisplay.Text = price.ToString("c"); 
}

1 loadStockPriceButton.Click += LoadStockPrice;
1
2
3
4
5
// Real interface in System.Runtime.CompilerServices 
public interface INotifyCompletion 
{ 
   void OnCompleted(Action continuation); 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
// Warning: these don't really exist 
// Imaginary interfaces for asynchronous operations returning values 
public interface IAwaitable<T> 
{ 
   IAwaiter<T> GetAwaiter(); 
} 
 
public interface IAwaiter<T> : INotifyCompletion 
{ 
   bool IsCompleted { get; } 
   T GetResult(); 
 
   // Inherited from INotifyCompletion 
   // void OnCompleted(Action continuation); 
} 
 
// Imaginary interfaces for "void" asynchronous operations 
public interface IAwaitable 
{ 
   IAwaiter GetAwaiter(); 
} 
 
public interface IAwaiter : INotifyCompletion 
{ 
   bool IsCompleted { get; } 
   void GetResult(); 
 
   // Inherited from INotifyCompletion 
   // void OnCompleted(Action continuation); 
}
1
2
3
4
5
using (var client = new HttpClient()) 
{ 
   Task<string> task = client.GetStringAsync(...); 
   string result = await task; 
}

await Task.Yield();
YieldAwaitable yielder = Task.Yield(); 
await yielder;
public async Task<int> FooAsync() 
{ 
  string bar = await BarAsync(); 
  // Obviously this would usually be more complicated... 
  return bar.Length; 
} 
public async Task<string> BarAsync() 
{ 
  // Some async code that could call more async methods... 
}
string pageText = await new HttpClient().GetStringAsync(url);
Task<string> task = new HttpClient().GetStringAsync(url); 
string pageText = await task;
AddPayment(await employee.GetHourlyRateAsync() * 
           await timeSheet.GetHoursWorkedAsync(employee.Id));
Task<decimal> hourlyRateTask = employee.GetHourlyRateAsync(); 
decimal hourlyRate = await hourlyRateTask; 
Task<int> hoursWorkedTask = timeSheet.GetHoursWorkedAsync(employee.Id); 
int hoursWorked = await hoursWorkedTask; 
AddPayment(hourlyRate * hoursWorked);

Figure 15.2. User-visible model of await  handling
Figure 15.3. Await handling via the awaitable pattern

static async Task<int> GetPageLengthAsync(string url) 
{ 
   using (HttpClient client = new HttpClient()) 
   { 
      Task<string> fetchTextTask = client.GetStringAsync(url); 
      int length = (await fetchTextTask).Length; 
      return length; 
   } 
}
async Task<string> FetchFirstSuccessfulAsync(IEnumerable<string> urls) 
{ 
   // TODO: Validate that we've actually got some URLs... 
   foreach (string url in urls) 
   { 
      try 
      { 
         using (var client = new HttpClient()) 
         { 
             return await client.GetStringAsync(url); 
         } 
      } 

      catch (WebException exception) 
      { 
         // TODO: Logging, update statistics etc. 
      } 
   } 
   throw new WebException("No URLs succeeded"); 
}
Listing 15.2. Rewrapping multiple exceptions from task failures
public static AggregatedExceptionAwaitable WithAggregatedExceptions( 
                                                       this Task task) 
{
Listing 15.3. Catching multiple exceptions as AggregateException
private async static Task CatchMultipleExceptions() 
{ 
Task task1 = Task Run(() => { throw new Exception("Message 1");
Caught 2 exceptions: Message 1, Message 2
Listing 15.4. Handling asynchronous exceptions in a familiar style
static async Task MainAsync() 
{ 
Task<string> task = ReadFileAsync("garbage le");
#1
Listing 15.5. Broken argument validation in an async method
static async Task MainAsync() 
{ 
Task<int> task = ComputeLengthAsync(null);
#1
Listing 15.6. Splitting argument validation from async implementation
static Task<int> ComputeLengthAsync(string text) 
{ 
if (text == null)

Listing 15.7. Creating a canceled task by throwing OperationCanceledException
static async Task ThrowCancellationException() 
{ 
throw new OperationCanceledException();
Listing 15.8. Cancellation of an async method via a canceled delay
static async Task DelayFor30Seconds(CancellationToken token) 
{ 
Console WriteLine("Waiting for 30 seconds ");
Waiting for 30 seconds... 
Initial status: WaitingForActivation 
Caught System.Threading.Tasks.TaskCanceledException: A task was canceled. 
Final status: Canceled
Func<Task> lambda = async () => await Task.Delay(1000); 
Func<Task<int>> anonMethod = async delegate() 
{ 
   Console.WriteLine("Started"); 
   await Task.Delay(1000); 
   Console.WriteLine("Finished"); 
   return 10; 
};
Listing 15.9. Creating and calling an asynchronous function using a lambda expression
Func<int, Task<int>> function = async x => 
{ 
Console WriteLine("Starting
x={0}" x);
Starting... x=5 
Starting... x=3 
Finished... x=3 
Finished... x=5 
First result: 10 
Second result: 6
Listing 15.10. Argument validation using an async anonymous function
static Task<int> ComputeLengthAsync(string text) 
{ 
if (text == null)

Figure 15.4. Flowchart of generated code
Listing 15.11. Simple async method to demonstrate compiler transformations
static async Task<int> SumCharactersAsync(IEnumerable<char> text) 
{ 
int total = 0;
[DebuggerStepThrough] 
[AsyncStateMachine(typeof(DemoStateMachine))] 
static Task<int> SumCharactersAsync(IEnumerable<char> text) 
{ 
   var machine = new DemoStateMachine(); 
   machine.text = text; 
   machine.builder = AsyncTaskMethodBuilder<int>.Create(); 

 
   machine.state = -1; 
   machine.builder.Start(ref machine); 
   return machine.builder.Task; 
}
[CompilerGenerated] 
private struct DemoStateMachine : IAsyncStateMachine 
{
void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine machine) 
{ 
   builder.SetStateMachine(machine); 
}
void IStateMachine.MoveNext() 
{ 
   // For an asynchronous method declared to return Task<int> 
   int result; 
   try 
   { 
      bool doFinallyBodies = true; 
      switch (state) 
      { 
         // Code to jump to the right place... 
      } 
 
      // Main body of the method 
   } 
   catch (Exception e) 
   { 
      state = -2; 
      builder.SetException(e); 
      return; 
   } 
   state = -2; 
   builder.SetResult(result); 
}
await Task.Delay(unicode);
TaskAwaiter localTaskAwaiter = Task.Delay(unicode).GetAwaiter(); 
   if (localTaskAwaiter.IsCompleted) 
   { 
      goto DemoAwaitCompletion; 
   } 
   state = 0; 
   taskAwaiter = localTaskAwaiter; 
   builder.AwaitUnsafeOnCompleted(ref localTaskAwaiter, ref this); 
   doFinallyBodies = false; 
   return; 
DemoAwaitContinuation: 
   localTaskAwaiter = taskAwaiter; 

 
   taskAwaiter = default(TaskAwaiter); 
   state = -1; 
DemoAwaitCompletion: 
   localTaskAwaiter.GetResult(); 
   localTaskAwaiter = default(TaskAwaiter);
var x = y * z;
push y 
push z 
multiply 
store x
var x = y * await z;
Console.WriteLine("{0}: {1}", x, await task);
   string localArg0 = "{0} {1}"; 
   int localArg1 = x; 
   localAwaiter = task.GetAwaiter(); 
   if (localAwaiter.IsCompleted) 
   { 
      goto SecondAwaitCompletion; 
   } 
   var localTuple = new Tuple<string, int>(localArg0, localArg1); 
   stack = localTuple; 
   state = 1; 
   awaiter = localAwaiter; 
   builder.AwaitUnsafeOnCompleted(ref awaiter, ref this); 
   doFinallyBodies = false; 
   return; 
SecondAwaitContinuation: 
   localTuple = (Tuple<string, int>) stack; 
   localArg0 = localTuple.Item1; 
   localArg1 = localTuple.Item2; 
   stack = null; 
 
   localAwaiter = awaiter; 
   awaiter = default(TaskAwaiter<int>); 
   state = -1; 
SecondAwaitCompletion: 
   int localArg2 = localAwaiter.GetResult(); 
   Console.WriteLine(localArg0, localArg1, localArg2);  // Bold
Employee LoadEmployeeById(string id)

Figure 15.5. Visualization of ordering
// NOTE TO PRODUCTION: Please consult with Jon on formatting. 
Do not abbreviate! 
Task<Employee> LoadEmployeeById(string id) 
Task<Employee> LoadEmployeeById(string id, CancellationToken cancellationToken) 
Task<Employee> LoadEmployeeById(string id, IProgress<int> progress) 
Task<Employee> LoadEmployeeById(string id, 
   CancellationToken cancellationToken, IProgress<int> progress)
public static async Task<int> ProcessRecords() 
{ 
   List<Record> records = await FetchRecordsAsync() 
      .ConfigureAwait(continueOnCapturedContext: false); 
 
   // ... record handling here ... 
   await SaveResultsAsync(results) 
      .ConfigureAwait(continueOnCapturedContext: false); 
 
   // Let the caller know how many records were processed 
   return records.Count; 
}
var tasks = urls.Select(async url => 
{ 
   using (var client = new HttpClient()) 
   { 
 
      return await client.GetStringAsync(url); 
   } 
}).ToList();
static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>> tasks)
string[] results = await Task.WhenAll(tasks);
Listing 15.12. Transforming a task sequence into a new collection in completion order
public static IEnumerable<Task<T>> InCompletionOrder<T> 
    (this IEnumerable<Task<T>> source) 
{

Listing 15.13. Displaying page lengths as the data is returned
static async Task<int> ShowPageLengthsAsync(params string[] urls) 
{ 
var tasks = urls Select(async url =>
[TestMethod] 
public void TasksCompleteInOrder() 
{ 
   var tardis = new TimeMachine(); 
   var task1 = tardis.ScheduleSuccess(1, "t1"); 
   var task2 = tardis.ScheduleSuccess(2, "t2"); 
   var task3 = tardis.ScheduleSuccess(3, "t3"); 
 
   var tasksOutOfOrder = new[] { task2, task3, task1 }; 

 
   tardis.ExecuteInContext(advancer => 
   { 
      var inOrder = tasksOutOfOrder.InCompletionOrder().ToList(); 
      advancer.AdvanceTo(3); 
      Assert.AreEqual("t1", inOrder[0].Result); 
      Assert.AreEqual("t2", inOrder[1].Result); 
      Assert.AreEqual("t3", inOrder[2].Result); 
   }); 
}
// Omitted setup steps, which are the same as the previous test. 
tardis.ExecuteInContext(advancer => 
{ 
   var inOrder = tasksOutOfOrder.InCompletionOrder().ToList(); 
 
   Assert.AreEqual(TaskStatus.WaitingForActivation, inOrder[0].Status); 
   Assert.AreEqual(TaskStatus.WaitingForActivation, inOrder[1].Status); 
 
   Assert.AreEqual(TaskStatus.WaitingForActivation, inOrder[2].Status); 
 
   advancer.Advance(); 
   Assert.AreEqual(TaskStatus.RanToCompletion, inOrder[0].Status); 
   Assert.AreEqual(TaskStatus.WaitingForActivation, inOrder[1].Status); 
   Assert.AreEqual(TaskStatus.WaitingForActivation, inOrder[2].Status); 
 
   advancer.Advance(); 
   Assert.AreEqual(TaskStatus.RanToCompletion, inOrder[1].Status); 
   Assert.AreEqual(TaskStatus.WaitingForActivation, inOrder[2].Status); 
 
   advancer.Advance(); 
   Assert.AreEqual(TaskStatus.RanToCompletion, inOrder[2].Status); 
});
[Test] // NUnit TestAttribute 
public async void BadTestMethod() 
{ 
   // Code using await 
}
[Test] 
public async Task GoodTestMethod() 
{ 
   // Code using await 
}
public interface INotifyCompletion 
{ 
   void OnCompleted(Action continuation); 
}
public interface ICriticalNotifyCompletion : INotifyCompletion 
{ 

   void UnsafeOnCompleted(Action continuation); 
}

CHAPTER 16
Listing 16.1. Using captured iteration variables
1
2
3
4
5
6
7
8
9
10
11
12
string[] values = { "x", "y", "z" }; 
var actions = new List<Action>(); 
 
foreach (string value in values) 
{ 
   actions.Add(() => Console.WriteLine(value)); 
} 
 
foreach (Action action in actions) 
{ 
   action(); 
}
Listing 16.2. Using caller information attributes properly, and abusing them
1
2
3
4
5
6
7
8
9
static void ShowInfo([CallerFilePath] string file = null, 
                     [CallerLineNumber] int line = 0, 
                     [CallerMemberName] string member = null) 
{ 
   Console.WriteLine("{0}:{1} - {2}", file, line, member); 
} 
... 
ShowInfo(); 
ShowInfo("LiesAndDamnedLies.java", -10);
1
2
1
2
c:\Users\Jon\Code\Chapter16\CallerInfoDemo.cs:21 - Main 
LiesAndDamnedLies.java:-10 - Main
Listing 16.3. Attempting to use caller information attributes in an attribute declaration
1
2
3
4
5
[AttributeUsage(AttributeTargets.All)] 
public class MemberDescriptionAttribute : Attribute 
{ 
   public MemberDescriptionAttribute([CallerMemberName] string member = null) 
   { 

6
7
8
9
10
   Member = member; 
   } 
 
   public string Member { get; set; } 
}
Listing 16.4. Attempting to use caller information attributes with dynamic invocation
1
2
3
4
5
6
7
8
9
10
class TypeUsedDynamically 
{ 
   internal void ShowCaller([CallerMemberName] string caller = "Unknown") 
   { 
      Console.WriteLine("Called by: {0}", caller); 
   } 
} 
... 
dynamic x = new TypeUsedDynamically(); 
x.ShowCaller();
1
2
public delegate void PropertyChangedEventHandler(Object sender, 
                                                 PropertyChangedEventArgs e)
1 public PropertyChangedEventArgs(string propertyName)
Listing 16.5. Implementing INotifyPropertyChanged  the old way
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
class OldPropertyNotifier : INotifyPropertyChanged 
{ 
   public event PropertyChangedEventHandler PropertyChanged; 
 
   private int firstValue; 
   public int FirstValue 
   { 
      get { return firstValue; } 
      set 
      { 
         if (value != firstValue) 
         { 
            firstValue = value; 
            NotifyPropertyChanged("FirstValue"); 
         } 
      } 
   } 
 

19
20
21
22
23
24
25
26
27
28
29
30
    // Other properties with the same pattern 
 
   private void NotifyPropertyChanged(string propertyName) 
   { 
      PropertyChangedEventHandler handler = PropertyChanged; 
      if (handler != null) 
 
      { 
         handler(this, new PropertyChangedEventArgs(propertyName)); 
      } 
   } 
}
Listing 16.6. Implementing INotifyPropertyChanged  using caller information
1
2
3
4
5
6
7
8
9
10
11
12
13
// Within the setter 
if (value != firstValue) 
{ 
   firstValue = value; 
   NotifyPropertyChanged(); 
} 
 
... 
 
void NotifyPropertyChanged([CallerMemberName] string propertyName = null) 
{ 
   // Exactly the same code as before 
}

