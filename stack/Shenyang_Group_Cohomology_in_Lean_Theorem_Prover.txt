Imperial College London
Mathematics
M4R Project
Group Cohomology in Lean Theorem Prover
Author
Shenyang Wu
With thanks to my supervisor
Professor Kevin Buzzard
June 8, 2020

Abstract
Lean Theorem Prover provides an interactive platform for users to state and prove mathe-
matical concepts in a computer-readable manner. Since Lean ﬁrst launched in 2013, many
work to enrich its math library and to test the ability of Lean in understanding advance
mathematical topics. This project aims to formalize in Lean the ﬁrst general deﬁnition of
group cohomology, Hn(GM) for any n ∈N, group G and G-module M in any theorem
provers. This report mainly consists of two parts. Part 1 is the blueprint of group coho-
mology, serving as a detailed mathematical guidance for Part 2, the formalization process in
Lean. Deﬁnitions of cochain, diﬀerential in a complex, cocycle, coboundary and cohomol-
ogy are given in a technical feasible and computational convenient manner and successfully
formalized in Lean. Some progress to formalizing the induced long exact sequence of group
cohomology are made. This project demonstrates Lean’s capability of understanding group
cohomology and Lean veriﬁes the blueprint provided. More importantly, formalizing group
cohomology in Lean opens Lean up to more advanced topics such as class ﬁeld theory due
to group cohomology’s great usefulness in both local and global ﬁeld theory.
1

CONTENTS
CONTENTS
Contents
1
Introduction
4
1.1
Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.1.1
Part 1: The Blueprint
. . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.1.2
Part 2: Formalization in Lean . . . . . . . . . . . . . . . . . . . . . .
5
1.2
Literature Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.3
Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.3.1
Usefulness of Group Cohomology . . . . . . . . . . . . . . . . . . . .
6
1.3.2
The First General Deﬁnition in any Theorem Prover
. . . . . . . . .
6
1.4
Special Notes on n ∈N . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
2
Group Cohomology
8
2.1
Cochain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.2
A Contraction Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.3
An Important Result on Double Sum . . . . . . . . . . . . . . . . . . . . . .
8
2.4
The Diﬀerential dn
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
2.5
dn+1 ◦dn = 0
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.6
dn is a Group Homomorphism . . . . . . . . . . . . . . . . . . . . . . . . . .
17
2.7
Cocycle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.8
Coboundary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.9
Cohomology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.10 Long Exact Sequence of Group Cohomology . . . . . . . . . . . . . . . . . .
19
3
An Introduction to Lean Theorem Prover
22
3.1
What is Lean? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
3.2
Conventions in Lean
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
3.2.1
Basic Set Up
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
3.2.2
Functions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
3.2.3
Bundled Compared to Un-bundled
. . . . . . . . . . . . . . . . . . .
25
3.3
Tactics in Lean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
4
Group Cohomology in Lean
27
4.1
Cochain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
4.2
The Contraction map Fn,j
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
4.2.1
Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
4.2.2
Lemma 2.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
4.3
The Result on Double Sum . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
4.3.1
Conversion to a Single Sum
. . . . . . . . . . . . . . . . . . . . . . .
30
4.3.2
Summand in the Double Sum . . . . . . . . . . . . . . . . . . . . . .
31
4.3.3
Rephrasing Lemma 2.3 . . . . . . . . . . . . . . . . . . . . . . . . . .
31
4.3.4
The Involution
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
4.3.5
Final Result on the Sum . . . . . . . . . . . . . . . . . . . . . . . . .
35
4.4
Deﬁnition of dn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
4.5
dn+1 ◦dn = 0
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
4.5.1
Facts about Double Sums
. . . . . . . . . . . . . . . . . . . . . . . .
39
4.5.2
Facts about Fn,j . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
4.5.3
Facts about G-Module . . . . . . . . . . . . . . . . . . . . . . . . . .
43
4.5.4
Proof of the Final Result . . . . . . . . . . . . . . . . . . . . . . . . .
45
4.6
dn as a Group Homomorphism . . . . . . . . . . . . . . . . . . . . . . . . . .
46
4.6.1
Bundle: Additive Subgroup
. . . . . . . . . . . . . . . . . . . . . . .
46
2

CONTENTS
CONTENTS
4.6.2
Bundle: Additive Group Homomorphism . . . . . . . . . . . . . . . .
47
4.6.3
dn as a Group Homomorphism . . . . . . . . . . . . . . . . . . . . . .
47
4.7
Deﬁnition of Cocycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
4.8
Deﬁnition of Coboundary
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
4.9
Deﬁnition of Cohomology
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
4.9.1
Bundle: Additive Sub-quotient
. . . . . . . . . . . . . . . . . . . . .
48
4.9.2
Deﬁnition of Cohomology
. . . . . . . . . . . . . . . . . . . . . . . .
48
4.10 Partially Finished: Long Exact Sequence . . . . . . . . . . . . . . . . . . . .
49
4.10.1 Bundle: G-Module and G-Module Homomorphism . . . . . . . . . . .
49
4.10.2 Step 1: Induced Cochain Map . . . . . . . . . . . . . . . . . . . . . .
49
4.10.3 Step 2: A Commutative Diagram . . . . . . . . . . . . . . . . . . . .
50
4.10.4 Step 3: Induced Map on Cohomology . . . . . . . . . . . . . . . . . .
50
5
Conclusion and Further Researches
51
5.1
Main Results
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
5.2
Implication in Lean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
5.3
Possible Directions of Future Researches
. . . . . . . . . . . . . . . . . . . .
51
6
References
53
3

1
INTRODUCTION
1
Introduction
“After World War II, developments in class
ﬁeld theory led to the stripping away of the
algebras in proofs of class ﬁeld theory as far
as possible, leaving behind only cohomological
formalism. ”
KEITH CONRAD
1.1
Overview
Lean Theorem Prover, launched by Leonardo de Moura at Microsoft Research Redmond in
2013, is an interactive platform where users can state deﬁnitions and prove theorems. The
level of readability and veriﬁability of Lean with regards to mathematical concepts are of
the interests of many mathematicians, and they test it by formalizing complex high-level
mathematical topics in Lean. There are many on-going Lean projects on diﬀerent aspects of
mathematics, such as Patrick Massot’s work on “Sphere Eversion in Lean”, and “Formalizing
the Solution to the Cap Set Problem” by Sander R. Dahmen, Johanne Holzl, and Robert Y.
Lewis. Most of such Lean projects have two main steps,
• Firstly, a detailed mathematics document containing relevant explicit deﬁnitions and
paper proofs of theorems is constructed, normally by mathematicians. This is called
the blueprint.
• Then, following the guidance in the blueprint, is the formalization process in Lean,
usually done by computer scientists.
This project aims to formalize a general deﬁnition of group cohomology in Lean, which is
unprecedented in any theorem provers. Group cohomology is an important tool used to
study groups. The particular way it re-assembles information about a group and its module
makes group cohomology the correct language for class ﬁeld theory.
Adapts similar methodology as other Lean projects, this report has two main parts,
• Part 1: The blueprint for group cohomology, focusing on detailed derivation of the
deﬁnition and proofs of some properties. This is in Section 2.
• Part 2: The implementation of concepts into Lean, using the blueprint as a guidance.
This is in Section 4, where Section 3 is a brief tutorial to Lean.
• Section 5 summaries the main results of this project and lists possible future researches.
It is remarkable that we have achieved both parts, providing the blueprint and achieving
formalization in Lean for group cohomology in this single project.
1.1.1
Part 1: The Blueprint
There are multiple ways to deﬁne group cohomology. For technical feasibility and computa-
tional convenience, we choose the deﬁnition that arises from the standard complex.
Deﬁnition 1.1. A complex is a sequence of abelian groups, A0, A1, A2, · · · , connected by
diﬀerentials dn : An →An+1 such that dn+1 ◦dn = 0. It can be written as
4

1.2
Literature Review
1
INTRODUCTION
A0
A1
A2
· · ·
d0
d1
d2
For a given group G and a G-module M, we will proceed based on the standard complex
above,
• Deﬁne abelian groups {An}, where an element of An is called an n-cochain
• Deﬁne diﬀerentials dn : An →An+1
• Prove that dn+1 ◦dn = 0
• Prove that dn is a group homomorphism
• Deﬁne n-cocycle, Zn(G, M), as kernel of dn+1
• Deﬁne n-coboundary, Bn(G, M), as image of dn
• Deﬁne n-cohomology, Hn(G, M), as the quotient of Zn(G, M) over Bn(G, M).
1.1.2
Part 2: Formalization in Lean
The structure of this part is analogue to that of Part 1 as we follow the blueprint for
formalization.
We will focus on the special properties of Lean as compared to a paper
document, such as its non-triviality, explicitness, dependence and type-speciﬁcity. Rationales
of construction, diﬃculties faced, solutions chosen as a result of these properties will be
discussed thoroughly and ﬁnal results will be presented.
The main goal of this project is to ﬁll in an appropriate type and an explicit deﬁnition to
replace sorry in the following,
def cohomology (n:N )(G : Type∗) [group G] (M : Type∗) [add_comm_group M]
[G_module G M]: SOME TYPE := sorry
The Lean repository for this entire project is available online at https://github.com/
Shenyang1995/M4R.
The audience is assumed to know nothing about group cohomology or Lean, but with certain
level of undergraduate mathematical knowledge, such as groups, subgroups, quotient groups,
homomorphisms, kernels, ranges,and modules.
1.2
Literature Review
Mathematically speaking, group cohomology is well developed in homological algebra. Most
textbooks relating this topic provide the deﬁnitions of complex, cochain, diﬀerential, cocycle,
coboundary and cohomology. During the derivation of the deﬁnition, some authors would
leave out certain details as practices to the reader. Namely, one property of the diﬀerentials
dn that is crucial to the deﬁnition of cohomology is that dn+1 ◦dn = 0, which most texts
state without proving. Further details have to be provided to produce a blueprint for group
cohomology.
For the process of formalization in Lean, there is an established math library in Lean,
consisting of many basic deﬁnitions and theorems that can be directly used. The docu-
ments that are highly relevant to this project includes algebra.basic, group_theory,
algebra.module, data.set, algebra.pi_instances, tactic.linarith, tactic.omega,
5

1.3
Motivation
1
INTRODUCTION
tactic.fin_cases. These ﬁles will be imported to our repository and content will be used
without proofs.
Previously, Anca Ciobanu had done the deﬁnitions of group cohomology for the ﬁrst two
cases, H0 and H1, and the corresponding exact sequences in Lean. She provided the deﬁnition
of n-cocycles and n-coboundaries in the cases of n = 0 and n = 1 as explicit expression in
terms of functions. Unfortunately, this approach fails for a general deﬁnition of n-cocycles,
n-coboundaries and Hn of any natural number n.
1.3
Motivation
1.3.1
Usefulness of Group Cohomology
In homological algebra, group cohomology is a set of useful mathematical tools used to study
groups. It provides insight into the structure of the group G and G-module M themselves.
A well-known result formulated in group cohomology is Hilbert’s Theorem 90, which states,
if L/K is a ﬁnite Galois extension of ﬁelds with Galois group G = Gal(L/K), then the
1-cohomology is trivial:
H1(G, L×) = 1
One application of this theorem is when L/K is the quadratic extension Q(i)/Q. Hilbert’s
Theorem 90 provides the well-known parametrization for the rational points of the unit circle
x2 + y2 = 1,
x = u2 −v2
u2 + v2, y =
2uv
u2 + v2, u, v ∈Q
This gives full characterization of all Pythagoras Triples, that is, the integral solutions to
the equation x2 + y2 = z2.
Another application is the Brauer group. For any arbitrary ﬁeld k, The Brauer group Br(k)
of k is the abelian group whose elements are the equivalence classes of central simple algebras
over k. The Brauer group Br(k) is completely described by group cohomology, in particular
Galois cohomology, as in
Br(k) = H2(G, k×
s )
where ks is a separable closure of k and G = Gal(ks/k) is the Galois group of the exten-
sion.
This is an example of 2-cohomology. Moreover, as the Brauer group plays an important role
in the modern formulation of class ﬁeld theory, study of group cohomology hence is essential
and useful for both local and global ﬁeld theory.
1.3.2
The First General Deﬁnition in any Theorem Prover
With Anca’s work on H0 and H1, one asks whether it is possible to provide a general
deﬁnition of group cohomology for any natural number n in Lean.
On the other hand,
there are concepts about group cohomology in GAP which enables users to compute explicit
cohomology groups by providing speciﬁc inputs n ∈N, group G and G-module M. GAP,
stands for Groups, Algorithms, Programming, is a system for computational discrete algebra
with a programming language and an interactive platform similar to Lean. However, both
Anca’s and GAP’s deﬁnitions of group cohomology requires an explicit value of n ∈N, and
fail to provide a general deﬁnition of n-cohomology for an arbitrary unspeciﬁed n ∈N. As
a result, both of their deﬁnitions cannot be used to state theorems about a general group
cohomology, such as the induced long exact sequence, and give proofs. As to this point in
6

1.4
Special Notes on n ∈N
1
INTRODUCTION
time, there is no well-known general deﬁnition of group cohomology in any theorem provers
and the result from this project may well be the ﬁrst ever deﬁnition of group cohomology
for any natural number n in a theorem prover.
This brings signiﬁcance as once group
cohomology is deﬁned in Lean, it opens Lean up to a large number of possible research
directions due to group cohomology’s great usefulness. One can move on to prove properties
of group cohomology, which further lead to the possibility of formalizing concepts of class
ﬁeld theory in Lean, a rather high level topic in mathematics.
This unprecedented nature brings challenging to this project, as
• Anca’s methodology for deﬁning group cohomology fails as we do not have explicit
expressions for cocycles and coboundaries anymore.
• Lean does not have a very simple way to deal with an arbitrary unspeciﬁed general
number n.
• One has to consider whether methods used in the deﬁnitions and proofs are pro-
grammable in Lean. There was no guarantee that Lean is able to understand a general
notion of group cohomology at the beginning of the project.
• One also needs to look out for the best feasible solution in terms of computationally
convenience for future uses of deﬁnitions and theorems.
Finding such a deﬁnition of group cohomology in Lean hence motivates this project.
1.4
Special Notes on n ∈N
For this report, N will taken to be the set of integers starting from 0. This is consistent with
the set up in Lean.
In addition, we will avoid, anywhere possible, the use of subtraction in any term that repre-
sents a shift in n, such as n −1. This is because subtraction like n −1 will cause complexity
in Lean when n = 0, as 0-1=0 in Lean by convention.
In terms of notation, for well-known concepts, such as diﬀerentials dn, cocycle Zn(G, M),
coboundary Bn(G, M) and cohomology Hn(G, M), the variable n ∈N is placed as super-
script to make sure consistency with most textbooks. This is to avoid confusion with those
placing as subscripts that represent the dual concepts in homology. When there is no con-
fusion, n might be placed as subscript.
7

2
GROUP COHOMOLOGY
2
Group Cohomology
2.1
Cochain
Deﬁnition 2.1. Given a group G, a (left) G-Module M and a natural number n ∈N, an
n-cochain is function from Gn to M.
2.2
A Contraction Map
Deﬁnition 2.2. Given a group G, a natural number n ∈N and another natural number
j < n, we can deﬁne a contraction map Fn,j, from G(n+1) to Gn simply as follow,
Fn,j : G(n+1) →Gn
Fn,j(g0, g1, · · · , gn) = (g0, g1, · · · , gj−1, gjgj+1, gj+2, gj+3, · · · , gn)
where gi ∈G ∀i ∈N.
More explicitly, we can see that Fn,j just multiplies gj and gj+1 together and puts it into the
place where gj initially was. Hence, Fn,j simply reduces the dimension by 1. One can also
give the following equivalent deﬁnition of Fn,j in terms of its explicit computation to each
gi,
Fn,j(g0, g1, · · · , gn) = (a0, a1, · · · , an−1)
where
∀i ≤n −1, ai =





gi
i < j
gjgj+1
i = j
gi+1
i > j
Remark 1: Notice that using the above explicit deﬁnition of Fn,j, the requirement that j < n
can be freed. For j ≥n, Fn,j simply deletes that last entry gn, i.e,
Fn,j(g0, g1, · · · , gn) = (g0, g1, · · · , gn−1)
Hence, Fn,j is actually well deﬁned for all j ∈N. We will use this explicit deﬁnition of Fn,j
unless otherwise stated.
Remark 2: Notice that for the i > j case in the explicit deﬁnition of Fn,j, there is a posi-
tion shift of 1 of gi+1. This is very important to keep in mind as we proceed to the next
subsection.
2.3
An Important Result on Double Sum
We are interested in a special property of using this contraction map Fn,j twice, i.e. we look
at Fn,i ◦Fn+1,j for some pairs of i, j ∈N. Question: What will happen if we exchange the
places of i and j? Intuition might tell us that there should be some relation between the
two results that we obtained by performing this exchange, as they both represent some sort
of dimension shrinking at places gi and gj, and doing at position i or position j ﬁrst should
give the same result. Well, this will true if we do not have any position shift. However, by
Remark 2, we do have one and this leads to the following lemma,
8

2.3
An Important Result on Double Sum
2
GROUP COHOMOLOGY
Lemma 2.3. Given a group G, for any natural number n ∈N, and any two natural numbers
j, k ∈N such that j ≤k, we have
Fn,j ◦Fn+1,k+1 = Fn,k ◦Fn+1,j
Proof. Consider the left-hand side (LHS) ﬁrst. Using the explicit deﬁnition of Fn+1,k+1, we
have
(Fn,j ◦Fn+1,k+1)(g0, g1, · · · , gn+1) = Fn,j(a0, a1, · · · , an)
where
∀i ≤n, ai =









gi
i < k + 1
gk+1gk+2
i = k + 1
gi+1
i > k + 1
According to the deﬁnition again, we then have to compare j with the indexes i of ai. Thus
we have,
(Fn,j ◦Fn+1,k+1)(g0, g1, · · · , gn+1) = (b0, b1, · · · , bn−1)
where
∀i ≤n −1, bi =









ai
i < j
ajaj+1
i = j
ai+1
i > j
For the ﬁrst case i < j, it is simple as i < j =⇒i < k + 1 because j ≤k =⇒j < k + 1.
Hence we always have bi = ai = gi for i < j. For second case i = j, one special possibility is
when aj+1 happens to be the product gk+1gk+2. This happens when j+1 = k+1 =⇒j = k.
In this situation, i = j =⇒bi = ajaj+1 = gkgk+1gk+2. Also, i > j =⇒i+1 > j +1 = k+1,
hence for the third case i > j, we have bi = ai+1 = gi+1+1 = gi+2. In summary, when j = k,
we have the LHS as
(Fn,j ◦Fn+1,k+1)(g0, g1, · · · , gn+1) = (b0, b1, · · · , bn−1)
where
∀i ≤n −1, bi =









gi
i < j
gkgk+1gk+2
i = j
gi+2
i > j
Now we continue to compute LHS when j < k. Notice j < k =⇒j + 1 < k + 1 =⇒bi =
ajaj+1 = gjgj+1 for the second case i = j. For the third case i > j, we have to compare the
indexes i + 1 of ai+1 with k + 1, which separates into 3 possibilities:
• i + 1 < k + 1 =⇒i < k =⇒bi = ai+1 = gi+1
9

2.3
An Important Result on Double Sum
2
GROUP COHOMOLOGY
• i + 1 = k + 1 =⇒i = k =⇒bi = ai+1 = gk+1gk+2
• i + 1 < k + 1 =⇒i < k =⇒bi = ai+1 = gi+1+1 = gi+2
Putting all together yields when j < k,
(Fn,j ◦Fn+1,k+1)(g0, g1, · · · , gn+1) = (b0, b1, · · · , bn−1)
where
∀i ≤n −1, bi =





















gi
i < j
gkgk+1
i = j
gi+1
j < i < k
gk+1gk+2
j < i = k
gi+2
i > k > j
Similarly, we can construct the explicit computation of the right-hand side (RHS), as follow,
(Fn,k ◦Fn+1,j)(g0, g1, · · · , gn+1) = (b0, b1, · · · , bn−1)
where
∀i ≤n −1, bi =









ai
i < k
akaj+1
k = k
ai+1
i > k
and
∀i ≤n, ai =









gi
i < j
gjgj+1
i = j
gi+1
i > j
When j = k, we have
• i < k =⇒i < j =⇒bi = ai = gi
• i = k =⇒i = j, k + 1 = j + 1 > j =⇒bi = ajaj+1 = gjgj+1gj+2 = gjgk+1gk+2
• i > k =⇒i > j =⇒bi = ai+1 = gi+1+1 = gi+2
which means,
(Fn,k ◦Fn+1,j)(g0, g1, · · · , gn+1) = (b0, b1, · · · , bn−1)
10

2.3
An Important Result on Double Sum
2
GROUP COHOMOLOGY
where
∀i ≤n −1, bi =









gi
i < j
gkgk+1gk+2
i = j
gi+2
i > j
This is exactly the same as that of LHS when j = k.
Similarly for j < k,
• For i < k, we compare i with j for the following 3 possibilities:
– i < j < k =⇒bi = ai = gi
– i = j < k =⇒bi = ai = gjgj+1
– j < i < k =⇒bi = ai = gi+1
• i = k =⇒i > j, =⇒bi = ajaj+1 = gk+1gk+2
• i > k =⇒i > j =⇒bi = ai+1 = gi+1+1 = gi+2
This is exactly
(Fn,k ◦Fn+1,j)(g0, g1, · · · , gn+1) = (b0, b1, · · · , bn−1)
where
∀i ≤n −1, bi =





















gi
i < j
gkgk+1
i = j
gi+1
j < i < k
gk+1gk+2
j < i = k
gi+2
i > k > j
and it is identical to that of LHS. This completes the proof.
One may argue that just by intuition that the lemma follows directly from that “The result
obtained by contraction at j-th position and then contracts again at k-th position is the
same as contracting at (k + 1)-th position and then j-th position, where the +1 is just the
result of the position shift of the given contraction.” Surely, there are simpler convincing
proofs for a well-trained mathematician, but this proof shows, as an example, how detailed
and concrete we have to go in order to make it work in Lean. That is, we have to provide an
explicit deﬁnition and use this deﬁnition to prove the lemma by considering all the possible
cases.
Following this lemma, we arrive at the important result about double sum stated as fol-
low,
Lemma 2.4. Given a group G, for any natural number n ∈N, and for any natural number
m ∈N we have
11

2.3
An Important Result on Double Sum
2
GROUP COHOMOLOGY
m+1
X
i=0
m
X
j=0
(−1)i+jFn,j ◦Fn+1,i = 0
where 0 here is the zero map.
Proof. Here is an easy proof using induction on m. Fixing any n ∈N, we have base case
m = 0 as
(−1)0+0Fn,0 ◦Fn+1,0 + (−1)0+1Fn,0 ◦Fn+1,1 = 0
since Fn,0 ◦Fn+1,0 = Fn,0 ◦Fn+1,1 which is an immediate application of Lemma 2.3 setting
j = 0, k = 0.
Assume that the lemma holds for m = k for some k ∈N, i.e.
k+1
X
i=0
k
X
j=0
(−1)i+jFn,j ◦Fn+1,i = 0
we have for m = k + 1,
k+1+1
X
i=0
k+1
X
j=0
(−1)i+jFn,j ◦Fn+1,i =
k+1
X
i=0
k
X
j=0
(−1)i+jFn,j ◦Fn+1,i
+
k
X
j=0
(−1)k+2+jFn,j ◦Fn+1,k+2
+
k
X
i=0
(−1)k+1+iFn,k+1 ◦Fn+1,i
+ (−1)k+1+k+1Fn,k+1 ◦Fn+1,k+1 + (−1)k+1+k+2Fn,k+1 ◦Fn+1,k+2
Notice that the ﬁrst term is the double sum that is 0 by the induction hypothesis. The
second term is obtained by setting i = k +2, the third term is obtained by setting j = k +1,
and adding the last two terms gives everything we need for the new double sum in the case
of m = k + 1.
For the last two terms, the sum is 0 because Fn,k+1 ◦Fn+1,k+1 = Fn,k+1 ◦Fn+1,k+2 by applying
Lemma 2.3, and of course −12k+2 = 1 and −12k+3 = −1.
We are remained to prove that
k
X
j=0
(−1)k+2+jFn,j ◦Fn+1,k+2 +
k
X
i=0
(−1)k+1+iFn,k+1 ◦Fn+1,i = 0
12

2.3
An Important Result on Double Sum
2
GROUP COHOMOLOGY
By simply changing variables we can combine the two sums as
k
X
i=0
(−1)k+2+iFn,i ◦Fn+1,k+2 + (−1)k+1+iFn,k+1 ◦Fn+1,i
Note that as we are summing for i from 0 to k, we always have i < k +1, hence we can apply
Lemma 2.3 to obtain Fn,i ◦Fn+1,k+2 = Fn,k+1 ◦Fn+1,i. Therefore, we have
k
X
j=0
(−1)k+2+jFn,j ◦Fn+1,k+2 +
k
X
i=0
(−1)k+1+iFn,k+1 ◦Fn+1,i
=
k
X
i=0
(−1)k+2+iFn,i ◦Fn+1,k+2 + (−1)k+1+iFn,k+1 ◦Fn+1,i
=
k
X
i=0
(−1)k+2+iFn,i ◦Fn+1,k+2 + (−1)k+1+iFn,i ◦Fn+1,k+2
=
k
X
i=0
((−1)k+2+i + (−1)k+1+i)Fn,i ◦Fn+1,k+2 = 0
as (−1)i + (−1)i+1 = 0 ∀i ∈N. We are done.
Remark 3: Notice that in the statement of Lemma 2.3, the numbers j, k are independent of
the number n. This allows us to give the general from of Lemma 2.4 as stated above, where
n and m can be chosen independently. If one is to avoid the case mentioned in Remark 1 of
Section 2.2, one should limit the choice of j, k to j, k < N in Lemma 2.3 and correspondingly
m < n in Lemma 2.4. Actually, we will not be using this general form of Lemma 2.4, but
only the case m = n.
Remark 4: Although the proof above using induction is rather easy to construct and under-
stand, it is, on the contrary, rather complex to achieve in Lean. Firstly, by setting m = n,
the induction step will change n to n + 1, and hence causing much more complexity. Sec-
ondly, there will problems in Lean when dealing with a general number n, which will be
discussed further in Lean sections. Thirdly, the sums, especially double sums, are not quite
well-established in Lean, as some seemingly trivial concepts (changing variables, combining
sums, splitting sums, etc.) cannot be used unless you prove them ﬁrst.
Remark 5: As for any function, surely same inputs yields same outputs, We can also integrate
both Lemmas in this section with a function, giving a result about some double sum of the
function evaluating at certain points. Namely, we can use the deﬁnition of an n-cochain and
obtain the following Lemma.
Lemma 2.5. Given a group G, a G-module M, a natural number n ∈N, an n-cochain
φ : Gn →M, for any natural number m ∈N we have
m+1
X
i=0
m
X
j=0
(−1)i+j(φ ◦Fn,j ◦Fn+1,i) = 0
where 0 here is the zero map.
13

2.4
The Diﬀerential dn
2
GROUP COHOMOLOGY
Proof. Notice that for j, k ∈N, with j ≤k, we have
φ ◦Fn,j ◦Fn+1,k+1 = φ ◦Fn,k ◦Fn+1,j
simply by Lemma 2.3. We can proceed by induction analogue to the proof of Lemma 2.4.
2.4
The Diﬀerential dn
Deﬁnition 2.6. Given a group G, a natural number n ∈N and another natural number
j < n, we can deﬁne another contraction map Fﬁrst, from G(n+1) to Gn the simply deletes
the ﬁrst entry, as follow,
Fﬁrst(g0, g1, · · · , gn) = (g1, g2, · · · , gn)
or equivalently
Fﬁrst(g0, g1, · · · , gn) = (a0, a1, · · · , an−1)
where ∀i ≤n −1, ai = gi+1.
Deﬁnition 2.7. Given a group G, a G-module M, for any natural number n ∈N, we deﬁne
the map dn(G, M) (denoted as dn when G, M are clear from the context) from n-cochain to
(n + 1)-cochain as:
For any n-cochain φ : Gn →M,
(dn ◦φ)(g0, g1, · · · , gn) = g0 · φ(g1, g2, · · · , gn)
+
n−1
X
j=0
(−1)(j+1)φ(g0, g1, · · · , gj−1, gjgj+1, gj+2, gj+3, · · · , gn)
+ (−1)nφ(g0, g1, · · · , gn−1)
where the operation g · m for g ∈G and m ∈M is the scalar multiplication.
In light of the contraction maps Fn,j deﬁned earlier and Fﬁrst above, we can simply this
deﬁnition to
(dn ◦φ)(g0, g1, · · · , gn) = g0 · φ(Fﬁrst(g0, g1, · · · , gn))
+
n−1
X
j=0
(−1)(j+1)φ(Fn,j(g0, g1, · · · , gn))
+ (−1)nφ(Fn,n(g0, g1, · · · , gn))
Notice that last two terms can be further combined due to the fact that our contraction
map Fn,j is well deﬁned for j = n as mentioned in Remark 1 in Section 2.2. Hence, we have
the following deﬁnition of the diﬀerential dn, of which we will normally use unless otherwise
14

2.5
dn+1 ◦dn = 0
2
GROUP COHOMOLOGY
stated.
(dn ◦φ)(g0, g1, · · · , gn) = g0 · φ(Fﬁrst(g0, g1, · · · , gn))
+
n
X
j=0
(−1)(j+1)φ(Fn,j(g0, g1, · · · , gn))
2.5
dn+1 ◦dn = 0
Theorem 2.8. Given a group G, a G-module M, for any natural number n ∈N, any
n-cochain φ : Gn →M, we have
(dn+1 ◦dn) ◦φ = 0
where 0 here is the zero map.
Proof. Using the deﬁnition of dn, we have
((dn+1 ◦dn)) ◦φ)(g0, g1, · · · , gn+1)
= g0 · (dn ◦φ)(Fﬁrst(g0, g1, · · · , gn+1)) +
n+1
X
j=0
(−1)(j+1)(dn ◦φ)(Fn+1,j(g0, g1, · · · , gn))
= g0g1 · φ

Fﬁrst(Fﬁrst(g0, g1, · · · , gn+1))

:= A
+ g0 ·
n
X
i=0
(
(−1)i+1φ(Fn,i(Fﬁrst(g0, g1, · · · , gn+1)))
)
:= B
+
n+1
X
j=1
(
(−1)(j+1)
 
g0 · φ

Fﬁrst(Fn+1,j(g0, g1, · · · , gn+1))
!)
:= C
+ (−1)
 
g0g1 · φ

Fﬁrst(Fn+1,0(g0, g1, · · · , gn+1))
!
:= D
+
n+1
X
j=0
(
(−1)(j+1)
 
n
X
i=0
(−1)(i+1)φ
 Fn,i(Fn+1,j(g0, g1, · · · , gn+1))

!)
:= E
To explain this long equation, we label the 5 terms, obtained after expanding through the
deﬁnition, with A to E as above, so that
((dn+1 ◦dn)) ◦φ)(g0, g1, · · · , gn+1) = A + B + C + D + E
Notice that
• A and B are simply the result of applying deﬁnition to the term
g0 · (dn ◦φ)(Fﬁrst(g0, g1, · · · , gn+1))
15

2.5
dn+1 ◦dn = 0
2
GROUP COHOMOLOGY
• The other term (in the line right above expression A)
n+1
X
j=0
(−1)(j+1)(dn ◦φ)(Fn+1,j(g0, g1, · · · , gn))
will also gives two terms after applying deﬁnition of dn. One of which will be a double
sum, which is indeed E.
• The other term is of course C + D. However, since according to the deﬁnition, we need
to separate into the two expressions given, as the ﬁrst entry of Fn+1,j(g0, g1, · · · , gn)
depends on the value of j. Explicitly,
– If j = 0, the ﬁrst entry of Fn+1,j(g0, g1, · · · , gn) is g0g1, this gives D.
– If j ̸= 0, the ﬁrst entry of Fn+1,j(g0, g1, · · · , gn) is g0, this gives C.
Our goal now is simply to prove A + B + C + D + E = 0. Consider E ﬁrst,
E =
n+1
X
j=0
(
(−1)(j+1)
 
n
X
i=0
(−1)(i+1)φ
 Fn,i(Fn+1,j(g0, g1, · · · , gn+1))

!)
=
n+1
X
j=0
n
X
i=0
(
(−1)(j+1+i+1)φ
 Fn,i(Fn+1,j(g0, g1, · · · , gn+1))

)
=
n+1
X
j=0
n
X
i=0
(
(−1)(j+i)φ
 Fn,i(Fn+1,j(g0, g1, · · · , gn+1))

)
Observe this is exactly the double sum in Lemma 2.5 by setting m = n. Hence, we apply
the Lemma and obtain E = 0.
Consider A and D. Notice that
Fﬁrst(Fﬁrst(g0, g1, · · · , gn+1)) = (g2, g3, · · · , gn+1) = Fﬁrst(Fn+1,0(g0, g1, · · · , gn+1))
One simply deletes the ﬁrst entry and then deletes again the ﬁrst entry of the resulting
sequence. The other composes the ﬁrst two entries and then deletes this product afterwards.
Both process indeed yields the same result. Hence, we have
A = g0g1 · φ

Fﬁrst(Fﬁrst(g0, g1, · · · , gn+1))

= g0g1 · φ

Fﬁrst(Fn+1,j(g0, g1, · · · , gn+1))

= −D
which gives A + D = 0. Hence remain to show that B + C = 0.
Notice that if we have the following statement,
Fn,j(Fﬁrst(g0, g1, · · · , gn+1)) = Fﬁrst(Fn+1,j+1(g0, g1, · · · , gn+1))
16

2.6
dn is a Group Homomorphism
2
GROUP COHOMOLOGY
for 0 ≤j ≤n, then we will have
C =
n+1
X
j=1
(
(−1)(j+1)
 
g0 · φ

Fﬁrst(Fn+1,j(g0, g1, · · · , gn+1))
!)
=
n
X
i=0
(
(−1)(i+1+1)
 
g0 · φ

Fﬁrst(Fn+1,i+1(g0, g1, · · · , gn+1))
!)
= g0 ·
 
n
X
i=1
(
(−1)iφ

Fﬁrst(Fn+1,i+1(g0, g1, · · · , gn+1))
)!
= (−1)g0 ·
n
X
i=0
(
(−1)i+1φ(Fn,i(Fﬁrst(g0, g1, · · · , gn+1)))
)
= −B
=⇒B + C = 0 =⇒A + B + C + D + E = 0
=⇒(dn+1 ◦dn) ◦φ = 0
Hence, we remain to show the statement above, as follow
Fn,j(Fﬁrst(g0, g1, · · · , gn+1)) = Fn,j(g1, g2, · · · , gn+1) = (a0, a1, · · · , an−1)
where
∀i ≤n −1, ai =









gi+1
i < j
gj+1gj+2
i = j
gi+2
i > j
Similarly,
Fﬁrst(Fn+1,j+1(g0, g1, · · · , gn+1)) = (b0, b1, · · · , bn−1)
where
∀i ≤n −1, bi = ai+1
and
∀i ≤n, ai =









gi
i < j + 1
gjgj+1
i = j + 1
gi+1
i > j + 1
=⇒bi =









gi+1
i < j
gj+1gj+2
i = j
gi+2
i > j
Hence the two are same and we are done.
2.6
dn is a Group Homomorphism
It is not too diﬃcult to check that dn as deﬁned before is actually a group homomor-
phism.
Lemma 2.9. The map dn from n-cochain to (n + 1)-cochain is an (additive) group homo-
morphism.
17

2.7
Cocycle
2
GROUP COHOMOLOGY
Proof. We need to show dn ◦0 = 0,
dn ◦0 = g0 · 0 +
n
X
j=0
(−1)(j+1)0 = 0
and for all n-cochains a, b, we have dn ◦(a + b) = dn ◦a + dn ◦b.
(dn ◦(a + b))(g0, g1, · · · , gn)
= g0 · (a + b)(Fﬁrst(g0, g1, · · · , gn)) +
n
X
j=0
(−1)(j+1)(a + b)(Fn,j(g0, g1, · · · , gn))
= g0 · a(Fﬁrst(g0, g1, · · · , gn)) + g0 · b(Fﬁrst(g0, g1, · · · , gn))
+
n
X
j=0
(
(−1)(j+1)(a(Fn,j(g0, g1, · · · , gn)) + b(Fn,j(g0, g1, · · · , gn)))
)
= g0 · a(Fﬁrst(g0, g1, · · · , gn)) + g0 · b(Fﬁrst(g0, g1, · · · , gn))
+
n
X
j=0
(−1)(j+1)a(Fn,j(g0, g1, · · · , gn)) +
n
X
j=0
(−1)(j+1)b(Fn,j(g0, g1, · · · , gn))
=
(
g0 · a(Fﬁrst(g0, g1, · · · , gn)) +
n
X
j=0
(−1)(j+1)a(Fn,j(g0, g1, · · · , gn))
)
+
(
g0 · b(Fﬁrst(g0, g1, · · · , gn)) +
n
X
j=0
(−1)(j+1)b(Fn,j(g0, g1, · · · , gn))
)
= (dn ◦a + dn ◦b)(g0, g1, · · · , gn)
2.7
Cocycle
Since dn(G, M) is a group homomorphism by Lemma 2.9, it is sensible to deﬁne the notion
of kernel to dn.
Deﬁnition 2.10. Given a group G, a G-module M, for any natural number n ∈N, we
deﬁne n-cocycle, denoted as Zn(G, M), as the kernel of the map dn+1. That is,
Zn(G, M) = Ker(dn+1) =
n
φ : Gn+1 →M : dn+1(G, M) ◦φ = 0
o
2.8
Coboundary
Since dn(G, M) is a group homomorphism by Lemma 2.9, it is sensible to deﬁne the notion
of image(range) to dn.
Deﬁnition 2.11. Given a group G, a G-module M, for any natural number n ∈N, we
18

2.9
Cohomology
2
GROUP COHOMOLOGY
deﬁne n-coboundary, denoted as Bn(G, M), as the range of the map dn. That is,
Bn(G, M) = Im(dn) =
n
φ : Gn+1 →M : ∃θ ∈Gn →M such that dn(G, M) ◦θ = φ
o
2.9
Cohomology
Theorem 2.8 actually tells that
∀n ∈N, Im(dn) ⊆Ker(dn+1)
That is,
Bn(G, M) ⊆Zn(G, M)
Hence, we can deﬁne the quotient group Zn(G, M)/Bn(G, M).
Deﬁnition 2.12. Given a group G, a G-module M, for any natural number n ∈N, we
deﬁne n-cohomology, denoted as Hn(G, M), as the quotient of n-cocycle over n-coboundary.
That is,
Hn(G, M) = Zn(G, M)/Bn(G, M)
2.10
Long Exact Sequence of Group Cohomology
In order to properly states the theorem about the long exact sequence of group cohomology,
we need a list of important deﬁnitions regarding a complex ﬁrst.
Deﬁnition 2.13. A complex is a sequence of abelian groups, A0, A1, A2, · · · , connected by
diﬀerentials dn : An →An+1 such that dn+1 ◦dn = 0. It can be written as
A0
A1
A2
· · ·
d0
d1
d2
Notice that we can deﬁne An to be the group of n-cochains and dn to the diﬀerentials
we deﬁned before.
Hence for a group G and a G-module M, we can obtain a cochain
complex.
Deﬁnition 2.14. Given two complexes A and B, a morphism, f : A →B, is a sequence of
homomorphisms f n : An →Bn which commutes with the diﬀerentials dn. That is, it gives
the following commutative diagram,
· · ·
An−1
An
An+1
· · ·
· · ·
Bn−1
Bn
Bn+1
· · ·
dn−2
A
dn−1
A
fn−1
dn
A
fn
dn+1
A
fn+1
dn−2
A
dn−1
B
dn
B
dn+1
B
For a given G-module homomorphism h : M →N where M, N are G-modules, it is not
diﬃcult to deﬁne naturally induced homomorphisms f n that maps an n-cochain of M to an
n-cochain of N for all n ∈N. That is for n ∈N, φ : Gn →M,
(f n ◦φ))(g0, g1, · · · gn−1)) = h(φ(g0, g1, · · · gn−1))
19

2.10
Long Exact Sequence of Group Cohomology
2
GROUP COHOMOLOGY
Deﬁnition 2.15. Given a sequence of groups {Gi}n+2
i=0 and group homomorphisms {fi}n+1
i=0
for n ∈N, written as
G0
G1
G2
· · ·
Gn+2
f0
f1
f2
fn+1
This sequence is exact if for all k ≤n,
Im(fk) = Ker(fk+1)
As a special case of the above deﬁnition of exactness, we have a deﬁnition for a short exact
sequence as
Deﬁnition 2.16. The sequence
0
A
B
C
0
f
g
is a short exact sequence if
• Ker(f) = {0},
• Im(g) = C,
• Im(f) = Ker(g).
Deﬁnition 2.17. Given complexes A, B, C, and morphisms f : A →B and g : B →C, we
say
0
A
B
C
0
f
g
is exact is for all n ∈N, we have the following short exact sequence
0
An
Bn
Cn
0
fn
gn
Theorem 2.18. Given a group G, and G-modules M, N, L. Suppose we have G-module
homomorphisms f : M →N and g : N →L such that we have the following short exact
sequence
0
M
N
L
0
f
g
Then there is an induced long exact sequence of cohomology,
0
H0(G, M)
H0(G, N)
H0(G, L)
H1(G, M)
H1(G, N)
H1(G, L)
H2(G, M)
· · ·
20

2.10
Long Exact Sequence of Group Cohomology
2
GROUP COHOMOLOGY
Proof. Omitted. Not in the scope of this project.
21

3
AN INTRODUCTION TO LEAN THEOREM PROVER
3
An Introduction to Lean Theorem Prover
This report should not be treated as a thorough tutorial for new users of Lean (it surely
is not).
It only provides a quick tutorial to Lean such that the reader will be able to
understand the second part of this report, and the online repository in Lean for this project.
For individuals interested in studying Lean, on should consult online resources, some of
which will be included in the references of this report.
3.1
What is Lean?
One can think Lean just as a programming language, on which you write write codes, func-
tions, and perform computations.
While others like Python, MATLAB, and R provides
tools for explicit calculation, Lean focuses on theorem proving. One can state deﬁnitions,
state theorems and prove those theorems in Lean, using given deﬁnitions, axioms and any
formulated statements that have been already proved in Lean.
Lean creates an interactive platform for users in terms of theorem proving. Everything you
entered in Lean is associated to a certain type. For anything you want to deﬁne in Lean (a
deﬁnition, a theorem, etc.), Lean will perform a type check to ensure fundamental validity
of the given statement. For example, for any equation, the types of both sides must match.
When you want to prove a certain statement, Lean provides a messages summarizing your
current stage including information on any variables you have, any assumptions made, and
the current goal or goals (to prove). As you proceed with your logic and reasoning in the
proof, Lean updates the message at each step, showing either the updated goal, or an error
message indicating that you did something wrong or simply Lean cannot understand with
its given knowledge.
I would prefer to think Lean just as digital mathematics student. As you put more deﬁnitions
and theorems in Lean, it ‘learns’ those concepts. As the knowledge of Lean builds up, it
then can use it to check every line of command as you proof a statement. The diﬀerences
between Lean and a normal human mathematics learner are probably
• ‘Non-triviality’: There is nothing as ‘trivial’ for Lean unless it is exactly the deﬁnition
given in Lean. On the other hands, ‘trivial’ in a human sense can refer to simple proofs
which has many underlying principles involved. Lean would require you (for the most
of time) to explicitly list these principles out in the correct order.
• ‘Dependence’: Lean cannot create something new on its own (at least for now). You
have to give everything it needs to understand a new statement or a new step in a proof.
In the case of stating a deﬁnition of theorem, this means you have to carefully deﬁne
all variables and any assumptions. In terms of a proof, this means that any lemmas or
claims must be proved ﬁrst before they can be used. Of course, you could also ‘teach’
Lean to ﬁnd some answers itself by writing algorithms.
• ‘Explicitness’: Lean cannot understand certain concepts that a human can. Most
of these concepts involves the process of certain ‘interpretation’. For example, we all
understand what is meant by 1, 2, 3, · · · , n, but it you type this to Lean, it will not be
able to tell what · · · means. Due to this fact, any deﬁnitions with any presence of · · ·
will face diﬃculties if one tries to put it in Lean.
• ‘Type-speciﬁcity’: Lean categorizes everything explicitly while human mixes nota-
tions sometimes. For example, 2 to a human eye is a number, one rarely distinguishes
between 2 ∈N and 2 ∈R, but to Lean, there is a huge diﬀerence as N and R are deﬁned
22

3.2
Conventions in Lean
3
AN INTRODUCTION TO LEAN THEOREM PROVER
very diﬀerently. As such, one has to be very careful with anything you deﬁne in Lean,
in the sense that you have to be clear which type it should fall into.
• There are many other notable properties of Lean. The following ones are listed for your
interests, but will not be discussed in much details as they will not be highly relevant
to this report.
– One cannot use any means of proofs that is not programmable in Lean. For example,
graphical method is unlikely to work as there is no graphical interface in Lean yet.
– Lean does not make mistakes or confusions between concepts while human surely
will.
– Lean also do not have any memory issue. Everything it has ‘learned’ is present
somewhere and you can always use it given that you state it correctly and that you
are in correct circumstances to use.
– And many more...
Note that we gave ‘names’ to the ﬁrst four properties of Lean above. One should keep these
features of Lean in mind as you proceed to the next section where we start to deﬁne notions
and construct proofs in Lean. These four names will extensively appear in the next section
as we proceed with the discussion, because indeed the way we have chosen highly depends
on these properties.
Due to these diﬀerences, continuing this project of group cohomology in Lean, is somewhat
similar, and at the same time very diﬀerent, to teaching a mathematics student group coho-
mology. One has to be very explicit in giving statements (due to ‘Explicitness’), and very
careful and logically concise when constructing proofs(due to ‘Type-Speciﬁcity’). You
may imagine that you cannot jump any steps in a proof(due to ‘Non-triviality’).
3.2
Conventions in Lean
3.2.1
Basic Set Up
A general deﬁnition in Lean takes the form of:
def name (variables: Type)[properties of variables](h: assumptions): Type
of defined term := explicit definition
All the terms are self-explanatory. One note is that for a deﬁnition, it is acceptable to just
give the type without an explicit expression.
A general lemma, theorem or example takes the similar form as that of deﬁnition,
theorem/lemma/example name (variables: Type)[properties of variables](h:
assumptions): Statement := Proof
A proof must be provided for a lemma, theorem or example. However, one may replace it
with sorry to ﬁll in later.
One important note on a general deﬁnition/theorem/lemma/example, regarding on the in-
puts, is that
• For variables closed in (), it has to be provided as inputs.
23

3.2
Conventions in Lean
3
AN INTRODUCTION TO LEAN THEOREM PROVER
• For variables closed in {}, it means this variable can be guessed by Lean from other
inputs and must not be included in the inputs.
A structure is a special kind of deﬁnition that takes more than one items to deﬁne a notion.
Such item could be an expression, or a proof of certain property.
Similar to that of a
deﬁnition, you have to provide variables and properties of variables needed.
A namespace creates a workspace where you can deﬁne some variables. After doing so, they
do not have to appear in any following deﬁnition/lemma/theorem/example’s statement,
within the same namespace, again.
In addition, the name of the deﬁnition/lemma/the-
orem/example can be shortened since when quoted anywhere, is named as ‵the name of
the namespace′. ‵the name of the theorem′. One can close a namespace by end + ‵the
name of the namespace′.
Similar to other programming languages, one can import other Lean ﬁles to the one you are
working one by import ‵name of the file′, normally at the beginning of your ﬁle. Once
imported, you can use all the deﬁnitions/theorems/lemmas in the ﬁle, and only imported
ones can be used. It is also important that ﬁles cannot cross import. If A imports B then
B cannot import A.
A highly relevant notion to this report is the set finset, fin(n) in Lean which is the set of
ﬁrst n elements of natural numbers starting from 0 inclusively. By convention, if one makes
a subtraction that results in less than 0, this will be set to 0. Hence, it is important to avoid
using subtraction when using fin(n), as any subtraction can cause unwanted results by the
above convention.
By deﬁnition, the inequality in Lean means the negation of equality. That is, that equality
implies false.
3.2.2
Functions
To deﬁne a function, one uses λ in Lean. λ k, k^2 means the function that sends k to k2.
Generality, any expression involving k can be used, as well as another function. Note that
there is also Π for deﬁning functions, but we will not be using it.
A piece-wise function can be deﬁned using, if A then B else C, where A is the condition
under this if, B is the expression, and C is the expression of other cases apart from condition
A.
C can be incorporated with again an if-then-else set up.
The short form of this is
ite(A)(B)(C).
Diﬀerent to the usual mathematical set up, where a function takes all its inputs at once,
functions in Lean can take arguments successively. For example, it is possible to have a
function as f: A →B →C where A, B, C are types. After inserting an element of type
a ∈A, one gets f a as a function B →C. One can easily transfer between a mathematical
multi-variable function to a function in this successive form.
Variables/inputs to a function, or the output of a function can have multiple entries where
each entries can be expressions or a proof of certain property. For example, an element,
i ∈fin(n), has two entries. The ﬁrst is its value, which can be extracted by i.1 or i.val.
The second is a proof such that this element is indeed in this set. That is, it is a proof that
i.val < n.
24

3.3
Tactics in Lean
3
AN INTRODUCTION TO LEAN THEOREM PROVER
3.2.3
Bundled Compared to Un-bundled
A bundled ﬁle refers to a set of notions, including relevant deﬁnitions, theorems, lemmas, etc.
grouped under the same namespace. On the contrary, un-bundled refers to any scattered
ones. It is important for notions to be bundled for more applicable and convenient uses. First
of all, any properties, theorems and lemmas of a given namespace can be easily cited for use.
For example, with a bundled ﬁle for an additive group, say, once you deﬁne something to
be an additive group, you can easily access the properties of groups proved in the bundle.
In addition, you will automatically be granted with all the instance in the bundle. On
the contrary, there is limited applicability when you only have a un-bundled statement like
is_group to check whether it is a group. On the other hand, as types of variables are of
signiﬁcant importance in Lean, bundled ﬁles ensure proper applicability of statements by a
much better structure on variables.
You will see many occasions of re-bundling in this report as many concepts required for this
project were un-bundled in the Lean’s math library.
3.3
Tactics in Lean
There are mainly two ways to provide a proof in Lean. The one we will generally use in
this project is the tactic mode proof. One can enter the tactic mode by begin and ends
simply by end.
Once entered, you will be able to use a list of powerful tactics for you
to solve your goal. From the very beginning of the proof, and as you move each step by
commanding a tactic, Lean provides you with all information about the current state of the
proof, including all the variables, assumptions and the current goals. Once this message
displays goals accomplished, your proof is complete.
Here is a list of tactics highly relevant to this report. Some are clear by demonstrating
the changes made to the goal before and after applying the tactic, as shown below in the
table.
Tactic Name
Brief description
Goal before
Goal after
funext
adds an input to both side
f = g
f x = g x
rw
replaces x using equation x = a
x > 0
a > 0
rw <-
replaces x using equation a = x
x > 0
a > 0
norm_num
performs simple arithmetic calculations
x = 1 + 1
x = 2
intro
introduces an assumption
P →Q
Q
Others are explained in words as follow,
• unfold: Expands a deﬁnition as it is given in Lean.
• simp only: Simpliﬁes the expression using the given set of theorems.
• dsimp: Simpliﬁes the expression using deﬁnitions and basic conventions. For example,
⟨a, _⟩.1 = 0 will be simpliﬁes to a = 0 as by convention .1 takes the ﬁrst entry.
• apply: Applies a theorem to change the goal.
• convert: Converts the goal to a given form.
• rwa: Rewrites using the assumptions.
25

3.3
Tactics in Lean
3
AN INTRODUCTION TO LEAN THEOREM PROVER
• exact: Claims that the goal is exactly the result of applying some theorem. This tactic
can only be used for the last step in a proof.
• show: Claims that the goal is equivalent to a given form.
• split: Splits the goal into all separate parts (creating multiple goals) and considers
each part individually.
• cases: Considers all possible cases and tackles each case separately. In particular, one
can uses cases for an assumption of the form ∃a, f(a) to eliminate ∃.
• if_pos: For an ite (A)(B)(C) situation, it checks that (A) is satisﬁes and change the
goal to (B).
• if_neg: For an ite (A)(B)(C) situation, it checks that (A) is false and change the
goal to (c).
• have: Makes an intermediate hypothesis, of which you have to provides a proof.
• exfalso: Changes the goal to false.
• refl: Solves the goal by reﬂectivity.
• linarith: Solves a goal of false by linear arithmetic on hypotheses.
This is not the full list of tactics available in Lean. It is also notable that some tactics can
also be applied to hypothesis by . . . at h. For example, rw T at h means rewriting the
hypothesis h using theorem T.
26

4
GROUP COHOMOLOGY IN LEAN
4
Group Cohomology in Lean
The Lean repository for this entire project is available online at https://github.com/
Shenyang1995/M4R. You may wish to refer the these codes as you proceed in this section,
as we will not provide a copy of all the codes here.
The structure of this section is designed to be similar to that of Section 2 due to the corre-
spondence between content. It is suggested to familiarize yourself with deﬁnitions and proofs
in Section 2.
4.1
Cochain
According to our deﬁnition of n-cochain, it is just a map from Gn →M. However, this
does not help us in giving a deﬁnition in Lean. This is as mentioned, a problem in Lean
with the general number n ∈N. Of course, for n = 1, n = 2 etc, one can easily states the
deﬁnitions explicitly as f : G →M or f : G × G →M. It is not possible to just write
f : G × G × · · · × G(n times) →M in Lean as it will not understand · · · . Hence, we need to
turn to alternatives of the deﬁnition of a n-cochain, due to ‘Explicitness’ of Lean.
Deﬁne Xn ⊂N to be the set of ﬁrst n elements of N. For example, X5 = {0, 1, 2, 3, 4}.
One possibility is to consider (g0, g1, · · · , gn−1) ∈Gn as a map f from Xn to G such that
f(i) = gi for all i ∈Xn. As such, for each n ∈N, we can explicitly deﬁne the set Xn,
and in consequence deﬁne the map f from Xn to G and n-cochain. It is also a standard
mathematics result such that the group of all such fs is isomorphic to G|Xn| = Gn.
This set, Xn, is already deﬁned in Lean as fin(n), which is indeed the set of ﬁrst n elements
of N. We have the deﬁnition of an n-cochain as follow,
def cochain(n: N)(G : Type∗)[Group G] (M : Type∗)[add_comm_group
M][G_module G M]:= (fin n →G) →M
4.2
The Contraction map Fn,j
4.2.1
Deﬁnition
Due to ‘Explicitness’ of Lean, one directly sees that the explicit deﬁnition of this contrac-
tion map Fn,j we gave works better in Lean than the other deﬁnition which involves the use
of ‘· · · ’ that requires interpretation.
Notice that it is deﬁned as a piece-wise function, which is achievable in Lean as follow,
def F{n: N}(j: N){G: Type∗}[Group G] (g: fin(n+1) →G) :(fin n →G)
:= λ k,
if k.val < j then g ⟨k.val, lt_trans k.2 $ lt_add_one _⟩else
if k.val=j then g ⟨k.val, lt_trans k.2 $ lt_add_one _⟩∗g ⟨k.val+1,
add_lt_add_right k.2 1⟩
else g
⟨k.val+1, add_lt_add_right k.2 1⟩
As mentioned before, each element of fin(n) consists of a value and a proof. As an example,
in the above deﬁnition, for the case k > j, in addition to gk+1, which is the value correspond-
ing to that of the explicit deﬁnition given in Section 2, denoted above as
g ⟨k.val+1,. . .,
we have to also provide a proof that k + 1 < n + 1.
An easy way is to use k ∈fin(n), we have k.2 is exactly the proof that k < n. The
theorem stating that k < n =⇒k + c < n + c for c having the same type as k and n is
27

4.2
The Contraction map Fn,j
4
GROUP COHOMOLOGY IN LEAN
indeed called add_lt_add_right in Lean. This theorem takes 2 inputs in Lean, the ﬁrst one
is the proof that k < n, which in our case if simply k.2. The second one is the input c in the
statement of the theorem which is 1 in this case, hence giving the above Lean code.
Remark: Note that the name of the theorem is chosen such that it relates to the content of
the theorem for easy uses. add_lt_add_right stands for additive inequality added to the
right. Also, the requirement that c has the same type as k and n is important due to ‘Type-
Speciﬁcity’. For example, if k, n ∈N and c ∈R, then unfortunately add_lt_add_right
cannot be applied!
4.2.2
Lemma 2.3
Following the deﬁnition, one immediately thinks of stating and proving Lemma 2.3. We ﬁrst
have to be careful with the inputs to function the F we deﬁned in Lean. Notice that F takes
two inputs, the number (j: N) followed by the map (g: fin(n+1) →G). Notice that
n: N and G: type∗are not required and must not be included as they are deﬁned using {}
instead of (). As such, a standard use should be something like F j g.
Also, the map F outputs a map (fin n →G) which can be again used for F as the new
g-input. However, we would see the occurrence of n −1 in that case as the output will be
a map (fin (n-1) →G). As discussed before, we should avoid the use of n −1 and we
should then change the initial input g to F to (g: fin(n+2) →G), yielding the statement
as follow,
theorem degenerate{n:N}{j:N}{k:N}{G : Type∗}[group G](h:j≤k)(g:fin
(n+2)→G):
F j (F (k+1) g) = F k (F j g):= sorry
Remark: Right after := is where we start our proof to replace sorry.
In Section 2 we provided a detailed proof that is concrete enough to allow implementation
in Lean. Now you can see the reasons, namely ‘Explicitness’ and ‘Non-triviality’, for
giving a concrete proof of 2.3 even it can somehow be ‘trivial’. For each
t ∈fin(n), we
simply consider all possibilities of t comparing with j and k to conclude in each case, both
sides of the equation coincides. A general structure of the proof in Lean in presented below.
(We will not go into details as the principles are exactly as that in Section 2. Some comments
in the Lean code should be self-explanatory.)
theorem degenerate{n:N}{j:N}{k:N}{G : Type∗}[group G](h:j≤k)(g:fin
(n+2)→G):
F j (F (k+1) g) = F k (F j g):=
begin
unfold F,
-- apply definition of F
funext t,
-- introduce t
cases t with t ht,
-- argue with cases of t
--some omitted lines of code
by_cases h1 : t < j,
-- comparing with j
--some omitted lines of code
by_cases h2:t=j,
--some omitted lines of code
by_cases h3 : t < k,
-- comparing with k
--some omitted lines of code
by_cases h4 : t = k,
--some omitted lines of code
28

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
end
Remark: One can practice the similar argument as before to ﬁnd out what inputs we should
present for the use of theorem degenerate, and also what should not be included.
By
distinguishing between {, and (, we have the only inputs in order is an assumption (h:j≤
k) and a function (g:fin (n+2)→G). Well, for theorems and lemmas, Lean will not be
too strict about inputs. One may just try to rewrite using this theorem by giving no inputs
and Lean will make a guess or ask you to provide proofs for the hypothesis afterwards.
4.3
The Result on Double Sum
As one can see from the proof of Theorem 2.8, the result on double sum that we need is
actually a special case of Lemma 2.5 when m = n. As one may already see it really takes
some eﬀort to contract statements and proofs in Lean, we will just focus on the required
results. That is, we will only prove the following statement in Lean, without proving the
more general case:
Given a group G, a G-module M, a natural number n ∈N, an n-cochain φ : Gn →M, we
have
n+1
X
i=0
n
X
j=0
(−1)i+j(φ ◦Fn,j ◦Fn+1,i) = 0
In Lean, this states as
theorem double_sum_zero1 (n′:N)(G : Type∗)[group G](g:fin (n′+3)→G)(M :
Type∗) [add_comm_group M] [G_module G M](v:cochain (n′+1) G M):
(range (n′+3)).sum(λ i, (range (n′+2)).sum(λ j, (F2 g v (i,j)))) =0:= sorry
Remark 1:
This is our ﬁnal result to prove in this section. Note we specially place n′+1 = n
to ensure our expression in the theorem will be of the exact form that we will use. You will
see this again in the proof of dn+1 ◦dn = 0.
Remark 2:
It is also worth nothing how to express a sum in Lean using finset. As an
example from above, it takes the form (range n).sum(λ i, f i) to mean Pn
i=0 f(i). Note
f(i) can be replaced by another sum to create a double sum.
Of course, there will many diﬀerent approaches. For example, you can even think of proving
the more general lemma and then apply to m = n case. We assume this is not the best
option. Here are some other possible methods one may naturally think of.
• Method 1: One may suggest we formalize the proofs of Lemma 2.4 and 2.5 in the case
of m = n. However, we have discussed the limitations of this approach in Section 2.3.
During the inductive step, we have to show for k ∈N,
k+1
X
i=0
k
X
j=0
(−1)i+j(φ ◦Fk,j ◦Fk+1,i) = 0 =⇒
k+2
X
i=0
k+1
X
j=0
(−1)i+j(φ ◦Fk+1,j ◦Fk+2,i) = 0
Notice that the indexes of F changes from k to k +1, and k +1 to k +2. This will cause
trouble when we try to use the inductive hypothesis in Lean, as Lean will look out for
the exact appearance of the expression in inductive hypothesis, and will fail due to this
29

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
index change. As a result, we need to provide much more claims and lemmas for this
to work. This then does not seem to be the best option.
• Method 2: When one tries to prove this by hand, it is quite straight forward as we
can just explicitly write out all the terms in the sum. By trying small examples of n,
one can easily see that we can pair up all the terms in a way such that for each pair,
we can apply Lemma 2.3 and the sum of each pair will be 0 due to the indices of −1.
For a general n, we can simply draw a graph or a table to discuss that the sum can be
partitioned into unions of such disjoint pairs. However, from this argument itself, one
can foreseen diﬃculties of employing the method in Lean due to ‘Explicitness’ and
Lean’s lack of graphical interface. One has to think of an explicit way of describing this
pairing, which is indeed the involution we are going to discuss.
Actually, due to ‘Dependence’, it would be much better to turn to any method based on
some proved lemma in Lean. Unfortunately, the library in Lean for double sum is not so
well established in the sense that only limited number of lemmas about double sums can be
directly used. If one has to formalize all the theorems we need, it will be very troublesome
and time-consuming. For example, we used some fundamental properties of a double sum,
like exchanging variables, combining two sums, partitioning a sum etc. These are trivial to
a well-educated mathematician, but requires proving in Lean due to ‘Non-triviality’. As
a result, we proceed by trying to convert the double sum to a single sum, and then using a
proved lemma in Lean using an involution.
4.3.1
Conversion to a Single Sum
This is achieve by the following statement,
Lemma 4.1. For any sets Si and Sj, and an expression T(i, j) formulated in terms of i ∈Si
and j ∈Sj, we have
X
i∈Si
X
j∈Sj
T(i, j) =
X
(i,j)∈Si×Sj
T(i, j)
This is stated in Lean as follow,
lemma sum_product {α : Type u} {β : Type v} {γ : Type w}{s : finset γ} {t :
finset α} {f : γ×α →β} :
(s.product t).sum f = s.sum (λx, t.sum $ λy, f (x, y)) := . . .
-- some ommited proof
We will emit the proof since it is trivial to a human eye and also already proved in Lean for
the case we need. The lemma in Lean is originally stated in a multiplicative group setting,
but analogy to additive group can and will be used.
In our case, Si = Xn+2 = fin (n+2) , Sj = Xn+1 = fin (n+1) and T(i, j) = (−1)i+j(φ◦
Fn,j ◦Fn+1,i) is our summand.
After conversion, we need to prove that,
X
(i,j)∈Xn+2×Xn+1
(−1)i+j(φ ◦Fn,j ◦Fn+1,i) = 0
30

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
Before moving into involution, we note that at this point in time, well, Lean is still not clear
enough in the sense that when we command it to apply something that have we already
proved, it looks out for the exact appearance of the expressions appeared. Even with a small
diﬀerence in the expression, Lean might just fail to apply what we want. One may note that
there is some slight diﬀerence between the summand in the sum above, and the expression
in the theorem degenerate. As such, we would better sort the −1 and φ in and make some
adjustment to make it look exactly like the summand.
4.3.2
Summand in the Double Sum
First of all, there is an important change we have to make due to this conversion. Previously,
we use F k (F j g) for Fn,k ◦Fn+1,j in Lean, which is deﬁned by {j:N} and {k:N} from
(h:j≤k). After the conversion, the type of input changes! The input will be some sort
of the form (j, k) ∈N × N. It is vital due to ‘Type-Speciﬁcity’, we have to give a new
formulation of Fn,k ◦Fn+1,j. As our primary goal is to make it exactly same as the summand,
we also add in the corresponding −1 and φ.
We have the summand as
def F2{n:N}{G : Type∗}[group G](g:fin (n+2)→G){M : Type∗} [add_comm_group
M] [G_module G M](v:cochain n G M): N × N →M:=
λ j, (-1:Z)^(j.1+j.2)· v (F (j.2) (F (j.1) g))
Remark 1: Here j ∈N×N , j.1 simply refers to the ﬁrst element and j.2 the second. Also,
it is important to give the type of (-1:Z) in this deﬁnition, due to ‘Type-Speciﬁcity’,
otherwise it will fail to compile. It is okay to specify the type in this way. The dot refers to
the scalar multiplication.
Remark 2: More importantly, note the inputs needed are (g:fin (n+2)→G) and (v:cochain
n G M), so a standard formulation is F2 g v (j, k), where (j, k) ∈N × N. This expression
gives an element of M.
4.3.3
Rephrasing Lemma 2.3
Now we will convert theorem degenerate properly to ensure smooth future use. This will
be an excellent example to showcase how detailed you need to go in order to complete a
proof in Lean even with a tiny change. We will present working and logical thinking in each
step.
Firstly, it will not be diﬃcult to state the new lemma using the new deﬁnition, as follow,
theorem F2_degenerate {n:N}{j:N}{k:N}(h:j≤k){G : Type∗}[group G](g:fin
(n+2)→G){M : Type∗} [add_comm_group M] [G_module G M](v:cochain n G M):
F2 g v (k+1, j)+F2 g v (j, k)=0:= sorry
• Step 1: First of all, we try to expand the deﬁnition of F2 through the tactic unfold.
This usually comes as the ﬁrst step in a proof. Unfolding often gives us rather messy
equation because of how Lean stores the deﬁnitions, so it is also common to simplify the
expression by using the some tactics. Normally dsimp, or if it is just some numerical
computation, norm_num works as well. In this case, we used norm_num and at this point
the goal appears to be the following,
After commanding (in order): unfold F2, norm_num,
31

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
⊢(-1) ^ (j + k) · v (F k (F j g)) + (-1) ^ (j + (k + 1)) · v (F j (F
(k + 1) g)) = 0
• Step 2: We see appearances of F k (F j g) and F j (F (k + 1) g) that are identical
to those of theorem degenerate. This is a great sign as it tells us we can apply the
proved statement in this proof. We can use rw to replace the left-hand side of theorem
degenerate the right-hand side, which will gives us
After commanding (in order): rw degenerate,
2 goals
⊢(-1) ^ (j + k) · v (F k (F j g)) + (-1) ^ (j + (k + 1)) · v (F k (F j
g)) = 0
⊢j ≤k
Remark: The second goal arises because in applying theorem degenerate, one needs
an assumption that j ≤k. It is okay to provide a proof afterwards. Note that in
this case this is just the assumption h we have, so if we put the command as rw
degenerate h,, this goal will not appear. However, sometimes the assumptions will
not be so clear, and such a way will give us a better structured proof. You will see this
in the section of involution. This feature does not contradicts to the ‘Dependence’ of
Lean as nonetheless you have to prove those assumptions to use the stated theorem.
• Step 3:
Note now we have a common term F k (F j g), and the next step will be to
combine them. This is NOT automatic! There is a underlying theorem we need, which
is in Lean stated as
theorem add_smul(α : Type u) (β : Type v) [semiring α]
[add_comm_monoid β] [semimodule α β] (r s : α) (x: β) : (r + s) ·
x = r · x + s · x
Due to ‘Type-Speciﬁcity’, in order to apply this theorem, one has to make sure the
inputs r, s, x has certain types with certain properties. This is why we mentioned earlier
that the type of (−1) is very important. Note that we actually have the expression on
the RHS and we want the LHS, so the tactic is rw <-, as follow,
After commanding (in order): rw <-add_smul,
2 goals
⊢((-1) ^ (j + k) + (-1) ^ (j + (k + 1))) · v (F k (F j g)) = 0
⊢j ≤k
• Step 4:
Notice (j + (k + 1)), we want to remove the bracket of (k + 1), this is
again of course trivial but actually based on a theorem which has some requirements of
inputs, as associative is not always true. It is called add_assoc in Lean with statement
of the form, . . ... :a+b+c=a+(b+c). So we need again rw <-,
After commanding (in order): rw <-add_assoc,
2 goals
⊢((-1) ^ (j + k) + (-1) ^ (j + k + 1)) · v (F k (F j g)) = 0
⊢j ≤k
• Step 5:
We can now ﬁnish by arguing any the sum of any two consecutive integer
powers of −1 is zero. However, this statement itself requires proving in Lean due to
32

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
‘Non-triviality’. Noting that v (F k (F j g)) is an element of M, we state the
following lemma, together with its proof and explanation included as comments in the
code.
theorem neg_one_power(n:N )(G : Type∗) [group G] (M : Type∗)
[add_comm_group M] [G_module G M]
: ∀m : M, ((-1:Z)^n
+ (-1:Z)^(n+1)) · m = 0 :=
begin
intro m,
-- bring m in to eliminate ∀m : M
induction n with h hd,
-- Induction on n
norm_num,
-- Case 0: just by evaluation n=0
rw nat.succ_eq_add_one,
-- Inductive case
rw pow_add (-1:Z ) h 1,
-- Use a^(m + n) = a^m ∗a^n
rw pow_add (-1:Z ) h (1+1),
-- Use a^(m + n) = a^m ∗a^n again
norm_num,
-- Evaluate to cancel out.
end
Remark:
One may ask why did we add m inside. This is just for simplicity as the
proof with or without this m does not make much diﬀerence. We can directly apply
this theorem to accomplish the goal.
• Step 6:
Use above proved theorem (you need to be careful with the inputs) and the
assumption (h:j≤k) to complete the proof.
After commanding (in order): rw rw neg_one_power (j+k) G M, exact h,
goals accomplished
In contrast, previously we concluded this result from Lemma 2.3 by simply arguing for any
function, same inputs give the same outputs, and that (−1)i + (−1)i+1 = 0 ∀i ∈N. This
two-line argument turns out to be in Lean, a 6-step proof which in addition contains an
induction!
This exactly demonstrates that due to this ‘Non-Triviality’, we will not be able to jump
any steps, and for each step, we need to very carefully ensure that our inputs satisﬁes the
requirements of the underlying theorems by ‘Type-Speciﬁcity’. In addition, this 6-step
proof is a result of a small change made to a proved theorem. Hence, we will try to state
any of our statements in a way that favours future uses.
This is though, just an easy example, where as things get more complex, each step will
requires much more complex proofs as compared to a single rewrite of some theorem. You
may now have a better idea of the challenging nature of deﬁning group cohomology in Lean.
We will not be presenting all the steps to this detail, but only elaborate on important concepts
in the following sections.
On the other hand, one sees that as we follow the ﬂow of logic, there will be at some point
that we realise we need something to be proved ﬁrst in order to proceed. From now on, we
will focus on presenting the results, as in we will prove all the required lemma ﬁrst, so that
we do not jump between proofs, though the thinking process does not follow this order.
4.3.4
The Involution
With theorem F2_degenerate in hand, we are well-prepared for involution. We deﬁne an
involution as follow,
33

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
Deﬁnition 4.2. Deﬁne the involution map, denoted as invo, as
invo : N × N →N × N
invo(j, k) =



(k + 1, j)
j ≤k
(k, j −1)
otherwise
Remark: This deﬁnition is deﬁne is a way such that by performing the involution map, the
output and input forms a pair (as described in Method 2 earlier) such that the sum of F2 g v
evaluating at this pair equals to 0 by theorem F2_degenerate.
In Lean, this deﬁnition is simply states as
def invo : N × N →N × N :=
λ jk, if jk.1 ≤jk.2 then ⟨jk.2 + 1, jk.1⟩else ⟨jk.2, jk.1 - 1⟩
We prove some general facts about this involution map ﬁrst. The reason is simply that we
are going to use these in our ﬁnal proof and ‘Dependence’.
Lemma 4.3.
1 : For j ≤k, we have invo(j, k) = (a, b) where ¬a ≤b
2 : For ¬j ≤k, we have invo(j, k) = (a, b) where a ≤b
3 : For ¬j ≤k, we have j −1 + 1 = j
4 : For all (j, k) ∈N × N, invo(invo(j, k)) = (j, k)
Proof.
• By deﬁnition, a = k + 1, b = j. Hence
j ≤k =⇒k + 1 > j =⇒¬j ≤k + 1 =⇒¬a ≤b
• By deﬁnition, a = k, b = j −1. Hence
¬j ≤k =⇒j > k =⇒k ≤j −1 =⇒a ≤b
• This is NOT trivial as 0 −1 = 0 in Lean ! Hence,
¬j ≤k =⇒j > k =⇒j > 0 =⇒j −1 + 1 = j
• We can just argue by cases.
– If j ≤k, we havej ≤k =⇒k + 1 > j =⇒¬k + 1 ≤j, Hence invo(invo(j, k)) =
invo(k + 1, j) = (j, k + 1 −1) = (j, k).
– If ¬j ≤k, we have¬j ≤k =⇒j > k =⇒k ≤j −1, Hence invo(invo(j, k)) =
34

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
invo(k, j −1) = (j −1 + 1, k) = (j, k) by 4.3.3 above.
Remark:
Each one of the implies signs above in the proofs actually corresponds to one
underlying fundamental arithmetic theorem which is proved and has a unique name in Lean.
One just need to look out for the correct names and applied to the proof. We will just
present the result without going into the details as the reasoning in clear from above. The
statements are in the exact order corresponding to that of Lemma 4.3.
lemma invo_ineq1 {jk : N × N}
(h : jk.1 ≤jk.2) :
¬(invo jk).1 ≤(invo jk).2 :=
begin
unfold invo,
rw if_pos h,
exact not_le.2 (nat.lt_succ_of_le h),
end
lemma invo_ineq2 {jk : N × N}
(h : ¬jk.1 ≤jk.2) :
(invo jk).1 ≤(invo jk).2 :=
begin
unfold invo,
rw if_neg h,
rw not_le at h,
exact nat.pred_le_pred h,
end
lemma invo_aux {j k : N} (h : ¬j ≤k) : j - 1 + 1 = j :=
nat.succ_pred_eq_of_pos $ lt_of_le_of_lt (zero_le _) (lt_of_not_ge h)
lemma invo_invo (jk : N × N) : invo (invo jk) = jk :=
begin
unfold invo,
split_ifs,
{ exfalso, linarith},
{ ext, refl, simp},
{ ext, dsimp, exact invo_aux h, refl},
{ exfalso,
rw not_le at h_1,
rw nat.lt_iff_add_one_le at h_1,
rw invo_aux h at h_1,
linarith,}
end
4.3.5
Final Result on the Sum
We are ready to prove the following, Given a group G, a G-module M, a natural number
n ∈N, an n-cochain φ : Gn →M, we have
X
(i,j)∈Xn+2×Xn+1
(−1)i+j(φ ◦Fn,j ◦Fn+1,i) = 0
35

4.3
The Result on Double Sum
4
GROUP COHOMOLOGY IN LEAN
The theorem we are going to use is stated in Lean as
lemma sum_involution{α : Type u} {β : Type v} {s : finset α} {f : α →β}
:
∀(g : Π a ∈s, α)
(h1 : ∀a ha, f a + f (g a ha) = 0)
(h2 : ∀a ha, f a ̸= 0 →g a ha ̸= a)
(h3 : ∀a ha, g a ha ∈s)
(h4 : ∀a ha, g (g a ha) (h3 a ha) = a),
s.prod f = 0 := . . .some omitted proof
Remark: The detailed proof in Lean uses strong induction on the sum and is omitted. One
can see that the 4 assumptions stated actually guarantee a partition of the sum into disjoint
pairs where each pair sums to 0. Hence the original sum is 0, similar to the argument as in
Method 2 before.
Hence, applying this lemma to our case, where g is taken to be the involution map deﬁne
before, yields 4 goals, which are exactly those 4 assumptions. Note from above, the notion
a ha means a ∈N × N while ha is the assumption that a ∈Xn+2 × Xn+1. We can introduce
a ha simply by intros jk hjk, so these will be omitted in the 4 goals stating below,
1 : F2 g v jk +F2 g v (invo jk) = 0
2 : F2 g v jk ̸= 0 →invo jk ̸= jk
3 : invo jk ∈finset.product (range (n′ + 3)) (range (n′ + 2))
4 : invo (invo jk) = jk
Remark:
In goal 3, finset.product (range (n′ + 3)) (range (n′ + 2)) means exactly
Xn′+3 × Xn′+2.
For goal 1, it is exactly applying theorem F2_degenerate after considering the two possible
cases of jk = (j, k), that is j ≤k or ¬j ≤k using the deﬁnition of invo. Lemma 4.3.3 is
used.
For goal 2, one introduces the assumption that F2 g v jk ̸= 0 and invo jk = jk and tries
to derive a contradiction. This is easily done by considering the two cases in the deﬁnition
of invo. Lemma 4.3.1 and 4.3.2 are used.
For goal 3, one has to use the deﬁnition of invo and argues by cases. One important notion
in Lean that is used is that
theorem mem_range : m ∈range n ↔m < n := mem_range
where range n := fin(n).
For goal 4, this is exactly Lemma 4.3.4!
Therefore, we proved all the 4 goals, and one can ﬁnish proving the ﬁnal result on the sum.
The statement in Lean with a general structure of the proof is presented as follow,
theorem double_sum_zero1 (n′:N)(G : Type∗)[group G](g:fin (n′+3)→G)(M :
Type∗) [add_comm_group M] [G_module G M](v:cochain (n′+1) G M):
(range (n′+3)).sum(λ i, (range (n′+2)).sum(λ j, (F2 g v (i,j)))) =0:=
36

4.4
Deﬁnition of dn
4
GROUP COHOMOLOGY IN LEAN
begin
rw <-sum_product,
--This is the conversion
apply sum_involution (λ jk h, invo jk),
--Applying involution
{ intros jk hjk,
--Goal 1
by_cases hin : j ≤k,
--Consider by cases
{ rw add_comm,
convert F2_degenerate hin g v,
--Use theorem F2_degenerate
exact invo_def1 hin},
--some omitted lines of proof
},
{ intros jk hjk _ h,
--Goal 2: introduce all
assumptions
dsimp at h,
by_cases hin : jk.1 ≤jk.2,
--Consider cases
{ apply invo_ineq1 hin,
--Apply Lemma 4.3
rwa h},
--some omitted lines of proof
},
{ intros jk hjk,
--Goal 3
--some omitted lines of proof
cases mem_product.1 hjk with hj hk,
--Consider cases
--some omitted lines of proof
}
{ intros jk hjk,
--Goal 4
dsimp,
exact invo_invo jk,
}
--Exactly Lemma 4.3.4
end
Remark:
When there is more than 1 goal, and knowing that each of the proof would not
be short, using {} to group the lines for proving each goal together, as shown in the above
example, helps to structure the proof much better.
4.4
Deﬁnition of dn
For the deﬁnition of dn, we can deﬁne the Fﬁrst in Lean similar to the way of deﬁning Fn,j,
but much simpler.
def F_first{n:N} {G : Type∗}[group G](g:fin (n+1)→G):fin n→G
:= λ k,
g
⟨k.val+1, add_lt_add_right k.2 1⟩
This leads us to the deﬁnition of dn in Lean, as follow,
def d.to_fun {n:N}{G : Type∗} [group G] {M : Type∗} [add_comm_group M]
[G_module G M]
(ϕ: cochain n G M): (cochain (n+1) G M):= λ(gi: fin (n+1) →G),
gi ⟨0, (by simp)⟩· ϕ (λ i, gi ⟨i.val + 1, add_lt_add_right i.2 1⟩)
+(range (n+1)).sum(λ j,(-1:Z
)^(j+1)· ϕ (F j gi))
Remark 1: Almost every single term in this deﬁnition has a similar form that we have
thoroughly explained before. This deﬁnition is long but should not be diﬃcult to understand
itself. Note that we did not use Fﬁrst actually in the deﬁnition, though the part corresponding
to it has exactly the same expression as that of Fﬁrst. This is chosen because we can then
avoid unfolding Fﬁrst for every time we use this deﬁnition.
Remark 2: You may notice that the name is d.to_fun. This is because ﬁnally we are going
37

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
to give a structural deﬁnition of dn as a group homomorphism. You have seen in Section
2 such that dn is indeed a group homomorphism. The reason for this choice of structural
deﬁnition is explained before in Section 3 under Bundled vs. Un-bundled.
Remark 3: One should be quite familier with how to decide what inputs should we give for
a deﬁnition. For d.to_fun, it is simply one input (ϕ: cochain n G M).
Before proceeding to prove that dn+1◦dn = 0 using this deﬁnition, one thinks about checking
whether this deﬁnition indeed provides exactly what we want. Because it is a rather long
deﬁnition, we do not want to waste time working on a wrong deﬁnition for hours solving an
extremely complex but wrong equation. An idea is to check it with an simple example. We
can choose 1-cocycle to test this deﬁnition, as follow,
example (G : Type∗) [group G] (M : Type∗) [add_comm_group M] [G_module G M]
(ϕ : cochain 1 G M) (hϕ : d.to_fun ϕ = (λ i, 0)) (g h : G) : ϕ (λ _, g ∗
h) = ϕ (λ _, g) + g · ϕ (λ _, h) :=
begin
unfold d.to_fun at hϕ,
--Use the definition before
let glist : fin 2 →G := λ i, if i.val = 0 then g else if i.val = 1 then
h else 1,
--Introduce a 2-cochain
have h2 : (λ (gi : fin (1 + 1) →G),
gi ⟨0, _⟩· ϕ (λ (i : fin 1), gi ⟨i.val + 1, _⟩) +
finset.sum (finset.range (1 + 1)) (λ (j : N), (-1: Z) ^ (j + 1) ·
ϕ (F j gi))) glist = 0,
rw hϕ,
--Rephrase the assumption
--some omitted lines of proof about rewriting h2,
convert h2,
--Use h2 to prove the goal
{
--3 goals to proof
ext,
cases x with x hx,
--argue by cases
cases (nat.sub_eq_zero_of_le hx),
refl,
},
--some omitted lines of proof similar to the one above
end
In the statement, it states that with the hypothesis that d◦φ = 0 where 0 is the 0 map that
sends everything to 0, then φ must satisfy φ(gh) = φ(g)+g ·φ(h). As shown in the structure
of the proof, one uses the deﬁnition we gave and indeed arrives at the desired result, hence
showing that our deﬁnition is most likely to be true.
Remark:
Note that above we have a long rewriting of hϕ. It is sometimes necessary to
just write out the expression yourself, and give it a proof even though it might be a trivial
one-line proof. Lean has the limitation that sometimes it cannot identify certain expressions
and does not know how to and where to apply some tactics when it is not very explicit, and
it will return an error.
4.5
dn+1 ◦dn = 0
Well, to begin with, we always give the statement in Lean ﬁrst. This is not diﬃcult at all,
once we know what the input does d.to_fun take and what type of output it generates. We
have the following,
38

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
theorem d_square_zero{n:N}{G : Type∗} [group G] {M : Type∗} [add_comm_group
M] [G_module G M]
(ϕ: cochain n G M):d.to_fun (d.to_fun ϕ )=λ(gi: fin (n+2) →G), 0:= sorry
Note the RHS simply represents the 0 function of Gn+2 →M.
However, one may expect a very long proof by inspecting the length of deﬁnition and the
complexity of the proof presented in Section 2. Indeed, just to have a taste, after expanding
the deﬁnition of d.to_dun, and some simplifying, we obtain the goal as,
⊢gi ⟨0, _⟩·
sum (range (n + 1)) (λ (x : N), (-1) ^ (x + 1) · ϕ (F x (λ (i :
fin (n + 1)), gi ⟨1 + i.val, _⟩))) +
(sum (range (n + 2))
(λ (x : N),
(-1) ^ (x + 1) ·
(F x gi ⟨0, _⟩· ϕ (λ (i : fin n), F x gi ⟨i.val + 1, _⟩) +
sum (range (n + 1)) (λ (j : N), (-1) ^ (j + 1) · ϕ (F j
(F x gi))))) +
(gi ⟨0, _⟩∗gi ⟨1, _⟩) · ϕ (λ (i : fin n), gi ⟨i.val + 2, _⟩)) =
0
We discuss everything that we need to complete this proof ﬁrst. You may wish to refer back
to the proof of Theorem 2.8 to see where does each of this seemingly trivial statement is
used.
4.5.1
Facts about Double Sums
After we expand through the deﬁnition of d.to_fun, we are deﬁnitely going to get a term
that is a double sum. This is exactly the reason of all the work we have done so far, namely,
the important the result as stated in theorem double_sum_zero1. Unfortunately, we are
not going to get the exact same expression as in the theorem after we expand. There is
going to be some rearranging for us to ﬁnd a match. This rearranging also appears in the
proof of Theorem 2.8 but they are so trivial that we do not need to explicitly point out.
However, due to ‘Non-Triviality’ of Lean, we have to proof any statements we want to
use for rearranging. Luckily, there are many that are already proved in Lean.
Firstly, we need the additive distributive law of a sum.
n−1
X
i=0
(f(i) + g(i)) =
n−1
X
i=0
f(i) +
n−1
X
i=0
g(i)
This is already proved in Lean, stated as
lemma sum_mul_distrib : s.sum (λx, f x + g x) = s.sum f + s.sum g := sorry
Next, we need to be able to take out the ﬁrst term of the sum, that is, when i = 0, and then
changes the variable of the sum accordingly. Mathematically, it states,
n−1
X
i=0
f(i) = f(0) +
n−2
X
i=0
f(i + 1)
39

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
In Lean, it is also formulated and proved as follow,
lemma sum_range_succ′ {β : Type v}[add_comm_monoid β] (f : N →β) :
∀n : N, (range (nat.succ n)).sum f = (range n).sum (f ◦nat.succ) + f
0:= sorry
Similarly, one will think of removing the last term.
n−1
X
i=0
f(i) = f(n) +
n−2
X
i=0
f(i)
and in Lean, the corresponding lemma is,
lemma sum_range_succ {β : Type v}[add_comm_monoid β](f : N →β) (n : N) :
(range (nat.succ n)).sum f = f n ∗(range n).sum f := sorry
Remark 1:
nat.succ(n) is deﬁned as the next natural number after n, and is proved that
nat.succ(n)=n+1. This is how natural numbers are deﬁne in Lean. With an initial number
0 and iteratively uses this nat.succ(n) function. Any natural number n in Lean hence can
be consider to be either 0 or the result of nat.succ(n′)=n for another natural number n′.
This also forms the set up for induction.
Remark 2 Important: Notice there is an occurrence of n −2 in the mathematical term!
The theorem in Lean is formulated to avoid the possible appearance of any n −1. However,
if we stick to n ∈N as our normal set up, we will face problem as one will see when we
apply this to n for the LHS, we will have a set fin (n-1) on the RHS as the range of the
sum. This will be problematic for n = 0. This is exactly why, as you will see in the ﬁnal
proof, that we separate the case of n to either 0 or nat.succ(n′)=n, which indeed gives the
appearance of n′ + 1 = n as you see before in earlier sections.
The next statement will be used in the case n = 0, as there will every explicit calculations
there.
0
X
i=0
f(i) = 0
In Lean,
lemma sum_range_zero (f : N →β) :
(range 0).sum f = 0 := sorry
The last lemma we need concerns the scalar multiplication relating a sum. One can directly
see the use of this in the proof of Theorem 2.8 as we move −1 in and out of the sum.
n−1
X
i=0
λ · f(i) = λ ·
n−1
X
i=0
f(i)
def finset.sum_smul2 {α : Type∗} {R : Type∗} [semiring R] {M : Type∗}
[add_comm_monoid M]
[semimodule R M] (s : finset α) (r : R) (f : α →M) :
finset.sum s (λ (x : α), (r · (f x))) = r · (finset.sum s f) := sorry
Remark Important: Notice carefully the type of
(r : R) where [semiring R]. Due to
40

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
‘Type-Speciﬁcity’ of Lean, this theorem about scalar multiplication only applied to any
λ from a semi-ring. In particular, we can applied this to −1 but not g ∈G! This is very
important, as shortly in the proof we will see that we need an analogue statement about
scalar multiplication as above but for λ = g ∈G where G is just a group. Hence, we need
to produce a new lemma for this. See the subsection on Facts about G-module.
We will not be discussing the proofs of these properties as they are already done in Lean and
are not part of this project. Nevertheless, we need to formally state them as they constitute
important steps in the ﬁnal proof we are going to construct in Lean.
4.5.2
Facts about Fn,j
As one may notice, apart from the double sum, there is still some forms of F x g appearing
in the goal shown earlier. We would require certain properties of Fn,j for us to cancel some
terms out, just like the proof of Theorem 2.8.
As discussed in the section before, we may be interested in taking out the ﬁrst term, giving
some expressions evaluated at value 0. Thus, we can categorize our results to the 0 case of
the general case, giving us the following 4 claims.
Let Fn,j(g0, g1, · · · , gn−1)i be the (i + 1)-th entry of the result for i ∈N and i ≤n −1.
Lemma 4.4. For n > 1,
Fn,0(g0, g1, · · · , gn−1)0 = g0g1
Proof. For n > 1, n −1 > 0 so g1 exists. Then the result follows from the deﬁnition when
j = 0 and i = 0 = j.
In Lean, it is stated as follow,
theorem F_0_0(n′:N){G : Type∗}[group G](g:fin (n′+1+1+1)→G):F 0 g ⟨0,
nat.succ_pos (n′+1)⟩= g⟨0, nat.succ_pos (n′+1+1) ⟩∗g⟨
1,nat.lt_of_sub_eq_succ rfl⟩:=
begin
refl,
end
Remark:
Within the deﬁnition, we also have to provide proofs that an element is in the set
fin (n′+1+1+1). This expression of +1 + 1 + 1 is used instead of just +3 is to favour some
proofs that uses the function nat.succ.
Similarly, we ﬁxed j = 0, and varies i > 0 to get,
Lemma 4.5. For n > 1,i ∈N
Fn,0(g0, g1, · · · , gn−1)i+1 = gi+2
Proof. For n > 1, n −1 > 0 so g1 exists. Then the result follows from the deﬁnition when
j = 0 and i > j. There is indeed an +1 position shift.
41

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
The corresponding lemma in Lean is,
theorem F_0_j{n′:N}{j:fin (n′+1)}{G : Type∗}[group G](g:fin (n′+1+1+1)→
G):F 0 g⟨j.val+1,nat.lt_succ_iff.mpr j.is_lt
⟩=g⟨j.val+2, add_lt_add_right j.is_lt 2⟩:=
begin
refl,
end
Now, ﬁx i = 0, and varies j > 0. We have,
Lemma 4.6. For n > 1, j ∈N,
Fn,j+1(g0, g1, · · · , gn−1)0 = g0
Proof. The result follows from the deﬁnition when j > 0 and i = 0 < j.
In Lean, it is
theorem F_x_0(n′ x:N)(h:x>0){G : Type∗}[group G](g:fin (n′+1+1+1)→G):F x g
⟨0, nat.succ_pos (n′+1)⟩= g⟨0, nat.succ_pos (n′+1+1) ⟩:=
begin
unfold F,
rw if_pos h,
end
Finally, without ﬁxing anything, we have,
Lemma 4.7. For n > 1, j ∈N, i ∈N,
Fn,j(g1, g2, · · · , gn)i = Fn,j+1(g0, g1, · · · , gn−1)i+1
Proof.
LHS = Fn,j(g1, g2, · · · , gn)i =









gi+1
i < j
gj+1gj+2
i = j
gi+2
i > j
RHS = Fn,j+1(g1, g2, · · · , gn)i+1 =









gi+1
i + 1 < j + 1 =⇒i < j
gj+1gj+2
i + 1 = j + 1 =⇒i = j
gi+2
i + 1 > j + 1 =⇒i > j
= LHS
In Lean, it is
theorem F_x_j(n′ x:N){G : Type∗}[group G](g:fin (n′+1+1+1)→G):F x (λ
(j:fin (n′+1+1)), g ⟨j.val+1, nat.lt_succ_iff.mpr j.is_lt,⟩)
= λ (j:fin (n′+1)), F (x+1) g⟨j.1+1, nat.lt_succ_iff.mpr j.is_lt,⟩:=
42

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
begin
unfold F,
funext,
split_ifs,
--Use def of F to give 9 cases
{refl},
{exfalso,linarith},
--In most cases contradiction
{exfalso,linarith},
{exfalso,linarith},
{refl},
{have h5: k.val+1=x+1,
rw h_1,
contradiction,
},
{exfalso,linarith},
{have h5: k.val=x,
exact nat.succ_inj h_3,
contradiction},
{refl},
end
Apart from the last one, the rest are really trivial lemmas. However, we need to state them
correctly, and explicitly as the same as that will appear in the ﬁnal proof. Otherwise, Lean
will fail to identify the instance to apply a speciﬁc lemma, especially when there is a long
expression.
4.5.3
Facts about G-Module
As discussed before, we will need an analogue of linearity of scalar multiplication for a sum
for some λ = g ∈G. This is achievable because we have our function f in the summand
mapping to M, which is a G-module, and on which we have linearity of scalar multiplication
with regards to the G-module.
Here is the analogue statement,
Lemma 4.8. Given a group G, a G-module M, and a map f : N →M, we have for n ∈N,
g ∈G
n−1
X
i=0
g · f(i) = g ·
n−1
X
i=0
f(i)
Proof. Induction on n. Base case is trivial as both side coincides. For the inductive hypoth-
esis, we will use the linearity of scalar multiplication of G in M which states that ∀g ∈G,
∀m, n ∈M,
g · (m + n) = g · m + g · n
Together with lemma sym_range_succ which allows us to take out the last term of the sum.
That is,
k−1+1
X
i=0
g · f(i) =
k−1
X
i=0
g · f(i) + g · f(k) = g ·
k−1
X
i=0
f(i) + g · f(k) = g ·
k−1+1
X
i=0
f(i)
43

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
Correspondingly, in Lean we have
lemma G_module.G_sum_smul {G : Type∗} [group G] {M : Type∗} [add_comm_group
M]
[G_module G M] (n:N )(g : G)(f: N →M):finset.sum
(finset.range (n+1))(λ
(x : N ), g · f x) = g · finset.sum (finset.range(n+1)) f:=
begin
induction n with d hd,
--Induction
norm_num,
rw finset.sum_range_succ,
--First = in math proof
rw hd,
--Second =
rw <-G_module.linear,
--Third =
rw <-finset.sum_range_succ _ (d+1),
--Third =
end
Here is a question, what if we have simultaneously −1 ∈Z and some g ∈G present? Can
we use either of the two lemmas stated about scalar multiplication be used? True, one may
say that we can take out the left most one ﬁrst by the appropriate lemma. However, the
problem goes with whether Lean is able to successfully identify the left most one and to
move out correctly. Even Lean can, there will be problem in the following situation:
• we want to move g out but having for some k ∈N
n−1
X
i=0
(−1)k · g · f(i)
The left-most approach would fail to achieve our goal. Indeed, the two lemmas are not
enough, due to again ‘Type-Speciﬁcity’. We need, in addition, the following lemma to
exchange the places of −1 and g.
Lemma 4.9. Given a group G, a G-module M, and a map f : N →M, we have for n ∈N,
g ∈G, m ∈M,
(−1)n · g · m = g · (−1)n · m
Proof. By induction on n. Base case trivial as both sides equal to 0. For inductive step, we
have
(−1)k+1 · g · m = (−1)(−1)k · g · m = (−1)g · (−1)k · m = g · (−1)k+1 · m
In Lean, it has the following form,
lemma G_module.neg_one_pow_mul_comm {G : Type∗} [group G] {M : Type∗}
[add_comm_group M]
[G_module G M] (n:N
)(g:G)(m:M): (-1:Z )^n · g · m = g · (-1:Z)^n · m:=
begin
induction n with d hd,
norm_num,
rw nat.succ_eq_add_one,
44

4.5
dn+1 ◦dn = 0
4
GROUP COHOMOLOGY IN LEAN
rw pow_add,
norm_num,
exact hd,
end
4.5.4
Proof of the Final Result
We are ﬁnally ready to prove our ﬁnal result. As mentioned before, we will separate to two
cases n = 0 and nat.succ(n′)=n. For the ﬁrst case n = 0, one can explicitly write up all the
expression in the deﬁnition of d.to_fun and using suitable arithmetic tools already proved
in Lean to solve the goal. We will not venture too much into that case.
For the second case, we will make use of all the theorems and lemmas proved before. The
proof below gives the general structure of the proof.
theorem d_square_zero{n:N}{G : Type∗} [group G] {M : Type∗} [add_comm_group
M] [G_module G M]
(ϕ: cochain n G M):d.to_fun (d.to_fun ϕ )=λ(gi: fin (n+2) →G), 0:=
begin
unfold d.to_fun,
-- Apply definition
funext,
dsimp,
norm_num,
cases n with n′,
-- Divides to two cases
{ norm_num,
-- Case n=0
rw sum_range_succ,
-- Use facts on sum
rw sum_range_succ,
rw sum_range_zero,
--some omitted lines of proof for case n=0
},
--
Case n=n′+1,
rw ←double_sum_zero1 n′ G gi _ ϕ,
--
Use result on double sum
unfold F2,
--
Apply def of F2
dsimp,
simp only [smul_add],
rw sum_add_eq_add_sum,
-- This is sum_distributive
rw sum_range_succ′ _ (n′+2),
-- Facts on sum
rw F_0_0,
-- Lemma \ref{F00}
simp only [F_0_j],
-- Lemma \ref{F0j}
rw [zero_add, pow_one, neg_one_smul],
--some omitted lines of proof --arithmetic rewrites
simp only [F_x_0 _ _ (nat.succ_pos _)],
-- Lemma \ref{Fx0}
simp only [(F_x_j n′ _ gi).symm],
-- Lemma \ref{Fxj}
rw sub_eq_add^neg,
convert add_comm _ _,
{
simp only [(pow_add′ _ _ _).symm, nat.succ_eq_add_one],
simp only [(G_module.G_sum_smul _ _ _).symm],
--Lemma \ref{Glinear}
norm_num,
simp only [G_module.neg_one_pow_mul_comm],
--Lemma \ref{Glinear2}
},
{
simp only [(finset.sum_smul2 _ _ _).symm], }
--Facts about sum
--some omitted lines of proof --arithmetic rewrites
end
We have successfully proved one of the most important results for deﬁning group cohomology
45

4.6
dn as a Group Homomorphism
4
GROUP COHOMOLOGY IN LEAN
in Lean. Though this proof is not diﬃcult mathematically speaking, but formalising in Lean
requires a clear mind when dealing with an extremely long string of sums, trying to ﬁgure
out the exact theorems to use, and ﬁlling every logical gap in the entire process. It is a
signiﬁcant work achieved in Lean.
At this point, the next goal will be to deﬁne dn as a group homomorphism, deﬁne kernel
and image(range) for a group homomorphism and hence deﬁne n-cocycle, n-coboundary and
n-cohomology accordingly. In order to progress, we need some basic notions about additive
group homomorphism, additive subgroup, kernel and image. Unfortunately there is no well-
structured documents in Lean for these concepts. Before this project, there is only certain
un-bundled lemmas that could be used for identiﬁcation, for example, def is_subgroup for
checking whether a set is a subgroup. We have discussed the beneﬁts of having bundled
ﬁles on such concepts as compared un-bundled ones, as such we will ﬁrst make some well
formulated bundle for the topics interested.
4.6
dn as a Group Homomorphism
4.6.1
Bundle: Additive Subgroup
In this bundle, we introduce basic deﬁnitions, and prove important theorems about an addi-
tive subgroup. As kernel and image are both subgroups, we construct some special subgroups
for later deﬁnitions of these two in the bundle of additive group homomorphism.
First important notion is the deﬁnition of an additive subgroup, which is deﬁned as a set
and a proof that this set is indeed a subgroup for a given group G. It appears in Lean as a
structure, as follow,
structure add_subgroup (G : Type∗) [add_group G] :=
(carrier : set G)
(is_add_subgroup : is_add_subgroup carrier)
For kernel, we deﬁne a special subgroup of a given group G to be set of one element containing
only 0 ∈G as we are in the additive group setting. One can easily prove that this is a
subgroup. It is called
bot
in Lean,
def bot {G : Type u} [add_group G] : add_subgroup G :=
{ carrier := {x| x=0},
is_add_subgroup := sorry
--proof omitted
For range, we similarly deﬁne a special subgroup of a given group G to be set of all elements
of G. It is called
top
and proved to be a subgroup.
def top {G : Type u} [add_group G] : add_subgroup G :=
{ carrier := {x | true},
is_add_subgroup := sorry --proof omitted
The rest of the bundle consists of basic properties of a subgroup H of G, including 0 ∈H,
g ∈H ⇐⇒−g ∈H, g, h ∈H =⇒g + h ∈H and the fact that H itself is an additive
group. In addition, if G is an additive abelian group, then so is H. The statement and
proofs can be found online and will not be discussed in detail.
One important thing to note is the type of H when it is treated as a group. Certainly it is
not G, and not H either as H has type as additive subgroup. It is noted as H lifted up to
G.
46

4.7
Deﬁnition of Cocycle
4
GROUP COHOMOLOGY IN LEAN
4.6.2
Bundle: Additive Group Homomorphism
This bundle imports the previously ﬁnished bundle add_subgroup.basic. Most of its con-
tent comes from bundled additive monoid homomorphism, but due to ‘Type-Speciﬁcity’
, we have to create this new bundled additive group homomorphism based on previously
deﬁned additive subgroup.
The important results of this bundle are the deﬁnitions of image and co-images of a given
set (group) with respect to a group homomorphism. These are formalized as map and comap
in Lean. Depending on these two deﬁnitions, we can easily deﬁne kernel and range.
def ker (f : add_group_hom G H) :add_subgroup G:= add_group_hom.comap f ⊥
def range (f : add_group_hom G H) :add_subgroup H:= add_group_hom.map f top
The remaining section concerns with quotients which is just re-formalisation of scattered
theorems about quotients in math library to make it a nice bundled ﬁle.
4.6.3
dn as a Group Homomorphism
With bundled additive group homomorphism, we can proceed to deﬁne dn as a group homo-
morphism. It is a structure where we have to provide a function f, a proof that f(0) = 0,
and another proof that f(a + b) = f(a) + f(b) for all a, b in the domain.
It is deﬁned as follow with some new lemmas explained in the comments.
def d : add_group_hom (cochain n G M) (cochain (n + 1) G M) :=
{ to_fun := d.to_fun,
--function is as before
map_zero′ := begin
unfold d.to_fun,
funext,
have h1: (0:cochain n G M)=0, refl,
have h2: (0:cochain (n+1) G M)=0, refl,
simp only [zero_cochain n G M h1],
--zero_cochain says 0 ∈cochain maps everything to 0
rw zero_cochain (n+1) G M h2,
norm_num,
rw G_module.zero,
--says g· (0:M) = 0
end,
map_add′ := begin
unfold d.to_fun,
intros,
funext,
simp only [sum_cochain, G_module.linear,
G_module.neg_one_linear_applied, sum_add_distrib],
--This is just applying linearity of cochain and G-module, and that
(-1:Z) is also linear in scalar multiplication of G-module.
rw [add_left_comm, <-add_assoc, add_left_comm, <-add_assoc,add_assoc],
--arithmetic rearrangeing of a equation.
end }
4.7
Deﬁnition of Cocycle
With kernel deﬁne, this is direct, as follow,
47

4.8
Deﬁnition of Coboundary
4
GROUP COHOMOLOGY IN LEAN
def cocycle (n:N )(G : Type∗) [group G] (M : Type∗) [add_comm_group M]
[G_module G M]
(N : Type∗) [add_comm_group N] [G_module G N]:= (add_group_hom.ker (d (n+1)
G M))
4.8
Deﬁnition of Coboundary
With range deﬁne, this is direct, as follow,
def coboundary (n:N )(G : Type∗) [group G] (M : Type∗) [add_comm_group M]
[G_module G M]
(N : Type∗) [add_comm_group N] [G_module G N]:= add_group_hom.range (d n G
M)
4.9
Deﬁnition of Cohomology
Due to ‘Type-Speciﬁcity’ , we note that a normal quotient is deﬁned as a group over
another group. However, it our deﬁnition of n-cohomology, it is actually a subgroup(kernel)
over another subgroup(range), with the additional property that this range is a subgroup of
the kernel. There is a type diﬀerence. Instead of using the deﬁnition of quotient already
in Lean, we need to deﬁne a notion for this kind of ‘quotient’, which leads us to this new
bundle of additive sub-quotient.
4.9.1
Bundle: Additive Sub-quotient
The deﬁnition of the newly introduced concept add_subquotient is,
structure add_subquotient (A : Type∗) [add_comm_group A] :=
(bottom : add_subgroup A)
(top : add_subgroup A)
(incl : bottom ≤top)
One immediately proves that the top, bottom of an add_subquotient and moreover the
add_subquotient itself are abelien groups. This is useful as we deﬁne cohomology using
add_subquotient, we immediate gets that Hn(G, M) forms an abelian group.
In addition to the above deﬁnition, one also proves in this ﬁle an important deﬁnition
for the section on induced map on cohomology.
That is, given abelian groups A, B,
add_subquotient of A, B as Q and R, and a homomorphism f : A →B, with the proper-
ties that f maps cocycles to cocycles and coboundaries to coboundaries. Then there is an
induced homomorphism from Q to R.
4.9.2
Deﬁnition of Cohomology
With add_subquotient, we can simply give the deﬁnition of n-cohomology in Lean as
def cohomology (n:N )(G : Type∗) [group G] (M : Type∗) [add_comm_group M]
[G_module G M]: add_subquotient (cochain (n + 1) G M) :=
{bottom := coboundary n G M,
top := cocycle n G M,
incl := cob_sub_of_coc n G M}
where the inclusion can be proved very simply by playing around definitions
and applying \lstinline{theorem d_square_zero1} that we have already
done in Lean.
48

4.10
Partially Finished: Long Exact Sequence
4
GROUP COHOMOLOGY IN LEAN
4.10
Partially Finished: Long Exact Sequence
A deﬁnition and some fundamental facts of G-module homomorphism will form the basic as
we moves towards the long exact sequence of group cohomology, which is the next concept
we want to formalize in Lean. The plan can be segmented into the following parts:
• Step 1: For a given G-module homomorphism f: M\to N, deﬁne a cochain map from
cochain n G M to cochain n G N.
• Step 2: Prove this cochain map commutes with the diﬀerential d.to_fun as deﬁned in
Lean.
• Step 3: Deﬁne the induced homomorphism on cohomology, from cohomology n G M to
cohomology n G N.
• Step 4: Deﬁne exactness in Lean.
• Step 5: Prove that given an short exact sequence of G-modules M, N, L and G-module
homomorphism f : M →N, g : N →L, we have the an short exact sequence of on
cohomology with the induced homomorphism deﬁned in Step 3.
• Step 6: Deﬁne the connecting homomorphism from Hn(G, L) to Hn+1(G, M).
• Step 7: Prove that the long sequence induced on cohomology is indeed exact.
However, as many dependencies essential for proving this theorem, such as the zig-zag lemma
in algebraic topology, is still not in place in Lean yet, we will not be able to ﬁnish all the
steps. This project ﬁnish with the completion of step 3 above.
4.10.1
Bundle: G-Module and G-Module Homomorphism
The bundle G_module.basic contains basic deﬁnition and results of the scalar multiplication
for a G-module M. The deﬁnition is given as follow. Some properties include those we have
already discussed in Section 4.5.3.
class G_module (G : Type∗) [group G] (M : Type∗) [add_comm_group M]
extends
has_scalar G M :=
(id : ∀m : M, (1 : G) · m = m)
(mul : ∀g h : G, ∀m : M, g · (h · m) = (g ∗h) · m)
(linear : ∀g : G, ∀m n : M, g · (m + n) = g · m + g · n)
The bundle G_module.hom contains deﬁnition of a G-module homomorphism, that is, a
homomorphism that is G-linear, and its properties. The deﬁnition is constructed as follow,
and denoted by M →[G] N.
structure G_module_hom :=
(f : M →+ N)
(smul : ∀g : G, ∀m : M, f (g · m) = g · (f m))
4.10.2
Step 1: Induced Cochain Map
Given a G-module homomorphism f, we have an induced cochain map, just as discussed in
Section 2.
def cochain.map {n : N} (f : M →[G] N) : cochain n G M →cochain n G N :=
λ b c, f (b c)
49

4.10
Partially Finished: Long Exact Sequence
4
GROUP COHOMOLOGY IN LEAN
It is indeed a homomorphism with simple checks in Lean,
def cochain.hom (f : M →[G] N) : cochain n G M →+ cochain n G N :=
{ to_fun := cochain.map f,
map_zero′ := begin unfold cochain.map, ext, apply
add_monoid_hom.map_zero, end,
map_add′ := begin intros, unfold cochain.map, funext, apply
add_monoid_hom.map_add,end }
4.10.3
Step 2: A Commutative Diagram
The important result is,
theorem d_map (n : N) (f : M →[G] N) (c : cochain n G M) :
cochain.map f (d.to_fun c) = d.to_fun (cochain.map f c) :=
begin
ext gs,
unfold d.to_fun,
unfold cochain.map,
rw f.map_add,
--says f(a+b)=f(a)+f(b)
rw f.map_smul,
-- says f(gm)=gf(m)
rw f.map_sum,
-- says linearity of a sum
congr′,
ext x,
show (f.f) _ = _,
exact add_monoid_hom.map_gsmul _ _ _,
end
It is not a mathematically diﬃcult proof. It is achieved by rearranging and simply applying
linearity everywhere. Of course, these facts about linearity have to be proved ﬁrst, but most
of which are already equipped in Lean.
4.10.4
Step 3: Induced Map on Cohomology
This is where we use the important deﬁnition of the induced homomorphism in the bundled
ﬁle add_subquotient.basic, we have the induced map on group cohomology as
def cohomology.map (f : M →[G] N) : cohomology n G M →+ cohomology n G N:=
add_subquotient.to_add_monoid_hom (cocycle.map_incl f) (coboundary.map_incl
f)
where the two inputs are the proofs that the induced cochain map sends cocycles of M to
cocycles of N, and similarly for coboundaries. One can also ﬁnd out explicit expressions for
the induced homomorphism on these cocycles and coboundaries but it is unnecessary.
Notice that in any of the deﬁnition of these induced homomorphisms, the number n is
never explicit speciﬁed. Actually, one can change the value of this n freely as long as it is
consistent in the corresponding deﬁnition of cochain, cocycle, coboundary and cohomology.
This is an essential fact as this actually shows that these induced maps can be created for
any n ∈N, hence forming the required complexes and morphisms as deﬁned in Section 2
which is important for the proof of the long exact sequence of group cohomology. We stop
here for this project.
50

5
CONCLUSION AND FURTHER RESEARCHES
5
Conclusion and Further Researches
5.1
Main Results
In summary, we have successfully achieved in both providing the blueprint and formalizing
the ﬁrst general deﬁnition of group cohomology in Lean. Moreover,
• The error-free and sorry-free Lean repository on the deﬁnition of group cohomology
veriﬁes that our blueprint is correct.
• The new introduced deﬁnitions in Lean, such as n-cochain, diﬀerential dn, n-cocycle,
n-coboundary, and n-cohomology are checked by examples and theorems such that they
are deﬁned correctly.
• We have shown that Lean is capable of understanding group cohomology.
• We have restructured and bundled some concepts of additive groups in Lean which
make future applications smoother.
• We have made some progress to formalizing the long exact sequence of group cohomol-
ogy in Lean. Once the dependencies are in place in Lean, such as deﬁnition of exactness,
the proof of the zig-zag lemma, and formalization of long exact sequence from short ex-
act sequence that are essential to the proof of the theorem, one can continue from our
progress to ﬁnish the induced long exact sequence in Lean based on the deﬁnitions given
in this project.
5.2
Implication in Lean
As a result of group cohomology’s usefulness, our main achievement of formalizing the ﬁrst
general deﬁnition of group cohomology in Lean has a signiﬁcant implication to Lean. It
sets up the basics in this area of study of groups and opens up countless possible directions
of future projects in Lean. For example, it makes all the formalization of theorems about
group cohomology possible. Actually more generally, it makes any theorems using group
cohomology in its statement (with other notions in the statement already deﬁned in Lean)
possible. For example, one may think of formalizing Hilbert’s Theorem 90 and Brauer groups
in Lean. In addition, due to the high relevance of group cohomology in modern formulation
of class ﬁeld theory, our deﬁnition of group cohomology in Lean makes class ﬁeld theory a
targeted topic in advanced mathematics that to be formalized in Lean.
On the other hand, Lean was not created to just to verify proofs. In a holistic point of
view, it aims to achieve automation of proof gradually, that is, providing a proof by Lean
itself. One can already see that Lean at this point is capable of ﬁnding some simple proofs
by itself through algorithms such as library_search, and linarith. We may foreseen in
the future, as the library of Lean builds up, and as Lean ‘learns’ more and more concepts,
that it is capable of performing machine learning and creating something new on its own.
This project enriches the math library in Lean by adding an important concept and opening
possibilities for many more important topics, and hence makes contribution towards this
automation objective of Lean.
5.3
Possible Directions of Future Researches
As discussed before, there are abundant possible directions of researches made available by
our achievements. Some include,
51

5.3
Possible Directions of Future Researches
5
CONCLUSION AND FURTHER RESEARCHES
• Continue to work on theorems about group cohomology in Lean, starting with the
induced long exact sequence.
• Deﬁne Brauer groups in Lean using the deﬁnition of group cohomology and hence
proceed to formalizing class ﬁeld theory in Lean.
• Cross comparison with non-general deﬁnitions of group cohomology. For example, one
can proof our deﬁnition in Lean is the same as that of in GAP to prove our deﬁnition
is computationally eﬃcient.
• Check other deﬁnitions of group cohomology in Lean. For example, prove that the
cohomology groups Hn(GM) are derived functors, or choose another resolution to obtain
a new formula for the diﬀerentials dn and compare which is more convenient to work
with.
52

6
REFERENCES
6
References
53

