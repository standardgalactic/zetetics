14
The Leordo computation system
Erik Sandewall
Link¨oping University and Royal Institute of Technology, Stockholm, Sweden
Abstract
The purpose of the research reported here was to explore an alternative
way
of
organizing
the
general
software
structure
in
computers,
eliminating the traditional distinctions between operating system,
programming language, database system, and several other kinds of
software. We observed that there is a lot of costly duplication of
concepts and of facilities in the conventional architecture, and believe
that most of that duplication can be eliminated if the software is
organized diﬀerently. This article describes Leordo, an experimental
software system that has been built in order to explore an alternative
design and to try to verify the hypothesis that a much more compact
design is possible and that concept duplication can be eliminated or at
least greatly reduced. Deﬁnite conclusions in those respects can not yet
be made, but the indications are positive and the design that has been
14.1 Introduction
14.1.1 Project goal and design goals
Leordo is a software project and an experimental software system that
integrates capabilities that are usually found in several diﬀerent software
systems:
• in the operating system
• in the programming language and programming environment
• in an intelligent agent system
• in a text formatting system
From Semantics to Computer Science Essays in Honour of Gilles Kahn,
eds Yves
Bertot, G´erard Huet, Jean-Jacques L´evy and Gordon Plotkin. Published by Cambridge
University Press.
c
⃝Cambridge University Press 2009.
309
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

310
E. Sandewall
and others more. I believe that it should be possible to make a much more
concise, eﬃcient, and user-friendly design of the total software system
in the conventional (PC-type) computer by integrating capabilities and
organizing them in a new way.
The purpose of the Leordo project1 was to verify or falsify this
hypothesis. This was done by designing and implementing an experi-
mental system, by iterating on its design until it satisﬁed a number of
well deﬁned criteria, and by implementing a number of characteritic
applications using the Leordo system as a platform.
The implementation of the experimental system has passed several
such iterations, and a reasonably well-working system has been in daily
use for several years. The following are the requirements that were
speciﬁed for that system and that are satisﬁed by the present implemen-
tation. We expect to retain them in future system generations.
The system is of course organized in a modular fashion, where the
modules are called knowledge blocks and contain both algorithms, data,
and intermediate information such as ontologies and rules. There shall
be a designated kernel consisting of one or a few knowledge blocks that
is used as a basis on which other blocks can be built, for the purpose of
additional services and for applications. The following were and are the
requirements on the kernel.
• It
shall
contain
self-describing
information
and
corresponding
procedural capabilities whereby it is able to administrate itself, its
own structure, and its own updates.
• It shall provide the extension capabilities that make it possible to
attach additional knowledge blocks to it and to administer them in
the same way as the kernel administers itself.
• It shall provide adequate representations for the persistent storage of
all contents of the blocks in the kernel, as well as the representations
and the computational services for performing computations on the
same contents.
• It shall provide capabilities for adaptation, in particular to facilitate
moving a system between hosts, and for deﬁning alternative conﬁg-
urations based on diﬀerent sets of knowledge blocks.
• Although the experimental system will be based on an existing,
conventional operating system and ditto programming language, it
1 The project and the system were previously called Leonardo, but the name was
changed to Leordo in order to avoid a name conﬂict.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
311
shall be designed in such a way that it can be ported to the weakest
possible, underlying software base.
The last item in these requirements is included because in principle we
believe that the services of the operating system and the programming
language and system, should just be parts of one integrated computation
system. The longer-term goal is therefore that the Leordo system
itself should contain the programming-language and operating-system
services.
Furthermore, the facilities in the kernel have been, and will continue
to be designed in such a way that they do not merely serve the above-
mentioned requirements on the kernel itself; they shall also be general
enough to provide a range of applications with similar services.
Above the kernel and below the speciﬁc application areas and
applications, there shall also be an extensible platform consisting of
knowledge blocks that are of general use for a number of applications of
widely diﬀerent character.
Illustration materials and annexes of the present article can be found
on the article’s persistent webpage at
http://www.ida.liu.se/ext/caisor/pm-archive/leonardo/002/. It
is useful to have access to that webpage while reading the present article.
14.1.2 Main hypothesis for the leordo project
The main hypothesis for this project, for which we hope to obtain
either strong positive evidence or a clear refutation, is as follows: It is
demonstrably possible to design the kernel and a platform in such a way
that (1) repeated implementation of similar tasks is virtually eliminated
in the kernel and platform, and (2) the total software structure that is
obtained when several applications are built on this platform can also be
essentially free from repeated implementations of similar tasks.
14.1.3 Approach to the design
The design of the system does not start by deﬁning a programming
language, nor by deﬁning a process structure or a virtual instruction
set. In Leordo, the ﬁrst step in the design is to deﬁne an object-oriented
information structure that has some points in common with RDF2
2 http://www.w3.org/RDF/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

312
E. Sandewall
and OWL,3 although also with signiﬁcant diﬀerences. The notation
used for this purpose is called KRE, the Knowledge Representation
Expression language. It is used for all information in the system,
including application data, procedures, ontologies, parameter structures,
and whatever corresponds to data declarations in our system. Full KRE
is a knowledge representation language but the present article will only
describe those parts of KRE that are used for the Leordo system design.
The element in the KRE structure is called an entity, and entities can
have attributes and properties. Attribute values can have structure and
are not merely links to other entities; they can be constructed by the
formation of sets, sequences, and records, even recursively. Moreover,
entities can be composite expressions; they are not merely atoms with
mnemonic names. Property values are like long strings and can be
used for expressing e.g. a function deﬁnition, or a descriptive comment.
Because of this expressive power, KRE is best viewed as a knowledge
representation language.
We use the term ‘entity’ rather than ‘object’ for the elements in KRE
since the term ’object’ has a connotation of message passing and a fairly
restrictive view of class hierarchy, which are not applicable in KRE.
Each knowledge block consists of a set of entity ﬁles; each entity ﬁle
consists of a sequence of entities; and each entity has its attributes and
properties.
The experimental system, which is based on conventional operating
systems, has in addition the following design. A Leordo individual is a
section of the ﬁle system in a computer hosting the individual, namely
one directory and all its sub-directories, with all the ﬁles contained in
them (with the exception of auxiliary ﬁles such as .bak ﬁles). Each
entityﬁle in the Leordo sense (i.e. a sequence of entities) is represented
by one ﬁle in the sense of the ﬁle system; this ﬁle is a text (‘ascii’)
ﬁle adhering to a particular syntax. An activation of the individual is
obtained by starting a run with a host programming language, where
the run is initialized using some of the ﬁles contained in the individual.
The run usually includes interactions with a human user, but maybe also
with robotic equipment, Internet information sources and resources, or
other Leordo individuals. Entityﬁles in the individual can be read and
written during the activation, for example for storing information that
has been acquired during the activation, or for updating the software.
3 http://www.w3.org/TR/owl-features/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
313
In accordance with the speciﬁed goals for Leordo, as described above,
the individual shall be self-contained and be able to model its own
structure, and to update it. In that sense the individual is able to modify
itself during the activation. The individual shall also contain facilities
for moving itself, or allowing itself to be moved from one host to another,
in ways that are reminiscent of mobile agents.4
The use of directories and ﬁles for representing aggregates of Leordo
entities is an intermediate solution. In the longer run we wish to port
Leordo to a persistent software system that is able to represent entities
directly, so that the structures and services that are traditionally oﬀered
by an operating system and in particular by its ﬁle system, can instead
be implemented in the Leordo kernel or platform.
Both the experimental system and the forthcoming persistent system
must use a host programming language. Functions, procedures, classes,
or whatever other building-blocks are used in the host language will be
represented by Leordo entities, and the deﬁnition of a function (etc) is
expressed in a property of that entity. Our main experimental system
has been implemented in CommonLisp; a part of the core has also been
implemented in Python. We expect that the persistent system will be
based on a language similar to Scheme. Interpretation-oriented languages
such as these are the best suited for our approach.
14.1.4 Notation vs. system
The language design and the system design in our approach are strongly
interdependent. The language design has come ﬁrst in the present
project, but the system design is by far the largest part of the work
and it has arguably the largest novelty value. The main purpose of the
present report is to describe the system design, but it is necessary to
describe the language design ﬁrst.
14.2 An example of KRE
By way of introduction we show two examples of how the Leordo Data
Expression language, KRE, is used in Leordo. A more detailed speciﬁ-
cation of KRE can be found in the report “The Leonardo Representation
Language.5
4 http://en.wikipedia.org/wiki/Mobile-agent
5 http://www.ida.liu.se/ext/caisor/pm-archive/leonardo/001/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

314
E. Sandewall
14.2.1 KRE in the Common Knowledge Library
The Common Knowledge Library6 (CKL) is an open-source repository
for structured information ranging from ’facts’ to ’knowledge’. It
presently contains more than 60 000 entitites each having a number
of attributes. The KRE notation is the ’ﬁrst language’ used by the
Common Knowledge Library. The reader is encouraged to browse its
website in order to obtain an impression of how information can be
represented using KRE.
One thing that is not immediately seen on the CKL website is,
however, the representation of meta-information. We use two kinds
of meta-information: type information and catalog information. Each
entity has an attribute called type where the attribute value is a new
entity representing the type of the given entity. Furthermore, for each
entityﬁle there is one entity that serves as the name of the entityﬁle;
one of the attributes of the naming entity is a sequence consisting of the
entityﬁle’s members. The name of an entityﬁle is itself the ﬁrst member
of that list.
The type system is quite simple. For use in some applications there is
also a notion of classes which are similar to the ’concepts’ of description
languages, but this is not used in the system kernel.
Notice that entityﬁles are used for expressing both programs and data.
Each named unit in a program, such as a function or a procedure, is
represented as a KRE entity, with the program code in a property of
that entity. The entityﬁles that are used within the system diﬀer in some
minor ways from those shown on the CKL website. For example, the
provenance and IPR information occurs only in the published ﬁles and
not in system-internal ﬁles.
The operation of loading an entityﬁle is performed by activations, and
consists of reading the text ﬁle for the entityﬁle, such as the ones used
in the CKL, and constructing the corresponding data structures in the
activation. The operation of storing an entityﬁle is the reverse operation
of re-writing its text ﬁle by converting data structures to corresponding,
textual expressions. Loading and immediately storing an entityﬁle has a
null eﬀect on its text ﬁle.
6 http://piex.publ.kth.se/ckl/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
315
14.2.2 Cooperating agents
The next example shows how a distributed computational process is
organized in Leordo, and how the KRE language is used for representing
the control information. Consider the following method description in
Leordo:
----------------------------------------------------------
-- method6
[: type method]
[: plan {[intend: t1 t2 (remex: lar-004 (query: makebid))]
[intend: t1 t3 (query: makebid)]
[intend: t4 t5 (query: propose-compromise)]}]
[: time-constraints {[afterall: {t2 t3} t4]}]
----------------------------------------------------------
This is a plan, i.e. a kind of high-level procedure, for a situation
where two separate users have to give their respective bids for some
purpose, and when both bids have been received, one user has to propose
a compromise. This requires performing the action query: three times
with diﬀerent arguments. The time when the ﬁrst two occurrences are
to start is called t1; the third occurrence starts at a time t4 which is
deﬁned as being when the ﬁrst two occurrences have ended. The time
when the ﬁrst mentioned occurrence ends is called t2, and similarly for
t3. The method consists of a set of intended actions, and set of time
constraints between them.
This plan is supposed to be executed in a particular individual (called
lar-003 in our speciﬁc run of the plan) but the ﬁrst mentioned action
is to be remote executed (therefore remex:) in another individual called
lar-004.
The KRE language is used for representing this plan, or script. In
this example there is an entity called method4 with three attributes
type, plan, and time-constraints. The value of the type attribute
determines what other attributes may be present.
This examples uses more of the KRE expressivity than in the ﬁrst
example. It shows how expressions in KRE may be atomic ones (symbols,
strings, or numbers), or may be formed recursively using the operators
<...> for sequences, {...} for sets, [...] for records, and (...)
for forming composite entities. In the example, (query: makebid) is a
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

316
E. Sandewall
composite entity that has a type and attributes, just like the atomic
entity method4.
The webpage of the present article contains details from an activation
using the method shown above, and it illustrates how KRE is used for the
control information as the plan or script is executed, and for retaining
some of that control information afterwards.
14.3 Information structure
14.3.1 The structure of Knowledgeblocks
The total information in a Leordo system is organized as a set of
knowledgeblocks, and each activation of Leordo is initialized by loading
one speciﬁc knowledgeblock in that set. Some knowledgeblocks require
others, however, so that to load a knowledgeblock one ﬁrst loads those
other knowledgeblocks that it requires, recursively, and then one loads
the entityﬁles that are speciﬁed for the given knowledgeblock itself.
Each knowledgeblock consists of a set of entityﬁles. One of those
entityﬁles represents the knowledgeblock as a whole and contains overall
information about it; it is called the index of the knowledgeblock. The
ﬁrst entity in the index has the type kb-index which is a subtype of
entityfile, and this entity is used to designate the knowledgeblock as
a whole. This means that it can have both attributes that pertain to its
role as describing its own entityﬁle, and attributes that pertain to the
knowledgeblock as a whole.
One important use of the knowledgeblock index is to specify where the
textﬁles for other entityﬁles in the same knowledgeblock are stored. The
kb index speciﬁes the mapping from entities as understood by Leordo,
to actual ﬁle paths in the computer or ﬁlestore at hand.7 This makes it
straightforward to move entityﬁles and to redirect references to them,
which has a number of uses including that it makes it easy for several
individuals to share some of their ﬁles.
A few of the entityﬁles in a knowledgeblock have special properties
or play special roles, besides its index. This applies in particular
for ontology ﬁles. To the largest extent possible, entities in the core
Leordo system and in its applications are organized in terms of an
ontology which is subject to modularization like all other aspects of the
7 Some Leordo individuals are placed on detachable memory devices, such as USB
sticks, which means that they can have activations on diﬀerent hosts without their
ﬁle structure having been ’moved’ in a conventional sense.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
317
system. The kernel contains a ‘core ontology’, and every knowledgeblock
contributes additional entities and links to the ontology, thereby
extending the core. Each activation of an individual contains a working
ontology that has been formed by loading and integrating the ontology
ﬁles of the knowledgeblocks that have been loaded.
Entities in a knowledgeblock can be of three kinds with respect to
mobility: software speciﬁc, individual speciﬁc, or host speciﬁc. These are
deﬁned as follows. If an individual is moved to another host, then it shall
encounter host-speciﬁc entities of the new host instead of those it had
on the old host, whereas software-speciﬁc and individual-speciﬁc entities
are retained. On the other hand, if a knowledgeblock is exported from
one individual to another then only the software-speciﬁc entities are
exported and they will be used with the individual-speciﬁc entities of the
receiving individual. Individual-speciﬁc information includes the history
and experience of the individual; host-speciﬁc information includes, for
example, the locations and properties of databases, printout devices, and
other resources that the host can oﬀer to a visiting software individual.
In the present Leordo design, each entityﬁle is required to have all
its members of the same kind in this respect, so that the distinction
between software speciﬁc, individual speciﬁc, and host speciﬁc applies to
entityﬁles as well. The knowledgeblock index speciﬁes only the locations
of software-speciﬁc entityﬁles that belong to it. There are separate
catalogs for all host-speciﬁc and for all individual-speciﬁc entityﬁles.
14.3.2 Considerations for the design of KRE
Knowledge Representation Expressions (KRE) is a textual represen-
tation for information structures, and the above examples have given
the ﬂavor of this notation. The details of the syntax are described
in a separate memo that is available on the Leordo website.8 The
present subsection shall discuss the design considerations that guided
the deﬁnition of KRE.
The idea of allowing data structures to be expressed as text,
and to deﬁne input and output of data structures accordingly, was
pioneered by John McCarthy with Lisp 1.5.9 It has been adopted in
several interpretive or ’scripting’ programming languages that are used
8 http://www.ida.liu.se/ext/leonardo/
9 http://www.lisp.org/alu/home
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

318
E. Sandewall
extensively, such as Perl10 and Python.11 It is also characteristic of high
level message formats, such as the KQML.12 With partly diﬀerent goals,
this tradition has also been continued in the XML family of information
representation languages, including e.g. RDF and OWL besides XML
itself.
There are several possible motivations for representing information
structures textually, in text ﬁles or otherwise, and in particular, for the
following situations.
(i) For persistent storage of the information, between runs of computer
programs.
(ii) For presentation of the information to the user, and for allowing her
or him to edit the information.
(iii) As a message format, for transmitting chunks of information from one
executing process to another one.
(iv) For representation of internal system information, such as parameter
settings for particular programs or services.
These alternatives apply regardless of whether the text ﬁles are
used for representing pieces of code, application data, or declarations,
ontologies, or other metadata.
The choice of representation may depend on which of these are the
intended uses. In particular, if the second purpose is intended then it
becomes important to have a representation that is convenient to read
for the human. The poor lisibility of XML was apparently accepted
because it was thought that XML coded information should mostly be
seen and edited through graphical interfaces, and not directly by users
or developers.
In our case, we wish to use KRE for all four of the above-mentioned
purposes. We also have some other design requirements.
• The notation should be suitable for use in textbooks, research articles,
and manuals. This strongly suggests that it should stay as close to
conventional set theory notation as possible.
• Since the notation is going to be the basis for an entire computation
system, including its programming-language aspects, it must be
expressive enough for the needs of a programming language.
10 http://www.perl.org/
11 http://www.python.org/
12 http://www.cs.umbc.edu/kqml/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
319
• The notation is used for the ontology structure that is a backbone for
the Leordo system. It must therefore be expressive enough for what
is needed in ontologies.
These requirements led to the decision of not using an existing
language or notation, but to design our own. The following aspects of
the KRE language should be emphasized in particular.
(1) The use of multiple bracket types. Most programming languages
use several kinds of parentheses and brackets, such as (...), [...],
{...}, and possibly others. On the other hand, representations for
information structures often use a single kind of brackets, such as (...)
in Lisp and <...> in XML and other languages in the SGML tradition.
This is suﬃcient in principle, but it makes it necessary to rewrite sets,
sequences, and other “naturally parenthesized” structures along the
lines of
(set a b c)
(sequence a b c)
and so on. LRX uses the multiple brackets approach and allows
expressions such as
{a b c}
<a b c>
for sets and sequences, and in addition a few other kinds of brackets.
This diﬀerence is trivial from an abstract point of view, but it makes
surprisingly much diﬀerence for the ease of reading complex expressions.
Compare, for example, the KRE reprsentation of the plan entity in
example 2, which was as follows:
----------------------------------------------------------
[: type method]
[: plan {[intend: t1 t2 (remex: lar-004 (query: makebid))]
[intend: t1 t3 (query: makebid)]
[intend: t4 t5 (query: propose-compromise)]}]
[: time-constraints {[afterall: {t2 t3} t4]}]
----------------------------------------------------------
with a representation of just the second line of that information in an
XML-style13 single-bracket notation:
13 http://www.w3.org/XML/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

320
E. Sandewall
----------------------------------------------------------
<plan>
<planstep-set>
<planstep>
<intendstep>
<fromtime>t1</fromtime>
<totime>t2</totime>
<remote-execute>
<execute-at>
<indiv-name>lar-004</indiv-name>
</execute-at>
<execute-what>
<query-action>
<phrase>makebid</phrase>
</query-action>
</execute-what>
</remote-execute>
<intendstep>
<planstep>
----------------------------------------------------------
Even
the
Lisp-style
single-bracket
representation
is
much
less
convenient to read than the multi-bracket representation:
----------------------------------------------------------
(maplet type method)
(maplet plan
(set (record intend: t1 t2
(term remex: lar-004 (term query: makebid)))
(record intend: t1 t3 (term query: makebid))
(record intend: t4 t5 (term query: propose-compromise))
))
(maplet time-constraints
(set (constraint afterall (set t2 t3) t4)) )
----------------------------------------------------------
In a historical perspective it is interesting to compare the great interest
in legibility issues when programming languages are designed, with the
virtually complete disregard for the same issue in the design of so-called
markup languages for representing structured information in general.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
321
(2) The use of composite expressions for entities. KRE is similar to
OWL, for example, in that it is based on the use of entities to which
attributes and properties are assigned. In the simplest cases, entities are
written as identiﬁers and attributes are expressions that are formed using
set, sequence, and record forming operators. However, entities can also
be composite expressions that are formed using a symbolic function and
one or more arguments which are again atomic or composite expressions,
for example as in
(payment: (membership: (member-number: 1452)
(year: 2006) ))
for “the payment for the membership during year 2006, by member
number 1452”, or
(b: 356 (remex: lar-004 (query: makebid)))
for “the instance of the action (query: makebid) that was initiated at
time 356 for execution in the individual lar-004”. Entities formed by
composite expressions share the same characteristics as atomic entities,
for example that they have a type and can be assigned attributes
and properties, and that they can be included in entityﬁles with their
assignments.
The YAML (Yet Another Markup Language)14 allows assigning
attributes to composite structures, but does not make it possible to
include such a composite structure as a term in a larger expression.
The use of composite entities has turned out to be very useful in
the design of ontologies and other knowledge representations. It is
included in the kernel of the Leordo system and is used in various ways
even for representing “system” information in the kernel, as the second
introductory example has showed. Another example is for intermediate
structures in the version management subsystem. On higher levels of
the design, there is an extension of LRX for representing formulas
in ﬁrst-order predicate calculus, in which case composite entities are
identiﬁed with terms in the sense of logic.
(3) The use of event-state records. Records are formed in LRX using
the notation of the following examples:
[date: 2006 10 24]
[quantity: meter 42195]
[quantity: (per: meter second) 46]
14 http://www.yaml.org/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

322
E. Sandewall
for the date of October 24, 2006, for the quantity of 42195 meters, and
for the quantity of 46 meters per second, respectively. Records diﬀer
from composite entities in that they are passive data objects that can
not be assigned attributes or properties.
One kind of records, called event-state records, actually allow some
of their components to change, but in restricted ways. They are used
for representing the current state of an action instance that the system
is performing during a period of time, or the current observation state
of an event that the system observes. An event record such as (simple
example)
[move-robot: r14 pos12 pos14 :start 16:22
:velocity [quantity: mps 4]
:current-pos [xy-coordinate: 47 12]]
where mps is an abbreviation for (per: meter second), may represent
the current state of an event where the robot r14 moves from position
pos12 to position pos14. The record contains the three direct arguments
of the operator move-robot:, and after them the three state variables
of the event with the respective labels :start, :velocity, and
:current-pos. The values of the state variables, except :start, can be
changed while the event executes in order to reﬂect the current state
of the robot concerned. When the event ends then the ending time is
added as an additional state variable, other state variables are added
or removed so that the record becomes a representation of the event as
a whole and its ﬁnal eﬀects, the record freezes, and no further changes
are possible in it.
An event-state record such as this may be the value of an attribute
of an action-instance entity as formed by, for example, the symbolic
function b: that was introduced previously.
14.4 The Leordo Kernel and platform
14.4.1 The structure and constituents
The Leordo Kernel consists of four knowledgeblocks, beginning with the
core which is called core-kb. By convention, the names of knowledge-
blocks end with “-kb“. The core satisﬁes all the requirements on the
kernel except version management. In addition there is chronos-kb
that implements a representation of calendar-level time and of events
in the lifecycle of an individual, config-kb that is used for creating
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
323
new copies (“individuals”) of the system and for conﬁguring old and
new individuals, and ﬁnally syshist-kb that implements version
management. Both reproduction and version management add entries
to the system’s history of its own activities which is maintained by
chronos-kb. For example, a so-called synchronization in the sense
of version management is treated as an event in the representation
provided by chronos-kb.
The more basic aspects of self-modiﬁcation in the system are
implemented in core-kb, however. This includes, for example, facilities
for allowing the user to edit attributes and properties of an entity, and
to add entities and entityﬁles.
The core part of the Leordo ontology, called coreonto, is an
entityﬁle within the the initial knowledgeblock core-kb. Every other
knowledgeblock, including the other three kernel blocks, can have their
own ontology ﬁles that extend preceding knowledgeblocks.
14.4.2 The Core Knowledgeblock, core-kb
The following are the contents of the core block, as organized in a number
of entityﬁles.
• The initial loading or ’bootstrap’ machinery. It consists of a few
entityﬁles that are the very ﬁrst ones to be loaded when an activation
is started, and it prepares the ground for subsequent loading.
• The index ﬁle of the core knowledgeblock. (core-kb).
• The ontology ﬁle of the core knowledgeblock, which is at the same time
the core or “top-level” ontology of Leordo as a whole. (coreonto).
• Miscellaneous additions to the core ontology that are needed for
historical or other reasons. (toponto).
• Deﬁnitions of procedures for loading entityﬁles and parsing the textual
representation of entities. (leo-preload, leoparse).
• Deﬁnitions of elementary operations on the structured objects in
the Leordo data representation, such as sequences, sets, and records.
(leoper).
• Miscellaneous auxiliary functions that are needed in the other
entityﬁles but which have a general-purpose character. (misc).
• Major timepoints in the history of the present instance of the system
(mp-catal).
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

324
E. Sandewall
• Functions for administrating entities, entityﬁles, and knowledge-
blocks, for example, for creating them and for editing their attributes.
(leo-admin).
• Functions for writing the textual representation of entityﬁles, and for
producing the textual representation of Leordo datastructures from
their internal ones. (leoprint).
• Deﬁnitions for a simple executive for command-line operation of the
system. (lite-exec).
The entityﬁle mp-catal mostly serves chronos-kb, but it is initialized
in the core block which is why it is present in this list.
Many of these blocks are straightforward and do not require further
comment here; their details are described in the systems documen-
tation. I have already described and discussed the data format for the
textual representation of entityﬁles. The ﬁles for loading and storing
that representation (leo-preload, leoparse, leoprint) are direct
implementations of the data format. Furthermore I shall discuss the
ontology, the bootstrap machinery, the machinery for cataloguing
entityﬁles using knowledgebase index ﬁles, and the facility for deﬁning
multiple conﬁgurations within an individual. Final sections will describe
the other parts of the kernel, namely, the facility for administrating
and ‘remembering’ information about calendar-time-level events in the
history of a Leordo individual, and the facility for version management
of entityﬁles.
14.4.3 The Leordo startup machinery
One of the basic requirements on the Leordo Kernel is that it shall be
able to administrate itself, and in addition it shall provide facilities for
self-administration of other knowledgeblocks that are built on top of the
four knowledgeblocks in the kernel. This self-administration requirement
includes several aspects.
• All program code in an implementation shall be represented as
entityﬁles, without exceptions. This guarantees that general facilities
for administration and analysis of Leordo software can apply even to
the initial parts of the bootstrap process.
• Since interactive sessions with the Leordo system typically involve
loading information from the textual representation of entityﬁles,
modifying their contents, and re-storing those entityﬁles, it shall be
possible to edit all entityﬁles for software in that way as well.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
325
• However, it shall also be possible to text-edit the ﬁle representation
of an entityﬁle and load it into an activation of Leordo, in order for
the edits to take eﬀect there.
• In addition, there shall be a version management system that applies
to software entityﬁles like for all other entityﬁles.
The ﬁrst three of these aspects is implemented using the core-kb
knowledgeblock;
the
fourth
one
using
the
separate
syshist-kb
knowledgeblock. Notice, however, that the ﬁrst aspect is a step towards
(i.e. facilitates greatly) the fourth one.
The startup process for Leordo activations is actually a good
illustration of how a somewhat complex process can be organized around
its symbolic data structures. Appendix 4 describes this in some detail.
14.4.4 Conﬁguration management
One Leordo individual may contain the software for a number of
applications, for example for simulation, for robotics, for document
management, and so on. However, it may not be necessary, or even
desirable to have all of that software and its associated application data
present in a particular activation of the system. The individual should
therefore have several conﬁgurations that specify alternative ways of
starting an activation. The startup ﬁles that were described above serve
to deﬁne such conﬁgurations. In particular, the kb-included attribute
speciﬁes which knowledgeblocks are to be loaded when the system
starts. Knowledgeblock dependencies whereby one knowledgeblock may
require some other knowledgeblocks to be loaded ﬁrst are supported,
and are represented by particular attributes on the knowledgeblocks
themselves.
Each conﬁguration may also make some other speciﬁcations, for
example for extra information that is to be loaded in order to start it.
Furthermore, each conﬁguration shall specify its user interface, in the
sense of a command-line interpreter, a GUI, and/or a web-accessible
service. This is done with the execdef attribute on the startup-ﬁle that
was described in Appendix 4.
14.4.5 The Knowledgebase index ﬁles
Each Leordo individual is represented as a directory structure, consisting
of a top-level directory and its various subdirectories on several levels,
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

326
E. Sandewall
with their contents. In a predecessor to Leordo, the Software Individuals
Architecture, we used ﬁxed conventions for where the entityﬁles would
be located within the directory structure, and relative addressing for
accessing them. This turned out to be too inﬂexible, and for Leordo
we have a convention where each entity representing an entityﬁle is
associated with the path to where the textual entityﬁle is to be found.
At ﬁrst it would seem that this should be one of the attributes of
the entity that names and describes the entityﬁle, and that is the ﬁrst
element in the entityﬁle. However, it would be pointless to put that
attribute within the ﬁle itself, since the system needs it in order to ﬁnd
the ﬁle so it can load it. One can think of two ways out of this dilemma:
either to divide the attributes of an entity into several groups that can
be located in diﬀerent physical ﬁles, or to construct a composite entity
with the entityﬁle entity as its argument.
Both approaches have their pros and cons. Leordo does provide a
mechanism for overlays whereby one can introduce entities and assign
some attributes to them in one entityﬁle, and then add some more
attributes in an overlay, which is a separate ﬁle. However, that facility is
not part of the kernel, and we are reticent of putting too much into the
kernel. Also, overlays require the entity as such to have been introduced
ﬁrst, before the overlay is added. The attribute for the location of an
entityﬁle is needed before the entity itself is available.
We have therefore chosen the other alternative. The following is a
typical entity in an index ﬁle for a knowledgeblock, such as core-kb:
---------------------------------------------------------
-- (location: leoadmin)
[: type location]
[: filepath "../../../leo-1/Coreblock/leoadmin"]
@Comment
Loading entityfiles and knowledgeblocks, creating new ones,
etc.
---------------------------------------------------------
It deﬁnes the location of the entityﬁle leoadmin by introducing a
composite entity (location: leoadmin) whose type is location, and
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
327
assigning a filepath attribute to it.15 Among the ﬁles that occur at the
beginning of the startup phase, self-kb, kb-catal and core-kb consist
mostly or entirely of such entities.
14.5 Other kernel knowledgeblocks
Until this point we have described the design of the core knowledgeblock,
core-kb. The Leordo kernel also contains three other knowledgeblocks,
beginning with chronos-kb that enables the Leordo activation to
register events and to have an awareness of the passing of time and a
notion of its own history. Based on it there is the reproduction facility,
config-kb, and the versions management facility, syshist-kb.
Both reproduction and version management are essential for the
evolution of the Leordo software through concurrent strands of
incremental change in several instances of the system, i.e. several Leordo
individuals. This is the decisive factor for considering these to be an
integral part of the system kernel. In addition, by doing so we also
provide a set of tools that can be used in applications of several kinds.
– The importance of having software tools for version administration
do not need to be explained; it has been proven through the very
widespread use of tools such as CVS.16
The following are brief summaries of the services that are provided by
these knowledgeblocks in the kernel:
14.5.1 Awareness of time in the Leordo individual
The basic contributions in chronos-kb are listed here.
• A facility for deﬁning and registering signiﬁcant timepoints. Such a
timepoint is registered with its date, hour, minutes, and seconds, and
it can be associated with the starting or ending of events.
• A facility for introducing events in a descriptive sense: the system
is told that a particular event starts or ends, and registers that
information.
• A facility for deﬁning sessions which are composite events corresponding
to the duration of one activation of the Leordo system, and for
deﬁning individual events within the session.
15 Actually this attribute is called filename in the current system, for historical
reasons. This is due to be changed.
16 http://www.nongnu.org/cvs/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

328
E. Sandewall
All of this information is built up within the Leordo system, and is
maintained persistently by placing it in entityﬁles.
14.5.2 System history and version management
The system history is a kind of skeleton on which several kinds of contri-
butions can be attached. The ﬁrst of these is the version management
facility which consists of two parts, one that is local within an individual,
and one that requires the use of two individuals.
Local version management works as follows. The individual maintains
a sequence of archive-points which are eﬀectively a subset of the
timepoints that are registered by chronos-kb. Archive-points have
names of the form ap-1234, allowing up to 9999 archivepoints in one
individual. Each archive-point is associated with the archiving of a
selection of ﬁles from one particular knowledgeblock. The archiving
action takes a knowledgeblock as argument, obtains a new archivepoint,
and for each entityﬁle in the knowledgeblock it compares the current
contents of the ﬁle with those of the latest archived version of the same
ﬁle. It then allocates a new directory, named after the new archive-point,
and places copies there of all entityﬁles where a nontrivial diﬀerence
has been identiﬁed. The archive-point is an entity that is provided with
attributes specifying its timepoint, its knowledgeblock, the set of names
for all entityﬁles in the knowledgeblock at the present time, and the set
of names for those entityﬁles that have been archived.
However, the comparison between current and archived version of the
entityﬁle also has a side-eﬀect on the current ﬁle, namely, that each
entity in the ﬁle is provided with an attribute specifying the most recent
archive-point where a change has been observed in that particular entity.
This makes it possible to make version management on the level of
entities, and not merely on entire ﬁles, which is important for resolving
concurrent updates of the same entityﬁle in diﬀerent individuals.
Local version management is useful for backup if mistaken edits
have destroyed existing code, but it does not help if several users make
concurrent changes in a set of entityﬁles. This is what two-party version
management is for. In this case, there is one ‘server’ individual that
keeps track of updates by several users, and one ‘client’ that does its
own updates and sometimes ‘synchronizes’17 with the server. Such
17 This is the usual term, although it is of course a terrible misuse of the word
’synchronize’.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
329
synchronization must always be preceded by a local archiving action in
the client. Then, downward synchronization allows the client to update
its entityﬁles with those changes that have been incorporated into the
server at a time that succeeds the latest synchronized update in the
client. If the current entityﬁle version in the client is not a direct or
indirect predecessor of the version that is presently in the server, then
no change is made. After that, an upward synchronization identiﬁes
those entityﬁles whose contents still diﬀer between the server and the
client. If the version in the server precedes, directly or indirectly, the
current version in the client, then the current version in the client is
imposed on the server.
In the remaining cases, the system attempts to resolve concurrent
changes in a particular entityﬁle by going to the level of the individual
entities. If that is not suﬃcient, the user is asked to resolve the
inconsistency.
A particular technical problem arises because these synchronization
actions require the Leordo activation to read and compare several
versions of the same entityﬁle. The problem is that normally, reading
such a ﬁle makes assignments to attributes and properties of the entities
in the ﬁle, but for synchronization purposes one does not wish the
deﬁnitions in one ﬁle to replace the deﬁnitions that were obtained from
another ﬁle. This problem is solved using composite entities, as follows:
The procedure for reading an entityﬁle in KRE format has an optional
parameter whose value, if it is present, should be a symbolic function of
one argument. If it is absent then the ﬁle is read as usual. If it is present,
on the other hand, then that function is applied to each entity that is
read from the ﬁle, obtaining a ‘wrapped’ entity, and the attributes and
properties in the ﬁle are assigned to the wrapped entity. After this, the
comparisons and updates can proceed in the obvious way.
We have now seen two examples of how symbolic functions and
composite entities have been useful even for internal purposes within
the kernel. This illustrates the potential value of reorganizing the overall
software architecture so that certain, generally useful facilities are
brought into, or closer to the system kernel, instead of treating them as
speciﬁc to applications.
14.5.3 Conﬁguration and reproduction of individuals
One of the important ideas in Leordo is that the system shall be self-
aware, so that it is able to represent its own internal state, to analyze it
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

330
E. Sandewall
and to modify it, and it shall be able to represent and “understand” its
own history. Furthermore, all of this shall occur in persistent ways and
over calendar time, and not only within one activation or “run” of the
system.
We believe that these properties are important for a number of
applications, but in particular for those that belong to, or border on
artiﬁcial intelligence, for example for “intelligent agents”. A system that
acquires information during its interactions with users and with the
physical world, and that is able to learn from experience for example
using case-based techniques, will certainly need to have persistence. It
does not make sense for the system to start learning again each time a
new activation is started. It is then a natural step to also provide the
system with a sense of its own history.
One must then deﬁne what is “the system” that has that persistence
and sense of its own history. What if the software is stored in a server
and is used on a number of thin clients that only contain the activations?
What if several copies of it are taken and placed on diﬀerent hosts?
What if a copy of the system is placed on a USB stick so that it can be
used on several diﬀerent hosts?
In the case of Leordo, the answer is in principle that each individual is
a self-contained structure that contains all of the software that it needs.
Diﬀerent individuals may contain equal copies of that software, but in
addition each of them contains its own history and its own “experience”.
However, it is also perfectly possible for each individual to modify its
software so that it comes to diﬀer from the software of its peers.
What if additional copies (individuals) are needed, for example
because additional persons wish to use the system? The simplest
solution is to have an archive individual from which one takes copies for
distribution, but in any case that archive individual will change over
time, so a notion of version or generation of the entire individual will be
needed. But more importantly, separate strands of the Leordo species
may develop in diﬀerent directions, and a particular new user may be
more interested in obtaining a copy of his friend’s Leordo rather than
one from the archive.
In principle, a new individual that is obtained from a Leordo
individual by copying its software but erasing its history and other local
information, is to be considered as an “oﬀspring” and not as a “copy”.
If the copy is perfect and all history is preserved in it, then it shall be
called a “clone”. The administration of clones oﬀers additional problems
that will not be addressed here.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
331
For oﬀspring, the following conventions are adopted. The making of
an oﬀspring from an individual is to be considered as an action of that
individual, and is to be recorded in its history. Each individual has a
name, and the oﬀspring of a particular individual are numbered from 1
and up. No individual is allowed to have more than 999 oﬀspring. The
ﬁrst individual under this scheme was called lar, and its direct oﬀspring
are called lar-001, lar-002, etc. The oﬀspring of lar-002 are called
lar-002-001, lar-002-002, and so forth. The abbreviation lar stands
for “Leordo Ancestry Root”.
The overall convention for the population of Leordo individuals is now
that new individuals can only be produced as oﬀspring of existing ones,
so that the parent is aware of the oﬀspring being produced and so that
no name clashes can occur in the population. Additional information
about when and where oﬀspring are produced is of course valuable, but
can be considered as add-on information.
Notice in particular that version management information is not
inherited by oﬀspring, and they start with an empty backup directory
as well as an empty memory of past events.
In principle, each new individual should obtain a copy of all the
software of its parent. In practice this is quite inconvenient when several
individuals are stored on the same host; one would like them to be able
to share some of the software ﬁles. This has been implemented as follows:
Each individual may identify another individual that is known as its
“provider”, and when its index ﬁles specify the locations of entityﬁles,
they may refer both to ﬁles in its own structure, and ﬁles in its provider.
An individual is only allowed to update entityﬁles of its own, and is not
supposed to update entityﬁles in its provider.18 When a new individual
is created, then it is ﬁrst produced with a minimal number of ﬁles of its
own, and it relies on its parent as its provider for most of the entityﬁles.
After that, it is up to the oﬀspring to copy whatever software it needs
from its provider to itself, until it can cut that umbillical cord. Only
then is it in a position to migrate to other hosts. Besides, given adequate
software, it may be able to import knowledgeblocks and entityﬁles from
other individuals and not only from its parent.
What has been said so far applies to Leordo-speciﬁc software. In
addition, applications in Leordo will often need to access other software
that is available in the individual’s host for its current activation, for
18 This restriction is not enforced at present, but users violate it at their own risk.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

332
E. Sandewall
example text editors and formatters. The kernel contains a systematic
framework for administrating this.
Facilities for reproduction of individuals were ﬁrst developed in the
earlier project towards the Software Individuals Architecture. In that
project we considered reproduction and knowledge transfer between
individuals to be very central in the architecture, besides the abilities for
self-modelling. In our present approch reproduction has been relegated
to a somewhat less central position, due to the experience of the previous
project.
14.5.4 Other facilities in the kernel
The four knowledgeblocks in the kernel also contain a number of other
facilities that have not been described here. In particular, there is
a concept of a “process” in a particular sense of that word. Leordo
processes are persistent things, so they exist on calendar time and not
only within one activation of the system. Each process has its own
subdirectories where it maintains its local state between activations,
and each activation is an activation of one particular process. Each
process can only have one activation at a time, but diﬀerent processes
can have activations concurrently.
14.6 Platform facilities
The next layer in the Leordo software architecture, after the kernel, is
called the platform. This layer is under construction and is intended to be
open-ended, so that new contributions can be added continuously as the
need is identiﬁed and the implementation is completed. The following
are some platform-level knowledgeblocks that exist and are in use at
present.
14.6.1 Channels
Leordo channels are a mechanism for sending messages between
individuals, for the purpose of requesting actions or transmitting
information. Each channel connects two speciﬁc individuals for two-way,
ansynchronous communication and is associated with a number of
attributes, including one specifying the data format to be used for the
messages. The KRE data format is the default choice.
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
333
14.6.2 Communicable executive
The initial example in this article describing the interactions between
two Leordo individuals was executed using our communicable executive
(CX). The basic command-line executive in the kernel is not suﬃcient
for it. CX performs incessantly a cycle where it does three things:
• Check whether an input line has been received from the user. If so,
act on it.
• Check what messages have arrived in the incoming branch of the
currently connected channels for this individual. If so, pick up the
messages and act on them.
• Visit all the currently executing actions in the present individual, and
apply an update procedure that is attached to each of them. This
procedure may perform input and output, update the local state of the
action, and terminate the action with success or failure, if appropriate.
The communicable executive is a natural basis for several kinds of
applications, including for some kinds of robotic systems, dialog systems,
and simulation systems.
14.7 The implemented leordo system
14.7.1 History of the experimental implementation
The design for Leordo started in early 2005. It was based on the earlier
experience with the Software Individuals Architecture (SIA), and with
several earlier systems before that. The SIA was used as the platform
the a major part of the Link¨oping-WITAS Robotic Dialog Environment,
RDE,19 which contributed valuable background for the present system.
During the almost three years of Leordo development we have tried
to make ‘laboratory notes’ documenting what steps were taken, what
design changes were made, and so on. We shall study the possibility
of extracting a more concise account of essential design decisions and
design changes from these laboratory notes.
14.7.2 Current usage
The goal of the Leordo project, as stated in the introduction to this
article, is to validate or refute the project’s hypothesis concerning the
possibility of a fully integrated software system architecture. In order to
19 http://www.ida.liu.se/ext/casl/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

334
E. Sandewall
test this hypothesis it is necessary both to implement the system kernel,
and to use it for a few diﬀerent applications of widely diﬀerent character.
Two such applications have been fully implemented and are in regular
use. This is a way of checking that the system is always kept operational
while it is being revised and extended continuously.
The present author uses a Leordo-based software application as his
standard tool for the preparation of articles and other documents and
for website pages, including the extensive CAISOR website.20 This
application has been in daily use since the year 2006.
Secondly, Leordo is used for the management and extension of the
Common Knowledge Library and its website. This support system is a
fairly large collection of routines for acquisition, revision, and presen-
tation of structured information, including version management, IPR
management, and type checking of large information structures.
Plans for the future include the porting to Leordo of the previously
written applications for simulation of a robotic environment and for user
dialog with such a robot.
14.8 Discussion: the need for software system consolidation
The main goal of the Leordo project, as we stated initially, is to explore
the possibility of obtaining a much simpler design of the overall software
system in a computer, in particular by reorganizing and realigning its
major parts so as to eliminate duplication of concepts and of software
facilities. It is not yet possible to evaluate the concrete, experimental
Leordo system design against that goal, but it is possible to identify how
the new design relates to some of the concrete redundances in conven-
tional systems. They are listed here.
Duplication of procedural language between operating system (shell
scripts) and programming languages. In Leordo there is a host language
which may vary between generations of the system, but which shall in
any case be a language of the ‘interpretive’ or ‘script’ type, such as
Scheme, Python, etc. The Leordo kernel provides the command-script
situation, and the language can be extended with more facilities, and
restricted by using, for example, type system, in order to satisfy the
needs of other usage situations.
Duplication of notations
and
systems
for
type
declarations
of
data structures, between programming languages, database systems,
20 http://www.ida.liu.se/ext/caisor/
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

The Leordo computation system
335
communication systems e.g. CORBA, etc. The two-layered approach to
the type system in Leordo was explained in the beginning of Section
14.2. Exactly because the type system is not built into the system kernel,
we foresee that it shall be possible to design it in such a ﬂexible way
that it can satisfy the varying needs of several kinds of contemporary
type systems. This is of course one aspect of the main design hypothesis
that was stated at the beginning of the present report.
Scripting languages in various software tools, for example spreadsheet
systems, webpage languages such as Javascript, etc. The idea is that such
tools ought to be implemented based on the Leordo kernel and inherit
its facilities, including in particular the use of the host language.
Duplication between the ﬁle-directory system and database systems.
Although the present, temporary implementation of Leordo is based on
a conventional operating system and makes fairly extensive use of its
ﬁle system, the long-term idea is to replace it with an implementation
of entities and aggregates of entities that is done on directly on the base
software. This new information structure shall then subsume what the
ﬁle-directory system does today.
In the continued work on Leordo we are going to build a number
of applications for the purpose of obtaining additional experience with
these and other aspects of duplication. At the same time we shall be
vigilant in monitoring what new duplications may arise as the system
and the applications grow in size and complexity.
References
Due to the character of this material, most of the references are to
websites that provide information about a particular language or system.
These references have been placed in footnotes on the page where the
reference occurs.
References to published articles and released reports from the Leordo
project can be found on the project website.21 References to published
articles from the preceding Software Individuals Architecture project
(SIA) can be found on its past project website.22
21 http://www.ida.liu.se/ext/leonardo/
22 http://www.ida.liu.se/ext/caisor/systems/sia/page.html
https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

https://doi.org/10.1017/CBO9780511770524.015 Published online by Cambridge University Press

