CODE LISTINGS AND FIGURES

CHAPTER 1
Figure 1.1. Some of the concepts that underlie the Clojure philosophy, and how they
intersect
Table 1.1. Separation of concerns in Clojure
Conated
Separated
Where
Object with mutable elds
Values from
identities
Chapter 4 and
section 5.1
Class acts as a namespace for methods
Function
namespaces from
type namespaces
Sections 8.2 and 8.3
1
2
3
4
# This is Python code 
x = [5] 
process(x) 
x[0] = x[0] + 1

Conated
Separated
Where
Inheritance hierarchy made of classes
Hierarchy of names
from data and
functions
Chapter 8
Data and methods bound together
lexically
Data objects from
functions
Sections 6.1 and 6.2
and chapter 8
Method implementations embedded
throughout the class inheritance chain
Interface
declarations from
function
implementations
Sections 8.2 and 8.3
1
2
3
4
(for [x [:a :b], y (range 5) :when (odd? y)] 
  [x y]) 
 
;;=> ([:a 1] [:a 3] [:b 1] [:b 3])
1
2
3
4
5
6
7
8
(doseq [x [:a :b], y (range 5) :when (odd? y)] 
  (prn x y)) 
 
; :a 1 
; :a 3 
; :b 1 
; :b 3 
;;=> nil
1
2
3
myFunction(arg1, arg2); 
 
myThing.myMethod(arg1, arg2);
1
2
3
4
// THIS IS NOT CLOJURE CODE 
 
1 + 2 * 3; 
//=> 7

Figure 1.2. Right-to-left shufØe: the r->lfix  function shufØes math operators,
moving the rightmost in×x operations to the innermost nested parentheses to ensure
that they execute ×rst.
1
2
3
(my-function arg1 arg2) 
 
(.myMethod my-thing arg1 arg2)
1
2
(+ 1 (* 2 3)) 
;;=> 7
Listing 1.1. Function that solves math equations, evaluated right to left
1
2
3
4
(defn r->lfix 
  ([a op b]              (op a b)) 
  ([a op1 b op2 c]       (op1 a (op2 b c))) 
  ([a op1 b op2 c op3 d] (op1 a (op2 b (op3 c d)))))
1
2
3
4
(r->lfix 1 + 2) 
;;=> 3 
(r->lfix 1 + 2 + 3) 
;;=> 6
1
2
(r->lfix 1 + 2 * 3) 
;;=> 7

Figure 1.3. Left-to-right shufØe: the l->rfix  function shufØes math operators,
moving the leftmost in×x operations to the inner-most nested parentheses to ensure
that they execute ×rst.
1
2
(r->lfix 10 * 2 + 3) 
;;=> 50
1
2
3
4
// THIS IS NOT CLOJURE CODE 
 
10 * 2 + 3 
//=> 23
Listing 1.2. Function that solves math equations, evaluated left to right
1
2
3
4
(defn l->rfix 
  ([a op b]              (op a b)) 
  ([a op1 b op2 c]       (op2 c (op1 a b))) 
  ([a op1 b op2 c op3 d] (op3 d (op2 c (op1 a b)))))
1
2
(l->rfix 10 * 2 + 3) 
;;=> 23
1
2
(l->rfix 1 + 2 + 3) 
;;=> 6

1
2
(l->rfix 1 + 2 * 3) 
;;=> 9
1
2
(def order {+ 0   - 0 
            * 1   / 1})
Listing 1.3. Function that changes evaluation order depending on operation weights
1
2
3
4
(defn infix3 [a op1 b op2 c] 
  (if (< (get order op1) (get order op2)) 
    (r->lfix a op1 b op2 c) 
    (l->rfix a op1 b op2 c)))
1
2
3
4
5
(infix3 1 + 2 * 3) 
;;=> 7 
 
(infix3 10 * 2 + 3) 
;;=> 23
1
2
3
4
(< (+ 1 (* 2 3)) 
   (* 2 (+ 1 3))) 
 
;;=> true
1 (a-function arg1 arg2)

1
2
(+ 1 2 3 4 5 6 7 8 9 10) 
;;=> 55
1
2
3
4
// THIS IS NOT CLOJURE CODE 
 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10; 
//=> 55
1
2
3
4
5
6
int numbers[] = {1,2,3,4,5,6,7,8,9,10}; 
int sum = 0; 
 
for (int n : numbers) { 
    sum += n; 
}
1
2
3
(def numbers [1 2 3 4 5 6 7 8 9 10]) 
 
(apply + numbers)
1
2
3
4
// THIS IS NOT CLOJURE CODE 
 
0 < 42; 
//=> true
1
2
(< 0 42) 
;;=> true
1
2
(< 0 1 3 9 36 42 108) 
;;=> true

Figure 1.4. The word REPL hints at three repeated or looped phases: read, eval, and
print.
Figure 1.5. More REPL phases: Clojure also has macro-expansion and compilation
phases.
Figure 1.6. The reader takes a textual representation of a Clojure program and produces
the corresponding data structures.
Figure 1.7. The Runner. A child’s Øip book serves to illustrate Clojure’s notions of state,
time, and identity. The book itself represents the identity. Whenever you wish to show
1
2
(< 0 1 3 9 36 -1000 42 108) 
;;=> false
1
2
(+ 1 2) 
;;=> 3

a change in the illustration, you draw another picture and add it to the end of your Øip
book. The act of Øipping the pages therefore represents the states over time of the
image within. Stopping at any given page and observing the particular picture
represents the state of the Runner at that moment in time.
Figure 1.8. The Mutable Runner. Modeling state change with mutation requires that
you stock up on erasers. Your book becomes a single page: in order to model changes,
you must physically erase and redraw the parts of the picture requiring change. Using
this model, you should see that mutation destroys all notion of time, and state and
identity become one.
Listing 1.4. Polymorphic Concatenatable  protocol
1
2
(defprotocol Concatenatable 
  (cat [this other]))

Figure 1.9. The corresponding chessboard layout
1
2
3
4
5
6
7
8
9
(extend-type String 
  Concatenatable 
  (cat [this other] 
    (.concat this other))) 
;;=> nil 
 
(cat "House" " of Leaves") 
 
;;=> "House of Leaves"
1
2
3
4
5
6
7
8
(extend-type java.util.List 
  Concatenatable 
  (cat [this other] 
    (concat this other))) 
 
(cat [1 2 3] [4 5 6]) 
 
;;=> (1 2 3 4 5 6)
Listing 1.5. Simple chessboard representation in Clojure
1
2
3
4
5
6
7
8
9
10
(ns joy.chess) 
(defn initial-board [] 
  [\r \n \b \q \k \b \n \r 
   \p \p \p \p \p \p \p \p  
   \- \- \- \- \- \- \- \- 
   \- \- \- \- \- \- \- \- 
   \- \- \- \- \- \- \- \- 
   \- \- \- \- \- \- \- \- 
   \P \P \P \P \P \P \P \P  
   \R \N \B \Q \K \B \N \R])
1
2

Listing 1.6. Querying the squares of a chessboard
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(def ^:dynamic *file-key* \a) 
(def ^:dynamic *rank-key* \0) 
(defn- file-component [file] 
  (- (int file) (int *file-key*))) 
(defn- rank-component [rank] 
  (->> (int *rank-key*) 
       (- (int rank)) 
       (- 8) 
       (* 8))) 
(defn- index [file rank] 
  (+ (file-component file) (rank- 
 component rank))) 
(defn lookup [board pos] 
  (let [[file rank] pos] 
    (board (index file rank)))) 
(lookup (initial-board) "a1") 
;;=> \R
1
2
3
Listing 1.7. Using block-level encapsulation
1
2
3
4
5
6
7
8
9
10
11
(letfn [(index [file rank] 
          (let [f (- (int file) (int \a)) 
                r (* 8 (- 8 (- (int rank) (int \0))))] 
 
            (+ f r)))] 
  (defn lookup2 [board pos] 
    (let [[file rank] pos] 
      (board (index file rank))))) 
 
(lookup2 (initial-board) "a1") 
;;=> \R

Listing 1.8. Local encapsulation
1
2
3
4
5
6
7
8
9
10
(defn lookup3 [board pos] 
  (let [[file rank] (map int pos) 
        [fc rc]     (map int [\a \0]) 
        f (- file fc) 
        r (* 8 (- 8 (- rank rc))) 
        index (+ f r)] 
    (board index))) 
 
(lookup3 (initial-board) "a1") 
;;=> \R

CHAPTER 2
1 user>
1
2
3
4
5
6
user> 42    ; numbers evaluate to themselves 
;=> 42 
user> "The Misfits" ; strings do too 
;=> "The Misfits" 
user> :pyotr  ; as do keywords 
;=> :pyotr
1
2
3
4
42 
+9 
-107 
991778647261948849222819828311491035886734385827028118707676848307166514
1
2
[127 0x7F 0177 32r3V 2r01111111] 
;=> [127 127 127 127 127]
1
2
3
4
5
6
7
1.17 
+1.22 
-2. 
 
366e7 
32e-14 
10.7e-3
1
2
3
4
22/7 
-7/22 
1028798300297636767687409028872/88829897008789478784 
-103/4

1
2
3
4
(def yucky-pi 22/7) 
 
yucky-pi 
;;=> 22/7
1
2
3
4
:chumby 
:2 
:? 
:ThisIsTheNameOfaKeyword
1
2
3
"This is a string" 
"This is also a 
         String"
1
2
3
4
5
\a       ; The character lowercase a 
\A       ; The character uppercase A 
\u0042   ; The Unicode character uppercase B 
\\       ; The back-slash character \ 
\u30DE   ; The Unicode katakana character ?
1 (yankee hotel foxtrot)
1
2
3
4
(1 2 3 4) 
() 
(:fred ethel) 
(1 2 (a b c) 4 5)

1 [1 2 :a :b :c]
1 {1 "one", 2 "two", 3 "three"}
1 #{1 2 "three" :four 0x5}
1
2
(vector 1 2 3) 
;;=> [1 2 3]
1
2
1 (def x 42)
1
2
3
(def y) 
y 
;=> java.lang.IllegalStateException: Var user/y is unbound.

1
2
3
4
5
(fn [x y] 
   (println "Making a set") 
   #{x y}) 
 
;;=> #<user$eval1027$fn__1028 user$eval1027$fn__1028@e324105>
1
2
3
1
2
3
4
5
6
((fn [x y] 
    (println "Making a set") 
   #{x y}) 
  1 2) 
;; Making a set 
 ;;=> #{1 2}
1
2
3
1
2
3
4
(def make-set 
  (fn [x y] 
    (println "Making a set") 
    #{x y}))
1
2
3
4
(make-set 1 2) 
 
;; Making a set 
;;=> #{1 2}
1
2
3
4
5
(defn make-set 
  "Takes two values and makes a set from them." 
  [x y] 
  (println "Making a set") 
#{x y})

1
2
3
(defn make-set 
  ([x] #{x}) 
  ([x y] #{x y}))
1
2
(make-set 42) 
;;=> #{42}
1
2
(make-set 1 2 3) 
;; ArityException Wrong number of args passed...
1
2
3
4
5
6
7
8
9
10
11
(defn arity2+ [first second & more] 
   (vector first second more)) 
 
(arity2+ 1 2) 
 ;;=> [1 2 nil] 
 
(arity2+ 1 2 3 4) 
 ;;=> [1 2 (3 4)] 
 
(arity2+ 1) 
 ;; ArityException Wrong number of args passed...
1
2
3
4
1
2
3
4
5
6
7
8
9
10
(def make-list0  #(list)) 
(make-list0) 
;;=> () 
 
(def make-list2  #(list %1 %2)) 
  
(make-list2 1 2) 
;;=> (1 2) 
 
(def make-list2+ #(list %1 %2 %&)) 
1
2
3

11
12
13
  
(make-list2+ 1 2 3 4 5) 
;;=> (1 2 (3 4 5))
1
2
3
4
5
6
7
(do 
  (def x 5) 
  (def y 4) 
  (+ x y) 
  [x y]) 
 
;;=> [5 4]
1
2
3
4
5
6
7
8
(let [r         5 
      pi        3.1415 
      r-squared (* r r)] 
  (println "radius is" r) 
  (* pi r-squared)) 
 
;; radius is 5 
;;=> 78.53750000000001
1
2
3
4
(defn print-down-from [x] 
  (when (pos? x) 
     (println x) 
     (recur (dec x))))
1
2
3
1
2
3
4
(defn sum-down-from [sum x] 
   (if (pos? x) 
     (recur (+ sum x) (dec x)) 
     sum))
1
2
3
4

Figure 2.1. A graphical representation of the sum-down-from  function
1
2
(sum-down-from 0 10) 
;=> 55
1
2
3
4
5
(defn sum-down-from [initial-x] 
  (loop [sum 0, x initial-x] 
    (if (pos? x) 
      (recur (+ sum x) (dec x)) 
       sum)))
1
2
1
2
3
4
(defn absolute-value [x] 
  (if (pos? x) 
    x            ; "then" clause 
    (- x)))      ; "else" clause
1
2
3
(fn [x] (recur x) (println x)) 
; java.lang.UnsupportedOperationException: 
;    Can only recur from tail position
1 (cons 1 [2 3])

1
2
cons 
;=> #<core$cons__3806 clojure.core$cons__3806@24442c76>
1
2
1 
;=> 1
1
2
[2 3] 
;=> [2 3]
1
2
(cons 1 [2 3]) 
;=> (1 2 3)
1 (quote age)
1
2
3
(def age 9) 
(quote age) 
;=> age
1
2
(quote (cons 1 [2 3])) 
;=> (cons 1 [2 3])

1
2
3
(cons 1 (2 3)) 
; java.lang.ClassCastException: 
;    java.lang.Integer cannot be cast to clojure.lang.IFn
1
2
(cons 1 (quote (2 3))) 
;=> (1 2 3)
1
2
(cons 1 '(2 3)) 
;=> (1 2 3)
1
2
[1 (+ 2 3)]      ;=> [1 5] 
'(1 (+ 2 3))     ;=> (1 (+ 2 3))
1
2
`(1 2 3) 
;=> (1 2 3)
1
2
3
clojure.core/map 
clojure.set/union 
i.just.made.this.up/quux
1
2
3
4
5
6
`map 
;=> clojure.core/map 
`Integer 
;=> java.lang.Integer 
`(map even? [1 2 3]) 
;=> (clojure.core/map clojure.core/even? [1 2 3])

1
2
`is-always-right 
;=> user/is-always-right
1
2
3
4
5
`(+ 10 (* 3 2)) 
;=> (clojure.core/+ 10 (clojure.core/* 3 2)) 
 
`(+ 10 ~(* 3 2)) 
;=> (clojure.core/+ 10 6)
1
2
3
4
5
6
7
(let [x 2] 
`(1 ~x 3)) 
;=> (1 2 3) 
 
`(1 ~(2 3)) 
;; ClassCastException java.lang.Long 
;;  cannot be cast to clojure.lang.IFn
1
2
(let [x '(2 3)] `(1 ~x)) 
;=> (1 (2 3))
1
2
(let [x '(2 3)] `(1 ~@x)) 
;=> (1 2 3)
1
2
`potion# 
;=> potion__211__auto__
1
2
java.util.Locale/JAPAN 
;=> #<Locale ja_JP>

1
2
(Math/sqrt 9) 
;=> 3.0
1
2
3
(new java.awt.Point 0 1) 
 
;=> #<Point java.awt.Point[x=0,y=1]>
1
2
(new java.util.HashMap {"foo" 42 "bar" 9 "baz" "quux"}) 
;=> {"baz" "quux", "foo" 42, "bar" 9}
1
2
(java.util.HashMap. {"foo" 42 "bar" 9 "baz" "quux"}) 
;=> {"baz" "quux", "foo" 42, "bar" 9}
1
2
(js/Date.) 
;=> #inst "2013-02-01T15:10:44.727-00:00"
1
2
(.-x (java.awt.Point. 10 20)) 
;=> 10
1
2
(.divide (java.math.BigDecimal. "42") 2M) 
;=> 21M

1
2
3
4
(let [origin (java.awt.Point. 0 0)] 
  (set! (.-x origin) 15) 
  (str origin)) 
;=> "java.awt.Point[x=15,y=0]"
1 new java.util.Date().toString().endsWith("2014") /* Java code */
1
2
(.endsWith (.toString (java.util.Date.)) "2014") ; Clojure code 
;=> true
1
2
(.. (java.util.Date.) toString (endsWith "2014")) 
;=> true
1
2
3
4
5
// This is Java, not Clojure 
java.util.HashMap props = new java.util.HashMap(); 
props.put("HOME", "/home/me");        /* More java code. Sorry. */ 
props.put("SRC",  "src"); 
props.put("BIN",  "classes");
1
2
3
4
5
6
(doto (java.util.HashMap.) 
  (.put "HOME" "/home/me") 
  (.put "SRC"  "src") 
  (.put "BIN"  "classes")) 
 
;=> {"HOME" "/home/me", "BIN" "classes", "SRC" "src"}
1
2
(throw (Exception. "I done throwed")) 
;=> java.lang.Exception: I done throwed ...

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
(defn throw-catch [f] 
  [(try 
    (f) 
    (catch ArithmeticException e "No dividing by zero!") 
    (catch Exception e (str "You are so bad " (.getMessage e))) 
    (finally (println "returning... ")))]) 
 
(throw-catch #(/ 10 5)) 
; returning... 
;=> [2] 
 
(throw-catch #(/ 10 0)) 
; returning... 
;=> ["No dividing by zero!"] 
 
(throw-catch #(throw (Exception. "Crybaby"))) 
; returning... 
;=> ["You are so bad Crybaby"]
1
2
3
4
(try 
  (throw (Error. "I done throwed in CLJS")) 
  (catch js/Error err "I done catched in CLJS")) 
;=> "I done catched in CLJS"
1 (ns joy.ch2)
1 joy.ch2=>
1
2
3
4
5
6
7
8
joy.ch2=> (defn hello [] 
  (println "Hello Cleveland!")) 
 
joy.ch2=> (defn report-ns [] 
  (str "The current namespace is " *ns*)) 
 
joy.ch2=> (report-ns) 
;=> "The current namespace is joy.ch2"

1
2
joy.ch2=> hello 
;=> #<ch2$hello joy.ch2$hello@2af8f5>
1
2
3
(ns joy.another) 
 
joy.another=>
1
2
3
joy.another=> (report-ns) 
; java.lang.Exception: 
;   Unable to resolve symbol: report-ns in this context
1
2
3
4
5
6
(ns joy.req 
  (:require clojure.set)) 
 
(clojure.set/intersection #{1 2 3} #{3 4 5}) 
  
;;=> #{3}
1
1
2
3
4
5
(ns joy.req-alias 
  (:require [clojure.set :as s])) 
 
(s/intersection #{1 2 3} #{3 4 5}) 
;=> #{3}
1
2
3
4
5
clojure.set 
 ; java.lang.ClassNotFoundException: clojure.set 
 
java.lang.Object 
 ;=> java.lang.Object
1
2

1
2
3
4
(ns joy.use-ex 
  (:require [clojure.string :refer (capitalize)])) 
(map capitalize ["kilgore" "trout"]) 
;=> ("Kilgore" "Trout")
1
2
3
4
5
(ns joy.yet-another 
  (:refer joy.ch2)) 
 
(report-ns) 
;=> "The current namespace is joy.yet-another"
1
2
3
4
5
(ns joy.yet-another 
  (:refer clojure.set :rename {union onion})) 
 
(onion #{1 2} #{4 5}) 
; => #{1 2 4 5}
(ns joy.java 
 (:import [java.util HashMap] 
          [java.util.concurrent.atomic AtomicLong])) 
(HashMap. {"happy?" true}) 
;=> {"happy?" true} 
(AtomicLong. 42) 
;=> 42

CHAPTER 3
1
2
3
4
(if true :truthy :falsey)  ;=> :truthy 
(if [] :truthy :falsey)    ;=> :truthy 
(if nil :truthy :falsey)   ;=> :falsey 
(if false :truthy :falsey) ;=> :falsey
1 (def evil-false (Boolean. "false")) ; NEVER do this
1
2
evil-false 
;=> false
1
2
(= false evil-false) 
;=> true
1
2
(if evil-false :truthy :falsey) 
;=> :truthy
1
2
(if (Boolean/valueOf "false") :truthy :falsey) 
;=> :falsey

1
2
(when (nil? nil) "Actually nil, not false") 
;=> "Actually nil, not false"
1
2
3
4
5
(seq [1 2 3]) 
;=> (1 2 3) 
 
(seq []) 
;=> nil
1
2
3
4
(defn print-seq [s] 
  (when (seq s) 
    (prn (first s)) 
    (recur (rest s))))
1
2
1
2
(print-seq []) 
;=> nil
1
2
3
4
(print-seq [1 2]) 
; 1 
; 2 
;=> nil
1
2
3
4
5
6
(def guys-whole-name ["Guy" "Lewis" "Steele"]) 
 
(str (nth guys-whole-name 2) ", " 
     (nth guys-whole-name 0) " " 
     (nth guys-whole-name 1)) 
;=> "Steele, Guy Lewis"

POSITIONAL DESTRUCTURING
This positional destructuring doesn’t work on maps and sets because
they’re not logically[3] aligned sequentially. Interestingly, positional
destructuring works with Java’s java.util.regex.Matcher :
3 Technically, positional destructuring might make sense with sorted
sets and maps, but alas it doesn’t operate as such because Clojure
doesn’t consider them to be sequential collections. See section 5.2.
Although it’s possible to destructure a Matcher  object, a better
solution would be to destructure the result of (re-find rem)
instead. Finally, positional destructuring also works for anything
implementing the CharSequence  and java.util.Random-Access
interfaces.
1
2
(let [[f-name m-name l-name] guys-whole-name] 
  (str l-name ", " f-name " " m-name))
1
2
3
4
5
6
7
8
(def date-regex #"(\d{1,2})\/(\d{1,2})\/(\d{4})") 
 
(let [rem (re-matcher date-regex "12/02/1975")] 
  (when (.find rem) 
     (let [[_ m d] rem] 
       {:month m :day d}))) 
 
;;=> {:month "12", :day "02"}
1
2
3
4
5
6
(let [[a b c & more] (range 10)] 
  (println "a b c are:" a b c) 
  (println "more is:" more)) 
; a b c are: 0 1 2 
; more is: (3 4 5 6 7 8 9) 
;=> nil
1
2
3
(let [range-vec (vec (range 10)) 
      [a b c & more :as all] range-vec] 
  (println "a b c are:" a b c) 

4
5
6
7
8
9
  (println "more is:" more) 
  (println "all is:" all)) 
; a b c are: 0 1 2 
; more is: (3 4 5 6 7 8 9) 
; all is: [0 1 2 3 4 5 6 7 8 9] 
;=> nil
1
2
(def guys-name-map 
  {:f-name "Guy" :m-name "Lewis" :l-name "Steele"})
1
2
3
4
(let [{f-name :f-name, m-name :m-name, l-name :l-name} guys-name-map] 
  (str l-name ", " f-name " " m-name)) 
 
;=> "Steele, Guy Lewis"
1
2
3
4
(let [{:keys [f-name m-name l-name]} guys-name-map] 
  (str l-name ", " f-name " " m-name)) 
 
;=> "Steele, Guy Lewis"
1
2
3
4
5
6
7
(let [{f-name :f-name, :as whole-name} guys-name-map] 
  (println "First name is" f-name) 
  (println "Whole name is below:") 
  whole-name) 
;; First name is Guy 
;; Whole name is below: 
;;=> {:f-name "Guy", :m-name "Lewis", :l-name "Steele"}
1
2
3
4
(let [{:keys [title f-name m-name l-name], 
       :or {title "Mr."}} guys-name-map] 
  (println title f-name m-name l-name)) 
 

5
6
; Mr. Guy Lewis Steele 
;=> nil
1
2
3
4
5
6
(defn whole-name [& args] 
  (let [{:keys [f-name m-name l-name]} args] 
    (str l-name ", " f-name " " m-name))) 
 
(whole-name :f-name "Guy" :m-name "Lewis" :l-name "Steele") 
;=> "Steele, Guy Lewis"
1
2
3
(let [{first-thing 0, last-thing 3} [1 2 3 4]] 
  [first-thing last-thing]) 
;=> [1 4]
1
2
3
4
5
(defn print-last-name [{:keys [l-name]}] 
  (println l-name)) 
 
(print-last-name guys-name-map) 
; Steele
1
2
(range 5) 
;=> (0 1 2 3 4)
1
2
(for [x (range 2) y (range 2)] [x y]) 
;=> ([0 0] [0 1] [1 0] [1 1])
1
2
(xor 1 2) 
;=> java.lang.Exception: Unable to resolve symbol: xor in this context

1
2
3
4
5
6
(find-doc "xor") 
; ------------------------- 
; clojure.core/bit-xor 
; ([x y]) ([x y & more]) 
;   Bitwise exclusive or 
;=> nil
1
2
(bit-xor 1 2) 
;=> 3
1
2
3
4
(for [x (range 2) y (range 2)] 
  [x y (bit-xor x y)]) 
 
;=> ([0 0 0] [0 1 1] [1 0 1] [1 1 0])
1
2
3
4
5
6
(defn xors [max-x max-y] 
  (for [x (range max-x) y (range max-y)] 
       [x y (bit-xor x y)])) 
 
(xors 2 2) 
;=> ([0 0 0] [0 1 1] [1 0 1] [1 1 0])
1
2
(def frame (java.awt.Frame.)) 
;=> #'user/frame
1
2
frame 
;=> #<Frame java.awt.Frame[frame0,0,22,0x0,invalid,hidden,...]>
1
2
3
(for [meth (.getMethods java.awt.Frame) 
       :let [name (.getName meth)]  
       :when (re-find #"Vis" name)] 
1
2
3

4
5
6
   name) 
 
;=> ("setVisible" "isVisible")
1
2
(.isVisible frame) 
;=> false
1
2
(.setVisible frame true) 
;=> nil
1
2
(.setSize frame (java.awt.Dimension. 200 200)) 
;=> nil
1
2
(def gfx (.getGraphics frame)) 
;=> #'user/gfx
1 (.fillRect gfx 100 100 50 75)
1
2
(.setColor gfx (java.awt.Color. 255 128 0)) 
(.fillRect gfx 100 150 75 50)
1
2
3
(doseq [[x y xor] (xors 200 200)] 
  (.setColor gfx (java.awt.Color. xor xor xor)) 
  (.fillRect gfx x y 1 1))

Figure 3.1. Visualization of xor. This is the graphic drawn by the 10 or so lines of code
we’ve looked at so far—a visual representation of Clojure’s bit-xor  function.
1
2
3
4
5
(doseq [[x y xor] (xors 500 500)] 
  (.setColor gfx (java.awt.Color. xor xor xor)) 
  (.fillRect gfx x y 1 1)) 
; java.lang.IllegalArgumentException: 
;    Color parameter outside of expected range: Red Green Blue
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(.printStackTrace *e) 
; java.lang.IllegalArgumentException: Color parameter outside of 
;         expected range: Red Green Blue 
; at clojure.lang.Compiler.eval(Compiler.java:4639) 
; at clojure.core$eval__5182.invoke(core.clj:1966) 
; at clojure.main$repl__7283$read_eval_print__7295.invoke(main.clj:180) 
; ...skipping a bit here... 
; Caused by: java.lang.IllegalArgumentException: Color parameter 
 
;         outside of expected range: Red Green Blue 
; at java.awt.Color.testColorValueRange(Color.java:298) 
; at java.awt.Color.<init>(Color.java:382) 
; ...skipping a bit more... 
; ... 11 more 
;=> nil
1 at java.awt.Color.testColorValueRange(Color.java:298)
1 at <class>.<method or constructor>(<filename>:<line>)

1 at java.awt.Color.<init>(Color.java:382)
1 ... 11 more
1
2
3
(defn xors [xs ys] 
  (for [x (range xs) y (range ys)] 
    [x y (rem (bit-xor x y) 256)]))
1 (defn clear [g] (.clearRect g 0 0 200 200))
1
2
3
(defn f-values [f xs ys] 
  (for [x (range xs) y (range ys)] 
    [x y (rem (f x y) 256)]))
1
2
3
4
5
6
(defn draw-values [f xs ys] 
  (clear gfx) 
  (.setSize frame (java.awt.Dimension. xs ys)) 
  (doseq [[x y v] (f-values f xs ys)] 
    (.setColor gfx (java.awt.Color. v v v)) 
    (.fillRect gfx x y 1 1)))
1
2
3
(draw-values bit-and 256 256) 
(draw-values + 256 256) 
(draw-values * 256 256)

Figure 3.2. The draw-values  function you’ve written can be used to create a variety
of graphics. Here are examples, from left to right, of bit-and , + , and * .

CHAPTER 4
1
2
3
4
5
6
7
8
9
10
11
(let [imadeuapi 3.14159265358979323846264338327950288419716939937M] 
  (println (class imadeuapi)) 
  imadeuapi) 
; java.math.BigDecimal 
;=> 3.14159265358979323846264338327950288419716939937M 
 
(let [butieatedit 3.14159265358979323846264338327950288419716939937] 
  (println (class butieatedit)) 
  butieatedit) 
; java.lang.Double 
;=> 3.141592653589793
1
2
3
4
5
6
7
8
9
10
11
12
13
(def clueless 9) 
 
(class clueless)  
;=> java.lang.Long  
  
(class (+ clueless 9000000000000000))  
;=> java.lang.Long  
  
(class (+ clueless 90000000000000000000)) 
;=> clojure.lang.BigInt 
  
(class (+ clueless 9.0)) 
;=> java.lang.Double
1
2
3
4
1
2
(+ Long/MAX_VALUE Long/MAX_VALUE) 
;=> java.lang.ArithmeticException: integer overflow
1
2
(unchecked-add (Long/MAX_VALUE) (Long/MAX_VALUE)) 
;=> -2

1
2
3
4
5
(float 0.0000000000000000000000000000000000000000000001) 
;=> 0.0 
 
1.0E-430 
;=> 0.0
1
2
3
4
5
6
7
8
(let [approx-interval  (/ 209715 2097152) 
       actual-interval (/ 1 10) 
       hours           (* 3600 100 10) 
      actual-total    (double (* hours actual-interval)) 
      approx-total    (double (* hours approx-interval))] 
  (- actual-total approx-total)) 
 
;=> 0.34332275390625
1
2
1
2
(+ 0.1M 0.1M 0.1M 0.1 0.1M 0.1M 0.1M 0.1M 0.1M 0.1M) 
;=> 0.9999999999999999
1
2
3
4
5
1.0E-430000000M 
;=> 1.0E-430000000M 
 
1.0E-4300000000M 
;=> java.lang.RuntimeException: java.lang.NumberFormatException
1
2
3
4
5
6
7
8
(let [approx-interval  (/ 209715 2097152) 
       actual-interval (/ 1 10) 
       hours           (* 3600 100 10) 
      actual-total    (double (* hours actual-interval)) 
      approx-total    (double (* hours approx-interval))] 
  (- actual-total approx-total)) 
 
;=> 0.34332275390625
1
2
1
2
3
4
(def a (rationalize 1.0e50)) 
(def b (rationalize -1.0e50)) 
(def c (rationalize 17.0e00)) 
(+ (+ a b) c) 

5
6
7
;;=> 17N 
(+ a (+ b c)) 
;;=> 17N
1
1
2
3
4
(numerator (/ 123 10)) 
;=> 123 
(denominator (/ 123 10)) 
;=> 10
1
2
3
4
5
6
7
:a-keyword 
 
;;=> :a-keyword 
 
::also-a-keyword 
 
;;=> :user/also-a-keyword
1
2
3
4
5
6
7
8
9
(def population {:zombies 2700, :humans 9}) 
 
(get population :zombies) 
;=> 2700 
 
(println (/ (get population :zombies) 
            (get population :humans)) 
         "zombies per capita") 
; 300 zombies per capita
1
2
3
4
5
6
7
(:zombies population) 
;=> 2700 
 
(println (/ (:zombies population) 
            (:humans population)) 
         "zombies per capita") 
; 300 zombies per capita

SEPARATING THE PLUMBING FROM THE DOMAIN
Even though qualied keywords can have any arbitrary prex,
sometimes it’s useful to use namespaces to provide special
information for keywords. In a namespace named crypto , the
keywords ::rsa  and ::blowfish  make sense as being namespace
qualied. Similarly, if you create a namespace aquarium , then using
::blowfish  in it is contextually meaningful. Likewise, when adding
metadata to structures, you should consider using qualied keywords
as keys and directives if their intention is domain oriented. Consider
the following code:
Listing 4.1. Using a keyword as a function directive
1
2
3
4
5
6
7
8
(defn pour [lb ub] 
  (cond 
    (= ub :toujours) (iterate inc lb) 
    :else (range lb ub))) 
(pour 1 10) 
 ;=> (1 2 3 4 5 6 7 8 9) 
(pour 1 :toujours) 
 ; ... runs forever
1
2
1
2
::not-in-ns 
;=> :user/not-in-ns
1
2
3
4
5
(ns another) 
 
another=> :user/in-another 
 
;=> :user/in-another
1
2
:haunted/name 
;=> :haunted/name

When switching to di|erent namespaces using ns , you can use the
namespacequalied keyword syntax to ensure that the correct
domain-specic code path is executed.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(defn do-blowfish [directive] 
  (case directive 
    :aquarium/blowfish (println "feed the fish") 
    :crypto/blowfish   (println "encode the message") 
    :blowfish          (println "not sure what to do"))) 
(ns crypto) 
(user/do-blowfish :blowfish) 
; not sure what to do 
 
(user/do-blowfish ::blowfish) 
; encode the message 
(ns aquarium) 
(user/do-blowfish :blowfish) 
; not sure what to do 
(user/do-blowfish ::blowfish) 
; feed the fish
1
2
(identical? 'goat 'goat) 
;=> false
1
2
3
4
5
(= 'goat 'goat) 
;=> true 
 
(name 'goat) 
"goat"
1
2
3
4
(let [x 'goat, y x] 
  (identical? x y)) 
 
;=> true
1
2
3
4
5
(let [x (with-meta 'goat {:ornery true}) 
      y (with-meta 'goat {:ornery false})] 
  [(= x y) 
   (identical? x y) 
   (meta x) 

6
7
8
   (meta y)]) 
 
;=> [true false {:ornery true} {:ornery false}]
1
2
3
4
5
6
7
8
9
10
11
(ns where-is) 
(def a-symbol 'where-am-i) 
 
a-symbol 
;=> where-am-i 
 
(resolve 'a-symbol) 
;=> #'where-is/a-symbol 
 
`a-symbol 
;=> where-is/a-symbol
1
2
3
4
5
(defn best [f xs] 
  (reduce #(if (f % %2) % %2) xs)) 
 
(best > [1 3 4 2 7 5 3]) 
;=> 7
1
2
3
4
5
6
7
8
;; This is Common Lisp and NOT Clojure code 
(defun best (f xs) 
  (reduce #'(lambda (l r) 
               (if (funcall f l r) l r)) 
          xs)) 
 
(best #'> '(1 3 4 2 7 5 3)) 
;=> 7
1 #"an example pattern"

Table 4.1. Flags that can be used in Clojure regular-expression patterns, along with their
long name and a description of what they do. See Java’s documentation for the
java.util.regex.Pattern  class for more details.
Flag
Flag name
Description
d
UNIX_LINES
., ^, and $ match only the Unix line terminator
'\n'.
i
CASE_INSENSITIVE
ASCII characters are matched without regard to
uppercase or lowercase.
x
COMMENTS
Whitespace and comments in the pattern are
ignored.
m
MULTILINE
^ and $ match near line terminators instead of
only at the beginning or end of the entire input
string.
s
DOTALL
. matches any character including the line
terminator.
u
UNICODE_CASE
Causes the i ag to use Unicode case insensitivity
instead of ASCII.
1
2
(class #"example") 
;=> java.util.regex.Pattern
1
2
(java.util.regex.Pattern/compile "\\d") 
;=> #"\d"
1
2
(re-seq #"\w+" "one-two/three") 
;=> ("one" "two" "three")
1
2
(re-seq #"\w*(\w)" "one-two/three") 
;=> (["one" "e"] ["two" "o"] ["three" "e"])


CHAPTER 5
Table 5.1. Sequence terms in brief
Term
Brief description
Example(s)
Collection
A composite data type
[1 2], {:a 1}, #{1 2}, and lists and arrays
Sequential
Ordered series of values
[1 2 3 4], (1 2 3 4)
Sequence
A sequential collection
that may or may not
exist yet
The result of (map a-fun a-collection)
Seq
Simple API for
navigating collections
rst, rest, nil, and ()
clojure.core/seq
A function that returns
an object implementing
the seq API
(seq []) ;;=> nil and (seq [1 2]) ;;=> (1
2)
1
2
3
(def ds (into-array [:willie :barnabas :adam]))  
(seq ds) 
;=> (:willie :barnabas :adam)
1
1
2
3
4
(aset ds 1 :quentin) 
;=> :quentin 
(seq ds) 
;=> (:willie :quentin :adam)
1
1
2
3
4
5
6
7
8
(def ds [:willie :barnabas :adam]) 
ds 
;=> [:willie :barnabas :adam] 
(def ds1 (replace {:barnabas :quentin} ds)) 
ds 
;=> [:willie :barnabas :adam] 
ds1 
;=> [:willie :quentin :adam]
1
2
3

Figure 5.1. Each cons-cell is a simple pair, a car  and a cdr . (A) A list with two cells,
each of which has a value— x  and y , respectively—as the head (the car  in Lisp
terminology) and a list as the tail (the cdr ). This is very similar to first  and rest
in Clojure sequences. (B) A cons-cell with a simple value for both the head and tail. This
is called a dotted pair but is not supported by any of Clojure’s built-in types.
1
2
(= [1 2 3] '(1 2 3)) 
;=> true
1
2
(= [1 2 3] #{1 2 3}) 
;=> false
1
2
(class (hash-map :a 1)) 
;=> clojure.lang.PersistentHashMap
1
2
3
4
5
(seq (hash-map :a 1)) 
;=> ([:a 1]) 
 
(class (seq (hash-map :a 1))) 
;=> clojure.lang.PersistentHashMap$NodeSeq
1
2
3
4
5
(seq (keys (hash-map :a 1))) 
;=> (:a) 
 
(class (keys (hash-map :a 1))) 
;=> clojure.lang.APersistentMap$KeySeq

Figure 5.2. In Big-O, regardless of the other ancillary costs, the higher order of
magnitude always overtakes the lower eventually.
1
2
(vec (range 10)) 
;=> [0 1 2 3 4 5 6 7 8 9]
1
2
3
(let [my-vector [:a :b :c]] 
  (into my-vector (range 10))) 
;=> [:a :b :c 0 1 2 3 4 5 6 7 8 9]
1
2
3
4
5
6
7
(into (vector-of :int) [Math/PI 2 1.3]) 
;=> [3 2 1] 
(into (vector-of :char) [100 101 102]) 
;=> [\d \e \f] 
(into (vector-of :int) [1 2 623876371267813267326786327863]) 
;  java.lang.IllegalArgumentException: Value out of range for int: 
     -8359803716404783817
1
2
3
(def a-to-j (vec (map char (range 65 75)))) 
  
1

Table 5.2. Vector lookup options: the three ways to look up an item in a vector, and how
each responds to different exceptional circumstances
 
nth
get
Vector as a function
If the vector is nil
Returns nil
Returns nil
Throws an
exception
If the index is out
of range
Throws exception
by default or
returns a “not
found” if supplied
Returns nil
Throws an
exception
Supports a “not
found” arg
Yes (nth [] 9
:whoops)
Yes (get [] 9
:whoops)
No
4 a-to-j 
;;=> [\A \B \C \D \E \F \G \H \I \J]
1
2
3
4
5
6
7
8
(nth a-to-j 4) 
;;=> \E 
 
(get a-to-j 4) 
;;=> \E 
 
(a-to-j 4) 
;;=> \E
1
2
3
4
5
(seq a-to-j) 
;=> (\A \B \C \D \E \F \G \H \I \J) 
 
(rseq a-to-j) 
;=> (\J \I \H \G \F \E \D \C \B \A)
1
2
(assoc a-to-j 4 "no longer E") 
;=> [\A \B \C \D "no longer E" \F \G \H \I \J]

1
2
(replace {2 :a, 4 :b} [1 2 3 2 3 4]) 
;=> [1 :a 3 :a 3 :b]
1
2
3
4
5
(def matrix 
     [[1 2 3] 
 
      [4 5 6] 
      [7 8 9]])
1
2
3
4
5
(get-in matrix [1 2]) 
;=> 6 
 
(assoc-in matrix [1 2] 'x) 
;=> [[1 2 3] [4 5 x] [7 8 9]]
1
2
(update-in matrix [1 2] * 100) 
;=> [[1 2 3] [4 5 600] [7 8 9]]
Listing 5.1. Function for ×nding the neighbors of a spot on a 2D matrix
1
2
3
4
5
6
7
8
9
(defn neighbors 
  ([size yx] (neighbors [[-1 0] [1 0] [0 -1] [0 1]] 
                        size 
                        yx)) 
  ([deltas size yx] 
     (filter (fn [new-yx] 
               (every? #(< -1 % size) new-yx)) 
             (map #(vec (map + yx %)) 
                  deltas))))
1
2
3
1
2
3
(neighbors 3 [0 0]) 
 
;;=> ((1 0) (0 1))

Figure 5.3. The crosswise neighbors of cell 0,0
Figure 5.4. The crosswise neighbors of cell 1,1
1
2
3
(neighbors 3 [1 1]) 
 
;;=> ((0 1) (2 1) (1 0) (1 2))
1
2
(map #(get-in matrix %) (neighbors 3 [0 0])) 
;=> (4 2)
1
2
3
4
5
6
7
8
9
10
11
12
(def my-stack [1 2 3]) 
(peek my-stack) 
 
;=> 3 
(pop my-stack) 
 
;=> [1 2] 
(conj my-stack 4) 
;=> [1 2 3 4] 
 
(+ (peek my-stack) (peek (pop my-stack))) 
;=> 5

1
2
3
4
5
6
7
8
(defn strict-map1 [f coll] 
  (loop [coll coll, acc nil]  
    (if (empty? coll)  
      (reverse acc)  
      (recur (next coll) 
             (cons (f (first coll)) acc))))) 
(strict-map1 - (range 5)) 
;;=> (0 -1 -2 -3 -4)
1
2
3
1
2
3
4
5
6
7
8
(defn strict-map2 [f coll] 
  (loop [coll coll, acc []] 
    (if (empty? coll) 
      acc  
      (recur (next coll) 
             (conj acc (f (first coll))))))) 
(strict-map2 - (range 5)) 
;=> [0 -1 -2 -3 -4]
1
2
3
1
2
(subvec a-to-j 3 6) 
;=> [\D \E \F]
1
2
(first {:width 10, :height 20, :depth 15}) 
;=> [:depth 15]
1
2
(vector? (first {:width 10, :height 20, :depth 15})) 
;=> true
1
2
3
4
5
(doseq [[dimension amount] {:width 10, :height 20, :depth 15}] 
  (println (str (name dimension) ":") amount "inches")) 
; width: 10 inches 
; height: 20 inches 

Figure 5.5. The two collections used internally in a single queue. peek returns the front
item of the seq, pop  returns a new queue with the front of the seq left off, and conj
adds a new item to the back of the vector.
6 ; depth: 15 inches 
;=> nil
1
2
3
4
5
(cons 1 '(2 3)) 
;=> (1 2 3) 
 
(conj '(2 3) 1) 
;=> (1 2 3)
1
2
3
4
5
6
7
8
9
(defmethod print-method clojure.lang.PersistentQueue 
  [q, w] 
 
  (print-method '<- w) 
  (print-method (seq q) w) 
  (print-method '-< w)) 
  
clojure.lang.PersistentQueue/EMPTY 
;=> <-nil-<
1
2
1
2
3
4
5
6
(def schedule 
  (conj clojure.lang.PersistentQueue/EMPTY 
        :wake-up :shower :brush-teeth)) 
 
schedule 
;=> <-(:wake-up :shower :brush-teeth)-<

FINDING ITEMS IN A SEQUENCE USING A SET AND THE SOME
FUNCTION
1
2
(peek schedule) 
;=> :wake-up
1
2
3
4
5
(pop schedule) 
;=> <-(:shower :brush-teeth)-< 
 
(rest schedule) 
;=> (:shower :brush-teeth)
1
2
3
4
5
(#{:a :b :c :d} :c) 
;=> :c 
 
(#{:a :b :c :d} :e) 
;=> nil
1
2
3
4
5
(get #{:a 1 :b 2} :b) 
;=> :b 
 
(get #{:a 1 :b 2} :z :nothing-doing) 
;=> :nothing-doing
1
2
3
4
5
6
7
8
9
(into #{[]} [()]) 
;;=> #{[]} 
 
(into #{[1 2]} '[(1 2)]) 
;;=> #{[1 2]} 
 
 
(into #{[] #{} {}} [()]) 
;;=> #{#{} {} []}

As we’ll explain in section 5.5.3, trying to nd a value in a vector using
the contains?  function doesn’t work the way we’d hope. Instead, the
some  function takes a predicate and a sequence. It applies the
predicate to each element in turn, returning the rst truthy value
returned by the predicate or else nil :
Using a set as the predicate supplied to some  allows you to check
whether any of the truthy values in the set are contained within the
given sequence. This is a frequently used Clojure idiom for searching for
containment within a sequence.
1
2
3
4
5
(some #{:b} [:a 1 :b 2]) 
;=> :b 
 
(some #{1 :b} [:a 1 :b 2]) 
;=> 1
1
2
3
4
5
6
7
8
9
(sorted-set :b :c :a) 
;=> #{:a :b :c} 
 
(sorted-set [3 4] [1 2]) 
;=> #{[1 2] [3 4]} 
 
(sorted-set :b 2 :c :a 3 1) 
; java.lang.ClassCastException: clojure.lang.Keyword cannot be cast to 
     java.lang.Number
1
2
3
4
5
6
(def my-set (sorted-set :a :b)) 
 
;; ... some time later 
(conj my-set "a") 
;=> java.lang.ClassCastException: clojure.lang.Keyword cannot be cast to 
     java.lang.String
1
2
3
4
5
(contains? #{1 2 4 3} 4) 
;=> true 
 
(contains? [1 2 4 3] 4) 
;=> false

Figure 5.6. The three Venn diagrams show a graphical representation of Clojure’s set
functions: intersection , union , and difference .
1 (require 'clojure.set)
1
2
(ns my.cool.lib 
  (:require clojure.set))
1
2
3
4
5
6
7
8
(clojure.set/intersection #{:humans :fruit-bats :zombies} 
                       #{:chupacabra :zombies :humans});=> 
#{:zombies :humans} 
 
(clojure.set/intersection #{:pez :gum :dots :skor} 
                       #{:pez :skor :pocky} 
                       #{:pocky :gum :skor}) 
;=> #{:skor}
1
2
3
4
5
6
7
8
(clojure.set/union #{:humans :fruit-bats :zombies} 
                #{:chupacabra :zombies :humans}) 
;=> #{:chupacabra :fruit-bats :zombies :humans} 
 
(clojure.set/union #{:pez :gum :dots :skor} 
                #{:pez :skor :pocky} 
                #{:pocky :gum :skor}) 
;=> #{:pez :pocky :gum :skor :dots}

1
2
3
4
;; This is not what really happens 
 
(clojure.set/difference #{1 2 3 4} #{3 4 5 6}) 
;=> #{1 2 5 6}
1
2
(clojure.set/difference #{1 2 3 4} #{3 4 5 6}) 
;=> #{1 2}
1
2
(hash-map :a 1, :b 2, :c 3, :d 4, :e 5) 
;=> {:a 1, :c 3, :b 2, :d 4, :e 5}
1
2
3
(let [m {:a 1, 1 :b, [1 2 3] "4 5 6"}] 
  [(get m :a) (get m [1 2 3])]) 
;=> [1 "4 5 6"]
1
2
3
(let [m {:a 1, 1 :b, [1 2 3] "4 5 6"}] 
  [(m :a) (m [1 2 3])]) 
;=> [1 "4 5 6"]
1
2
(seq {:a 1, :b 2}) 
;=> ([:a 1] [:b 2])
1
2
(into {} [[:a 1] [:b 2]]) 
;=> {:a 1, :b 2}

1
2
(into {} (map vec '[(:a 1) (:b 2)])) 
;=> {:a 1, :b 2}
1
2
(apply hash-map [:a 1 :b 2]) 
;=> {:a 1, :b 2}
1
2
(zipmap [:a :b] [1 2]) 
;=> {:b 2, :a 1}
1
2
(sorted-map :thx 1138 :r2d 2) 
;=> {:r2d 2, :thx 1138}
1
2
3
4
5
(sorted-map "bac" 2 "abc" 9) 
;=> {"abc" 9, "bac" 2} 
 
(sorted-map-by #(compare (subs %1 1) (subs %2 1)) "bac" 2 "abc" 9) 
;=> {"bac" 2, "abc" 9}
1
2
3
(sorted-map :a 1, "b" 2) 
;=> java.lang.ClassCastException: clojure.lang.Keyword cannot be cast to 
        java.lang.String
1
2
3
4
5
(assoc {1 :int} 1.0 :float) 
;=> {1.0 :float, 1 :int} 
 
(assoc (sorted-map 1 :int) 1.0 :float) 
;=> {1 :float}

1
2
3
4
5
(seq (hash-map :a 1, :b 2, :c 3)) 
;=> ([:a 1] [:c 3] [:b 2]) 
 
(seq (array-map :a 1, :b 2, :c 3)) 
;=> ([:a 1] [:b 2] [:c 3])
Listing 5.2. First cut of the position function
1
2
3
4
5
6
7
8
9
10
11
(defn pos [e coll] 
  (let [cmp (if (map? coll) 
              #(= (second %1) %2) 
              #(= %1 %2))] 
     (loop [s coll idx 0] 
       (when (seq s) 
         (if (cmp (first s) e) 
           (if (map? coll) 
             (first (first s)) 
             idx) 
           (recur (next s) (inc idx)))))))
1
2
3
4
5
6
1
2
3
4
5
6
7
8
9
10
11
(pos 3 [:a 1 :b 2 :c 3 :d 4]) 
;;=> 5 
 
(pos :foo [:a 1 :b 2 :c 3 :d 4]) 
;;=> nil 
 
(pos 3 {:a 1 :b 2 :c 3 :d 4}) 
;;=> :c 
 
(pos \3 ":a 1 :b 2 :c 3 :d 4") 
;;=> 13
1
2
3
4
5
(defn index [coll] 
  (cond 
    (map? coll) (seq coll) 
    (set? coll) (map vector coll coll) 
    :else (map vector (iterate inc 0) coll)))
1
2
3
4
5
(index [:a 1 :b 2 :c 3 :d 4]) 
;=> ([0 :a] [1 1] [2 :b] [3 2] [4 :c] [5 3] [6 :d] [7 4]) 
 
(index {:a 1 :b 2 :c 3 :d 4}) 
;=> ([:a 1] [:b 2] [:c 3] [:d 4]) 

6
7
8
 
(index #{:a 1 :b 2 :c 3 :d 4}) 
;=> ([1 1] [2 2] [3 3] [4 4] [:a :a] [:c :c] [:b :b] [:d :d])
1
2
3
4
5
6
7
8
9
10
11
(defn pos [e coll] 
  (for [[i v] (index coll) :when (= e v)] i)) 
 
(pos 3 [:a 1 :b 2 :c 3 :d 4]) 
;=> (5) 
(pos 3 {:a 1, :b 2, :c 3, :d 4}) 
;=> (:c) 
(pos 3 [:a 3 :b 3 :c 3 :d 4]) 
;=> (1 3 5) 
(pos 3 {:a 3, :b 3, :c 3, :d 4}) 
;=> (:a :c :b)
1
2
3
4
5
(pos #{3 4} {:a 1 :b 2 :c 3 :d 4}) 
;=> (:c :d) 
 
(pos even? [2 3 6 7]) 
;=> (0 2)
Listing 5.3. Final version of pos
1
2
(defn pos [pred coll] 
 (for [[i v] (index coll) :when (pred v)] i))

CHAPTER 6
1
2
3
4
5
6
7
8
9
(def baselist (list :barnabas :adam)) 
(def lst1 (cons :willie baselist)) 
(def lst2 (cons :phoenix baselist)) 
 
lst1 
;=> (:willie :barnabas :adam) 
 
lst2 
;=> (:phoenix :barnabas :adam)
1
2
3
4
(= (next lst1) (next lst2)) 
;=> true 
(identical? (next lst1) (next lst2)) 
;=> true
1
2
1 {:val 5, :L nil, :R nil}
1
2
3
4
5
(defn xconj [t v] 
   (cond 
    (nil? t) {:val v, :L nil, :R nil})) 
(xconj nil 5) 
;=> {:val 5, :L nil, :R nil}
1
1 (< v (:val t))

KEYWORDS AS FUNCTIONS FOR TRUE-POWER ELEGANCE
A point of deep signicance in understanding the fragment using
:val  and :R  in the function position is how Clojure uses keywords
as functions. In section 4.3.1, we said that keywords, when placed in a
function call position, work as functions taking a map that then look up
themselves (as keywords) in said map. Therefore, the snippet (:val
t)  states that the keyword :val  takes the map t  and looks itself up
in the map. This is functionally equivalent to (get t :val) .
Although we prefer the keyword-as-function approach used in
xconj , you’ll sometimes be faced with a decision and may instead
choose to use get . Either choice is ne, and your decision is stylistic.
A nice rule of thumb to follow is that if a keyword is stored in a local or
var, using get  is often clearer in its “lookup” intent:
That is, the preceding is more clear than (some-local a-map) .
1
2
3
{:val (:val t), 
 :L (insert-new-val-here), 
 :R (:R t)}
1
2
3
4
(let [some-local :a-key] 
(get {:a-key 42} :a-key)) 
 
;;=> 42
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(defn xconj [t v] 
  (cond 
    (nil? t)       {:val v, :L nil, :R nil} 
 
 
    (< v (:val t)) {:val (:val t), 
                    :L (xconj (:L t) v), 
                    :R (:R t)})) 
 
(def tree1 (xconj nil 5)) 
tree1 
;=> {:val 5, :L nil, :R nil} 
 
(def tree1 (xconj tree1 3)) 
tree1 
;=> {:val 5, :L {:val 3, :L nil, :R nil}, :R nil} 
 

Figure 6.1. Shared structure tree: no matter how big the left side of a tree’s root node is,
something can be inserted on the right side without copying, changing, or even
examining the left side. All those values will be included in the new tree, along with the
inserted value.
18
19
20
(def tree1 (xconj tree1 2)) 
tree1 
;=> {:val 5, :L {:val 3, :L {:val 2, :L nil, :R nil}, :R nil}, :R nil}
1
2
3
4
5
6
(defn xseq [t] 
  (when t 
    (concat (xseq (:L t)) [(:val t)] (xseq (:R t))))) 
 
(xseq tree1) 
;=> (2 3 5)
1
2
3
4
5
6
7
8
9
(defn xconj [t v] 
  (cond 
    (nil? t)       {:val v, :L nil, :R nil} 
    (< v (:val t)) {:val (:val t), 
                    :L (xconj (:L t) v), 
                    :R (:R t)} 
   :else           {:val (:val t), 
                    :L (:L t), 
                    :R (xconj (:R t) v)}))
1
2
3
1
2
3
4
5
6
(def tree2 (xconj tree1 7)) 
(xseq tree2) 
;=> (2 3 5 7) 
 
(identical? (:L tree1) (:L tree2)) 
;=> true

1
2
(- 13 (+ 2 2)) 
;=> 9
1
2
3
if (obj != null && obj.isWhatiz()) { 
    ... 
}
Listing 6.1. Short-circuiting if  expression
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(defn if-chain [x y z] 
  (if x 
    (if y 
      (if z 
 
        (do 
 
          (println "Made it!") 
           :all-truthy))))) 
 
(if-chain () 42 true) 
; Made it! 
;=> :all-truthy 
 
(if-chain true true  false) 
;=> nil

REST VS. NEXT
What happens when you create a potentially innite sequence of
integers using iterate , printing a dot each time you generate a new
value, and then use either rest  or next  to return the rst three
values of the sequence? The di|erence between rest  and next  can
be seen in the following example:
1
2
3
4
5
6
7
8
9
(defn and-chain [x y z] 
  (and x y z (do (println "Made it!") :all-truthy))) 
 
(and-chain () 42 true) 
; Made it! 
;=> :all-truthy 
 
(and-chain true false true) 
;=> false
1
2
(steps [1 2 3 4]) 
;=> [1 [2 [3 [4 []]]]]
1
2
3
4
5
6
7
(defn rec-step [[x & xs]] 
  (if x 
    [x (rec-step xs)] 
    [])) 
 
(rec-step [1 2 3 4]) 
;=> [1 [2 [3 [4 []]]]]
1
2
(rec-step (range 200000)) 
;=> java.lang.StackOverflowError
1
2
3
4
5
6
(def very-lazy (-> (iterate #(do (print \.) (inc %)) 1) 
                    rest rest rest)) 
;=> ..#'user/very-lazy 
 
(def less-lazy (-> (iterate #(do (print \.) (inc %)) 1) 

As shown, the next  version printed three dots, whereas the rest
version printed only two. When building a lazy seq from another,
rest  doesn’t cause the calculation of (or realize) any more elements
than it needs to; next  does. In order to determine whether a seq is
empty, next  needs to check whether there’s at least one thing in it,
thus potentially causing one extra realization. Here’s an example:
Grabbing the rst element in a lazy seq built with rest  causes a
realization as expected. But the same doesn’t happen for a seq built
with next  because it’s already been previously realized. Using next
causes a lazy seq to be one element less lazy, which might not be
desired if the cost of realization is expensive. In general, we
recommend that you use next  unless you’re specically trying to
write code to be as lazy as possible.
7                     next next next)) 
;=> ...#'user/less-lazy
1
2
3
(println (first very-lazy)) ; .4 
 
(println (first less-lazy)) ; 4
Listing 6.2. Using lazy-seq  to avoid stack overØows
1
2
3
4
5
6
7
8
9
10
11
(defn lz-rec-step [s] 
  (lazy-seq 
    (if (seq s) 
      [(first s) (lz-rec-step (rest s))] 
      []))) 
(lz-rec-step [1 2 3 4]) 
;=> (1 (2 (3 (4 ())))) 
(class (lz-rec-step [1 2 3 4])) 
;=> clojure.lang.LazySeq 
(dorun (lz-rec-step (range 200000))) 
;=> nil
1
1
2
3
(defn simple-range [i limit] 
  (lazy-seq 

Figure 6.2. Each step of a lazy seq may be in one of two states. If the step is unrealized, it
contains a function or closure of no arguments that can be called later to realize the
step. When this happens, the thunk’s return value is cached instead, and the thunk
itself is released as pictured in the ×rst two lazy seq boxes, transitioning the step to the
realized state. Note that although not shown here, a realized lazy seq may contain
nothing at all, called nil, indicating the end of the seq.
4     (when (< i limit) 
      (cons i (simple-range (inc i) limit)))))
1
2
(simple-range 0 9) 
;=> (0 1 2 3 4 5 6 7 8)
1
2
3
4
5
6
7
8
9
(let [r (range 1e9)] 
  (first r) 
  (last r)) 
;=> 999999999 
 
(let [r (range 1e9)] 
  (last r) 
  (first r)) 
; java.lang.OutOfMemoryError: GC overhead limit exceeded
1
2
3
; Run at your own risk 
(iterate (fn [n] (/ n 2)) 1) 
;=> (1 1/2 1/4 1/8 ...)
1
2
3
4
5
(defn triangle [n] 
(/ (* n (+ n 1)) 2)) 
 
(triangle 10) 
;=> 55

IF-LET AND WHEN-LET
The if-let  and when-let  macros are useful when you’d like to
bind the results of an expression based on whether it returns a truthy
value. This helps to avoid the need to nest if/when  and let  as
shown:
1
2
(map triangle (range 1 11)) 
;=> (1 3 6 10 15 21 28 36 45 55)
Listing 6.3. In×nite sequences fostering declarative solutions
1
2
3
4
5
6
7
8
9
10
11
(def tri-nums (map triangle (iterate inc 1))) 
(take 10 tri-nums) 
;=> (1 3 6 10 15 21 28 36 45 55) 
(take 10 (filter even? tri-nums)) 
;=> (6 10 28 36 66 78 120 136 190 210) 
(nth tri-nums 99) 
;=> 5050 
(double (reduce + (take 1000 (map / tri-nums)))) 
;=> 1.998001998001998 
(take 2 (drop-while #(< % 10000) tri-nums)) 
;=> (10011 10153)
1
2
3
4
5
1
2
3
4
5
6
7
8
9
10
(defn defer-expensive [cheap expensive] 
  (if-let [good-enough (force cheap)] 
     good-enough 
    (force expensive))) 
(defer-expensive (delay :cheap) 
                 (delay (do (Thread/sleep 5000) :expensive))) 
;=> :cheap 
(defer-expensive (delay false) 
                 (delay (do (Thread/sleep 5000) :expensive))) 
;=> :expensive
1

The latter is much more succinct.
Figure 6.3. Lazy linked-list example. Each node of this linked list contains a value (the
head) and a delay (the tail). The creation of the next part is forced by a call to tail —it
doesn’t exist until then.
1
2
3
4
5
6
(if :truthy-thing 
  (let [res :truthy-thing] (println res))) 
; :truthy-thing 
 
(if-let [res :truthy-thing] (println res)) 
; :truthy-thing
1
2
3
4
5
6
(defn inf-triangles [n] 
  {:head (triangle n) 
   :tail (delay (inf-triangles (inc n)))}) 
 
(defn head  [l]   (:head l)) 
(defn tail  [l]   (force (:tail l)))
1
2
3
4
5
6
7
8
(def tri-nums (inf-triangles 1)) 
 
(head tri-nums) 
;=> 1 
(head (tail tri-nums)) 
;=> 3 
(head (tail (tail tri-nums))) 
;=> 6

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(defn taker [n l] 
  (loop [t n, src l, ret []] 
    (if (zero? t) 
      ret 
      (recur (dec t) (tail src) (conj ret (head src)))))) 
 
(defn nthr [l n] 
  (if (zero? n) 
    (head l) 
    (recur (tail l) (dec n)))) 
 
(taker 10 tri-nums) 
;=> [1 3 6 10 15 21 28 36 45 55] 
 
(nthr tri-nums 99) 
;=> 5050
1
2
3
4
(ns joy.q) 
 
(defn rand-ints [n] 
  (take n (repeatedly #(rand-int n))))
1
2
3
(rand-ints 10) 
 
;;=> (0 1 5 7 3 5 6 4 9 0)

Figure 6.4. The qsort function shown earlier uses a structure like this for its work  list
when sorting the vector [2 1 4 3] . Note that all the parts described by a
standard quicksort implementation are represented here.
Listing 6.4. Lazy, tail-recursive, incremental quicksort
1
2
3
4
5
6
7
8
9
10
11
12
(defn sort-parts [work] 
  (lazy-seq 
   (loop [[part & parts] work] 
     (if-let [[pivot & xs] (seq part)] 
       (let [smaller? #(< % pivot)] 
         (recur (list* 
                 (filter smaller? xs) 
                 Pivot 
                 (remove smaller? xs) 
                 parts))) 
        (when-let [[x & parts] parts] 
         (cons x (sort-parts parts)))))))
1
2
3
4
5
6
7
1
2
(defn qsort [xs] 
  (sort-parts (list xs)))
1
2
3
4
5
(qsort [2 1 4 3]) 
;=> (1 2 3 4) 
 
(qsort (rand-ints 20)) 
;=> (0 2 3 5 6 7 7 8 9 10 11 11 11 12 12 13 14 16 17 19)
1
2
(first (qsort (rand-ints 100))) 
;=> 1

Figure 6.5. Internal structure of qsort . Each filter  and remove  lazily returns
items from its parent sequence only as required. So, to return the ×rst two items of the
seq returned by qsort , no remove  steps are required from either level A or level B.
To generate the sequence (4), a single remove  step at level B is needed to eliminate
everything less than 3. As more items are forced from the seq returned by qsort ,
more of the internal filter  and remove  steps are run.
1
2
(take 10 (qsort (rand-ints 10000))) 
;=> (0 0 0 4 4 7 7 8 9 9)

CHAPTER 7
1
2
(map [:chthon :phthor :beowulf :grendel] #{0 3}) 
;;=> (:chthon :grendel)
1
2
1
2
3
(def fifth (comp first rest rest rest rest)) 
(fifth [1 2 3 4 5]) 
;=> 5
1
2
3
4
5
6
7
(defn fnth [n] 
  (apply comp 
         (cons first 
               (take (dec n) (repeat rest))))) 
 
((fnth 5) '[a b c d e]) 
;=> e
1
2
3
4
5
6
(map (comp 
       Keyword 
       #(.toLowerCase %) 
       name) 
     '(a B C)) 
;;=> (:a :b :c)
1
2
3
4
5
1
2
((partial + 5) 100 200) 
;=> 305
1
2
3
4
(let [truthiness (fn [v] v)] 
  [((complement truthiness) true) 
   ((complement truthiness) 42) 
   ((complement truthiness) false) 

THE FACES OF DEFN METADATA
As shown in the denition of the join  function with built-in tests,
placing a map before a function’s parameters is one way of assigning
metadata to a function using the defn  macro. Another way is to use
the shorthand notation before the function name, like so:
The use of the shorthand ^:private  and ^:dynamic  is the same as
saying
which is the same as saying
5
6
7
8
9
10
   ((complement truthiness) nil)]) 
 
;=> [false false true true] 
 
((complement even?) 2) 
;=> false
1
2
3
4
5
6
(defn join 
  {:test (fn [] 
           (assert 
             (= (join "," [1 2 3]) "1,3,3")))} 
  [sep s] 
  (apply str (interpose sep s)))
1
2
(defn ^:private ^:dynamic sum [nums] 
  (map + nums))
1
2
(defn ^{:private true, :dynamic true} sum [nums] 
  (map + nums))

which is also the same as saying
The di|ering choices come in handy usually in di|erent macro
metaprogramming scenarios. For most human-typed functions, the
shorthand form works ne.
1
2
(defn sum {:private true, :dynamic true} [nums] 
  (map + nums))
1
2
3
4
(defn sum 
  ([nums] 
    (map + nums)) 
  {:private true, :dynamic true})
1
2
3
4
5
6
7
8
9
(use '[clojure.test :as t]) 
(t/run-tests) 
; Testing user 
; 
; ERROR in (join) (test.clj:646) 
; ... 
; actual: java.lang.AssertionError: 
;  Assert failed: (= (join "," [1 2 3]) "1,3,3") 
; ...
1
2
(sort [1 5 7 0 -42 13]) 
;;=> (-42 0 1 5 7 13)
1
2
3
4
5
6
7
8
9
(sort ["z" "x" "a" "aa"]) 
;;=> ("a" "aa" "x" "z") 
 
(sort [(java.util.Date.) (java.util.Date. 100)]) 
;;=> (#inst "1970-01-01T00:00:00.100-00:00" 
;;    #inst "2013-06-18T02:49:53.544-00:00") 
 
(sort [[1 2 3], [-1, 0, 1], [3 2 1]]) 
;;=> ([-1 0 1] [1 2 3] [3 2 1])

1
2
(sort > [7 1 4]) 
;;=> (7 4 1)
1
2
3
4
5
(sort ["z" "x" "a" "aa" 1 5 8]) 
;; ClassCastException java.lang.Long cannot be cast to java.lang.String 
 
(sort [{:age 99}, {:age 13}, {:age 7}]) 
;; ClassCastException clojure.lang.PersistentArrayMap cannot be ...
1
2
(sort [[:a 7], [:c 13], [:b 21]]) 
;;=> ([:a 7] [:b 21] [:c 13])
1
2
(sort second [[:a 7], [:c 13], [:b 21]]) 
;; ArityException Wrong number of args (2) passed to: core$second
1
2
(sort-by second [[:a 7], [:c 13], [:b 21]]) 
;;=> ([:a 7] [:c 13] [:b 21])
1
2
3
4
5
(sort-by str ["z" "x" "a" "aa" 1 5 8]) 
;;=> (1 5 8 "a" "aa" "x" "z") 
 
(sort-by :age [{:age 99}, {:age 13}, {:age 7}]) 
;;=> ({:age 7} {:age 13} {:age 99})
1
2
3
4
(def plays [{:band "Burial",     :plays 979,  :loved 9} 
            {:band "Eno",        :plays 2333, :loved 15} 
            {:band "Bill Evans", :plays 979,  :loved 9} 
            {:band "Magma",      :plays 2665, :loved 31}]) 

5
6
 
(def sort-by-loved-ratio (partial sort-by #(/ (:plays %) (:loved %))))
1
2
3
4
5
(sort-by-loved-ratio plays) 
;=> ({:band "Magma",         :plays 2665, :loved 31} 
     {:band "Burial",        :plays 979,  :loved 9} 
     {:band "Bill Evans",    :plays 979,  :loved 9} 
     {:band "Eno",           :plays 2333, :loved 15})
1
2
3
4
5
(sort-by (columns [:plays :loved :band]) plays) 
;=> ({:band "Bill Evans", :plays 979,  :loved 9} 
     {:band "Burial",     :plays 979,  :loved 9} 
     {:band "Eno",        :plays 2333, :loved 15} 
     {:band "Magma",      :plays 2665, :loved 31})
1
2
3
(defn columns [column-names] 
  (fn [row] 
    (vec (map row column-names))))
1
2
3
4
5
6
7
(columns [:plays :loved :band]) 
;;=> #<user$columns$fn__1076 user$columns$fn__1076@689ba632> 
 
((columns [:plays :loved :band]) 
  {:band "Burial", :plays 979, :loved 9}) 
 
;;=> [979 9 "Burial"]
1
2
(vec (map (plays 0) [:plays :loved :band])) 
;=> [979 9 "Burial"]
1
2
(defn keys-apply [f ks m] 
  (let [only (select-keys m ks)] 
1

3
4
    (zipmap (keys only) 
            (map f (vals only)))))
2
1
2
(keys-apply #(.toUpperCase %) #{:band} (plays 0)) 
;;=> {:band "BURIAL"}
1
2
(defn manip-map [f ks m] 
  (merge m (keys-apply f ks m)))
1
1
2
3
(manip-map #(int (/ % 2)) #{:plays :loved} (plays 0)) 
 
;;=> {:band "Burial", :plays 489, :loved 4}
1
2
3
4
5
6
7
8
(defn mega-love! [ks] 
  (map (partial manip-map #(int (* % 1000)) ks) plays)) 
 
(mega-love! [:loved]) 
;;=> ({:band "Burial",     :plays 979,  :loved 9000} 
      {:band "Eno",        :plays 2333, :loved 15000} 
      {:band "Bill Evans", :plays 979,  :loved 9000} 
      {:band "Magma",      :plays 2665, :loved 31000})
1
2
3
4
5
6
7
8
9
10
11
12
def slope(p1=(0,0), p2=(1,1)): 
    return (float(p2[1] - p1[1])) / (p2[0] - p1[0]) 
 
slope((4,15), (3,21)) 
#=> -6.0 
 
slope(p2=(2,1)) 
#=> 0.5 
 
 
slope() 
#=> 1.0

1
2
3
4
5
6
7
8
9
10
11
12
(defn slope 
  [& {:keys [p1 p2] :or {p1 [0 0] p2 [1 1]}}] 
  (float (/ (- (p2 1) (p1 1)) 
            (- (p2 0) (p1 0))))) 
(slope :p1 [4 15] :p2 [3 21]) 
;=> -6.0 
 
(slope :p2 [2 1]) 
;=> 0.5 
 
(slope) 
;=> 1.0
1
2
3
4
5
(defn slope [p1 p2] 
  {:pre [(not= p1 p2) (vector? p1) (vector? p2)] 
   :post [(float? %)]} 
  (/ (- (p2 1) (p1 1)) 
     (- (p2 0) (p1 0))))
1
2
3
4
5
6
7
8
(slope [10 10] [10 10]) 
; java.lang.AssertionError: Assert failed: (not= p1 p2) 
(slope [10 1] '(1 20)) 
; java.lang.AssertionError: Assert failed: (vector? p2) 
(slope [10 1] [1 20]) 
; java.lang.AssertionError: Assert failed: (float? %) 
(slope [10.0 1] [1 20]) 
 ;=> -2.111111111111111
1
2
3
4
1
2
3
4
5
(defn put-things [m] 
  (into m {:meat "beef" :veggie "broccoli"})) 
 
(put-things {}) 
;=> {:meat "beef", :veggie "broccoli"}
1
2
3
4
(defn vegan-constraints [f m] 
  {:pre [(:veggie m)] 
   :post [(:veggie %) (nil? (:meat %))]} 
  (f m)) 

5
6
7
 
(vegan-constraints put-things {:veggie "carrot"}) 
; java.lang.AssertionError: Assert failed: (nil? (:meat %))
1
2
3
4
5
6
7
8
9
10
(defn balanced-diet [f m] 
  {:post [(:meat %) (:veggie %)]} 
   (f m))  
(balanced-diet put-things {}) 
;=> {:veggie "broccoli", :meat "beef"} 
(defn finicky [f m] 
  {:post [(= (:meat %) (:meat m))]} 
   (f m)) 
(finicky put-things {:meat "chicken"}) 
; java.lang.AssertionError: Assert failed: (= (:meat %) (:meat m))
1
2
1
2
3
(def times-two 
  (let [x 2] 
    (fn [y] (* y x))))
1
2
(times-two 5) 
;=> 10
1
2
3
4
5
6
7
8
9
10
(def add-and-get 
  (let [ai (java.util.concurrent.atomic.AtomicInteger.)] 
    (fn [y] (.addAndGet ai y)))) 
 
(add-and-get 2) 
;=> 2 
(add-and-get 2) 
;=> 4 
(add-and-get 7) 
;=> 11
1
2
3
(defn times-n [n] 
  (let [x n] 
    (fn [y] (* y x))))

1
2
(times-n 4) 
;=> #<user$times_n$fn__39 user$times_n$fn__39@427be8c2>
1 (def times-four (times-n 4))
1
2
(times-four 10) 
;=> 40
1
2
(defn times-n [n] 
  (fn [y] (* y n)))
1
2
3
(defn divisible [denom] 
  (fn [num] 
    (zero? (rem num denom))))
1
2
3
4
5
((divisible 3) 6) 
;=> true 
 
((divisible 3) 7) 
;=> false
1
2
(filter even? (range 10)) 
;=> (0 2 4 6 8)

1
2
(filter (divisible 4) (range 10)) 
;=> (0 4 8)
1
2
3
4
5
(defn filter-divisible [denom s] 
  (filter (fn [num] (zero? (rem num denom))) s)) 
 
(filter-divisible 4 (range 10)) 
;=> (0 4 8)
1
2
3
4
5
(defn filter-divisible [denom s] 
  (filter #(zero? (rem % denom)) s)) 
 
(filter-divisible 5 (range 20)) 
;=> (0 5 10 15)
1
2
3
4
(def bearings [{:x  0, :y  1}    ; north 
               {:x  1, :y  0}    ; east 
               {:x  0, :y -1}    ; south 
               {:x -1, :y  0}])  ; west
1
2
3
(defn forward [x y bearing-num] 
  [(+ x (:x (bearings bearing-num))) 
   (+ y (:y (bearings bearing-num)))])
1
2
(forward 5 5 0) 
;=> [5 6]
1
2
3
4
(forward 5 5 1) 
;=> [6 5] 
(forward 5 5 2) 
;=> [5 4]

1
2
3
4
5
6
(defn bot [x y bearing-num] 
  {:coords  [x y] 
   :bearing ([:north :east :south :west] bearing-num) 
   :forward (fn [] (bot (+ x (:x (bearings bearing-num))) 
                        (+ y (:y  (bearings bearing-num))) 
                        bearing-num))})
1
2
3
4
5
(:coords (bot 5 5 0)) 
;=> [5 5] 
 
(:bearing (bot 5 5 0)) 
;=> :north
1
2
(:coords ((:forward (bot 5 5 0)))) 
;=> [5 6]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defn bot [x y bearing-num] 
  {:coords     [x y] 
   :bearing    ([:north :east :south :west] bearing-num) 
   :forward    (fn [] (bot (+ x (:x (bearings bearing-num))) 
                           (+ y (:y (bearings bearing-num))) 
                           bearing-num)) 
   :turn-right (fn [] (bot x y (mod (+ 1 bearing-num) 4))) 
   :turn-left  (fn [] (bot x y (mod (- 1 bearing-num) 4)))}) 
 
(:bearing ((:forward ((:forward ((:turn-right (bot 5 5 0)))))))) 
;=> :east 
 
(:coords ((:forward ((:forward ((:turn-right (bot 5 5 0)))))))) 
;=> [7 5]
1
2
3
4
5
6
7
(defn mirror-bot [x y bearing-num] 
  {:coords     [x y] 
   :bearing    ([:north :east :south :west] bearing-num) 
   :forward    (fn [] (mirror-bot (- x (:x (bearings bearing-num))) 
 
                                  (- y (:y (bearings bearing-num))) 
                                  bearing-num)) 

8
9
   :turn-right (fn [] (mirror-bot x y (mod (- 1 bearing-num) 4))) 
   :turn-left  (fn [] (mirror-bot x y (mod (+ 1 bearing-num) 4)))})
1
2
3
4
5
(defn do-thing-builder [x y z] 
  (fn do-thing [a b] 
    ... 
    (massive-calculation x y z) 
    ...))
1
2
3
4
5
6
7
8
(defn pow [base exp] 
  (if (zero? exp) 
    1 
    (* base (pow base (dec exp))))) 
(pow 2 10) 
;=> 1024 
(pow 1.01 925) 
;=> 9937.353723241924
1
2
(pow 2 10000) 
; java.lang.StackOverflowError
1
2
3
4
5
6
7
8
9
10
(defn pow [base exp] 
  (letfn [(kapow [base exp acc] 
            (if (zero? exp) 
 
              acc 
              (recur base (dec exp) (* base acc))))] 
    (kapow base exp 1))) 
 
(pow 2N 10000) 
;=> ... A very big number
1
2
3
(ns joy.units) 
 
(def simple-metric {:meter 1, 

4
5
6
                    :km 1000, 
                    :cm 1/100, 
                    :mm [1/10 :cm]})
1
2
3
4
5
6
7
(->    (* 3  (:km simple-metric)) 
    (+ (* 10 (:meter simple-metric))) 
    (+ (* 80 (:cm simple-metric))) 
    (+ (* (:cm simple-metric) 
          (* 10 (first (:mm simple-metric))))) 
    float) 
;;=> 3010.81
Listing 7.1. Function to recursively convert units of measure
1
2
3
4
5
6
7
8
9
(defn convert [context descriptor] 
  (reduce (fn [result [mag unit]] 
            (+ result 
               (let [val (get context unit)] 
                 (if (vector? val) 
                   (* mag (convert context val)) 
                   (* mag val))))) 
          0 
          (partition 2 descriptor)))
1
2
3
4
1
2
3
4
5
6
7
8
(convert simple-metric [1 :meter]) 
;;=> 1 
 
(convert simple-metric [50 :cm]) 
;;=> 1/2 
 
(convert simple-metric [100 :mm]) 
;;=> 1/10
1
2
(float (convert simple-metric [3 :km 10 :meter 80 :cm 10 :mm])) 
;;=> 3010.81
1
2
(convert {:bit 1, :byte 8, :nibble [1/2 :byte]} [32 :nibble]) 
;;=> 128N

Figure 7.1. Generalized tail-call optimization: if you know that A  calls B  in the tail
position, then you also know that A ’s resources are no longer needed, allowing
Scheme to deallocate them and defer to B  for the return call instead.
Table 7.1. Tail positions and recur targets
Form(s)
Tail position
Recur target?
fn, defn
(fn [args] expressions tail)
Yes
loop
(loop [bindings] expressions tail)
Yes
let, letfn, binding
(let [bindings] expressions tail)
No
do
(do expressions tail)
No
if, if-not
(if test then-tailelse-tail)
No
when, when-not
(when test expressions tail)
No
cond
(cond test test tail ...:else else tail)
No
or, and
(or test test... tail)
No
case
(case const const tail ... default tail)
No
1
2
3
4
5
(defn gcd [x y] 
  (cond 
     (> x y) (gcd (- x y) y) 
     (< x y) (gcd x (- y x)) 
    :else x))

Figure 7.2. Elevator trampoline: the trampoline function explicitly bounces between
mutually recursive calls.
1
2
3
4
5
6
7
8
(defn gcd [x y] 
  (int 
    (cond 
       (> x y) (recur (- x y) y) 
       (< x y) (recur x (- y x)) 
       :else x))) 
 
; java.lang.UnsupportedOperationException: Can only recur from tail...
Listing 7.2. Using mutually recursive functions to implement a ×nite state machine
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
(defn elevator [commands] 
(letfn  
  [(ff-open [[_ & r]] 
     "When the elevator is open on the 1st floor 
      it can either close or be done." 
     #(case _ 
        :close (ff-closed r) 
        :done  true 
        false)) 
   (ff-closed [[_ & r] 
     "When the elevator is closed on the 1st floor 
      it can either open or go up." 
     #(case _ 
        :open (ff-open r) 
        :up   (sf-closed r) 
        false)) 
   (sf-closed [[_ & r]] 
     "When the elevator is closed on the 2nd floor 
      it can either go down or open." 
     #(case _ 
        :down (ff-closed r) 
        :open (sf-open r) 
        false)) 
   (sf-open [[_ & r]] 
     "When the elevator is open on the 2nd floor 
      it can either close or be done" 
     #(case _ 
        :close (sf-closed r) 
        :done  true 
        false))] 
  (trampoline ff-open commands)))
1
2
3
4
5
6

1
2
3
4
5
6
7
8
9
(elevator [:close :open :close :up :open :open :done]) 
;=> false 
 
(elevator [:close :up :open :close :down :open :done]) 
;=> true 
 
;; run at your own risk! 
(elevator (cycle [:close :open])) 
; ... runs forever
1
2
3
4
5
6
7
8
9
(defn fac-cps [n k] 
  (letfn [(cont [v] (k (* v n)))] 
     (if (zero? n) 
       (k 1) 
       (recur (dec n) cont)))) 
(defn fac [n] 
  (fac-cps n identity)) 
(fac 10) 
;=> 3628800
1
2
3
1
2
3
4
5
6
7
8
9
(defn mk-cps [accept? kend kont] 
  (fn [n] 
    ((fn [n k] 
       (let [cont (fn [v] 
                     (k ((partial kont v) n)))] 
         (if (accept? n) 
            (k 1) 
            (recur (dec n) cont)))) 
      n kend)))
1
2
3
1
2
3
4
5
6
7
8
9
10
11
12
(def fac 
   (mk-cps zero? 
           Identity 
           #(* %1 %2))) 
(fac 10) 
;;=> 3628800 
(def tri 
   (mk-cps #(== 1 %) 
           Identity 
           #(+ %1 %2))) 
(tri 10) 
;;=> 55
1
2
3
4
5
6
7
8

1
2
3
4
5
(def world [[  1   1   1   1    1] 
            [999 999 999 999    1] 
            [  1   1   1   1    1] 
            [  1 999 999 999  999] 
            [  1   1   1   1    1]])
1
2
(neighbors 5 [0 0]) 
;=> ([1 0] [0 1])
Listing 7.3. Function to estimate the straight-line remaining path cost
1
2
3
4
5
6
7
8
(defn estimate-cost [step-cost-est size y x] 
  (* step-cost-est 
 
     (- (+ size size) y x 2))) 
(estimate-cost 900 5 0 0) 
;=> 7200 
(estimate-cost 900 5 4 4) 
;=> 0
Listing 7.4. Function to calculate the cost of the path traversed so far
1
2
3
4
5
(defn path-cost [node-cost cheapest-nbr] 
  (+ node-cost 
     (or (:cost cheapest-nbr) 0))) 
(path-cost 900 {:cost 1}) 
;=> 901
1
Listing 7.5. Function to calculate the estimated total cost of the path
1
2
3
4
5
6
7
8
9
10
11
12
(defn total-cost [newcost step-cost-est size y x] 
  (+ newcost 
     (estimate-cost step-cost-est size y x))) 
 
(total-cost 0 900 5 0 0) 
;=> 7200 
 
(total-cost 1000 900 5 3 4) 
;=> 1900 
 
(total-cost (path-cost 900 {:cost 1}) 900 5 3 4) 
;=> 1801

Listing 7.6. Function to retrieve the minimum value based on a criteria function
1
2
3
4
5
6
7
8
9
(defn min-by [f coll] 
  (when (seq coll) 
    (reduce (fn [min other] 
              (if (> (f min) (f other)) 
                other 
                min)) 
            coll))) 
(min-by :cost [{:cost 100} {:cost 36} {:cost 9}]) 
;;=> {:cost 9}
1
2
Listing 7.7. Main A* algorithm
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
(defn astar [start-yx step-est cell-costs] 
  (let [size (count cell-costs)] 
    (loop [steps 0 
           routes (vec (replicate size (vec (replicate size nil)))) 
           work-todo (sorted-set [0 start-yx])] 
      (if (empty? work-todo) 
        [(peek (peek routes)) :steps steps]  
        (let [[_ yx :as work-item] (first work-todo) 
              rest-work-todo (disj work-todo work-item)  
              nbr-yxs (neighbors size yx) 
              cheapest-nbr (min-by :cost  
                                   (keep #(get-in routes %) 
                                         nbr-yxs)) 
              newcost (path-cost (get-in cell-costs yx) 
                                 cheapest-nbr) 
              oldcost (:cost (get-in routes yx))] 
          (if (and oldcost (>= newcost oldcost)) 
            (recur (inc steps) routes rest-work-todo) 
            (recur (inc steps)  
                   (assoc-in routes yx 
                             {:cost newcost 
                              :yxs (conj (:yxs cheapest-nbr []) 
                                         yx)}) 
                   (into rest-work-todo  
                     (map 
                       (fn [w] 
                         (let [[y x] w] 
                           [(total-cost newcost step-est size y x) w])) 
                       nbr-yxs)))))))))
1
2
3
4
5
6
7
8
9
10
Listing 7.8. Running the A* algorithm on Z World
1
2
3
(astar [0 0] 
       900 
       world) 

Figure 7.3. A graphical representation of Z World clearly shows the optimal/only path.
4
5
6
7
8
9
 
;=> [{:cost 17, 
      :yxs [[0 0] [0 1] [0 2] [0 3] [0 4] [1 4] [2 4] 
            [2 3] [2 2] [2 1] [2 0] [3 0] [4 0] [4 1] 
            [4 2] [4 3] [4 4]]} 
     :steps 94]
Listing 7.9. Shrubbery World
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(astar [0 0] 
       900 
       [[  1   1   1   2   1] 
        [  1   1   1 999   1] 
        [  1   1   1 999   1] 
        [  1   1   1 999   1] 
        [  1   1   1   1   1]]) 
;=> [{:cost 9, 
      :yxs [[0 0] [0 1] [0 2] 
            [1 2] 
            [2 2] 
            [3 2] 
            [4 2] [4 3] [4 4]]} 
      :steps 134]
1
2
3
Listing 7.10. Bunny World
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(astar [0 0] 
       900 
       [[  1   1   1   2   1] 
        [  1   1   1 999   1] 
        [  1   1   1 999   1] 
        [  1   1   1 999   1] 
        [  1   1   1 666   1]]) 
;=> [{:cost 10, 
      :yxs [[0 0] [0 1] [0 2] [0 3] [0 4] 
            [1 4] 
            [2 4] 
            [3 4] 
            [4 4]]} 
      :steps 132]
1
2
3


CHAPTER 8
Figure 8.1. Arrow macro: each expression is inserted into the following one at compile
time, allowing you to write the whole expression inside-out when that feels more
natural.
1 (list (int (Math/sqrt 25)))
1
2
3
4
5
(-> (/ 144 12) (/  2 3) str keyword list) 
;=> (:2) 
 
(-> (/ 144 12) (*  4 (/ 2 3)) str keyword (list  :33)) 
;=> (:32 :33)
1
2
3
4
5
6
7
8
9
(eval 42) 
;=> 42 
 
(eval '(list 1 2)) 
;=> (1 2) 
 
(eval (list 1 2)) 
; java.lang.ClassCastException: 
;  java.lang.Integer cannot be cast to clojure.lang.IFn

HANDLING NESTED SYNTAX-QUOTES
Dealing with nested syntax-quotes can at times be complicated. But
you can visualize the way in which unquoting a|ects the nested
structures as a result of repeated evaluations (Steele 1990) relative to
its nesting level:
The nesting of the syntax-quotes in the rst two println  calls takes
the value of y  further up the abstraction ladder. But by including a
1
2
(eval (list (symbol "+") 1 2)) 
;=> 3
1
2
3
4
(defn contextual-eval [ctx expr] 
  (eval 
   `(let [~@(mapcat (fn [[k v]] [k `'~v]) ctx)] 
      ~expr)))
1
1
2
3
4
5
(contextual-eval '{a 1, b 2} '(+ a b)) 
;;=> 3 
 
(contextual-eval '{a 1, b 2} '(let [b 1000] (+ a b))) 
;;=> 1001
1
2
3
4
5
6
7
8
9
10
11
(let [x 9, y '(- x)] 
  (println `y) 
  (println ``y) 
  (println ``~y) 
  (println ``~~y) 
  (contextual-eval {'x 36} ``~~y)) 
; user/y 
; (quote user/y) 
; user/y 
; (- x) 
;=> -36

single unquote in the third println , we again bring it back down.
Finally, by unquoting a second time, we’ve created a structure that can
then be evaluated—and doing so yields the result -36 . We had to use
contextual-eval  in the tail because core eval  doesn’t have access
to local bindings—only var bindings. One nal note is that had we
attempted to unquote one extra time, we’d have seen the exception
java.lang.IllegalState-Exception: Var
clojure.core/unquote is unbound . The reason for this error is that
unquote is the way to “jump” out of a syntax-quote, and to do so
more than nesting allows will cause an error. You won’t use this
technique in this chapter, and in most cases you won’t need to utilize
it unless you’re planning to create macrodening macros—something
you won’t do until section 14.4.3.
1
2
3
4
5
6
7
8
(do-until 
  (even? 2) (println "Even") 
  (odd?  3) (println "Odd") 
  (zero? 1) (println "You never see me") 
  :lollipop (println "Truthy thing")) 
; Even 
; Odd 
;=> nil
1
2
3
4
5
6
7
8
(defmacro do-until [& clauses] 
  (when clauses  
    (list 'clojure.core/when (first clauses) 
           (if (next clauses) 
             (second clauses) 
             (throw (IllegalArgumentException. 
                     "do-until requires an even number of forms"))) 
           (cons 'do-until (nnext clauses)))))
1
2
3
1
2
3
(macroexpand-1 '(do-until true (prn 1) false (prn 2))) 
;=> (clojure.core/when true 
  (prn 1) (do-until false (prn 2)))

1
2
3
4
5
6
7
(require '[clojure.walk :as walk]) 
(walk/macroexpand-all '(do-until true (prn 1) false (prn 2))) 
;=> (if true (do (prn 1) (if false (do (prn 2) nil)))) 
 
(do-until true (prn 1) false (prn 2)) 
; 1 
;=> nil
1
2
3
4
5
(unless (even? 3) "Now we see it...") 
;=> "Now we see it..." 
 
(unless (even? 2) "Now we don't.") 
;=> nil
1
2
3
(defmacro unless [condition & body] 
  `(if (not ~condition) 
     (do ~@body)))
1
2
1
2
3
4
5
6
(unless true (println "nope")) 
;;=> nil 
 
(unless false (println "yep!")) 
;; yep! 
;;=> nil
1
2
3
4
5
6
7
(macroexpand `(if (not condition) "got it")) 
;=> (if (clojure.core/not user/condition) "got it") 
(eval `(if (not condition) "got it")) 
; java.lang.Exception: No such var: user/condition 
(def condition false) 
(eval `(if (not condition) "got it")) 
;=> "got it"
1
2
3
4
5

1
2
3
4
5
6
7
(defmacro def-watched [name & value] 
  `(do 
     (def ~name ~@value) 
     (add-watch (var ~name) 
                :re-bind 
                (fn [~'key ~'r old# new#] 
                  (println old# " -> " new#)))))
1
2
3
4
5
6
(do (def x 2) 
    (add-watch (var x) 
               :re-bind 
 
               (fn [key r old new] 
                 (println old " -> " new))))
1
2
3
4
5
6
(def-watched x (* 12 12)) 
x 
;=> 144 
 
(def x 0) 
; 144 -> 0
1
2
3
4
5
6
7
8
9
10
11
12
13
(domain man-vs-monster 
  (grouping people 
    (Human "A stock human") 
 
    (Man (isa Human) 
 
      "A man, baby" 
      [name] 
      [has-beard?])) 
  (grouping monsters 
    (Chupacabra 
      "A fierce, yet elusive creature" 
      [eats-goats?])))
1
2
3
{:tag <node form>, 
 :attrs {}, 
 :content [<nodes>]}
1
2
3

1
2
3
4
(defmacro domain [name & body] 
  `{:tag :domain, 
    :attrs {:name (str '~name)}, 
    :content [~@body]})
1
2
3
4
5
6
(declare handle-things) 
 
(defmacro grouping [name & body] 
  `{:tag :grouping, 
    :attrs {:name (str '~name)}, 
    :content [~@(handle-things body)]})
1
2
3
4
5
6
7
8
9
10
(declare grok-attrs grok-props) 
 
(defn handle-things [things] 
  (for [t things] 
    {:tag :thing, 
     :attrs (grok-attrs (take-while (comp not vector?) t)) 
     :content (if-let [c (grok-props (drop-while (comp not vector?) t))] 
 
                [c] 
                [])}))
1
2
3
4
5
6
(defn grok-attrs [attrs] 
  (into {:name (str (first attrs))} 
        (for [a (rest attrs)] 
          (cond 
            (list? a) [:isa (str (second a))] 
            (string? a) [:comment a]))))
1
2
3
4
5
6
7
(defn grok-props [props] 
  (when props 
    {:tag :properties, :attrs nil, 
     :content (apply vector (for [p props] 
                 {:tag :property, 
                  :attrs {:name (str (first p))}, 
                  :content nil}))}))

1
2
3
4
5
6
7
8
9
10
11
12
(def d 
  (domain man-vs-monster 
    (grouping people 
      (Human "A stock human") 
      (Man (isa Human) 
        "A man, baby" 
        [name] 
        [has-beard?])) 
    (grouping monsters 
      (Chupacabra 
        "A fierce, yet elusive creature" 
        [eats-goats?]))))
1
2
3
4
5
1
2
3
4
5
(:tag d) 
;=> :domain 
 
(:tag (first (:content d))) 
;=> :grouping
1
2
(use '[clojure.xml :as xml]) 
(xml/emit d)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
<?xml version='1.0' encoding='UTF-8'?> 
<domain name='man-vs-monster'> 
  <grouping name='people'> 
    <thing name='Human' comment='A stock human'> 
      <properties></properties> 
    </thing> 
    <thing name='Man' isa='Human' comment='A man, baby'> 
      <properties> 
        <property name='name'/> 
        <property name='has-beard?'/> 
      </properties> 
    </thing> 
  </grouping> 
  <grouping name='monsters'> 
    <thing name='Chupacabra' comment='A fierce, yet elusive creature'> 
      <properties> 
        <property name='eats-goats?'/> 
      </properties> 
    </thing> 
  </grouping> 
</domain>
1
2
3
4
5

1 (defmacro resolution [] `x)
1
2
(macroexpand '(resolution)) 
;=> user/x
1
2
3
(def x 9) 
(let [x 109] (resolution)) 
;=> 9
1
2
3
4
// NOTE: This is Scala, not Clojure 
 
Array(1, 2, 3, 4, 5).map(2 * _) 
//=> res0: Array[Int] = Array(2, 4, 6, 8, 10)
1
2
3
4
5
6
7
8
9
10
(defmacro awhen [expr & body] 
  `(let [~'it ~expr] 
     (if ~'it 
       (do ~@body)))) 
(awhen [1 2 3] (it 2)) 
;=> 3 
(awhen nil (println "Will never get here")) 
;=> nil 
(awhen 1 (awhen 2 [it])) 
;=> [2]
1
2
3
4
5
1
2
3
4
5
6
7
8
9
10
11
// NOTE: This is Java, not Clojure 
try { 
 
     // open the resource 
} 
catch (Exception e) { 
     // handle any errors 
} 
finally { 
// in any case, release the resource 
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
(import [java.io BufferedReader InputStreamReader] 
        [java.net URL]) 
(defn joc-www [] 
  (-> "http://joyofclojure.com/hello" URL. 
      .openStream 
      InputStreamReader. 
      BufferedReader.)) 
(let [stream (joc-www)] 
  (with-open [page stream] 
    (println (.readLine page))                                 
    (print "The stream will now close... ")) 
  (println "but let's read from it anyway.") 
  (.readLine stream)) 
; Hello Cleveland 
; The stream will now close... but let's read from it anyway. 
; java.io.IOException: Stream closed
1
2
3
1
2
3
4
5
6
7
8
9
10
11
(defmacro with-resource [binding close-fn & body] 
  `(let ~binding 
     (try 
       (do ~@body) 
        (finally 
        (~close-fn ~(binding 0)))))) 
 
(let [stream (joc-www)] 
  (with-resource [page stream] 
     #(.close %) 
    (.readLine page)))
1
2
3
4
5
6
(contract doubler 
  [x] 
  (:require 
    (pos? x)) 
  (:ensure 
    (= (* 2 x) %)))
Listing 8.1. Contract top-level macro
1
2
3
(declare collect-bodies) 
(defmacro contract [name & forms] 
  (list* `fn name (collect-bodies forms)))

1
2
3
4
5
(fn doubler 
  ([f x] 
     {:post [(= (* 2 x) %)], 
      :pre [(pos? x)]} 
     (f x)))
1
2
3
4
5
(declare build-contract) 
 
(defn collect-bodies [forms] 
  (for [form (partition 3 forms)] 
    (build-contract form)))
Listing 8.2. Contract auxiliary function build-contract
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defn build-contract [c] 
  (let [args (first c)] 
    (list 
      (into '[f] args) 
      (apply merge 
             (for [con (rest c)] 
               (cond (= (first con) 'require) 
                   (assoc {} :pre (vec (rest con))) 
                 (= (first con) 'ensure) 
                   (assoc {} :post (vec (rest con))) 
                 :else (throw (Exception. 
                                (str "Unknown tag " 
                                     (first con))))))) 
  (list* 'f args))))
1
2
3
4
5
6
Listing 8.3. Composition of the contract function and constrained function
1
2
3
4
5
6
7
8
9
10
11
12
13
(def doubler-contract  
  (contract doubler 
    [x] 
    (require 
      (pos? x)) 
    (ensure 
      (= (* 2 x) %)))) 
(def times2 (partial doubler-contract #(* 2 %))) 
(times2 9) 
 
;=> 18 
(def times3 (partial doubler-contract #(* 3 %))) 
(times3 9) 
; java.lang.AssertionError: Assert failed: (= (* 2 x) %)
1
2
3

Listing 8.4. Contract for multiple-arity functions
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
(def doubler-contract 
  (contract doubler 
    [x] 
    (require 
      (pos? x)) 
    (ensure 
      (= (* 2 x) %)) 
    [x y] 
      (require 
        (pos? x) 
        (pos? y)) 
      (ensure 
        (= (* 2 (+ x y)) %)))) 
((partial doubler-contract #(* 2 (+ %1 %2))) 2 3) 
;=> 10 
((partial doubler-contract #(+ %1 %1 %2 %2)) 2 3) 
;=> 10 
((partial doubler-contract #(* 3 (+ %1 %2))) 2 3) 
; java.lang.AssertionError: Assert failed: (= (* 2 (+ x y)) %)
1
2
3
4
5

CHAPTER 9
Figure 9.1. The logical layout of namespaces. The process to resolve a var
joy.ns/authors  includes a symbolic resolution of the namespace and the var
name. The result is the var itself. Aliases created with :use  work as expected.
1
2
3
4
5
6
7
8
9
10
11
(in-ns 'joy.ns) 
(def authors ["Chouser"]) 
(in-ns 'your.ns) 
(clojure.core/refer 'joy.ns) 
joy.ns/authors 
;=> ["Chouser"] 
(in-ns 'joy.ns) 
(def authors ["Chouser" "Fogus"]) 
(in-ns 'your.ns) 
joy.ns/authors  
;=> ["Chouser" "Fogus"]
1
2
3
4
5
1
2
3
(ns chimp) 
(reduce + [1 2 (Integer. 3)]) 
;=> 6
1
2
3
(in-ns 'gibbon) 
 
(reduce + [1 2 (Integer. 3)]) 

4
5
6
7
8
; java.lang.Exception: Unable to resolve symbol: reduce in this context 
 
(clojure.core/refer 'clojure.core) 
(reduce + [1 2 (Integer. 3)]) 
;=> 6
1
2
3
4
5
6
(def b (create-ns 'bonobo)) 
b 
;=> #<Namespace bonobo> 
 
((ns-map b) 'String) 
;=> java.lang.String
1
2
3
4
(intern b 'x 9) 
;=> #'bonobo/x 
bonobo/x 
;=> 9
1
2
3
4
5
6
7
8
9
(intern b 'reduce clojure.core/reduce) 
;=> #'bonobo/reduce 
 
(intern b '+ clojure.core/+) 
;=> #'bonobo/+ 
 
(in-ns 'bonobo) 
(reduce + [1 2 3 4 5]) 
;=> 15
1
2
3
4
5
6
7
(in-ns 'user) 
(get (ns-map 'bonobo) 'reduce) 
;=> #'bonobo/reduce 
 
(ns-unmap 'bonobo 'reduce)  ;=> nil 
(get (ns-map 'bonobo) 'reduce) 
;=> nil
1
2
(remove-ns 'bonobo) 
;=> #<Namespace bonobo> 

Figure 9.2. The directories layout for an illustrative joy.contracts  namespace
Figure 9.3. The top of the source ×le for the joy.contracts  namespace
3
4
5
6
7
8
 
(all-ns) 
;=> (#<Namespace clojure.set> #<Namespace clojure.main> 
     #<Namespace clojure.core> #<Namespace clojure.zip> 
     #<Namespace chimp> #<Namespace gibbon> 
     #<Namespace clojure.xml>)
1
2
3
4
5
6
7
8
9
(ns hider.ns) 
 
(defn ^{:private true} answer [] 42) 
 
(ns seeker.ns 
  (:refer hider.ns)) 
 
(answer) 
; java.lang.Exception: Unable to resolve symbol: answer in this context

Figure 9.4. Private API directories: using the folder layout to hide namespace
implementation details
Figure 9.5. Private API source: the client-facing API is located in contracts.clj, and the
private API in impl.clj.
1
2
3
4
5
6
(ns joy.ns-ex 
  (:refer-clojure :exclude [defstruct]) 
  (:use (clojure set xml)) 
  (:use [clojure.test :only (are is)]) 
  (:require (clojure [zip :as z])) 

7   (:import (java.util Date) 
           (java.io File)))
1
2
(ns joy.udp 
  (:refer-clojure :exclude [get]))
1
1
2
(defn beget [this proto] 
  (assoc this ::prototype proto))
1
1
2
3
(beget {:sub 0} {:super 1}) 
 
;=> {:joy.udp/prototype {:super 1}, :sub 0}
1
2
3
4
5
6
7
8
9
(defn get [m k] 
  (when m 
    (if-let [[_ v] (find m k)] 
      v 
      (recur (::prototype m) k)))) 
 
(get (beget {:sub 0} {:super 1}) 
     :super) 
;=> 1
1 (def put assoc)
1
2
3
4
(def cat {:likes-dogs true, :ocd-bathing true}) 
(def morris (beget {:likes-9lives true} cat)) 
(def post-traumatic-morris (beget {:likes-dogs nil} morris)) 
 

5
6
7
8
9
10
11
12
(get cat :likes-dogs) 
;=> true 
 
(get morris :likes-dogs) 
;=> true 
 
(get post-traumatic-morris :likes-dogs) 
;=> nil
1
2
(get post-traumatic-morris :likes-9lives) 
;;=> true
1
2
3
(defmulti compiler :os) 
(defmethod compiler ::unix [m] (get m :c-compiler)) 
(defmethod compiler ::osx  [m] (get m :llvm-compiler))
1
2
3
4
5
6
7
8
9
10
11
12
(def clone (partial beget {})) 
(def unix   {:os ::unix, :c-compiler "cc", :home "/home", :dev "/dev"}) 
(def osx  (-> (clone unix) 
              (put :os ::osx) 
              (put :llvm-compiler "clang") 
              (put :home "/Users"))) 
 
(compiler unix) 
;=> "cc" 
 
(compiler osx) 
;=> "clang"
1
2
3
4
5
6
7
8
9
(defmulti home :os) 
(defmethod home ::unix [m] (get m :home)) 
 
(home unix) 
;=> "/home" 
 
(home osx) 
; java.lang.IllegalArgumentException: 
;   No method in multimethod 'home' for dispatch value: :user/osx

Figure 9.6. Most languages allowing type derivations use a built-in conØictresolution
strategy. In the case of CLOS, it’s fully customizable. Clojure requires conØicts to be
resolved with prefermethod .
1 (derive ::osx ::unix)
1
2
(home osx) 
;=> "/Users"
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(parents ::osx) 
;=> #{:user/unix} 
 
(ancestors ::osx) 
;=> #{:user/unix} 
 
(descendants ::unix) 
;=> #{:user/osx} 
 
(isa? ::osx ::unix) 
;=> true 
 
(isa? ::unix ::osx) 
;=> false
1
2
3
4
5
6
7
(derive ::osx ::bsd) 
(defmethod home ::bsd [m] "/home") 
 
(home osx) 
; java.lang.IllegalArgumentException: Multiple methods in multimethod 
;  'home' match dispatch value: :user/osx -> :user/unix and 
;  :user/bsd, and neither is preferred
1
2
3
(prefer-method home ::unix ::bsd) 
(home osx) 
;=> "/Users"
1

1
2
3
(remove-method home ::bsd) 
(home osx) 
;=> "/Users"
1
2
3
4
(derive (make-hierarchy) ::osx ::unix) 
;=> {:parents {:user/osx #{:user/unix}}, 
      :ancestors {:user/osx #{:user/unix}}, 
      :descendants {:user/unix #{:user/osx}}}
1
2
3
4
5
(defmulti  compile-cmd  (juxt :os compiler)) 
(defmethod compile-cmd [::osx "gcc"] [m] 
  (str "/usr/bin/" (get m :c-compiler))) 
(defmethod compile-cmd :default [m] 
  (str "Unsure where to locate " (get m :c-compiler)))
1
2
1
2
3
4
5
(compile-cmd osx) 
;=> "/usr/bin/gcc" 
 
(compile-cmd unix) 
;=> "Unsure where to locate cc"

THE HANDY-DANDY JUXT FUNCTION
The juxt  function is useful in dening multimethod dispatch
functions. In a nutshell, juxt  takes a bunch of functions and
composes them into a function returning a vector of its argument(s)
applied to each given function, as shown:
Having a convenient and succinct way to build vectors of applied
functions is powerful for dening understandable multimethods—
although that’s not the limit of juxt's  usefulness.
EXPLICITLY IMPORTING DEFRECORD AND DEFTYPE CLASSES
It’s important to note that when you dene a defrecord  and a
deftype , corresponding classes are generated. These classes are
automatically imported into the same namespace where the
defrecord  and deftype  declarations occur, but not in any other
1
2
3
4
5
6
(def each-math (juxt + * - /)) 
(each-math 2 3) 
;=> [5 6 -1 2/3] 
 
((juxt take drop) 3 (range 9)) 
[(0 1 2) (3 4 5 6 7 8)]
1 {:val 5, :l nil, :r nil}
1 (defrecord TreeNode [val l r])
1
2
(TreeNode. 5 nil nil) 
;=> #:user.TreeNode{:val 5, :l nil, :r nil}

namespace. Instead, you must explicitly import defrecord  and
deftype  classes using the import  function or :import  namespace
declaration:
Loading a namespace via :require  or :use  isn’t enough to import
defrecord  and deftype  classes.
THE DOWNFALL OF DEFSTRUCTS
Clojure provides a defstruct  mechanism, which can be viewed as a
way to dene a map that acts as an ad hoc class mechanism. These
structs dene a set of keys that are required to exist in the map and
therefore can’t be removed via dissoc . With the advent of
defrecord , the need for structs has been nearly eliminated, and
therefore structs aren’t covered in this book. But if you have a code
base reliant on structs, a record can replace them with minimal code
changes, as highlighted here:
Note that the change-age  function works with either structs or
records—no change is required. Only the denition and the
mechanism of instantiation need to be updated.
1
2
(ns my-cool-ns 
  (:import joy.udp.TreeNode))
1
2
3
4
5
6
7
8
9
(defn change-age [p] (assoc p :age 286)) 
 
(defstruct person :fname :lname) 
(change-age (struct person "Immanuel" "Kant")) 
;=> {:fname "Immanuel", :lname "Kant", :age 286} 
 
(defrecord Person [fname lname]) 
(change-age (Person. "Immanuel" "Kant")) 
;=> #:user.Person{:fname "Immanuel", :lname "Kant", :age 286}
Listing 9.1. Persistent binary tree built from records
1
2
(defrecord TreeNode [val l r]) 
(defn xconj [t v] 
1
2

CLOJURE-STYLE MIXINS
3
4
5
6
7
8
9
10
11
12
   (cond 
    (nil? t)       (TreeNode. v nil nil) 
    (< v (:val t)) (TreeNode. (:val t) (xconj (:l t) v) (:r t)) 
    :else          (TreeNode. (:val t) (:l t) (xconj (:r t) v)))) 
(defn xseq [t] 
   (when t 
    (concat (xseq (:l t)) [(:val t)] (xseq (:r t))))) 
(def sample-tree (reduce xconj nil [3 5 2 4 6])) 
 (xseq sample-tree) 
;=> (2 3 4 5 6)
3
4
1
2
(dissoc (TreeNode. 5 nil nil) :l) 
;=> {:val 5, :r nil}
1
2
3
4
(defprotocol FIXO 
  (fixo-push [fixo value]) 
  (fixo-pop [fixo]) 
  (fixo-peek [fixo]))
1
2
3
4
5
6
7
(extend-type TreeNode 
  FIXO 
  (fixo-push [node value] 
    (xconj node value))) 
 
(xseq (fixo-push sample-tree 5/2)) 
;=> (2 5/2 3 4 5 6)
1
2
3
4
5
6
7
(extend-type clojure.lang.IPersistentVector 
  FIXO 
  (fixo-push [vector value] 
    (conj vector value))) 
 
(fixo-push [2 3 4 5 6] 5/2) 
;=> [2 3 4 5 6 5/2]

As you proceed through this section, you’ll notice that you extend the
FIXO  protocol’s fixo-push  function in isolation. This works ne for
our purposes, but you might want to take note of the implications of
this approach. Consider the following:
Dening the StringOps  protocol and extending its rev  function to
String  seems to work ne. But observe what happens when the
protocol is again extended to cover the remaining upp  function:
The reason for this exception is that for a protocol to be fully
populated (all of its functions callable), it must be extended fully, per
individual type. Protocol extension is at the granularity of the entire
protocol and not at a per-function basis. This behavior seems
antithetical to the common notion of a mixin—granules of discrete
functionality that can be “mixed into” existing classes, modules, and
so on. Clojure too has mixins, but it takes a slightly di|erent approach:
1
2
3
4
5
6
7
8
9
10
(use 'clojure.string) 
 
(defprotocol StringOps (rev [s]) (upp [s])) 
 
(extend-type String 
  StringOps 
  (rev [s] (clojure.string/reverse s))) 
 
(rev "Works") 
;=> "skroW"
1
2
3
4
5
6
7
8
9
10
11
(extend-type String 
  StringOps 
  (upp [s] (clojure.string/upper-case s))) 
 
(upp "Works") 
;=> "WORKS" 
 
(rev "Works?") 
; IllegalArgumentException No implementation of method: :rev 
;   of protocol: #'user/StringOps found for 
;     class: java.lang.String
1
2
3
4
5
(def rev-mixin {:rev clojure.string/reverse}) 
 
(def upp-mixin {:upp (fn [this] (.toUpperCase this))}) 
 
(def fully-mixed (merge upp-mixin rev-mixin)) 

Mixins in Clojure refer to the creation of discrete maps containing
protocol function implementations that are combined in such a way as
to create a complete implementation of a protocol. Once mixed
together (as in the var fully-mixed ), only then are types extended
to protocols. As with many of Clojure’s features, mixins and protocol
extension are fully open.
Figure 9.7. As opposed to the notion of monkey-patching and wrapping, the
polymorphism in Clojure resides in the functions themselves and not in the classes
worked with.
6
7
8
9
10
 
(extend String StringOps fully-mixed) 
 
(-> "Works" upp rev) 
;=> SKROW
1
2
3
4
(reduce fixo-push nil [3 5 2 4 6 0]) 
; java.lang.IllegalArgumentException: 
; No implementation of method: :fixo-push 
;  of protocol: #'user/FIXO found for class: nil
1
2
3
4
5
6
7
(extend-type nil 
  FIXO 
  (fixo-push [t v] 
    (TreeNode. v nil nil))) 
 
(xseq (reduce fixo-push nil [3 5 2 4 6 0])) 
;=> (0 2 3 4 5 6)

Listing 9.2. Complete implementations of FIXO  for TreeNode  and vector
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(extend-type TreeNode 
  FIXO 
  (fixo-push [node value] 
    (xconj node value)) 
  (fixo-peek [node] 
    (if (:l node) 
      (recur (:l node)) 
      (:val node))) 
  (fixo-pop [node] 
    (if (:l node) 
      (TreeNode. (:val node) (fixo-pop (:l node)) (:r node)) 
      (:r node)))) 
(extend-type clojure.lang.IPersistentVector 
  FIXO 
  (fixo-push [vector value] 
    (conj vector value)) 
  (fixo-peek [vector] 
    (peek vector)) 
  (fixo-pop [vector] 
    (pop vector)))
1
2
3
4
5
6
1
2
3
4
5
6
7
8
(defn fixo-into [c1 c2] 
  (reduce fixo-push c1 c2)) 
 
(xseq (fixo-into (TreeNode. 5 nil nil) [2 4 6 7])) 
;=> (2 4 5 6 7) 
 
(seq (fixo-into [5] [2 4 6 7])) 
;=> (5 2 4 6 7)
Listing 9.3. Using a map to extend FIXO  to TreeNode
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(def tree-node-fixo 
  {:fixo-push (fn [node value] 
                (xconj node value)) 
   :fixo-peek (fn [node] 
                (if (:l node) 
                  (recur (:l node)) 
                  (:val node))) 
   :fixo-pop (fn [node] 
               (if (:l node) 
                 (TreeNode. (:val node) (fixo-pop (:l node)) (:r node)) 
                 (:r node)))}) 
(extend TreeNode FIXO tree-node-fixo)  
(xseq (fixo-into (TreeNode. 5 nil nil) [2 4 6 7])) 
;=> (2 4 5 6 7)
1
2

POLYMORPHISM AND RECUR
Throughout this section, we’ve implemented the fixo-peek  function
using di|erent methodologies, but a more subtle di|erence is worth
noting. The rst implementation uses recur  for its recursive call:
Listing 9.4. Size-limited stack FIXO  using reify
1
2
3
4
5
6
7
8
9
10
11
12
(defn fixed-fixo 
  ([limit] (fixed-fixo limit [])) 
  ([limit vector] 
    (reify FIXO  
      (fixo-push [this value]  
        (if (< (count vector) limit) 
          (fixed-fixo limit (conj vector value)) 
          this)) 
      (fixo-peek [_] 
        (peek vector)) 
      (fixo-pop [_] 
        (pop vector)))))
1
2
Listing 9.5. Method implementations in defrecord
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
(defrecord TreeNode [val l r] 
  FIXO 
  (fixo-push [t v] 
    (if (< v val) 
      (TreeNode. val (fixo-push l v) r) 
      (TreeNode. val l (fixo-push r v)))) 
  (fixo-peek [t] 
    (if l 
      (fixo-peek l) 
      val)) 
  (fixo-pop [t] 
    (if l 
      (TreeNode. val (fixo-pop l) r) 
      r))) 
(def sample-tree2 (reduce fixo-push (TreeNode. 3 nil nil) [5 2 4 6])) 
(xseq sample-tree2) 
;=> (2 3 4 5 6)
1
2
1
2
3
4
(fixo-peek [node] 
  (if (:l node) 
    (recur (:l node)) 
    (:val node)))

Because of the nature of recur , the rst implementation of fixo-
peek  isn’t polymorphic on the recursive call. But the second version of
fixo-peek  uses a di|erent approach:
Notice that the recursive call in the second implementation is direct
(mundane) and as a result is polymorphic. In the course of writing your
own programs, this di|erence probably won’t cause issues, but it’s
worth storing in the back of your mind.
1
2
3
4
(fixo-peek [t] 
  (if l 
    (fixo-peek l) 
    val))
1
2
3
4
5
6
(defrecord InfiniteConstant [i] 
  clojure.lang.ISeq 
  (seq [this] 
    (lazy-seq (cons i (seq this))))) 
; java.lang.ClassFormatError: Duplicate method 
;   name&signature in class file user/InfiniteConstant
1
2
3
4
5
6
7
(deftype InfiniteConstant [i] 
  clojure.lang.ISeq 
  (seq [this] 
    (lazy-seq (cons i (seq this))))) 
 
(take 3 (InfiniteConstant. 5)) 
;=> (5 5 5)
1
2
(:i (InfiniteConstant. 5)) 
;=> nil
1
2
(.i (InfiniteConstant. 5)) 
;=> 5

Listing 9.6. Implementing map interfaces with deftype
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
(deftype TreeNode [val l r] 
  FIXO 
  (fixo-push [_ v] 
    (if (< v val) 
      (TreeNode. val (fixo-push l v) r) 
      (TreeNode. val l (fixo-push r v)))) 
  (fixo-peek [_] 
    (if l 
      (fixo-peek l) 
      val)) 
  (fixo-pop [_] 
    (if l 
      (TreeNode. val (fixo-pop l) r) 
      r)) 
  clojure.lang.IPersistentStack  
  (cons [this v] (fixo-push this v)) 
  (peek [this] (fixo-peek this)) 
  (pop [this] (fixo-pop this)) 
  clojure.lang.Seqable 
  (seq [t] 
    (concat (seq l) [val] (seq r)))) 
(extend-type nil 
  FIXO 
  (fixo-push [t v] 
    (TreeNode. v nil nil))) 
(def sample-tree2 (into (TreeNode. 3 nil nil) [5 2 4 6])) 
(seq sample-tree2) 
;=> (2 3 4 5 6)
1
2
3
4
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
public class FluentMove { 
    private String from, to, promotion = ""; 
    private boolean castlep; 
 
    public static MoveBuilder desc() { return new MoveBuilder(); } 
 
    public String toString() { 
        return "Move " + from + 
           " to " + to + 
           (castlep ? " castle" : "") + 
           (promotion.length() != 0 ? " promote to " + promotion : ""); 
     } 
 
    public static final class MoveBuilder { 
        FluentMove move = new FluentMove(); 
 
        public MoveBuilder from(String from) { 
            move.from = from; return this; 
        } 
 
        public MoveBuilder to(String to) { 
           move.to = to; return this; 
        } 
 
        public MoveBuilder castle() { 
           move.castlep = true; return this; 
        } 
 

29
30
31
32
33
34
35
        public MoveBuilder promoteTo(String promotion) { 
           move.promotion = promotion; return this; 
        } 
 
        public FluentMove build() { return move; } 
    } 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
public static void main(String[] args) { 
    FluentMove move = FluentMove.desc() 
         .from("e2") 
 
 
         .to("e4").build(); 
     System.out.println(move); 
 
     move = FluentMove.desc() 
         .from("a1") 
         .to("c1") 
         .castle().build(); 
 
     System.out.println(move); 
 
     move = FluentMove.desc() 
         .from("a7") 
         .to("a8") 
        .promoteTo("Q").build(); 
 
     System.out.println(move); 
} 
//  Move e2 to e4 
//  Move a1 to c1 castle 
//  Move a7 to a8 promote to Q
1 {:from "e7", :to "e8", :castle? false, :promotion \Q}
1
2
3
4
5
(defn build-move [& pieces] 
  (apply hash-map pieces)) 
 
(build-move :from "e7" :to "e8" :promotion \Q) 
;=> {:from "e7", :to "e8", :promotion \Q}
1
2
3
(defrecord Move [from to castle? promotion] 
  Object 
  (toString [this] 

4
5
6
7
8
9
    (str "Move " (:from this) 
         " to " (:to this) 
         (if (:castle? this) " castle" 
           (if-let [p (:promotion this)] 
             (str " promote to " p) 
             "")))))
1
2
3
4
5
(str (Move. "e2" "e4" nil nil)) 
;=> "Move e2 to e4" 
 
(.println System/out (Move. "e7" "e8" nil \Q)) 
; Move e7 to e8 promote to Q
1
2
3
4
5
6
(defn build-move [& {:keys [from to castle? promotion]}] 
  {:pre [from to]} 
  (Move. from to castle? promotion)) 
 
(str (build-move :from "e2" :to "e4")) 
;=> "Move e2 to e4"

CHAPTER 10
AN EXAMPLE DOTHREADS FUNCTION
Figure 10.1. Tom, alone
Figure 10.2. Tom inserts data into the work queue
Figure 10.3. Tom inserts data into the work queue while Crow and Joel consume it at
their leisure.
Figure 10.4. Clojure’s four reference types are listed across the top, with their features
listed down the left. Atoms are for lone synchronous objects. Agents are for
asynchronous actions. Vars are for thread-local storage. Refs are for synchronously
coordinating multiple objects.

To illustrate some major points, we’ll use a function dothreads ! that
launches a given number of threads each running a function a number
of times:
The dothreads!  function is of limited utility—throwing a bunch of
threads at a function to see if it breaks:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(ns joy.mutation 
  (:import java.util.concurrent.Executors)) 
 
(def thread-pool 
      (Executors/newFixedThreadPool 
       (+ 2 (.availableProcessors (Runtime/getRuntime))))) 
 
(defn dothreads!  
  [f & {thread-count :threads 
         exec-count   :times  
         :or {thread-count 1 exec-count 1}}] 
   (dotimes [t thread-count] 
    (.submit thread-pool  
             #(dotimes [_ exec-count] (f)))))
1
2
3
4
5
1
2
(dothreads! #(.print System/out "Hi ") :threads 2 :times 2) 
Hi Hi Hi Hi
Listing 10.1. 3 x 3 chess board representation using Clojure refs
1
2
3
4
5
6
7
(def initial-board  
      [[:- :k :-] 
      [:- :- :-] 
      [:- :K :-]]) 
(defn board-map [f board] 
  (vec (map #(vec (for [s %] (f s))) 
             board)))
1
2
Listing 10.2. Setting up the refs example
1
2
3
4
5
6
(defn reset-board! 
  "Resets the board state.  Generally these types of functions are a 
   bad idea, but matters of page count force our hand." 
  [] 
  (def board (board-map ref initial-board)) 
  (def to-move (ref [[:K [2 1]] [:k [0 1]]])) 
1

Figure 10.5. The king neighbors of cell 1,1
7
8
9
10
11
12
13
14
15
16
17
18
19
  (def num-moves (ref 0))) 
(def king-moves  
  (partial neighbors 
      [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]] 3)) 
(defn good-move? 
  [to enemy-sq] 
  (when (not= to enemy-sq)  
     to)) 
(defn choose-move 
  "Randomly choose a legal move" 
  [[[mover mpos] [_ enemy-pos]]] 
  [mover (some #(good-move? % enemy-pos) 
                (shuffle (king-moves mpos)))])
2
3
4
5
1
2
3
(reset-board!) 
(take 5 (repeatedly #(choose-move @to-move))) 
;=> ([:K [1 0]] [:K [1 2]] [:K [1 1]] [:K [1 2]] [:K [1 0]])
Listing 10.3. Using alter  to update refs in a transaction
1
2
3
4
5
6
7
8
9
10
11
(defn place [from to] to) 
(defn move-piece [[piece dest] [[_ src] _]] 
  (alter (get-in board dest) place piece) 
   (alter (get-in board src ) place :-) 
  (alter num-moves inc)) 
(defn update-to-move [move] 
  (alter to-move #(vector (second %) move))) 
(defn make-move [] 
  (let [move (choose-move @to-move)] 
    (dosync (move-piece move @to-move))  
     (dosync (update-to-move move))))
1
2
3
4
1
2
3
(reset-board!) 
 
(make-move) 

Figure 10.5. Illustrating an STM retry: Clojure’s STM works much like a database.
4
5
6
7
8
9
10
11
12
13
;=> [[:k [0 1]] [:K [2 0]]] 
 
(board-map deref board) 
;=> [[:- :k :-] [:- :- :-] [:K :- :-]] 
 
(make-move) 
;=> [[:K [2 0]] [:k [1 1]]] 
 
(board-map deref board) 
;=> [[:- :- :-] [:- :k :-] [:K :- :-]]
1
2
3
4
(dothreads! make-move :threads 100 :times 100) 
 
(board-map deref board) 
;=> [[:- :- :-] [:- :K :-] [:- :- :K]]

Figure 10.6. A restart in any of Clojure’s embedded transactions A , B , b , or C
causes a restart in the entire subsuming transaction. This is unlike a fully embedded
transaction system, where the subtransactions can be used to restrain the scope of
restarts.
1
2
(io! (.println System/out "Haikeeba!")) 
; Haikeeba!
1
2
(dosync (io! (.println System/out "Haikeeba!"))) 
; java.lang.IllegalStateException: I/O in transaction
1
2
3
4
(defn make-move [] 
  (let [move (choose-move @to-move)] 
    (dosync (move-piece move @to-move)) 
    (dosync (update-to-move move))))

Figure 10.7. If refs A  and B  should be coordinated, then splitting their updates across
different transactions is dangerous. Value a ? is eventually committed to A , but the
update for B  never commits due to retry, and coordination is lost. Another error
occurs if B ’s change depends on A ’s value and A  and B  are split across
transactions. There are no guarantees that the dependent values refer to the same
timeline.
1
2
3
4
5
(defn make-move-v2 [] 
  (dosync 
    (let [move (choose-move @to-move)] 
     (move-piece move @to-move) 
     (update-to-move move))))
1
1
2
3
4
5
6
7
8
9
(reset-board!) 
(make-move) 
;=> [[:k [0 1]] [:K [2 0]]] 
 
(board-map deref board) 
;=> [[:- :k :-] [:- :- :-] [:K :- :-]] 
 
@num-moves 
;=> 1
1
2
3
4
5
6
7
(dothreads! make-move-v2 :threads 100 :times 100) 
(board-map #(dosync (deref %)) board) 
;=> [[:k :- :-] [:- :- :-] [:K :- :-]] 
@to-move 
;=> [[:k [0 0]] [:K [2 0]]] 
@num-moves 
;=> 10001

Figure 10.8. The in-transaction value 9 for the ref num-moves  is retrieved in the body
of the transaction and manipulated with the alter  function inc . The resulting
value 10 is eventually used for the committime value, unless a retry is required.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defn move-piece [[piece dest] [[_ src] _]] 
  (commute (get-in board dest) place piece) 
  (commute (get-in board src ) place :-) 
  (commute num-moves inc)) 
 
(reset-board!) 
 
(dothreads! make-move-v2 :threads 100 :times 100) 
 
(board-map deref board) 
;=> [[:K :- :-] [:- :- :-] [:- :- :k]] 
 
@to-move 
;=> [[:K [0 0]] [:k [2 2]]]
1
2
3
4
5
6
7
8
9
10
(defn update-to-move [move] 
  (commute to-move #(vector (second %) move))) 
 
(dothreads! make-move-v2 :threads 100 :times 100) 
 
(board-map #(dosync (deref %)) board) 
;=> [[:- :- :-] [:- :K :-] [:- :- :K]] 
 
@to-move 
;=> [[:K [2 2]] [:K [1 1]]]

Figure 10.9. The in-transaction value 9 in the nummoves  ref is retrieved in the body of
the transaction and manipulated with the commute  function. But the commute
function inc  is again run at commit time with the current value 13 contained in the
ref. The result of this action serves as the committed value 14.
1
2
3
(dosync (ref-set to-move '[[:K [2 1]] [:k [0 1]]])) 
 
;=> [[:K [2 1]] [:k [0 1]]]
Listing 10.4. How to make a ref squirm
1
2
3
4
5
6
7
8
9
10
11
12
13
(defn stress-ref [r] 
  (let [slow-tries (atom 0)] 
    (future 
      (dosync  
         (swap! slow-tries inc) 
        (Thread/sleep 200) 
        @r) 
      (println (format "r is: %s, history: %d, after: %d tries" 
                       @r (.getHistoryCount r) @slow-tries))) 
    (dotimes [i 500] 
      (Thread/sleep 10) 
       (dosync (alter r inc))) 
    :done))
1
2

1
2
3
(stress-ref (ref 0)) 
;=> :done 
; r is: 500, history: 10, after: 26 tries
1
2
3
(stress-ref (ref 0 :max-history 30)) 
; r is: 410, history: 20, after: 21 tries 
;=> :done
1
2
3
(stress-ref (ref 0 :min-history 15 :max-history 30)) 
; r is: 97, history: 19, after: 5 tries 
;=> :done
1 (def joy (agent []))
1 (send joy conj "First edition")
1
2
@joy  ;; read as (deref joy) 
;=> ["First edition"]
1
2
3
(defn slow-conj [coll item] 
  (Thread/sleep 1000) 
  (conj coll item))
1
2
(send joy slow-conj "Second edition") 
;=> #<Agent@5efefc32: ["First edition"]>

Figure 10.10. Clojure agents versus Erlang processes: each agent and process starts
with the value 1. Both receive an inc  request simultaneously but can process only
one at a time, so more are queued. Requests to the process are queued until a response
can be delivered, whereas any number of simultaneous derefs  can be done on an
agent. Despite what this illustration may suggest, an agent is not an actor with a hat on.
1
2
@joy 
;=> ["First edition" "Second edition"]
1 (def log-agent (agent 0))

1
2
3
(defn do-log [msg-id message] 
  (println msg-id ":" message) 
  (inc msg-id))
Listing 10.5. Controlling I/O with an agent
1
2
3
4
5
6
7
8
9
10
11
12
(defn do-step [channel message] 
  (Thread/sleep 1) 
  (send-off log-agent do-log (str channel message))) 
(defn three-step [channel] 
  (do-step channel " ready to begin (step 0)") 
  (do-step channel " warming up (step 1)") 
  (do-step channel " really getting going now (step 2)") 
  (do-step channel " done! (step 3)")) 
(defn all-together-now [] 
  (dothreads! #(three-step "alpha")) 
  (dothreads! #(three-step "beta")) 
  (dothreads! #(three-step "omega")))
1
2
3
4
5
6
1
2
3
4
5
6
7
8
9
10
11
12
13
0 : alpha ready to begin (step 0) 
1 : omega ready to begin (step 0) 
 
2 : beta ready to begin (step 0) 
3 : alpha warming up (step 1) 
4 : alpha really getting going now (step 2) 
5 : omega warming up (step 1) 
6 : alpha done! (step 3) 
7 : omega really getting going now (step 2) 
8 : omega done! (step 3) 
9 : beta warming up (step 1) 
10 : beta really getting going now (step 2) 
11 : beta done! (step 3)
1
2
@log-agent 
;=> 11
1
2
(do-step "important: " "this must go out") 
(await log-agent)

Figure 10.11. When an agent is idle, no CPU resources are being consumed. Each action
is sent to an agent using either send  or send-off , which determines which thread
pool is used to dequeue and apply the action. Because actions queued with send  are
applied by a limited thread pool, the agents queue up for access to these threads—a
constraint that doesn’t apply to actions queued with send-off .
1
2
3
4
(send log-agent (fn [_] 1000)) 
 
(do-step "epsilon " "near miss") 
; 1000 : epsilon near miss
1
2
3
4
5
6
(defn exercise-agents [send-fn] 
  (let [agents (map #(agent %) (range 10))] 
    (doseq [a agents] 
      (send-fn a (fn [_] (Thread/sleep 1000)))) 
    (doseq [a agents] 
      (await a))))
1
2
(time (exercise-agents send-off)) 
; "Elapsed time: 1008.771296 msecs"

1
2
(time (exercise-agents send)) 
; "Elapsed time: 3001.555086 msecs"
1
2
3
4
(send log-agent (fn [] 2000))   ; incorrect 
 
@log-agent 
;=> 1001
1
2
3
(agent-error log-agent) 
;=> #<IllegalArgumentException java.lang.IllegalArgumentException: 
;      Wrong number of args passed to: user$eval--509$fn>
1
2
(send log-agent (fn [_] 3000)) 
; java.lang.RuntimeException: Agent is failed, needs restart
1
2
@log-agent 
;=> 1001
1
2
(restart-agent log-agent 2500 :clear-actions true) 
;=> 2500
1
2
3
(send-off log-agent do-log "The agent, it lives!") 
; 2500 : The agent, it lives! 
;=> #<Agent@72898540: 2500>

1
2
(restart-agent log-agent 2500 :clear-actions true) 
;=> java.lang.RuntimeException: Agent does not need a restart
1
2
3
4
5
6
(defn handle-log-error [the-agent the-err] 
  (println "An action sent to the log-agent threw " the-err)) 
 
(set-error-handler! log-agent handle-log-error) 
 
(set-error-mode! log-agent :continue)
1
2
3
4
5
6
7
8
9
10
(send log-agent (fn [x] (/ x 0)))   ; incorrect 
; An action sent to the log- 
     agent threw java.lang.ArithmeticException: Divide by zero 
;=> #<Agent@66200db9: 2501> 
 
(send log-agent (fn [] 0))           ; also incorrect 
; An action sent to the log-agent threw 
;   java.lang.IllegalArgumentException: 
;   Wrong number of args passed to: user$eval--820$fn 
;=> #<Agent@66200db9: 2501>
1
2
(send-off log-agent do-log "Stayin' alive, stayin' alive...") 
; 2501 : Stayin' alive, stayin' alive...
1
2
3
4
5
(def ^:dynamic *time* (atom 0)) 
(defn tick [] (swap! *time* inc)) 
(dothreads! tick :threads 1000 :times 100) 
@*time* 
;=> 100000
Listing 10.6. Resettable memoize  function
1
2
3
4
5
(defn manipulable-memoize [function] 
  (let [cache (atom {})]  
    (with-meta 
      (fn [& args] 
        (or (second (find @cache args)) 
1
2

6
7
8
9
            (let [ret (apply function args)] 
              (swap! cache assoc args ret) 
              ret))) 
      {:cache cache})))
3
4
5
6
1
2
3
4
5
6
7
8
(def slowly (fn [x] (Thread/sleep 1000) x)) 
(time [(slowly 9) (slowly 9)]) 
; "Elapsed time: 2000.33 msecs" 
;=> [9 9] 
(def sometimes-slowly (manipulable-memoize slowly)) 
(time [(sometimes-slowly 108) (sometimes-slowly 108)]) 
; "Elapsed time: 2000.409 msecs" 
;=> [108 108]
1
2
1
2
3
4
5
6
(meta sometimes-slowly) 
;=> {:cache #<Atom@e4245: {(108) 108}>} 
 
(let [cache (:cache (meta sometimes-slowly))] 
  (swap! cache dissoc '(108))) 
;=> {}
1
2
3
4
5
6
(meta sometimes-slowly) 
;=> {:cache #<Atom@e4245: {}>} 
 
(time [(sometimes-slowly 108) (sometimes-slowly 108)]) 
; "Elapsed time: 1000.3 msecs" 
;=> [108 108]
Listing 10.7. Simple SafeArray  protocol
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(ns joy.locks 
  (:refer-clojure :exclude [aget aset count seq]) 
  (:require [clojure.core :as clj]) 
  (:use [joy.mutation :only (dothreads!)])) 
 
(defprotocol SafeArray 
  (aset  [this i f]) 
  (aget  [this i]) 
  (count [this]) 
  (seq   [this])) 
(defn make-dumb-array [t sz] 
  (let [a (make-array t sz)] 
    (reify 
      SafeArray 
1
2
3
4

15
16
17
18
19
20
21
      (count [_]   (clj/count a)) 
      (seq   [_]   (clj/seq a)) 
      (aget  [_ i] (clj/aget a i)) 
      (aset  [this i f] 
        (clj/aset a 
                  i 
                  (f (aget this i)))))))
5
6
7
1
2
3
4
5
6
7
8
(defn pummel [a] 
  (dothreads! #(dotimes [i (count a)] (aset a i inc)) 
               :threads 100)) 
(def D (make-dumb-array Integer/TYPE 8)) 
(pummel D) 
;; wait for pummel to terminate 
(seq D) 
;=> (82 84 65 63 83 65 83 87)
1
2
3
Listing 10.8. Implementating SafeArray  using the locking  macro
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defn make-safe-array [t sz] 
  (let [a (make-array t sz)] 
     (reify 
      SafeArray 
      (count [_] (clj/count a)) 
      (seq [_] (clj/seq a)) 
      (aget [_ i]  
         (locking a 
          (clj/aget a i))) 
      (aset [this i f] 
         (locking a 
          (clj/aset a 
                    i 
                    (f (aget this i))))))))
1
2
3
4
1
2
3
4
5
6
7
(def A (make-safe-array Integer/TYPE 8)) 
 
(pummel A) 
;; wait for pummel to terminate 
 
(seq A) 
;;=> (100 100 100 100 100 100 100 100)
1
2
(defn lock-i [target-index num-locks] 
  (mod target-index num-locks))
1

Listing 10.9. Implementing SafeArray  using ReentrantLock
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
(import 'java.util.concurrent.locks.ReentrantLock) 
(defn make-smart-array [t sz] 
  (let [a   (make-array t sz) 
        Lsz (/ sz 2) 
        L   (into-array (take Lsz 
                        (repeatedly #(ReentrantLock.))))] 
    (reify 
      SafeArray 
      (count [_] (clj/count a)) 
      (seq [_] (clj/seq a)) 
      (aget [_ i] 
        (let [lk (clj/aget L (lock-i (inc i) Lsz))] 
          (.lock lk) 
          (try 
            (clj/aget a i) 
            (finally (.unlock lk))))) 
      (aset [this i f] 
        (let [lk (clj/aget L (lock-i (inc i) Lsz))] 
          (.lock lk) 
          (try 
            (clj/aset a 
                      i 
                      (f (aget this i))) 
             (finally (.unlock lk))))))))
1
2
3
4
5
1
2
3
4
5
6
7
(def S (make-smart-array Integer/TYPE 8)) 
 
(pummel S) 
;; wait for pummel to terminate 
 
(seq S) 
;;=> (100 100 100 100 100 100 100 100)
1
2
*read-eval* 
;=> true
1
2
(var *read-eval*) 
;=> #'clojure.core/*read-eval*

Figure 10.12. Thread-local var bindings. This illustration depicts a single var being used
from three different threads. Each rounded box is a var binding, either thread-local or
root. Each star is the var being deref’ed, with the solid arrow pointing to the binding
used. The dotted lines point from a thread-local binding to the next binding on the
stack.
1
2
#'*read-eval* 
;=> #'clojure.core/*read-eval*
1
2
(defn print-read-eval [] 
  (println "*read-eval* is currently" *read-eval*))
1
2
3
4
5
(defn binding-play [] 
  (print-read-eval) 
  (binding [*read-eval* false] 
    (print-read-eval)) 
  (print-read-eval))
1
2
3
4
(binding-play) 
; *read-eval* is currently true 
; *read-eval* is currently false 
; *read-eval* is currently true

Table 10.1. Var states
Initialization mechanism
(resolve ‘x)
(bound? #‘x)
(thread-bound?
#‘x)
1
2
(def favorite-color :green) 
#'user/favorite-color
1
2
favorite-color 
;=> :green
1
2
(var favorite-color) 
;=> #'user/favorite-color

Initialization mechanism
(resolve ‘x)
(bound? #‘x)
(thread-bound?
#‘x)
(def x)
#'user/x
false
false
(def x 5)
#'user/x
true
false
(binding [x 7] ...)
#'user/x
true
true
(with-local-vars [x 9] ...)
nil
true
true
1
2
3
4
5
6
7
8
9
(def x 42) 
{:outer-var-value x 
 :with-locals (with-local-vars [x 9] 
                {:local-var x 
                 :local-var-value (var-get x)})} 
 
;=> {:outer-var-value 42, 
     :with-locals {:local-var #<Var: --unnamed-->, 
                   :local-var-value 9}}
1
2
3
(with-precision 4 
  (/ 1M 3)) 
;=> 0.3333M
1
2
3
(/ 1M 3) 
; java.lang.ArithmeticException: Non-terminating decimal expansion; 
;   no exact representable decimal result.
1
2
3
4
5
(with-precision 4 
  (map (fn [x] (/ x 3)) (range 1M 4M))) 
 
; java.lang.ArithmeticException: Non-terminating decimal expansion; 
;   no exact representable decimal result.
1
2
3
(with-precision 4 
  (doall (map (fn [x] (/ x 3)) (range 1M 4M)))) 
;=> (0.3333M 0.6667M 1M)

1
2
3
(with-precision 4 
  (map (bound-fn [x] (/ x 3)) (range 1M 4M))) 
;=> (0.3333M 0.6667M 1M)

CHAPTER 11
Figure 11.1. The concurrent design with an intermediate work queue from the previous
chapter is potentially parallelizable.
Figure 11.2. The concurrent design can be parallelized through the use of another work
queue and producer as well as two more consumers.
1
2
3
4
(time (let [x (future (do (Thread/sleep 5000) (+ 41 1)))] 
  [@x @x])) 
; "Elapsed time: 5001.682 msecs" 
;=> [42 42]
1
2
3
4
<rss version="2.0"> 
  <channel> 
    <title>Twitter / fogus</title> 
    <link>http://twitter.com/fogus</link> 

5
6
7
8
9
10
11
12
    <item> 
      <title>fogus: Thinking about #Clojure futures.</title> 
      <link> 
         http://twitter.com/fogus/statuses/12180102647/ 
      </link> 
    </item> 
  </channel> 
</rss>
Listing 11.1. Converting an XML feed to an XML zipper
1
2
3
4
5
6
7
(ns joy.futures 
  (:require (clojure [xml :as xml])) 
  (:require (clojure [zip :as zip])) 
  (:import  (java.util.regex Pattern))) 
(defn feed->zipper [uri-str] 
  (->> (xml/parse uri-str)  
       zip/xml-zip))
1
2
Listing 11.2. Normalizing RSS and Atom feed entries to a common structure
1
2
3
4
5
6
7
8
9
10
(defn normalize [feed] 
  (if (= :feed (:tag (first feed))) 
     feed 
    (zip/down feed))) 
(defn feed-children [uri-str] 
  (->> uri-str 
       feed->zipper 
        normalize 
        zip/children    
       (filter (comp #{:item :entry} :tag))))
1
2
3
4
5
Listing 11.3. Retrieving the title text from the normalized feed structure
1
2
3
4
5
6
(defn title [entry] 
  (some->> entry 
           :content  
           (some #(when (= :title (:tag %)) %)) 
           :content  
           first))
1
2
3
4
Listing 11.4. Function to count the number of occurrences of text

1
2
3
4
5
6
7
(defn count-text-task [extractor txt feed] 
   (let [items (feed-children feed) 
        re    (Pattern/compile (str "(?i)" txt))] 
    (->> items 
         (map extractor) 
          (mapcat #(re-seq re %)) 
          count)))
1
2
3
1
2
3
4
5
6
7
8
9
10
(count-text-task 
 title  
 "Erlang" 
 "http://feeds.feedburner.com/ElixirLang") 
;=> 0 
(count-text-task 
  title 
  "Elixir" 
  "http://feeds.feedburner.com/ElixirLang") 
;;=> 14
1
Listing 11.5. Manually spreading tasks over a sequence of futures
1
2
3
4
5
6
7
(def feeds #{"http://feeds.feedburner.com/ElixirLang"  
             "http://blog.fogus.me/feed/"}) 
(let [results (for [feed feeds] 
                (future 
                  (count-text-task title "Elixir" feed)))] 
  (reduce + (map deref results))) 
//=> 17
1
2
3
4
Listing 11.6. Macro to dispatch a sequence of futures
1
2
3
4
5
6
(defmacro as-futures [[a args] & body] 
  (let [parts          (partition-by #{'=>} body) 
         [acts _ [res]] (partition-by #{:as} (first parts)) 
         [_ _ task]     parts] 
    `(let [~res (for [~a ~args] (future  ~@acts))] 
        ~@task)))
1
2
3
1
2
3
4
5
(as-futures [<arg-name> <all-args>] 
  <actions-using-args> 
  :as <results-name> 
 => 
  <actions-using-results>)

Listing 11.7. Counting text occurrences in feed titles fetched in parallel
1
2
3
4
5
6
(defn occurrences [extractor tag & feeds] 
  (as-futures [feed feeds] 
    (count-text-task extractor tag feed) 
    :as results 
   => 
    (reduce + (map deref results))))
1
1
2
3
4
5
(occurrences title "released" 
  "http://blog.fogus.me/feed/" 
  "http://feeds.feedburner.com/ElixirLang" 
  "http://www.ruby-lang.org/en/feeds/news.rss") 
;=> 11
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(def x (promise)) 
(def y (promise)) 
(def z (promise)) 
 
(dothreads! #(deliver z (+ @x @y))) 
 
(dothreads! 
  #(do (Thread/sleep 2000) (deliver x 52))) 
 
(dothreads! 
  #(do (Thread/sleep 4000) (deliver y 86))) 
 
(time @z) 
; "Elapsed time: 3995.414 msecs" 
;=> 138
Listing 11.8. Dispatching a sequence of promises across threads
1
2
3
4
5
6
7
8
9
10
(defmacro with-promises [[n tasks _ as] & body] 
  (when as 
    `(let [tasks# ~tasks 
           n# (count tasks#) 
           promises# (take n# (repeatedly promise))] 
      (dotimes [i# n#] 
        (dothreads! 
          (fn [] 
            (deliver (nth promises# i#) 
                     ((nth tasks# i#)))))) 

11
12
13
      (let [~n tasks# 
            ~as promises#] 
        ~@body))))
Listing 11.9. Parallel test runner using with-promises
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defrecord TestRun [run passed failed]) 
(defn pass [] true) 
 (defn fail [] false) 
(defn run-tests [& all-tests] 
  (with-promises  
    [tests all-tests :as results] 
    (into (TestRun. 0 0 0) 
          (reduce #(merge-with + %1 %2) {} 
            (for [r results] 
              (if @r 
                {:run 1 :passed 1} 
                {:run 1 :failed 1})))))) 
(run-tests pass fail fail fail pass) 
;=> #:user.TestRun{:run 5, :passed 2, :failed 3}
1
2
3
4
1
2
3
4
5
(defn feed-items [k feed] 
  (k 
    (for [item (filter (comp #{:entry :item} :tag) 
                       (feed-children feed))] 
      (-> item :content first :content))))
1
2
3
4
(feed-items 
 count 
 "http://blog.fogus.me/feed/") 
;=> 5
1
2
3
4
5
(let [p (promise)] 
  (feed-items #(deliver p (count %)) 
               "http://blog.fogus.me/feed/") 
  @p) 
;=> 5

Listing 11.10. Transforming a callback-based function to a blocking call
1
2
3
4
5
6
7
8
9
10
(defn cps->fn [f k] 
  (fn [& args] 
    (let [p (promise)] 
      (apply f (fn [x] (deliver p (k x))) args) 
      @p))) 
 
(def count-items (cps->fn feed-items count)) 
 
(count-items "http://blog.fogus.me/feed/") 
;=> 5
1
2
3
4
5
6
7
8
(def kant (promise)) 
(def hume (promise)) 
 
(dothreads! 
  #(do (println "Kant has" @kant) (deliver hume :thinking))) 
 
(dothreads! 
  #(do (println "Hume is" @hume) (deliver kant :fork)))
1
2
(pvalues 1 2 (+ 1 2)) 
;=> (1 2 3)
1
2
3
4
5
6
7
8
9
(defn sleeper [s thing] (Thread/sleep (* 1000 s)) thing) 
(defn pvs [] (pvalues 
               (sleeper 2 :1st) 
               (sleeper 3 :2nd) 
               (keyword "3rd"))) 
 
(-> (pvs) first time) 
;  "Elapsed time: 2000.309 msecs" 
;=> :1st
1
2
3
(-> (pvs) last time) 
; "Elapsed time: 2999.435 msecs" 
;=> :3rd

1
2
3
4
5
6
(->> [1 2 3] 
     (pmap (comp inc (partial sleeper 2))) 
     doall 
     time) 
; "Elapsed time: 2000.811 msecs" 
;=> (2 3 4)
1
1
2
3
4
5
6
7
8
(-> (pcalls 
      #(sleeper 2 :first) 
      #(sleeper 3 :second) 
      #(keyword "3rd")) 
    doall 
    time) 
; "Elapsed time: 3001.039 msecs" 
;=> (:1st :2nd :3rd)
1
2
3
4
5
6
7
8
9
10
(require '[clojure.core.reducers :as r]) 
(def big-vec (vec (range (* 1000 1000)))) 
 
(time (reduce + big-vec)) 
; "Elapsed time: 63.050461 msecs" 
;=> 499999500000 
 
(time (r/fold + big-vec)) 
; "Elapsed time: 27.389584 msecs" 
;=> 499999500000

CHAPTER 12
Listing 12.1. Importing Java classes to create a simple, dynamic web server
1
2
3
4
5
6
7
8
(ns joy.web 
  (:require [clojure.java.io :as io]  
            [clojure.string :as string]) 
  (:import [com.sun.net.httpserver HttpHandler HttpExchange 
            HttpServer] 
           [java.net InetSocketAddress URLDecoder URI] 
           [java.io File FilterOutputStream])) 
(def OK java.net.HttpURLConnection/HTTP_OK)
1
2
1
2
3
4
5
6
7
(defn respond 
  ([exchange body]   
    (respond identity exchange body)) 
  ([around exchange body] 
    (.sendResponseHeaders exchange OK 0) 
    (with-open [resp (around (.getResponseBody exchange))] 
      (.write resp (.getBytes body)))))
1
2
3
4
Listing 12.2. Simplest possible web server using Java
1
2
3
4
5
6
(defn new-server [port path handler] 
  (doto  
    (HttpServer/create (InetSocketAddress. port) 0) 
    (.createContext path handler) 
     (.setExecutor nil)  
    (.start)))
1
2
3
Listing 12.3. De×ning a default web handler using proxy
1
2
3
4
5
(defn default-handler [txt] 
  (proxy [HttpHandler] 
    []  
    (handle [exchange]  
      (respond exchange txt))))
1
2
3

1
2
3
4
5
(def server 
  (new-server 
    8123 
    "/joy/hello" 
    (default-handler "Hello Cleveland")))
1 (.stop server 0)
1
2
3
4
5
(def p (default-handler 
         "There's no problem that can't be solved 
          with another level of indirection")) 
 
(def server (new-server 8123 "/" p))
1
2
3
(update-proxy p 
  {"handle" (fn [this exchange] 
              (respond exchange (str "this is " this)))})
Listing 12.4. Web handler that echoes the request headers
1
2
3
4
(def echo-handler 
  (fn [_ exchange] 
    (let [headers (.getRequestHeaders exchange)] 
      (respond exchange (prn-str headers)))))
1
1 (update-proxy p {"handle" echo-handler})
1
2
3
4
{"Cache-control" ("max-age=0"), 
 "Host" ("localhost:8123"), 
 "Connection" ("keep-alive"), 
 ...}

Figure 12.1. The instance returned by proxy  is a proper proxy that does method
dispatch to functions in a lookup table. These functions can therefore be swapped out
with replacements as needed.
Listing 12.5. “Around” ×lter that wraps an output stream with head and body tags
1
2
3
4
5
6
7
8
(defn html-around [o] 
  (proxy [FilterOutputStream] 
     [o]  
     (write [raw-bytes] 
      (proxy-super write 
         (.getBytes (str "<html><body>" 
                         (String. raw-bytes) 
                        "</body></html>"))))))
1
2
3
4
1
2
(defn listing [file] 
  (-> file .list sort))
1
2
3
4
5
(listing (io/file ".")) 
;;=> (".gitignore" "README.md" "project.clj" "src" "target" "test") 
 
(listing (io/file "./README.md")) 
;;=> ()

Listing 12.6. Quick and dirty function to generate HTML ×le listings
1
2
3
4
5
6
7
8
9
10
11
(defn html-links [root filenames] 
  (string/join 
   (for [file filenames] 
     (str "<a href='" 
          (str root 
               (if (= "/" root)  
                 "" 
                 File/separator) 
               file) 
          "'>" 
          file "</a><br>"))))
1
1
2
3
4
5
6
7
8
(html-links "." (listing (io/file "."))) 
 
;;=> "<a href='./.gitignore'>.gitignore</a><br> 
;;       <a href='./README.md'>README.md</a><br> 
;;       <a href='./project.clj'>project.clj</a><br> 
;;       <a href='./src'>src</a><br> 
;;       <a href='./target'>target</a><br> 
;;       <a href='./test'>test</a><br>"
Listing 12.7. Function to build a string representation of a ×le-size listing
1
2
3
4
5
6
7
(defn details [file] 
  (str (.getName file) " is " 
       (.length file)  " bytes.")) 
 
(details (io/file "./README.md")) 
 
;;=> "README.md is 330 bytes."
Listing 12.8. Function to convert a relative-path URI into a ×le
1
2
3
4
5
6
7
8
9
10
(defn uri->file [root uri] 
  (->> uri 
       str 
       URLDecoder/decode  
       (str root) 
       io/file)) 
(uri->file "." (URI. "/project.clj")) 
;;=> #<File ./project.clj> 
(details (uri->file "." (URI. "/project.clj"))) 
;;=> "project.clj is 289 bytes."
1
2
3

Figure 12.2. A directory listing served by the simple web server
Figure 12.3. File details served by the simple web server
Listing 12.9. Web handler to list and navigate a local ×le system
1
2
3
4
5
6
7
8
9
10
11
(def fs-handler 
  (fn [_ exchange] 
    (let [uri  (.getRequestURI exchange) 
          file (uri->file "." uri)] 
      (if (.isDirectory file) 
        (do (.add (.getResponseHeaders exchange)          
                  "Content-Type" "text/html") 
            (respond html-around 
                     exchange 
                     (html-links (str uri) (listing file)))) 
        (respond exchange (details file))))))
1
2
3
4
1 (update-proxy p {"handle" fs-handler})
Listing 12.10. DynaFrame  class ns  block showing rich gen-class  usage
1
2
3
4
5
6
(ns joy.gui.DynaFrame 
  (:gen-class 
   :name         joy.gui.DynaFrame 
   :extends      javax.swing.JFrame 
   :implements   [clojure.lang.IMeta] 
   :prefix       df- 
1
2

7
8
9
10
11
12
13
14
   :state        state  
   :init         init  
   :constructors {[String] [String] 
                 [] [String]} 
   :methods      [[display [java.awt.Container] void] 
                 ^{:static true} [version [] String]]) 
 (:import (javax.swing JFrame JPanel JComponent) 
           (java.awt BorderLayout Container)))
3
4
5
6
7
1
2
3
4
(joy.gui.DynaFrame. "First try") 
 
; java.lang.UnsupportedOperationException: 
;   joy.gui.DynaFrame/df-init not defined
1
2
3
4
(in-ns 'joy.gui.DynaFrame) 
 
(defn df-init [title] 
  [[title] (atom {::title title})])
1
2
3
4
(joy.gui.DynaFrame. "2nd") 
 
; java.lang.UnsupportedOperationException: 
;   meta (joy.gui.DynaFrame/df-meta not defined?)
1
2
(defn df-meta [this] @(.state this)) 
(defn version [] "1.0")
1
2
3
4
5
(meta (joy.gui.DynaFrame. "3rd")) 
;=> {:joy.gui.DynaFrame/title "3rd"} 
 
(joy.gui.DynaFrame/version) 
;=> "1.0"

Figure 12.4. Now that you’ve compiled the DynaFrame  class, you can start using it to
display simple GUIs.
Figure 12.5. You can update the DynaFrame  on the Øy without restarting.
1
2
3
4
5
6
7
8
(defn df-display [this pane] 
  (doto this 
    (-> .getContentPane .removeAll) 
 
    (.setContentPane (doto (JPanel.) 
                       (.add pane BorderLayout/CENTER))) 
    (.pack) 
    (.setVisible true)))
1
2
3
4
(def gui (joy.gui.DynaFrame. "4th")) 
 
(.display gui (doto (javax.swing.JPanel.) 
                (.add (javax.swing.JLabel. "Charlemagne and Pippin"))))
1
2
(.display gui (doto (javax.swing.JPanel.) 
              (.add (javax.swing.JLabel. "Mater semper certa est." ))))
1
2
3
4
5
6
7
package joy.gui; 
public class DynaFrame$df_display extends AFunction { 
    . . . 
    public Object invoke(Object that, Object container) { 
        . . . display actions . . . 
    } 
}

Figure 12.6. Using only a handful of rudimentary containers, you can build neato GUI
prototypes.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
package joy.gui; 
 
public class DynaFrame extends javax.swing.JFrame { 
    public final Object state; 
    public DynaFrame(String title) { 
      Object r =  clojure.lang.RT.var("joy.gui.DynaFrame", "df-init") 
                     .invoke(title); 
      Object cargs = clojure.lang.RT.nth(r, 0); 
      state = clojure.lang.RT.nth(r, 1); 
      super((String) clojure.lang.RT.nth(cargs, 0)); 
    } 
 
    public static String version() { return "1.0"; } 
 
    // Delegate to the display function var 
    public void display(Object the_this, java.awt.Container c) { 
        return clojure.lang.RT.var("joy.gui.DynaFrame", "df-display") 
                 .invoke(the_this, c); 
    } 
 
    . . . 
}
Listing 12.11. Simple GUI containers
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(ns joy.gui.socks 
  (:import 
   (joy.gui DynaFrame) 
   (javax.swing Box BoxLayout JTextField JPanel 
                JSplitPane JLabel JButton 
                JOptionPane) 
   (java.awt BorderLayout Component GridLayout FlowLayout) 
   (java.awt.event ActionListener))) 
 
(defn shelf [& components] 
  (let [shelf (JPanel.)] 
     (.setLayout shelf (FlowLayout.)) 
     (doseq [c components] (.add shelf c)) 
     shelf)) 
 

Figure 12.7. DynaFrame  alerts: you can create slightly more complex GUIs and attach
actions on the Øy.
16
17
18
19
20
21
22
23
24
25
26
27
(defn stack [& components] 
  (let [stack (Box. BoxLayout/PAGE_AXIS)] 
     (doseq [c components] 
       (.setAlignmentX c Component/CENTER_ALIGNMENT) 
       (.add stack c)) 
     stack)) 
 
  (defn splitter [top bottom] 
   (doto (JSplitPane.) 
     (.setOrientation JSplitPane/VERTICAL_SPLIT) 
     (.setLeftComponent top) 
     (.setRightComponent bottom)))
Listing 12.12. Set of simple widgets
1
2
3
4
5
6
7
8
9
10
11
12
13
(defn button [text f] 
  (doto (JButton. text) 
    (.addActionListener 
     (proxy [ActionListener] [] 
       (actionPerformed [_] (f)))))) 
 
 
(defn txt  [cols t] 
  (doto (JTextField.) 
    (.setColumns cols) 
     (.setText t))) 
 
(defn label [txt] (JLabel. txt))
1
2
3
4
(defn alert 
  ([msg] (alert nil msg)) 
  ([frame msg] 
     (javax.swing.JOptionPane/showMessageDialog frame msg)))

Figure 12.8. A much more elaborate DynaFrame  GUI. There’s no limit to the
complexity of this simple GUI model. Go ahead and experiment to your heart’s content.
1
2
3
4
(.display gui 
  (splitter 
    (button "Procrastinate" #(alert "Eat Cheetos")) 
    (button "Move It" #(alert "Couch to 5k"))))
1
2
3
4
5
6
7
(defn grid [x y f] 
   (let [g (doto (JPanel.) 
             (.setLayout (GridLayout. x y)))] 
      (dotimes [i x] 
        (dotimes [j y] 
         (.add g (f)))) 
      g))
Listing 12.13. A more complex GUI example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(.display gui 
   (let [g1 (txt 10 "Charlemagne") 
          g2 (txt 10 "Pippin") 
          r  (txt 3 "10") 
          d  (txt 3 "5")] 
      (splitter  
        (stack 
          (shelf (label "Player 1") g1) 
          (shelf (label "Player 2") g2) 
          (shelf (label "Rounds ") r 
                 (label "Delay  ") d)) 
        (stack  
          (grid 21 11 #(label "-")) 
          (button "Go!" #(alert (str (.getText g1) " vs. " 
1
2
3
4

15
16
17
                                     (.getText g2) " for " 
                                     (.getText r)  " rounds, every " 
                                     (.getText d)  " seconds.")))))))
1
2
3
4
(doto (StringBuilder. "abc") 
  (.append (into-array [\x \y \z]))) 
 
;=> #<StringBuilder abc[Ljava.lang.Character;@65efb4be>
1
2
3
4
(doto (StringBuilder. "abc") 
  (.append (char-array [\x \y \z]))) 
 
;=> #<StringBuilder abcxyz>
1
2
3
4
5
6
7
8
9
10
(let [ary (make-array Long/TYPE 3 3)] 
  (dotimes [i 3] 
    (dotimes [j 3] 
      (aset ary i j (+ i j)))) 
  (map seq ary)) 
 
;=> ((0 1 2) (1 2 3) (2 3 4)) 
 
(into-array Integer/TYPE [1 2 3]) 
;=> #<int[] [I@391be9d4>
1
2
3
4
5
6
7
8
9
10
11
(into-array ["a" "b" "c"]) 
;=> #<String[] [Ljava.lang.String;@3c3ac93e> 
 
(into-array [(java.util.Date.) (java.sql.Time. 0)]) 
;=> #<Date[] [Ljava.util.Date;@178aab40> 
 
(into-array ["a" "b" 1M]) 
; java.lang.IllegalArgumentException: array element type mismatch 
 
(into-array Number [1 2.0 3M 4/5]) 
;=> #<Number[] [Ljava.lang.Number;@140b6e46>

Table 12.1. Array type class names and dimensions
Representation
Array type
[Ljava.lang.Object;
Reference array
[B
Primitive byte array
[I
Primitive int array
[C
Primitive char array
[S
Primitive short array
1
2
3
4
5
6
7
8
9
10
11
to-array-2d function: 
 
(to-array-2d [[1 2 3] 
              [4 5 6]]) 
;=> #<Object[][] [[Ljava.lang.Object;@bdccedd> 
 
(to-array ["a" 1M #(%) (proxy [Object] [])]) 
;=> #<Object[] [Ljava.lang.Object;@18987a33> 
 
(to-array [1 (int 2)]) 
;=> #<Object[] [Ljava.lang.Object;@6ad3c65d>
1
2
3
4
(def ary  (into-array [1 2 3])) 
(def sary (seq ary)) 
sary 
;=> (1 2 3)
1
2
3
(aset ary 0 42) 
sary 
;=> (42 2 3)
1
2
3
4
5
6
7
8
9
(defn asum-sq [xs] 
  (let [dbl (amap xs i ret 
              (* (aget xs i) 
                 (aget xs i)))] 
    (areduce dbl i ret 0 
      (+ ret (aget dbl i))))) 
 
(asum-sq (double-array [1 2 3 4 5])) 
;=> 55.0

Representation
Array type
[F
Primitive oat array
[D
Primitive double array
[J
Primitive long array
[Z
Primitive boolean array
Representation
Dimension
[
1D
[[
2D
...
And so on ...
1
2
3
4
5
6
7
8
(what-is (into-array ["a" "b"])) 
;=> "1d String" 
 
(what-is (to-array-2d [[1 2][3 4]])) 
;=> "2d Object" 
 
(what-is (make-array Integer/TYPE 2 2 2 2)) 
;=> "Primitive 4d int"
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(defmulti what-is class) 
(defmethod what-is 
  (Class/forName "[Ljava.lang.String;") 
  [_] 
  "1d String") 
 
(defmethod what-is 
  (Class/forName "[[Ljava.lang.Object;") 
  [_] 
  "2d Object") 
 
(defmethod what-is 
  (Class/forName "[[[[I") 
  [_] 
  "Primitive 4d int")
1
2
3
(what-is (into-array [[1.0] [2.0]])) 
; java.lang.IllegalArgumentException: No method in multimethod 
;  'what-is' for dispatch value: class [Lclojure.lang.PersistentVector;
1
2
3
(defmethod what-is (Class/forName "[[D") [a] "Primitive 2d double") 
(defmethod what-is (Class/forName "[Lclojure.lang.PersistentVector;") 
[a] "1d Persistent Vector") 

4
5
6
7
8
9
 
(what-is (into-array (map double-array [[1.0] [2.0]]))) 
;=> "Primitive 2d double" 
 
(what-is (into-array [[1.0] [2.0]])) 
;=> "1d Persistent Vector"
1
2
3
4
(String/format "An int %d and a String %s" 
  (to-array [99, "luftballons"])) 
 
;=> "An int 99 and a String luftballons"
1
2
3
4
5
6
7
(import '[java.util Comparator Collections ArrayList]) 
 
(defn gimme [] (ArrayList. [1 3 4 8 2])) 
(doto (gimme) 
  (Collections/sort (Collections/reverseOrder))) 
 
;=> [8, 4, 3, 2, 1]
1
2
3
4
5
6
7
8
9
(doto (gimme) 
  (Collections/sort 
    (reify Comparator 
      (compare [this l r] 
        (cond 
          (> l r) -1 
          (= l r) 0 
          :else 1))))) 
;=> #<ArrayList [8, 4, 3, 2, 1]>
1
2
3
4
5
6
7
8
(doto (gimme) (Collections/sort #(compare %2 %1))) 
;;=> #<ArrayList [8, 4, 3, 2, 1]> 
(doto (gimme) (Collections/sort >)) 
;;=> #<ArrayList [8, 4, 3, 2, 1]> 
(doto (gimme) (Collections/sort <)) 
;;=> #<ArrayList [1, 2, 3, 4, 8]> 
(doto (gimme) (Collections/sort (complement <))) 
;;=> #<ArrayList [8, 4, 3, 2, 1]>
1
2
3
4

1
2
3
4
5
6
(doto (Thread. #(do (Thread/sleep 5000) 
                    (println "haikeeba!"))) 
  .start) 
; => #<Thread Thread[Thread-3,5,main]> 
; ... 5 seconds later 
; haikeeba!
1
2
3
4
5
6
7
(import '[java.util.concurrent FutureTask]) 
 
(let [f (FutureTask. #(do (Thread/sleep 5000) 42))] 
  (.start (Thread. #(.run f))) 
  (.get f)) 
; ... 5 seconds later 
;=> 42
Listing 12.14. java.util.List  conformance for sequences and seqs
1
2
3
4
5
6
7
8
(.get '[a b c] 1) 
;=> b 
(.get (repeat :a) 138)  
;=> :a 
(.containsAll '[a b c] '[b c]) 
;=> true 
(.add '[a b c] 'd) 
; java.lang.UnsupportedOperationException
1
2
3
4
1
2
(java.util.Collections/sort [3 4 2 1]) 
; java.lang.UnsupportedOperationException
1
2
3
4
5
6
7
8
9
10
11
(.compareTo [:a] [:a]) 
;=> 0 
 
(.compareTo [:a :b] [:a]) 
;=> 1 
 
(.compareTo [:a :b] [:a :b :c]) 
;=> -1 
 
(sort [[:a :b :c] [:a] [:a :b]]) 
;=> ([:a] [:a :b] [:a :b :c])

1
2
3
4
(.compareTo [1 2 3] '(1 2 3)) 
 
; java.lang.ClassCastException: clojure.lang.PersistentList 
;    cannot be cast to clojure.lang.IPersistentVector
1
2
(.get '[a b c] 2) 
;=> c
1
2
3
4
5
6
(defn shuffle [coll] 
  (seq (doto (java.util.ArrayList. coll) 
         java.util.Collections/shuffle))) 
 
(shuffle (range 10)) 
;=> (3 9 2 5 4 7 8 6 1 0)
1
2
3
4
5
(java.util.Collections/unmodifiableMap 
  (doto (java.util.HashMap.) (.put :a 1))) 
;=> #<UnmodifiableMap {:a=1}> 
(into {} (doto (java.util.HashMap.) (.put :a 1))) 
;=> {:a 1}
1
2
3
4
5
6
(def x (java.awt.Point. 0 0)) 
(def y (java.awt.Point. 0 42)) 
(def points #{x y}) 
points 
;=> #{#<Point java.awt.Point[x=0,y=0]> 
#<Point java.awt.Point[x=0,y=42]>}

1
2
3
4
(.setLocation y 0 0) 
points 
;=> #{#<Point java.awt.Point[x=0,y=0]> 
#<Point java.awt.Point[x=0,y=0]>}
Listing 12.15. Interface de×ning a sliceable object
1
2
3
4
(definterface ISliceable 
  (slice [^long s ^long e]) 
  (^long sliceCount [])) 
;=> user.ISliceable
Listing 12.16. Dummy rei×ed ISliceable
1
2
3
4
5
6
7
8
9
10
(def dumb 
  (reify user.ISliceable 
    (slice [_ s e] [:empty]) 
    (sliceCount [_] 42))) 
 
(.slice dumb 1 2) 
;=> [:empty] 
 
(.sliceCount dumb) 
;=> 42
Listing 12.17. Using a protocol to extend ISliceable
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defprotocol Sliceable 
  (slice [this s e]) 
  (sliceCount [this])) 
 
(extend user.ISliceable 
  Sliceable 
  {:slice (fn [this s e] (.slice this s e)) 
   :sliceCount (fn [this] (.sliceCount this))}) 
 
(sliceCount dumb) 
;=> 42 
 
(slice dumb 0 0) 
;=> [:empty]

Listing 12.18. Extending strings along the Sliceable  protocol
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(defn calc-slice-count [thing] 
  "Calculates the number of possible slices using the formula: 
     (n + r - 1)! 
     ------------ 
      r!(n - 1)! 
   where n is (count thing) and r is 2" 
  (let [! #(reduce * (take % (iterate inc 1))) 
        n (count thing)] 
    (/ (! (- (+ n 2)  1)) 
       (* (! 2) (! (- n 1)))))) 
 
(extend-type String 
  Sliceable 
  (slice [this s e] (.substring this s (inc e))) 
  (sliceCount [this] (calc-slice-count this))) 
 
(slice "abc" 0 1) 
;=> "ab" 
(sliceCount "abc") 
;=> 6
1
2
3
(defn explode [] (explode)) 
(try (explode) (catch Exception e "Stack is blown")) 
; java.lang.StackOverflowError
1
2
3
4
5
6
7
8
9
10
11
12
(try (explode) (catch StackOverflowError e "Stack is blown")) 
;=> "Stack is blown" 
(try (explode) (catch Error e "Stack is blown")) 
;=> "Stack is blown" 
 
 
(try (explode) (catch Throwable e "Stack is blown")) 
;=> "Stack is blown" 
 
(try (throw (RuntimeException.)) 
  (catch Throwable e "Catching Throwable is Bad")) 
;=> "Catching Throwable is Bad"
1
2
3
4
(defmacro do-something [x] `(~x)) 
(do-something 1) 
; java.lang.ClassCastException: 
;   java.lang.Integer cannot be cast to clojure.lang.IFn

Figure 12.9. There are two ways to handle errors in Clojure. The typical way is to let
exceptions Øow from the inner forms to the outer. The other way, discussed in section
17.4, uses dynamic bindings to reach into the inner forms to handle errors immediately.
1
2
3
4
5
6
7
8
9
10
11
(defmacro pairs [& args] 
  (if (even? (count args)) 
   `(partition 2 '~args) 
    (throw (Exception. 
             (str "pairs requires an even number of args"))))) 
 
(pairs 1 2 3) 
; java.lang.Exception: pairs requires an even number of args 
 
(pairs 1 2 3 4) 
;=> ((1 2) (3 4))
1
2
(fn [] (pairs 1 2 3)) 
; java.lang.Exception: pairs requires an even number of args
1
2
3
4
5
6
7
8
9
(defmacro -?> [& forms] 
 `(try (-> ~@forms) 
    (catch NullPointerException _# nil))) 
 
(-?> 25 Math/sqrt (+ 100)) 
;=> 105.0 
 
(-?> 25 Math/sqrt (and nil) (+ 100)) 
;=> nil

1
2
(defn perform-unclean-act [x y] 
  (/ x y))
1
2
3
4
5
6
(try 
  (perform-unclean-act 42 0) 
  (catch RuntimeException ex 
    (println (str "Something went wrong.")))) 
 
;; Something went wrong.
1
2
3
4
5
6
(defn perform-cleaner-act [x y] 
  (try 
    (/ x y) 
    (catch ArithmeticException ex 
      (throw (ex-info "You attempted an unclean act" 
                      {:args [x y]})))))
1
2
3
4
5
6
7
8
(try 
  (perform-cleaner-act 108 0) 
  (catch RuntimeException ex 
    (println (str "Received error: "   (.getMessage ex))) 
    (when-let [ctx (ex-data ex)] 
      (println (str "More information: " ctx))))) 
 

9 ;; Received error: You attempted an unclean act 
;; More information: {:args [108 0]}

CHAPTER 13
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
;; Clojure 1.5.1 clojure/src/jvm/clojure/lang/RT.java line 527 
public static int count(Object o){ 
    if(o instanceof Counted) 
       return ((Counted) o).count(); 
    return countFrom(Util.ret1(o, o = null)); 
} 
static int countFrom(Object o){  
    if(o == null) 
        return 0; 
        /* ...some else-if's elided for brevity... */ 
    else if(o instanceof Collection) 
        return ((Collection) o).size(); 
    else if(o instanceof Map) 
        return ((Map) o).size(); 
    else if(o.getClass().isArray()) 
        return Array.getLength(o); 
    throw new UnsupportedOperationException( 
      "count not supported on this type: "  
      + o.getClass().getSimpleName()); 
}
1
2
3
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
;; ClojureScript r1835 src/cljs/cljs/core.cljs line 195 
(defprotocol ICounted  
  (-count [coll] "constant time count")) 
;; ClojureScript r1835 src/cljs/cljs/core.cljs line 492 
(extend-type nil 
  ICounted  
  (-count [_] 0)) 
;; ClojureScript r1835 src/cljs/cljs/core.cljs line 730 
(extend-type array 
  ICounted  
  (-count [a] (alength a)) 
;; ClojureScript r1835 src/cljs/cljs/core.cljs line 840 
(defn count 
  "Returns the number of items in the collection. (count nil) returns 
  0.  Also works on strings, arrays, and Maps" 
  [coll] 
  (if (counted? coll) 
    (-count coll) 
    (accumulating-seq-count coll)))
1
2
3
4
Listing 13.1. Extending ICounted  to LinkedMap

1
2
3
4
5
6
7
8
9
10
11
12
(ns cljs.user 
  (:require [goog.structs.LinkedMap])) 
(extend-type goog.structs.LinkedMap 
  cljs.core.ICounted 
  (-count [m] (.getCount m))) 
(def m (goog.structs.LinkedMap.)) 
(count m) 
;=> 0 
(.set m :foo :bar) 
(.set m :baz :qux) 
(count m) 
;=> 2
1
2
3
4
1
2
3
4
(def pm {:answer 42}) 
 
(pm :answer) 
;=> 42
Listing 13.2. Extending IFn  to LinkedMap
1
2
3
4
5
6
7
8
9
10
(.set m 43 :odd) 
(m 43) 
;; "Error evaluating:" (m 43) :as "cljs.user.m.call(null,43)" 
(extend-type goog.structs.LinkedMap 
  cljs.core/IFn 
  (-invoke  
    ([m k] (.get m k nil)) 
    ([m k not-found] (.get m k not-found)))) 
(m 43)  
;=> :odd
1
2
3
4
1
2
3
(defproject joy/music "1.0.0" 
  :dependencies [[org.clojure/clojure "1.5.1"] 
                 [org.clojure/clojurescript "0.0-1835"]])
1
2
3
4
(require '[cljs.compiler :as comp] 
         '[cljs.analyzer :as ana]) 
 
(def code-string "(defn hello [x] (js/alert (pr-str 'greetings x)))")

1
2
3
(def code-data (read-string code-string)) 
code-data 
;=> (defn hello [x] (js/alert (pr-str (quote greetings) x)))
1
2
3
4
(first code-string)  ;; A Character: 
;=> \( 
(first code-data) ;; A Symbol: 
;=> defn
1 (def ast (ana/analyze (ana/empty-env) code-data))
1
2
(keys ast) 
;=> (:children :env :op :form :name :var :doc :init)
Listing 13.3. De×nition of the print-ast  function
1
2
3
4
5
6
7
8
9
10
(require '[clojure.walk :refer [prewalk]] 
         '[clojure.pprint :refer [pprint]]) 
(defn print-ast [ast] 
  (pprint  
    (prewalk 
      (fn [x] 
        (if (map? x) 
          (select-keys x [:children :name :form :op]) 
          x))  
      ast)))
1
2
3
4
1
2
3
4
5
6
7
8
9
10
{:op :def, 
 :form (def hello (clojure.core/fn ([x]  
                    (js/alert (pr-str 'greetings x))))), 
 :name cljs.user/hello, 
 :children 
 [{:op :fn, 
   :form (fn* ([x] (js/alert (pr-str 'greetings x)))), 
   :name hello, 
   :children 
   [{:op :do, 
1
2

11
12
13
14
15
16
17
18
19
20
21
22
     :form (do (js/alert (pr-str 'greetings x))), 
     :children 
     [{:op :invoke, 
       :form (js/alert (pr-str 'greetings x)), 
       :children 
       [{:op :var, :form js/alert} 
        {:op :invoke, 
         :form (pr-str 'greetings x), 
         :children 
         [{:op :var, :form pr-str} 
          {:op :constant, :form greetings} 
          {:op :var, :form x}]}]}]}]}]}
1
2
3
4
5
6
7
(comp/emit ast) 
; cljs.user.hello = (function hello(x){ 
; return alert(cljs.user.pr_str.call(null, 
;   new cljs.core.Symbol(null,"greetings","greetings", 
;                        432603411,null),x)); 
; }); 
;=> nil
Listing 13.4. project.clj for music
1
2
3
4
5
6
7
8
9
10
11
(defproject joy/music "1.0.0" 
  :dependencies [[org.clojure/clojure "1.5.1"] 
                 [org.clojure/clojurescript "0.0-1835"]] 
  :plugins [[lein-cljsbuild "0.3.2"]] 
  :cljsbuild 
  {:builds  
   [{:source-paths ["src/cljs"] 
     :compiler 
     {:output-to "dev-target/all.js" 
      :optimizations :whitespace 
      :pretty-print true}}]})
1
2
Listing 13.5. HTML contents of music.html
1
2
3
4
5
6
7
8
<!DOCTYPE html> 
<html lang="en"> 
  <head><title>Web Audio with ClojureScript</title></head> 
  <body> 
    <button onclick="joy.music.go()">Play</button> 
    <script src="dev-target/all.js"></script> 
  </body> 
</html>

Listing 13.6. Web Audio functions in ClojureScript
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
(ns joy.music) 
(defn soft-attack  
  "Return a gain node that goes from silent at time <delay> 
  up to <volume> in 50 milliseconds, then ramps back down 
  to silent after <duration>" 
  [ctx {:keys [volume delay duration]}] 
  (let [node (.createGainNode ctx)] 
    (doto (.-gain node) 
      (.linearRampToValueAtTime 0 delay) 
      (.linearRampToValueAtTime volume (+ delay 0.05)) 
      (.linearRampToValueAtTime 0 (+ delay duration))) 
    node)) 
(defn sine-tone 
  "Return an oscillator that plays starting at  
   <delay> for <duration> seconds" 
  [ctx {:keys [cent delay duration]}] 
  (let [node (.createOscillator ctx)] 
    (set! (-> node .-frequency .-value) 440) 
    (set! (-> node .-detune .-value) (- cent 900)) 
 
    (.noteOn node delay) 
    (.noteOff node (+ delay duration)) 
    node)) 
(defn connect-to 
  "Connect the output of node1 to the input of node2,  
   returning node2" 
  [node1 node2] 
  (.connect node1 node2) 
  node2) 
(defn woo  
  "Play a 'woo' sound; sounds a bit like a glass harp." 
  [ctx note] 
  (let [linger 1.5 
        note (update-in note [:duration] * linger)] 
    (-> (sine-tone ctx note) 
        (connect-to (soft-attack ctx note))))) 
(def make-once (memoize (fn [ctor] (new ctor)))) 
(defn play! 
  "Kick off playing a sequence of notes. note-fn must take 
  two arguments, an AudioContext object and a map 
  representing one note to play. It must return an AudioNode 
  object that will play that note." 
  [note-fn notes] 
  (if-let [ctor (or (.-AudioContext js/window) 
                      (.-webkitAudioContext js/window))] 
    (let [ctx (make-once ctor) 
          compressor (.createDynamicsCompressor ctx)] 
      (let [now (.-currentTime ctx)] 
        (doseq [note notes] 
          (-> 
           (note-fn ctx (update-in note [:delay] + now)) 
           (connect-to compressor)))) 
      (connect-to compressor (.-destination ctx))) 
    (js/alert "Sorry, this browser doesn't support AudioContext")))
1
2
3
4
5
6
7
8
1 (play! woo [{:cent 1100, :duration 1, :delay 0, :volume 0.4}])

1
2
3
(play! woo [{:cent 1100, :duration 1, :delay 0.0, :volume 0.4} 
            {:cent 1400, :duration 1, :delay 0.2, :volume 0.4} 
            {:cent 1800, :duration 1, :delay 0.4, :volume 0.4}])
Listing 13.7. Tune-construction functions
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
(defn pair-to-note  
  "Return a note map for the given tone and duration" 
  [[tone duration]] 
  {:cent (* 100 tone) 
   :duration duration 
   :volume 0.4}) 
(defn consecutive-notes  
  "Take a sequence of note maps that have no :delay, and return them 
  with correct :delay's so that they will play in the order given." 
  [notes] 
  (reductions (fn [{:keys [delay duration]} note] 
                (assoc note 
                  :delay (+ delay duration))) 
              notes)) 
(defn notes [tone-pairs] 
  "Returns a sequence of note maps at moderate tempo for 
  the given sequence of tone-pairs." 
  (let [bpm 360 
        bps (/ bpm 60)] 
    (->> tone-pairs 
         (map pair-to-note) 
         consecutive-notes 
         (map #(update-in % [:delay] / bps)) 
         (map #(update-in % [:duration] / bps))))) 
(defn magical-theme  
  "A sequence of notes for a magical theme" 
  [] 
  (notes 
   (concat 
    [[11 2] [16 3] [19 1] [18 2] [16 4] [23 2]] 
    [[21 6] [18 6] [16 3] [19 1] [18 2] [14 4] [17 2] [11 10]] 
    [[11 2] [16 3] [19 1] [18 2] [16 4] [23 2]] 
    [[26 4] [25 2] [24 4] [20 2] [24 3] [23 1] [22 2] [10 4]  
     [19 2] [16 10]]))) 
(defn go []  
  (play! woo (magical-theme)))
1
2
3
4
5
6
1
2
3
4
5
{:source-paths ["src/cljs"] 
 :compiler 
 {:output-to "prod-target/all.js" 
  :optimizations :advanced 
  :pretty-print false}}
1 <script src="prod-target/all.js"></script>

1 Uncaught ReferenceError: joy is not defined
1
2
(defn ^:export go [] 
  (play! woo (notes magical-theme)))
1
2
3
4
{:output-to "prod-target/all.js" 
 :optimizations :advanced 
 :externs ["externs.js"] 
 :pretty-print false}
1
2
3
var window = {}; 
window.AudioContext = function(){}; 
window.webkitAudioContext = function(){};
1 Uncaught TypeError: Object #<AudioContext> has no method 'ub'
Listing 13.8. Using analyze  to generate an AST for a ClojureScript ×le
1
2
3
4
5
6
7
8
9
10
(ns joy.externs-for-cljs 
  (:require [cljs.compiler :as comp] 
            [cljs.analyzer :as ana] 
            [clojure.walk :refer [prewalk]] 
            [clojure.pprint :refer [pprint]] 
            [clojure.java.io :as io]) 
  (:import (clojure.lang LineNumberingPushbackReader))) 
(defn read-file 
  "Read the contents of filename as a sequence of Clojure values." 
  [filename] 

11
12
13
14
15
16
17
18
19
20
21
22
23
24
  (let [eof (Object.)] 
    (with-open [reader (LineNumberingPushbackReader. 
                         (io/reader filename))] 
      (doall  
      (take-while #(not= % eof) 
                   (repeatedly #(read reader false eof))))))) 
(defn file-ast 
  "Return the ClojureScript AST for the contents of filename. Tends to 
  be large and to contain cycles -- be careful printing at the REPL." 
  [filename] 
  (binding [ana/*cljs-ns* 'cljs.user 
            ana/*cljs-file* filename] 
   (mapv #(ana/analyze (ana/empty-env) %) 
          (read-file filename))))
1
2
1
2
3
4
5
(count (file-ast "src/cljs/joy/music.cljs")) 
;=> 11 
 
(first (file-ast "src/cljs/joy/music.cljs")) 
;=> {:requires nil, :form (ns joy.music) ...}
1
2
3
4
5
6
7
(defn flatten-ast [ast] 
  (mapcat #(tree-seq :children :children %) ast)) 
 
(def flat-ast (flatten-ast (file-ast "src/cljs/joy/music.cljs"))) 
 
(count flat-ast) 
;=> 473
1
2
3
4
5
6
7
8
9
10
11
(defn get-interop-used 
  "Return a set of symbols representing the method and field names 
  used in interop forms in the given sequence of AST nodes." 
  [flat-ast] 
  (set (keep #(some % [:method :field]) flat-ast))) 
 
(get-interop-used flat-ast) 
;=> #{noteOn value webkitAudioContext AudioContext gain 
 createDynamicsCompressor frequency detune linearRampToValueAtTime 
 destination currentTime createOscillator createGainNode connect 
 noteOff}
1
2
3
4
(defn externs-for-interop [syms] 
  (apply str 
         "var DummyClass={};\n" 

5          (map #(str "DummyClass." % "=function(){};\n") 
              syms)))
1 (spit "externs.js" (externs-for-interop (get-interop-used flat-ast)))
1 lein cljsbuild once
Listing 13.9. consecutive-notes  function ×xed to work in Clojure
1
2
3
4
5
6
7
8
9
(defn consecutive-notes 
  "Take a sequences of note maps that have no :delay, and return them 
  with correct :delay's so that they will play in the order given." 
  [notes] 
  (reductions (fn [{:keys [delay duration]} note] 
                (assoc note 
                  :delay (+ delay duration))) 
              {:delay 0 :duration 0} 
              notes))
1
1
2
No method in multimethod 'emit-constant' 
for dispatch value: class clojure.lang.Ratio
Listing 13.10. notes  function ×xed to work in Clojure
1
2
3
4
5
6
7
8
9
10
(defn notes [tone-pairs] 
  "Returns a sequence of note maps at moderate tempo for the given 
  sequence of tone-pairs." 
  (let [bpm 360 
        bps (/ bpm 60)] 
    (->> tone-pairs 
         (map pair-to-note) 
         consecutive-notes 
         (map #(update-in % [:delay] (comp double /) bps)) 
         (map #(update-in % [:duration] (comp double /) bps)))))
1

1 lein trampoline cljsbuild repl-rhino

CHAPTER 14
Product ID
Product name
Supplier ID
Price
Unit sales
Total
0
Pumpkin
spice
0
0.99
400,000
396,000.00
1
Dung spice
1
1.99
null
null
1
2
3
4
5
6
7
8
9
create table COFFEE 
  (COF_ID int NOT NULL AUTO_INCREMENT, 
   COF_NAME varchar(64) NOT NULL, 
   SUP_ID int NOT NULL, 
   PRICE numeric(10,2) NOT NULL, 
   UNIT_SALES integer, 
   TOTAL numeric(10,2), 
   PRIMARY KEY (COF_ID), 
   FOREIGN KEY (SUP_ID) REFERENCES SUPPLIERS (SUP_ID));
1
2
3
4
5
6
select COF_NAME from COFFEE 
  where COFFEE.UNIT_SALES is NULL; 
 
--> COF_NAME 
--> -------- 
--> Dung spice
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
// ... some details elided 
 
public static void viewTable(Connection con) throws SQLException { 
 
    Statement stmt = null; 
    String query = "select COF_NAME, SUP_ID, " + 
                   "PRICE, UNIT_SALES, TOTAL from " + 
                   "COFFEE_DB.COFFEE"; 
    try { 
        stmt = con.createStatement(); 
        ResultSet rs = stmt.executeQuery(query); 
        while (rs.next()) { 
            String coffeeName = rs.getString("COF_NAME"); 
            int supplierID = rs.getInt("SUP_ID"); 
            float price = rs.getFloat("PRICE"); 
            int sales = rs.getInt("UNIT_SALES"); 
            float total = rs.getFloat("TOTAL"); 
            doPrint(coffeeName, supplierID, price, sales, total); 
        } 

Figure 14.1. Accessing rectangular data in Java is often a chore, highlighting the vast
differences in the data model and the code to access it.
Figure 14.2. Via various programming magicks, an ORM provides a class-instance
interface that maps to database tables on the back end for its property values.
20
21
22
23
24
25
    } catch (SQLException e ) { 
        JDBCTutorialUtilities.printSQLException(e); 
    } finally { 
        if (stmt != null) { stmt.close(); } 
    } 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
@Entity 
@Table(name="COFFEE") 
public class Coffee implements Ormish { 
    @Id 
    Long id; 
 
    @Column(name="COF_NAME") 
    String name; 
 
    @Reference(via="SUPPLIERS") 
    Supplier supp; 
 
    ... more elided 
}

Product name
Price
Pumpkin spice
0.99
Dung spice
1.99
1
2
3
4
5
6
7
8
Supplier supp = new Supplier("Quarks Coffee"); 
supp.save(); 
 
Coffee   coff = new Coffee(); 
coff.setName("Pumpkin spice"); 
coff.setSupplier(supp); 
coff.setPrice(1.99); 
coff.save();
1
2
3
4
Map<String,Integer> stuff = new HashMap<String,Integer>() {{ 
    put("a", 1); 
    put("b", 2); 
}};
1
2
3
4
5
(rand-int 1024) 
;;=> 524 
 
(+ (rand-int 100) (rand-int 100)) 
;;=> 114
1
2
(ns joy.generators) 
(def ascii (map char (range 65 (+ 65 26))))
1
1
2
3
4
5
(defn rand-str [sz alphabet] 
  (apply str (repeatedly sz #(rand-nth alphabet)))) 
 
(rand-str 10 ascii) 
;;=> "OMCIBULTOB"

1
2
3
4
5
6
7
8
(def rand-sym #(symbol  (rand-str %1 %2))) 
(def rand-key #(keyword (rand-str %1 %2))) 
 
(rand-key 10 ascii) 
;;=> :JRFTYTUYQA 
 
(rand-sym 10 ascii) 
;;=> DDHRWLOVME
1
2
3
4
5
6
7
(defn rand-vec [& generators] 
  (into [] (map #(%) generators))) 
 
(rand-vec #(rand-sym 5  ascii) 
          #(rand-key 10 ascii) 
          #(rand-int 1024)) 
;;=> [EGALM :FXTDTCMGRO 703]
1
2
3
4
5
6
(defn rand-map [sz kgen vgen] 
  (into {} 
        (repeatedly sz #(rand-vec kgen vgen)))) 
 
(rand-map 3 #(rand-key 5 ascii) #(rand-int 100)) 
;;=> {:RBBLD 94, :CQXLR 71, :LJQYL 72}
1 (assert (= [1 2 3] (conj [1 2] 3)))
1
2
3
4
(use 'clojure.data) 
 
(diff [1 2 3] [1 2 4]) 
;;=> [[nil nil 3] [nil nil 4] [1 2]]
1
2
3
4
(defspec slope-rules 
  (fn [p1 p2] (slope :p1 p1 :p2 p2)) 
    [^{:tag (vec long 2)} p1, ^{:tag (vec long 2)} p2] 
    (assert (float? %)))

1
2
3
4
5
6
7
(defn filter-rising [segments] 
  (clojure.set/select 
    (fn [{:keys [p1 p2]}] 
      (> 0 
         (/ (- (p2 0) (p1 0)) 
            (- (p2 1) (p1 1))))) 
    segments))
1
2
3
4
(filter-rising #{{:p1 [0 0]  :p2 [1 1]} 
                 {:p1 [4 15] :p2 [3 21]}}) 
 
;;=> #{{:p1 [4 15], :p2 [3 21]}}
1 #a-ns/tag some-legal-clojure-form
1
2
#inst "1969-08-18" 
;;=> #inst "1969-08-18T00:00:00.000-00:00"
Listing 14.1. Function to read distance units
1
2
3
4
5
6
7
(in-ns 'joy.unit) 
(def distance-reader 
 (partial convert 
          {:m  1 
           :km 1000, 
           :cm 1/100, 
           :mm [1/10 :cm]}))
1 {unit/length joy.unit/distance-reader}

1
2
#unit/length [1 :km] 
;;=> 1000
1
2
3
4
5
6
7
8
(in-ns 'joy.unit) 
 
(def time-reader 
     (partial convert 
              {:sec 1 
               :min 60, 
               :hr  [60 :min], 
               :day [24 :hr]}))
1
2
3
4
(binding [*data-readers* {'unit/time #'joy.units/time-reader}] 
  (read-string "#unit/time [1 :min 30 :sec]")) 
 
;;=> 90
1
2
3
4
(binding [*default-data-reader-fn* #(-> {:tag %1 :payload %2})] 
  (read-string "#nope [:doesnt-exist]")) 
 
;;=> {:tag nope, :payload [:doesnt-exist]}
1 #uuid "dae78a90-d491-11e2-8b8b-0800200c9a66"
1
2
(class #uuid "dae78a90-d491-11e2-8b8b-0800200c9a66") 
;;=> java.util.UUID

Figure 14.3. Many programs can be viewed as an Engine of computation, taking an input
and performing some action.
1
2
3
4
(require '[clojure.edn :as edn]) 
 
(edn/read-string "#uuid \"dae78a90-d491-11e2-8b8b-0800200c9a66\"") 
;;=> #uuid "dae78a90-d491-11e2-8b8b-0800200c9a66"
1
2
3
4
5
(edn/read-string "42") 
;;=> 42 
 
(edn/read-string "{:a 42, \"b\" 36, [:c] 9}") 
;;=> {:a 42, "b" 36, [:c] 9}
1
2
3
(edn/read-string "#unit/time [1 :min 30 :sec]") 
 
;; java.lang.RuntimeException: No reader function for tag unit/time
1
2
3
4
(def T {'unit/time #'joy.units/time-reader}) 
 
(edn/read-string {:readers T} "#unit/time [1 :min 30 :sec]") 
;;=> 90
1
2
3
(edn/read-string {:readers T, :default vector} "#what/the :huh?") 
 
;;=> [what/the :huh?]

Figure 14.4. The data-programmable model is composed of an Engine taking a
speci×cation, performing some actions, and eventually returning or materializing a
result.
Figure 14.5. The Ant engine: Ant takes a build speci×cation and returns a build artifact.
Figure 14.6. The Lisp compiler as the ultimate computation engine. The Clojure
compiler is a data-programmable engine taking Clojure data as input and returning
Clojure data as a result.
At-bats
Hits
Average
5
2
0.400
1
2
3
4
5
6
7
8
9
10
<project name="EngineSummer" basedir="." default="compile"> 
   <property name="src" value="src"/> 
   <property name="output" value="classes"/> 
   <target name="compile" depends="create"> 
     <javac destdir="${output}"> 
       <src path="${src}"/> 
       <classpath refid="java"/> 
     </javac> 
   </target> 
 </project>

Table 14.1. Baseball events
Event number
Result
1
:out
2
:hit
3
:out
4
:hit
5
:out
Figure 14.7. Integrating polyglot systems using events as data
1
2
3
{:ab  5 
 :h   2 
 :avg 0.400}
1 {:result :hit}
Listing 14.2. Checking the form of an event
1
2
3
4
5
(ns joy.event-sourcing) 
 
(defn valid? [event] 
  (boolean (:result event))) 
 

6
7
8
9
10
(valid? {}) 
;;=> false 
 
(valid? {:result 42}) 
;;=> true
Listing 14.3. Event-sourcing function that affects state
1
2
3
4
5
6
7
8
(defn effect [{:keys [ab h] :or {ab 0, h 0}} 
              event] 
  (let [ab  (inc ab) 
        h   (if (= :hit (:result event)) 
              (inc h) 
              h) 
        avg (double (/ h ab))] 
    {:ab ab :h h :avg avg}))
1
2
3
1
2
3
4
5
6
(effect {} {:result :hit}) 
;;=> {:ab 1 :h 1 :avg 1.0} 
 
(effect {:ab 599 :h 180} 
        {:result :out}) 
;;=> {:ab 600 :h 180 :avg 0.3}
Listing 14.4. Function that applies an effect only when the event is valid
1
2
3
4
(defn apply-effect [state event] 
  (if (valid? event) 
    (effect state event) 
    state))
1
2
3
4
(apply-effect {:ab 600 :h 180 :avg 0.3} 
              {:result :hit}) 
 
;;=> {:ab 601, :h 181, :avg 0.3011647254575707}
Listing 14.5. Event-sourcing, mass-effect function

1 (def effect-all #(reduce apply-effect %1 %2))
1
2
3
4
5
6
7
(effect-all {:ab 0, :h 0} 
            [{:result :hit} 
             {:result :out} 
             {:result :hit} 
             {:result :out}]) 
 
;;=> {:ab 4, :h 2, :avg 0.5}
1
2
3
4
5
6
7
(def events(repeatedly 100 
 
 
 
 
 
(fn[] 
 
 
 
(rand-map 1 
 
 
 
 
 
 
#(-> :result) 
 
 
 
 
#(if (< (rand-int 10) 3) 
 
 
 
 
 
 
:hit 
 
 
 
 
 
:out)))))
1
2
3
1
2
(effect-all {} events) 
;;=> {:ab 100 :h 32 :avg 0.32}
1
2
(effect-all {} (take 50 events)) 
;;=> {:ab 50 :h 14 :avg 0.28}
1
2
3
4
5
6
7
(def fx-timeline #(reductions apply-effect %1 %2)) 
 
(fx-timeline {} (take 3 events)) 
;;=> ({} 
;    {:ab 1, :h 0, :avg 0.0} 
;    {:ab 2, :h 0, :avg 0.0} 
;    {:ab 3, :h 1, :avg 0.3333333})

Listing 14.6. Data model for representing baseball player abilities
1
2
3
4
5
6
7
8
9
10
11
(ns joy.sim-test 
  (:require [joy.event-sourcing :as es] 
            [joy.generators :refer (rand-map)] 
            [clojure.set :as sql])) 
(def PLAYERS #{{:player "Nick", :ability 32} 
               {:player "Matt", :ability 26} 
               {:player "Ryan", :ability 19}}) 
(defn lookup [db name] 
  (first (sql/select 
           #(= name (:player %)) 
           db)))
1
2
3
Listing 14.7. lookup  function
1
2
3
(lookup PLAYERS "Nick") 
 
;;=> {:ability 8/25, :player "Nick"}
Listing 14.8. Applying a baseball result event to a database
1
2
3
4
5
(defn update-stats [db event] 
  (let [player    (lookup db (:player event)) 
        less-db   (sql/difference db #{player})] 
    (conj less-db  
          (merge player (es/effect player event)))))
1
2
1
2
3
4
5
(update-stats PLAYERS {:player "Nick", :result :hit}) 
 
;;=> #{{:ability 19/100, :player "Ryan"} 
;;     {:ability 8/25,   :player "Nick", :h 1, :avg 1.0, :ab 1} 
;;     {:ability 13/50,  :player "Matt"}}
Listing 14.9. Transactionally applying result events to a data store
1
2
3
4
5
(defn commit-event [db event] 
  (dosync (alter db update-stats event))) 
 
(commit-event (ref PLAYERS) {:player "Nick", :result :hit}) 
//=> #<Ref@658ba666: #{...}>

Listing 14.10. Generating a random baseball event based on player ability
1
2
3
4
5
6
7
8
(defn rand-event [{ability :ability}] 
  (let [able (numerator ability) 
        max  (denominator ability)] 
    (rand-map 1 
              #(-> :result) 
              #(if (< (rand-int max) able) 
                 :hit 
                 :out))))
1
2
Listing 14.11. Generating a number of random baseball events
1
2
3
4
5
(defn rand-events [total player] 
  (take total 
        (repeatedly #(assoc (rand-event player) 
                            :player 
                            (:player player)))))
1
2
1
2
3
4
5
(rand-events 3 {:player "Nick", :ability 32/100}) 
 
;;=> ({:player "Nick", :result :out} 
;;    {:player "Nick", :result :hit} 
;;    {:player "Nick", :result :out})
Listing 14.12. Creating or retrieving a unique agent for a given player name
1
2
3
4
5
6
(def agent-for-player 
  (memorize 
   (fn [player-name] 
     (-> (agent [])  
         (set-error-handler! #(println "ERROR: " %1 %2)) 
         (set-error-mode! :fail)))))
1
2
3
4
Listing 14.13. Feeding an event into the data store and player event store

1
2
3
4
5
6
(defn feed [db event] 
  (let [a (agent-for-player (:player event))] 
    (send a 
          (fn [state] 
            (commit-event db event) 
            (conj state event)))))
1
2
3
Listing 14.14. Feeding all events into a data store and player event stores
1
2
3
4
(defn feed-all [db events] 
  (doseq [event events] 
    (feed db event)) 
  db)
1
1
2
3
4
5
6
7
(let [db (ref PLAYERS)] 
  (feed-all db (rand-events 100 {:player "Nick", :ability 32/100})) 
    db) 
 
;;=> #<Ref@321881a2: #{{:ability 19/100, :player "Ryan"} 
;;                     {:ability 13/50,  :player "Matt"} 
;;                     {:player "Nick", :h 27, :avg 0.27, :ab 100,...}}
1
2
3
(count @(agent-for-player "Nick")) 
 
;;=> 100
1
2
(es/effect-all {} @(agent-for-player "Nick")) 
;;=> {:ab 100, :h 27, :avg 0.27}
Listing 14.15. Simulation driver
1
2
3
4
5
6
7
(defn simulate [total players] 
  (let [events  (apply interleave  
                       (for [player players] 
                         (rand-events total player))) 
        results (feed-all (ref players) events)] 
    (apply await (map #(agent-for-player (:player %)) players)) 
    @results))
1
2
3

Figure 14.8. Clojure code is a data structure that Clojure can manipulate.
1
2
3
4
5
(simulate 2 PLAYERS) 
 
;;=> #{{:ability 8/25,   :player "Nick", :h 2, :avg 1.0, :ab 2} 
;;     {:ability 19/100, :player "Ryan", :h 1, :avg 0.5, :ab 2} 
;;     {:ability 13/50,  :player "Matt", :h 0, :avg 0.0, :ab 2}}
1
2
3
4
5
(simulate 400 PLAYERS) 
 
;;=> #{{:ability 13/50,  :player "Matt", :h 95, :avg 0.2375, :ab 400} 
;;     {:ability 8/25,   :player "Nick", :h 138, :avg 0.345, :ab 400} 
;;     {:ability 19/100, :player "Ryan", :h 66, :avg 0.165, :ab 400}}
1
2
3
(es/effect-all {} @(agent-for-player "Nick")) 
 
;;=> {:ab 402, :h 140, :avg 0.3482587064676617}
1
2
3
4
5
6
7
8
(defn meters->feet [m] (* m 3.28083989501312)) 
(defn meters->miles [m] (* m 0.000621)) 
 
(meters->feet 1609.344) 
;;=> 5279.9999999999945 
 
(meters->miles 1609.344) 
;;=> 0.999402624

1
2
3
4
5
6
(Our base unit of distance is the :meter 
  [There are 1000 :meters in a :kilometer] 
  [There are 100 :centimeters in a :meter] 
  [There are 10 :millimeters in a :centimeter] 
  [There are 3.28083 :feet in a :meter] 
  [There are 5280 :feet in a :mile])
1
2
3
4
5
6
7
(define unit of distance 
  {:m 1, 
   :km 1000, 
   :cm 1/100, 
   :mm [1/10 of a :cm], 
   :ft 0.3048, 
   :mile [is 5280 :ft]})
Listing 14.16. Driving the calculation of compositional units of measure
1
2
3
4
5
6
7
8
(in-ns 'joy.units) 
 
(defn relative-units [context unit] 
  (if-let [spec (get context unit)] 
    (if (vector? spec) 
      (convert context spec) 
      spec) 
    (throw (RuntimeException. (str "Undefined unit " unit)))))
1
2
3
4
5
6
7
8
(relative-units {:m 1, :cm 1/100, :mm [1/10 :cm]} :m) 
;;=> 1 
 
(relative-units {:m 1, :cm 1/100, :mm [1/10 :cm]} :mm) 
;;=> 1/1000 
 
(relative-units {:m 1, :cm 1/100, :mm [1/10 :cm]} :ramsden-chain) 
;; RuntimeException Undefined unit :ramsden-chain
1
2
3
(defunits-of distance :m 
  :km 1000 
  :cm 1/100 

4
5
6
  :mm [1/10 :cm] 
  :ft 0.3048 
  :mile [5280 :ft])
Listing 14.17. defunits-of  macro
1
2
3
4
5
6
7
8
9
10
11
12
13
(defmacro defunits-of [name base-unit & conversions] 
  (let [magnitude (gensym) 
        unit (gensym) 
        units-map (into `{~base-unit 1} 
                        (map vec (partition 2 conversions)))] 
    `(defmacro ~(symbol (str "unit-of-" name)) 
       [~magnitude ~unit] 
       `(* ~~magnitude 
           ~(case ~unit 
                  ~@(mapcat 
                     (fn [[u# & r#]] 
                       `[~u# ~(relative-units units-map u#)]) 
                     units-map))))))
1
2
3
4
1
2
3
4
5
6
7
8
9
10
11
(unit-of-distance 1 :m) 
;;=> 1 
 
(unit-of-distance 1 :mm) 
;;=> 1/1000 
 
(unit-of-distance 1 :ft) 
;;=> 0.3048 
 
(unit-of-distance 1 :mile) 
;;=> 1609.344
1
2
3
4
5
6
7
8
9
(defmacro unit-of-distance [G__43 G__44] 
  (* G__43 
     (case G__44 
       :mile 1609.344 
       :km 1000 
       :cm 1/100 
       :m 1 
       :mm 1/1000 
       :ft 0.3048)))


CHAPTER 15
1
2
(set! *warn-on-reflection* true) 
;=> true
1
2
3
4
5
6
7
8
9
(defn asum-sq [xs] 
  (let [dbl (amap xs i ret 
              (* (aget xs i) 
                 (aget xs i)))] 
    (areduce dbl i ret 0 
      (+ ret (aget dbl i))))) 
 
; Reflection warning - call to aclone can't be resolved. 
; ...
1
2
3
(time (dotimes [_ 10000] (asum-sq (float-array [1 2 3 4 5])))) 
; "Elapsed time: 410.539 msecs" 
;=> nil
1
2
3
(defn asum-sq [ ^floats xs] 
  (let [^floats dbl (amap xs i ret 
  ...
1
2
3
(time (dotimes [_ 10000] (asum-sq (float-array [1 2 3 4 5])))) 
; "Elapsed time: 17.087 msecs" 
;=> nil
1
2
3
(.intValue (asum-sq (float-array [1 2 3 4 5]))) 
; Reflection warning, reference to field intValue can't be resolved. 
;=> 55

1
2
3
4
5
(defn ^Float asum-sq [ ^floats xs] 
  ... 
 
(.intValue (asum-sq (float-array [1 2 3 4 5]))) 
;=> 55
1
2
(.intValue ^Float (asum-sq (float-array [1 2 3 4 5]))) 
;=> 55
1
2
(reduce merge [{1 3} {1 2} {3 4} {3 5}]) 
;=> {1 2, 3 5}
1
2
3
4
5
6
7
8
9
10
11
12
(defn zencat1 [x y] 
  (loop [src y, ret x] 
    (if (seq src) 
      (recur (next src) (conj ret (first src))) 
      ret))) 
 
(zencat1 [1 2 3] [4 5 6]) 
;=> [1 2 3 4 5 6] 
 
(time (dotimes [_ 1000000] (zencat1 [1 2 3] [4 5 6]))) 
; "Elapsed time: 486.408 msecs" 
;=> nil
1
2
3
4
5
6
7
8
9
10
(defn zencat2 [x y] 
  (loop [src y, ret (transient x)] 
     (if src 
      (recur (next src) (conj! ret (first src))) 
      (persistent! ret)))) 
(zencat2 [1 2 3] [4 5 6]) 
;=> [1 2 3 4 5 6] 
(time (dotimes [_ 1000000] (zencat2 [1 2 3] [4 5 6]))) 
; "Elapsed time: 846.258 msecs" 
;=> nil
1
2
3

Figure 15.1. Clojure’s chunked sequences allow a windowed view of a sequence. This
model is more ef×cient, in that it allows for larger swaths of memory to be reclaimed by
the garbage collector and better cache locality in general. There’s a cost to total
laziness, but often the bene×t gained is worth the cost.
1
2
3
4
5
6
7
8
9
(def bv (vec (range 1e6))) 
 
(first (time (zencat1 bv bv))) 
; "Elapsed time: 181.988 msecs" 
;=> 0 
 
(first (time (zencat2 bv bv))) 
; "Elapsed time: 39.353 msecs" 
;=> 0
1
2
3
(def gimme #(do (print \.) %)) 
 
(take 1 (map gimme (range 32)))
1 ;=> (................................0)
1
2
(take 1 (map gimme (range 33))) 
;=> (................................0)
1
2
(take 1 (drop 32 (map gimme (range 64)))) 
;=> (................................................................32)

Figure 15.2. Using seq1 , you can reclaim the one-at-a-time sequence model.
Although not as ef×cient as the chunked model, it does provide total sequence laziness.
1
2
3
4
5
6
7
8
9
10
(defn seq1 [s] 
  (lazy-seq 
    (when-let [[x] (seq s)] 
      (cons x (seq1 (rest s)))))) 
 
(take 1 (map gimme (seq1 (range 32)))) 
;=> (.0) 
 
(take 1 (drop 32 (map gimme (seq1 (range 64))))) 
;=> (.................................32)
1
2
3
4
5
6
7
8
9
10
(def gcd (memoize 
           (fn [x y] 
             (cond 
               (> x y) (recur (- x y) y) 
               (< x y) (recur x (- y x)) 
 
 
               :else x)))) 
(gcd 1000645475 56130776629010010) 
;=> 215

Listing 15.1. Protocol for caching
1
2
3
4
5
(defprotocol CacheProtocol 
  (lookup  [cache e]) 
  (has?    [cache e] ) 
  (hit     [cache e]) 
  (miss    [cache e ret]))
Listing 15.2. BasicCache  type
1
2
3
4
5
6
7
8
9
(deftype BasicCache [cache] 
  CacheProtocol 
  (lookup [_ item] 
    (get cache item)) 
  (has? [_ item] 
    (contains? cache item)) 
  (hit [this item] this) 
  (miss [_ item result] 
    (BasicCache. (assoc cache item result))))
1
2
3
4
(def cache (BasicCache. {})) 
 
(lookup (miss cache '(servo) :robot) '(servo)) 
;=> :robot
1
2
3
4
(defn through [cache f item] 
  (if (has? cache item) 
    (hit cache item) 
    (miss cache item (delay (apply f item)))))
Listing 15.3. Type implementing pluggable memoization
1
2
3
4
5
6
7
8
(deftype PluggableMemoization [f cache] 
  CacheProtocol 
  (has? [_ item] (has? cache item)) 
  (hit  [this item] this) 
  (miss [_ item result] 
    (PluggableMemoization. f (miss cache item result))) 
 

9   (lookup [_ item] 
    (lookup cache item)))
Listing 15.4. Applying pluggable memoization to a function
1
2
3
4
5
6
7
(defn memoization-impl [cache-impl] 
  (let [cache (atom cache-impl)] 
    (with-meta 
      (fn [& args] 
        (let [cs (swap! cache through (.f cache-impl) args)] 
          @(lookup cs args))) 
      {:cache cache})))
1
2
3
4
5
6
7
8
9
10
11
12
13
(def slowly (fn [x] (Thread/sleep 3000) x)) 
(def sometimes-slowly (memoization-impl 
                        (PluggableMemoization. 
                          slowly 
                          (BasicCache. {})))) 
 
(time [(sometimes-slowly 108) (sometimes-slowly 108)]) 
; "Elapsed time: 3001.611 msecs" 
;=> [108 108] 
 
(time [(sometimes-slowly 108) (sometimes-slowly 108)]) 
; "Elapsed time: 0.049 msecs" 
;=> [108 108]
Listing 15.5. Tail-recursive factorial, with no type declarations
1
2
3
4
5
(defn factorial-a [original-x] 
  (loop [x original-x, acc 1] 
    (if (>= 1 x) 
      acc 
      (recur (dec x) (* x acc)))))
1
2
3
1
2
3
4
5
(factorial-a 10) 
;=> 3628800 
 
(factorial-a 20) 
;=> 2432902008176640000

1
2
(time (dotimes [_ 1e5] (factorial-a 20))) 
; "Elapsed time: 172.914384 msecs"
Listing 15.6. Factorial with a coerced local
1
2
3
4
5
6
7
(defn factorial-b [original-x] 
  (loop [x (long original-x), acc 1] 
    (if (>= 1 x) 
      acc 
      (recur (dec x) (* x acc))))) 
(time (dotimes [_ 1e5] (factorial-b 20))) 
; "Elapsed time: 44.687297 msecs"
1
Listing 15.7. Factorial with a primitive long argument
1
2
3
4
5
6
7
(defn factorial-c [^long original-x]  
  (loop [x original-x, acc 1] 
    (if (>= 1 x) 
      acc 
      (recur (dec x) (* x acc))))) 
(time (dotimes [_ 1e5] (factorial-b 20))) 
; "Elapsed time: 43.797143 msecs"
1
2
Listing 15.8. Factorial without overØow checking
1
2
3
4
5
6
7
(set! *unchecked-math* true) 
(defn factorial-d [^long original-x] 
  (loop [x original-x, acc 1] 
    (if (>= 1 x) 
      acc 
      (recur (dec x) (* x acc))))) 
(set! *unchecked-math* false)
1
2
3
1
2
(time (dotimes [_ 1e5] (factorial-d 20))) 
; "Elapsed time: 15.674197 msecs"

1
2
(factorial-d 21) 
;=> -4249290049419214848
1
2
(factorial-a 21) 
; ArithmeticException integer overflow
Listing 15.9. Factorial with a primitive double argument
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(defn factorial-e [^double original-x] 
  (loop [x original-x, acc 1.0] 
    (if (>= 1.0 x) 
      acc 
      (recur (dec x) (* x acc))))) 
(factorial-e 10.0) 
;=> 3628800.0 
(factorial-e 20.0) 
;=> 2.43290200817664E18  
(factorial-e 30.0) 
;=> 2.652528598121911E32  
(factorial-e 171.0) 
;=> Double/POSITIVE_INFINITY  
(time (dotimes [_ 1e5] (factorial-e 20.0))) 
; "Elapsed time: 15.678149 msecs"
1
2
3
4
5
6
Listing 15.10. Factorial with auto-promotion
1
2
3
4
5
6
7
8
9
10
11
12
13
(defn factorial-f [^long original-x] 
  (loop [x original-x, acc 1] 
    (if (>= 1 x) 
      acc 
      (recur (dec x) (*' x acc)))))  
(factorial-f 20) 
;=> 2432902008176640000 
(factorial-f 30) 
;=> 265252859812191058636308480000000N 
(factorial-f 171) 
;=> 124101... this goes on a while ...0000N 
(time (dotimes [_ 1e5] (factorial-f 20))) 
; "Elapsed time: 101.7621 msecs"
1
2
3
4

Listing 15.11. Reimplementing Clojure’s range  function using lazy-seq
1
2
3
4
5
6
7
8
9
10
11
(defn empty-range? [start end step] 
  (or (and (pos? step) (>= start end)) 
      (and (neg? step) (<= start end)))) 
(defn lazy-range [i end step] 
  (lazy-seq 
    (if (empty-range? i end step) 
      nil  
      (cons i 
            (lazy-range (+ i step) 
                        end 
                        step)))))
1
2
3
1
2
3
4
5
(lazy-range 5 10 2) 
;=> (5 7 9) 
 
(lazy-range 6 0 -1) 
;=> (6 5 4 3 2 1)
1
2
3
4
5
(reduce conj [] (lazy-range 6 0 -1)) 
;=> [6 5 4 3 2 1] 
 
(reduce + 0 (lazy-range 6 0 -1)) 
;=> 21
1
2
3
4
5
(fn [reducing-fn initial-value] 
  ;; ... 
 
  ;; returns the reduced value 
)
1
2
3
4
5
6
7
(def countdown-reducable (reducible-range 6 0 -1)) 
 
(countdown-reducible conj []) 
;=> [6 5 4 3 2 1] 
 
(countdown-reducible + 0) 
;=> 21

Listing 15.12. Reimplementation of range  that returns a reducible
1
2
3
4
5
6
7
(defn reducible-range [start end step] 
  (fn [reducing-fn init] 
    (loop [result init, i start] 
      (if (empty-range? i end step)  
        Result 
        (recur (reducing-fn result i) 
               (+ i step))))))
1
2
3
1
2
3
4
5
6
7
8
(defn half [x] 
  (/ x 2)) 
 
(half 4) 
;=> 2 
 
(half 7) 
;=> 7/2
1
2
3
4
5
6
7
8
(defn sum-half [result input] 
  (+ result (half input))) 
 
(reduce sum-half 0 (lazy-range 0 10 2)) 
;=> 10 
 
((reducible-range 0 10 2) sum-half 0) 
;=> 10
1
2
3
(defn half-transformer [f1] 
  (fn f1-half [result input] 
    (f1 result (half input))))
1
2
3
4
5
((reducible-range 0 10 2) (half-transformer +) 0) 
;=> 10 
 
((reducible-range 0 10 2) (half-transformer conj) []) 
;=> [0 1 2 3 4]

Table 15.1. The various kinds of reducer-related functions
Name
Parameters
Return value
Example
Mapping function
Input
Mapped output
half
Reducing function
Previous result,
next input
Reduced value
sum-half
Reducible
Reducing function,
init value
Reduced value
(reducible-range 0
5 1)
Reducible
constructor
Various
Reducible
reducible-range
Reducing function
transformer
Reducing function
Reducing function
half-transformer
Transformer
constructor
Various
Reducing
transformer
mapping
Listing 15.13. Essence of mapping , bundled to be used with a reducible
1
2
3
4
(defn mapping [map-fn] 
  (fn map-transformer [f1] 
    (fn [result input] 
      (f1 result (map-fn input)))))
1
2
3
1
2
3
4
5
6
7
8
((reducible-range 0 10 2) ((mapping half) +) 0) 
;=> 10 
 
((reducible-range 0 10 2) ((mapping half) conj) []) 
;=> [0 1 2 3 4] 
 
((reducible-range 0 10 2) ((mapping list) conj) []) 
;=> [(0) (2) (4) (6) (8)]
Listing 15.14. Essence of filtering , bundled to be used with a reducible
1
2
3
(defn filtering [filter-pred] 
  (fn [f1] 
    (fn [result input] 

4
5
6
      (if (filter-pred input) 
        (f1 result input) 
        result))))
1
2
3
1
2
3
4
5
((reducible-range 0 10 2) ((filtering #(not= % 2)) +) 0) 
;=> 18 
 
((reducible-range 0 10 2) ((filtering #(not= % 2)) conj) []) 
;=> [0 4 6 8]
1
2
3
4
5
6
((reducible-range 0 10 2) 
  ((filtering #(not= % 2)) 
    ((mapping half) conj)) 
  []) 
 
;=> [0 2 3 4]
1
2
3
4
5
6
((reducible-range 0 10 2) 
  ((mapping half) 
   ((filtering #(not= % 2)) conj)) 
  []) 
 
;=> [0 1 3 4]
Listing 15.15. Essence of mapcatting , bundled to be used with a reducible
1
2
3
4
5
(defn mapcatting [map-fn] 
  (fn [f1] 
    (fn [result input] 
      (let [reducible (map-fn input)] 
        (reducible f1 result)))))
1
2
1
2
3
4
5
(defn and-plus-ten [x] 
  (reducible-range x (+ 11 x) 10)) 
 
((and-plus-ten 5) conj []) 
;=> [5 15]

1
2
((reducible-range 0 10 2) ((mapcatting and-plus-ten) conj) []) 
;=> [0 10 2 12 4 14 6 16 8 18]
1
2
3
4
(filter #(not= % 2) 
  (map half 
       (lazy-range 0 10 2))) 
;=> (0 1 3 4)
Listing 15.16. A couple of reducible transformers
1
2
3
4
5
6
(defn r-map [mapping-fn reducible]  
  (fn new-reducible [reducing-fn init] 
    (reducible ((mapping mapping-fn) reducing-fn) init)))   
(defn r-filter [filter-pred reducible] 
  (fn new-reducible [reducing-fn init] 
    (reducible ((filtering filter-pred) reducing-fn) init)))
1
2
1
2
3
4
5
6
7
(def our-final-reducible 
  (r-filter #(not= % 2) 
            (r-map half 
                   (reducible-range 0 10 2)))) 
 
(our-final-reducible conj []) 
;=> [0 1 3 4]
1
2
3
4
5
(require '[criterium.core :as crit]) 
(crit/bench 
  (reduce + 0 (filter even? (map half (lazy-range 0 
             (* 10 1000 1000) 2))))) 
; Execution time mean : 1.593855 sec

1
2
3
(crit/bench 
 (reduce + 0 (filter even? (map half (range 0 (* 10 1000 1000) 2))))) 
; Execution time mean : 603.006967 ms
1
2
3
4
(crit/bench 
 ((r-filter even? (r-map half 
     (reducible-range 0 (* 10 1000 1000) 2))) + 0)) 
; Execution time mean : 385.042958 ms
Listing 15.17. Converting transformers to core reducibles
1
2
3
4
5
(require '[clojure.core.reducers :as r]) 
(defn core-r-map [mapping-fn core-reducible] 
  (r/reducer core-reducible (mapping mapping-fn))) 
(defn core-r-filter [filter-pred core-reducible] 
  (r/reducer core-reducible (filtering filter-pred)))
1
2
3
1
2
3
4
(reduce conj [] 
        (core-r-filter #(not= % 2) 
                       (core-r-map half [0 2 4 6 8]))) 
;=> [0 1 3 4]
Listing 15.18. Implementing a reducible-range via the CollReduce protocol
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(defn reduce-range [reducing-fn init, start end step]  
  (loop [result init, i start] 
    (if (empty-range? i end step) 
      result 
      (recur (reducing-fn result i) 
             (+ i step))))) 
(defn core-reducible-range [start end step] 
  (reify protos/CollReduce 
    (coll-reduce [this reducing-fn init] 
      (reduce-range reducing-fn init, start end step)) 
    (coll-reduce [this reducing-fn] 
      (if (empty-range? start end step) 
        (reducing-fn) 
        (reduce-range reducing-fn start, (+ start step) end step)))))
1
2
3

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(reduce conj [] 
        (core-r-filter #(not= % 2) 
                       (core-r-map half 
                                   (core-reducible-range 0 10 2)))) 
;=> [0 1 3 4] 
 
 
(reduce + (core-reducible-range 10 12 1)) 
;=> 21 
 
(reduce + (core-reducible-range 10 11 1)) 
;=> 10 
 
(reduce + (core-reducible-range 10 10 1)) 
;=> 0
1
2
3
4
5
(reduce + [1 2 3 4 5]) 
;=> 15 
 
(r/fold + [1 2 3 4 5]) 
;=> 15
Listing 15.19. Converting transformers to core foldables
1
2
3
4
(defn core-f-map [mapping-fn core-reducible] 
  (r/folder core-reducible (mapping mapping-fn))) 
(defn core-f-filter [filter-pred core-reducible] 
  (r/folder core-reducible (filtering filter-pred)))
1
2
1
2
3
4
5
(r/fold + 
        (core-f-filter #(not= % 2) 
                       (core-f-map half 
                                   [0 2 4 6 8]))) 
;=> 8
1
2
3
4
5
(r/fold + 
        (r/filter #(not= % 2) 
                  (r/map half 
                         [0 2 4 6 8]))) 
;=> 8

1
2
(r/fold (fn ([] 100) ([a b] (+ a b))) (range 10)) 
;=> 145
1
2
(r/fold (r/monoid + (constantly 100)) (range 10)) 
;=> 145
1
2
3
4
5
(r/fold 512  
        (r/monoid + (constantly 100)) 
        + 
        (range 10)) 
;=> 145
1
2
3
1
2
(r/fold 4 (r/monoid conj (constantly [])) conj (vec (range 10))) 
;=> [0 1 [2 3 4] [5 6 [7 8 9]]]
1
2
(r/fold 4 (r/monoid into (constantly [])) conj (vec (range 10))) 
;=> [0 1 2 3 4 5 6 7 8 9]
1
2
3
4
5
(r/foldcat (r/filter even? (vec (range 1000)))) 
;=> #<Cat clojure.core.reducers.Cat@209bc0df> 
 
>(seq (r/foldcat (r/filter even? (vec (range 10))))) 
;=> (0 2 4 6 8)
1
2
3
4
5
(def big-vector (vec (range 0 (* 10 1000 1000) 2))) 
 
(crit/bench 
 (r/fold + (core-f-filter even? (core-f-map half big-vector)))) 
;; Execution time mean : 126.756586 ms


CHAPTER 16
Figure 16.1. Starting position of the example Sudoku board
1
2
3
4
5
6
7
8
9
(def b1 '[3 - - - - 5 - 1 - 
          - 7 - - - 6 - 3 - 
          1 - - - 9 - - - - 
          7 - 8 - - - - 9 - 
          9 - - 4 - 8 - - 2 
          - 6 - - - - 5 - 1 
          - - - - 4 - - - 6 
          - 4 - 7 - - - 2 - 
          - 2 - 6 - - - - 3])
1
2
3
(defn prep [board] 
  (map #(partition 3 %) 
       (partition 9 board)))
Listing 16.1. Printing the starting position of a Sudoku board
1
2
3
4
5
6
7
8
9
10
(defn print-board [board] 
  (let [row-sep (apply str (repeat 37 "-"))] 
    (println row-sep) 
    (dotimes [row (count board)] 
      (print "| ") 
      (doseq [subrow (nth board row)] 
        (doseq [cell (butlast subrow)] 
          (print (str cell "   "))) 
        (print (str (last subrow) " | "))) 
      (println) 

11
12
      (when (zero? (mod (inc row) 3)) 
        (println row-sep)))))
1 (-> b1 prep print-board)
1
2
3
4
5
(defn rows [board sz] 
  (partition sz board)) 
 
(defn row-for [board index sz] 
  (nth (rows board sz) (/ index 9)))
1
2
(row-for b1 1 9) 
;=> (3 - - - - 5 - 1 -)
1
2
3
4
(defn column-for [board index sz] 
  (let [col (mod index sz)] 
    (map #(nth % col) 
         (rows board sz))))
1
2
(column-for b1 2 9) 
;=> (- - - 8 - - - - -)
1
2
3
4
5
6
7
(defn subgrid-for [board i] 
  (let [rows (rows board 9) 
        sgcol (/ (mod i 9) 3) 
        sgrow (/ (/ i 9) 3) 
        grp-col (column-for (mapcat #(partition 3 %) rows) sgcol 3) 
        grp (take 3 (drop (* 3 (int sgrow)) grp-col))] 
    (flatten grp)))
1
2
3
4

1
2
(subgrid-for b1 0) 
;=> (3 - - - 7 - 1 - -)
1
2
3
4
5
------------- 
| 3   -   - | 
| -   7   - | 
| 1   -   - | 
-------------
1
2
3
4
5
* Place a number into the first empty square 
* Check if the constraints hold 
  - If so, then start this algorithm again 
  - If not, then remove the number and start this algorithm again 
* repeat
1
2
3
4
5
(defn numbers-present-for [board i] 
  (set 
   (concat (row-for board i 9) 
           (column-for board i 9) 
           (subgrid-for board i))))
1
2
(numbers-present-for b1 1) 
;=> #{1 2 3 4 5 6 7 -}
1
2
(numbers-present-for (assoc b1 1 8) 1) 
;=> #{1 2 3 4 5 6 7 8 -}
1
2
(set/difference #{1 2 3 4 5 6 7 8 9} 
                (numbers-present-for b1 1)) 

3 ;=> #{8 9}
1
2
3
(defn possible-placements [board index] 
  (set/difference #{1 2 3 4 5 6 7 8 9} 
                  (numbers-present-for board index)))
Listing 16.2. Brute-force Sudoku solver
1
2
3
4
5
6
7
(defn solve [board] 
  (if-let [[i & _]  
            (and (some '#{-} board) 
                 (pos  '#{-} board))]  
    (flatten (map #(solve (assoc board i %)) 
                  (possible-placements board i))) 
    board))
1
2
3
1
2
3
4
(-> b1 
      solve 
      prep 
      print-board)
1
2
3
4
5
6
7
8
9
10
11
12
13
------------------------------------- 
| 3   8   6 | 2   7   5 | 4   1   9 | 
| 4   7   9 | 8   1   6 | 2   3   5 | 
| 1   5   2 | 3   9   4 | 8   6   7 | 
------------------------------------- 
| 7   3   8 | 5   2   1 | 6   9   4 | 
| 9   1   5 | 4   6   8 | 3   7   2 | 
| 2   6   4 | 9   3   7 | 5   8   1 | 
------------------------------------- 
| 8   9   3 | 1   4   2 | 7   5   6 | 
| 6   4   1 | 7   5   3 | 9   2   8 | 
| 5   2   7 | 6   8   9 | 1   4   3 | 
-------------------------------------
1 (= ?something 2)

1
2
3
4
1      ;; constant term 
?x     ;; variable term 
(1 2)  ;; ground term 
(1 ?x) ;; term
Listing 16.3. Identifying logic variables
1
2
3
4
5
6
(defn lvar? 
  "Determines if a value represents a logic variable" 
  [x] 
  (boolean 
   (when (symbol? x) 
     (re-matches #"^\?.*" (name x)))))
1
2
3
4
5
6
7
8
(lvar? '?x) 
;;=> true 
 
(lvar? 'a) 
;;=> false 
 
(lvar? 2) 
;;=> false
Listing 16.4. Simpli×ed satis×ability function
1
2
3
4
5
6
7
8
(defn satisfy1 
  [l r knowledge] 
  (let [L (get knowledge l l) 
        R (get knowledge r r)] 
    (cond 
     (= L R)   knowledge  
     (lvar? L) (assoc knowledge L R) 
     (lvar? R) (assoc knowle
1
2
3
1
2
3
4
5
(satisfy1 '?something 2 {}) 
;;=> {?something 2} 
 
(satisfy1 2 '?something {}) 
;;=> {?something 2}

1
2
(satisfy1 '?x '?y {}) 
;;=> {?x ?y}
1
2
3
4
5
(->> {} 
     (satisfy1 '?x '?y) 
     (satisfy1 '?x 1)) 
 
;;=> {?y 1, ?x ?y}
1 (= '(1 2 3) '(1 2 3))
1 (= '(1 2 3) '(1 ?something 3))
1
2
3
What is the value of x in the term: 
 
38 - (x + 2) = 5x
Listing 16.5. Function that satis×es seqs
1
2
3
4
5
6
7
8
9
10
11
12
13
(defn satisfy 
  [l r knowledge] 
  (let [L (get knowledge l l) 
        R (get knowledge r r)] 
    (cond 
     (not knowledge)        nil 
     (= L R)          knowledge 
     (lvar? L)        (assoc knowledge L R) 
     (lvar? R)        (assoc knowledge R L) 
     (every? seq? [L R]) 
       (satisfy (rest L) 
                (rest R) 
                (satisfy (first L) 
1
2
3
4

14
15
16
                         (first R) 
                         knowledge)) 
     :default nil)))
1
2
(satisfy '(1 2 3) '(1 ?something 3) {}) 
;;=> {?something 2}
1
2
(satisfy '((((?something)))) '((((2)))) {}) 
;;=> {?something 2}
1
2
3
4
5
6
7
8
(satisfy '(?x 2 3 (4 5 ?z)) 
         '(1 2 ?y (4 5 6)) 
         {}) 
 
;;=> {?z 6, ?y 3, ?x 1} 
 
(satisfy '?x '(?y) {}) 
;;=> {?x (?y)}
1
2
(satisfy '(?x 10000 3) '(1 2 ?y) {}) 
;;=> nil
Listing 16.6. Walking a data structure and substituting logic variables for bound values
1
2
3
4
5
6
7
8
9
(require '[clojure.walk :as walk]) 
(defn subst [term binds] 
  (walk/prewalk 
 
   (fn [expr] 
     (if (lvar? expr) 
       (or (binds expr) expr) 
       expr)) 
   term))

1
2
3
4
5
6
7
8
9
10
11
(subst '(1 ?x 3) '{?x 2}) 
;;=> (1 2 3) 
 
(subst '((((?x)))) '{?x 2}) 
;;=> ((((2)))) 
 
(subst '[1 ?x 3] '{?x 2}) 
;;=> [1 2 3] 
 
(subst '{:a ?x, :b [1 ?x 3]} '{?x 2}) 
;;=> {:a 2, :b [1 2 3]}
1
2
3
4
5
(subst '(1 ?x 3) '{}) 
;;=> (1 ?x 3) 
 
(subst '(1 ?x 3) '{?x ?y}) 
;;=> (1 ?y 3)
1
2
3
4
5
6
7
(def page 
  '[:html 
    [:head [:title ?title]] 
    [:body [:h1 ?title]]]) 
 
(subst page '{?title "Hi!"}) 
;;=> [:html [:head [:title "Hi!"]] [:body [:h1 "Hi!"]]]
Listing 16.7. Melding two seqs, substituting logic variables
1
2
3
4
(defn meld [term1 term2] 
  (->> {} 
       (satisfy term1 term2) 
       (subst term1)))
1
2
3
4
5
(meld '(1 ?x 3) '(1 2 ?y)) 
;;=> (1 2 3) 
 
(meld '(1 ?x) '(?y (?y 2))) 
;;=> (1 (1 2))

1
2
3
4
5
(satisfy '?x 1 (satisfy '?x '?y {})) 
;;=> {?y 1, ?x ?y} 
 
(satisfy '(1 ?x) '(?y (?y 2)) {}) 
;;=> {?x (?y 2), ?y 1}
1
2
3
What is the value of x in the term: 
 
5x - 2(x - 5) = 4x
1
2
(ns joy.logic.cl 
  (require [clojure.core.logic :as logic]))
1
2
(satisfy '?answer 5 {}) 
;;=> {answer 5}
1
2
3
(logic/run* [answer] 
  (logic/== answer 5)) 
;;=> (5)
1
2
3
4
5
(logic/run* [val1 val2] 
  (logic/== {:a val1, :b 2} 
            {:a 1,    :b val2})) 
 
;;=> ([1 2])
1
2
(logic/run* [x y] 
  (logic/== x y)) 

3
4
 
;;=> ([_0 _0])
1
2
3
4
5
(logic/run* [q] 
  (logic/== q 1) 
  (logic/== q 2)) 
 
;;=> ()
1
2
3
4
5
6
(logic/run* [george] 
  (logic/conde 
   [(logic/== george :born)] 
   [(logic/== george :unborn)])) 
 
;;=> (:born :unborn)
1
2
3
4
(ns joy.logic.planets 
  (require [clojure.core.logic :as logic])) 
 
(logic/defrel orbits orbital body)
1
2
3
4
5
6
7
8
(logic/fact orbits :mercury :sun) 
(logic/fact orbits :venus   :sun) 
(logic/fact orbits :earth   :sun) 
(logic/fact orbits :mars    :sun) 
(logic/fact orbits :jupiter :sun) 
(logic/fact orbits :saturn  :sun) 
(logic/fact orbits :uranus  :sun) 
(logic/fact orbits :neptune :sun)
1
2
3
4
5
'[orbits :mercury :sun] 
 
; ... 
 
'[orbits :neptune :sun]

Table 16.1. Planets  table
ID
Planet
Orbits
1
Mercury
Stars[1]
2
Venus
Stars[1]
3
Earth
Stars[1]
4
Mars
Stars[1]
5
Jupiter
Stars[1]
6
Saturn
Stars[1]
7
Uranus
Stars[1]
8
Neptune
Stars[1]
Table 16.2. Stars  table
ID
Star
1
Sun
2
Alpha Centauri
Listing 16.8. Querying planetary bodies
1
2
3
4
5
6
(logic/run* [q] 
  (logic/fresh [orbital body] 
    (orbits orbital body) 
    (logic/== q orbital))) 
;;=> (:earth :saturn :jupiter :mars 
;;    :mercury :neptune :uranus :venus)
1
2
3
1
2
3
4
5
6
7
(logic/defrel stars star) 
 
(logic/fact stars :sun) 
(defn planeto [body] 
  (logic/fresh [star] 
    (stars star) 
    (orbits body star)))

1
2
3
4
(logic/run* [q] 
  (planeto :earth)) 
 
;;=> (_0)
1
2
3
4
5
(logic/run* [q] 
  (planeto :earth) 
  (logic/== q true)) 
 
;;=> (true)
1
2
3
4
5
(logic/run* [q] 
  (planeto :sun) 
  (logic/== q true)) 
 
;;=> ()
1
2
3
4
5
6
7
(logic/run* [q] 
  (logic/fresh [orbital] 
    (planeto orbital) 
    (logic/== q orbital))) 
 
;;=> (:earth :saturn :jupiter :mars 
;;    :mercury :neptune :uranus :venus)
1
2
3
4
5
6
7
(logic/fact stars :alpha-centauri) 
(logic/fact orbits :Bb :alpha-centauri) 
 
(logic/run* [q] 
  (planeto :Bb)) 
 
;;=> (_0)
1
2
3
4
5
(logic/run* [q] 
  (logic/fresh [orbital] 
    (planeto orbital) 
    (logic/== q orbital))) 
 

Table 16.3. Satellites  table
ID
Satellite
Planet
1
Moon
Planet[3]
2
Phobos
Planet[4]
Table 16.4. Satellites  table implemented as links
Satellite
Planet
Planet[9]
Planet[3]
Planet[10]
Planet[4]
6
7
;;=> (:earth :saturn :jupiter :mars :Bb 
;;    :mercury :neptune :uranus :venus)
1
2
3
4
(defn satelliteo [body] 
  (logic/fresh [p] 
      (orbits body p) 
      (planeto p)))
1
2
3
4
5
6
7
8
9
(logic/run* [q] 
  (satelliteo :sun)) 
 
;;=> () 
 
(logic/run* [q] 
  (satelliteo :earth)) 
 
;;=> ()
1 (logic/fact orbits :moon :earth)

1
2
3
4
(logic/run* [q] 
  (satelliteo :moon)) 
 
;;=> (_0)
1
2
3
4
5
6
7
8
9
10
(logic/fact orbits :phobos :mars) 
(logic/fact orbits :deimos :mars) 
(logic/fact orbits :io :jupiter) 
(logic/fact orbits :europa :jupiter) 
(logic/fact orbits :ganymede :jupiter) 
(logic/fact orbits :callisto :jupiter) 
 
(logic/run* [q] 
  (satelliteo :io)) 
;;=> (_0)
1
2
3
(logic/run* [q] 
  (orbits :leda :jupiter)) 
;;=> ()
1 (defn doubler [n] (* n 2))
1
2
3
4
5
6
7
8
9
10
11
(doubler 2) 
;;=> 4 
 
(doubler Math/E) 
;;=> 5.43656365691809 
 
(doubler 38781787272072020703083739N) 
;;=> 77563574544144041406167478N 
 
(doubler 1/8) 
;;=> 1/4

1
2
3
4
5
6
7
8
(doubler []) 
;; ClassCastException ... 
 
(doubler #(%)) 
;; ClassCastException ... 
 
(doubler "") 
;; ClassCastException ...
1
2
3
4
(def doubling 
  (defcontract c [x] 
    (require (number? x)) 
    (ensure  (= % (* 2 x)))))
1
2
3
4
(def checked-doubler (partial doubling doubler)) 
 
(checked-doubler "") 
;; AssertionError: Assert failed: (number? x)
1
2
3
4
5
(logic/run* [q] 
   (logic/fresh [x y] 
     (logic/== q [x y]))) 
 
 ;;=> ([_0 _1])
1
2
3
4
5
6
7
(logic/run* [q] 
  (logic/fresh [x y] 
 
    (logic/== [:pizza "Java"] [x y]) 
    (logic/== q [x y]))) 
 
;;=> ([:pizza "Java"])
1
2
3
4
(logic/run* [q] 
  (logic/fresh [x y] 
    (logic/== q [x y]) 
    (logic/!= y "Java"))) 

5
6
 
;;=> (([_0 _1] :- (!= (_1 "Java"))))
1
2
3
4
5
6
7
(logic/run* [q] 
  (logic/fresh [x y] 
    (logic/== [:pizza "Java"] [x y]) 
    (logic/== q [x y]) 
    (logic/!= y "Java"))) 
 
;;=> ()
1
2
3
4
5
6
7
(logic/run* [q] 
  (logic/fresh [x y] 
    (logic/== [:pizza "Scala"] [x y]) 
    (logic/== q [x y]) 
    (logic/!= y "Java"))) 
 
;;=> ([:pizza "Scala"])
1
2
3
4
5
(logic/run* [q] 
  (logic/fresh [n] 
    (logic/== q n))) 
 
;;=> (_0)
1
2
3
4
5
6
(logic/run* [q] 
  (logic/fresh [n] 
    (logic/!= 0 n) 
    (logic/== q n))) 
 
;;=> ((_0 :- (!= (_0 0))))
1 (require '[clojure.core.logic.fd :as fd])

1
2
3
4
5
6
7
;; CAUTION: RUN THIS AT YOUR OWN RISK 
(logic/run* [q] 
  (logic/fresh [n] 
    (fd/in n (fd/interval 1 Integer/MAX_VALUE)) 
    (logic/== q n))) 
 
;;=> (1 2 3 ... many more numbers follow)
1
2
3
4
5
6
(logic/run* [q] 
  (logic/fresh [n] 
    (fd/in n (fd/domain 0 1)) 
    (logic/== q n))) 
 
;;=> (0 1)
1
2
3
4
5
6
7
8
(logic/run* [q] 
  (let [coin (fd/domain 0 1)] 
    (logic/fresh [heads tails] 
      (fd/in heads 0 coin) 
      (fd/in tails 1 coin) 
      (logic/== q [heads tails])))) 
 
;;=> ([0 0] [0 1] [1 0] [1 1])
1
2
3
4
5
(defn rowify [board] 
  (->> board 
       (partition 9) 
       (map vec) 
       vec))
1
2
3
4
5
6
7
8
9
10
(rowify b1) 
 
;;=> [[3 - - - - 5 - 1 -] 
      [- 7 - - - 6 - 3 -] 
      [1 - - - 9 - - - -] 
      [7 - 8 - - - - 9 -] 
      [9 - - 4 - 8 - - 2] 
      [- 6 - - - - 5 - 1] 
      [- - - - 4 - - - 6] 

11       [- 4 - 7 - - - 2 -] 
      [- 2 - 6 - - - - 3]]
1
2
(defn colify [rows] 
  (apply map vector rows))
1
2
(colify (rowify b1)) 
;;=> ([3 - 1 7 9 - - - -] [- 7 - - - 6 - 4 2] ... )
1
2
3
4
5
6
7
(defn subgrid [rows] 
  (partition 9 
    (for [row (range 0 9 3) 
          col (range 0 9 3) 
          x (range row (+ row 3)) 
          y (range col (+ col 3))] 
      (get-in rows [x y]))))
(subgrid (rowify b1)) 
;;=> ((3 - - - 7 - 1 - -) (- - 5 - - 6 - 9 -) ... )
1 (def logic-board #(repeatedly 81 logic/lvar))
Listing 16.9. Recursively initializing a Sudoku board ×lled with logic variables
(defn init [[lv & lvs] [cell & cells]] 
 (if lv 
   (logic/fresh [] 
     (if (= '- cell) 
       logic/succeed 
       (logic/== lv cell)) 

     (init lvs cells)) 
   logic/succeed))
------------------------------------- 
| 3   ?   ? | ?   ?   5 | ?   1   ? | 
| ?   7   ? | ?   ?   6 | ?   3   ? | 
| 1   ?   ? | ?   9   ? | ?   ?   ? | 
------------------------------------- 
| 7   ?   8 | ?   ?   ? | ?   9   ? | 
| 9   ?   ? | 4   ?   8 | ?   ?   2 | 
| ?   6   ? | ?   ?   ? | 5   ?   1 | 
------------------------------------- 
| ?   ?   ? | ?   4   ? | ?   ?   6 | 
| ?   4   ? | 7   ?   ? | ?   2   ? | 
| ?   2   ? | 6   ?   ? | ?   ?   3 | 
-------------------------------------
Listing 16.10. A core.logic Sudoku solver
(defn solve-logically [board] 
 (let [legal-nums (fd/interval 1 9) 
       lvars (logic-board)            
       rows  (rowify lvars) 
       cols  (colify rows) 
       grids (subgrid rows)]          
   (logic/run 1 [q] 
     (init lvars board) 
     (logic/everyg #(fd/in % legal-nums) lvars) 
     (logic/everyg fd/distinct rows) 
     (logic/everyg fd/distinct cols) 
     (logic/everyg fd/distinct grids) 
     (logic/== q lvars))))
(-> b1 
   solve-logically 
   first 
   prep 
   print-board) 
;; ------------------------------------- 
;; | 3   8   6 | 2   7   5 | 4   1   9 | 
;; | 4   7   9 | 8   1   6 | 2   3   5 | 
;; | 1   5   2 | 3   9   4 | 8   6   7 | 
;; ------------------------------------- 
;; | 7   3   8 | 5   2   1 | 6   9   4 | 
;; | 9   1   5 | 4   6   8 | 3   7   2 | 
;; | 2   6   4 | 9   3   7 | 5   8   1 | 
;; ------------------------------------- 
;; | 8   9   3 | 1   4   2 | 7   5   6 | 
;; | 6   4   1 | 7   5   3 | 9   2   8 | 

;; | 5   2   7 | 6   8   9 | 1   4   3 | 
;; -------------------------------------

CHAPTER 17
Table 17.1. Artists
:artist
:genre-id
Burial
1
Magma
2
Can
3
Faust
3
Ikonika
1
Grouper
4
Table 17.2. Genres
:genre-id
:genre-name
1
Dubstep
2
Zeuhl
3
Prog
4
Drone
1
2
3
4
5
6
7
8
9
10
11
12
13
14
(def artists 
  #{{:artist "Burial"  :genre-id 1} 
    {:artist "Magma"   :genre-id 2} 
    {:artist "Can"     :genre-id 3} 
    {:artist "Faust"   :genre-id 3} 
    {:artist "Ikonika" :genre-id 1} 
    {:artist "Grouper"}}) 
 
 
(def genres 
  #{{:genre-id 1 :genre-name "Dubstep"} 
    {:genre-id 2 :genre-name "Zeuhl"} 
    {:genre-id 3 :genre-name "Prog"} 
    {:genre-id 4 :genre-name "Drone"}})
Listing 17.1. select *  example using Clojure’s relational algebra functions
1
2
3
(require '[clojure.set :as ra]) 
(def ALL identity) 
 

4
5
6
7
8
9
(ra/select ALL genres) 
 
;;=> #{{:genre-id 4, :genre-name "Drone"} 
       {:genre-id 3, :genre-name "Prog"} 
       {:genre-id 2, :genre-name "Zeuhl"} 
       {:genre-id 1, :genre-name "Dubstep"}}
1
2
3
4
(ra/select (fn [m] (#{1 3} (:genre-id m))) genres) 
 
;;=> #{{:genre-id 3, :genre-name "Prog"} 
       {:genre-id 1, :genre-name "Dubstep"}}
1
2
(defn ids [& ids] 
  (fn [m] ((set ids) (:genre-id m))))
1
2
3
4
(ra/select (ids 1 3) genres) 
 
;;=> #{{:genre-id 3, :genre-name "Prog"} 
       {:genre-id 1, :genre-name "Dubstep"}}
1
2
3
4
(take 2 (ra/select ALL (ra/join artists genres))) 
 
;;=> #{{:artist "Burial", :genre-id 1, :genre-name "Dubstep"} 
       {:artist "Magma", :genre-id 2, :genre-name "Zeuhl"}}
1
2
3
4
5
(defn fantasy-query [max] 
  (SELECT [a b c] 
    (FROM X 
      (LEFT-JOIN Y :ON (= X.a Y.b))) 
    (WHERE (< a 5) AND (< b max))))

1
2
3
4
5
(fantasy-query 5) 
 
;;=> {:query "SELECT a, b, c FROM X LEFT JOIN Y ON (X.a = Y.b) 
              WHERE ((a < 5) AND (b < ?))" 
      :bindings [5]}
Listing 17.2. ShufØing SQL-like operators into in×x position
1
2
3
4
5
6
7
8
9
10
11
(ns joy.sql 
  (:use [clojure.string :as str :only []])) 
(defn shuffle-expr [expr] 
  (if (coll? expr) 
    (if (= (first expr) `unquote) 
      "?" 
      (let [[op & args] expr] 
        (str "(" 
          (str/join (str " " op " ") 
                    (map shuffle-expr args)) ")"))) 
    expr))
1
2
3
1
2
(shuffle-expr 42) 
;;=> 42
1
2
(shuffle-expr `(unquote max)) 
;;=> "?"
1
2
3
(read-string "~max") 
 
;;=> (clojure.core/unquote max)
1
2
(shuffle-expr '(= X.a Y.b)) 
;;=> "(X.a = Y.b)"

1
2
(shuffle-expr '(AND (< a 5) (< b ~max))) 
;;=> "((a < 5) AND (b < ?))"
1
2
(shuffle-expr '(AND (< a 5) (OR (> b 0) (< b ~max)))) 
;;=> "((a < 5) AND ((b > 0) OR (b < ?)))"
1
2
(defn process-where-clause [processor expr] 
  (str " WHERE " (processor expr)))
1
2
3
(process-where-clause shuffle-expr '(AND (< a 5) (< b ~max))) 
 
;;=> " WHERE (((a < 5) AND (b < ?)))"
1
2
3
(defn process-left-join-clause [processor table _ expr] 
  (str " LEFT JOIN " table 
       " ON " (processor expr)))
1
2
3
4
5
(apply process-left-join-clause 
       shuffle-expr 
       '(Y :ON (= X.a Y.b))) 
 
;;=> " LEFT JOIN Y ON (X.a = Y.b)"
1
2
3
4
(let [LEFT-JOIN (partial process-left-join-clause shuffle-expr)] 
  (LEFT-JOIN 'Y :ON '(= X.a Y.b))) 
 
;;=> " LEFT JOIN Y ON (X.a = Y.b)"

1
2
3
(defn process-from-clause [processor table & joins] 
  (apply str " FROM " table 
         (map processor joins)))
1
2
3
4
(process-from-clause shuffle-expr 'X 
  (process-left-join-clause shuffle-expr 'Y :ON '(= X.a Y.b))) 
 
;;=> " FROM X LEFT JOIN Y ON (X.a = Y.b)"
1
2
3
(defn process-select-clause [processor fields & clauses] 
  (apply str "SELECT " (str/join ", " fields) 
         (map processor clauses)))
1
2
3
4
5
6
7
8
9
(process-select-clause shuffle-expr 
  '[a b c] 
  (process-from-clause shuffle-expr 'X 
    (process-left-join-clause shuffle-expr 'Y :ON '(= X.a Y.b))) 
  (process-where-clause shuffle-expr '(AND (< a 5) (< b ~max)))) 
 
;;=> "SELECT a, b, c FROM X 
;;    LEFT JOIN Y ON (X.a = Y.b) 
;;    WHERE ((a < 5) AND (b < ?))"
1
2
3
4
5
6
7
(declare apply-syntax) 
 
(def ^:dynamic *clause-map* 
  {'SELECT    (partial process-select-clause apply-syntax) 
   'FROM      (partial process-from-clause apply-syntax) 
   'LEFT-JOIN (partial process-left-join-clause shuffle-expr) 
   'WHERE     (partial process-where-clause shuffle-expr)})
Listing 17.3. Looking up syntax processors in the processor table

1
2
(defn apply-syntax [[op & args]] 
  (apply (get *clause-map* op) args))
1
Listing 17.4. Building a SQL-like SELECT  statement DSL
1
2
3
4
5
6
(defmacro SELECT [& args] 
  {:query (apply-syntax (cons 'SELECT args)) 
   :bindings (vec (for [n (tree-seq coll? seq args) 
                    :when (and (coll? n) 
                               (= (first n) `unquote))] 
                    (second n)))})
1
2
1
2
3
4
5
6
7
8
9
10
11
(defn example-query [max] 
  (SELECT [a b c] 
    (FROM X 
          (LEFT-JOIN Y :ON (= X.a Y.b))) 
    (WHERE (AND (< a 5) (< b ~max))))) 
 
(example-query 9) 
;;=> {:query "SELECT a, b, c 
;;            FROM X LEFT JOIN Y ON (X.a = Y.b) 
;;            WHERE ((a < 5) AND (b < ?))" 
;;    :bindings [9]}
1
2
3
(cond 
  (keyword? x) "x is a keyword" 
  :else "x is not a keyword")
Listing 17.5. Using with-redefs  to create stubs
1
2
3
4
5
6
7
8
9
10
11
(ns joy.unit-testing 
  (:require [joy.futures :as joy])) 
(def stubbed-feed-children 
  (constantly [{:content [{:tag :title 
                           :content ["Stub"]}]}])) 
(defn count-feed-entries [url] 
  (count (joy/feed-children url))) 
(count-feed-entries "http://blog.fogus.me/feed/") 
;;=> 5 
(with-redefs [joy/feed-children stubbed-feed-children] 
1
2
3

12   (count-feed-entries "dummy url")) 
;;=> 1
1
2
3
4
(with-redefs [feed-children stubbed-feed-children] 
  (joy/occurrences joy/title "Stub" "a" "b" "c")) 
 
;=> 3
Listing 17.6. clojure.test  as a partial speci×cation
1
2
3
4
5
6
7
8
9
10
(require '[clojure.test :refer (deftest testing is)]) 
(deftest feed-tests 
  (with-redefs [joy/feed-children stubbed-feed-children] 
    (testing "Child Counting" 
      (is (= 1000 (count-feed-entries "Dummy URL")))) 
    (testing "Occurrence Counting" 
      (is (= 0 (joy/count-text-task 
                  joy/title 
                  "ZOMG" 
                  "Dummy URL"))))))
1
2
3
1
2
3
4
5
6
7
8
9
10
11
12
(clojure.test/run-tests 'joy.unit-testing) 
; Testing joy.unit-testing 
; 
;  FAIL in (feed-tests) 
;  Child Counting 
;  expected: (= 1000 (count-feed-entries "Dummy URL")) 
;   actual: (not (= 1000 1)) 
 
; 
;  Ran 1 tests containing 2 assertions. 
;  1 failures, 0 errors. 
;;=> {:type :summary, :pass 1, :test 1, :error 0, :fail 1}
1
2
3
4
(def sqr (partial 
  (contract sqr-contract 
    [n] 
    (require (number? n)) 

5
6
7
8
9
    (ensure (pos? %))) 
  #(* % %))) 
 
[(sqr 10) (sqr -9)] 
;=> [100 81]
1
2
3
4
5
6
7
8
9
(doseq [n (range Short/MIN_VALUE Short/MAX_VALUE)] 
  (try 
    (sqr n) 
    (catch AssertionError e 
      (println "Error on input" n) 
      (throw e)))) 
 
; Error on input 0 
;=> java.lang.AssertionError: Assert failed: (pos? %)
Listing 17.7. Creating formulas that are like spreadsheet cells
1
2
3
4
5
6
7
8
9
10
(ns joy.cells) 
(defmacro defformula [nm bindings & formula]  
  `(let ~bindings 
     (let [formula#   (agent ~@formula) 
           update-fn# (fn [key# ref# o# n#] 
                        (send formula# (fn [_#] ~@formula)))] 
       (doseq [r# ~(vec (map bindings 
                          (range 0 (count bindings) 2)))] 
         (add-watch r# :update-formula update-fn#)) 
       (def ~nm formula#))))
1
2
3
Listing 17.8. defformula  to track baseball averages
1
2
3
4
5
(def h (ref 25) 
(def ab (ref 100)) 
(defformula avg 
  [at-bats ab, hits h] 
  (float (/ @hits @at-bats)))
1
2
1
2
@avg 
;;=> 0.25

Figure 17.1. Using defformula  is akin to programming a spreadsheet.
1
2
3
4
(dosync (ref-set h 33)) 
 
@avg 
;;=> 0.33
1
2
3
4
5
6
(ns joy.patterns.abstract-factory) 
 
(def config 
  '{:systems {:pump {:type :feeder, :descr "Feeder system"} 
              :sim1 {:type :sim,    :fidelity :low} 
              :sim2 {:type :sim,    :fidelity :high, :threads 2}}})
1
2
(defn describe-system [name cfg] 
  [(:type cfg) (:fidelity cfg)])
1
2
3
(describe-system :pump {:type :feeder, :descr "Feeder system"}) 
 
;;=> [:feeder nil]
Listing 17.9. Basis for an abstract factory implementation using multimethods
1
2
3
4
(defmulti construct describe-system) 
(defmethod construct :default [name cfg] 
  {:name name 
   :type (:type cfg)}) 
1
2

5
6
7
(defn construct-subsystems [sys-map] 
  (for [[name cfg] sys-map] 
    (construct name cfg)))
3
1
2
3
4
5
(construct-subsystems (:systems config)) 
 
;;=> ({:name :pump, :type :feeder} 
;;    {:name :sim1, :type :sim} 
;;    {:name :sim2, :type :sim})
1
2
3
4
5
6
7
8
(defmethod construct [:feeder nil] 
  [_ cfg] 
  (:descr cfg)) 
 
(construct-subsystems (:systems config)) 
;;=> ("Feeder system" 
;;    {:name :sim1, :type :sim} 
;;    {:name :sim2, :type :sim})
1
2
(defrecord LowFiSim [name]) 
(defrecord HiFiSim  [name threads])
Listing 17.10. De×ning concrete factories using multimethods
1
2
3
4
5
6
(defmethod construct [:sim :low] 
  [name cfg] 
  (->LowFiSim name)) 
(defmethod construct [:sim :high] 
  [name cfg] 
  (->HiFiSim name (:threads cfg)))
1
2
1
2
3
4
5
(construct-subsystems (:systems config)) 
 
;;=> ("Feeder system" 
;;    #joy.patterns.abstract_factory.LowFiSim{:name :sim1} 
;;    #joy.patterns.abstract_factory.HiFiSim {:name :sim2, :threads 2})

1
2
3
4
5
6
(ns joy.patterns.di 
  (:require [joy.patterns.abstract-factory :as factory])) 
 
(def lofi {:type :sim, :descr "Lowfi sim", :fidelity :low}) 
 
(def hifi {:type :sim, :descr "Hifi sim", :fidelity :high, :threads 2})
1
2
3
(factory/construct :lofi lofi) 
 
;;=> #joy.patterns.abstract_factory.LowFiSim{:name :lofi, ...}
Listing 17.11. Protocols describing system-level and simulation capabilities
1
2
3
4
5
(defprotocol Sys 
  (start! [sys]) 
  (stop!  [sys])) 
(defprotocol Sim 
  (handle [sim msg]))
1
2
Listing 17.12. Using abstract system construction and a system-level protocol
1
2
3
4
(defn build-system [name config] 
  (let [sys (factory/construct name config)] 
    (start! sys) 
    sys))
Listing 17.13. Extending an existing type to the Sys  and Sim  protocols
1
2
3
4
5
6
7
8
9
(extend-type joy.patterns.abstract_factory.LowFiSim 
  Sys 
  (start! [this] 
    (println "Started a lofi simulator.")) 
  (stop!  [this] 
    (println "Stopped a lofi simulator.")) 
  Sim 
  (handle [this msg] 
    (* (:weight msg) 3.14)))
1
2

1
2
(start! (factory/construct :lofi lofi)) 
;; Started a lofi simulator.
1
2
3
(build-system :sim1 lofi) 
;; Started a lofi simulator. 
;;=> #joy.patterns.abstract_factory.LowFiSim{:name :sim1, ...}
1
2
(handle (build-system :sim1 lofi) {:weight 42}) 
;;=> 131.88
Listing 17.14. Extending the existing HiFiSim  type to Sys  and Sim
1
2
3
4
5
6
7
8
(extend-type joy.patterns.abstract_factory.HiFiSim 
  Sys 
  (start! [this] (println "Started a hifi simulator.")) 
  (stop!  [this] (println "Stopped a hifi simulator.")) 
  Sim 
  (handle [this msg] 
    (Thread/sleep 5000) 
    (* (:weight msg) 3.1415926535897932384626M)))
1
2
1
2
3
4
5
6
7
(build-system :sim2 hifi) 
;; Started a lofi simulator. 
;;=> #joy.patterns.abstract_factory.HiFiSim{:name :sim2,...} 
 
(handle (build-system :sim2 hifi) {:weight 42}) 
;; wait 5 seconds... 
;;=> 131.9468914507713160154292M
Listing 17.15. Calculating both a low- and a high-×delity answer
1
2
(def excellent (promise)) 
(defn simulate [answer fast slow opts] 

3
4
  (future (deliver answer (handle slow opts))) 
  (handle fast opts))
12
1
2
3
4
5
6
(simulate excellent 
          (build-system :sim1 lofi) 
          (build-system :sim2 hifi) 
          {:weight 42}) 
 
;;=> 131.88
1
2
(realized? excellent) 
;;=> false
1
2
3
4
5
6
7
;; wait a few seconds 
 
(realized? excellent) 
;;=> true 
 
@excellent 
;;=> 131.9468914507713160154292M
Listing 17.16. Creating a mock of a system
1
2
3
4
5
6
7
(ns joy.patterns.mock 
  (:require [joy.patterns.abstract-factory :as factory] 
            [joy.patterns.di :as di])) 
 
(defrecord MockSim [name]) 
 
(def starts (atom 0))
Listing 17.17. Extending a mock system to existing protocols.
1
2
3
4
5
(extend-type MockSim 
  di/Sys 
  (start! [this] 
    (if (= 1 (swap! starts inc)) 
      (println "Started a mock simulator.") 
1

6
7
8
9
      (throw (RuntimeException. "Called start! more than once.")))) 
  (stop!  [this] (println "Stopped a mock simulator.")) 
  di/Sim 
  (handle [_ _] 42))
2
Listing 17.18. Construction function for the mock system
1
2
3
(defmethod factory/construct [:mock nil] 
  [nom _] 
  (MockSim. nom))
Listing 17.19. Tying together a system via con×guration
1
2
3
4
(ns joy.patterns.app 
  (require [joy.patterns.di :as di])) 
 
(def config {:type :mock, :lib  'joy.patterns.mock})
Listing 17.20. Injecting dependencies
1
2
3
4
(defn initialize [name cfg] 
  (let [lib (:lib cfg)] 
    (require lib) 
    (di/build-system name cfg)))
1
2
3
(di/handle (initialize :mock-sim config) {}) 
;; Started a mock simulator. 
;;=> 42
1
2
3
(initialize :mock-sim config) 
 
;; java.lang.RuntimeException: Called start! more than once.

1 {:tag <node form>, :attrs {}, :content [<nodes>]}
1
2
3
4
5
(defn traverse [node f] 
  (when node 
    (f node) 
    (doseq [child (:content node)] 
      (traverse child f))))
1
2
3
4
(traverse {:tag :flower :attrs {:name "Tanpopo"} :content []} 
          println) 
 
; {:tag :flower, :attrs {:name Tanpopo}, :content []}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
xml/parse function: 
 
(use '[clojure.xml :as xml]) 
 
(def DB 
  (-> "<zoo> 
         <pongo> 
           <animal>orangutan</animal> 
         </pongo> 
         <panthera> 
           <animal>Spot</animal> 
           <animal>lion</animal> 
           <animal>Lopshire</animal> 
         </panthera> 
       </zoo>" 
      .getBytes 
      (java.io.ByteArrayInputStream.) 
      xml/parse))
Listing 17.21. Handling nefarious tree nodes with exceptions
1
2
3
(defn ^:dynamic handle-weird-animal  
  [{[name] :content}] 
  (throw (Exception. (str name " must be 'dealt with'"))))
1

Listing 17.22. Example of dynamic delegation
1
2
3
4
5
6
(defmulti visit :tag) 
(defmethod visit :animal [{[name] :content :as animal}] 
  (case name 
    "Spot"     (handle-weird-animal animal) 
    "Lopshire" (handle-weird-animal animal) 
    (println name)))
1
1
2
3
(traverse DB visit) 
; orangutan 
; java.lang.Exception: Spot must be 'dealt with'
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
(defmulti handle-weird  (fn [{[name] :content}] name)) 
 
(defmethod handle-weird "Spot" [_] 
  (println "Transporting Spot to the circus.")) 
 
(defmethod handle-weird "Lopshire" [_] 
  (println "Signing Lopshire to a book deal.")) 
 
(binding [handle-weird-animal handle-weird] 
  (traverse DB visit)) 
 
; orangutan 
; Transporting Spot to the circus. 
; lion 
; Signing Lopshire to a book deal.
1
2
3
4
5
6
7
(def _ (future 
         (binding [handle-weird-animal #(println (:content %))] 
           (traverse DB visit)))) 
; orangutan 
; [Spot] 
; lion 
; [Lopshire]

1 (defn div [n d] (int (/ n d)))
1
2
3
(defn div [n d] (break) (int (/ n d))) 
(div 10 0) 
debug=>
Listing 17.23. A modest debug console reader
1
2
3
4
5
(defn readr [prompt exit-code] 
  (let [input (clojure.main/repl-read prompt exit-code)] 
    (if (= input ::tl) 
      exit-code 
      input)))
1
2
1
2
3
4
5
6
7
8
9
(readr #(print "invisible=> ") ::exit) 
[1 2 3]  ;; this is what you type 
 
;=> [1 2 3] 
 
(readr #(print "invisible=> ") ::exit) 
::tl  ;; this is what you type 
 
;=> :user/exit
Listing 17.24. Creating a map of the local context using &env
1
2
3
4
5
(defmacro local-context [] 
  (let [symbols (keys &env)] 
     (zipmap (map (fn [sym] `(quote ~sym)) 
                  symbols) 
             symbols)))
1
2
1
2
(local-context) 
;=> {} 

3
4
5
6
7
 
(let [a 1, b 2, c 3] 
  (let [b 200] 
    (local-context))) 
;=> {a 1, b 200, c 3}
Listing 17.25. Implementation of a breakpoint macro
1
2
3
4
5
(defmacro break [] 
  `(clojure.main/repl 
    :prompt #(print "debug=> ") 
    :read readr 
    :eval (partial contextual-eval (local-context))))
1
2
3
(defn div [n d] (break) (int (/ n d))) 
(div 10 0) 
debug=>
1
2
3
4
5
6
7
8
9
10
11
debug=> n 
;=> 10 
 
debug=> d 
;=> 0 
 
debug=> (local-context) 
;=> {n 10, d 0} 
 
debug=> ::tl 
; java.lang.ArithmeticException: Divide by zero
Listing 17.26. Using multiple breakpoints in the keys-apply  function
(defn keys-apply [f ks m] 
 (break) 
 (let [only (select-keys m ks)] 
   (break) 
   (zipmap (keys only) (map f (vals only))))) 
(keys-apply inc [:a :b] {:a 1, :b 2, :c 3}) 
debug=> only 
; java.lang.Exception: Unable to resolve symbol: only in this context 
debug=> ks 
;=> [:a :b] 

debug=> m 
;=> {:a 1, :b 2, :c 3} 
debug=> ::tl 
debug=> only 
;=> {:b 2, :a 1} 
debug=> ::tl 
;=> {:a 2, :b 3}
Listing 17.27. Using a breakpoint in the awhen  macro
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
(defmacro awhen [expr & body] 
  (break) 
  `(let [~'it ~expr] 
     (if ~'it 
       (do (break) ~@body)))) 
 
(awhen [1 2 3] (it 2)) 
debug=> it 
; java.lang.Exception: Unable to resolve symbol: it in this context 
debug=> expr 
;=> [1 2 3] 
debug=> body 
;=> ((it 2)) 
debug=> ::tl 
debug=> it 
;=> [1 2 3] 
debug=> (it 1) 
;=>  2 
debug=> ::tl 
;=> 3

