|
Part III: Mathematical basics of data science


10 Mathematics as a language for science
10.1 Introduction
In data science, all problems will be approached computationally. For this reason,
we started this book with an introduction to the programming language R.
Since most of the models for data analysis are based on mathematics and statis-
tics, the next step will focus on the understanding of mathematical background
needed to formulate and build these models. However, before we present, in the sub-
sequent chapters, the mathematical basis of data science, we want to emphasize in
this chapter a more general point concerning the mathematical language itself. This
point refers to the abstract nature of data science.
In Figure 10.1, we visualize a generic framework that holds for every data anal-
ysis problem. The key point here is that every data analysis is conducted via a
computer program that represents methodological ideas from statistics and machine
learning, and every computer program consists of instructions (commands) that en-
able the communication with the processor of a computer to perform computations
electronically. Since every data analysis is conducted via a computer program that
contains instructions in a programming language, a good data scientist needs to
â€œspeakâ€ fluently a programming language. However, the basis of any programming
language for data analysis is mathematics, and its key characteristic is abstractness.
For this reason, a simplified message from the above discussion can be summarized
as follows:
Thinking in abstract mathematical terms makes you a better programmer and, hence, a
better data scientist.
This is also the reason why mathematics is sometimes called the language of science
[185, 188], as noted by Galileo.
Before we proceed, we would like to add a couple of notes for clarification. First,
by a programmer we mean actually a scientific programmer i. e., someone who is
concerned with the conversion of statistical and machine learning ideas into a com-
puter program rather than a general programmer who implements graphical user
interfaces (GUIs) or websites. The crucial difference is that the level of mathematics
needs for, e. g., the implementation of a GUI is minimal comparable to the imple-
mentation of a data analysis method. Also, such a way of programming is usually
purely deterministic and not probabilistic. On the other hand, the nature of a data
analysis is to deal with measurement errors and other imperfections of the data.
Hence, probabilistic and statistical methods cannot be avoided in data science since
they are integral pillars of the topic.
Second, although it is certainly not necessary to implement every method for
conducting a data analysis, a good data scientist should be capable to implement
https://doi.org/10.1515/9783110796063-010

150
|
10 Mathematics as a language for science
Figure 10.1: Generic visualization of any data analysis problem. Data analysis is conducted via
a computer program that has been written based on statistical- and machine-learning methods
informed with domain-specific knowledge, e. g., from biology, medicine, or the social sciences.
any method required for the analysis. Third, the natural language we are speaking,
e. g., English, does not translate equally well into a computer language like R, but
there are certain terms and structures that translate better. For instance, when we
speak about a â€œvectorâ€ and its components, we will not have a problem to capture
this in R, as shown in Chapter 5. Furthermore, in Chapter 12, we will learn much
more about vectors in the context of linear algebra. This is not a coincidence, but
the meaning of a vector is informed by its mathematical concept. Hence, whenever
we use this term in our natural language, we have an immediate correspondence to
its mathematical concept. This implies that the more we know about mathemat-
ics, the more we become familiar with terms that are well defined mathematically,
and such terms can be swiftly translated into a computer program for data analy-
sis.
We would like to finish this section by adding one more example that demon-
strates the importance of â€œlanguageâ€ and its influence on the way humans think.
Suppose, you have a twin sibling and you both are separated right after birth. You
grow up in the way you did, and your twin grows up on a deserted island without
civilization. Then, let say after 20 years, you both are independently asked a series
of questions and given tasks to solve. Given that you both share the same DNA,
one would expect that both of you have the same potential in answering these ques-
tions. However, practically it is unlikely that your twin will perform well, because
of basic communication problems in the first place. In our opinion the language of
â€œmathematicsâ€ plays a similar role with respect to â€œquestionsâ€ and â€œtasksâ€ from a
data analysis perspective.
In the remainder of this chapter, we provide a discussion of some basic abstract
mathematical symbols and operations we consider very important to (A) help for-
mulating concise mathematical statements, and (B) shape the way of thinking.

10.2 Numbers and number operations
|
151
10.2 Numbers and number operations
In mathematics, we distinguish five main number systems from each other:
â€“
natural numbers: N
â€“
integers: Z
â€“
rational numbers: Q
â€“
real numbers: R
â€“
complex numbers: C
Each of the above symbols represents a set of all numbers that belong to the cor-
responding number system. For instance, N represents all natural numbers, i. e.,
1, 2, 3, . . . ; Z represents all integer number, i. e., . . . , âˆ’2, âˆ’1, 0, +1, +2, . . . ; Q repre-
sents all rational numbers ğ‘
ğ‘with ğ‘and ğ‘being any integer number; and R is the
set of all real numbers, e. g., 1.4271.
There is a natural connection between these number systems in the way that
N âŠ‚Z âŠ‚Q âŠ‚R âŠ‚C.
(10.1)
That means, e. g., every integer number is also a real number, but not every integer
number is a natural number. Furthermore, the special sets Z+ and R+ denote the
set of all positive integers and positive reals.
Intervals
When defining functions, it is common to limit the value of numbers to specific
intervals. One distinguishes finite from infinite intervals. Specifically, finite intervals
can be defined in four different ways:
[ğ‘, ğ‘] = {ğ‘¥| ğ‘â‰¤ğ‘¥â‰¤ğ‘}
closed interval,
(10.2)
[ğ‘, ğ‘) = {ğ‘¥| ğ‘â‰¤ğ‘¥< ğ‘}
half-closed interval,
(10.3)
(ğ‘, ğ‘] = {ğ‘¥| ğ‘< ğ‘¥â‰¤ğ‘}
half-closed interval,
(10.4)
(ğ‘, ğ‘) = {ğ‘¥| ğ‘< ğ‘¥< ğ‘}
open interval.
(10.5)
Similarly, infinite intervals can be defined as follows:
[ğ‘, âˆ) = {ğ‘¥| ğ‘â‰¤ğ‘¥< âˆ},
(10.6)
(ğ‘, âˆ) = {ğ‘¥| ğ‘< ğ‘¥< âˆ},
(10.7)
(âˆ’âˆ, ğ‘] = {ğ‘¥| âˆ’âˆ< ğ‘¥â‰¤ğ‘},
(10.8)
(âˆ’âˆ, ğ‘) = {ğ‘¥| âˆ’âˆ< ğ‘¥< ğ‘},
(10.9)
(âˆ’âˆ, âˆ) = R.
(10.10)

152
|
10 Mathematics as a language for science
The difference between a closed interval and an open interval is that for a closed
interval the end point(s) belong to the interval, whereas this is not the case for an
open interval.
Modulo operation
The modulo operation gives the remainder of a devision of two positive numbers ğ‘
and ğ‘. It is defined for ğ‘âˆˆR+ and ğ‘âˆˆR+ âˆ–{0} by
ğ‘
mod ğ‘= modulo(ğ‘, ğ‘) = ğ‘âˆ’ğ‘›Â· ğ‘= ğ‘Ÿ.
(10.11)
Here, ğ‘›âˆˆN âˆª{0} is a natural number, and ğ‘ŸâˆˆR+ is the remainder of the division
of ğ‘by ğ‘. For programming, the modulo operation is frequently used for integer
numbers ğ‘and ğ‘, because a cyclic mapping can be easily realized, i. e., ğ‘+ 1 â†’1
can be obtained by
modulo(ğ‘+ 1, ğ‘).
(10.12)
In R, the module operation is carried out using the following code:
Listing 10.1: Modulo Operation
a %% b
#
modulo(a, b)
Example 10.2.1. We calculate 17 mod 4
=
modulo(17, 4) and 3 mod 7
=
modulo(3, 7). In these examples, ğ‘and ğ‘are integers. Therefore, we use the fact
that in case we determine ğ‘
ğ‘, we always find ğ‘, ğ‘ŸâˆˆZ such that ğ‘= ğ‘Ë™ğ‘+ ğ‘Ÿ, see [199].
We start with 17 mod 4 and see that 17 = ğ‘Â· 4 + ğ‘Ÿ. Hence, ğ‘= 4, and ğ‘Ÿ= 1.
Thus, 17 mod 4 = 1. If we consider 3 mod 7, we find 3 = ğ‘Â· 7 + ğ‘Ÿ. Thus, ğ‘= 0,
and ğ‘Ÿ= 3. This yields to 3 mod 7 = 3.
Rounding operations
The floor and ceiling operations round a real number to its nearest integer value up
or down. The corresponding functions are denoted by
âŒŠğ‘¥âŒ‹
floor function,
(10.13)
âŒˆğ‘¥âŒ‰
ceiling function.
(10.14)
As an example, the value of ğ‘¥= 1.9 results in âŒŠğ‘¥âŒ‹= 1 and âŒˆğ‘¥âŒ‰= 2.
In contrast, the command round(ğ‘¥), rounds the value of the real number ğ‘¥to its
nearest integer value. For instance, round(0.51) = 1. In R, the value 0.5 is rounded
toward the lower integer value, e. g., round(âˆ’3.5) = âˆ’4.

10.3 Sets and set operations
|
153
Finally, the truncation function, trunc(ğ‘¥), of a real number ğ‘¥is just the integer
digits of the number ğ‘¥without the fractional digits i. e., the numbers after the
decimal point. For instance, trunc(3.91) = 3.
Listing 10.2: Rounding operations, sign function and absolute value
floor(x)
# âŒŠğ‘¥âŒ‹
ceiling(x)
# âŒˆğ‘¥âŒ‰
round(x)
# round(x)
trunc(x)
# truncation(x)
sign(x)
# sign of x
abs(x)
# absolute value of x
Sign function
For any real number ğ‘¥âˆˆR, the sign function, sign(ğ‘¥), is given by
sign(ğ‘¥) =
â§
âª
âª
â¨
âª
âª
â©
+1
if ğ‘¥> 0;
0
if ğ‘¥= 0;
âˆ’1
if ğ‘¥< 0.
(10.15)
Absolute value
The absolute value or the modulus of a real number ğ‘¥âˆˆR is given by
abs(ğ‘¥) = |ğ‘¥| =
{ï¸ƒ
+ğ‘¥
if ğ‘¥â‰¥0;
âˆ’ğ‘¥
if ğ‘¥< 0.
(10.16)
10.3 Sets and set operations
In the following, we introduce sets and some of their basic operations. In general,
a set is a well-defined collection of objects. For instance, ğ’œ= {1, 2, 3} contains the
three natural numbers 1, 2, and 3, â„¬= {â–³, âˆ˜} is a set consisting of two geometric
objects,
ğ’= {K, Q, N, B, p}
(10.17)
is the set containing chess pieces, and ğ’Ÿ= {ğ’œ, ğ’} is a set of sets. From these
examples, one can see that an object is something very generic, and a set is just a
container for objects. Usually, the objects of a set are enclosed by the curly brackets
â€œ{â€ and â€œ}â€.
The symbol âˆˆdenotes the membership relation to indicate that an object is
contained in a set. For instance, 2 âˆˆğ’œ, and âˆ˜âˆˆâ„¬. Here, the objects 2 and âˆ˜are also

154
|
10 Mathematics as a language for science
called elements of their corresponding sets. The symbol âˆˆis a relation, because it
establishes a connection between an object and a set and, hence, relates both with
each other.
If we have two sets, ğ´1 and ğ´2, and every element in ğ´1 is also contained in
ğ´2, but there are also elements in ğ´2 that are not in ğ´1, we write ğ´1 âŠ‚ğ´2. In this
case ğ´1 is called a subset of ğ´2. In contrast, if every element in ğ´1 is also contained
in ğ´2, and there are no additional elements in ğ´2, we write ğ´1 = ğ´2, because both
sets contain the same elements. Finally, if every element in ğ´1 is also contained in
ğ´2, and there is at least one additional element in ğ´2, we write ğ´1 âŠ†ğ´2. In this
case ğ´1 is a proper subset of ğ´2.
A special set is the empty set, denoted by âˆ…, which does not contain any element.
|ğ´| is the cardinality of ğ´, i. e., the number of its elements. It is possible that a set
contains a finite or infinite number of elements. For instance, for the above set â„¬,
we have |â„¬| = 2, and for the set of natural numbers we have |N| = âˆ.
The set ğ´1 âˆªğ´2 = {ğ‘¥: ğ‘¥âˆˆğ´1 âˆ¨ğ‘¥âˆˆğ´2} is called the union of ğ´1, and ğ´2.
ğ´1 âˆ©ğ´2 = {ğ‘¥: ğ‘¥âˆˆğ´1 âˆ§ğ‘¥âˆˆğ´2} is called the intersection of ğ´1 and ğ´2. For the
definition of these sets, we used the colon symbol â€œ:â€ within the curled brackets.
This symbol means â€œwith the propertyâ€™â€™. Hence, the set {ğ‘¥: ğ‘¥âˆˆğ´1 âˆ¨ğ‘¥âˆˆğ´2} can be
read explicitly as every ğ‘¥that is element in ğ´1 or every ğ‘¥that is element of ğ´2 is a
member of the set ğ´1 âˆªğ´2. Alternatively, sometimes the symbol â€œ|â€ is used instead
of â€œ:â€.
In Figure 10.2, we show a visualization of the union and the intersection. It is
important to realize that both operations create new sets, i. e., ğµ= ğ´1 âˆªğ´2, and
ğ¶= ğ´1 âˆ©ğ´2 are two new sets. If ğ´1 âˆ©ğ´2 = âˆ…, then ğ´1, ğ´2 are called disjoint sets.
Figure 10.2: Visualization of set operations. Left: The union of two sets. Right: The intersection
of ğ´1 and ğ´2.
An alphabet Î£ is a finite set of atomic symbols, e. g., Î£ = {ğ‘, ğ‘, ğ‘}. That means, Î£
contains all elements for a given setting. No other elements can exist.
Î£â‹†is the set of all words over Î£. For example if Î£ = {ğ‘}, then Î£â‹†= {ğœ–, ğ‘, ğ‘ğ‘, ğ‘ğ‘ğ‘,
ğ‘ğ‘ğ‘ğ‘. . .}. Here ğœ–is the empty word.

10.4 Boolean logic
|
155
There are three quantifiers from predicate logic that allow a concise description
of properties of elements of sets.
Definition 10.3.1. The expression âˆ€means for all. For example if ğ´= {ğ‘1, ğ‘2, ğ‘3},
then by âˆ€ğ‘¥âˆˆğ´, we mean all elements in set ğ´, i. e., ğ‘1, ğ‘2, ğ‘3.
Definition 10.3.2. The expression âˆƒmeans there exits. For example if ğµ
=
{âˆ’1, 2, 3}, then by âˆƒğ‘¥âˆˆğµ: ğ‘¥< 3, we mean that in set ğµthere exists an el-
ement, which is less than 3. Possibly, there is more than one such element, as is the
case for ğµ.
Definition 10.3.3. The expression âˆƒ! means there exits only one. For example: âˆƒ! ğ‘¥âˆˆ
ğµ: ğ‘¥< 2 means that in the set ğµthere exists only one element, which is less than 2.
10.4 Boolean logic
The operators âˆ¨and âˆ§are the logical or and and, respectively. They form logical
operators to combine logical variables ğ‘£, ğ‘âˆˆ{1, 0}. Sometimes the logical variables
are expressed as {true, false}. By using operations from the set
ğ’ª:= {ï¸€
Â¬, âˆ§, âˆ¨, ()}ï¸€
,
(10.18)
of logical operators, we can easily construct logical formulas. For instance, the for-
mulas
ğ‘£âˆ¨ğ‘, (ğ‘£âˆ¨ğ‘), (ğ‘£âˆ¨ğ‘) âˆ§Â¬(ğ‘£âˆ¨ğ‘)
(10.19)
represent valid logical formulas as they are derived by using the operators in (10.18).
However, according to this definition, the formulas
(ğ‘£âˆ¨ğ‘)ğ‘ğ‘, (ğ‘£ğ‘)
(10.20)
are not valid (their meaning is undefined).
Suppose that ğ‘†1, ğ‘†2, ğ‘†3 are logical expressions (statements) derived by using
the elements of the set operators ğ’ª, similar to the ones given in equation (10.19).
The following statements about logical formulas hold:
Theorem 10.4.1 (Commutative laws [98]).
ğ‘†1 âˆ§ğ‘†2 â‡â‡’ğ‘†2 âˆ§ğ‘†1
(10.21)
ğ‘†1 âˆ¨ğ‘†2 â‡â‡’ğ‘†2 âˆ¨ğ‘†1
(10.22)
Theorem 10.4.2 (Associative laws [98]).
(ğ‘†1 âˆ§ğ‘†2) âˆ§ğ‘†3 â‡â‡’ğ‘†1 âˆ§(ğ‘†2 âˆ§ğ‘†3)
(10.23)

156
|
10 Mathematics as a language for science
(ğ‘†1 âˆ¨ğ‘†2) âˆ¨ğ‘†3 â‡â‡’ğ‘†1 âˆ¨(ğ‘†2 âˆ¨ğ‘†3)
(10.24)
Theorem 10.4.3 (Distributive laws [98]).
ğ‘†1 âˆ¨(ğ‘†2 âˆ§ğ‘†3) â‡â‡’(ğ‘†1 âˆ¨ğ‘†2) âˆ§(ğ‘†1 âˆ¨ğ‘†3)
(10.25)
ğ‘†1 âˆ§(ğ‘†2 âˆ¨ğ‘†3) â‡â‡’(ğ‘†1 âˆ§ğ‘†2) âˆ¨(ğ‘†1 âˆ§ğ‘†3)
(10.26)
Theorem 10.4.4 (Rules of de Morgan [98]).
Â¬(ğ‘†1 âˆ¨ğ‘†2) â‡â‡’Â¬ğ‘†1 âˆ§Â¬ğ‘†2
(10.27)
Â¬(ğ‘†1 âˆ§ğ‘†2) â‡â‡’Â¬ğ‘†1 âˆ¨Â¬ğ‘†2
(10.28)
Theorem 10.4.1 says that the logical arguments can be switched for the logical
operators and and or. Theorem 10.4.2 says that we may successively shift the brack-
ets to the right. Similarly, when expanding expressions over the reals, for instance
ğ‘¥(ğ‘¥+ 1) = ğ‘¥2 + ğ‘¥, Theorem 10.4.3 gives a rule for expanding logical expressions.
The rules of de Morgan given by Theorem 10.4.4 state that a negation applied
to the single expressions flips the logical operator. Note that these rules can be
formulated for sets accordingly.
Theorem 10.4.5 (Rules of de Morgan for sets [100]).
ğ´âˆªğµ= ğ´âˆ©ğµ
(10.29)
ğ´âˆ©ğµ= ğ´âˆªğµ
(10.30)
The resulting statements (or forms) are called normal forms, and important
examples thereof are the disjunctive normal form and conjunctive normal form of
logical expressions, see [98].
Definition 10.4.1 (Disjunctive normal form (DNF) [98]). A logical expression ğ‘†is
given in disjunctive normal form if
ğ‘†= ğ‘†1 âˆ¨ğ‘†1 âˆ¨Â· Â· Â· âˆ¨ğ‘†ğ‘˜,
(10.31)
where
ğ‘†ğ‘–= ğ‘†ğ‘—1 âˆ§ğ‘†ğ‘—2 âˆ§Â· Â· Â· âˆ§ğ‘†ğ‘—ğ‘˜ğ‘—.
(10.32)
The terms ğ‘†ğ‘—ğ‘–are literals, i. e., logical variables or the negation thereof.
Two examples for logical formulas given in disjunctive normal form are
(ğ‘£âˆ§ğ‘) âˆ¨(Â¬ğ‘£âˆ§Â¬ğ‘)
(10.33)

10.5 Sum, product, and Binomial coefficients
|
157
or
ğ‘£âˆ¨(ğ‘£âˆ§ğ‘).
(10.34)
Here we denote the literals by using the notations ğ‘£and ğ‘for logical variables.
Definition 10.4.2 (Conjunctive normal form (DNF) [98]). A logical expression ğ‘†is
given in conjunctive normal form if
ğ‘†= ğ‘†1 âˆ§ğ‘†1 âˆ§Â· Â· Â· âˆ§ğ‘†ğ‘˜,
(10.35)
where
ğ‘†ğ‘–= ğ‘†ğ‘—1 âˆ¨ğ‘†ğ‘—2 âˆ¨Â· Â· Â· âˆ¨ğ‘†ğ‘—ğ‘˜ğ‘—.
(10.36)
The terms ğ‘†ğ‘—ğ‘–are literals.
Examples for logical formulas given in conjunctive normal form are
(ğ‘£âˆ¨ğ‘) âˆ§(Â¬ğ‘£âˆ¨Â¬ğ‘)
(10.37)
or
ğ‘£âˆ§(ğ‘£âˆ¨ğ‘).
(10.38)
In practice, the application of Boolean functions [98] has been important to de-
velop electronic chips for computers, mobile phones, etc. A logic gate [98] represents
an electronic component that realizes (computes) a Boolean function ğ‘“(ğ‘£1, . . . , ğ‘£ğ‘›) âˆˆ
{0, 1}; ğ‘£ğ‘–are logical variables. These logic gates use the logical operators âˆ§, âˆ¨, Â¬
and transform input signals into output signals. Figure 10.3 shows the elementary
logic gates and their corresponding truth tables.
We see in Figure 10.3 that the OR-gate is based on the functionality of the
operator âˆ¨. That means, the output signal of the OR-gate equals 1 as soon as one
of its input signals is 1.
The output signal of the AND-gate equals 1 if and only if all input signals
equal 1. As soon as one input signal equals 0, the value of the Boolean function
computed by this gate is 0.
The NOT-gate computes the logical negation of the input signal. If the input
signal is 1, the NOT-gate gives 0, and vice versa.
10.5 Sum, product, and Binomial coefficients
For a given set ğ´= {ğ‘1, . . . , ğ‘ğ‘›}, the sum and product of its components can be
conveniently summarized by the sum operation (âˆ‘ï¸€) and the product operation (âˆï¸€).

158
|
10 Mathematics as a language for science
Figure 10.3: Elementary logic gates of Boolean functions and their corresponding truth table.
The top symbol corresponds to the IEC, and the bottom to the US standard symbols.
Sum
The sum, âˆ‘ï¸€, for the numbers ğ‘ğ‘–involving the integer indices ğ‘–ğ‘™, ğ‘–ğ‘™+ 1 . . . , ğ‘–ğ‘¢âˆˆN is
defined by
ğ‘–ğ‘¢
âˆ‘ï¸
ğ‘–=ğ‘–ğ‘™
ğ‘ğ‘–= ğ‘ğ‘–ğ‘™+ ğ‘ğ‘–ğ‘™+1 + Â· Â· Â· + ğ‘ğ‘–ğ‘¢.
(10.39)
Here the index â€œlâ€ indicates â€œlowerâ€ whereas â€œuâ€ indicates â€œupperâ€, and they are
used to denote the start and end of the sequence of indices. For ğ‘–ğ‘™= 1, and ğ‘–ğ‘¢= ğ‘›,
we obtain the sum over all elements of ğ´, âˆ‘ï¸€ğ‘›
ğ‘–=1 ğ‘ğ‘–= ğ‘1 +Â· Â· Â·+ğ‘ğ‘›. Alternatively, the
sum can also be written using a different notation for the index of the sum symbol,
namely
âˆ‘ï¸
ğ‘–âˆˆ{ğ‘–ğ‘™,ğ‘–ğ‘™+1,...,ğ‘–ğ‘¢}
ğ‘ğ‘–= ğ‘ğ‘–ğ‘™+ ğ‘ğ‘–ğ‘™+1 + Â· Â· Â· + ğ‘ğ‘–ğ‘¢.
(10.40)
The latter form is more convenient when the summation concerned a subset of the
indices. For instance, suppose that ğ¼= {2, 4, 5} is a subset containing the desired
indices for the summation then
âˆ‘ï¸
ğ‘–âˆˆğ¼
ğ‘ğ‘–=
âˆ‘ï¸
ğ‘–âˆˆ{2,4,5}
ğ‘ğ‘–= ğ‘2 + ğ‘4 + ğ‘5.
(10.41)

10.5 Sum, product, and Binomial coefficients
|
159
Product
Similar to the sum, the product, âˆï¸€, for the numbers ğ‘ğ‘–involving the integer indices
ğ‘–ğ‘™, ğ‘–ğ‘™+ 1 . . . , ğ‘–ğ‘¢âˆˆN is defined as follows.
ğ‘–ğ‘¢
âˆï¸
ğ‘–=ğ‘–ğ‘™
ğ‘ğ‘–= ğ‘ğ‘–ğ‘™Â· ğ‘ğ‘–ğ‘™+1 Â· Â· Â· Â· Â· ğ‘ğ‘–ğ‘¢;
(10.42)
âˆï¸
ğ‘–âˆˆ{ğ‘–ğ‘™,ğ‘–ğ‘™+1...,ğ‘–ğ‘¢}
ğ‘ğ‘–= ğ‘ğ‘–ğ‘™Â· ğ‘ğ‘–ğ‘™+1 Â· Â· Â· Â· Â· ğ‘ğ‘–ğ‘¢.
(10.43)
Remark 10.5.1. In the above discussions of the sum and product, we assumed inte-
ger indices for the identification of the numbers ğ‘ğ‘–, i. e., ğ‘–âˆˆN. However, we would
like to remark that, in principle, this can be generalized to arbitrary â€œlabelsâ€. For
instance, for the set ğ´= {ğ‘â–³, ğ‘âˆ˜, ğ‘âŠ—}, we can define the sum and product over its
elements as
âˆ‘ï¸
ğ‘–âˆˆ{â–³,âˆ˜,âŠ—}
ğ‘ğ‘–= ğ‘â–³+ ğ‘âˆ˜+ ğ‘âŠ—;
(10.44)
âˆï¸
ğ‘–âˆˆ{â–³,âˆ˜,âŠ—}
ğ‘ğ‘–= ğ‘â–³Â· ğ‘âˆ˜Â· ğ‘âŠ—.
(10.45)
Hence, from a mathematical point of view, the nature of the indices is flexible.
However, whenever we implement a sum or a product with a programming language,
integer values for the indices are advantageous, because, e. g., the indexing of vectors
or matrices is accomplished via integer indices.
In R, the most flexible way to realize sums and products is via loops. However,
if one just wants a sum or a product over all elements in a vector ğ´, from ğ‘–ğ‘™= 1 to
ğ‘–ğ‘¢= ğ‘, one can use the following commands:
Listing 10.3: Sum and product
sum(A)
# sum of all elements in vector A
prod(A)
# product of all elements in vector A
Binomial coefficients
For all natural numbers ğ‘˜, ğ‘›âˆˆN with 0 â‰¤ğ‘˜â‰¤ğ‘›, the binomial coefficient, denoted
ğ¶(ğ‘›, ğ‘˜), is defined by
ğ¶(ğ‘›, ğ‘˜) =
(ï¸‚ğ‘›
ğ‘˜
)ï¸‚
=
ğ‘›!
ğ‘˜!(ğ‘›âˆ’ğ‘˜)!.
(10.46)
It is interesting to note that a binomial coefficient is a natural number itself, i. e.,
ğ¶(ğ‘›, ğ‘˜) âˆˆN.

160
|
10 Mathematics as a language for science
Figure 10.4: Visualization of the meaning of the Binomial coefficient ğ¶(4, 2).
For the definition of a binomial coefficient, the factorial of a natural number, denoted
by the symbol â€œ!â€, is used. The factorial of an natural number ğ‘›is just the product
of the numbers from 1 to ğ‘›, i. e.,
ğ‘›! =
ğ‘›
âˆï¸
ğ‘–=1
ğ‘–= 1 Â· 2 Â· Â· Â· Â· Â· ğ‘›.
(10.47)
The binomial coefficient has the combinatorial meaning that from ğ‘›objects, there
are ğ¶(ğ‘›, ğ‘˜) ways to select ğ‘˜objects without considering the order in which the
objects have been selected. In Figure 10.4, we show an urn with ğ‘›= 4 objects. From
this urn, we can draw ğ‘˜= 2 objects in 6 different ways.
Also, the factorial ğ‘›! has a combinatorial meaning. It gives the number of dif-
ferent arrangements of ğ‘›objects by considering the order. For instance, the objects
{1, 2, 3} can be arranged in 3! = 6 different ways:
(1, 2, 3) âˆ’(1, 3, 2) âˆ’(2, 3, 1) âˆ’(2, 1, 3) âˆ’(3, 1, 2) âˆ’(3, 2, 1).
(10.48)
Listing 10.4: Factorial and Binomial coefficients
factorial(k)
# factorial of the natural number k
choose(n, k)
# binomical coefficient ğ¶(ğ‘›, ğ‘˜)
Properties of Binomial coefficients
The binomial coefficients have interesting properties. Some of these are listed below.
ğ¶(ğ‘›, 0) =
(ï¸‚ğ‘›
0
)ï¸‚
= 1,
(10.49)
ğ¶(ğ‘›, ğ‘›) =
(ï¸‚ğ‘›
ğ‘›
)ï¸‚
= 1,
(10.50)
(ï¸‚ğ‘›
ğ‘˜
)ï¸‚
=
(ï¸‚
ğ‘›
ğ‘›âˆ’ğ‘˜
)ï¸‚
,
(10.51)
âˆ€ğ‘›âˆˆN, and 0 â‰¤ğ‘˜â‰¤ğ‘›.

10.6 Further symbols
|
161
Figure 10.5: Pascalâ€™s triangle for Binomial coefficients. Visualized is the recurrence relation for
Binomial coefficients in equation (10.52).
The following recurrence relation for binomial coefficients is called Pascalâ€™s rule:
(ï¸‚ğ‘›+ 1
ğ‘˜+ 1
)ï¸‚
=
(ï¸‚ğ‘›
ğ‘˜
)ï¸‚
+
(ï¸‚
ğ‘›
ğ‘˜+ 1
)ï¸‚
.
(10.52)
In Figure 10.5, we visualize the result of Pascalâ€™s rule for ğ‘›âˆˆ{0, . . . , 6}. The resulting
object is called Pascalâ€™s triangle.
10.6 Further symbols
Let us again assume we have a given set ğ´= {ğ‘1, . . . , ğ‘ğ‘›}, where its elements ğ‘ğ‘–are
numbers.
Minimum and maximum
The minimum and the maximum of the set ğ´are defined by
ğ‘*
min =
min
ğ‘–=1,...,ğ‘›{ğ´} = {ğ‘ğ‘–| ğ‘ğ‘–âˆˆğ´and ğ‘ğ‘–â‰¤ğ‘ğ‘—âˆ€ğ‘—Ì¸= ğ‘–};
(10.53)
ğ‘*
max =
max
ğ‘–=1,...,ğ‘›{ğ´} = {ğ‘ğ‘–| ğ‘ğ‘–âˆˆğ´and ğ‘ğ‘–â‰¥ğ‘ğ‘—âˆ€ğ‘—Ì¸= ğ‘–}.
(10.54)
If there is more than one element that is minimum or maximum, then the corre-
sponding sets ğ‘*
min and ğ‘*
max contain more than one element.

162
|
10 Mathematics as a language for science
Argmin and Argmax
There are two related functions to the minimum and maximum that return the
indices of the minimal/maximal elements instead of their values:
ğ‘–*
min = argmin
ğ‘–=1,...,ğ‘›
{ğ´} = {ğ‘–| ğ‘ğ‘–âˆˆğ´and ğ‘ğ‘–â‰¤ğ‘ğ‘—âˆ€ğ‘—Ì¸= ğ‘–};
(10.55)
ğ‘–*
max = argmax
ğ‘–=1,...,ğ‘›
{ğ´} = {ğ‘–| ğ‘ğ‘–âˆˆğ´and ğ‘ğ‘–â‰¥ğ‘ğ‘—âˆ€ğ‘—Ì¸= ğ‘–}.
(10.56)
Logical statements
A logical statement may be defined verbally or mathematically, and take one of the
values true or false. For simplicity, we define the Boolean value 1 for true, and 0 for
false. One can show that the set {true, false} is isomorphic to the set {0, 1}.
The Boolean value of the statement â€œThe next autumn comes for sureâ€ equals
1 and, hence, the statement is true. From a probabilistic point of view, this event is
certain and its probability equals one. Therefore, we may conclude that this state-
ment does not contain any information, see also [169]. The following inequalities and
equations
ğ‘–= âˆ’5,
(10.57)
100 = 50 + 20 + 30,
(10.58)
âˆ’1 â‰¥5,
(10.59)
1 < 2,
(10.60)
ğ‘›
âˆ‘ï¸
ğ‘—=1
ğ‘—= ğ‘›(ğ‘›+ 1)
2
,
ğ‘›âˆˆN,
(10.61)
are mathematical statements, which are true or false. The first equation is false, as
ğ‘–= âˆšâˆ’1, where ğ‘–is the imaginary unit of a complex number ğ‘§= ğ‘+ ğ‘–ğ‘. The second
equation is obviously true, as 50 + 20 + 30 equals 100. For the third statement, a
negative number cannot be greater or equal than a positive number and its Boolean
value is therefore false. The fourth statement represents an inequality too, and is
true. Strictly speaking, the fifth equation is a statement form (Sf) over the natural
numbers, as it contains the variable ğ‘›âˆˆN.
In general, statement forms contain variables and are true or false. In case of
equation (10.61), we can write âŸ¨Sf(ğ‘›)âŸ©= âŸ¨âˆ‘ï¸€ğ‘›
ğ‘—=1 ğ‘—= ğ‘›(ğ‘›+1)
2
âŸ©. This statement form is
true for all ğ‘›âˆˆN and can be proven by induction. Another example of a statement
form is
âŸ¨ï¸€
Sf(ğ‘¥)âŸ©ï¸€
= âŸ¨ğ‘¥+ 5 = 15âŸ©> .
(10.62)
For ğ‘¥= 10, âŸ¨Sf(ğ‘¥)âŸ©is true. For ğ‘¥Ì¸= 10, âŸ¨Sf(ğ‘¥)âŸ©is false.

10.6 Further symbols
|
163
Generally, we can see that the statement changes if the variable of the statement
form (Sf) changes. Once we define statements (or statement forms), they can be
combined by using logical operations. We demonstrate these operations by first
assuming that ğ‘†1 and ğ‘†2 are logical statements. The statement ğ‘†1 âˆ§ğ‘†2 means that
ğ‘†1 and ğ‘†2 hold. This statement may have the value true or false, see Figure 10.3.
For instance, ğ‘†1 := 2 + 2 = 4 âˆ§ğ‘†2 := 3 + 3 = 6 is true, but ğ‘†1 := 2 + 2 =
4 âˆ§ğ‘†3 := 3 + 3 = 9 is false. Similarly, ğ‘†1 âˆ¨ğ‘†2 means that ğ‘†1 or ğ‘†2 holds. Here,
ğ‘†1 := 2 + 2 = 4 âˆ¨ğ‘†2 = 3 + 3 = 6 is true, but ğ‘†1 := 2 + 2 = 4 âˆ¨ğ‘†3 := 3 + 3 = 9 is
true as well. The logical negation of the statement ğ‘†is usually denoted by Â¬ğ‘†. The
well-known triangle equation,
|ğ‘¥1 + ğ‘¥2| â‰¤|ğ‘¥1| + |ğ‘¥2|,
ğ‘¥1, ğ‘£2 âˆˆR,
(10.63)
holds true, but not
Â¬(|ğ‘¥1 + ğ‘¥2| â‰¤|ğ‘¥1| + |ğ‘¥2|).
(10.64)
This means
|ğ‘¥1 + ğ‘¥2| > |ğ‘¥1| + |ğ‘¥2|
(10.65)
is generally false.
Statement: â‡’
The logical implication ğ‘†1 =â‡’ğ‘†2 means that ğ‘†1 implies ğ‘†2. Verbally, one can say
ğ‘†1 â€œlogically impliesâ€ ğ‘†2, or if ğ‘†1 holds, then follows ğ‘†2.
Statement â‡”
The statement ğ‘†1 â‡â‡’ğ‘†2 is stronger, because ğ‘†1 holds if and only if ğ‘†2 holds.
For the above statements, it is important to note that to go from the left state-
ment to the right one, or vice versa, one needs to apply logical operators (Â¬, âˆ§, âˆ¨)
or algebraic operations (+, âˆ’, /, etc.). For instance, by assuming the true statement
ğ‘›2 â‰¥2ğ‘›, ğ‘›> 1, we obtain the implications
ğ‘›2 â‰¥2ğ‘›=â‡’ğ‘›2 âˆ’2ğ‘›â‰¥0 =â‡’ğ‘›2 âˆ’2ğ‘›+ 1 = (ğ‘›âˆ’1)2 â‰¥0.
(10.66)
Finally, we want to remark that a false statement may imply a true statement; ğ‘–2 = 1
(false as ğ‘–2 = âˆ’1) implies 0 Â· ğ‘–2 = 0 Â· 1 (true).

164
|
10 Mathematics as a language for science
10.7 Importance of definitions and theorems
In order to develop and formulate precise mathematical concepts and ideas, we need
a concise language. For instance, if we want to define a mathematical term, we
first need to understand what a mathematical definition is. In general, a definition
is a concept formation of a mathematical term that is (possibly) based on other
(mathematical) terms, which are either immediately clear or which have already
been defined. Put simply, a definition is used to give a precise meaning to a new term.
It is important not to confuse a definition with a theorem. As mentioned above,
a definition is just a concept formation, and not a statement and, therefore, it cannot
be proven, but it is assumed to be true. In contrast, a theorem is a mathematical
statement that needs to be proven by using other statements. In the following, we
give some examples of definitions:
Definition 10.7.1. Let ğ‘, ğ‘âˆˆR. The sum of these two real numbers are defined by
sum(ğ‘, ğ‘) := ğ‘+ ğ‘.
(10.67)
Definition 10.7.1 defines the sum of two real numbers based on the trivial defi-
nition of the symbol â€œ+â€.
Definition 10.7.2. Let ğ‘, ğ‘âˆˆR. The function ğ‘“ğ¿: R âˆ’â†’R, given by
ğ‘“ğ¿(ğ‘¥) := ğ‘ğ‘¥+ ğ‘,
(10.68)
defines a linear function or a linear mapping.
The next statement can be formulated as a theorem based on the previous
definition.
Theorem 10.7.1. The unique solution of the equation
ğ‘“ğ¿(ğ‘¥) = 0
(10.69)
is given by ğ‘¥= âˆ’ğ‘
ğ‘.
The proof of Theorem 10.7.1 is very simple, as ğ‘“ğ¿(ğ‘¥) := ğ‘ğ‘¥+ğ‘= 0 leads directly
to ğ‘¥= âˆ’ğ‘
ğ‘by performing elementary calculations. Specifically, the first elementary
calculation is subtracting ğ‘from ğ‘ğ‘¥+ğ‘= 0. Second, we divide the resulting equation
by ğ‘and obtain the result.
Another example is the famous binomial theorem.
Theorem 10.7.2. Let ğ‘, ğ‘âˆˆR and ğ‘›â‰¥1. Then,
(ğ‘+ ğ‘)ğ‘›=
ğ‘›
âˆ‘ï¸
ğ‘˜=1
(ï¸‚ğ‘›
ğ‘˜
)ï¸‚
ğ‘ğ‘›âˆ’ğ‘˜ğ‘ğ‘˜.
(10.70)

10.8 Summary
|
165
Theorem 10.7.2 can be proven by induction over ğ‘›.
Sometimes, one uses the term lemma instead of theorem. Also a lemma is a
statement that needs to be proven, however, it is not as important as a theorem.
An example of an important theorem is the well-known fundamental theorem of
Algebra [127], stating that any complex-valued polynomial with degree ğ‘›has exactly
ğ‘›zeros. To give a function-theoretic proof, one needs several lemmas to conclude
this theorem, see, e. g., [49].
10.8 Summary
In general, the mathematical language is meant to help with the precise formulation
of problems. If one is new to the field, such formulations can be intimidating at first,
and verbal formulations may appear as sufficient. However, with a bit of practice one
realizes quickly that this is not the case, and one starts to appreciate and to benefit
from the power of mathematical symbols. Importantly, the mathematical language
has a profound implication on the general mathematical thinking capabilities, which
translate directly to analytical problem-solving strategies. The latter skills are key
for working successfully on data science projects, e. g., in business analytics, because
the process of analyzing data requires a full comprehension of all involved aspects,
and the often abstract relationships.

