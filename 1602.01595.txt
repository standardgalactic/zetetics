Many Languages, One Parser
Waleed Ammar♦George Mulcaire♥Miguel Ballesteros♠♦Chris Dyer♦Noah A. Smith♥
♦School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA
♥Computer Science & Engineering, University of Washington, Seattle, WA, USA
♠NLP Group, Pompeu Fabra University, Barcelona, Spain
wammar@cs.cmu.edu, gmulc@uw.edu, miguel.ballesteros@upf.edu
cdyer@cs.cmu.edu, nasmith@cs.washington.edu
Abstract
We train one multilingual model for depen-
dency parsing and use it to parse sentences
in several languages.
The parsing model
uses (i) multilingual word clusters and em-
beddings; (ii) token-level language informa-
tion; and (iii) language-speciﬁc features (ﬁne-
grained POS tags). This input representation
enables the parser not only to parse effec-
tively in multiple languages, but also to gener-
alize across languages based on linguistic uni-
versals and typological similarities, making it
more effective to learn from limited annota-
tions. Our parser’s performance compares fa-
vorably to strong baselines in a range of data
scenarios, including when the target language
has a large treebank, a small treebank, or no
treebank for training.
1
Introduction
Developing tools for processing many languages
has long been an important goal in NLP (Rösner,
1988; Heid and Raab, 1989),1 but it was only when
statistical methods became standard that massively
multilingual NLP became economical. The main-
stream approach for multilingual NLP is to design
language-speciﬁc models. For each language of in-
terest, the resources necessary for training the model
are obtained (or created), and separate parameters
are ﬁt for each language separately. This approach
is simple and grants the ﬂexibility of customizing
1As of 2007, the total number of native speakers of the
hundred most popular languages only accounts for 85% of the
world’s population (Wikipedia, 2016).
the model and features to the needs of each lan-
guage, but it is suboptimal for theoretical and prac-
tical reasons. Theoretically, the study of linguistic
typology tells us that many languages share mor-
phological, phonological, and syntactic phenomena
(Bender, 2011); therefore, the mainstream approach
misses an opportunity to exploit relevant supervi-
sion from typologically related languages. Practi-
cally, it is inconvenient to deploy or distribute NLP
tools that are customized for many different lan-
guages because, for each language of interest, we
need to conﬁgure, train, tune, monitor, and occasion-
ally update the model. Furthermore, code-switching
or code-mixing (mixing more than one language in
the same discourse), which is pervasive in some gen-
res, in particular social media, presents a challenge
for monolingually-trained NLP models (Barman et
al., 2014).2
In parsing, the availability of homogeneous syn-
tactic dependency annotations in many languages
(McDonald et al., 2013; Nivre et al., 2015b; Agi´c
et al., 2015; Nivre et al., 2015a) has created an
opportunity to develop a parser that is capable of
parsing sentences in multiple languages, address-
ing these theoretical and practical concerns.3
A
multilingual parser can potentially replace an array
of language-speciﬁc monolingually-trained parsers
2While our parser can be used to parse input with code-
switching, we have not evaluated this capability due to the lack
of appropriate data.
3Although multilingual dependency treebanks have been
available for a decade via the 2006 and 2007 CoNLL shared
tasks (Buchholz and Marsi, 2006; Nivre et al., 2007), the tree-
bank of each language was annotated independently and with
its own annotation conventions.
arXiv:1602.01595v4  [cs.CL]  26 Jul 2016

(for languages with a large treebank).
The same
approach has been used in low-resource scenarios
(with no treebank or a small treebank in the target
language), where indirect supervision from auxiliary
languages improves the parsing quality (Cohen et
al., 2011; McDonald et al., 2011; Zhang and Barzi-
lay, 2015; Duong et al., 2015a; Duong et al., 2015b;
Guo et al., 2016), but these models may sacriﬁce ac-
curacy on source languages with a large treebank. In
this paper, we describe a model that works well for
both low-resource and high-resource scenarios.
We propose a parsing architecture that takes as in-
put sentences in several languages,4 optionally pre-
dicting the part-of-speech (POS) tags and input lan-
guage. The parser is trained on the union of avail-
able universal dependency annotations in different
languages. Our approach integrates and critically
relies on several recent developments related to de-
pendency parsing: universal POS tagsets (Petrov et
al., 2012), cross-lingual word clusters (Täckström et
al., 2012), selective sharing (Naseem et al., 2012),
universal dependency annotations (McDonald et al.,
2013; Nivre et al., 2015b; Agi´c et al., 2015; Nivre
et al., 2015a), advances in neural network architec-
tures (Chen and Manning, 2014; Dyer et al., 2015),
and multilingual word embeddings (Gardner et al.,
2015; Guo et al., 2016; Ammar et al., 2016). We
show that our parser compares favorably to strong
baselines trained on the same treebanks in three data
scenarios: when the target language has a large tree-
bank (Table 3), a small treebank (Table 7), or no
treebank (Table 8). Our parser is publicly available.5
2
Overview
Our goal is to train a dependency parser for a set
of target languages Lt, given universal dependency
annotations in a set of source languages Ls. Ide-
ally, we would like to have training data in all tar-
get languages (i.e., Lt ⊆Ls), but we are also inter-
ested in the case where the sets of source and target
languages are disjoint (i.e., Lt ∩Ls = ∅). When
all languages in Lt have a large treebank, the main-
stream approach has been to train one monolingual
parser per target language and route sentences of a
4We discuss data requirements in the next section.
5https://github.com/clab/
language-universal-parser
given language to the corresponding parser at test
time. In contrast, our approach is to train one pars-
ing model with the union of treebanks in Ls, then
use this single trained model to parse text in any lan-
guage in Lt, hence the name “Many Languages, One
Parser” (MALOPA). MALOPA strikes a balance be-
tween: (1) enabling cross-lingual model transfer via
language-invariant input representations; i.e., coarse
POS tags, multilingual word embeddings and mul-
tilingual word clusters, and (2) tweaking the be-
havior of the parser depending on the current input
language via language-speciﬁc representations; i.e.,
ﬁne-grained POS tags and language embeddings.
In addition to universal dependency annotations
in source languages (see Table 1), we use the follow-
ing data resources for each language in L = Lt∪Ls:
• universal POS annotations for training a POS tag-
ger,6
• a bilingual dictionary with another language in L
for adding cross-lingual lexical information,7
• language typology information,8
• language-speciﬁc POS annotations,9 and
• a monolingual corpus.10
Novel contributions of this paper include: (i) us-
ing one parser instead of an array of monolingually-
trained parsers without sacriﬁcing accuracy on lan-
guages with a large treebank, (ii) an effective neural
network architecture for using language embeddings
to improve multilingual parsing, and (iii) a study
of how automatic language identiﬁcation affects the
performance of a multilingual dependency parser.
While not the primary focus of this paper, we also
show that a variant of our parser outperforms pre-
vious work on multi-source cross-lingual parsing in
6See §3.6 for details.
7Our best results make use of this resource. We require that
all languages in L are (transitively) connected. The bilingual
dictionaries we used are based on unsupervised word align-
ments of parallel corpora, as described in Guo et al. (2016).
See §3.3 for details.
8See §3.4 for details.
9Our best results make use of this resource. See §3.5 for
details.
10This is only used for training word embeddings with ‘mul-
tiCCA,’ ‘multiCluster’ and ‘translation-invariance’ methods in
Table 6. We do not use this resource when we compare to pre-
vious work.

German (de)
English (en)
Spanish (es)
French (fr)
Italian (it)
Portuguese (pt)
Swedish (sv)
UDT 2
train
14118 (264906)
39832 (950028)
14138 (375180)
14511 (351233)
6389 (149145)
9600 (239012)
4447 (66631)
dev.
801 (12215)
1703 (40117)
1579 (40950)
1620 (38328)
399 (9541)
1211 (29873)
493 (9312)
test
1001 (16339)
2416 (56684)
300 (8295)
300 (6950)
400 (9187)
1205 (29438)
1219 (20376)
UD 1.2
train
14118 (269626)
12543 (204586)
14187 (382436)
14552 (355811)
11699 (249307)
8800 (201845)
4303 (66645)
dev.
799 (12512)
2002 (25148)
1552 (41975)
1596 (39869)
489 (11656)
271 (4833)
504 (9797)
test
977 (16537)
2077 (25096)
274 (8128)
298 (7210)
489 (11719)
288 (5867)
1219 (20377)
tags
-
50
-
-
36
866
134
Table 1: Number of sentences (tokens) in each treebank split in Universal Dependency Treebanks (UDT)
version 2.0 and Universal Dependencies version (UD) 1.2 for the languages we experiment with. The last
row gives the number of unique language-speciﬁc ﬁne-grained POS tags used in a treebank.
low resource scenarios, where languages in Lt have
a small treebank (see Table 7) or where Lt ∩Ls = ∅
(see Table 8). In the small treebank setup with 3,000
token annotations, we show that our parser consis-
tently outperforms a strong monolingual baseline
with 5.7 absolute LAS (labeled attachment score)
points per language, on average.
3
Parsing Model
Recent advances suggest that recurrent neural net-
works, especially long short-term memory (LSTM)
architectures, are capable of learning useful repre-
sentations for modeling problems of sequential na-
ture (Graves et al., 2013; Sutskever et al., 2014).
In this section, we describe our language-universal
parser, which extends the stack LSTM (S-LSTM)
parser of Dyer et al. (2015).
3.1
Transition-based Parsing with S-LSTMs
This section brieﬂy reviews Dyer et al.’s S-LSTM
parser, which we modify in the following sections.
The core parser can be understood as the sequential
manipulation of three data structures:
• a buffer (from which we read the token sequence),
• a stack (which contains partially-built parse trees),
and
• a list of actions previously taken by the parser.
The parser uses the arc-standard transition system
(Nivre, 2004).11 At each timestep t, a transition ac-
tion is applied that alters these data structures ac-
cording to Table 2.
11In a preprocessing step, we transform nonprojective trees
in the training treebanks to pseudo-projective trees using the
“baseline” scheme in (Nivre and Nilsson, 2005). We evaluate
against the original nonprojective test set.
Along with the discrete transitions of the arc-
standard system, the parser computes vector repre-
sentations for the buffer, stack and list of actions at
time step t denoted bt, st, and at, respectively.12
The parser state at time t is given by:
pt = max {0, W[st; bt; at] + Wbias}
(1)
where the matrix W and the vector Wbias are
learned parameters. The matrix W is multiplied by
the vector [st; bt; at] created by the concatenation of
st, bt, at. The parser state pt is then used to deﬁne
a categorical distribution over possible next actions
z:13
p(z | pt) =
exp
 g⊤
z pt + qz

P
z′ exp
 g⊤
z′pt + qz′
(2)
where gz and qz are parameters associated with ac-
tion z. The selected action is then used to update
the buffer, stack and list of actions, and to compute
bt+1, st+1 and at+1 accordingly.
The model is trained to maximize the log-
likelihood of correct actions. At test time, the parser
greedily chooses the most probable action in every
time step until a complete parse tree is produced.
The following sections describe our extensions of
the core parser. More details about the core parser
can be found in Dyer et al. (2015).
3.2
Token Representations
The vector representations of input tokens feed into
the stack-LSTM modules of the buffer and the stack.
12A stack-LSTM module is used to compute the vector rep-
resentation for each data structure, as detailed in Dyer et al.
(2015).
13The total number of actions is 1+2× the number of unique
dependency labels in the treebank used for training, but we only
consider actions which meet the arc-standard preconditions in
Fig. 2.

Stackt
Buffert
Action
Dependency
Stackt+1
Buffert+1
u, v, S
B
REDUCE-RIGHT(r)
u
r→v
u, S
B
u, v, S
B
REDUCE-LEFT(r)
u
r←v
v, S
B
S
u, B
SHIFT
—
u, S
B
Table 2: Parser transitions indicating the action applied to the stack and buffer at time t and the resulting
stack and buffer at time t + 1.
For monolingual parsing, we represent each token
by concatenating the following vectors:
• a ﬁxed, pretrained embedding of the word type,
• a learned embedding of the word type,
• a learned embedding of the Brown cluster,
• a learned embedding of the ﬁne-grained POS tag,
• a learned embedding of the coarse POS tag.
For multilingual parsing with MALOPA, we start
with a simple delexicalized model where the token
representation only consists of learned embeddings
of coarse POS tags, which are shared across all lan-
guages to enable model transfer. In the following
subsections, we enhance the token representation in
MALOPA to include lexical embeddings, language
embeddings, and ﬁne-grained POS embeddings.
3.3
Lexical Embeddings
Previous work has shown that sacriﬁcing lexical fea-
tures amounts to a substantial decrease in the perfor-
mance of a dependency parser (Cohen et al., 2011;
Täckström et al., 2012; Tiedemann, 2015; Guo et al.,
2015). Therefore, we extend the token representa-
tion in MALOPA by concatenating learned embed-
dings of multilingual word clusters, and pretrained
multilingual embeddings of word types.
Multilingual Brown clusters.
Before training the
parser, we estimate Brown clusters of English words
and project them via word alignments to words in
other languages. This is similar to the ‘projected
clusters’ method in Täckström et al. (2012). To go
from Brown clusters to embeddings, we ignore the
hierarchy within Brown clusters and assign a unique
parameter vector to each cluster.
Multilingual word embeddings.
We also use
Guo et al.’s (2016) ‘robust projection’ method to pre-
train multilingual word embeddings. The ﬁrst step
in ‘robust projection’ is to learn embeddings for En-
glish words using the skip-gram model (Mikolov et
al., 2013). Then, we compute an embedding of non-
English words as the weighted average of English
word embeddings, using word alignment probabili-
ties as weights. The last step computes an embed-
ding of non-English words which are not aligned to
any English words by averaging the embeddings of
all words within an edit distance of 1 in the same
language. We experiment with two other methods—
‘multiCCA’ and ‘multiCluster,’ both proposed by
Ammar et al. (2016)—for pretraining multilingual
word embeddings in §4.1. ‘MultiCCA’ uses a lin-
ear operator to project pretrained monolingual em-
beddings in each language (except English) to the
vector space of pretrained English word embed-
dings, while ‘multiCluster’ uses the same embed-
ding for translationally-equivalent words in different
languages. The results in Table 6 illustrate that the
three methods perform similarly on this task.
3.4
Language Embeddings
While many languages, especially ones that belong
to the same family, exhibit some similar syntac-
tic phenomena (e.g., all languages have subjects,
verbs, and objects), substantial syntactic differences
abound. Some of these differences are easy to char-
acterize (e.g., subject-verb-object vs. verb-subject-
object, prepositions vs. postpositions, adjective-
noun vs. noun-adjective), while others are sub-
tle (e.g., number and positions of negation mor-
phemes). It is not at all clear how to translate de-
scriptive facts about a language’s syntax into fea-
tures for a parser.
Consequently,
training
a
language-universal
parser on treebanks in multiple source languages
requires caution.
While exposing the parser to a
diverse set of syntactic patterns across many lan-
guages has the potential to improve its performance

in each, dependency annotations in one language
will, in some ways, contradict those in typologically
different languages.
For instance, consider a context where the next
word on the buffer is a noun, and the top word on
the stack is an adjective, followed by a noun. Tree-
banks of languages where postpositive adjectives
are typical (e.g., French) will often teach the parser
to predict REDUCE-LEFT, while those of languages
where prepositive adjectives are more typical (e.g.,
English) will teach the parser to predict SHIFT.
Inspired by Naseem et al. (2012), we address this
problem by informing the parser about the input lan-
guage it is currently parsing. Let l be the input vector
representation of a particular language. We consider
three deﬁnitions for l:14
• one-hot encoding of the language ID,
• one-hot encoding of individual word-order prop-
erties,15 and
• averaged one-hot encoding of WALS typological
properties (including word-order properties).16
It is worth noting that the ﬁrst deﬁnition (language
ID) turns out to work best in our experiments.
We use a hidden layer with tanh nonlinearity to
compute the language embedding l′ as:
l′ = tanh(Ll + Lbias)
where the matrix L and the vector Lbias are addi-
tional model parameters. We modify the parsing ar-
chitecture as follows:
• include l′ in the token representation (which feeds
into the stack-LSTM modules of the buffer and
the stack as described in §3.1),
14The
ﬁles
which
contain
these
deﬁnitions
are
available
at
https://github.com/clab/
language-universal-parser/tree/master/
typological_properties.
15The World Atlas of Language Structures (WALS; Dryer
and Haspelmath, 2013) is an online portal documenting typo-
logical properties of 2,679 languages (as of July 2015). We
use the same set of WALS features used by Zhang and Barzilay
(2015), namely 82A (order of subject and verb), 83A (order of
object and verb), 85A (order of adposition and noun phrase),
86A (order of genitive and noun), and 87A (order of adjective
and noun).
16Some WALS features are not annotated for all languages.
Therefore, we use the average value of all languages in the same
genus. We rescale all values to be in the range [−1, 1].
• include l′ in the action vector representation
(which feeds into the stack-LSTM module that
represents previous actions as described in §3.1),
and
• redeﬁne the parser state at time t as pt
=
max {0, W[st; bt; at; l′] + Wbias}.
Intuitively, the ﬁrst two modiﬁcations allow the
input language to inﬂuence the vector representation
of the stack, the buffer and the list of actions. The
third modiﬁcation allows the input language to in-
ﬂuence the parser state which in turn is used to pre-
dict the next action. In preliminary experiments, we
found that adding the language embeddings at the
token and action level is important. We also experi-
mented with computing more complex functions of
(st, bt, at, l′) to deﬁne the parser state, but they did
not help.
3.5
Fine-grained POS Tag Embeddings
Tiedemann (2015) shows that omitting ﬁne-grained
POS tags signiﬁcantly hurts the performance of a de-
pendency parser. However, those ﬁne-grained POS
tagsets are deﬁned monolingually and are only avail-
able for a subset of the languages with universal de-
pendency treebanks.
We extend the token representation to include
a ﬁne-grained POS embedding (in addition to the
coarse POS embedding). We stochastically dropout
the ﬁne-grained POS embedding for each token with
50% probability (Srivastava et al., 2014) so that the
parser can make use of ﬁne-grained POS tags when
available but stay reliable when the ﬁne-grained
POS tags are missing.
3.6
Predicting POS Tags
The model discussed thus far conditions on the POS
tags of words in the input sentence. However, gold
POS tags may not be available in real applications
(e.g., parsing the web). Here, we describe two mod-
iﬁcations to (i) model both POS tagging and depen-
dency parsing, and (ii) increase the robustness of the
parser to incorrect POS predictions.
Tagging
model.
Let
x1, . . . , xn,
y1, . . . , yn,
z1, . . . , z2n be the sequence of words, POS tags,
and parsing actions, respectively, for a sentence of
length n. We deﬁne the joint distribution of a POS

tag sequence and parsing actions given a sequence
of words as follows:
p(y1, . . . , yn, z1, . . . , z2n | x1, . . . , xn) =
n
Y
i=1
p(yi | x1, . . . , xn)
×
2n
Y
j=1
p(zj | x1, . . . , xn, y1, . . . , yn, z1, . . . , zj−1)
where p(zj | . . .) is deﬁned in Eq. 2, and p(yi |
x1, . . . , xn) uses a bidirectional LSTM (Graves et
al., 2013). Huang et al. (2015) show that the perfor-
mance of a bidirectional LSTM POS tagger is on par
with a conditional random ﬁeld tagger.
We use slightly different token representations for
tagging and parsing in the same model. For tag-
ging, we construct the token representation by con-
catenating the embeddings of the word type (pre-
trained), the Brown cluster and the input language.
This token representation feeds into the bidirectional
LSTM, followed by a softmax layer (at each posi-
tion) which deﬁnes a categorical distribution over
possible POS tags. For parsing, we construct the to-
ken representation by further concatenating the em-
beddings of predicted POS tags. This token repre-
sentation feeds into the stack-LSTM modules of the
buffer and stack components of the transition-based
parser. This multi-task learning setup enables us to
predict both POS tags and dependency trees in the
same model. We note that pretrained word embed-
dings, cluster embeddings and language embeddings
are shared for tagging and parsing.
Block dropout.
We use an independently devel-
oped variant of word dropout (Iyyer et al., 2015),
which we call block dropout. The token representa-
tion used for parsing includes the embedding of pre-
dicted POS tags, which may be incorrect. We intro-
duce another modiﬁcation which makes the parser
more robust to incorrect POS tag predictions, by
stochastically zeroing out the entire embedding of
the POS tag. While training the parser, we replace
the POS embedding vector e with another vector (of
the same dimensionality) stochastically computed
as: e′ = (1 −b)/µ × e, where b ∈{0, 1} is a
Bernoulli-distributed random variable with parame-
ter µ which is initialized to 1.0 (i.e., always dropout,
setting b = 1, e′ = 0), and is dynamically updated
to match the error rate of the POS tagger on the de-
velopment set. At test time, we never dropout the
predicted POS embedding, i.e., e′ = e. Intuitively,
this method extends the dropout method (Srivastava
et al., 2014) to address structured noise in the input
layer.
4
Experiments
In this section, we evaluate the MALOPA approach
in three data scenarios: when the target language has
a large treebank (Table 3), a small treebank (Table 7)
or no treebank (Table 8).
Data.
For experiments where the target language
has a large treebank, we use the standard data splits
for German (de), English (en), Spanish (es), French
(fr), Italian (it), Portuguese (pt) and Swedish (sv) in
the latest release (version 1.2) of Universal Depen-
dencies (Nivre et al., 2015a), and experiment with
both gold and predicted POS tags. For experiments
where the target language has no treebank, we use
the standard splits for these languages in the older
universal dependency treebanks v2.0 (McDonald et
al., 2013) and use gold POS tags, following the base-
lines (Zhang and Barzilay, 2015; Guo et al., 2016).
Table 1 gives the number of sentences and words
annotated for each language in both versions. In a
preprocessing step, we lowercase all tokens and re-
move multi-word annotations and language-speciﬁc
dependency relations. We use the same multilingual
Brown clusters and multilingual embeddings of Guo
et al. (2016), kindly provided by the authors.
Optimization.
We follow Dyer et al. (2015) in
parameter initialization and optimization.17
How-
ever, when training the parser on multiple languages
17We use stochastic gradient updates with an initial learn-
ing rate of η0 = 0.1 in epoch #0, update the learning rate
in following epochs as ηt = η0/(1 + 0.1t). We clip the ℓ2
norm of the gradient to avoid “exploding” gradients.
Unla-
beled attachment score (UAS) on the development set deter-
mines early stopping. Parameters are initialized with uniform
samples in ±
p
6/(r + c) where r and c are the sizes of the
previous and following layer in the nueral network (Glorot and
Bengio, 2010). The standard deviations of the labeled attach-
ment score (LAS) due to random initialization in individual tar-
get languages are 0.36 (de), 0.40 (en), 0.37 (es), 0.46 (fr), 0.47
(it), 0.41 (pt) and 0.24 (sv). The standard deviation of the aver-
age LAS scores across languages is 0.17.

LAS
target language
average
de
en
es
fr
it
pt
sv
monolingual
79.3
85.9
83.7
81.7
88.7
85.7
83.5
84.0
MALOPA
70.4
69.3
72.4
71.1
78.0
74.1
65.4
71.5
+lexical
76.7
82.0
82.7
81.2
87.6
82.1
81.2
81.9
+language ID
78.6
84.2
83.4
82.4
89.1
84.2
82.6
83.5
+ﬁne-grained POS
78.9
85.4
84.3
82.4
89.0
86.2
84.5
84.3
Table 3: Dependency parsing: labeled attachment scores (LAS) for monolingually-trained parsers and
MALOPA in the fully supervised scenario where Lt = Ls. Note that we use the universal dependencies
verson 1.2 which only includes annotations for ∼13,000 English sentences, which explains the relatively
low scores in English. When we instead use the universal dependency treebanks version 2.0 which includes
annotations for ∼40,000 English sentences (originally from the English Penn Treebank), we achieve UAS
score 93.0 and LAS score 91.5.
in MALOPA, instead of updating the parameters
with the gradient of individual sentences, we use
mini-batch updates which include one sentence sam-
pled uniformly (without replacement) from each
language’s treebank, until all sentences in the small-
est treebank are used (which concludes an epoch).
We repeat the same process in following epochs.
We found this to help prevent one source language
with a larger treebank (e.g., German) from dominat-
ing parameter updates at the expense of other source
languages with a smaller treebank (e.g., Swedish).
4.1
Target Languages with a Treebank
(Lt = Ls)
Here, we evaluate our MALOPA parser when the
target language has a treebank.
Baseline.
For each target language, the strong
baseline we use is a monolingually-trained S-LSTM
parser with a token representation which concate-
nates:
pretrained word embeddings (50 dimen-
sions),18 learned word embeddings (50 dimensions),
coarse (universal) POS tag embeddings (12 dimen-
sions), ﬁne-grained (language-speciﬁc, when avail-
able) POS tag embeddings (12 dimensions), and em-
beddings of Brown clusters (12 dimensions), and
uses a two-layer S-LSTM for each of the stack, the
buffer and the list of actions. We independently train
one baseline parser for each target language, and
share no model parameters. This baseline, denoted
18These embeddings are treated as ﬁxed inputs to the parser,
and are not optimized towards the parsing objective. We use the
same embeddings used in Guo et al. (2016).
‘monolingual’ in Tables 3 and 7, achieves UAS score
93.0 and LAS score 91.5 when trained on the En-
glish Penn Treebank, which is comparable to Dyer
et al. (2015).
MALOPA.
We train MALOPA on the concante-
nation of training sections of all seven languages. To
balance the development set, we only concatenate
the ﬁrst 300 sentences of each language’s develop-
ment section.
Token
representations.
The
ﬁrst
MAL-
OPA parser we evaluate uses only coarse POS
embeddings to construct the token representation.19
As shown in Table 3, this parser consistently
underperforms the monolingual baselines, with a
gap of 12.5 LAS points on average.
Augmenting the token representation with lexical
embeddings to the token representation (both mul-
tilingual word clusters and pretrained multilingual
word embeddings, as described in §3.3) substan-
tially improves the performance of MALOPA, re-
covering 83% of the gap in average performance.
We experimented with three ways to include
language information in the token representation,
namely: ‘language ID’, ‘word order’ and ‘full ty-
pology’ (see §3.4 for details), and found all three
to improve the performance of MALOPA
giving
LAS scores 83.5, 83.2 and 82.5, respectively. It is
noteworthy that the model beneﬁts more from lan-
19We use the same number of dimensions for the coarse POS
embeddings as in the monolingual baselines. The same applies
to all other types of embeddings used in MALOPA.

Recall %
left
right
root
short
long
nsubj*
dobj
conj
*comp
case
*mod
monolingual
89.9
95.2
86.4
92.9
81.1
77.3
75.5
66.0
45.6
93.3
77.0
MALOPA
85.4
93.3
80.2
91.2
73.3
57.3
62.7
64.2
34.0
90.7
69.6
+lexical
89.9
93.8
84.5
92.6
78.6
73.3
73.4
66.9
35.3
91.6
75.3
+language ID
89.1
94.7
86.6
93.2
81.4
74.7
73.0
71.2
48.2
92.8
76.3
+ﬁne-grained POS
89.5
95.7
87.8
93.6
82.0
74.7
74.9
69.7
46.0
93.3
76.3
Table 4: Recall of some classes of dependency attachments/relations in German.
LAS
target language
average
language ID
coarse POS
de
en
es
fr
it
pt
sv
gold
gold
78.6
84.2
83.4
82.4
89.1
84.2
82.6
83.5
predicted
gold
78.5
80.2
83.4
82.1
88.9
83.9
82.5
82.7
gold
predicted
71.2
79.9
80.5
78.5
85.0
78.4
75.5
78.4
predicted
predicted
70.8
74.1
80.5
78.2
84.7
77.1
75.5
77.2
Table 5: Effect of automatically predicting language ID and POS tags with MALOPA on LAS scores.
guage ID than from typological properties. Using
‘language ID,’ we recover another 12% of the origi-
nal gap.
Finally, the best conﬁguration of MALOPA adds
ﬁne-grained POS embeddings to the token represen-
tation.20 Surprisingly, adding ﬁne-grained POS em-
beddings improves the performance even for some
languages where ﬁne-grained POS tags are not avail-
able (e.g., Spanish).
This parser outperforms the
monolingual baseline in ﬁve out of seven target lan-
guages, and wins on average by 0.3 LAS points. We
emphasize that this model is only trained once on
all languages, and the same model is used to parse
the test set of each language, which simpliﬁes the
distribution or deployment of multilingual parsing
software.
Qualitative analysis.
To gain a better understand-
ing of the model behavior, we analyze certain
classes of dependency attachments/relations in Ger-
man, which has notably ﬂexible word order, in Ta-
ble 4.
We consider the recall of left attachments
(where the head word precedes the dependent word
in the sentence), right attachments, root attach-
ments, short-attachments (with distance = 1), long-
attachments (with distance > 6), as well as the fol-
lowing relation groups: nsubj* (nominal subjects:
20Fine-grained POS tags were only available for English,
Italian, Portuguese and Swedish.
Other languages reuse the
coarse POS tags as ﬁne-grained tags instead of padding the ex-
tra dimensions in the token representation with zeros.
nsubj, nsubjpass), dobj (direct object: dobj),
conj (conjunct:
conj), *comp (clausal comple-
ments: ccomp, xcomp), case (clitics and adposi-
tions: case), *mod (modiﬁers of a noun: nmod,
nummod, amod, appos), neg (negation modiﬁer:
neg).21
Findings.
We found that each of the three im-
provements (lexical embeddings, language embed-
dings and ﬁne-grained POS embeddings) tends to
improve recall for most classes.
MALOPA
un-
derperforms (compared to the monolingual base-
line) in some classes: nominal subjects, direct ob-
jects and modiﬁers of a noun. Nevertheless, MAL-
OPA outperforms the baseline in some important
classes such as: root, long attachments and conjunc-
tions.
Predicting language IDs and POS tags.
In Ta-
ble 3, we assume that both gold language ID of the
input language and gold POS tags are given at test
time. However, this assumption is not realistic in
practical applications. Here, we quantify the degra-
dation in parsing accuracy when language ID and
POS tags are only given at training time, but must
be predicted at test time. We do not use ﬁne-grained
21For each group, we report recall of both the attach-
ment and relation weighted by the number of instances in the
gold annotation. A detailed description of each relation can
be found at http://universaldependencies.org/
u/dep/index.html

POS tags in these experiments because some lan-
guages use a very large ﬁne-grained POS tag set
(e.g., 866 unique tags in Portuguese).
In order to predict language ID, we use the
langid.py library (Lui and Baldwin, 2012)22 and
classify individual sentences in the test sets to one
of the seven languages of interest, using the default
models included in the library.
The macro aver-
age language ID prediction accuracy on the test set
across sentences is 94.7%. In order to predict POS
tags, we use the model described in §3.6 with both
input and hidden LSTM dimensions of 60, and with
block dropout. The macro average accuracy of the
POS tagger is 93.3%. Table 5 summarizes the four
conﬁgurations: {gold language ID, predicted lan-
guage ID} × {gold POS tags, predicted POS tags}.
The performance of the parser suffers mildly (–0.8
LAS points) when using predicted language IDs,
but more (–5.1 LAS points) when using predicted
POS tags. As an alternative approach to predicting
POS tags, we trained the Stanford POS tagger, for
each target language, on the coarse POS tag annota-
tions in the training section of the universal depen-
dency treebanks,23 then replaced the gold POS tags
in the test set of each language with predictions of
the monolingual tagger. The resulting degradation
in parsing performance between gold vs. predicted
POS tags is –6.0 LAS points (on average, compared
to a degradation of –5.1 LAS points in Table 5). The
disparity in parsing results with gold vs. predicted
POS tags is an important open problem, and has
been previously discussed by Tiedemann (2015).
The predicted POS results in Table 5 use block
dropout. Without using block dropout, we lose an
extra 0.2 LAS points in both conﬁgurations using
predicted POS tags.
Different
multilingual
embeddings.
Several
methods have been proposed for pretraining mul-
tilingual word embeddings. We compare three of
them:
• multiCCA (Ammar et al., 2016) uses a lin-
22https://github.com/saffsd/langid.py
23We
used
version
3.6.0
of
the
Stanford
POS
tag-
ger,
with the following pre-packaged conﬁguration ﬁles:
german-fast-caseless.tagger.props
(de),
english-caseless-
left3words-distsim.tagger.props (en), spanish.tagger.props (es),
french.tagger.props (fr). We reused french.tagger.props for (it,
pt, sv).
multilingual embeddings
UAS
LAS
multiCluster
87.7
84.1
multiCCA
87.8
84.4
robust projection
87.8
84.2
Table 6: Effect of multilingual embedding estima-
tion method on the multilingual parsing with MAL-
OPA.
UAS and LAS scores are macro-averaged
across seven target languages.
ear operator to project pretrained monolingual
embeddings in each language (except English)
to the vector space of pretrained English word
embeddings.
• multiCluster (Ammar et al., 2016) uses the
same embedding for translationally-equivalent
words in different languages.
• robust projection (Guo et al., 2015) ﬁrst pre-
trains monolingual English word embeddings,
then deﬁnes the embedding of a non-English
word as the weighted average embedding of
English words aligned to the non-English
words (in a parallel corpus). The embedding of
a non-English word which is not aligned to any
English words is deﬁned as the average embed-
ding of words with a unit edit distance in the
same language (e.g., ‘playz’ is the average of
‘plays’ and ‘play’).24
All embeddings are trained on the same data and use
the same number of dimensions (100).25 Table 6 il-
lustrates that the three methods perform similarly on
this task. Aside from Table 6, in this paper, we ex-
clusively use the robust projection multilingual em-
beddings trained in Guo et al. (2016).26 The “ro-
bust projection” result in Table 6 (which uses 100
dimensions) is comparable to the last row in Table 3
(which uses 50 dimensions).
24Our
implementation
of
this
method
can
be
found
at
https://github.com/gmulcaire/
average-embeddings.
25We share the embedding ﬁles at https://github.
com/clab/language-universal-parser/tree/
master/pretrained_embeddings.
26The embeddings were kindly provided by the authors
of Guo et al. (2016) at https://drive.google.com/
file/d/0B1z04ix6jD_DY3lMN2Ntdy02NFU/view

LAS
target language
average
de
es
fr
it
pt
sv
Zhang and Barzilay (2015)
54.1
68.3
68.8
69.4
72.5
62.5
65.9
Guo et al. (2016)
55.9
73.0
71.0
71.2
78.6
69.5
69.3
MALOPA
57.1
74.6
73.9
72.5
77.0
68.1
70.5
Table 8: Dependency parsing: labeled attachment scores (LAS) for multi-source transfer parsers in the
simulated low-resource scenario where Lt ∩Ls = ∅.
LAS
target language
de
es
fr
it
sv
monolingual
58.0
64.7
63.0
68.7
57.6
Duong et al.
61.8
70.5
67.2
71.3
62.5
MALOPA
63.4
70.5
69.1
74.1
63.4
Table 7: Small (3,000 token) target treebank setting:
language-universal dependency parser performance.
Small target treebank.
Duong et al. (2015b) con-
sidered a setup where the target language has a small
treebank of ∼3,000 tokens, and the source language
(English) has a large treebank of ∼205,000 tokens.
The parser proposed in Duong et al. (2015b) is a
neural network parser based on Chen and Manning
(2014), which shares most of the parameters be-
tween English and the target language, and uses
an ℓ2 regularizer to tie the lexical embeddings of
translationally-equivalent words. While not the pri-
mary focus of this paper,27 we compare our pro-
posed method to that of Duong et al. (2015b) on
ﬁve target languages for which multilingual Brown
clusters are available from Guo et al. (2016). For
each target language, we train the parser on the En-
glish training data in the UD version 1.0 corpus
(Nivre et al., 2015b) and a small treebank in the
target language.28 Following Duong et al. (2015b),
in this setup, we only use gold coarse POS tags,
27The setup cost involved in recruiting linguists, developing
and revising annotation guidelines to annotate a new language
ought to be higher than the cost of annotating 3,000 tokens. Af-
ter investing much resources in a language, we believe it is un-
realistic to stop the annotation effort after only 3,000 tokens.
28We
thank
Long
Duong
for
sharing
the
processed,
subsampled training corpora in each target language at
https://github.com/longdt219/universal_
dependency_parser/tree/master/data/
universal-dep/universal-dependencies-1.0.
we do not use any development data in the target
languages (we use the English development set in-
stead), and we subsample the English training data
in each epoch to the same number of sentences in the
target language. We use the same hyperparameters
speciﬁed before for the single MALOPA parser and
each of the monolingual baselines. Table 7 shows
that our method outperforms Duong et al. (2015b)
by 1.4 LAS points on average. Our method consis-
tently outperforms the monolingual baselines in this
setup, with an average improvement of 5.7 absolute
LAS points.
4.2
Target Languages without a Treebank
(Lt ∩Ls = ∅)
McDonald et al. (2011) established that, when no
treebank annotations are available in the target lan-
guage, training on multiple source languages out-
performs training on one (i.e., multi-source model
transfer outperforms single-source model transfer).
In this section, we evaluate the performance of our
parser in this setup.
We use two strong baseline
multi-source model transfer parsers with no super-
vision in the target language:
• Zhang and Barzilay (2015) is a graph-based arc-
factored parsing model with a tensor-based scor-
ing function.
It takes typological properties of
a language as input.
We compare to the best
reported conﬁguration (i.e., the column titled
“OURS” in Table 5 of Zhang and Barzilay, 2015).
• Guo et al. (2016) is a transition-based neural-
network parsing model based on Chen and Man-
ning (2014). It uses a multilingual embeddings
and Brown clusters as lexical features. We com-
pare to the best reported conﬁguration (i.e., the
column titled “MULTI-PROJ” in Table 1 of Guo
et al., 2016).

Following Guo et al. (2016), for each target lan-
guage, we train the parser on six other languages in
the Google universal dependency treebanks version
2.029 (de, en, es, fr, it, pt, sv, excluding whichever
is the target language), and we use gold coarse POS
tags. Our parser uses the same word embeddings
and word clusters used in Guo et al. (2016), and does
not use any typology information.30
The results in Table 8 show that, on average, our
parser outperforms both baselines by more than 1
point in LAS, and gives the best LAS results in four
(out of six) languages.
5
Related Work
Our work builds on the model transfer approach,
which was pioneered by Zeman and Resnik (2008)
who trained a parser on a source language treebank
then applied it to parse sentences in a target lan-
guage.
Cohen et al. (2011) and McDonald et al.
(2011) trained unlexicalized parsers on treebanks of
multiple source languages and applied the parser to
different languages.
Naseem et al. (2012), Täck-
ström et al. (2013), and Zhang and Barzilay (2015)
used language typology to improve model trans-
fer.
To add lexical information, Täckström et al.
(2012) used multilingual word clusters, while Xiao
and Guo (2014), Guo et al. (2015), Søgaard et al.
(2015) and Guo et al. (2016) used multilingual word
embeddings.
Duong et al. (2015b) used a neural
network based model, sharing most of the parame-
ters between two languages, and used an ℓ2 regular-
izer to tie the lexical embeddings of translationally-
equivalent words.
We incorporate these ideas in
our framework, while proposing a novel neural ar-
chitecture for embedding language typology (see
§3.4), and use a variant of word dropout (Iyyer et
al., 2015) for consuming noisy structured inputs.
We also show how to replace an array of mono-
lingually trained parsers with one multilingually-
trained parser without sacriﬁcing accuracy, which is
related to Vilares et al. (2016).
Neural network parsing models which preceded
Dyer et al. (2015) include Henderson (2003), Titov
and Henderson (2007), Henderson and Titov (2010)
29https://github.com/ryanmcd/uni-dep-tb/
30In preliminary experiments, we found language embed-
dings to hurt the performance of the parser for target languages
without a treebank.
and Chen and Manning (2014).
Related to lexi-
cal features in cross-lingual parsing is Durrett et al.
(2012) who deﬁned lexico-syntactic features based
on bilingual lexicons. Other related work include
Östling (2015), which may be used to induce more
useful typological properties to inform multilingual
parsing.
Another popular approach for cross-lingual su-
pervision is to project annotations from the source
language to the target language via a parallel cor-
pus (Yarowsky et al., 2001; Hwa et al., 2005) or
via automatically-translated sentences (Tiedemann
et al., 2014). Ma and Xia (2014) used entropy regu-
larization to learn from both parallel data (with pro-
jected annotations) and unlabeled data in the target
language.
Rasooli and Collins (2015) trained an
array of target-language parsers on fully annotated
trees, by iteratively decoding sentences in the tar-
get language with incomplete annotations. One re-
search direction worth pursuing is to ﬁnd synergies
between the model transfer approach and annotation
projection approach.
6
Conclusion
We presented MALOPA, a single parser trained on
a multilingual set of treebanks.
We showed that
this parser, equipped with language embeddings and
ﬁne-grained POS embeddings, on average outper-
forms monolingually-trained parsers for target lan-
guages with a treebank. This pattern of results is
quite encouraging. Although languages may share
underlying syntactic properties, individual parsing
models must behave quite differently, and our model
allows this while sharing parameters across lan-
guages.
The value of this sharing is more pro-
nounced in scenarios where the target language’s
training treebank is small or non-existent, where
our parser outperforms previous cross-lingual multi-
source model transfer methods.
Acknowledgments
Waleed Ammar is supported by the Google fellow-
ship in natural language processing. Miguel Balles-
teros is supported by the European Commission un-
der the contract numbers FP7-ICT-610411 (project
MULTISENSOR) and H2020-RIA-645012 (project
KRISTINA). Part of this material is based upon

work supported by a subcontract with Raytheon
BBN Technologies Corp. under DARPA Prime Con-
tract No. HR0011-15-C-0013, and part of this re-
search was supported by a Google research award
to Noah Smith.
We thank Jiang Guo for sharing
the multilingual word embeddings and multilingual
word clusters.
We thank Lori Levin, Ryan Mc-
Donald, Jörg Tiedemann, Yulia Tsvetkov, and Yuan
Zhang for helpful discussions. Last but not least,
we thank the anonymous TACL reviewers for their
valuable feedback.
References
[Agi´c et al.2015] Željko Agi´c, Maria Jesus Aranzabe,
Aitziber Atutxa, Cristina Bosco, Jinho Choi, Marie-
Catherine de Marneffe,
Timothy Dozat,
Richárd
Farkas, Jennifer Foster, Filip Ginter, Iakes Goe-
naga, Koldo Gojenola, Yoav Goldberg, Jan Ha-
jiˇc, Anders Trærup Johannsen, Jenna Kanerva, Juha
Kuokkala, Veronika Laippala, Alessandro Lenci, Kris-
ter Lindén, Nikola Ljubeši´c, Teresa Lynn, Christopher
Manning, Héctor Alonso Martínez, Ryan McDonald,
Anna Missilä, Simonetta Montemagni, Joakim Nivre,
Hanna Nurmi, Petya Osenova, Slav Petrov, Jussi Piit-
ulainen, Barbara Plank, Prokopis Prokopidis, Sampo
Pyysalo, Wolfgang Seeker, Mojgan Seraji, Natalia Sil-
veira, Maria Simi, Kiril Simov, Aaron Smith, Reut
Tsarfaty, Veronika Vincze, and Daniel Zeman. 2015.
Universal dependencies 1.1. LINDAT/CLARIN digi-
tal library at Institute of Formal and Applied Linguis-
tics, Charles University in Prague.
[Ammar et al.2016] Waleed Ammar, George Mulcaire,
Yulia Tsvetkov, Guillaume Lample, Chris Dyer, and
Noah A. Smith. 2016. Massively multilingual word
embeddings. arXiv:1602.01925v2.
[Barman et al.2014] Utsab
Barman,
Amitava
Das,
Joachim Wagner, and Jennifer Foster.
2014.
Code
mixing: A challenge for language identiﬁcation in the
language of social media. In EMNLP Workshop on
Computational Approaches to Code Switching.
[Bender2011] Emily M. Bender. 2011. On achieving and
evaluating language-independence in NLP. Linguistic
Issues in Language Technology, 6(3):1–26.
[Buchholz and Marsi2006] Sabine Buchholz and Erwin
Marsi. 2006. CoNLL-X shared task on multilingual
dependency parsing. In Proc. of CoNLL.
[Chen and Manning2014] Danqi Chen and Christopher
Manning.
2014.
A fast and accurate dependency
parser using neural networks. In Proc. of EMNLP.
[Cohen et al.2011] Shay B. Cohen, Dipanjan Das, and
Noah A. Smith. 2011. Unsupervised structure predic-
tion with non-parallel multilingual guidance. In Proc.
of EMNLP.
[Dryer and Haspelmath2013] Matthew S. Dryer and Mar-
tin Haspelmath, editors.
2013.
WALS Online.
Max Planck Institute for Evolutionary Anthropology,
Leipzig.
[Duong et al.2015a] Long Duong, Trevor Cohn, Steven
Bird, and Paul Cook. 2015a. Low resource depen-
dency parsing: Cross-lingual parameter sharing in a
neural network parser. In Proc. of ACL-IJCNLP.
[Duong et al.2015b] Long Duong, Trevor Cohn, Steven
Bird, and Paul Cook. 2015b. A neural network model
for low-resource universal dependency parsing.
In
Proc. of EMNLP.
[Durrett et al.2012] Greg Durrett, Adam Pauls, and Dan
Klein. 2012. Syntactic transfer using a bilingual lexi-
con. In Proc. of EMNLP.
[Dyer et al.2015] Chris Dyer, Miguel Ballesteros, Wang
Ling, Austin Matthews, and Noah A. Smith.
2015.
Transition-based dependency parsing with stack long
short-term memory. In Proc. of ACL.
[Gardner et al.2015] Matt Gardner, Kejun Huang, Evan-
gelos Papalexakis, Xiao Fu, Partha Talukdar, Christos
Faloutsos, Nicholas Sidiropoulos, and Tom Mitchell.
2015.
Translation invariant word embeddings.
In
Proc. of EMNLP.
[Glorot and Bengio2010] Xavier Glorot and Yoshua Ben-
gio.
2010.
Understanding the difﬁculty of training
deep feedforward neural networks. In Proc. of AIS-
TATS.
[Graves et al.2013] Alan
Graves,
Abdel-rahman
Mo-
hamed, and Geoffrey Hinton. 2013. Speech recog-
nition with deep recurrent neural networks. In Proc.
of ICASSP.
[Guo et al.2015] Jiang
Guo,
Wanxiang
Che,
David
Yarowsky, Haifeng Wang, and Ting Liu. 2015. Cross-
lingual dependency parsing based on distributed rep-
resentations. In Proc. of ACL.
[Guo et al.2016] Jiang
Guo,
Wanxiang
Che,
David
Yarowsky, Haifeng Wang, and Ting Liu. 2016. A rep-
resentation learning framework for multi-source trans-
fer parsing. In Proc. of AAAI.
[Heid and Raab1989] Ulrich Heid and Sybille Raab.
1989.
Collocations in multilingual generation.
In
Proc. of EACL.
[Henderson and Titov2010] James Henderson and Ivan
Titov. 2010. Incremental sigmoid belief networks for
grammar learning. Journal of Machine Learning Re-
search, 11:3541–3570.
[Henderson2003] James Henderson. 2003. Inducing his-
tory representations for broad coverage statistical pars-
ing. In Proc. of NAACL-HLT.

[Huang et al.2015] Zhiheng Huang, Wei Xu, and Kai Yu.
2015. Bidirectional LSTM-CRF models for sequence
tagging. arXiv:1508.01991.
[Hwa et al.2005] Rebecca Hwa,
Philip Resnik,
Amy
Weinberg, Clara Cabezas, and Okan Kolak.
2005.
Bootstrapping parsers via syntactic projection across
parallel texts.
Natural Language Engineering,
11(03):311–325.
[Iyyer et al.2015] Mohit Iyyer, Varun Manjunatha, Jor-
dan L. Boyd-Graber, and Hal Daumé. 2015. Deep un-
ordered composition rivals syntactic methods for text
classiﬁcation. In Proc. of ACL.
[Lui and Baldwin2012] Marco Lui and Timothy Baldwin.
2012. langid.py: An off-the-shelf language identiﬁca-
tion tool. In Proc. of ACL.
[Ma and Xia2014] Xuezhe Ma and Fei Xia. 2014. Un-
supervised dependency parsing with transferring dis-
tribution via parallel guidance and entropy regulariza-
tion. In Proc. of ACL.
[McDonald et al.2011] Ryan McDonald, Slav Petrov, and
Keith Hall. 2011. Multi-source transfer of delexical-
ized dependency parsers. In Proc. of EMNLP.
[McDonald et al.2013] Ryan McDonald, Joakim Nivre,
Yvonne Quirmbach-Brundage, Yoav Goldberg, Di-
panjan Das, Kuzman Ganchev, Keith Hall, Slav Petrov,
Hao Zhang, Oscar Täckström, Claudia Bedini, Núria
Bertomeu Castelló, and Jungmee Lee. 2013. Univer-
sal dependency annotation for multilingual parsing. In
Proc. of ACL.
[Mikolov et al.2013] Tomas Mikolov, Kai Chen, Greg
Corrado, and Jeffrey Dean. 2013. Efﬁcient estima-
tion of word representations in vector space. In Proc.
of ICLR.
[Naseem et al.2012] Tahira Naseem, Regina Barzilay, and
Amir Globerson. 2012. Selective sharing for multilin-
gual dependency parsing. In Proc. of ACL.
[Nivre and Nilsson2005] Joakim Nivre and Jens Nilsson.
2005.
Pseudo-projective dependency parsing.
In
Proc. of ACL.
[Nivre et al.2007] Joakim Nivre,
Johan Hall,
Sandra
Kubler, Ryan McDonald, Jens Nilsson, Sebastian
Riedel, and Deniz Yuret.
2007.
The CoNLL 2007
shared task on dependency parsing.
In Proc. of
CoNLL.
[Nivre et al.2015a] Joakim Nivre, Željko Agi´c, Maria Je-
sus Aranzabe, Masayuki Asahara, Aitziber Atutxa,
Miguel Ballesteros, John Bauer, Kepa Bengoetxea,
Riyaz Ahmad Bhat, Cristina Bosco, Sam Bowman,
Giuseppe G. A. Celano, Miriam Connor, Marie-
Catherine de Marneffe, Arantza Diaz de Ilarraza, Kaja
Dobrovoljc, Timothy Dozat, Tomaž Erjavec, Richárd
Farkas, Jennifer Foster, Daniel Galbraith, Filip Gin-
ter, Iakes Goenaga, Koldo Gojenola, Yoav Gold-
berg, Berta Gonzales, Bruno Guillaume, Jan Ha-
jiˇc, Dag Haug, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Hiroshi Kanayama, Jenna Kanerva, Simon
Krek, Veronika Laippala, Alessandro Lenci, Nikola
Ljubeši´c, Teresa Lynn, Christopher Manning, C˘at˘alina
M˘ar˘anduc, David Mareˇcek, Héctor Martínez Alonso,
Jan Mašek, Yuji Matsumoto, Ryan McDonald, Anna
Missilä, Verginica Mititelu, Yusuke Miyao, Simon-
etta Montemagni, Shunsuke Mori, Hanna Nurmi,
Petya Osenova, Lilja Øvrelid, Elena Pascual, Marco
Passarotti, Cenel-Augusto Perez, Slav Petrov, Jussi
Piitulainen, Barbara Plank, Martin Popel, Prokopis
Prokopidis, Sampo Pyysalo, Loganathan Ramasamy,
Rudolf Rosa, Shadi Saleh, Sebastian Schuster, Wolf-
gang Seeker, Mojgan Seraji, Natalia Silveira, Maria
Simi, Radu Simionescu, Katalin Simkó, Kiril Simov,
Aaron Smith, Jan Štˇepánek, Alane Suhr, Zsolt Szántó,
Takaaki Tanaka, Reut Tsarfaty, Sumire Uematsu, Lar-
raitz Uria, Viktor Varga, Veronika Vincze, Zdenˇek
Žabokrtský, Daniel Zeman, and Hanzhi Zhu. 2015a.
Universal dependencies 1.2. LINDAT/CLARIN digi-
tal library at Institute of Formal and Applied Linguis-
tics, Charles University in Prague.
[Nivre et al.2015b] Joakim Nivre, Cristina Bosco, Jinho
Choi, Marie-Catherine de Marneffe, Timothy Dozat,
Richárd Farkas, Jennifer Foster, Filip Ginter, Yoav
Goldberg, Jan Hajiˇc, Jenna Kanerva, Veronika Laip-
pala, Alessandro Lenci, Teresa Lynn, Christopher
Manning, Ryan McDonald, Anna Missilä, Simon-
etta Montemagni, Slav Petrov, Sampo Pyysalo, Na-
talia Silveira, Maria Simi, Aaron Smith, Reut Tsarfaty,
Veronika Vincze, and Daniel Zeman.
2015b.
Uni-
versal dependencies 1.0. LINDAT/CLARIN digital li-
brary at Institute of Formal and Applied Linguistics,
Charles University in Prague.
[Nivre2004] Joakim Nivre. 2004. Incrementality in de-
terministic dependency parsing.
In Proceedings of
the Workshop on Incremental Parsing: Bringing En-
gineering and Cognition Together.
[Östling2015] Robert Östling. 2015. Word order typol-
ogy through multilingual word alignment. In Proc. of
ACL-IJCNLP.
[Petrov et al.2012] Slav Petrov, Dipanjan Das, and Ryan
McDonald. 2012. A universal part-of-speech tagset.
In Proc. of LREC.
[Rasooli and Collins2015] Mohammad Sadegh Rasooli
and Michael Collins.
2015.
Density-driven cross-
lingual transfer of dependency parsers.
In Proc. of
EMNLP.
[Rösner1988] Deitmar Rösner.
1988.
The genera-
tion system of the semsyn project: Towards a task-
independent generator for german. Advances in Natu-
ral Language Generation, 2.

[Søgaard et al.2015] Anders Søgaard, Željko Agi´c, Héc-
tor Martínez Alonso, Barbara Plank, Bernd Bohnet,
and Anders Johannsen. 2015. Inverted indexing for
cross-lingual NLP. In Proc. of ACL-IJCNLP 2015.
[Srivastava et al.2014] Nitish Srivastava, Geoffrey Hin-
ton, Alex Krizhevsky, Ilya Sutskever, and Ruslan
Salakhutdinov. 2014. Dropout: A simple way to pre-
vent neural networks from overﬁtting. Journal of Ma-
chine Learning Research, 15(1):1929–1958.
[Sutskever et al.2014] Ilya Sutskever, Oriol Vinyals, and
Quoc V. Le.
2014.
Sequence to sequence learning
with neural networks. In NIPS.
[Täckström et al.2012] Oscar Täckström, Ryan McDon-
ald, and Jakob Uszkoreit. 2012. Cross-lingual word
clusters for direct transfer of linguistic structure. In
Proc. of NAACL-HLT.
[Täckström et al.2013] Oscar Täckström, Dipanjan Das,
Slav Petrov, Ryan McDonald, and Joakim Nivre.
2013.
Token and type constraints for cross-lingual
part-of-speech tagging. Transactions of the Associa-
tion for Computational Linguistics, 1:1–12.
[Tiedemann et al.2014] Jörg Tiedemann, Zeljko Agic, and
Joakim Nivre. 2014. Treebank translation for cross-
lingual parser induction. In Proc. of CoNLL.
[Tiedemann2015] Jörg Tiedemann. 2015. Cross-lingual
dependency parsing with universal dependencies and
predicted POS labels. In Proc. of DepLing.
[Titov and Henderson2007] Ivan Titov and James Hen-
derson. 2007. Constituent parsing with incremental
sigmoid belief networks. In Proc. of ACL.
[Vilares et al.2016] David
Vilares,
Carlos
Gómez-
Rodríguez, and Miguel A. Alonso.
2016.
One
model, two languages: training bilingual parsers with
harmonized treebanks. arXiv:1507.08449v2.
[Wikipedia2016] Wikipedia.
2016.
List of languages
by number of native speakers. http://bit.ly/
1LUP5kJ. Accessed: 2016-01-26.
[Xiao and Guo2014] Min Xiao and Yuhong Guo. 2014.
Distributed word representation learning for cross-
lingual dependency parsing. In Proc. of CoNLL.
[Yarowsky et al.2001] David Yarowsky, Grace Ngai, and
Richard Wicentowski. 2001. Inducing multilingual
text analysis tools via robust projection across aligned
corpora. In Proc. of HLT.
[Zeman and Resnik2008] Daniel
Zeman
and
Philip
Resnik.
2008.
Cross-language parser adaptation
between related languages. In Proc. of IJCNLP.
[Zhang and Barzilay2015] Yuan Zhang and Regina Barzi-
lay. 2015. Hierarchical low-rank tensors for multilin-
gual transfer parsing. In Proc. of EMNLP.

