

An Introduction to Category Theory
Category theory provides a general conceptual framework that has proved fruitful in
subjects as diverse as geometry, topology, theoretical computer science and
foundational mathematics. Here is a friendly, easy-to-read textbook that explains the
fundamentals at a level suitable for newcomers to the subject.
Beginning postgraduate mathematicians will ﬁnd this book an excellent
introduction to all of the basics of category theory. It gives the basic deﬁnitions; goes
through the various associated gadgetry, such as functors, natural transformations,
limits and colimits; and then explains adjunctions. The material is slowly developed
using many examples and illustrations to illuminate the concepts explained. Over 200
exercises, with solutions available online, help the reader to access the subject and
make the book ideal for self-study. It can also be used as a recommended text for a
taught introductory course.


An Introduction to
Category Theory
HAROLD SIMMONS
University of Manchester

C A M B R I D G E U N I V E R S I T Y P R E S S
Cambridge, New York, Melbourne, Madrid, Cape Town,
Singapore, S˜ao Paulo, Delhi, Tokyo, Mexico City
Cambridge University Press
The Edinburgh Building, Cambridge CB2 8RU, UK
Published in the United States of America by Cambridge University Press, New York
www.cambridge.org
Information on this title: www.cambridge.org/9781107010871
c⃝H. Simmons 2011
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
Original published 2011
Printed in the United Kingdom at the University Press, Cambridge
A catalogue record for this publication is available from the British Library
Library of Congress Cataloguing in Publication data
Simmons, Harold
An introduction to category theory / Harold Simmons.
p.
cm.
ISBN 978-1-107-01087-1 (hardback)
1. Categories (Mathematics)
I. Title.
QA169.S56
2011
512′.62–dc23
2011021721
ISBN 978-1-107-01087-1 Hardback
ISBN 978-0-521-28304-5 Paperback
Additional resources for this publication at www.cambridge.org/simmons
Cambridge University Press has no responsibility for the persistence or
accuracy of URLs for external or third-party internet websites referred to
in this publication, and does not guarantee that any content on such
websites is, or will remain, accurate or appropriate.

Contents
Preface
page vii
1
Categories
1
1.1
Categories deﬁned
1
1.2
Categories of structured sets
8
1.3
An arrow need not be a function
16
1.4
More complicated categories
27
1.5
Two simple categories and a bonus
31
2
Basic gadgetry
34
2.1
Diagram chasing
34
2.2
Monics and epics
37
2.3
Simple limits and colimits
43
2.4
Initial and ﬁnal objects
45
2.5
Products and coproducts
47
2.6
Equalizers and coequalizers
56
2.7
Pullbacks and pushouts
64
2.8
Using the opposite category
71
3
Functors and natural transformations
72
3.1
Functors deﬁned
73
3.2
Some simple functors
76
3.3
Some less simple functors
79
3.4
Natural transformations deﬁned
90
3.5
Examples of natural transformations
93
4
Limits and colimits in general
108
4.1
Template and diagram – a ﬁrst pass
109
4.2
Functor categories
114
4.3
Problem and solution
118

vi
Contents
4.4
Universal solution
120
4.5
A geometric limit and colimit
124
4.6
How to calculate certain limits
130
4.7
Conﬂuent colimits in Set
143
5
Adjunctions
148
5.1
Adjunctions deﬁned
148
5.2
Adjunctions illustrated
153
5.3
Adjunctions uncoupled
164
5.4
The unit and the counit
170
5.5
Free and cofree constructions
174
5.6
Contravariant adjunctions
186
6
Posets and monoid sets
190
6.1
Posets and complete posets
190
6.2
Two categories of complete posets
191
6.3
Sections of a poset
193
6.4
The two completions
195
6.5
Three endo-functors on Pos
197
6.6
Long strings of adjunctions
199
6.7
Two adjunctions for R-sets
202
6.8
The upper left adjoint
205
6.9
The upper adjunction
209
6.10
The lower right adjoint
212
6.11
The lower adjunction
218
6.12
Some ﬁnal projects
221
Bibliography
223
Index
224

Preface
As it says on the front cover this book is an introduction to Category Theory. It
gives the basic deﬁnitions; goes through the various associated gadgetry such
as functors, natural transformations, limits and colimits; and then explains ad-
junctions. This material could be developed in 50 pages or so, but here it takes
some 220 pages. That is because there are many examples illustrating the var-
ious notions, some rather straightforward, and others with more content. More
importantly, there are also over 200 exercises. And perhaps even more impor-
tantly, solutions to these exercises are available online.
The book is aimed primarily at the beginning graduate student, but that does
not mean that other students or professional mathematicians will not ﬁnd it
useful. I have designed the book so that it can be used by a single student or
small group of students to learn the subject on their own. The book will make
a suitable text for a reading group. The book does not assume the reader has
a broad knowledge of mathematics. Most of the illustrations use rather simple
ideas, but every now and then a more advanced topic is mentioned. The book
can also be used as a recommended text for a taught introductory course.
Every mathematician should at least know of the existence of category the-
ory, and many will need to use categorical notions every now and then. For
those groups this is the book you should have. Other mathematicians will use
category theory every day. That group has to learn the subject sometime, and
this is the book to start that process. Of course, the more advanced topics are
not dealt with here.
The book has been developed over quite a few years. Several short courses
of about 10 hours have been taught (not always by me) using some of the
material. In 2007, 2008, and 2009 I gave a course over the web to about a
dozen universities. This was part of MAGIC, the
Mathematics
Access
Grid
Instruction
and
Collaboration

viii
Preface
cooperative of quite a few University Departments of Mathematics in England
and Wales. That was an interesting experience and helped me to split the mate-
rial into small chunks each of the right length to ﬁt into one hour. (The course
is still being taught but someone else has taken over the wand.) Of course, the
order in which material is taught need not be the same as the written account.
As someone once said, Mathematics is not a spectator sport. To learn and
understand Mathematics you have to get stuck in and get your hands dirty.
You have to do the calculations, manipulations, and proofs yourself, not just
read the stuff and pretend you understand it. Thus I have included over 200
exercises to help with this process. I have also written a more or less complete
set of solutions to these exercises. But these are not available in the book, for it
is too easy simply to look up a solution. When you can’t see how to do it you
have to sweat a bit to ﬁnd a solution. Someone else once said that horses sweat,
gentlemen perspire, and ladies glow. However, I can’t remember meeting many
horses who could do mathematics all that well. In other words, although effort
is important to learn mathematics you also need something else. You need
help every now and then. That is why there are exercises and solutions. These
solutions are available at
www.cambridge.org/simmons
The book is divided into six Chapters, each chapter is divided into several
Sections, and a few of these are divided into Blocks (Subsections). Each chap-
ter contains a list of Items, that is Deﬁnitions, Lemmas, Theorems, Examples,
and so on. These are numbered by section. Thus item X.Y.Z is in Chapter X,
Section Y , and is the Zth item in that section. Where a section is divided into
blocks the items are still numbered by the parent section.
Each section contains a selection of Exercises. These are numbered sepa-
rately throughout the section. Thus Exercise X.Y.Z is in Chapter X, Section
Y , and is the Zth exercise of that section. Again, where a section is divided
into blocks the exercises are still numbered by the parent section.
Occasionally you will see a word or two IN THIS FONT. This is a mention of
a NOTION that is dealt with in more detail later. You should remember to come
back to this place when you understand the notion.
There are several other books available on this subject. Some of these are
introductory texts and some are more advanced. I have listed some of them in
the bibliography. None of these are needed when reading this book, but some
will certainly help broaden and advance your understanding of the subject. I
have refrained from passing comment on these books, for I know that different
people have different tastes. However, you should look around for different
accounts. Some of these will help.

Preface
ix
I ﬁrst became aware of Category Theory in 1965 during a Summer Meeting
in Leicester (England). Since then I have been trying to learn and understand
the subject. It is patently obvious to me that Category Theory is a very useful
tool. It helps to organize many parts of mathematics. It can sort out the ‘rou-
tine’ aspects of a proof and isolate the ‘essential content’ of the result. In some
ways that is why Eilenberg and MacLane invented the subject. However, I am
not one of those 42ers who think that Category Theory is the essential foun-
dations for Mathematics, Life, and Everything. Of course Category Theory is
something that every mathematician should know something about, but there
are other things as well.
Many people have inﬂuenced this book. For several years Andrea Schalk
has used the material to teach an introductory course. Hugh Steele, Roman
Krenick´y, and Francisco Lobo have pointed out and sometimes corrected my
eccentricities. And Wolfy has guided me through some of the deeper mysteries
of LaTeX. Where would we be without the wonderful LaTeX?
There may still be mistakes, inaccuracies, or garbled bits in the book. I
would be quite happy to pass on the blame, but I won’t. I am not a politi-
cian. I am responsible for everything inside the cover. The outside cover is the
work of others.
Any book of this kind must contain many diagrams, some of which must
commute. I have used Paul Taylor’s diagram package to do this job. If you
don’t know this package then I recommend you have a look at it. I have also
used his lesser known tree drawing package at one place.
At Cambridge University Press my contact, Silvia Barbina, has been very
helpful. I once taught her a little bit about football (and, as she reminded me,
some Model Theory). Silvia has made writing this ﬁnal version very enjoyable.
She has kept me on the straight and narrow, so I didn’t wander off to do some-
thing else. In her charming Italian style she asked me (instructed me) to cut
out all the jokes. This was quite difﬁcult since some of the ofﬁcial categorical
terminology is a joke, but I have done my best.
Clare Dennison and Lucy Edwards oversaw the production period (getting
my raw code converted into the material you have in front of you). Siriol Jones
copy-edited the book and corrected many of my silly mistakes. I thank them
all. Roger Astley was chief pie-man for the whole project.
On a more personal level I am very grateful to Bobby Manc and what he
is achieving. I hope he continues for quite some time. The Lodge (Appleby
Lodge) is at last getting back to what it should be. Ruth Maddocks kept me
cheerful. She made me the odd cup of tea. A very odd cup of tea.
Enjoy yourself and learn something at the same time.


1
Categories
This chapter gives the deﬁnition of ‘category’ in Section 1.1, and follows that
by four sections devoted entirely to examples of categories of various kinds. If
you have never met the notion of a category before, you should quite quickly
read through Deﬁnition 1.1.1 and then go to Section 1.2. There you will ﬁnd
some examples of categories that you are familiar with, although you may not
have recognized the categorical structure before. In this way you will begin
to see what Deﬁnition 1.1.1 is getting at. After that you can move around the
chapter as you like.
Remember that it is probably better not to start at this page and read each
word, sentence, paragraph, ..., in turn. Move around a bit. If there is something
you don’t understand, or don’t see the point of, then leave it for a while and
come back to it later.
Life isn’t linear, but written words are.
1.1 Categories deﬁned
This section contains the deﬁnition of ‘category’, follows that with a few bits
and pieces, and concludes with a discussion of some examples. No examples
are looked at in detail, that is done in the remaining four sections. Section
1.2 contains a collection of simpler examples, some of which you will know
already. You might want to dip into that section as you read this section. In the
ﬁrst instance you should ﬁnd a couple of examples that you already know. As
you become familiar with the categorical ideas you should look at some of the
more complicated examples given in the later sections.
The following deﬁnition doesn’t quite give all the required information.
There are a couple of restrictions that are needed and which are described in
detail in the paragraphs following.

2
Categories
1.1.1 Deﬁnition
A category C consists of
• a collection Obj of entities called objects
• a collection Arw of entities called arrows
• two assignments
Arw
source-
target
- Obj
• an assignment
Obj
id - Arw
• a partial composition
Arw × Arw
- Arw
where this data must satisfy certain restrictions as described below.
Before we look at the restrictions on this data let’s ﬁx some notation.
• We let A, B, C, . . . range over objects.
• We let f, g, h, . . . range over arrows.
This convention isn’t always used. For instance, sometimes a, b, c, . . . range
over objects, and α, β, γ, . . . or θ, φ, ψ, . . . range over arrows. The notation
used depends on what is convenient at the time and what is the custom in the
topic under discussion. Here we will take the above convention as the norm,
but sometimes we will use other notations.
There are two assignments
source
target
each of which attaches an object to an arrow, that is each consumes an arrow
and returns an object. We write
A
f
- B
to indicate that f is an arrow with source A and target B. This is a small
example of a diagram. Later we will see some slightly bigger ones.
This terminology isn’t always used. Sometimes combinations of
A
f
- B
source
arrow
target
domain
morphism
codomain
map
are used. Certainly morphisms (such as group morphisms) and maps (such as
continuous maps) usually are examples of arrows in some category. However,

1.1. Categories deﬁned
3
it is better to use ‘arrow’ for the abstract notion, and so distinguish between
the general and the particular.
The word ‘domain’ already has other meanings in mathematics. Why bother
with this and ‘codomain’ when there are two perfectly good words that capture
the idea quite neatly. You will also see
f : A
- B
used to name the arrow above. However, as we see later, you should not think
of an arrow as a function.
All three of the notations
A
id A
idA
1A- A
are used for the identity arrow assigned to the object A. We will tend to use
idA. Notice that the source and the target of idA are both the parent object A.
Quite often when there is not much danger of confusion id is written for idA.
You will also ﬁnd in the literature that some people write ‘A’ for the arrow
idA. This is a notation so ridiculous that it should be laughed at in the street.
Certain pairs of arrows are compatible for composition to form another
arrow. Two arrows
A
f
- B1
B2
g
- C
are composible, in that order, precisely when B1 and B2 are the same object,
and then an arrow
A
- C
is formed. For arrows
A
f
- B
g
- C
both of the notations
A
g ◦f
gf- C
are used for the composite arrow. Read this as
g after f
and be careful with the order of composition. Here we write g ◦f for the
composite.
We need to understand how to manipulate composition, sometimes involv-
ing many arrows.

4
Categories
Composition of arrows is associative as far as it can be. For arrows
A
f
- B
g
- C
h
- D
various composites are possible, as follows.
A
(h ◦g) ◦f
- D
A
f
- B
h ◦g
- D
A
f
- B
g
- C
h
- D
A
g ◦f
- C
h
- D
A
h ◦(g ◦f)
- D
It is required that the two extreme arrows are equal
(h ◦g) ◦f = h ◦(g ◦f)
and we usually write
h ◦g ◦f
for this composite. This is the ﬁrst of the axioms restricting the data.
The second axiom says that identity arrows are just that. Consider
A
idA - A
f
- B
idB - B
an arbitrary arrow and the two compatible identity arrows. Then
idB ◦f = f = f ◦idA
must hold.
Given two objects A and B in an arbitrary category C, there may be no
arrows from A to B, or there may be many. We write
C[A, B]
or
C(A, B)
for the collection of all such arrows. For historical reasons this is usually called
the
hom-set
from A to B, although
arrow-class
would be better. Some people insist that C[A, B] should be a set, not a class.
As usual, there are some variants of this notation. We often write
[A, B]
for
C[A, B]

1.1. Categories deﬁned
5
especially when it is clear which category C is intended. Sometimes
HomC[A, B]
is used for this hom-set.
We have seen above one very small diagram. Composition gives us a slightly
larger one. Consider three arrows
•
•
h
-
f
-
•
g
-
arranged in a triangle, as shown. Here we haven’t given each object a name,
because we don’t need to. However, the notation does not mean that the three
objects are the same. For this small diagram, the triangle, the composite g ◦f
exists to give us a parallel pair
•
g ◦f -
h
- •
of arrows across the bottom of the triangle. These two arrows may or may not
be the same. When they are
h = g ◦f
we say the triangle commutes. We look at some more commuting diagrams
in Section 2.1, and other examples occur throughout the book.
Examples of categories
In the remaining sections of this chapter we look at a selection of examples of
categories. Roughly speaking these are of four kinds.
The ﬁrst collection is listed in Table 1.1 on page 6. These all have a similar
nature and are examples of the most common kind of category we meet in
practice. In each an object is a structured set, a set furnished, or equipped, with
some extra gadgetry, the furnishings of the object. An arrow between two
objects is a function between the carrying sets where the function ‘respects’ the
carried structure. Arrow composition is then function composition. We look at
some of these categories in Section 1.2.
Some categories listed in Table 1.1 are not deﬁned in this chapter. Some are
used later to illustrate various aspects of category theory, in which case each

6
Categories
Table 1.1 Categories of structured sets and structure preserving functions
Category
Objects
Arrows
Set
sets
total functions
Pfn
sets
partial functions
Set⊥
pointed sets
point preserving functions
RelH
sets with a relation
relation respecting functions
Sgp
semigroups
morphisms
Mon
monoids
morphisms
CMon
commutative monoids
morphisms
Grp
groups
morphisms
AGrp
abelian groups
morphisms
Rng
rings
morphisms
CRng
commutative rings
morphisms
Pre
pre-ordered sets
monotone maps
Pos
posets
monotone maps
Sup
complete posets
W-preserving
monotone functions
Join
posets with all ﬁnitary joins
∨-preserving
monotone functions
Inf
complete posets
V-preserving
monotone functions
Meet
posets with all ﬁnitary meets
∧-preserving
monotone functions
Top
topological spaces
continuous maps
Top⋆
pointed topological spaces
point preserving
continuous maps
Topopen
topological spaces
continuous open maps
VectK
vector spaces over a given ﬁeld K
linear transformations
Set-R
sets with a right action from
action preserving functions
a given monoid R
R-Set
sets with a left action from
action preserving functions
a given monoid R
Mod-R
right R-modules over a ring R
morphisms
R-Mod
left R-modules over a ring R
morphisms

1.1. Categories deﬁned
7
Table 1.2 More complicated categories
Category
Objects
Arrows
RelA
sets
binary relations
Pos⊣
posets
poset adjunctions
Pospp
posets
projection embedding pairs
bS
presheaves
natural transformations
on a given poset S
c
C
presheaves
natural transformations
on a given category C
Ch(Mod-R)
chain complexes
is deﬁned when it ﬁrst appears. Some categories are listed but not used in this
book, but you should be able to ﬁll in the details when you need to.
These simple examples tend to give the impression that in any category an
object is a structured set and an arrow is a function of a certain kind. This is
a false impression, and in Section 1.3 we look at some examples to illustrate
this. In particular, these examples show that an arrow need not be a function
(of the kind you ﬁrst thought of).
An important message of category theory is that the more important part of
a category is not its objects but the way these are compared, its arrows. Given
this we might expect a category to be named after its arrows. For historical
reasons this often doesn’t happen.
Section 1.4 contains some examples to show that the objects of a category
can have a rather complicated internal structure, and the arrows are just as
complicated. These examples are important in various parts of mathematics,
but you shouldn’t worry if you cannot understand them immediately.
Table 1.2 lists some of these more complicated examples looked at in Sec-
tions 1.3 and 1.4.
Finally in Section 1.5 we look at two very simple kinds of categories. These
examples could be given now, but in some ways it is better if we leave them
for a while.
Exercises
1.1.1
Observe that sets and functions do form a category Set.
1.1.2
Can you see that each poset is a category, and each monoid is a cate-
gory? Read that again.

8
Categories
1.2 Categories of structured sets
The categories we ﬁrst meet usually have a rather simple nature. Each object
is a structured set
(A, · · · )
a set furnished with some extra gadgetry, its furnishings, and each arrow
(A, · · · )
- (B, · · · )
is a (total) function
f : A
- B
between the two carrying sets which respects the carried structure in some
appropriate sense. More often than not these structured sets are ‘algebras’.
Thus the furnishings carried by A are a selection of nominated elements, and
a selection of nominated operations on A. These operations are usually binary
or singulary, but other arities do occur.
You have already met
Grp
Rng
VectK
as given in Table 1.1, but you may not have realized that each of these is a
category. You should make sure that you understand the workings of each of
these as a category of ‘algebras’. You may have to puzzle a bit over VectK,
but later we look at some more general examples of this nature, and that should
help you.
To help with the general idea, in the ﬁrst part of this section we look at the
category Mon of monoids. This has all the typical properties of an ‘algebraic’
category. You may not have met monoids before, so this example will serve as
an introduction, and it is quite easy to understand. Monoids are quite important
in category theory. They can tell us quite a lot about the structure of a particular
category. Also, they can be used to illustrate many aspects of category theory.
The exercises for the ﬁrst part of this section look at several other categories
of structured sets, some of which are not ‘algebraic’ in this intuitive sense. One
of these
Top
is particularly important, and you should make sure you understand it. It is
important here and in many other parts of mathematics.

1.2. Categories of structured sets
9
1.2.1 Example
A monoid is a structure
(R, ⋆, 1)
where R is a set, ⋆is a binary operation on R (usually written as an inﬁx), 1 is
a nominated element of R, and where
(r ⋆s) ⋆t = r ⋆(s ⋆t)
1 ⋆r = r = r ⋆1
for all r, s, t ∈R. In other words, the operation is associative and the nomi-
nated element is a unit for the operation. Monoids are sometimes referred to
as unital semigroups, or even semigroups. However, sometimes a ‘semigroup’
need not have a unit.
Usually we omit the operation symbol and write
rs
for
r ⋆s
but for the time being we will stick to the ofﬁcial notation.
A monoid morphism
R
φ
- S
between two monoids is a function that respects the furnishings, that is
φ(r ⋆s) = φ(r) ⋆φ(s)
φ(1) = 1
for all r, s ∈R. (Notice that we have overloaded the operation symbol and the
unit symbol. That shouldn’t cause a problem here, but every now and then it is
a good idea to distinguish between the source and target furnishings.)
It is routine to check that for two morphisms
R
φ
- S
ψ
- T
between monoids the function composite
R
ψ ◦φ- T
is a morphism.
This gives us the category Mon of monoids (as objects) and monoid mor-
phisms (as arrows). The veriﬁcation of the axioms is almost trivial. Given a
monoid R the identity arrow
R
idR - R
is just the identity function on R viewed as a morphism.

10
Categories
As suggested above, many categories ﬁt into this ‘algebraic’ form. Each
object is a structured set, and each arrow (usually called a morphism or a map)
is a structure respecting function. Almost all of the categories in Table 1.1 ﬁt
into this kind, but one or two don’t.
In a sense the study of monoids is the study of composition in the miniature.
There is a corresponding study of comparison in the miniature. That is the
topic of the next example.
1.2.2 Example
A pre-order ≤on a set S is a binary relation that is both re-
ﬂexive and transitive. (Sometimes a pre-order is called a quasi-order.) A partial
order is a pre-order that is also anti-symmetric.
A
preset
poset
is a set S furnished with a
pre-order
partial order
respectively. Thus each poset is a preset, but not conversely.
When comparing two such structures
(R, ≤R)
(S, ≤S)
we use the carrying sets R and S to refer to the structures and write ≤for
both the carried comparisons. Rarely does this cause any confusion, but when
it does we are a bit more careful with the notation.
Given a pair R, S of presets a monotone map
R
f
- S
is a function, as indicated, such that
x ≤y =⇒f(x) ≤f(y)
for all x, y ∈R. Note that this condition is an implication, not an equivalence.
It is routine to check that for two monotone maps
R
f
- S
g
- T
between presets the function composition g ◦f is also monotone.
This gives us two categories
Pre
Pos
where the objects are
presets
posets
respectively, and in both cases the arrows are the monotone maps. Each identity
arrow is the corresponding identity function viewed as a monotone map.

1.2. Categories of structured sets
11
Consider a pair R and S of posets. Each is a preset, so we have the two
collections of arrows
Pre[R, S]
Pos[R, S]
in the categories. A moment’s thought shows that, as sets of functions, these
two sets are the same. Technically, this shows that Pos is a FULL SUBCATE-
GORY of Pre.
The study of monoids is the study of composition in the miniature.
The study of presets is the study of comparison in the miniature.
What should we do to study these two notions together and in the large?
Category theory! In a sense every category is an amalgam of certain monoids
and presets, and that is a good enough reason why we should always keep these
two simple notions in mind.
From the examples we have seen so far it is easy to get the impression that
certain things always happen. The next example shows that some categories
can be awkward (and sometimes cantankerous).
1.2.3 Example
We enlarge the category Set of sets and total functions to the
category Pfn of sets and partial functions. The objects of Pfn are just sets
A, B, C, . . .
as in Set. However, an arrow
A
f
- B
is a partial function from A to B. In other words, an arrow is a total function
A
B
X
∪
6
f
-
from a subset X of the source A. (This is an example where the use of the word
‘domain’ for source can be confusing. The set X is the domain of deﬁnition
of the partial function.) Notice that we need to distinguish between the total
function f and the arrow f it determines. The notation has been chosen to
emphasize that distinction.
We wish to show that these objects and arrows form a category Pfn. To do
that we must ﬁrst produce a composition of arrows.

12
Categories
Consider a pair of partial functions.
A
f
- B
g
- C
X
∪
6
f
-
Y
∪
6
g
-
How might we compose these? We somehow want to stick f and g together,
but these functions are not composition compatible.
We extract a subset U ⊆A by
a ∈U ⇐⇒a ∈X and f(a) ∈Y
(for a ∈A). Since f is deﬁned on the whole of U we restrict f to U.
A
f
- B
g
- C
X
∪
6
f
-
Y
∪
6
g
-
U
∪
6
f |U
-
Now we do have composition compatible functions. Thus we take
g ◦f
to be that arrow (partial function) determined by
g ◦f = g ◦f |U
to produce a composition of arrows in Pfn.
Notice here how the symbol ‘◦’ is overloaded. On the right it is the standard
composition of total functions. On the left it is the deﬁned operation on par-
tial functions. If at ﬁrst you ﬁnd this confusing then write ‘•’ for the deﬁned
operation. Thus
g • f = g ◦f |U
is its deﬁnition.
There is still some work to be done. For instance, we need to show that this
composition of arrows is associative. That is left as an exercise.
Once we see it the step from Set to Pfn is not so big. An arrow is still a
function, but we have to take a little more care with composition. There is also
a much neater way of handling Pfn. Perhaps you can think about that.

1.2. Categories of structured sets
13
We began this section by looking at the category Mon of monoids. We
conclude by looking at two categories attached to each monoid.
1.2.4 Example
Let R be a ﬁxed, but arbitrary, monoid. A
left
right
R-set is a set A together with an action
R, A
- A
A, R
- A
r, a
- ra
a, r
- ar
where
s(ra) = (sr)a
(ar)s = a(rs)
1a = a
a = a1
for each a ∈A and r, s ∈R. Here the two deﬁnitions are given in parallel.
These R-sets are the objects of two categories
R-Set
Set-R
with left R-sets on the left and right R-sets on the right.
Given two R-sets A and B of the same handedness, a morphism
A
f
- B
is a function f such that
f(ra) = rf(a)
f(ar) = f(a)r
for each a ∈A and r ∈R. These are the arrows of the two categories.
This may look a quite simple example but it is useful. Many aspects of cat-
egory theory can be illustrated with these categories. We use them quite a lot
in this book. They are also module categories in miniature. We can replace the
monoid R by a ring and replace each set A by an abelian group. This gives the
categories
R-Mod
Mod-R
of left and right modules over R, respectively. These categories have quite a
bit more structure, but we won’t go into that too much here.

14
Categories
Exercises
1.2.1
The category Pno described in this exercise may look less than excit-
ing, but it plays an important role in mathematics. (It was originally discovered
by Dedekind without the category theory.)
The objects of Pno are the structures (A, α, a) where A is a set, and where
α : A
- A is a function, and a ∈A is a nominated element. Given two
such structures a morphism
(A, α, a)
f - (B, β, b)
is a function f : A
- B which preserves the structure in the sense that
f ◦α = β ◦f
f(a) = b
hold.
(a) Verify that Pno is a category.
(b) Show that (N, succ, 0) is a Pno-object (where succ is the successor
function).
(c) Show that for each Pno-object (A, α, a) there is a unique arrow
(N, succ, 0)
- (A, α, a)
and describe the behaviour of the carrying function.
1.2.2
Consider pairs (A, X) where A is a set and X ⊆A. For two such pairs
a morphism
(A, X)
f - (B, Y )
is a function f : A
- B that respects the selected subsets, that is
f(x) ∈Y
for each x ∈X. Show that such pairs and morphisms form a category SetD,
the category of sets with a distinguished subset.
1.2.3
Consider pairs (A, R) where A is a set and R ⊆A × A is a binary
relation on A. Show that these pairs are the objects of a category. You must
ﬁnd a sensible notion of morphism for such pairs.
1.2.4
A topological space (S, OS) is a set S furnished with a certain family
OS of subsets of S (called the open sets of the space). This family is required
to contain both ∅and S, be closed under ∩(binary intersection), and be closed
under S (arbitrary unions).

1.2. Categories of structured sets
15
A continuous map
(S, OS)
φ - (T, OT)
between two such spaces is a function
φ : S
- T
such that
φ←(V ) ∈OS
for each V ∈OT. Here φ←is the inverse image map given by
x ∈φ←(V ) ⇐⇒φ(x) ∈V
for each V ∈OT and x ∈S.
Show that these spaces and maps form a category Top.
1.2.5
Let A be an arbitrary object of an arbitrary category C. Show that
C[A, A] is a monoid under composition.
1.2.6
Fill in the details missing from the description of Pfn. In particular,
you should show that composition of partial functions is associative.
1.2.7
A pointed set is a set S with a nominated element which we usually
write as ⊥. An arrow
S
φ
- T
between two such pointed sets is a function φ : S
- T which respects the
nominated points, that is φ(⊥) = ⊥.
Almost trivially, pointed sets with these arrows form a category Set⊥.
Try to show that Set⊥and Pfn are ‘essentially the same’ category.
1.2.8
Verify that for each monoid R both
R-Set
Set-R
are categories.
Can you see how each is a category of structured sets?

16
Categories
1.3 An arrow need not be a function
In this section we look ﬁrst at some examples to show that arrows may not be
the simple kind of things we have seen so far. Then we look at some general
constructions for turning an old category into a new one.
In the next example an arrow is still a function, but not where you might
expect it to be.
1.3.1 Example
The objects are the ﬁnite sets. An arrow
A
f
- B
is a function
f : A × B
- R
(with no imposed conditions). For each pair
A
f
- B
g
- C
of arrows we deﬁne
g ◦f : A × C
- R
by
(g ◦f)(a, c) =
X 
f(a, y)g(y, c) | y ∈B
	
for a ∈A, b ∈B. A little work shows that this produces a category.
We did not give this category a name because it is not that important. It is
merely an example to illustrate that an arrow need not be a function in the way
you might expect it to be.
1.3.2 Example
We have seen that the category Set of sets and functions
can be extended to Pfn by adding more arrows but keeping the same objects.
There is also a different extension to the category RelA.
Again the objects of RelA are just sets. However, a RelA-arrow
A
F
- B
is a subset F ⊆B × A which we can think of as a relation from A to B.
In other words, RelA[A, B] is just this set of all such relations from A to B.
You should note the way the source and target have been set up. This is not a
mistake. It leads to a neater description of the category.
Before we can claim this is a category we must deﬁne the composition of
these arrows, and then check that the axioms are satisﬁed.

1.3. An arrow need not be a function
17
Consider an arrow F as above, so F ⊆B × A. For a ∈A and b ∈B we
write bFa for (b, a) ∈F. For two composible arrows
A
F
- B
G - C
we deﬁne the composition G ◦F by
c(G ◦F)a ⇐⇒(∃b ∈B)[cGbFa]
for a ∈A, b ∈B. We show that a is G ◦F related to c by passing through a
common element b ∈B. It is easy to check that this composition is associative,
and the equality relation on a set gives the identity arrow.
The two categories Set and RelA are connected in a certain way (which
will be explained in more detail later). There is a canonical way
A
f
- B
>
A
Γ(f) - B
of converting a Set-arrow into a RelA-arrow with the same source and target.
We simply take the graph of the function, that is we let
b Γ(f) a ⇐⇒b = f(a)
for a ∈A, b ∈B.
The next example is important in itself, and also provides a miniature version
of a central notion of category theory, that of an ADJUNCTION.
1.3.3 Example
We modify the category Pos of posets, of Example 1.2.2, to
produce a new category Pos⊣. As with Pos, the objects of Pos⊣are posets,
but the arrows are different.
Given a pair S, T of posets, an adjunction from S to T is a pair of monotone
maps as on the left such that the equivalence on the right
S
f
-

g
T
f(a) ≤b ⇐⇒a ≤g(b)
holds for all a ∈S and b ∈T. We call
f the left adjoint
g the right adjoint
of the pair, and sometimes write
f ⊣g
to indicate an adjunction.

18
Categories
Here we use the more common notation and write
S
f ∗
-

f∗
T
to indicate an adjunction f ∗⊣f∗. Sometimes a harpoon arrow
S
f ∗⊣f∗⇀T
is used to indicate an adjunction. By convention, an adjunction points in the
direction of its left component. Thus S is the source and T is the target. (You
are warned that in some of the older literature this convention hadn’t yet been
established.)
Poset adjunctions are the arrows of Pos⊣.
This gives us the object and arrows of Pos⊣, but we still have some work
to do before we know we have a category.
Consider a pair of adjunctions.
R
f ∗⊣f∗⇀S
g∗⊣g∗⇀T
which ought to be composible. How should the composite
R
(g∗⊣g∗) ◦(f ∗⊣f∗) ⇀T
be formed? The two left hand components are monotone maps that compose to
give a monotone map. Similarly the two right hand components are monotone
maps that compose to give a monotone map. Thus we have a pair of monotone
maps
R
g∗◦f ∗
-

f∗◦g∗
T
going in opposite directions. We check that this is an adjunction and take that
as the composite. Almost trivially, this composition is associative, and so we
do obtain a category.
It is not so surprising that any given monotone map may or may not have a
left adjoint, and it may or may not have a right adjoint. It can have neither, and
it can have one without the other. What is a little surprising is that it can have
both adjoints where these are not the same. In fact, arbitrarily longs strings of
adjoints can be produced. A simple example of this is given in Chapter 6.
Once we become familiar with categories we ﬁnd that old categories can be
used to produce new categories. Let’s look at some examples.

1.3. An arrow need not be a function
19
1.3.4 Example
Consider categories C and D. To help us distinguish be-
tween these let us write
A, B, C. . . for objects of C
f, g, h . . . for arrows of C
R, S, T . . . for objects of D
θ, φ, ψ. . . for arrows of D
respectively. We form a new category, the product
C × D
of C and D as follows. Each new object is an ordered pair of old objects
(A, R)
an object A from C and an object R from D. A new arrow
(A, R)
- (B, S)
is a pair of old arrows
A
f
- B
R
θ
- S
from the given categories. For composible new arrows
(A, R)
(f, θ)- (B, S
(g, φ)- (C, T)
the composite
(A, R) (g ◦f, φ ◦θ)
- (C, T)
is formed using composition in the old categories. Almost trivially, this does
give a category.
That’s not the most exciting example you have ever seen, is it? Here is a
more interesting construction.
1.3.5 Example
Given a category C we form a new category where the new
objects are the arrows of C. This is the arrow category of C.
Consider the small graph
0
(↓)
1
?
with two nodes, here labelled 0 and 1, and with one edge. We use (↓) to convert
C into a new category
C ↓
the category of (↓)-diagrams in C.

20
Categories
We think of (↓) as a TEMPLATE for diagrams in C, and these diagrams are
the objects of C ↓. Thus a new object is a pair of old objects
A0
A1
α
?
and an old arrow between them. Given two new objects a new arrow
A0
B0
f
-
A1
α
?
B1
β
?
is a pair of old arrows
A0
f0 - B0
f1 ◦α = β ◦f0
A1
α
?
f1
- B1
β
?
such that the square commutes. Composition of new arrows is performed in the
obvious way, we compose the two component old arrows. You should check
that this does give a category.
This is a simple example of a much more general construction, that of a
FUNCTOR CATEGORY. We look at this once we know what a FUNCTOR is.
Other simple examples of this construction are given in the exercises.
The idea of the previous example is to view all the arrows of the old category
as the objects of the new category. Sometimes we want to do a similar thing
but using only some old arrows.
1.3.6 Example
Given a category C and an object S we form the two slice
categories
(C ↓S)
(S ↓C)
of objects
over S
under S

1.3. An arrow need not be a function
21
respectively. Each object of the new category is an arrow
to S
from S
A
S
S
α
?
A
α
?
of C. An arrow of the new category
A
B
S
S
f
-
f
-
S
α
?
S
β
?
A
α
?
B
β
?
is an arrow of C
A
f
- B
S
S
β

α
-
A
f
-
α

B
β
-
for which the indicated triangle commutes. Composition of the new arrows is
obtained from composition of arrows in C
As with Example 1.3.5 this construction is a particular case of a more gen-
eral construction, that of a COMMA CATEGORY. Before we can explain that we
need to understand the notion of a FUNCTOR.
Exercises
1.3.1
Consider the strictly positive integers 1, 2, 3, . . . as objects. For two
such integers m, n let an arrow
n
- m
be an m × n matrix A (with real entries). Given two compatible matrices
n
B
- k
k
A
- m
let the composite
n
A ◦B- m
be the matrix product AB. Show that this gives a category.
Can you show that this example is a bit of a cheat?

22
Categories
1.3.2
A directed graph, or simply a graph for short (and sometimes called
a network), is a pair
(N, E)
of sets together with a pair of assignments
E
σ
-
τ
- V
(as with a category). Each member of N is a node, and each member of E is
an edge. For each edge e ∈E we call
σ(e)
τ(e)
the source node and the target node of e, and we write
a
e
- b
to indicate that σ(e) = a and τ(e) = b. In general there are no other conditions
on these edges and nodes. In particular, there is no notion of composing edges.
Notice that (modulo size) each category is a graph.
A graph morphism
(N, E)
f- (M, F)
is a pair of functions
N
f0 - M
E
f1 - F
such that
σ ◦f1 = f0 ◦σ
τ ◦f1 = f0 ◦τ
hold. Of course, here there are two different source and two different target
assignments.
Show that, with the appropriate notion of composition, graphs and their mor-
phisms form a category.
1.3.3
Consider any pair of categories A and S. We form a new category. The
new objects are pairs
(A, R)
where A is an A-object and R is an S-object. A new arrow
(A, R)
(f, φ)- (B, S)

1.3. An arrow need not be a function
23
is a pair of arrows
A
f
- B
R 
φ
S
from the two component categories where the S-arrow goes backwards.
Show that with the obvious composition this does form a category.
1.3.4
As in Exercise 1.2.8, each monoid R gives us a category Set-R of
(right) R-sets. We can also vary R to produce a larger category.
Each object is a pair
(A, R)
where R is a monoid and A is an R-set. Each arrow
(A, R)
(f, φ)- (B, S)
is a pair
A
f
- B
R 
φ
S
where φ is a monoid morphism and f is a function with
f(aφ(s)) = f(a)s
for each a ∈A and s ∈S.
Using the obvious composition, show that this does give a category.
1.3.5
Consider the category RelA of Example 1.3.2.
Show the deﬁned composition is associative, and so it is a category.
Show also that
Γ(g ◦f) = Γ(g) ◦Γ(f)
for each pair of composible Set-arrows.
1.3.6
Consider any pair of Pos-arrows.
S
f
-

g
T
(a) Show that f ⊣g precisely when both idS ≤g ◦f and f ◦g ≤idT ,
where the two comparisons are pointwise.
(b) Show that if f ⊣g then
f ◦g ◦f = f
g ◦f ◦g = g
and hence g ◦f is a closure operation on A and f ◦g is a co-closure operation
on B.

24
Categories
1.3.7
Posets and certain adjoint pairs form another category Pospp.
The objects of Pospp are again just posets. A Pospp-arrow
A =======
(f, g)
⇒B
is a Pos⊣-arrow
A
f ⊣g ⇀B
for which g ◦f = idA. These arrows are sometimes called projection pairs.
Show that these projection pairs are closed under composition, and hence
Pospp is a category.
You see here a useful little trick. It can be helpful to draw arrows in different,
but related, categories in a different way. Thus here we have
Pos
-
Pos⊣
⇀
Pospp
=========⇒
for the three different kinds of arrows.
1.3.8
Consider the ordered sets Z and R as posets, and let
Z
ι
- R
be the insertion.
(a) Show there are (unique) maps
R
λ
-
ρ
- Z
such that
Z
ι ⊣ρ ⇀R
λ ⊣ι ⇀Z
are adjunctions.
(b) Show also that this composite is idZ in Pos⊣and the other composite,
on R, is idempotent.
(c) Show that ι ⊣ρ is a Pospp-arrow, but λ ⊣ι is not.
1.3.9
For a poset S let LS be the poset of lower sections under inclusion. (A
lower section of S is a subset X ⊆S such that
y ≤x ∈X =⇒y ∈X
for all x, y ∈S.)

1.3. An arrow need not be a function
25
(a) For a monotone map
T
φ
- S
between posets, show that setting f = φ←(the inverse image map) produces
a monotone map
LT  f = φ←
LS
in the opposite direction.
(b) Show that f has both a left adjoint and a right adjoint
f ♯⊣f ⊣f♭
where, in general, these are different.
1.3.10
Let C be an arbitrary category. In Example 1.3.5 we used (↓) as a
template to obtain a category C ↓of certain diagrams from C. The same idea
can be used with other templates.
A wedge in a category C is a pair or arrows
A0
A1

A2
-
as shown. A wedge morphism
A0
f0
- B0
A2
f1
-
- B2
-
A1
?
f1
- B1
?
is a triple of arrows which make the two associated squares commute.
(a) Show that wedges and wedge morphisms form a category.
(b) This wedge example uses
•
•

•
-
as the template. Play around with other templates to produce other examples

26
Categories
of categories. For example, consider each of
•
•
•
•
-
•
-
•
-

•
-
•

•
-
•
-

and worry about which cells are required to commute.
1.3.11
Let 1 and 2 be the 1-element set and the 2-element set, respectively.
Describe the categories
(Set ↓1)
(1 ↓Set)
(Set ↓2)
(2 ↓Set)
and show that you have met two of them already together with near relatives
of the other two.
1.3.12
Given a category C and two objects S, T we form
S
A
αS
?
T
αT
?
S
S
A
αS
?
f
- B
βS
?
T
αT
?
T
βT
?
(S ↓C ↓T)
the butty category between S and T. Each object
of the new category is an object A of C together
with a pair of arrows from S and to T. An arrow of
the new category is an arrow f of C to make the
two triangles commute.
S
A
f
-
αS

B
βS
-
T
βT

αT
-
(a) Show that with the appropriate notion of
composition this gives a category.
(b) Can you show that for an appropriate parent
category C both the slice categories
(C ↓T)
(S ↓C)
are instance of the butty construction?

1.4. More complicated categories
27
1.4 More complicated categories
From the examples we have seen so far you might conclude that category the-
ory is making a bit of a fuss. It is true that objects are not just structured sets
and arrows are not just functions, but the examples seem to suggest that we
don’t move too far from those ideas. Of course, as yet we have seen only com-
paratively simple examples of categories. One of the original aims of category
theory was to organize and analyse what we now see as rather complicated
categories. The simpler examples came along later. In this section we look at
a couple of examples of the more complicated kind of category. You proba-
bly won’t understand these at a ﬁrst reading, but you should give it a go. You
should come back to these examples as you learn more about category theory.
1.4.1 Example
Let S be any partially ordered set. We describe the category
bS of PRESHEAVES ON S. There is a more general notion where S is replaced
by an arbitrary category, but we save that for later. We may think of bS as the
category of ‘sets developing over S’. At ﬁrst sight the structure of bS looks
quite complicated, but you will get used to it.
We think of S as a store of indexes i, j, k, . . . partially ordered
j ≤i
to form a poset.
A presheaf on S is an S-indexed family of sets
A
 A(i) | i ∈S

together with a family of connecting functions
A
A(i)
A(j, i)- A(j)
one for each comparison j ≤i. Note these functions progress down the poset.
These functions have to ﬁt together in a coherent fashion. Thus
A(i, i) = idA(i)
for each index i ∈S, and the triangle
A(i)
A(k, i)
- A(k)
A(k, j) ◦A(j, i) = A(k, i)
A(j)
A(k, j)
-
A(j, i)
-
commutes for all k ≤j ≤i. These are the objects of bS . Note the way the
connecting functions are indexed.

28
Categories
An arrow
A
f
- B
between two presheaves is an S-indexed family of functions
A(i)
fi - B(i)
such that
A(i)
fi - B(i)
j ≤i
fj ◦A(j, i) = B(j, i) ◦fi
A(j)
A(j, i)
?
fj
- B(j)
B(j, i)
?
commutes for all comparisons j ≤i in S. These arrows are composed in
the obvious way, we compose the corresponding functions at each index. Of
course, we have to show that the resulting squares commute, and that this com-
position is associative, but that is straightforward.
In the previous example we used a poset S to index the constructed category
bS . There is also a more general construction which converts an arbitrary cat-
egory C into the category c
C of presheaves of C. We look at that brieﬂy in
Section 3.5. Such presheaf categories occur in many places, and are not always
recognized as such. For instance, Set-R and Mod-R are two such categories.
The next example is important in homology.
1.4.2 Example
Let R be a ﬁxed ring and consider the category
Mod-R
of right R-modules. If you are not yet happy with Mod-R then you can replace
it by the category AGrp of abelian groups. We construct a new category
Ch(Mod-R)
out of the objects and arrows of Mod-R.
A chain complex, sometimes called a complex, over R is a Z indexed
family
A
· · ·
- An+1
αn+1- An
αn- An−1
- · · ·
of objects and connecting arrows taken from Mod-R. These arrows have to
satisfy a certain condition which we come to in a moment.

1.4. More complicated categories
29
...
An+1
?
An
αn+1 ?
An−1
αn ?
...
?
Note the indexing of the objects. The indexes become smaller
as we move along the chain to the right. For this reason it
is sometimes convenient to think of the chain as progressing
downwards. However, for obvious reasons, a chain is rarely
printed in this form.
Also, it is customary to write d• for each connecting arrow
α• but in the ﬁrst instance that can be confusing.
The value of each index is important. If we re-index by mov-
ing each object 1-step along, then we get a different complex.
In particular, the object A0 plays a special role in the complex.
If we change the indexing then that role is give to a different
object, and we have a different complex.
The connecting arrows α• must interact in a simple way.
Given objects B and C of Mod-R the zero arrow
B
0
- C
sends each element of B to the zero element of C. (Strictly speaking, we should
label each zero arrow with its source and target, but that gets a bit cumber-
some.) Consecutive connecting arrows in the complex are required to compose
to 0, that is
αn ◦αn+1 = 0
for each n ∈Z.
Each complex A is an object of the new category Ch(Mod-R). Let’s call
it an Object to distinguish it from an object of Mod-R.
Given two Objects A and B, complexes from Mod-R, what is an Arrow
A
f
- B
in Ch(Mod-R)? It is an indexed family of arrows of Mod-R
An+1
fn+1- Bn+1
An
αn+1
?
fn
- Bn
βn+1
?
An−1
αn
?
fn−1- Bn−1
βn
?

30
Categories
such that at each step the corresponding square commutes, that is
fn ◦αn+1 = βn+1 ◦fn+1
for each n ∈Z. (This is why we choose to write α rather than the customary d
for the connecting arrows.)
The structure of Ch(Mod-R) is now more or less obvious.
Given a pair
A
f
- B
g
- C
of Arrows, we have commuting squares
An+1
fn+1- Bn+1
gn+1- Cn+1
An+1
gn+1 ◦fn+1- Cn+1
An
αn+1
?
fn
- Bn
βn+1
?
gn
- Cn
γn+1
?
An
αn+1
?
gn ◦fn
- Cn
γn+1
?
as on the left, and the horizontal components of these compose in Mod-R
to give commuting squares as on the right. All these composites in Mod-R
provide the composite
A
g ◦f - C
in Ch(Mod-R).
Verifying that Ch(Mod-R) is a category is now straight forward. It is a
simple exercise in diagram chasing which we look at in Section 2.1.
The gadget Ch(Mod-R) is central to homology theory. But what is the
point of setting it up as a category? It is because some of its properties can be
analysed by arrow-theoretic methods without getting inside the internal struc-
ture of its Objects and Arrows. This is beyond the scope of this book, but not
that far beyond.
Exercises
1.4.1
Try to understand Example 1.4.1. To help with this consider the par-
ticular cases where S is a 2-element set partially ordered in the two different
ways.
1.4.2
Try to understand Example 1.4.2. To help with this consider the com-
plexes A where only A−1, A0, A1 are non-trivial.

1.5. Two simple categories and a bonus
31
1.5 Two simple categories and a bonus
As we are going to see in a moment, every monoid is a category with a simple
object structure, and every preset is a category with a simple arrow structure.
Every category is a certain kind of amalgam of monoids and presets. Thus
whenever you meet a new categorical notion it is worth trying it out on monoids
and presets. Sometimes this gives a little bit of insight and sometimes not.
1.5.1 Example
Each monoid (R, ·, 1) can be viewed as a category with just
one object. It doesn’t matter what this object is, and it doesn’t have any internal
structure. Let’s use
⋆
for this symbolic object. Don’t confuse this with the monoid R.
For each r ∈R there is an arrow
⋆
r
- ⋆
and again this has no internal structure. In other words the arrows of the cate-
gory are the elements of R. Composition of arrows is just the carried operation
of R.
⋆
⋆
s ◦r = sr
-
r
-
⋆
s
-
The identity arrow
id⋆= 1
is just the unit of R. This construction does produce a category because the
operation on R is associative and 1 is a unit.
On its own this example is rather trite, but later we will add to it to illustrate
several aspects of category theory.
1.5.2 Example
Each pre-ordered set (S, ≤) can be viewed as a category. The
objects are the elements
i, j, k, . . .
of S. Given a pair of objects i, j there is an arrow
i
- j
precisely when i ≤j. Thus between any two objects there is at most one

32
Categories
arrow. The existence of the arrow indicates a comparison between the objects.
It is sometimes convenient to write
i
(j, i) - j
for this arrow. We have
idi = (i, i)
since
i ≤i
(k, j) ◦(j, i) = (k, i)
since
i ≤j ≤k ⇒i ≤k
so the construction does give a category.
Again this example looks rather feeble, but again we will add to it later to
produce more interesting structures.
In Sections 1.3 and 1.4 we saw various ways of producing a new category
out of old categories. There is one very simple example of such a construction.
This could have been presented earlier, but we have saved it until the end of
this chapter.
1.5.3 Example
Each category C is a collection of objects and a collection
of arrows with certain properties. In particular, each arrow
A
f
- B
has an assigned source and an assigned target. A formal trick converts C into
another category C
op called the opposite of C. This category C
op has the
same objects as C. Each arrow f of C, as above, is turned into its formal dual
B
f
op
- A
to produce an arrow of C
op. The formal composition of these formal arrows is
deﬁned by
f
op ◦
op g
op = (g ◦f)
op
for each composible pair
A
f
- B
g
- C
of arrows from the parent category C. A routine exercise (which you should
go through at least once) shows that C
op is a category.
The process f
> f
op doesn’t actually do anything to the arrows. We

1.5. Two simple categories and a bonus
33
merely decide that the words ‘source’ and ‘target’ should mean their exact op-
posites. Thus the change is merely formal rather than actual. This trick shows
there is a lot of duality in category theory. Notions often come in dual pairs
dog
god
where a dog of a category C is nothing more than a god of its opposite category
C
op. We will see many examples of this, and not just when it is raining cats
and dogs.
Sometimes the opposite category C
op has properties rather different to the
parent C. For instance Set
op is isomorphic to the category of complete, atomic
boolean algebras and complete morphisms. As a simpler version of this the
opposite of the category of ﬁnite sets is the category of ﬁnite boolean algebras.
(Both of these observations are instances of Stone duality.)
Exercises
1.5.1
(a) Let R and S be monoids viewed as categories. What is the product
category?
(b) Let R and S be presets viewed as categories. What is the product cate-
gory?
1.5.2
Let S be a preset viewed as a category.
For an arbitrary element s ∈S what are the slice categories (S ↓s) and
(s ↓S)?
For arbitrary elements s, t ∈S what is the butty category (s ↓S ↓t)? Be
careful.
1.5.3
Each poset S is a category. What is the opposite S
op?
Each monoid R is a category. What is the opposite R
op?
1.5.4
Give a short and precise description of the category constructed in Ex-
ercise 1.3.3.

2
Basic gadgetry
In this chapter we describe some of the basic gadgets of category theory. We
meet notions such as
diagram
monic
epic
split monic
split epic
isomorphism
initial
ﬁnal
wedge
product
coproduct
equalizer
coequalizer
pullback
pushout
universal solution
some of which are discussed only informally. All of these notions are impor-
tant, and have to be put somewhere in the book. It is more convenient to have
them together in one place, and here seems the ‘logical’ place to put them.
However, that does not mean you should plod through this chapter section by
section. I suggest you get a rough idea of the notions involved, and then go to
Chapter 3 (which discusses more important ideas). You can come back to this
chapter to ﬁll in the missing details.
2.1 Diagram chasing
As in many parts of mathematics, in category theory we sometimes have to
show that two things are equal. We don’t often, or even ever, have to show that
two objects are the same, but we often have to show that two arrows are equal.
The main technique for doing that is diagram chasing.

2.1. Diagram chasing
35
Roughly speaking, a diagram in a category is a collection of objects to-
gether with a collection of arrows between these objects.
For instance, the following diagram
•
•
f
-
•
g
-
•
h
?
l
-
k
-
has four objects (unnamed) and ﬁve arrows f, g, h, k, l. There are also ﬁve
composite arrows
g ◦f
h ◦f
l ◦h ◦f
l ◦h
l ◦k
and some of these may be equal. This diagram has three cells; the left hand
triangle, the right hand triangle, and the outer rectangle (lozenge). Some of
these cells may commute.
• The left hand triangle commutes if h ◦f = k.
• The right hand triangle commutes if l ◦h = g.
• The outer cell commutes if g ◦f = l ◦k.
Roughly speaking a diagram chase is a process by which we show that a
particular cell commutes knowing that other cells commute and using certain
other properties of the diagram.
2.1.1 Example
For the diagram above, if the two triangles commute then the
outside cell commutes. We are given that
h ◦f = k
l ◦h = g
and we must show that
g ◦f = l ◦k
holds. We can do that by equational reasoning. Thus
g ◦f = (l ◦h) ◦f = l ◦(h ◦f) = l ◦k
is a more or less trivial calculation.
However, it is more common to do this by chasing round the diagram and
noting that certain composites are equal. Thus
•
•
•
f
-
•
g
-
=
•
f
-
•
=
•
•
•
h
?
l
-
•
l
-
k
-
is what we trace out with our pencil and think whilst we are doing it.

36
Basic gadgetry
Since this example is so trivial it doesn’t matter which method we use. For
larger diagrams the chase is often easier to explain when talking to someone.
This is a bit unfortunate since no-one has yet devised a method of writing down
a diagram chase in an efﬁcient manner.
Even with this simple diagram there are other questions to ask.
2.1.2 Example
Consider the small diagram above.
(a) If the outer cell commutes then neither of the two triangles need com-
mute. This is because we could replace h by some other arrow without altering
f, g, k, l.
(b) If the outer cell commutes and the right hand triangle commutes, then
the left hand triangle need not commute. It is not hard to ﬁnd an appropriate
example in Set. Simply let l collapse a lot of elements to the same element.
(c) If the outer cell commutes, the right hand triangle commutes, and l is
MONIC, then the left hand triangle also commutes. We deal with this in the
next section.
(d) If the outer cell commutes and the left hand triangle commutes, then
the right hand triangle need not commute. It is not hard to ﬁnd an appropriate
example in Set. Simply let the range of f be a small part of its target.
(e) If the outer cell commutes, the left hand triangle commutes, and f is
EPIC, then the right hand triangle also commutes. We deal with this in the next
section.
We will take part in many diagram chases. For now I leave you with a couple
of simple exercises and one that you might think is a bit devilish.
Exercises
2.1.1
Consider the following diagram.
•
g
- •
•
-
f
-
•
-
-
-
•
h
-
•
l
-
k
-
Show that if the four inner triangles commute, then so does the outer cell. Write
down the argument in the form of equational reasoning and in a pictorial form
of a diagram chase.

2.2. Monics and epics
37
2.1.2
Consider the triangular pyramid of arrows.
•
•

- •
-
•
-
-
-
Show that if the three other faces commute then the back face commutes.
2.1.3
Consider a pentagram inscribed in a pentagon.
4
2 
-
1
-
5 

-

3


-
Suppose that the following triangles commute.
123
345
512
234
451
Show that a trip twice round the pentagram is equal to a trip once round the
pentagon.
2.2 Monics and epics
It is clear, as someone once said, that in the great categorical menagerie all
arrows have equal status, but some have more status than others. In this section
we look at some of these special arrows.
2.2.1 Deﬁnition
In a category an arrow
B
m - A
A
e
- B
is, respectively,
monic
epic
if for each parallel pair of arrows
X
f
-
g
- B
B
f -
g
- X
we have
m ◦f = m ◦g =⇒f = g
f ◦e = g ◦e =⇒f = g
as appropriate.

38
Basic gadgetry
What are we getting at here? The following example gives the precursors of
monics and epics, but you mustn’t read too much into it. Later we will see that
it can suggest quite a false story.
2.2.2 Example
Consider a category of structured sets. Each arrow is (carried
by) a total function between the carriers of the two objects.
(m) If
B
m - A
is injective as a function then it is monic as an arrow. To see this suppose
m ◦f = m ◦g
for some parallel pair
X
f
-
g
- B
of arrows. We require f = g. Thus, since f and g are total functions it sufﬁces
to show
f(x) = g(x)
for each x ∈X. We have
m(f(x)) = (m ◦f)(x) = (m ◦g)(x) = m(g(x))
for each such x. But m is injective, that is
m(b1) = m(b2) =⇒b1 = b2
for b1, b2 ∈B, to give the required result.
(e) If
A
e
- B
is surjective as a function then it is epic as an arrow. To see this suppose
f ◦e = g ◦e
for some parallel pair
B
f
-
g
- X

2.2. Monics and epics
39
of arrows. We require f = g, that is
f(b) = g(b)
for each b ∈B. Consider any such b ∈B. Since e is surjective we have
b = e(a) for some a ∈A. But now
f(b) = f(e(a)) = (f ◦e)(a) = (g ◦e)(a) = g(e(a)) = g(b)
to give the required result.
These examples show that
injective =⇒monic
surjective =⇒epic
for appropriately nice categories. However, you are warned. Even in nice cate-
gories these implications can be far from equivalences. There are several quite
common categories of structured sets in which an epic arrow need not be sur-
jective. Roughly speaking an arrow
A
e
- B
is epic if the range e[A] of e is a ‘large part’ of B. Exercises 2.2.5, 2.2.6,
and 2.2.8 give examples of this. Of course, in many categories the notions of
‘injective arrow’ and ‘surjective arrow’ don’t make sense.
Monics and epics are those arrows that can be cancelled on one side or
the other. If an arrow has a 1-sided inverse than it can be cancelled on the
appropriate side. This gives us special classes of monics and epics.
2.2.3 Deﬁnition
A pair of arrows
B
s
- A
A
r
- B
such that
r ◦s = idB
are a
section
retraction
respectively (as indicated by the initial letter).
It is not hard to show that each section is monic and each retraction is epic.
For this reason such an arrow is often referred to as a
split monic
split epic
respectively. In some ways this is better terminology.

40
Basic gadgetry
As we said at the beginning of Section 2.1 rarely do we need to show that
two objects of a category are the same. But we often have to show they are
isomorphic.
2.2.4 Deﬁnition
A pair of arrows
B
g
- A
A
f
- B
such that
g ◦f = idA
f ◦g = idB
form an inverse pair of isomorphisms. Each arrow is an isomorphism.
An arrow is an isomorphism if it has a 2-sided inverse, and hence each iso-
morphism is both a split monic and a split epic. This gives us a short hierarchy
of kinds of arrows.
Arrow
Monic
⊂
-
Epic

⊃
Bimorphism
⊂
-

⊃
Split monic
∪
6
Split epic
∪
6
Isomorphism
∪
6
⊂
-

⊃
It is easy to see that an arrow that is both a split monic and a split epic is
automatically an isomorphism (and there is a stronger result). However, an
arrow that is both monic and epic need not be an isomorphism.
2.2.5 Deﬁnition
A bimorphism is an arrow that is monic and epic.
Each isomorphism is a bimorphism, but there can be bimorphisms which are
not isomorphisms.
A category is balanced if each bimorphism is an isomorphism.
Monics and epics often have a role to play in a diagram chase. There are
some exercises to illustrate this.
Exercises
2.2.1
(a) Show that
section =⇒monic
retraction =⇒epic
section + epic =⇒isomorphism
retraction + monic =⇒isomorphism

2.2. Monics and epics
41
that is show that if an arrow satisﬁes the hypothesis then it satisﬁes the conclu-
sion.
(b) Show that if arrows
B
g
- A
f
- B
h
- A
satisfy
h ◦f = idA
f ◦g = idB
then g = h, and each arrow is an isomorphism.
2.2.2
(a) Consider a preset as a category. Show that every arrow is a bimor-
phism.
(b) When is a poset balanced and when is a preset balanced?
2.2.3
Consider a monoid as a category. Which of the elements (when viewed
as arrows) are monic, epic, a retraction, a section, an isomorphism? When is a
monoid balanced?
2.2.4
Consider a composible pair of arrows.
A
m - B
n
- C
Show that if both m and n are monic, then so is the composite n ◦m.
Show that if the composite n ◦m is monic, then so is m.
Find an example where the composite n ◦m is monic but n is not.
State the corresponding results for epics.
Obtain similar results (where possible) for the other classes of arrows dis-
cussed in this section.
2.2.5
Consider the category Mon of monoids, and view N and Z as addi-
tively written monoids. Show that the insertion
N ⊂
e
- Z
is epic.
2.2.6
Consider the category Rng of rings. Show that the insertion
Z ⊂
e
- Q
is epic.

42
Basic gadgetry
2.2.7
(a) Let C be a category of structured sets. Suppose C has a partic-
ular object S which has a special element ⋆(usually not part of the ofﬁcial
furnishings) such that for each object A and element a ∈A, there is a unique
arrow
S
α
- A
with α(⋆) = a. Show that in C each monic is injective.
(This is a particular instance of a more general notion called a selector, or
sometimes a generator.)
(b) Show that in
Set, Pos, Top, Mon, Grp, Rng, Set-R
each monic is injective.
2.2.8
(a) In Top an isomorphism is usually called something else. What is
the name used?
Show that in Top each monic is injective.
Show that an arrow of Top that is bijective as a function need not be an
isomorphism.
(b) Let Top2 be the category of hausdorff spaces and continuous maps.
Show that the insertion
Q ⊂
e
- R
is epic in this category.
More generally, show that if
T
ϵ
- S
is an arrow of Top2 where the range ϵ[T] is dense in the target S, then ϵ is
epic.
If you are brave you can show that this result does not hold for Top1.

2.3. Simple limits and colimits
43
2.2.9
Consider the following cube of arrows a, b, . . . , l, m.
•
j
- •
•
g

c
-
m 6
•
k

•
f
6
l
- •
•
b 6
a
-
e

•
d
6
h

(e) Show that if e is epic and if the other ﬁve faces commute, then the back
face commutes.
(m) Show that if m is monic and if the other ﬁve faces commute, then the
bottom face commutes.
2.2.10
In the following diagram suppose the four trapeziums commute.
•
- •
•
-
e
-
•

•
?
- •
?
•
?
-
-
•
?
m
-
(a) Show that if the inner square commutes then so does the outer square.
(b) Conversely, show that if e is epic, m is monic, and the outer square
commutes, then so does the inner square.
2.3 Simple limits and colimits
Limits and colimits (of the categorical kind) occur all over mathematics, and
concrete examples of these notions were being used before category theory
was invented. Different areas of mathematics tend to use different terminology,
mainly for historical reasons rather than natural cussedness, but that is not too
important. It was one of the ﬁrst achievements of category theory to codify and
extract the essential content of these notions.

44
Basic gadgetry
Table 2.1 Some simple limits and colimits
Limit
Template
Colimit
(1)
ﬁnal object
initial object
•
(2)
binary product
binary coproduct
•
(3)
equalizer
•
-
- •
co-equalizer
•
(4)
pullback
•
-
•
-
•
(5)
•
-
pushout
•
-
In the next four sections we look at the basic examples of these notions, as
given in Table 2.1. These examples can be set in a more general context, but
we don’t attempt that just yet. However, we can look at a particular case of the
general notion which you already know about.
Let S be a poset viewed as a category. It is usual to think of the comparison
as progressing upwards, that is i ≤j means that i is below j. However, to ﬁt in
with the categorical picture we think of the comparison as progressing to the
right. Thus
i ≤j
i
- j
mean the same thing.
Let X be a subset of S. A
left solution
right solution
for X is an element a ∈S such that
a ≤x
x ≤a
for each x ∈X. A
limit
colimit

2.4. Initial and ﬁnal objects
45
is a ‘best possible’ solution on the appropriate side. In other words, it is a
solution a such that
b ≤a
a ≤b
for each solution b of the appropriate handedness.
You should recognize these notions under different names.
Exercises
2.3.1
For a poset what are the notions above usually called?
What happens if X is empty?
What happens if X is a singleton?
What happens if X is a pair of elements?
What differences might occur if S is a preset?
2.4 Initial and ﬁnal objects
In some categories some objects play special roles because they take up ex-
treme positions.
2.4.1 Deﬁnition
An object S of a category C is, respectively
initial
ﬁnal
if for each object A there is a unique arrow
S
- A
A
- S
as indicated. Here the uniqueness is important.
Sometimes a ﬁnal object is said to be terminal.
You may not know this terminology, but you already know some examples.
2.4.2 Example
(a) Consider the category Set of sets and let
1 = {⋆}
be a singleton set. For each set A there is a unique arrow
A
- 1
the function that sends everything to ⋆. Thus 1 is a ﬁnal object of Set.
Let ∅be the empty set. You will probably have to think about this, but for
each set A there is a unique arrow
∅
- A

46
Basic gadgetry
(since the function doesn’t have any requirements that it must satisfy). Thus ∅
is an initial object of Set.
(b) Consider the category AGrp of abelian groups. Let O be the trivial
group. For each abelian group A, the group O is uniquely embedded in A, and
there is a unique morphism
A
- O
to O. Thus O is both initial and ﬁnal in AGrp.
A category C may or may not have an initial object. It may or may not have
a ﬁnal object. It can have one without the other. It can have both. If it has both
then these objects may or may not be the same. An object that is both initial
and ﬁnal is often called a zero object.
It is easy to show that any two initial objects of a category are uniquely
isomorphic. For this reason we usually speak of the initial object rather than an
initial object. In the same way, any two ﬁnal objects are uniquely isomorphic,
and we speak of the ﬁnal object.
It is common to let 1 be the ﬁnal object of a category (assuming this exists).
Because of certain special cases an arrow
1
a
- A
to an object A is a global element of A. For instance, in Set these pick out
the members of a set in the usual sense. In more structured categories these can
pick out a special kind of member of an object.
Exercises
2.4.1
Show that in a category any two initial objects are uniquely isomorphic.
That is, if I, J are two initial objects, then there is a unique arrow I
- J,
and this is an isomorphism.
State and prove the dual result concerning ﬁnal objects.
2.4.2
Suppose that I is initial in C. Show that each C-arrow
A
- I
is a retraction. Prove the corresponding result for ﬁnal objects. Show that if C
has an initial object I and a ﬁnal object F and an arrow
F
- I
then I and F are isomorphic. In such a case we have a zero object.

2.5. Products and coproducts
47
2.4.3
Show that the category Pno has an interesting initial object but a bor-
ing ﬁnal object. What are these objects?
2.4.4
Show that the category Grp of groups has both an initial and a ﬁnal
object, and these are the same.
Show that the category Rng of unital rings has both an initial and a ﬁnal
object, and these are not the same.
Consider the categories Idm and Fld of integral domains and ﬁelds.
2.4.5
Show that for each set A there is a bijection between elements of A and
Set-arrows 1
- A. Show that for each pair of Set-arrows
A
f
- B
1
- A
where the second represents the element a ∈A, the composite
1
- A
f
- B
represents the element f(a) ∈B.
2.4.6
Let S be a poset and consider the category bS of presheaves over S (as
described in Example 1.4.1).
(a) Show that this category has a ﬁnal object 1.
(b) Show that for a presheaf A = (A, A) over S a global element 1
- A
is a kind of choice function for A. It ‘threads’ its way through the component
sets A(s). Make precise the notion of ‘thread’.
2.5 Products and coproducts
We all know how to form the cartesian product
A × B
of two sets A and B, the set of all ordered pairs
(a, b)
for a ∈A and b ∈B. We also know that often when A and B carry structures
of a similar kind, the product A × B can be furnished with the same kind of
structure. Groups, rings, topological spaces, and so on, provide examples of

48
Basic gadgetry
this. In these cases we ﬁnd that the two projections
(a, b)
A × B
a

A

B
-
b
-
are arrows in the appropriate category.
There is also a dual process which is not so clear.
Given two sets A and B we can form the disjoint union (sum)
A + B
of the sets, a larger set that includes copies of A and B with minimal interfer-
ence. Technically, we tag the elements of A and B to remember their origin,
and take the union of the tagged versions of the sets.
A + B =
 A × {0}

∪
 B × {1}

We then ﬁnd that the two embeddings
a
A
B
b
(a, 0)
-
A + B

-
(b, 1)

locate disjoint copies of the parent sets within the sum.
What about this dual process for structured sets? Given two groups, or two
rings, A and B, can we ﬁnd a group or ring that includes copies of A and B
with minimal interference? It can be done but we have to think a bit before we
spot the construction. If you don’t know how to do this then you should worry
about it for a while.
What we can do here is look at a variant of this dual problem. Given two
abelian groups A and B we wish to ﬁnd an abelian group that includes copies
of A and B with minimal interference. This is easier.
Let’s suppose the two abelian groups are written multiplicatively. Thus
(A, ·, 1)
(B, ·, 1)
are the two structures. Let
A × B
be the cartesian product of these two groups. This, of course, is also an abelian

2.5. Products and coproducts
49
group. We have four morphisms.
a
A
B
b
(a, 1)
-
A × B

-
(1, b)

(a, b)
A

a

b
-
B
-
The lower two are the projections. The upper two are the embeddings which
solve our problem.
There is something going on here, isn’t there? Category theory can help to
explain this. In all cases we are looking for a universal solution to a particular
kind of problem which comes in two forms, a left handed version and a right
handed version.
For the remainder of this section we ﬁx a category C, and we ﬁx a pair of
objects A and B of C. We place these as
A
B
to help with various diagrams we draw. (Just why we do this will become clear
when we look at more general constructions in Chapter 5.)
We are going to look at the left handed version and the right handed version
of the problem in parallel. Thus each deﬁnition and result that we give is really
two deﬁnitions or results in one. The left hand side gives the left version and the
right hand side gives the right version (in the sense of ‘dexterous’ not ‘correct’).
2.5.1 Deﬁnition
For a pair A, B of objects of a category C, a wedge
to
from
the pair A, B is an object X together with a pair of arrows
A
A
X
-
X
-
B
-
B
-
in the parent category C.
Often a wedge of this kind is called a
cone
cocone

50
Basic gadgetry
depending on which side of the pair it lies. However, it is hardly worth remem-
bering which is which so we call both a wedge.
For a given pair there may be many wedges on one side or the other. We
look for a ‘best possible’ wedge, one that is as ‘near’ the pair as possible.
Technically, we look for a universal wedge. You will probably need to read
this next deﬁnition several times. Remember also that it is two deﬁnitions in
one, so in the ﬁrst instance concentrate on one side.
2.5.2 Deﬁnition
Given a pair A, B of objects of a category C, a
product
coproduct
of the pair is a wedge
A
A
S
pA
-
S
iA
-
B
pB
-
B
iB
-
with the following universal property.
For each wedge
A
A
X
fA
-
X
fA
-
B
fB
-
B
fB
-
there is a unique arrow
X
m - S
S
m - X
such that
A
A
X
m-
fA
-
S
pA
6
S
iA
?
m- X
fA
-
B
pB
?
fB
-
B
iB
6
fB
-
commutes. This arrow m is the mediating arrow (or mediator) for the wedge
on X.

2.5. Products and coproducts
51
There are a couple of things about this deﬁnition that you should notice.
Firstly, a product or coproduct is not just an object. It is an object furnished
with a pair of arrows. Secondly, the mediator is unique for the given wedge on
X. This has some important consequences.
2.5.3 Lemma
Let
A
A
S
pA
-
S
iA
-
B
pB
-
B
iB
-
be a
product
coproduct
wedge in the category C. Let
S
k
- S
be any endo-arrow of S for which
pA = pA ◦k
k ◦iA = iA
pB = pB ◦k
k ◦iB = iB
hold. Then k = idS.
Proof
We consider the given wedge both as a special wedge and as an arbi-
trary wedge. Thus there is a unique arrow, the mediator, such that
A
A
S
m-
pA
-
S
pA
6
S
iA
?
m- S
iA
-
B
pB
?
pB
-
B
iB
6
iB
-
commutes. Since idS makes these diagram commute we have m = idS. But
the arrow k makes this diagram commute, and hence k = idS.
This result leads to the essential uniqueness of the universal solution.

52
Basic gadgetry
2.5.4 Lemma
For objects A, B in a category C let
P
I
A
pA
-
A
iA
-
B
pB
-
B
iB
-
Q
qA
-
qB
-
J
jA
-
jB
-
be a pair of
product
coproduct
wedges. Then
P, Q
I, J
are uniquely isomorphic over the wedges. There are unique arrows
P
I
Q
f
?
g
6
J
f
?
g
6
such that
(1)
pA = qA ◦f
pB = qB ◦f
(3)
iA = g ◦jA
iB = g ◦jB
(2)
qA = pA ◦g
qB = pB ◦g
(4)
jA = f ◦iA
jB = f ◦iB
and in particular f and g are an inverse pair of isomorphisms.
Proof
We look at the product, left hand, version and leave the coproduct ver-
sion as an exercise.
The object Q and the pair qA, qB form a product wedge for A, B. The object
P and the pair pA, pB form an arbitrary wedge for A, B. Thus there is a unique
mediator f satisfying (1). By reversing the roles of P and Q there is a unique
mediator satisfying (2). From (1) and (2) we have
pA ◦g ◦f = qA ◦f = pA
pB ◦g ◦f = qB ◦f = pB
so that a use of Lemma 2.5.3 gives the left hand equality
g ◦f = idP
f ◦g = idQ
and the right hand equality follows by a similar argument.

2.5. Products and coproducts
53
The left hand part of this result shows that if a pair of objects has a product
then that gadget is essentially unique. Thus we often speak of the product of a
pair. Similarly, from the right hand part of this result, we speak of the coproduct
of a pair of objects.
In some categories not all products or coproducts exist. A pair of objects
may have one of these gadgets without the other. The pair may have both, or it
may have neither. The existence of products and coproducts in some particular
categories is looked at in Exercises 2.5.1 and 2.5.2. Here we look at a result
which relates the categorical notions to the concrete construction discussed at
the beginning of this section.
2.5.5 Lemma
Let A and B be a pair of sets. Then the
cartesian product
disjoint union
A × B
A + B
furnished with the canonical functions forms the
product
coproduct
of the pair in Set.
Proof
We look at the right hand, coproduct, version and leave the left hand
version as an exercise.
The elements of
A + B
are of two kinds
(a, 0) for a ∈A
(b, 1) for b ∈B
where the tag 0 or 1 records the parent of the element. The embeddings
A
iA(a) = (a, 0)
A + B
iA ?
iB(b) = (b, 1)
B
iB 6
merely tag the input. We must show that these form a coproduct wedge.

54
Basic gadgetry
Consider any wedge
A
X
fA
-
B
fB
-
to some set X. We deﬁne
A + B
m - X
by
m(a, 0) = fA(a)
m(b, 1) = fB(b)
for a ∈A and b ∈B. Trivially, the diagram
A
A + B
iA
?
m- X
fA
-
B
iB
6
fB
-
commutes. We must show that m is the only function that makes this diagram
commute.
Consider any function
A + B
h - X
with
h ◦iA = fA
h ◦iB = fB
that is h makes the diagram commute. For a ∈A and b ∈B we have
h(a, 0) = h(iA(a)) = (h ◦iA)(a) = fA(a) = m(a, 0)
h(b, 1) = h(iB(b)) = (h ◦iB)(b) = fB(b) = m(b, 1)
and hence h = m, as required.
We ﬁnish this section with a few remarks on terminology and notation.
Strictly speaking the two notions we have described here are the
binary product
binary coproduct

2.5. Products and coproducts
55
respectively. There are more general notions that deal with an arbitrary number
of objects, not just two. The notations
A × B
A + B
A
Q B
A
` B
are used for the object associated with the constructed wedge. Of course, a use
of ‘×’ does not mean that the object is constructed using a cartesian product.
In some categories the product and the coproduct produce the same object (but
not the same structuring arrows). For such cases
A ⊕B
is a common notation. This is sometimes called a biproduct.
Exercises
2.5.1
As well as Top, choose a selection of the following categories.
Set, CMon, Mon, AGrp, Grp, CRng, Rng, Set-R, Mod-R, Pos
Show that each category has all binary products, and that each is given by a
cartesian product with the obvious projections.
2.5.2
Show that each of
Set, Pos, CMon, AGrp, Set-R, Mod-R, Top
has all binary coproducts.
Can you spot any similarities between the various constructions?
2.5.3
Each poset is a category.
What is the product of two elements?
What is the coproduct of two elements?
2.5.4
Show that Set⊥has all binary products and binary coproducts.
2.5.5
Consider the category SetD of sets with a distinguished subset.
Does this category have binary products.
Does it have binary coproducts.
2.5.6
Consider the category RelA of sets and relations of Example 1.3.2.
Show this has all binary products and coproducts and give a description of
them. (The product is not given by a cartesian product.)

56
Basic gadgetry
2.5.7
Let C be a category with a ﬁnal object 1 and all binary products.
(a) Show that for each object A the three objects 1 × A, A, A × 1 are iso-
morphic.
(b) Show that for each triple A, B, C of objects, the two objects
(A × B) × C
A × (B × C)
are isomorphic.
2.5.8
Let C be a category with all binary products and coproducts. For ob-
jects A, B, C let
L = A × C + B × C
R = (A + B) × C
to form two more objects. Show there is an arrow
L
- R
and ﬁnd an example to show that there need not be an arrow R
- L.
2.5.9
In the category AGrp of abelian groups the cartesian product of two
objects implements both the product and the coproduct. Does this work in
Grp?
Consider the cartesian product A × B of two abelian groups. This gives the
coproduct of A and B in AGrp. Does this give the coproduct of A and B in
Grp?
2.6 Equalizers and coequalizers
When we ﬁrst see their categorical deﬁnition, equalizers and coequalizers are
not something we immediately relate to our previous mathematical experience.
They are a couple of notions which help in certain categorical situations. How-
ever, once we become familiar with the idea we begin to realize that we have
seen particular instances of the notions.
There are two notions here, the left notion and the right notion. We develop
the two versions in parallel. For instance, the following deﬁnition is two deﬁni-
tions in one. As with other parallel developments, at a ﬁrst reading concentrate
on one side. Once you understand that come back and do the other side. In this
instance I suggest that the left hand, equalizing, side is easier to begin with.
2.6.1 Deﬁnition
Given a parallel pair
A
f
-
g
- B

2.6. Equalizers and coequalizers
57
of arrows in a category C, an arrow
X
h
- A
B
h
- X
makes equal the parallel pair if
f ◦h = g ◦h
h ◦f = h ◦g
that is, the two composite arrows
X
f ◦h-
g ◦h
- B
A
h ◦f -
h ◦g
- X
agree.
Any given parallel pair could be made equal, on one side or the other, by
many different arrows. We look for a ‘best possible’ coalescing arrow.
2.6.2 Deﬁnition
Given a parallel pair
A
f
-
g
- B
of arrows in a category C,
an equalizer
a coequalizer
is an arrow
S
k
- A
B
k
- S
which makes equal f and g, and has the following universal property.
For each arrow
X
h
- A
B
h
- X
which makes equal the parallel pair, there is a unique arrow
X
m - S
S
m - X
such that
h = k ◦m
h = m ◦k
holds. This m is the mediating arrow (or mediator) for the arrow h.

58
Basic gadgetry
Read this deﬁnition a couple of times and compare it with Deﬁnition 2.5.2.
Later, in Chapter 4, we will see that both notions are particular instances of a
more general notion.
For now we develop the idea of Deﬁnition 2.6.2. We follow a path quite
similar to that in Section 2.5. Here is the analogue of Lemma 2.5.3.
2.6.3 Lemma
Each equalizer is monic. Each coequalizer is epic.
The proof of this is similar to that of Lemma 2.5.3, so we leave it as an
exercise. We use the result to obtain the analogue of Lemma 2.5.4.
2.6.4 Lemma
For a parallel pair
A
f
-
g
- B
of arrows in a category C let
S
S
A
k
-
B
k
-
T
l
-
T
l
-
be a pair of
equalizers
coequalizers
respectively. Then S, T are uniquely isomorphic over the wedges, In other
words, there are unique arrows
S
T
m
?
n
6
such that
(1)
l = k ◦m
(3)
l = m ◦k
(2)
k = l ◦n
(4)
k = n ◦l
and in particular m and n are an inverse pair of isomorphisms.
Proof
We look at the coequalizer, right hand, version and leave the equalizer
version as an exercise.
The arrow l makes equal f and g. The arrow k is the coequalizer of f and
g. Thus there is a unique mediator m satisfying (3). By reversing the roles of l

2.6. Equalizers and coequalizers
59
and k we see there is a unique mediator n satisfying (4). From (3) and (4) we
have
n ◦m ◦k = n ◦l = k = idS ◦k
and hence
n ◦m = idS
since k is epic. Similarly
m ◦n = idT
to show that m and n are an inverse pair of isomorphisms.
The left hand part of this result shows that if a pair of arrows has an equalizer
then that gadget is essentially unique. Thus we speak of the equalizer of a pair.
Similarly, from the right hand part of this result, we speak of the coequalizer
of a pair of arrows.
Let’s now look at a few examples. Any given pair of arrows need not have
an equalizer, nor a coequalizer. In contrast to this for some categories these
gadgets always exist.
2.6.5 Example
Let
A
f
-
g
- B
be a parallel pair of functions, arrows in Set. Let
S = {a ∈A | f(a) = g(a)}
be the set of elements of A on which f and g agree. Then the insertion
S ⊂
i
- A
is the equalizer of f and g. To see that suppose the function
X
h
- A
makes equal f and g. For each x ∈X we have
f(h(x)) = (f ◦h)(x) = (g ◦h)(x) = g(h(x))
so that h(x) ∈S, and hence the function
X
m - S
x
- h(x)
is the required mediator.

60
Basic gadgetry
A similar idea can be used in several other categories.
The category Set also has all coequalizers. To obtain these we combine
two standard constructions which, at ﬁrst sight, seem to have little to do with
category theory. Almost certainly you will know the content of the following
example, but you may not have seen it set out like this.
2.6.6 Example
Let S be an arbitrary set, and let ∼be an equivalence relation
on S. This relation partitions S into blocks (equivalence classes). For each
s ∈S let [s] be the block in which s lives, and let
S/∼
be the set of all such blocks. Let
S
σ - S/∼
s
- [s]
be the induced surjection.
Let
S
h
- X
be any function. The kernel of h is the relation ≈on S given by
s2 ≈s2 ⇐⇒h(s1) = h(s2)
for s1, s2 ∈S. Trivially, this is an equivalence relation.
Now suppose ≈includes ∼, that is
s1 ∼s2 =⇒h(s1) = h(s2)
for s1, s2 ∈S. Under these conditions there is a commuting triangle
S
h
- X
S/∼
h♯
-
σ
-
for some unique function h♯. This function is given by
h♯([s]) = h(s)
for s ∈S. The only problem is to show that h♯is well-deﬁned.
To produce a coequalizer we generate a certain equivalence relation.

2.6. Equalizers and coequalizers
61
2.6.7 Example
Let
A
f
-
g
- B
be a parallel pair of functions, arrows in Set. Let ⇝be the relation on B given
by
b1 ⇝b2 ⇐⇒(∃a ∈A)[b1 = f(a) and b2 = g(a)]
for b1, b2 ∈B. Let ∼be the equivalence relation on B generated by ⇝. (An
explicit description of ∼is not as easy as it looks.)
Using the construction of Example 2.6.6 we may check that the canonical
quotient
B
- B/∼
is the coequalizer of the pair f, g (in Set).
A variation of this construction can be used in some Set-based categories.
We ﬁrst pass down to Set, produce a quotient set, and then furnish this to
produce an object of the parent category.
Exercises
2.6.1
Prove Lemma 2.6.3, and complete the proof of Lemma 2.6.4.
2.6.2
Complete the proof of Example 2.6.5. In other words, show that the
function m does make the relevant triangle commute, and it is the only function
to make that triangle commute.
2.6.3
Consider a parallel pair of morphisms
A
f
-
g
- B
between groups (written multiplicatively).
(a) Let
E = {a ∈A | f(a) = g(a)}
and let S be the subgroup of A generated by E. Show that the insertion
S ⊂
- A
is the equalizer of f and g in Grp.

62
Basic gadgetry
(b) Let
F = {f(a)g(a)−1 | a ∈A}
and let K be the normal subgroup generated by F. Show that the canonical
quotient
B
- B/K
is the coequalizer of f and g in Grp.
2.6.4
Write down the details missing from Example 2.6.6. (None of these
details are difﬁcult, but you should at least list what is missing.)
2.6.5
Write down the details missing from Example 2.6.7.
2.6.6
Let
S
φ
-
ψ
- T
be a parallel pair of continuous maps between topological spaces. Let
T
θ - T/∼
be the coequalizer in Set of the pair of functions φ and ψ.
Show there is a suitable topology on T/∼for which θ becomes the coequal-
izer of the pair φ, ψ in Top.
2.6.7
Consider the forgetful functor
Pre 
Pos
from posets to presets. Eventually we will see that this exercise produces the
left adjoint to this functor.
(a) Let S be a pre-ordered set and let ∼be the relation on S given by
a ∼b ⇐⇒a ≤b ≤a
(for a, b ∈S).
Show that ∼is an equivalence relation on the set S.
Show that S is a poset precisely when ∼is equality.
(b) Let S/∼be the set of blocks of ∼and let
S
η - S/∼
be the canonical quotient.

2.6. Equalizers and coequalizers
63
Show that letting
[a] ≤[b] ⇐⇒a ≤b
for a, b ∈S produces a well-deﬁned partial order on S/∼.
Show that the function η is monotone.
(c) Consider any monotone map
S
f
- T
from the preset S to a poset T.
Show that
a ∼b =⇒f(a) = f(b)
for all a, b ∈S.
Show there is a unique monotone map f ♯such that the
S
f
- T
S/∼
f ♯
-
η
-
triangle commutes.
2.6.8
Consider a diagram
•
e
- •
f
-
g
- •
where e makes equal f and g. Suppose also there is a commuting diagram
•
e - •
p - •
•
e
?
g
- •
f
?
q
- •
e
?
where the bottom and top composites are identity arrows.
Show that e is the equalizer of f and g.

64
Basic gadgetry
2.7 Pullbacks and pushouts
As I said in Section 2.3, the notions discussed in Sections 2.4, 2.5, 2.6, and this
section are particular cases of a more general notion, that of a
limit
colimit
of a diagram. In this section we begin to use the terminology and the ideas
behind this more general notion. This is not essential here, but it will help
when we look at the more general notion in Chapter 5.
Each of the gadgets we are interested in is the universal solution of a prob-
lem posed by a diagram. For the simple gadgets of this chapter the shape of the
diagram - the template - determines the name of the gadget. These templates
are given in Table 2.1 on page 44 with the names
left universal solution
right universal solution
for that shape. (The template for row (1) is there, but it’s empty.)
The diagram for a
pullback
pushout
is a
left wedge
right wedge
as in the table. This wedge poses a problem on the appropriate side.
As before, we develop the two notions in parallel. So each deﬁnition or result
is two for the price of one.
2.7.1 Deﬁnition
Let
A
A
C
-
C
-
B
-
B
-
be a wedge in a category C. A solution for the
left
right

2.7. Pullbacks and pushouts
65
problem posed by the wedge is a wedge
A
A
X
-
X
-
B
-
B
-
(of the opposite handedness) such that the square
A
A
X
-
C
-
C
-
X
-
B
-
-
B
-
-
commutes.
Notice that we haven’t given each arrow a name. We are beginning to work
more and more in terms of diagrams, and we name an arrow only when it
becomes necessary. (It is also the case that we need not name the objects, but
let’s not go that far just yet.)
The problem posed by a wedge can have many different solutions. We look
for a ‘best possible’ solution.
2.7.2 Deﬁnition
Let
A
A
C
-
C
-
B
-
B
-
be a wedge in a category C. A
pullback
pushout
for the wedge is a solution
A
A
S
-
S
-
B
-
B
-
with the following universal property.

66
Basic gadgetry
For each solution
A
A
X
-
X
-
B
-
B
-
there is a unique arrow
X
m - S
S
m - X
such that the following diagram commutes.
A
A
X
m-
-
S
-
S
m-
-
X
-
B
-
-
B
-
-
This arrow m is the mediating arrow (or mediator) for the wedge on X.
As always, each universal solution is essentially unique. To prove this here
we ﬁrst obtain the analogue of Lemma 2.5.3.
2.7.3 Lemma
Let
A
A
S
-
C
-
C
-
S
-
B
-
-
B
-
-
be a
pullback
pushout
square in the category C. Let
S
k
- S
be any endo-arrow of S for which the two triangles
A
A
S
k -
-
S
-
S
k -
-
S
-
B
-
-
B
-
-
commute. Then k = idS.

2.7. Pullbacks and pushouts
67
You should be able to see the proof of this immediately. We use the result to
obtain the analogue of Lemma 2.5.4.
2.7.4 Lemma
For a wedge
A
A
C
-
C
-
B
-
B
-
in a category C, let
S
S
A
-
A
-
C
-
C
-
B
-
-
B
-
-
T
-
-
T
-
-
be a pair of
pullback
pushout
squares. Then S, T are uniquely isomorphic over the parent wedge. In other
words, there are unique arrows
S
T
m
?
n
6
such that all the triangles
S
S
A
-
A
-
B
-
B
-
T
m
?
n
6
-
-
T
m
?
n
6
-
-
commute. In particular, m and n are an inverse pair of isomorphisms.
Proof
We are given two solutions of the parent problem. Furthermore, each
is a universal solution. Thus the associated mediators are the arrows m and n.
We now apply Lemma 2.7.3 to the two compounds
n ◦m
m ◦n
to show these are
idS
idT
respectively.

68
Basic gadgetry
If you found this proof a little hard to follow, try labelling the arrows and
re-work the argument using equational reasoning.
Let’s now look at a couple of examples of these notions.
2.7.5 Examples
(a) In the category Set (of sets and functions) consider a
wedge of functions f, g as on the right. Consider also the product
A
A
A
P
p
-
P
p
-
C
f
-
C
f
-
B
q
-
B
g
-
q
-
B
g
-
wedge p, q of the two two sets A, B, as on the left. This gives us a square of
arrows, as in the centre, but this square need not commute.
Let
S = {z ∈P | f(p(z)) = g(q(z))}
be the set of elements of P which arrive at the same place no matter which
route they take. Let
S ⊂
i
- P
be the insertion of S in P. Then the wedge
A
S
p ◦i
-
B
q ◦i
-
is the pullback of the parent wedge.
To see this observe ﬁrst that, by construction, this wedge on S is a solution
to the problem posed by the parent wedge.
Consider any solution to the posed problem.
A
X
h
-
C
f
-
B
g
-
k
-

2.7. Pullbacks and pushouts
69
Using the product property we have a commuting diagram
A
X
l-
h
-
P
p
6
B
q?
k
-
for some unique function l. For each x ∈X we have
f(p(l(x))) = (f ◦p ◦l)(x)
= (f ◦h)(x)
= (g ◦k)(x)
= (g ◦q ◦l)(x) = g(q(l(x)))
to show that l(x) ∈S. We may now check that
X
l
- S
x
- l(x)
is the required unique mediating arrow.
(b) In the category Set (of sets and functions) consider a wedge of functions
f, g as on the left. Consider also the coproduct wedge i, j of
A
A
A
C
f
-
P
f
-
C
i
-
P
i
-
B
g
-
B
j
-
g
-
B
j
-
the two two sets A, B, as on the right. This gives us a square of arrows, as in
the centre, but this square need not commute.
Let ⇝be the relation on P given by
z1 ⇝z2 ⇐⇒(∃c ∈C)[z1 = (i ◦f)(c) and z2 = (j ◦g)(c)]
for z1, z2 ∈B. Let ∼be the equivalence relation on P generated by ⇝. Let
S = P/∼and let
P
k
- S

70
Basic gadgetry
be the canonical quotient. By construction the square
A
C
f
-
s
k ◦i
-
B
k ◦j
-
g
-
commutes, and so we do have a solution to the posed problem. We need to
show it is a universal solution. This follows by a few calculations.
Did you spot anything about these two constructions?
Exercises
2.7.1
(a) Suppose the category C has all binary products and all equalizers.
Show that C has all pullbacks.
(b) Suppose the category C has all binary coproducts and all coequalizers.
Show that C has all pushouts.
2.7.2
Let S be a poset which as a category has all pushouts. What does this
mean lattice theoretically. (There is a lattice theoretic notion which matches
the categorical notion, but is rarely recognized as such.)
2.7.3
Consider the following commuting diagram
•
- •
- •
•
?
- •
?
- •
?
of two inner cells and one outer cell.
Show that if each of the two inner cells is a pullback, then so is the outer
cell.
Show that if the outer cell and the right inner cell are pullbacks, then the left
inner cell is a pullback.
Sort out the corresponding results for pushouts.
2.7.4
Show that monics are stable across pullbacks, that is if
•
k- •
•
h
?
g
- •
f
?
is a pullback and f is monic, then h is monic.

2.8. Using the opposite category
71
2.7.5
Show that equalizers are stable across pullbacks, that is if
•
k- •
•
h
?
g
- •
f
?
is a pullback and f is is the equalizer of some pair, then h is the equalizer of
some other pair.
2.8 Using the opposite category
In Sections 2.2 to 2.7 we have looked at six pairs of gadgets, a left version and
a right version. By using the opposite category C
op we can make precise this
left-right symmetry, and halve the work.
Consider any arrow
•
f
- •
of a category C. Then
f is monic in C ⇐⇒f
op is epic in C
op
f is epic in C ⇐⇒f
op is monic in C
op
to show that one of the notions immediately gives the other one.
Consider any object
K
of a category C. Then
K is ﬁnal in C ⇐⇒K is initial in C
op
K is initial in C ⇐⇒K is ﬁnal in C
op
to show that one of the notions immediately gives the other one.
This duality is a useful trick. It can help to save work. For instance, we have
seen that each gadget discussed in this chapter is ‘essentially unique’, but in
each case we only did half the proof. This is because the other half is the same
argument carried out in the opposite category.
Exercises
2.8.1
Check that each of the gadgets of this chapter is the dual of a similar
gadget in the opposite category.

3
Functors and natural transformations
Eilenberg and MacLane invented (discovered) category theory in the early
1940s. They were working on ˇCech cohomology and wanted to separate the
routine manipulations from those with more speciﬁc content. It turned out
that category theory is good at that. Hence its other name abstract nonsense
which is not always used with affection.
Another part of their motivation was to try to explain why certain ‘natural’
constructions are natural, and other constructions are not. Such ‘natural’ con-
structions are now called natural transformations, a term that was used infor-
mally at the time but now has a precise deﬁnition. They observed that a natural
transformation passes between two gadgets. These had to be made precise,
and are now called functors. In turn each functor passes between two gadgets,
which are now called categories. In other words, categories were invented to
support functors, and these were invented to support natural transformations.
But why the somewhat curious terminology? This is explained on pages 29
and 30 of Mac Lane (1998).
.. . the discovery of ideas as general as these is chieﬂy the willingness to make a brash
or speculative abstraction, in this case supported by the pleasure of purloining words
from philosophers: “Category” from Aristotle and Kant, “Functor” from Carnap . . .
That, of course, is the bowdlerized version.
Most of the basic notions were set up in Eilenberg and MacLane (1945) and
that paper is still worth reading.
In this chapter we look at these two basic notions. We deal ﬁrst with the
deﬁnition of functor, and then look at various examples of these gadgets. Af-
ter that we look at the deﬁnition of natural transformation and conclude with
several examples of these gadgets.

3.1. Functors deﬁned
73
3.1 Functors deﬁned
The basic belief of category theory is that whenever we conceive of a collection
of ‘objects’ - things we don’t want to take apart - we should, at the same time,
decide how these ‘objects’ are to be compared. We then formalize a category.
In other words, for any given category C we should think of the arrows of C
as those gadgets which compare the objects. Furthermore, these arrows are just
as important as, and sometimes more important than, the objects. To stay true
to this principle we must now ask a question. We have invented a collection
of things called categories. How should categories be compared? Functors are
the comparison gadgets.
3.1.1 Deﬁnition
(Preliminary) Given a pair of categories
Src
Trg
a functor
Src
- Trg
A
- FA
f
- F(f)
consists of two assignments. One sends objects to objects, and the other sends
arrows to arrows.
As here, it is customary to use the same letter for both assignments. I ﬁnd
it helpful to use brackets in the arrow assignment but not in the object assign-
ment.
Of course, there is more to a functor than just a pair of assignments. It is
supposed to be a ‘morphism of categories’ in the sense that it must respect the
structure of the two categories. What can that mean?
The ﬁrst bit is that a functor F must preserve identity arrows. For each Src
object A we must have
A
idA - A
-
FA
idF A- FA
that is
F(idA) = idF A
in equational form.
That part is easy, but now comes the part that might be confusing.

74
Functors and natural transformations
The second bit is that a functor F must preserve composition of composible
arrows. But here there can be a twist in the tale. Given an arrow
A
f
- B
in the source category Src, the arrow F(f) in the target category Trg must
pass between the two objects FA and FB of Trg. But there are two ways it
might do that. It can preserve the direction or it can reverse the direction. This
leads to two kinds of functors.
Covariant
A
f - B
-
FA
F(f)- FB
Contravariant
A
f - B
-
FB
F(f)- FA
For both kinds the source and target of an arrow are preserved as an unordered
pair. For a covariant functor the direction of the arrow is always preserved, but
for a contravariant functor the direction of the arrow is always reversed.
Notice that the direction is not sometimes preserved and sometimes re-
versed. It is always one or the other.
3.1.2 Deﬁnition
(In full) Given a pair of categories
Src
Trg
a functor
Src
- Trg
A
- FA
f
- F(f)
consists of two assignments. One sends objects to objects, and the other sends
arrows to arrows.
(Co) For a covariant functor composition is preserved as follows.
B
Covariant
FB
-
A
g ◦f
-
f
-
C
g
-
FA
F(g ◦f)
-
F(f)
-
FC
F(g)
-
F(g ◦f) = F(g) ◦F(f)

3.1. Functors deﬁned
75
(Contra) For a contravariant functor composition is preserved as follows.
B
Contravariant
FB
-
A
g ◦f
-
f
-
C
g
-
FA 
F(g ◦f)
F(f)

FC
F(g)

F(g ◦f) = F(f) ◦F(g)
For both kinds identity arrows are preserved in the sense that
F(idA) = idF A
for each object A.
As mentioned before this deﬁnition, it doesn’t make sense to say a functor
is sometimes covariant and sometimes contravariant.
(There is a notion of a multi-functor with several input positions for objects.
Such multi-functors can be covariant in some input positions and contravariant
in the other input positions. The simplest example of this is the 2-placed hom-
functor. We meet this in the next section.)
In the main we deal with covariant functors and refer to these as functors.
Only when it is important do we speciﬁcally mention the variance of a functor.
Exercises
3.1.1
Consider a pair S, T of monoids viewed as categories.
What is a covariant functor from S to T?
What is a contravariant functor from S to T?
3.1.2
Consider a pair S, T of presets viewed as categories.
What is a covariant functor from S to T?
What is a contravariant functor from S to T?
3.1.3
Show that for each pair Src and Trg of categories, covariant functors
Srcop
- Trg
Src
- Trgop
are just contravariant functors from Src to Trg.
3.1.4
Deﬁne the composite G ◦F of two functors F and G (perhaps of dif-
ferent variance), and show that the result is a functor.
How does the variance of G ◦F relate to that of F and G?

76
Functors and natural transformations
Table 3.1 Some forgetful functors
Rng
- AGrp
forget the × -structure
Rng
- Mon
forget the +-structure
Mod-R
- AGrp
forget the action
Mod-R
- Set-R
forget the +-structure
CMon
- Mon
For all three
AGrp
- Grp
the commutative property
CRng
- Rng
is forgotten
Sup
- Join
- Pos
ﬁrst forget arbitrary suprema but
retain joins then forget these
Inf
- Meet
- Pos
3.2 Some simple functors
In this section we look at some simple examples of functors. Most of these
are chosen merely to illustrate the notion, but one or two are important in their
own right.
Forgetful functors
Let C be any category of structured sets. Thus each object
(A, · · · )
is a set furnished with some gadgetry, and each arrow
(A, · · · )
- (B, · · · )
is a function between the two carrying sets. Arrow composition is just function
composition. Here we have a covariant functor
C
- Set
which sends each object to its carrying set, and each arrow to its carrying
function. I know this is not very exciting, but the idea can help to clear up
a bit of confusion from time to time.
This is an example of a forgetful functor. There are a few more given in
Table 3.1. For each of these something is forgotten (or ignored) as we pass

3.2. Some simple functors
77
from the source category to the target category. In the ﬁrst batch some structure
is forgotten. In the second batch some property is forgotten. In the third batch
it is a mixture of structure and property that is forgotten.
All of these forgetful functors are covariant. Occasionally we meet a con-
travariant forgetful functor. Consider the functors
Pos⊣
L- Pos
Pos⊣
R- Pos
which pick out the left component and the right component of each arrow.
Hom-functors
The next two examples, one covariant and one contravariant, are very impor-
tant. We will meet them many times in several forms.
Let C be an arbitrary category. Let K be an object of C. For each object A
we have an arrow set
LA = C[K, A]
RA = C[A, K]
(unless, of course, this collection is too big to be a set). Thus we have a pair of
object assignments
C
- Set
C
- Set
A
- LA
A
- RA
to the category of sets. These are the object assignments of a pair of functors
where each arrow
A
f
- B
of C is sent to
C[K, A]
L(f)- C[K, B]
C[B, K]
R(f)- C[A, K]
r
- f ◦r
l
- l ◦f
that is
L(f)(r) = f ◦r
R(f)(l) = l ◦f
respectively. Each of these is a
covariant
contravariant
hom-functor, respectively.
Of course, we should check that we do have a pair of functors, and sort out
the variance of each. This is not difﬁcult but it is worth setting down the two
calculations in parallel.

78
Functors and natural transformations
Consider a pair of arrows
A
f
- B
g
- C
of C. Consider also arrows
K
r
- A
C
l
- K
r ∈LA
l ∈RC
respectively. Then
 L(g) ◦L(f)

(r) = L(g)
 L(f)(r)

 R(f) ◦R(g)

(l) = R(f)
 R(g)(l)

= L(g)(f ◦r)
= R(f)(l ◦g)
= g ◦(f ◦r)
= (l ◦g) ◦f
= (g ◦f) ◦r
= l ◦(g ◦f)
= L(g ◦f)(r)
= R(g ◦f)(l)
to show that L is a covariant functor and R is a contravariant functor. We
should also show that
L(idA) = idLA
R(idA) = idRA
but that is more or less trivial.
Exercises
3.2.1
For an arbitrary category C consider the arrow category C ↓of Exam-
ple 1.3.5. Show there are three functors
C ↓
S -
T
- C
∆- C ↓
between the categories. The functor ∆is called the diagonal functor.
3.2.2
Let S be a poset viewed as a category. What is a contravariant functor
S
- Set
to Set? You have seen this notion before.
3.2.3
Let R be a monoid viewed as a category. What is a covariant functor,
and what is a contravariant functor
R
- Set
to Set? Both these notions occur elsewhere in this book, but are described in
a different way.

3.3. Some less simple functors
79
3.2.4
In Example 1.3.2 we looked at the graph Γ(f) of a function (between
sets). Show that this is the arrow assignment of a functor, and determine the
variance of that functor.
3.2.5
In Example 1.3.4 we saw how to produce the product C × D of two
categories. This enables us to think of 2-placed functors
C × D
- Trg
with two inputs. In particular, for a given category C we can view
C × C
C[−, −]- Set
as a 2-placed functor. Think about this, and what it should mean.
3.3 Some less simple functors
In this section we look at some examples of functors with a bit more content,
although none of them are very complicated. Some of the examples may look a
bit contrived, but each one is a miniature version of something quite important.
3.3.1 Three power set functors
It may come as a surprise, but different functors can have the same object
assignment. In this block we look at three endo-functors on Set
Set
- Set
where the object assignment of each sends a set A to its power set.
A
- PA
Furthermore, two of these functors are covariant and one contravariant.
It is common to use the same letter as the name of both the object assignment
and the arrow assignment. Here we can’t do that. We use
Set
∃
-

I
∀
-
Set
as the three names, where the two outer ones are covariant and the central one is
contravariant. The stacking of the functors is signiﬁcant, but that won’t become
clear for some time. Also the use of ‘∃’ and ‘∀’ may look a bit pretentious, but

80
3. Functors and natural transformations
in a more general setting these functors really do have something to do with
quantiﬁcation. We will see just a hint of this shortly.
For each set A we have
∃A = PA
IA = PA
∀A = PA
as the three object assignments.
For the three arrow assignments consider any arrow of Set
A
f
- B
a function between the two sets. We require three functions
PA
∃(f)- PB
PA I(f)
PB
PA
∀(f)- PB
where the central one reverses the direction. We set
∃(f)(X) = f[X]
I(f)(Y ) = f ←(Y )
∀(f)(X) = f[X′]′
for each X ∈PA and Y ∈PB. Here f[ · ] gives the direct image across f,
and f ←( · ) gives the inverse image across f. Notice that ∀(f) uses the dual
complement of the direct image (for (·)′ is complementation).
We ﬁnd that
b ∈∃(f)(X) ⇐⇒(∃a ∈A)[b = f(a) & a ∈X]
b ∈∀(f)(X) ⇐⇒(∀a ∈A)[b = f(a) ⇒a ∈X]
for all X ∈P and b ∈B. Notice how the description matches the name. We
also have
a ∈I(f)(Y ) ⇐⇒f(a) ∈Y
for all Y ∈PB and a ∈A.
It is not immediately clear that these constructions do give functors, so we
must check that.
For functions
A
f
- B
g
- C
we must show that
∃(g ◦f) = ∃(g) ◦∃(f)
I(g ◦f) = I(f) ◦I(g)
∀(g ◦f) = ∀(g) ◦∀(f)
and the identity requirements. This is not hard, if you take a bit of care.

3.3. Some less simple functors
81
Exercises
3.3.1
Consider the three constructions ∃, I, ∀on Set. Show that each passes
across composition in the required manner.
3.3.2
For each set A the power set PA is a poset under inclusion. Show that
for each function f, as on the left,
A
f
- B
PA
∃(f) -
 I(f)
∀(f)
-
PB
the three functions on the right form a double poset adjunction.
3.3.2 Spaces, presets, and posets
In this block we compare the category Top of topological spaces with the
categories Pre and Pos. We set up four functors.
Pre
⇑-

⇓
Top
O -
Ξ
- Pos
The two on the left are covariant. They also form an ADJUNCTION, but we
won’t explain that until Chapter 4. The two on the right are contravariant. They
are also NATURALLY ISOMORPHIC, and we explain that later in this chapter.
You should remember that a topological space need not be hausdorff. The
separation properties T0 and T1 play a minor role here.
We look ﬁrst at the two covariant functors ⇑and ⇓on the left.
Consider an arbitrary preset A. An upper section of A is a subset U ⊆A
such that
a ∈U
a ≤b
)
=⇒b ∈U
for all a, b ∈A. Let ΥA be the family of all upper sections of A. This is a
topology on A, and is sometimes called the Alexandroff topology.
Let ⇑A be the preset A viewed as a topological space, that is with ΥA as
the carried topology. We think of ⇑A as an upgrading of A. (It’s getting above
itself.) This gives the object assignment of one of the functors. The arrow as-
signment is more or less trivial.
For a topological space S with topology OS, the specialization order of S
is the comparison on S given by
r ≤s ⇐⇒(∀U ∈OS)[r ∈U =⇒s ∈U] ⇐⇒r ∈s−

82
Functors and natural transformations
for r, s ∈S. Here s−is the closure of {s}. This specialization order is a pre-
order on S. (You might like to check that S is T0 precisely when ≤is a partial
ordering, and S is T1 precisely when ≤is equality.)
Let ⇓S be the space S viewed as a preset, that is with its specialization
order as its carried comparison. We think of ⇓S as a downgrading of S. (It
isn’t making enough of its talents.) This gives the object assignment of the
other functor. The arrow assignment is more or less trivial.
The Exercises 3.3.3, 3.3.4, and 3.3.5 ﬁll in some of the missing details.
Next we look at the two contravariant functors O and Ξ on the right.
For each space S let OS be its topology viewed as a poset under inclusion.
For each continuous map
T
φ
- S
between spaces consider the inverse image function.
OS
O(φ) = φ←
- OT
Almost trivially, this is monotone, and so gives us one of the functors.
Consider the 2-element set on the left
2 = {0, 1}
O2 = {∅, {1}, 2}
together with the topology O2 on the right. This is Sierpi´nski space.
For a space S consider the set of continuous characters of S.
ΞS = Top[S, 2]
These are partially ordered pointwise, that is
p ≤q ⇐⇒(∀s ∈S)[p(s) ≤q(s)]
for p, q ∈ΞS. For each continuous map
T
φ
- S
between space let
ΞS
Ξ(φ)
- ΞT
p
- p ◦φ
for p ∈ΞS. This gives us the other functor. Of course, there are a few things
to be checked. These are dealt with by Exercises 3.3.6 and 3.3.7.

3.3. Some less simple functors
83
Exercises
3.3.3
(a) For a preset A, what is the specialization order of ⇑A?
(b) For a space S, show that OS ⊆Υ⇓S.
3.3.4
(a) Show that a monotone function
A
f
- B
between presets is continuous relative to the two Alexandroff topologies.
Show that ⇑is a functor.
(b) Show that a continuous map
S
φ
- T
between spaces is monotone relative to the two specialization orders.
Show that ⇓is a functor.
3.3.5
Let
θ : A
- S
be a function from a pre-ordered set to a topological space.
Show that θ is monotone (relative to ⇓S) precisely when it is continuous
(relative to ΥA).
Show there is a bijection between
Pre[A, ⇓S]
Top[⇑A, S]
for arbitrary A and S.
3.3.6
Show that for each continuous map
T
φ
- S
between spaces, the function O(φ) is monotone.
Show that O(φ) passes across composition, and hence O is a functor.
Show that the function Ξ(φ) does convert continuous characters into contin-
uous characters, and that Ξ(φ) is monotone.
Show that Ξ(φ) passes across composition, and hence Ξ is a functor.
Where have you seen some of these calculations before?
3.3.7
For an arbitrary space S and open set U ∈OS, let
χS(U) : S
- 2

84
Functors and natural transformations
be the characteristic function of U, that is
χS(U)(s) =
(
1 if s ∈U
0 if s /∈U
for s ∈S.
Show that for each U ∈OS the character χS(U) is continuous, and hence
we have an assignment
OS
χS - ΞS
between the two posets.
Show that χS is an isomorphism of posets. (This is more than showing χS
is a monotone bijection.)
3.3.3 Functors from products
In Section 2.5 we deﬁned the notion of a product of two objects A and B in a
category C. This consists of a wedge
A
A × B
-
B
-
with certain properties. As we saw in Section 2.5 the object A × B is unique
only up to a certain canonical isomorphism. What happens if we decide to
change some of these selected objects and modify the projections accordingly?
Suppose the category C has all binary products. For each pair A, B of ob-
jects suppose we select, in some way or other, a product wedge for that pair.
This choice could be haphazard, but it still produces a functor.
Let R be some ﬁxed object of C. For each object A consider a product
wedge, as on the right,
A
F = A × R
A × R
pA
-
R
qA
-
together with the product object FA, as on the left. Thus we have an object
assignment
A
- FA

3.3. Some less simple functors
85
on C. We show there is a corresponding arrow assignment
f
- F(f)
so that the pair of assignments forms an endo-functor on C.
Let
A
f
- B
be an arrow of C. We have a diagram
A
f
- B
FA
pA
-
FB
pB
-
R
idR
-
qA
-
R
qB
-
using the selected product wedges. The product condition gives an arrow
FA
F(f)- FB
with certain properties. With a little bit of work we can check that this gives an
endo-functor on C.
Exercises
3.3.8
Use the mediating property for product wedges to complete the details
of the functorial product construction.
Show also that the coproduct construction gives an endo-functor on the par-
ent category.
3.3.9
If you are happy with the previous exercise, you can try this generaliza-
tion. Let C be a category with all binary products, and consider the assignment
C × C
- C
(A1, A2)
- A1 × A2
which attaches a product object to each pair of objects. Show that this ﬁlls out
to a functor.

86
Functors and natural transformations
3.3.4 Comma category
In this block we use two functors to produce a new category from three old cat-
egories. This construction generalizes the two slice constructions of Example
1.3.6.
We start with three categories and two functors
U
U - C 
L
L
where we think of U as the upper component and L as the lower component.
Using these we produce a category
(U ↓L)
sometimes called a comma category. Each new object is a triple (conveniently
written vertically)
AU
UAU
AU ∈U
α
α ∈C
AL
LAL
α
?
AL ∈L
formed using an upper object AU from U , a lower object AL from L, and a
connecting central arrow α from C, as indicated. The new arrows
UAU
UBU
f
-
LAL
α
?
LBL
β
?
are formed using an arrow fU from U and an arrow fL from L such that the
square
AU
fU
- BU
UAU
U(fU)- UBU
LAL
α
?
L(fL)
- LBL
β
?
AL
fL
- BL
commutes. You should check that this does produce a category and generalizes
the two slice constructions.

3.3. Some less simple functors
87
Exercises
3.3.10
Fill in the details of the construction of the comma category.
3.3.11
(a) What is (U ↓L) when both U and L are the identity endo-functor
on C?
(b) For an object S of C describe the slice categories (C ↓S) and (S ↓C)
as comma categories.
3.3.12
For convenience let Com be the comma category (U ↓L). Construct
three forgetful functors
Com
- U
Com
- C ↓
Com
- L
using the arrow category in the central one.
3.3.5 Other examples
Functors appear almost everywhere in mathematics. Exercises 3.3.13 to 3.3.18
give a few more examples.
Exercises
3.3.13
For a group A let δA be the derived subgroup (generated by the com-
mutators). In particular, A/δA is an abelian group. Show that each of the two
object assignments
A
- δA
A
- A/δA
is part of a functor.
3.3.14
Consider a morphism between monoids.
S
φ
- R
Using restriction of scalars we may view each (right) R-set A as an S-set.
The S-action ⋆is obtained from the R-action · by
a ⋆s = a · φ(s)
for each a ∈A and s ∈S.
(a) Show that this construction does convert the R-set A into an S-set.
(b) Show that the construction produces a functor
Set-S Φ
Set-R
which is trivial on objects and arrows.
(c) Try generalizing this construction using rings and modules.

88
Functors and natural transformations
3.3.15
You will have to think clearly to do this exercise.
We form a new large category MON . Each object of MON is a category
Set-R for some monoid R. The arrows of MON are the functors between
these categories. Show that the construction of Exercise 3.3.14 produces a con-
travariant functor
Mon
- MON
from the small to the large.
3.3.16
Exercise 1.2.7 shows that the two categories Set⊥and Pfn are ‘es-
sentially the same’ category. Re-do that exercise to show there is an inverse
pair of functors passing between the two categories.
3.3.17
Each preset S can be converted into a poset in a canonical fashion. We
consider the relation ∼on S given by
s1 ∼s2 ⇐⇒s1 ≤s2 and s2 ≤s1
for s1, s2 ∈S. Almost trivially, this is an equivalence relation on S, and is
equality precisely when S is a poset.
Let S/∼be the corresponding set of blocks [s] for s ∈S, and partially order
S/∼by
[s1] ≤[s2] ⇐⇒s2 ≤s2
for s1, s2 ∈S.
(a) Show that this construction of a poset S/∼is well-deﬁned, and show that
the canonical function
S
- S/∼
is monotone.
(b) Show that
S
- S/∼
is the object part of a functor Pre
- Pos.
3.3.18
This exercise makes precise the notion of ‘freely generated by’ in
appropriate circumstances. Later we look at a more general version of this
construction.
Suppose we have two categories Src and Trg and a forgetful functor be-
tween them. It is customary not to give such a functor a name, but here it will
help if it does have one.

3.3. Some less simple functors
89
You are allowed not to take the following too seriously.
Let
Src  ¿
Trg
be the forgetful functor. (Eventually you can forget ‘¿’!)
Suppose to each Src-object A we attach a Trg-object FA and an arrow
A
ηA- (¿ ◦F)A
of Src with the following universal property.
For each Src-arrow
A
f
- ¿S
where S is a Trg-object, there is a unique Trg-arrow
FA
f ♯
- S
such that the triangle
A
f
- ¿S
(¿ ◦F)A
¿(f ♯)
-
ηA
-
commutes in Src.
(a) Show that
A
- FA
is the object assignment of a functor Src
- Trg.
(b) Show that for each Src-object A and Trg-object S the assignment
f
- f ♯
Src[A, ¿S] - Trg[FA, S]
is a bijection, and describe its inverse.
(c) Where have you seen this construction before?

90
Functors and natural transformations
3.4 Natural transformations deﬁned
As we have seen, each arrow of a category compares two objects, and each
functor compares two categories. Next we will see how each natural transfor-
mation compares two functors.
How might we compare two functors F and G? Surely we want them to pass
between the same two categories
Src
F -
G
- Trg
in the same direction. It also seems reasonable to insist that they have the same
variance, either both are covariant or both are contravariant. Given these con-
dition, how might we compare F and G?
Consider an arbitrary object A of Src. The two functors pass this to two
objects FA and GA of Trg. We compare these objects in Trg. Thus we look
for an arrow
FA
τA - GA
of Trg. We do this for each object A of Src.
3.4.1 Deﬁnition
(Preliminary) Given a parallel pair
Src
F -
G
- Trg
of functors of the same variance, a natural transformation
F
τ
- G
is a family of arrows of Trg
FA
τA - GA
indexed by the objects A of Src.
Notice that each component arrow τA passes in the same direction, from F
to G in this case. Of course, there is more to a natural transformation than just
an indexed family of arrows. The selected arrow τA is required to be natural
for variation of A. This is where we have to take note of the common variance
of F and G.

3.4. Natural transformations deﬁned
91
3.4.2 Deﬁnition
(In full) Given a parallel pair
Src
F -
G
- Trg
of functors of the same variance, a natural transformation
F
τ
- G
is a family of arrows of Trg
FA
τA - GA
indexed by the objects A of Src, and such that for each arrow
A
f
- B
of Src the appropriate square in Trg commutes
FA
τA - GA
A
FA
τA
- GA
covariant
contravariant
FB
F(f)
?
τB
- GB
G(f)
?
B
f
?
FB
F(f)
6
τB
- GB
G(f)
6
depending on the common variance of F and G.
This is quite a short deﬁnition, but it has some subtleties. This will become
clear as we look at various examples in the next section.
A natural transformation compares two functors. We reﬁne the notion to
make precise the idea of two functors being ‘essentially the same’.
3.4.3 Deﬁnition
A natural isomorphism between two functors F and G is
a natural transformation
F
τ
- G
such that for each source arrow A the selected arrow
FA
τA - GA
is an isomorphism in the target category.
Sometimes two functors that are naturally isomorphic are said to be natu-
rally equivalent.

92
Functors and natural transformations
Exercises
3.4.1
(a) Consider the small graph (↓) as described in Example 1.3.5. We
may view this as a very small category with two objects and three arrows. The
two identity arrows have been omitted from the picture.
Show that the objects of C ↓are essentially the covariant functors
(↓)
- C
and the arrows of C ↓are the natural transformations between these functors.
(b) Show that each of the categories of Exercise 1.3.10 is the category of
functors
∇
- C
and natural transformations for some appropriate template category ∇.
(c) Can you see a generalization of this idea?
3.4.2
For an arbitrary poset S consider the category bS of presheaves on S, as
deﬁned in Example 1.4.1. Describe this as a category of functors and natural
transformations.
3.4.3
Let R be a monoid viewed as a category. Exercise 3.2.3 located the
functors of both variance.
R
- Set
Now locate the natural transformations between these functors.
3.4.4
Let
F
τ
- G
be a natural isomorphism between two functors. Suppose that for each source
object A the arrow
FA
τA - GA
has an inverse in the target category.
FA 
σA
GA
Show that the family σ of arrows is a natural transformation.

3.5. Examples of natural transformations
93
3.5 Examples of natural transformations
In this section we look at several examples of natural transformations. Some of
these build on earlier examples of functors. The exercises give further details
and examples.
As a ﬁrst example let’s have a look at some natural transformations between
hom-functors.
3.5.1 Example
Let C be an arbitrary category, and let K and L be arbitrary
objects of C. These give hom-functors
[K, −]
[L, −]
from C to Set.
C
- Set
As is customary, here we can omit the name of the parent category on the
hom-functors. Consider an arbitrary arrow of C.
L
φ
- K
For each object A of C we have an assignment
[K, A]
τA- [L, A]
l
- l ◦φ
given by composition in C. We show these functions form a natural transfor-
mation between the two functors.
To do that we must consider an arbitrary arrow f of C, as on the left
l
- l ◦φ
A
[K, A]
−◦φ
τA
- [L, A]
B
f
?
[K, B]
f ◦−
?
τB
−◦φ
- [L, B]
f ◦−
?
f ◦(l ◦φ)
?
f ◦l
?
- (f ◦l) ◦φ
and verify that the inner square commutes. To do that we take an arbitrary
member
K
l
- A
of the top left hand corner of the square and track it both ways to the bottom

94
Functors and natural transformations
right hand corner. We require that both paths give the same member of [L, B].
Thus we require
(f ◦l) ◦φ = f ◦(l ◦φ)
which is immediate.
Work out the corresponding result for the contravariant hom-functors. Exer-
cises 3.5.1 and 3.5.2 deal with this and a more involved version.
By inspecting the construction of the natural transformation τ of Example
3.5.1 we see that it is completely determined by one output
φ = τK(idK)
of one component of τ. There is more to this.
3.5.2 Example
Let C be an arbitrary category, let
C
F - Set
be an arbitrary functor to Set. Let K be an arbitrary object of C. What can a
natural transformations
[K, −]
- F
look like? We show they are in bijective correspondence with the elements of
the set FK.
(a) Consider ﬁrst any element k ∈FK. This gives a family of functions
[K, A]
ϵA- FA
l
- F(l)(k)
indexed by the objects A of C. This function ϵA is ‘evaluation at k’.
We check that the family
[K, −]
ϵ - F
is a natural transformation. To do that we must consider an arbitrary arrow f
of C, as on the left, and verify that the inner square commutes.
l
- F(l)(k)
A
[K, A]
ϵA
- FA
B
f
?
[K, B]
f ◦−
?
ϵB
- FB
F(f)
?
F(f)
 F(l)(k)

?
f ◦l
?
- F(f ◦l)(k)

3.5. Examples of natural transformations
95
To do that we take an arbitrary member of the top left hand corner
K
l
- A
of the square and track both ways to the bottom right hand corner. We required
that both paths give the same member of FB. Thus we require
F(f ◦l)(k) = F(f)
 F(l)(k)

for arbitrary f and l. But F is a covariant functor, so
F(f)
 F(l)(k)

=
 F(f) ◦F(l)

(k) = F(f ◦l)(k)
to give the required result.
(b) This gives us many examples of natural transformations from [K, −] to
F. Are there any more? In fact, we can show that every such natural transfor-
mation is determined by a unique element of FK.
Consider an arbitrary natural transformation
[K, −]
τ - F
look at the K-component
[K, K]
τK- FK
and set
k = τK(idK)
to produce k ∈FK. We show that τ is ‘evaluation at k’.
Consider an arbitrary object A of C and an arbitrary member
K
l
- A
of [K, A]. We show that
τA(l) = F(l)(k)
holds. To do that we remember that the square
[K, K]
τK- FK
[K, A]
l ◦−
?
τA
- FA
F(l)
?
commutes. By tracking the member idK of the top left hand corner we obtain
the required result.

96
Functors and natural transformations
Consider the natural transformation induced by k ∈FK.
[K, −]
ϵ - F
When this is a natural isomorphism, we say the pair (K, k) is a pointwise
representation of F. We say F is representable when it has at least one
pointwise representation.
There is, of course, a contravariant version of this example, and in a way
that is more important.
Let C be an arbitrary category. A presheaf on C is a contravariant Set-
valued functor.
C
F - Set
Such presheaves F and G are compared via natural transformations.
G
τ
- F
These presheaves, as objects, and natural transformations, as arrows, form a
category c
C , the Yoneda completion of C. Each object A of C gives a presheaf
on C
bA = C[−, A]
the contravariant hom-functor. These are the representable presheaves. Let A
be a ﬁxed object of C, and let F be a ﬁxed presheaf on C. The basic Yoneda
result characterizes the natural transformations
bA
- F
from the representable to the arbitrary. They are essentially the elements of the
set FA. See Exercises 3.5.4 to 3.5.6. You might also want to have another look
at Exercises 3.4.2 and 3.4.3.
In Block 3.3.1 we set up three endo-functors
∃
I
∀
on Set. There are several natural transformations associated with these.
3.5.3 Example
Let Id be the identity endo-functor on Set. Thus
IdA = A
Id(f) = f
for each set A and function f. We set up two natural transformations
Id
η∃
- ∃
Id
η∀
- ∀

3.5. Examples of natural transformations
97
using the two indicated covariant endo-functors on Set. Thus for each set A
we require a pair a functions
A
η∃
A - PA
A
η∀
A - PA
with appropriate properties. Notice that here we have omitted ‘Id’. This should
not cause too much confusion.
We must produce η∃and η∀so that for each function f the two squares
A
η∃
A - PA
X
A
η∀
A - PA
X
B
f
?
η∃
B
- PB
∃(f)
?
f[X]
?
B
f
?
η∀
B
- PB
∀(f)
?
f[X′]′
?
commute. For each a ∈A each of
η∃
A(a)
η∀
A(a)
must be a certain subset of A. Given the other requirements, there isn’t much
choice.
The two natural transformations η∃and η∀of this last example don’t look
very interesting. However, in a more general setting they are quite important.
We look at this in Chapter 6.
Let’s now look at the contravariant power set functor. In the next example we
set up a natural isomorphism which again doesn’t look very exiting. However,
the idea has many important reﬁnements. It is the core of many representation
results, especially when 2 is replaced by a more complicated structure.
3.5.4 Example
The inverse image functor I on Set is contravariant, and is
really a hom-functor in disguise. The set
2 = {0, 1}
induces a hom-functor [−, 2] on Set. Thus we have two endo-functors
Set
I
-
[−, 2]
- Set
on Set, both of which are contravariant. We show that these two functors are
naturally isomorphic.

98
Functors and natural transformations
To do that we recall that for any set A its subsets are in bijective correspon-
dence with the characteristic functions on A. Thus, for each X ∈PA we let
χA(X) : A
- 2
be given by
χA(X)(a) =
(
1 if a ∈X
0 if a /∈X
for a ∈A. The assignment
PA
χA- [A, 2]
X
- χA(X)
is a bijection. We show this is natural for variation of A. To do that we must
show that the inner square commutes
X
- p = χA(X)
A
PA
χA
- [A, 2]
B
f 6
PB
f ←
?
χB
- [B, 2]
−◦f
?
p ◦f
?
f ←(X)
?
- q
for an arbitrary arrow f, as on the left. Observe the contravariance here.
We track an arbitrary member X ∈PA of the top left hand corner both
ways to the bottom right hand corner. This gives us two members q and p ◦f
of [B, 2]. A calculation shows these are the same function.
Two compatible contravariant functors can be composed to produce a co-
variant functor. This often happens when we produce a ‘representation’ of an
algebra. Let’s look at a miniature version of that.
3.5.5 Example
The inverse image functor I on Set can be composed
Π = I ◦I
with itself to produce a covariant endo-functor on Set. Thus for each set A we
have
ΠA = P2A
the second power set of A, the family of all collections of subsets of A. To
describe the behaviour of Π on functions we ﬁx some notation.

3.5. Examples of natural transformations
99
Each function f gives us two other functions
A
f
- B
PA 
I(f) = f ←
PA
P2A
Π(f)
- P2B
where the central one goes in the opposite direction. For the pair of sets
A
B
we let
x ∈A
X ∈PA
X ∈P2A
y ∈B
Y ∈PB
Y ∈O2B
be typical members of the indicated sets. We have
x ∈I(f)(Y ) ⇐⇒f(x) ∈Y
for each Y ∈PB and x ∈A. This gives
Y ∈Π(f)(X) ⇐⇒I(f)(Y ) ∈X ⇐⇒f ←(Y ) ∈X
for X ∈P2A and Y ∈PB.
For each set A let
A
ηA - PA
be the function given by
X ∈ηA(x) ⇐⇒x ∈X
for x, X as above. We show that
Id
η
- Π
is a natural transformation.
We must show that the inner square commutes
x
- ηA(x)
A
ηA
- P2A
B
f
?
ηB
- P2B
Π(f)
?
Π(f)(ηA(x))
?
f(x)
?
- ηB(f(x))
for each function f as indicated on the left of the square. To do that, as usual,

100
Functors and natural transformations
we take an arbitrary member x of the top left hand component and track it both
ways to the bottom right hand component. Thus
ηB(f(x)) = Π(f)(ηA(x))
is the problem. This can be veriﬁed by a simple calculation.
As ﬁnal example we look at one of the motivating ‘natural’ constructions
and its ‘unnatural’ mate.
3.5.6 Example
Let K be a (commutative) ﬁeld, and let VectK be the cat-
egory of vector spaces over K, or K-spaces for short. Each K-space V is an
abelian group, written additively, and furnished with an action
K, V
- V
r, a
- ra
satisfying the usual axioms. This is a left action, but since K is commutative
the difference between left and right hardly matters.
These K-spaces are the objects of VectK, and the arrows are the corre-
sponding linear transformations.
The ﬁeld K is itself a K-space. Thus for an arbitrary K-space V we may
form the hom-set
V ∗= VectK[V, K]
in VectK. It turns out that we can furnish V ∗as a K-space to produce the
dual space of V . In fact, (·)∗is a contravariant endo-functor on VectK. It is
an enriched hom-functor.
We wish to investigate the interaction between a parent K-space V and its
dual space V ∗. To do that we ﬁx some notation and terminology.
We let
r, s, t, . . . range over scalars,
the members of K
a, b, c, . . . range over vectors,
the members of V
α, β, γ, . . . range over characters, the members of V ∗
and we let
f, g, h, l, . . .
range over linear transformations between K-spaces.
The elements of V ∗are those functions
α : V
- K

3.5. Examples of natural transformations
101
such that
α(0) = 0
α(a + b) = α(a) + α(b)
α(ra) = rα(a)
for all a, b ∈V and r ∈K. We add these pointwise and this, with the obvious
zero, furnishes V ∗as an abelian group.
The action
K, V ∗
- V ∗
r, α
- rα
is given by
(rα)(a) = r(α(a))
for r ∈K, α ∈V ∗, and a ∈V . This converts V ∗into a K-space.
Each ﬁnite dimensional K-space V is uniquely determined up to isomor-
phism. If V has dimension n ≥0 then the isomorphisms
Kn
- V
are in bijective correspondence with the bases of V . The crucial fact, which
you should look up some time, is as follows.
Let V be a ﬁnite dimensional K-space. Then the dual space V ∗is ﬁnite dimensional
with the same dimension. In particular V ∼= V ∗.
This suggests a problem.
Let V be ﬁnite dimensional. There is at least one isomorphism
V
- V ∗
but is there a canonical one? To set up such an isomorphism we must ﬁrst select
a base for V , and then the resulting isomorphism is hardly canonical.
Now we come to what used to be the puzzling bit.
Each K-space V has a dual space V ∗which itself has a dual space V ∗∗.
This is the second dual of V . We know that (·)∗∗is a covariant endo-functor
on VectK (because it is the composite of two contravariant endo-functors).
Furthermore, it is easy to exhibit members of V ∗∗.
For each a ∈V let
ab : V ∗
- K
be the function given by
ab(α) = α(a)
for α ∈V ∗.
We can now check three facts.

102
Functors and natural transformations
(1) For each a ∈V the functions ab is a member of V ∗∗.
(2) For each K-space V the assignment
V
(·)b - V ∗∗
is a linear transformation.
(3) The whole family of assignments (·)bis a natural transformation.
Thus for each ﬁnite dimensional K-space V the assignment of (2) is a canoni-
cal isomorphism, independent of any choice of base.
You can see what the puzzle was. Why is it that the second dual seems to
have a ‘natural’ behaviour whereas the ﬁrst dual doesn’t?
We will meet many more functors and natural transformations. Some of
these are quite complicated. The exercises give some hints of what can happen.
Exercises
3.5.1
Consider arbitrary objects K, L of an arbitrary category C. Show how
a natural transformation
[−, L]
τ- [−, K]
can be induced by an arrow between K and L.
3.5.2
Let C be an arbitrary category and let
Q
p
- P
be an arbitrary arrow of C. Let
R
s
- S
be an arbitrary function (between sets). For each object A of C let
FA = Set[C[A, P], R]
GA = Set[C[A, Q], S]
using hom-sets in the two different categories.
(a) Show that each of
A
- FA
A
- GA
is the object assignment of a functor
C
- Set
and determine the variance of each.

3.5. Examples of natural transformations
103
(b) Use the arrow p and function s to produce a natural transformation
F
- G.
3.5.3
Complete the details of Example 3.5.2.
3.5.4
Consider the notion of a presheaf as deﬁned just after Example 3.5.2.
Where have you seen examples of this before?
3.5.5
Consider an arbitrary category C, and arbitrary presheaf F on C, an
arbitrary object A of C, and an arbitrary element a ∈FA.
For each set X consider the following assignment.
C[X, A]
aX- FX
k
- F(k)(a)
Check that this is a function. In other words, show that the output does live in
FX. Show that the whole family a is a natural transformation.
3.5.6
Continuing with the notation of Exercise 3.5.5, consider an arbitrary
natural transformation
bA
τ
- F
and let a = τA(idA). Check that a ∈FA, and show that τ = a.
3.5.7
Describe the natural transformations η∃and η∀of Example 3.5.3.
3.5.8
Complete the calculation of Example 3.5.4.
3.5.9
(a) Do the calculation required to complete Example 3.5.5.
(b) By Example 3.5.4 the inverse image functor I is naturally isomorphic
to the hom-functor [−, 2]. Thus Π is naturally isomorphic to the endo-functor
with
A
- [[A, 2], 2]
as the object assignment. Write down the arrow assignment and re-do Example
3.5.5 for this functor.
(c) Which version do you think is easier to understand?
3.5.10
Consider Example 3.5.6
(a) Write down all the axioms needed to set up VectK. (The axioms for a
ﬁeld, for an additive abelian group, for an action, and for a linear transforma-
tion.) It is instructive not to overload the notation. In other words, distinguish
between the various additions, and use a different visible inﬁx for each multi-
plication.

104
Functors and natural transformations
(b) Verify that the dual space V ∗of a K-space is itself a K-space. (You may
now go back to the standard, overloaded, notation.)
(c) Show that (·)∗is a contravariant endo-functor on VectK. In particular,
you must decide how (·)∗behaves on arrows of VectK.
3.5.11
Continuing with Example 3.5.6, verify the three facts (1), (2), and (3).
3.5.12
Show that the functors O and Ξ of Block 3.3.2 are naturally isomor-
phic.
3.5.13
Consider the functors arising from the product construction, as de-
scribed in Block 3.3.3 and Exercises 3.3.8 and 3.3.9. Show that the projection
arrows form natural transformations.
3.5.14
Let C be a category with all binary products. Let R, S be two objects
and let
F = −× R
G = −× S
to obtain two endo-functors on C. Show that each arrow
R
φ
- S
of C induces a natural transformation
F
φ• - G
between these functors. This involves some serious diagram chasing.
3.5.15
Let C be a category with all binary products and coproducts, and let
A, B, C be three arbitrary objects of C. Let
L = A × C + B × C
R = (A + B) × C
to form two more objects.
Show that by ﬁxing two of A, B, C, each of L and R is an endo-functor of
C, and there is a natural transformation L
- R.
If you are brave you might try the 3-placed version of this, that is do not ﬁx
two of A, B, C.
3.5.16
Recall the difference between a monoid and a semigroup. (A semi-
group need not have a unit.) Given a semigroup A let
FA = A ∪{ω}
where ω is a new element not in A. Let
A
ι
- FA

3.5. Examples of natural transformations
105
be the insertion. Let ⋆be the operation on FA given by
a ⋆b = ab
a ⋆ω = a = ω ⋆a
ω ⋆ω = ω
for all a, b ∈A.
(a) Show that (FA, ⋆, ω) is a monoid.
(b) Show that ι is a semigroup morphism.
(c) Show that for each semigroup morphism
A
f
- B
to a monoid B, there is a commuting triangle
A
f
- B
FA
f ♯
-
ι
-
for some unique monoid morphism f ♯.
(d) Show that F ﬁlls out to a functor. You will have to sort out its source and
target.
(e) Show that ι is natural for variation of A. You will have to insert a couple
of trivial functors.
(f) What happens if A already has a unit?
3.5.17
For an arbitrary set A think of A as an alphabet. Let FA be the set of
all words on A, ﬁnite lists
a = [a1, . . . , al]
for a1, . . . , al ∈A. The empty word, with l = 0, is allowed.
(a) Show that FA is a monoid under concatenation.
(b) Show that F ﬁlls out to a functor. Make sure you write down the source
and target.
(c) Show that the assignment
A
- FA
a
- [a]
is a natural transformation. You will have to sort out the two functors it passes
between.
(d) Show that FA is the free monoid on the sets A in a sense that you should
make precise.
(e) What happens if A already carries a monoid structure?

106
Functors and natural transformations
3.5.18
Consider the two functors
A
- δA
A
- A/δA
of Exercise 3.3.13 (where here only the object assignments are given).
(a) Show the canonical embedding ι and the canonical quotient η
δA
ι
- A
A
η - A/δA
are natural for variation of A. You must describe explicitly the source and
target for each functor.
(b) Show that for each morphism from an arbitrary group A
A
f
- B
to an abelian group B, there is a unique morphism
A/δA
f ♯
- B
such that
A
f
- B
A/δA
f ♯
-
η
-
commutes.
3.5.19
Consider the ‘freely generated by’ construction of Exercise 3.3.18.
Show that the family η of arrows is a natural transformation.
3.5.20
Let ∇be an arbitrary category and think of this as a template. Let
C be an arbitrary category. These combine to give another category C ∇. The
objects of C ∇are the covariant functors
∇
- C
and the arrows are the natural transformations between these functors.
Show that this does give a category. The problem is to produce an appropri-
ate method of composing natural transformations.
3.5.21
The composition used in Exercise 3.5.20 is know as the vertical com-
position of natural transformations. There is also a horizontal composition.
(Don’t ask what is vertical or horizontal about the two constructions.)

3.5. Examples of natural transformations
107
Consider three categories A, B, C, four functors F, G, K, L, and two natu-
ral transformations λ, ρ, as shown.
A
λ-
F
? B
G
?
ρ-
K
? C
L
?
Show that for each object A of A the following square commutes.
(K ◦F)A
ρF A - (L ◦F)A
(K ◦G)A
K(λA)
?
ρGA
- (L ◦G)A
L(λA)
?
Let
(K ◦F)A
(ρ ⋆λ)A - (L ◦G)A
be the diagonal of this square. Show that this family (ρ ⋆λ)• is natural.
This gives the horizontal composite of
(K ◦F)
ρ ⋆λ
- (L ◦G)
of the two natural transformations between the composite functors.
3.5.22
Consider three categories A, B, C, six functors F, G, H, K, L, M,
and four natural transformations λ, µ, ρ, σ, as shown.
A
λ -
µ -
F
?
B
G?
H
?
ρ -
σ -
K
?
C
L?
M
?
Using vertical and horizontal composition (as in Exercises 3.5.20 and 3.5.21)
show that
(σ ⋆µ) ◦(ρ ⋆λ) = (σ ◦ρ) ⋆(µ ◦λ)
holds.

4
Limits and colimits in general
In Chapter 2, Sections 2.3 to 2.7 we looked at some simple examples of limits
and colimits. These are brought together in Table 2.1 which is repeated here as
Table 4.1. In this chapter we generalize the idea.
Before we begin the details it is useful to outline the ﬁve steps we go through
together with the associated notions for each step. After that we look at each
step in more detail.
Template
This is the shape ∇that a particular kind of diagram can have. It is a picture
consisting of nodes (blobs) and edges (arrows). The central column of Table
4.1 lists a few of the simpler templates. Technically, a template is often a di-
rected graph or more generally a category.
Diagram
This is an instantiation of a particular template ∇in a category C. Each node
of ∇is instantiated with an object of C, and each edge is instantiated with an
arrow of C. There are some obvious source and target restrictions that must
be met, and the diagram may require that some cells commute. Thus we some-
times use a category as a template.
Posed problem
Each diagram in a category C poses two problems, the left (blunt end) problem
and the right (sharp end) problem. We never actually say what the problem is
(which is perhaps the reason why it is rarely mentioned) but we do say what a
solution is. The idea is to ﬁnd a ‘best’ solution.
Solution
A solution for a diagram in C is a nominated object X of C together with
a collection of arrows. For a left solution all arrows start from X, and such a

4.1. Template and diagram – a ﬁrst pass
109
Table 4.1 Some simple limits and colimits – a repeat of Table 2.1
Limit
Template
Colimit
(1)
ﬁnal object
initial object
•
(2)
binary product
binary coproduct
•
(3)
equalizer
•
-
- •
co-equalizer
•
(4)
pullback
•
-
•
-
•
(5)
•
-
pushout
•
-
gadget is often called a cone. For a right solution all arrows ﬁnish at X, and
such a gadget is often called a co-cone. For both kinds of solutions the arrows
must make various triangles commute.
Universal solution
A universal solution is a particular solution through which each solution (of
that handedness) must pass via a unique mediating arrow. A limit is a universal
left solution. A colimit is a universal right solution.
We now begin to look at each these notions in more detail.
4.1 Template and diagram – a ﬁrst pass
Roughly speaking a template is a collection of nodes, each drawn as a •, and a
collection of edges, each drawn as an arrow. Each edge passes from a particular
node (its source) to a particular node (its target). In other words, a template is
a directed graph. There may also be some commuting conditions on the edges,
in which case the template is a category. We usually draw the edges as pointing
from left to right.

110
Limits and colimits in general
We instantiate the template in a category C to produce a diagram in C.
We replace each node by an object of C and we replace each edge by an
arrow of C. We respect the source and target conditions and any commuting
conditions that the template requires. We look for the left (blunt end) solutions
or the right (sharp end) solutions. In particular, we look for a universal solution
on the appropriate side, to obtain a limit (universal left solution) or a colimit
(universal right solution).
Table 4.1 gives a few small templates. Let’s look at a few more examples
that are not so simple.
4.1.1 Examples
(1) Suppose we have a collection of nodes with no edges. It
is convenient of think of this collection arranged vertically.
...
•
•
•
•
...
There may be inﬁnitely many of these, ﬁnitely many, or none at all.
A limit for a corresponding diagram is a product and a colimit for a corre-
sponding diagram is a coproduct (sometimes called a sum). We have already
seen the case where there are zero, one, or just two nodes.
(2) Suppose we have a collection of nodes arranged in a line with an edge
between adjacent nodes.
· · · - • - • - • - • - · · ·
If there are only ﬁnitely many nodes then the posed problem isn’t interesting
(since any associated diagram has a left-most object and a right-most object).
Thus we may as well suppose there are inﬁnitely many nodes. We use the
integers as nodes. This gives us three (or perhaps four) different templates.
The template may have a left-most node and go off to the right
0 - 1 - 2 - 3 - 4 - · · ·
in which case it is the colimit (right universal solution) that is interesting.
The template may have a right-most node and go off to the left
· · · - 4 - 3 - 2 - 1 - 0
in which case it is the limit (left universal solution) that is interesting.

4.1 Template and diagram – a ﬁrst pass
111
Notice that we have again used the natural numbers to label the nodes.
The template may go off to the left and the right
· · · - −3 - −2 - −1 - 0
- 1
- 2
- 3
- · · ·
· · ·
- 3
- 2
- 1
- 0 - −1 - −2 - −3 - · · ·
in which case we may use the integers to label the nodes in one of two ways.
Both these are useful in different circumstances. For a diagram of this shape
both the limit and the colimit may be interesting.
(3) The template may be a collection of zig-zags
...
•
•
-
•
-
•
-
•
-
•
-
•
-
...
and may be ﬁnite or inﬁnite. Even the ﬁnite case (with at least four nodes)
leads to interesting solutions.
(4) There are more complicated examples.
...
•
· · ·
•
-
•
-
•
-
•
· · ·
•
-
-
•
-
•
-
•
· · ·
•
-
•
-
•
-
-
•
· · ·
•
-
-
•
-
...
This is a tree which grows to the left and keeps growing for ever, but with the
edges pointing to the right. A limit is something that is put out on the far left.
What can that be?

112
Limits and colimits in general
Table 4.2 A more exotic template
...
· · ·
...
•
...
•
-
•
-
· · ·
...
•
-
•
•
-
-
•
-
· · ·
•
-
•
•
-
•
-
· · ·
...
•
-
-
•
...
•
-
-
· · ·
...
•
-
...
(5) Consider the template in Table 4.2. The nodes are arranged in vertical
layers each of which is inﬁnite both ways, and there are inﬁnitely many layers
progressing leftwards. Each edge passes between one layer and the next. Think
of going through this graph from right to left, moving backwards along the
edges. Intuitively something is being approached out on the far left. The notion
of a limit makes this precise.
This template stops at the vertical layer on the right. We could also continue
the same pattern moving off to the right. This would not change the limit (at the
far left) but could have a dramatic impact on the colimit (at the far right).
Let’s now try to make the idea of these examples precise.
4.1.2 Deﬁnition
A template (of the ﬁrst kind)
∇= (I, E)
is a directed graph consisting of
nodes i, j, k, . . . in I
edges e, f, g, . . . in E
where each edge
i
e
- j
has a nominated source and target, each of which is a node.

4.1. Template and diagram – a ﬁrst pass
113
This version says nothing about any commuting conditions in the template.
We look at that in the next section. However, notice that all the templates of
Table 4.1 and Examples 4.1.1 do match this deﬁnition.
4.1.3 Deﬁnition
Let ∇= (I, E) be a directed graph viewed as a template of
the ﬁrst kind. Let C be a category. A ∇-diagram in C is
• an I-indexed family of objects of C
A =
 A(i) | i ∈I

• an E-indexed family of arrows of C
A =
 A(e) | e ∈E

where each edge, as on the left, produces an arrow, as on the right
i
e
- j
A(i)
A(e)- A(j)
with indicated source and target restrictions.
In other words, this is just a ‘functor’ from ∇= (I, E) but with any com-
muting conditions ignored.
There aren’t many exercises concerned solely with templates, but the fol-
lowing construction should be looked at.
Consider the notion of a directed graph as given in Deﬁnition 4.1.2. Such
a gadget consists of nodes and edges with two source and target assignments.
This looks a bit like the notion of a category. Each category is a directed graph,
but the converse does not hold. A directed graph has no notion of composition
of edges, and no notion of identity edges. However, there is a construction that
converts each directed graph into a category.
4.1.4 Deﬁnition
Let ∇be a directed graph.
For each l ∈N a path through ∇of length l is a list of l edges
i(0)
e(1)- i(1)
e(2)- i(2)
- · · · · · ·
e(l)- i(l)
where the target of each edge is the source of the next one. A path of length 1
is just an edge. A path of length 0 is just a node.
We create a category Pth(∇), the category of paths through ∇.
The objects of Pth(∇) are the nodes of ∇.
The arrows of Pth(∇) are the paths through ∇.
Given two paths
i(0) - i(1) - · · · - i(l)
j(0) - j(1) - · · · - j(m)
with i(l) = j(0) the composite path is
i(0) - i(1) - · · · - i(l) = j(0) - j(1) - · · · - j(m)
formed by sticking one path after the other.
There is something to be checked here, and this is not entirely trivial.

114
Limits and colimits in general
Exercises
4.1.1
Show that the construction Pth(·) does produce a category.
Make sure you verify all the required properties. This is an example where
the required identity properties are not immediately obvious.
4.1.2
Consider the following three different graphs.
(a)
1
0
-
3
-
2
-
-
(b)
1
0
-
2
-
3

-
(c)
1
0
-
2
-
3


In each case describe the generated category of paths.
4.1.3
Suppose the graph you start from is already a category. Do you merely
reconstruct the category?
4.1.4
Let ∇be a directed graph viewed as a template. Let A be a ∇-diagram
in some category C.
Show that A extends uniquely to a functor Pth(∇)
- C.
Show that each functor Pth(∇)
- C is the unique extension of some
∇-diagram in C.
4.2 Functor categories
In this section we replace the directed graph (I, E) by a category ∇. We think
of ∇as an indexing gadget, and to emphasize this we refer to the objects
i, j, k, . . . of ∇as nodes and its arrows e, f, g, . . . as edges.
The following notion generalizes that of Example 1.3.5 and Exercise 1.3.10.
You may want to look at those before you continue. You should make sure you
understand they are particular cases of the following.

4.2. Functor categories
115
4.2.1 Deﬁnition
Let ∇be an arbitrary category viewed as a template. Let C
be an arbitrary category. These combine to produce the category
C ∇
of ∇-diagrams in C.
Each object of C ∇is a functor
∇
A - C
from the template to C.
Given two such functors (objects of C ∇)
∇
A -
B
- C
an arrow of C ∇from A to B
A
σ
- B
is a natural transformation between the functors.
Given three such functors and two such natural transformations
∇
∇
∇
σ
-
τ
-
C
A
?
C
B
?
C
C
?
the composite
∇
∇
τ ◦σ -
C
A
?
C
C
?
is given by
A(i)
(τ ◦σ)i = τi ◦σi - C(i)
for each index i.
There is something to prove here. We must show that the composite τ ◦σ of
two natural transformations is a natural transformation, and that this composi-
tion is associative. The proofs are straightforward, but you should go through
them. Because if you don’t you know what will happen, don’t you!

116
Limits and colimits in general
As the terminology of Deﬁnition 4.1.2 suggests, for each category ∇viewed
as a template, and each category C, a ∇-diagram in C is merely a functor A
from ∇to C. In other words, such a diagram is
a family of objects A(i) of C
a family of arrows A(e) of C
indexed by the
nodes
edges
of ∇, respectively. As with a diagram over a directed graph we require that
each edge
i
e
- j
of ∇produces an arrow
A(i)
A(e)- A(j)
of C. We now also require that for each pair
i
e
- j
f
- k
of composible edges of ∇, the induced triangle in C
A(i)
A(f ◦e) - A(k)
A(j)
A(f)
-
A(e)
-
commutes. Finally, we now also require that
A(idi) = idA(i)
for each index i.
In many cases we don’t use an arbitrary category as a template. We use a
partially ordered set, or occasionally a pre-ordered set.
Let I be a pre-ordered set, let
i, j, k, . . .
range over I and think of these as nodes. We may view I as a category in one
of two ways. For each pair of nodes i, j there is at most one edge
i
(j, i) - j

4.2. Functor categories
117
from i to j. There is such an edge precisely when there is a comparison between
i and j. We orientate these edges in one of two ways.
Upwards
Downwards
i ≤j
i
(j, i) - j
j ≤i
Depending on which view we take, such an arrow always points upwards or
always points downwards in the pre-ordered set.
4.2.2 Deﬁnition
A pre-ordered set is directed or upwards directed if for
each pair i, j of nodes there is at least one node k with i ≤k and j ≤k.
Depending on the circumstances sometimes we want a pre-ordered diagram
that is directed to the right (directed to the sharp end). In that case we index the
diagram by a directed pre-order with its edges pointing upwards. Sometimes
we want a pre-ordered diagram that is directed to the left (directed to the blunt
end). In that case we index the diagram by a directed pre-order with its edges
pointing downwards. We could achieve the same effect using a downwards
directed pre-order, but that rarely seems to be used.
Notice that when we use a pre-ordered set at a template we lie it on its side,
so that ‘upwards’ means ‘towards the right’.
To conclude this section let’s take a closer look at the way edges in a preset
are labelled. Since there is at most one edge between two indexes we can use
these to label the edge.
i
(j, i) - j
At ﬁrst sight the two components of the edge seem to be the wrong way round.
But consider what happens when we compose two such edges. The common
node should disappear.
i
(k, i)
- k
(k, j) ◦(j, i) = (k, i)
j
(k, j)
-
(j, i)
-
This convention is neater.
Exercises
Throughout these exercises ∇and C are an arbitrary pair of categories.
4.2.1
Show that the construction of C ∇does produce a category.

118
Limits and colimits in general
4.2.2
For each C-object X let ∆X be the ∇-diagram with X at each node
and idX at each edge. Show that X
- ∆X is the object assignment of a
functor
C
- C ∇
from C to C ∇. This is the diagonal functor.
4.2.3
Describe typical arrows
∆X
- A
A
- ∆X
where X is a C-object and A is a ∇-diagram.
4.3 Problem and solution
Let ∇be a template, let C be a category, and let A be a ∇-diagram in C.
This diagram A is a collection of objects and arrows given by the shape ∇.
This diagram poses two problems in C, the blunt end problem and the sharp
end problem. When we draw the diagram we usually let the arrows point from
left to right, so it is more common to speak of the left problem and the right
problem.
The following deﬁnition is two deﬁnitions in one given in parallel.
4.3.1 Deﬁnition
Let ∇be a template, and let A be a ∇-diagram in a category
C. A
left
right
solution is a C-object X together with a family of arrows
X
α(i)- A(i)
A(i)
α(i)- X
indexed by the nodes of ∇, such that for each edge e of ∇
A(i)
i
A(i)
X
α(i)
-
X
α(i)
-
A(j)
A(e)
?
α(j)
-
j
e
?
A(j)
A(e)
?
α(j)
-
the induced C-triangle commutes.

4.3. Problem and solution
119
A diagram may have many different left solutions or it may have none. It
may have many right solutions or it may have none. In general there is little or
no relationship between left solutions and right solutions. In the next section,
we make precise the notion of a ‘best’ left solution or a ‘best’ right solution,
but we don’t need to worry about that just yet.
4.3.2 Example
Suppose the category C is a poset with its arrows pointing
upwards (to the right). One kind of diagram in C is simply a subset S with the
induced comparisons. Then a
left
right
solution for S is merely a
lower
upper
bound of S in the poset. The orientations here have got a bit twisted, but that
is just an historical accident.
Is there something missing in Deﬁnition 4.3.1? Suppose the template im-
poses some commuting conditions on the diagram. Shouldn’t those conditions
be observed in the corresponding solutions? They are!
Suppose the template ∇has composible edges
i
e
- j
f
- k
with
i
g = f ◦e- k
as the composite edge. For a left solution we certainly require that the three
triangles commute.
A(i)
A(i)
X
α(j)-
α(i)
-
A(j)
A(e)
?
X
α(i)
-
A(i)
A(f)
?
α(k)
-
A(i)
A(g)
?
α(k)
-
But the notion of a diagram requires
A(g) = A(f) ◦A(e)
so that the fact that the two triangles on the left commute ensures that the trian-
gle on the right also commutes. For this reason sometimes only a ‘generating
part’ of a template is used.

120
Limits and colimits in general
4.3.3 Example
Suppose we use the integers Z
· · ·
−3
−2
−1
0
1
2
3
· · ·
as a poset template with its edges pointing upwards. We have an edge
n
(m, n)- m
for all n ≤m in Z. In fact
(m, n) = (m, m −1) ◦(m −1, m −2) ◦· · · ◦(n + 2, n + 1) ◦(n + 1, n)
using the 1-step edges. Any Z-diagram requires
A(m, n) = A(m, m−1)◦A(m−1, m−2)◦· · ·◦A(n+2, n+1)◦A(n+1, n)
so, in practice, we often describe just the 1-step arrows
A(n + 1, n)
for n ∈Z.
On the whole we need not worry too much about the difference between a
diagram indexed by a directed graph and one indexed by a category. In fact,
as we have seen, each graph ∇has an associated path category Pth(∇) and
these produce ‘equivalent’ diagrams in any category. These two diagrams have
the same solutions.
Exercises
4.3.1
Let ∇be a directed graph and let C be an arbitrary category. Recall
that each ∇-diagram in C extends uniquely to a Pth(∇)-diagram, and each
Pth(∇)-diagram arises from a ∇-diagram
Show that such a corresponding pair of diagrams have exactly the same left
solutions and exactly the same right solutions.
4.3.2
Given a ∇-diagram A in a category C, describe the notions of a left
solution and a right solution using the diagonal functor.
4.4 Universal solution
Each diagram in a category poses two problems, the left problem and the right
problem. Each of these problems may have many solutions, and in general
there is no relationship between the left solutions and the right solutions. We
now look for a ‘best’ solution on either side. On any particular side such a

4.4. Universal solution
121
solution need not exists, but if there is one, then all the ‘best’ solutions are
canonically isomorphic.
A universal solution of a diagram is a particular solution that is as econom-
ical as possible, in that it is as ‘near’ to the diagram as possible. Here is the
formal deﬁnition. As usual, it is two deﬁnitions in one.
4.4.1 Deﬁnition
Let ∇be a template and let A be a ∇-diagram in a category
C. A
left universal solution
right universal solution
usually called a
limit
colimit
for A is a particular solution
S
σ(i)- A(i)
A(i)
σ(i)- S
such that for each solution
X
α(i)- A(i)
A(i)
α(i)- X
there is a unique arrow
X
µ
- S
S
µ
- X
such that for each node i the triangle
X
X
S
σ(i)
-
µ
-
A(i)
α(i)
-
A(i) σ(i)
-
α(i)
-
S
µ
-
commutes. We call µ the mediator.
A limit or a colimit of a diagram need not exists. A diagram can have one
without the other. However, once we have a universal solution (left or right)
we can obtain all other solutions of the same handedness. We simply weaken
the universal solution by an arrow to (for left) or from (for right) the carrying
object, the apex of the universal solution.
Limits and colimits of diagrams (when they exist) are essentially unique. To
prove that for limits we make a preliminary observation.

122
Limits and colimits in general
4.4.2 Lemma
Let ∇be a template, let A be a diagram in a category C, and
suppose
S
σ(i)- A(i)
is a limit of that diagram indexed by the nodes i of ∇. Then this family of
arrows is collection-wise monic. That is, if
X
θ
-
ψ
- S
is a parallel pair of arrows with
σ(i) ◦θ = σ(i) ◦ψ
for each node i, then θ = ψ.
Proof
Consider any such parallel pair θ, ψ of arrows. Let
X
α(i)- A(i)
be the arrow given by
α(i) = σ(i) ◦θ = σ(i) ◦ψ
for node i. Consider any edge
i
e
- j
of ∇. By passing through S we see that the triangle
A(i)
X
α(i)
-
A(j)
A(e)
?
α(j)
-
commutes, and hence we have a left solution of the diagram. Since S is the
apex of a universal left solution there is a unique arrow
X
µ
- S
such that
α(i) = σ(i) ◦µ
for each node i. Since both θ and ψ do this, we have θ = ψ.

4.4. Universal solution
123
This result has a simple consequence.
4.4.3 Corollary
Let ∇be a template, let A be a diagram in a category C,
and suppose
S
σ(i)- A(i)
is a limit of that diagram indexed by the nodes i of ∇. Suppose also that
S
ϵ
- S
is an endo-arrow of S such that
σ(i) ◦ϵ = σ(i)
for each node i. Then ϵ = idS.
Proof
We apply Lemma 4.4.2 to the pair θ = ϵ and ψ = idS.
So far we have been careful to speak of a limit of a diagram. We can now
show that we needn’t be so cautious.
4.4.4 Theorem
Let ∇be a template, let A be a diagram in a category C,
and suppose each of
S
σ(i)- A(i)
T
τ(i)- A(i)
is a limit of that diagram indexed by the nodes i of ∇. Then there is a unique
arrow
T
τ
- S
such that
τ(i) = σ(i) ◦τ
for each node i. Furthermore, τ is an isomorphism.
Proof
Since the arrows σ(·) form a limit, and the arrows τ(·) form a left
solution, there is a unique arrow τ, with indicated type, such that
τ(i) = σ(i) ◦τ
for each node i. This τ is just the mediator. By symmetry, there is a unique
arrow
S
σ
- T

124
Limits and colimits in general
such that
σ(i) = τ(i) ◦σ
for each node i.
Now consider the endo-arrow
ϵ = τ ◦σ
of S. For each node i we have
σ(i) ◦ϵ = σ(i) ◦τ ◦σ = τ(i) ◦σ = σ(i)
and hence ϵ = idS by Corollary 4.4.3. By symmetry we have
τ ◦σ = idS
σ ◦τ = idT
hence these mediators σ and τ are an inverse pair of isomorphisms.
This shows that if a diagram has a limit then that limit is essentially unique.
Thus we may speak of the limit of a diagram (when this does exist). There is a
similar result for colimits with the same proof but where the arrows point the
other way.
In the remaining three sections of this chapter we gather together a random
collection of examples to show how limits and colimits can be calculated in
appropriate circumstances.
Exercises
4.4.1
Find a simple example of a category where a diagram has two distinct
limits.
4.4.2
Show that in the familiar categories (Set, Grp, Rng, . . .) limits and
colimits are not absolutely unique, only unique up to a canonical isomorphism.
4.4.3
State and prove the right hand version of each of the three results of
this section.
4.5 A geometric limit and colimit
In this section we ﬁrst look at a geometric example involving the circle group
and topological spaces. After that there is an exercise which is similar in nature,
but discrete and simpler.

4.5. A geometric limit and colimit
125
For the template we use the integers Z as a poset. There are two ways to do
this, upwards or downwards. Here we use the downward version.
· · ·
- 2
- 1
- 0
- −1
- −2
- · · ·
This helps with some of the calculations. Notice that the limit will occur at the
positive end of Z, and the colimit will occur at the negative end. We look at a
simple diagram in Top, the category of topological spaces. We put the same
space at each node, and the same map at each edge.
Let O be the circle group. We think of O as the circle in the cartesian plane
with radius 1 and centre at the origin. Each point on O is determined by its
unique polar coordinate θ with 0 ≤α < 2π. Here addition (mod 2π) is
important. Put a copy of O at each index. For each edge
O
δ
- O
we take the doubling map
δ(α) = 2α
(mod 2π)
for co-ordinate α. This function wraps the source circle twice round the target
circle. What can a left solution be?
The limit
The limit is some kind of topological space A furnished with a family of func-
tions
A
φm - O
m ∈N
such that
δ ◦φm+1 = φm
for each m ∈N. Thus, for each a ∈A we have
φm(a) = 2φm+1(a)
(mod 2π)
and hence
φm(a) = 2rφm+r(a)
(mod 2π)
for each m, r ∈N. Since we can divide any real number by 2, we seem to have
φr(a) = 1
2r φ0(a)
for all a ∈A, r ∈N. This is not right. We have forgotten the 2π aspect.

126
Limits and colimits in general
Suppose we have
φ0(a) = α
for some 0 ≤α < 2π. Then one of
φ1(a) = α
2
φ1(a) = α
2 + π = α + 2π
2
must hold, and these can arise from
φ2(a) = α
4
φ2(a) = α + 4π
4
φ2(a) = α + 2π
4
φ2(a) = α + 6π
4
and so on. These possibilities are conveniently displayed as a tree
...α
8
...
α + 8π
8
α
4
...
α + 4π
8
...
α + 12π
8
α + 4π
4
α
2
...
α + 2π
8
...
α + 10π
8
α + 2π
4
...
α + 6π
8
...
α + 14π
8
α + 6π
4
α + 2π
2
α
and each a ∈A with φ0(a) = α generates a branch of the tree. Each point of
A corresponds to a certain region of O.
The colimit
The colimit is easier, and we can give a full description of it.
We ﬁrst look at some properties of a general right solution.
O
δ
- O
S
φm
-
φm+1
-
Thus we consider a space S furnished with a Z indexed family of functions
φm such that each indicated triangle commutes. In other words
2α ≡β =⇒φm+1(α) = φm(β)
for all coordinates α, β and all m ∈Z. Here and below
λ ≡ρ
means
λ = ρ
(mod 2π)

4.5. A geometric limit and colimit
127
with all the usual properties. By a trivial induction the equivalence gives
2rα ≡β =⇒φk+r(α) = φk(β)
for all coordinates α, β, all k ∈Z, and all r ∈N. We need a variant of this last
result, namely
(⋆)
2mα ≡β =⇒φm(α) = φ0(β)
for all coordinates α, β and all m ∈Z. Notice how this shows that the map φ0
determines the whole of the structure of the solution.
We now show that any function
O
φ
- S
to a space can be used to generate a solution. To prove this implication suppose
that
2mα ≡β
holds. If m ≤0 then, with r = m the previous result gives
φk+m(α) = φk(β)
for all k ∈Z. Thus we take k = 0. Suppose m ≤0, say m = −r for r ∈N.
Then
0 ≤2mα = 2−rα ≤α
so that
2−rα = β
and hence
α = 2rβ
holds. A version of the previous result now gives
φk+r(β) = φk(α)
for all k ∈Z. Thus taking k = m gives the required result.
Consider the maps
O
ρm - O
given by
ρm(α) ≡2mα
for all m ∈Z and coordinates α. In particular, note that ρ0 is the identity
function on O. We check that these maps furnish O as a right solution.

128
Limits and colimits in general
We have
ρm+1(α) ≡2m+1α
for all m ∈Z and coordinates α. Let
β ≡2α
so that
2mβ ≡2m+1α
and hence
(ρm ◦δ)(α) = ρm(β) ≡2mβ ≡ρm+1(α)
so that
ρm ◦δ = ρm+1
as required.
Finally, we show that O with these furnishings is the colimit of the diagram.
To do that consider an arbitrary right solution, as above. We require a unique
map
O
µ
- S
such that
φm = µ ◦ρm
for each m ∈Z. By considering the case m = 0 we see that µ = φ0 is the
only possible map. We check that this does mediate.
Consider any m ∈Z and any coordinate α. With
β ≡2mα
we have
(µ ◦ρm)(α) = µ(β) = φ0(β)
so that
φm(α) = φ0(β)
is the requirement. This is precisely the result (⋆).
After reading this you might think this colimit example is a bit of a cheat.
You could be right.

4.5. A geometric limit and colimit
129
Exercises
4.5.1
For the template use Z as a poset. It doesn’t matter which way you
order Z, but you might ﬁnd it easier to use the upwards version, positives to
the right and negatives to the left.
Consider the following diagram in Set. At each node place Z (so now Z is
playing two different roles). At each edge place the doubling function.
Z
d
- Z
z
- 2z
Show that the arrows of any left solution have a simple behaviour.
Describe the limit of the diagram. You should verify your claims.
Investigate the behaviour of an arbitrary right solution.
Show that when suitably furnished, the dyadic rationals are the colimit of
the diagram.
4.5.2
For the template use Z as a linear order, and for convenience let the
edges point to the right, the positive end of Z. We look at a Z-diagram in Pos,
the category of posets.
At each node i place a copy of the 3-element poset A(i)
⊤
⋆
⊥
with a top, bottom, and a middle elements ⋆. For each successive edge (i+1, i)
of the template Z, from node i to node i + 1, consider the monotone map
⊤
⊤
⋆
- ⋆
-
⊥
-
⊥
that sends the three source elements to the central target element. This gives
the Z diagram in Pos.
Describe both the limit and the colimit of this diagram.

130
Limits and colimits in general
4.6 How to calculate certain limits
For many categories the objects are structured sets, and the arrows are struc-
ture preserving functions. Each object is a single set, its carrier, furnished
with some structure, perhaps restricted by certain required properties (axioms).
Each arrow is a function between the carriers which respects the structure in
an appropriate fashion. For instance
Pos
Mon
Top
are three categories of this kind. For each such category C there is a forgetful
functor
C
- Set
which sends each object to its carrier, and views each arrow as the function.
Often this functor is named U, for underlying.
In this section we show how to compute a limit in such a category C. To do
that we ﬁrst compute the corresponding limit in Set, and then lift back up to
C. Thus we must ﬁrst show how to calculate limits in Set. The construction
we give works for many categories of structured sets, but not necessarily all.
In the next section we look at certain colimits.
We recall the notation we have used throughout this chapter. We assume we
have a diagram in the category under investigation given by a template ∇. We
let i, j, k, . . . range over the family I of nodes of ∇, and we let e, f, g, . . . range
over the family E of edges of ∇. The construction works when ∇is a graph
and when ∇is a category.
4.6.1 Limits in Set
In this block we show how to compute the limit of a diagram in Set. This then
forms the basis for limits in the other three and similar categories.
We begin with a review of products in Set. Binary products are easy, we
take the cartesian product – the set of ordered pairs – of the two component
sets. Products of ﬁnitely many components are just as easy, again we take the
cartesian product of the components.
What about the product of an arbitrary indexed family
A =
 A(i) | i ∈I

of sets? Let
S A
be the union of the family A. (It is often useful to tag each component A(i)

4.6. How to calculate certain limits
131
so we have a disjoint union. But that is not needed here.) We look at certain
functions
I
- S A
from nodes to elements.
4.6.1 Deﬁnition
Let A be an I-indexed family of sets, as above. A choice
function for A is a function
a(·) : I
- S A
such that
a(i) ∈A(i)
for each node i ∈I.
A choice function selects one member from each component set A(i). When
I is ﬁnite such a choice function can be coded as a tuple. When I is not ﬁnite
we need this more general idea.
4.6.2 Deﬁnition
Let A be an I-indexed family of sets, let QA be the set of
all choice functions for A, and for each node i ∈I let
QA
α(i)- A(i)
a
- a(i)
α(i)(a) = a(i)
be the ‘evaluation at i’ function.
Before you continue reading you might try to show that
 QA α(i)- A(i) | i ∈I

is a product wedge in Set. Here we prove something more general.
We have a template ∇with nodes I and edges E. Suppose also we have a
diagram in Set
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

which instantiates the template. We produce a limit of this diagram.
4.6.3 Deﬁnition
Given a ∇-diagram (A, A), as above, a thread is a choice
function
a(·) : I
- S A
such that
A(e)
 a(i)

= a(j)
for each edge
i
e- j
of ∇.

132
Limits and colimits in general
A choice function merely selects a member from each component set A(i).
A thread ensures that these selections are compatible. If we pass from one
component A(i) to another A(j) using an edge A(e), then we can take the
selected element with us knowing that we will arrive at the selected element at
the end.
If E = ∅then every choice function is a thread.
4.6.4 Deﬁnition
Given a ∇-diagram (A, A), as above, let A be the set of all
threads, and for each node i ∈I let
A
α(i)- A(i)
a
- a(i)
α(i)(a) = a(i)
be the ‘evaluation at i’ function.
By the observation before the deﬁnition, this does not conﬂict with Deﬁni-
tion 4.6.2. It extends the idea to a more general context.
4.6.5 Lemma
Given a ∇-diagram (A, A), as above, the evaluation functions
furnish the set of threads as a left solution of the diagram.
Proof
We must show that for each edge e the induced triangle,
A(i)
i
A
α(i)
-
 A(e) ◦α(i)

(a) = α(j)(a)
A(j)
A(e)
?
α(j)
-
j
e
?
as on the left, commutes. In other words we require the equality on the right
for each a ∈A. But since a is a thread we have
 A(e) ◦α(i)

(a) = (A(e)
 α(i)(a)

= (A(e)
 a(i)

= a(j) = α(j)(a)
as required.
With this we have the result we want.
4.6.6 Theorem
Given a ∇-diagram (A, A), as above, the evaluation func-
tions furnish the set of threads as a limit of the diagram.
Proof
By Lemma 4.6.5 we already know that we have a left solution of the
diagram. Thus it sufﬁces to show that this left solution is universal.

4.6. How to calculate certain limits
133
To this end let
A(i)
i
X
ξ(i)
-
A(j)
A(e)
?
ξ(j)
-
j
e
?
be a typical part of an arbitrary left solution of the diagram. We require a unique
function
X
µ
- A
such that
ξ(i) = α(i) ◦µ
for each i ∈I.
To obtain one such function set
µ(x)(i) = ξ(i)(x)
for each x ∈X and i ∈I. Since
ξ(i)(x) ∈A(i)
we see that µ(x) is a choice function. For each edge e, as above, we have
A(e)
 µ(x)(i)

= A(e)
 ξ(i)(x)

=
 A(e) ◦ξ(i)

(x) = ξ(j)(x) = µ(x)(j)
to show that µ(x) is a thread. Thus we do have a function µ of the required
type. Finally, for each node i we have
 α(i) ◦µ

(x) = α(i)
 µ(x)

= µ(x)(i) = ξ(i)(x)
to show that
α(i) ◦µ = ξ(i)
as required.
This deals with the existence of a mediating arrow. Now we must deal with
the uniqueness. To this end suppose we have a function ν with
α(i) ◦ν = ξ(i)
for each node i. Consider any x ∈X and the corresponding thread a = ν(x).
For each node i we have
ν(x)(i) = a(i)
= α(i)(a)
= α(i)
 ν(x)

=
 α(i) ◦ν

(x)
= ξ(i)(x) = µ(x)(i)
to show ν = µ, as required.

134
Limits and colimits in general
In the next three blocks we show how to calculate limits in certain categories
C of structured sets. The process is the same for these categories. In each case
there is a forgetful functor
C
- Set
to the category of sets. It merely forgets the structure. Given a diagram in C
this functor converts it into a diagram in Set. We calculate the limit of that
Set-diagram using the method of this block. The problem then is to furnish
that set and collection of arrows so that they form a limit in C. This last part
needs some special properties of C.
Exercises
4.6.1
Let SetD be the category of sets with a distinguished subset, as used
in Exercise 1.2.2. Thus each object is a pair (A, R) where A is a set and R is
a subset R ⊆A. The arrows are those functions which preserve the selected
subset.
Let ∇= (I, E) be a template, and consider a ∇-diagram
A(D) =
 (A(i), R(i)) | i ∈I

A(D) =
 A(e) | e ∈E

in SetD. By forgetting the distinguished subsets we have a ∇-diagram
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

in Set. Consider the limit of the diagram in Set, that is the set of threads with
the attached functions. Show that this can be furnished to produce a limit of
the diagram in SetD.
4.6.2 Limits in Pos
We look at the category Pos of posets and monotone maps. We continue with
the notation of the previous block. Thus we have a template ∇with a collection
I of nodes and a collection E of edges. These index certain objects and arrows
in Pos. We assume we have an instantiation of ∇
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

to form a diagram in Pos. Thus each A(i) is a poset, and for each edge
i
e- j
the arrow
A(i)
A(e)- A(j)

4.6. How to calculate certain limits
135
is a monotone map. Eventually we put these extra facilities to good use.
For the ﬁrst step we forget the extra facilities and drop down to Set. We
look at the limit of this Set-diagram, the set of all threads
a : I
- S A
together with the I-indexed family
A
σ(i)- A(i)
a
- a(i)
of evaluation functions. Recall that a thread satisﬁes
A(e)
 a(i)

= a(j)
for each edge e, as above. This family of equalities rephrases as
A(e) ◦α(i) = α(j)
using the evaluation function α.
Our job is to furnish A as a poset, and check that each evaluation function
is monotone. In this way we produce a left solution of the Pos-diagram. We
then show that this solution is universal, a limit in Pos.
How can we partially order A? In other words, how can we compare threads?
In this kind of situation there is one trick that should always be tried. We use
the pointwise comparison. We let
a ≤b ⇐⇒(∀i ∈I)[a(i) ≤b(i)]
for threads a and b. Notice how this works. For threads a and b we pass to each
poset A(i) in turn and carry out a comparison there. All of these must give a
positive answer.
Why does this give a partial order on A? Verifying the three properties is
routine. Let’s look at the antisymmetry. Consider two threads a and b with
a ≤b ≤a. Then, for each i ∈I, we have
a(i) ≤b(i) ≤a(i)
and hence a(i) = b(i), since A(i) is a poset. Thus a = b.
Next we show that each evaluation function α(i) is monotone, that is
a ≤b =⇒α(i)(a) ≤α(i)(b)
for threads a and b. Since
α(i)(a) = a(i)
α(i)(b) = b(i)
this is immediate.

136
Limits and colimits in general
This produces the furnishings. Why does it give us a left solution of the
diagram in Pos? We require each cell
A(i)
i
A
α(i)
-
A(j)
A(e)
?
α(j)
-
j
e
?
to be a commuting triangle in Pos, for each edge e, as indicated. This is cer-
tainly a triangle in Pos. We are given that each A(e) is monotone, and we
have ensured that α(i) and α(j) are monotone. This Pos-triangle commutes
because it commutes down in Set.
Our next job is to show that this left solution is universal in Pos. To do that
we compare it with an arbitrary left solution of the Pos-diagram. Thus we
assume given a poset X together with an I-indexed family of monotone maps
X
ξ(i)- A(i)
such that the Pos-triangle
A(i)
i
X
ξ(i)
-
A(j)
A(e)
?
ξ(j)
-
j
e
?
commutes for each edge e, as indicated. We require a unique mediator
X
µ
- A
which, of course, must be monotone.
Think about this. If there is such a mediator µ then, by passing down to Set,
it can only be that function that works for the Set-diagram. If that function
turns out to be monotone, it will certainly make all the required Pos-triangles
commute, for they commute down in Set. Thus we don’t have much choice.
The Set-mediator is given by
µ(x)(i) = ξ(i)(x)
for each x ∈X and i ∈I. We have to show this function is monotone.

4.6. How to calculate certain limits
137
Why does
x ≤y =⇒µ(x) ≤µ(y)
hold for all x, y ∈X? Consider such x, y ∈X with x ≤y. We are given that
each ξ(i) is monotone, so that
ξ(i)(x) ≤ξ(i)(y)
and hence, by deﬁnition of µ, we have
µ(x)(i) ≤µ(y)(i)
for each i ∈I. Finally, remember that each of µ(x) and µ(y) is a thread, so
that this last universally quantiﬁed comparison gives
µ(x) ≤µ(y)
as required.
The construction of this block is fairly typical. We will use it again with
minor variations to produce limits in two more categories.
Exercises
4.6.2
(a) Let Eqv be the category of equivalence relations. Each object is a
pair (A, ∼) where A is a set and ∼is an equivalence relation on A. Make sure
you understand the arrows. Exercise 1.2.3 will help.
(b) Let ∇= (I, E) be a template, and consider a ∇-diagram
A(∼) =
 (A(i), ∼i) | i ∈I

A(D) =
 A(e) | e ∈E

in Eqv. By forgetting the distinguished subsets we obtain a ∇-diagram
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

in Set. Consider the limit of the diagram in Set, that is the set of threads with
the attached functions. Show that this can be furnished to produce a limit of
the diagram in Eqv.
4.6.3
Let ∇= (I, E) be a template. Let R be a monoid and let
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

be a ∇-diagram in Set-R. Show how the set of threads can be furnished to
produce a limit of this diagram.

138
Limits and colimits in general
4.6.3 Limits in Mon
In this block we show how the construction of Block 4.6.1 also produces lim-
its in Mon, the category of monoids. The general procedure is the same as
outlined at the beginning of Block 4.6.2. Starting from a diagram in Mon, we
pass to Set and take the limit of that Set-diagram. The main problem is to
furnish that Set-limit to become a limit of the original Mon-diagram.
Recall that a monoid is a furnished set
(A, •, 1)
where ‘•’ is a binary operation on A, and 1 is a distinguished element. These
attributes must satisfy
(a • b) • c = a • (b • c)
1 • a = a = a • 1
for all a, b, c ∈A. In general, we write
ab
for
a • b
but there is one case when we will explicitly show the operation symbol.
Monoids are the objects of Mon. The arrows are the monoid morphism.
Recall that a monoid morphism
(A, •, 1)
f- (B, •, 1)
is a function
f : A
- B
between the carriers such that
f(ab) = f(a)f(b)
f(1) = 1
for all a, b ∈A.
As usual we have a template ∇with a collection I of nodes and a collection
E of edges. We also have an instantiation
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

to form a Mon-diagram. Thus each A(i) is a monoid and each A(e) is a
monoid morphism. By passing to Set we obtain the set A of all threads
a : I
- S A
together with the I-indexed family
A
α(i)- A(i)

4.6. How to calculate certain limits
139
of evaluation functions. Our ﬁrst job is to furnish A as a monoid, and check
that each evaluation function is a monoid morphism.
How can we combine a pair of threads a and b to form
a ⋆b
a third thread? This is the case where we will explicitly indicate the operation.
Let
(a ⋆b)(i) = a(i)b(i)
for each i ∈I. Notice how we use the operation on A(i). This construction
certainly gives a function
a ⋆b : I
- S A
and it is a choice function since a(i)b(i) lives in A(i).
Why is a⋆b a thread? Consider an arbitrary edge e from i to j. We remember
that A(e) is a monoid morphism. Thus
A(e)
 (a ⋆b)(i)

= A(e)
 a(i)b(i)

=

A(e)
 a(i)

A(e)
 b(i)

= a(j)b(j) = (a ⋆b)(j)
as required. Why is this operation associative? Because
 (a ⋆b) ⋆c

(i) =
 (a ⋆b)(i)

c(i)
=
 a(i)b(i)

c(i)
= a(i)
 b(i)c(i)

= a(i)
 (b ⋆c)(i)

=
 a ⋆(b ⋆c)

(i)
for all a, b, c ∈A and i ∈I. We need a distinguished element of A. We set
1(i) = 1i for each i ∈I. Here 1i is the distinguished element of A(i). It is
easy to check that this function 1 is a thread and, almost trivially, we have
1 ⋆a = a = a ⋆1
for each thread a. Thus we have furnished A as a monoid.
Why is each evaluation function
A
α(i)- A(i)
a monoid morphism? Because
α(i)
 a ⋆b

=
 a ⋆b

(i) = a(i)b(i) =
 α(i)(a)
 α(i)(b)

for each a, b ∈A.

140
Limits and colimits in general
This sets up the furnishings. Why does it give a left solution of the Mon-
diagram? To be a left solution we require that certain triangles commute in
Mon. These triangles do commutes in Set, and they are triangles in Mon,
so they commute in Mon.
Our main job is to show that this left solution is universal in Mon. To do that
we compare it with an arbitrary left solution of the Mon-diagram. We assume
given a monoid X together with an I-indexed family of monoid morphisms
x
ξ(i) - A(i)
such that the Mon-triangle
A(i)
i
X
ξ(i)
-
A(j)
A(e)
?
ξ(j)
-
j
e
?
commutes for each edge e, as indicated. We require a unique mediator
X
µ
- A
which, of course, must be a monoid morphism.
By passing to Set we see there is only one possible function µ we can use,
that given by
µ(x)(i) = ξ(i)(x)
for each x ∈X and i ∈I. Thus it sufﬁces to show that this function µ is a
monoid morphism. For each x, y ∈X and i ∈I, remembering that ξ(i) is a
monoid morphism, we have
µ(xy)(i) = ξ(i)(xy)
=
 ξ(i)(x)
 ξ(i)(y)

=
 µ(x)(i)
 µ(y)(i)

=
 µ(x) ⋆µ(y)

(i)
so that
µ(xy) = µ(x) ⋆µ(y)
to show that µ passes across the operation. The other requirement
µ(1) = 1
is even easier.
This kind of construction works in many algebraic categories. In fact, the
earlier Exercise 4.6.3 uses exactly the same technique.

4.6. How to calculate certain limits
141
Exercises
4.6.4
(a) Let CMon be the category of commutative monoids. Show that
the construction of this block produces limits in CMon.
(b) Let Grp be the category of groups. Show that the construction of this
block produces limits in Grp.
(c) Let Rng be the category of unital rings. Show that Rng has limits for
∇= (I, E) diagrams.
4.6.5
A partially ordered monoid (a pom) is a structure
(A, ≤, ·, 1)
where (A, ≤) is a poset and (A, ·, 1) is a monoid, and
x ≤a
y ≤b

=⇒xy ≤ab
for all a, b, x, y ∈A. These are the objects of the category Pom. An arrow of
Pom is a monoid morphism that is also monotone. For an arbitrary template
∇= (I, E) show that each ∇-diagram in Pom has a limit.
4.6.4 Limits in Top
In this block we show how the construction of Block 4.6.1 also produces limits
in Top, the category of topological spaces and continuous maps. In topologi-
cal circles a left limit is usually called an inverse limit. More often than not the
template is a partial order or even a pre-order, and the indexing is contravariant.
We won’t deal with that aspect here.
As usual we have a template ∇of nodes I and edges
A =
 A(i) | i ∈I

A =
 A(e) | e ∈E

to form a Top-diagram. Thus each A(i) is a topological space and each A(e)
is a continuous map. By passing to Set we obtain the set A of all threads
a : I
- S A
together with the I-indexed family
A
α(i)- A(i)
of evaluation functions. Our ﬁrst job is to convert A into a topological space in
such a way that each α(i) is continuous.

142
Limits and colimits in general
Consider any node i ∈I and any open U ∈OA(i) of that component. We
certainly require the inverse image set
i(U) = α(i)←(U) = {a ∈A | a(i) ∈U}
to be open. Thus we take the family of all these subsets of A as a subbase of a
topology on A. This ensures that each α(i) is continuous.
In the usual way this gives us a left solution of the diagram. This has nothing
much to do with the topological aspects. It’s merely that certain triangles of
function do commute.
Our main job is to show that this left solution is universal in Top. To do
that we compare it with an arbitrary left solution of the Top-diagram. Thus
we assume given a topological space X together with an I-indexed family of
continuous maps
X
ξ(i)- A(i)
such that the Top-triangle
A(i)
i
X
ξ(i)
-
A(j)
A(e)
?
ξ(j)
-
j
e
?
commutes for each edge e, as indicated. We require a unique mediator
X
µ
- A
which, of course, must be a continuous map.
By passing to Set the only possible mediating function is given by
µ(x)(i) = ξ(i)(x)
for each x ∈X and i ∈I. Thus it sufﬁces to show that this function µ is
continuous. To do that it sufﬁces to show that for each subbasic open set of A
the inverse image across µ is open. Thus we require
µ←(i(U)) ∈OR
for each node i ∈I and open U ∈OA(i). For each x ∈X we have
x ∈µ←(i(U)) ⇐⇒µ(x) ∈i(U) = α(i)←(U)
⇐⇒α(i)(µ(x)) ∈U
⇐⇒µ(x)(i) ∈U
⇐⇒ξ(i)(r) = µ(x)(i) = U
⇐⇒x ∈ξ(i)←(U)

4.7. Conﬂuent colimits in Set
143
to show that
µ←(i(U)) = ξ(i)←(U)
for each pair i and U. Since each ξ(i) is continuous this shows that each
µ←(i(U)) is open, for the required result.
Notice how this construction and proof works. To ensure that each α(i) is
continuous we need at least all the sets i(U) in the topology on A. To show
that a mediator µ is continuous we can’t deal with more than the sets i(U).
Exercises
4.6.6
Let I be a discrete template (that is, just a set). Let A be an I-diagram
in Top (that is, an I-indexed family of topological spaces). Describe the limit
of A, and relate this to a standard topological notion.
4.7 Conﬂuent colimits in Set
We have looked at examples of limits. In this section we see how to calculate
a certain kind of colimit. We work in the category Set of sets, but the same
method works for other categories of structured sets.
For this example we assume the template is a poset. Thus let I be a poset
with nodes
i, j, k, . . .
and for each comparison i ≤j let
i
(j, i) - j
be the corresponding edge.
We assume I satisﬁes a certain restriction
4.7.1 Deﬁnition
The poset I is directed if for each i, j ∈I there is some
k ∈I with i, j ≤k.
The poset I is conﬂuent if for each i, j, l ∈I with l ≤i, j, there is some
k ∈I with i, j ≤k.
Trivially, each directed poset is conﬂuent, but there are conﬂuent posets that
are not directed. For example, each discrete set is conﬂuent but not directed (if
it has more than one node). Notice that if a poset is directed then (by repeated
use of this property) each ﬁnite subset has at least one upper bound. Similarly,

144
Limits and colimits in general
if a poset is conﬂuent, then each ﬁnite subset which has a lower bound also has
an upper bound.
We assume the template poset I is conﬂuent.
Let (A, A) be an I-diagram in Set. This is an I-indexed family of sets
A(i)
together with connecting functions
A(i) A(j, i)- A(j)
one for each comparison i ≤j in I. These functions must compose in the usual
way, that is
A(i, i) = idA(i)
and
A(k, j) ◦A(j, i) = A(k, i)
for i ≤j ≤k. To help with the later calculations it is convenient to write
A(i)
- A(j)
x
- x|j
for the function A(j, i). Thus
x|j = A(j, i)(x)
and we may think of this as the ‘restriction’ of x ∈A(i) to j. Note that
x|i = x
x|j|k = x|k
for i ≤j ≤k with x ∈A(i).
To obtain the colimit of (A, A) we ﬁrst produce the coproduct of A. Consider
the disjoint union of the sets A(i). We set this up with some care. We let
⨿A = S{A(i) × {i} | i ∈I}
that is we take the set of all pairs
(x, i)
for i ∈I and x ∈A(i). An element x may occur many times, but each occur-
rence is tagged with an index. For each i ∈I there is a function
A(i)
- ⨿A
x
- (x, i)
and these functions structure ⨿A as the coproduct of A in Set. The proof of
that is the discrete case of the following proof.

4.7. Conﬂuent colimits in Set
145
For the general situation we take a quotient of ⨿A. Consider the relation ∼
on ⨿A given by
(x, i) ∼(y, j) ⇐⇒(∃i, j ≤k)[x|k = y|k]
for (x, i) and (y, j) from ⨿A. Here the quantiﬁer looks for a node k which is
an upper bound of the two given nodes. Trivially, this relation is reﬂexive and
symmetric. We show it is transitive, and hence is an equivalence relation on
⨿A. To do that we use the conﬂuence of I.
Consider any situation
(x, i) ∼(y, j) ∼(z, k)
so that (x, i) ∼(z, k) is required. We are given nodes l, m with
i, j ≤l
j, k ≤m
x|l = y|l
y|m = z|m
respectively. Now look how the nodes sit in I.
i
l
-
j
-
n
-
m
-
-
k
-
The nodes l, m have a lower bound and hence, by conﬂuence, they have some
upper bound n. But now
x|n = x|l|n = y|l|n = y|n = y|m|n = z|m|n = z|n
to show that
(x, i) ∼(z, k)
as required.
Since ∼is an equivalence relation on ⨿A we may take
L = ⨿A/∼
the family of blocks (equivalence classes) of ∼in ⨿A. Let
⨿A
- L
(x, i)
- [x, i]
be the associated quotient function. For later observe that
[x, i] = [x|j, j]
for all nodes i ≤j.

146
Limits and colimits in general
We show that the family of composite functions
A(i)
- ⨿A
- L
x
- (x, i)
- [x, i]
structure L as the colimit of the I-diagram A.
We ﬁrst show that we do have a right solution of the diagram. Consider any
pair of nodes i ≤j. We require that the inner triangle commutes.
x
- [x, i]
A(i)
- L[x|j, j]
A(j)
-
-
x|j
-
-
To prove that we track an element from the top left hand corner to the top right
hand corner by the short trip and the long trip. We require
[x, i] = [x|j, j]
and this is nothing more than the observation made above.
Now we show that we have a universal right solution. Consider any right
solution M where for nodes i ≤j the commuting triangle
A(i)
αi
- M
A(j)
αj
-
-
is a typical part of the structure. Thus we have
αj(x|j) = αi(x)
for each x ∈A(i). We require a unique function
L
µ
- M
such that for each node i the triangle
A(i)
αi
- M
L
µ
-
-
commutes. If there is such a function µ, then
µ
 [x, i]

= αi(x)

4.7. Conﬂuent colimits in Set
147
for each i ∈I and x ∈A(i). This shows that there is at most one such µ.
To show there is at least one, it sufﬁces to show that this assignment is well-
deﬁned, that is
[x, i] = [y, j] =⇒αi(x) = αj(y)
for i, j ∈I and x ∈A(i), y ∈A(j). Assuming
[x, i] = [y, j]
we have
(x, i) ∼(y, j)
to give
x|k = y|k
for some node k with i, j ≤k. But now
αi(x) = αk(x|k) = αk(y|k) = αj(y)
for the required result.
Exercises
4.7.1
Let I be a conﬂuent poset and let (A, A) be an I-diagram in Set-R for
some monoid R. Thus for each node i the component A(i) is an R-set, and for
each pair i ≤j of nodes the function
A(i)
A(j, i)- A(j)
is an R-morphism. Show that A has a colimit in Mon.
4.7.2
Let I be a conﬂuent poset and let (A, A) be an I-diagram in Mon.
Thus for each node i the component A(i) is a monoid, and for each pair i ≤j
of nodes the function
A(i) A(j, i)- A(j)
is a monoid morphism. Show that A has a colimit in Mon.
4.7.3
The solution to the last part of Exercise 2.5.2 is a bit terse. We can now
ﬁll in the missing details. Consider any category of algebras such as Mon. We
produce the coproduct A ⨿B of two objects A, B in three stages. First forget
the carried structure and look at the coproduct in Set, the disjoint union A ˙∪B.
Next freely generate a monoid from this set. Finally take a quotient of this free
monoid to convert certain functions into morphisms. Fill in the details.
4.7.4
Once you have mastered Exercise 4.7.3, show how to construct co-
equalizers in Pos.

5
Adjunctions
The isolation of the notion of an adjunction is one of the most important contri-
butions of category theory. In a sense adjoints form the ﬁrst ‘non-trivial’ part
of category theory; at least it can seem that way now that all the basic stuff
has been sorted out. There are adjunctions all over mathematics, and examples
were known before the categorical notion was formalized. We have already
met several examples, and later I will point you to them.
In this chapter we go through the various aspects of adjunctions quite slowly.
We look at each part in some detail but, I hope, not in so much detail that we
lose the big picture.
There is a lot going on in adjunctions, and you will probably get confused
more than once. You might get things mixed up, forget which way an arrow
is supposed to go, not be able to spell contafurious, and so on. Don’t worry.
I’ve been at it for over 40 years and I still can’t remember some of the details.
In fact, I don’t try to. You should get yourself to the position where you can
recognize that perhaps there is an adjunction somewhere around, but you may
not be quite sure where. You can then look up the details. If you ever have to
use adjunctions every day, then the details will become second nature to you.
5.1 Adjunctions deﬁned
When ﬁrst seen in full categorical adjunctions can seem a bit daunting. There
is a lot going on but in many particular examples much of this complexity can
disappear. In this section we look at all the various components and eventually
arrive at the formal deﬁnition. Then in the later sections we analyse the content
of the notion. For most of this section we merely run through the various bits of
gadgetry that make up an adjunction. We don’t look at the restrictions imposed
on these gadgets.

5.1. Adjunctions deﬁned
149
An adjunction is an interaction between two categories
Src
Trg
which we may think of as the
source
target
category. This is merely a conventional distinction, but it can help. These cat-
egories play similar roles, but some of their attributes are in mirror image.
We have two covariant functors
Src
F -

G
Trg
going between the two categories, but in opposite directions. These functors
are related in a certain way. We look at the details later. By convention we call
F the left
G the right
adjoint of the pair, and we write
F ⊣G
to indicate this relationship. We also write any of
Src
F
-
⊣

G
Trg
Src
F
-
⊥

G
Trg
Src
-
F ⊣G

Trg
to indicate the relationship. Usually the left functor is placed above the right
functor.
There are other notations used with adjunctions. Sometimes we write
F ∗
for
F
F∗
for
G
where the position of the decoration indicates which is the left and which is the
right component. This can be useful when there is more than one adjunction
around. In these circumstances we sometimes write F for the pair (F ∗, F∗).
For the time being we will stick with F ⊣G, but eventually we will use some
of this other notation.
By convention we think of an adjunction as passing in the direction of its
left adjoint. We write any of
Src
⇀Trg
Src
F ⊣G⇀Trg
Src
F ∗⊣F∗⇀Trg
for the adjunction making use of the harpoon arrow to alert us. This is the con-
ventional terminology and notation. Some of the older literature was written

150
Adjunctions
before these conventions were established. You might ﬁnd that left and right
are called something else, such as right and left.
The two functors can be composed to give endo-functors
G ◦F on Src
F ◦G on Trg
respectively. These composites are related to the corresponding identity func-
tors by natural transformations
IdSrc
η - G ◦F
F ◦G
ϵ - IdTrg
called the
unit
counit
of the adjunction. Notice the left/right antisymmetry of these gadgets.
Consider any pair A and S of objects
A from Src
S from Trg
respectively. An adjunction tries to compare these objects. Of course, there
isn’t a direct comparison, for they live in different worlds. To compare them
we move one of the objects to the other category, and do the comparison there.
Thus we use one of the two arrow sets
Src[A, GS]
Trg[FA, S]
of the indicated category. Notice that the
left functor F
right functor G
occurs in the
left position
right position
of the appropriate arrow set. This helps us to remember which functor is doing
which job.
Each of the two arrow sets provides a place where we might compare the
two objects. But which place should we use? It doesn’t matter, for part of the
gadgetry of an adjunction is an inverse pair of bijections
f
- f ♯
Src[A, GS]
Trg[FA, S]
g♭
g

5.1. Adjunctions deﬁned
151
between the two arrow sets. Furthermore, and this is the crucial aspect of an
adjunction, these two assignments
(·)♯
(·)♭
must be natural for variation of both A and S.
There is a lot going on here. In the next section we work through this data
again to see exactly what it means. Here is the formal deﬁnition.
5.1.1 Deﬁnition
An adjunction
 F, G, (·)♯, (·)♭

consists of a pair of covariant functors
Src
F
-
⊣

G
Trg
where, for each
Src-object A
Trg-object S
the two transposition assignments
Src[A, GS]
(·)♯
-

(·)♭
Trg[FA, S]
form an inverse pair of bijections, and each is natural in A and S.
Note that the data for an adjunction is not just a pair (F, G) of functors. We
also need the transposition assignments (·)♯and (·)♭. Of course, we only need
one of (·)♯and (·)♭, for each is the inverse of the other. The unit and the counit
aren’t mentioned in this deﬁnition, because we can show that
ηA = (idF A)♭
ϵS = (idGS)♯
do those jobs. It turns out that various selections of the data
F
G
(·)♯
(·)♭
η
ϵ
can be put together in different ways to form an adjunction. We look at these
various combinations in the following sections.
Exercises 5.1.1, 5.1.2, and 5.1.3 are rather straight forward. You have seen
most of the gadgetry before. Exercises 5.1.4, 5.1.5, and 5.1.6 are more compli-
cated, and you may have to return to them more than once.

152
Adjunctions
Exercises
5.1.1
Each poset can be viewed as a category. Show that a poset adjunction,
as in Example 1.3.3, is a categorical adjunction.
5.1.2
Each set S can be converted into a preset in two extreme ways. The
discrete version uses equality as the comparison. For the indiscrete version
any two elements are comparable. Show that the forgetful functor
Set 
Pre
has both a left and a right adjoint, and these are different.
5.1.3
Show that the forgetful functor
Set 
Top
has both a left and a right adjoint, and these are different.
5.1.4
For a poset S let LS be the poset of lower sections of S (under inclu-
sion).
(a) Show that each monotone function
S
f
- T
between posets induces a monotone function
LS  f ←
LT
via inverse image.
(b) Show that the monotone function f ←has both a left adjoint and a right
adjoint, and in general these are different. One of these is given by direct image,
and the other isn’t.
5.1.5
Let ∇be a category viewed as a template, let C be an arbitrary cate-
gory, and consider the diagonal functor.
C ∇ ∆
C
Show that C has a limit for each ∇-diagram precisely when ∆has a right
adjoint, and sort out the corresponding result for colimits.
5.1.6
Let
Src 
G
Trg
be a functor which does have a left adjoint. Show that each limit cone in Trg
is transported by G into a limit cone in Src.

5.2. Adjunctions illustrated
153
5.1.7
Let
Src
F ⊣G⇀Trg
be an adjunction, consider the product category Src × Trg, and consider the
two object assignments
(A, S)
F
- Trg[FA, S]
Src × Trg
- Set
(A, S)
G
- Trg[A, GS]
to the category of sets. In what sense are these the object assignments of a pair
of functors? Describe the arrow assignments.
5.2 Adjunctions illustrated
Deﬁnition 5.1.1 says what an adjunction is, but doesn’t tell us very much. There
are several hidden consequences of the deﬁnition. In the following sections we
take the deﬁnition apart, and look at the various components of an adjunction
in some detail. To do that it will help if there are some examples we can look
at. There are some simple examples. Exercises 5.1.2 and 5.1.3 give some of
these, and we will see a few more. In this section we look at two (or perhaps
it’s three) examples with a bit more content. The idea is that as you read the
following sections you can use these examples to illustrate what is going on.
Thus you shouldn’t expect to understand these examples immediately. Keep
coming back to them as you are learning the various aspects of adjunctions.
The two examples, an algebraic example and a topological example, are
miniature versions of more involved, and quite important, adjunctions. I will
say what these larger versions are, but at this stage we don’t go into any details.
There is also a rather simple set-theoretic example (as a preliminary for the
topological example). This is, perhaps, the best example to start with. However,
you should be careful with it. In some ways it is too simple to bring out all of
the different properties that an adjunction can have.
You should remember that an adjunction has many different components,
but in any particular example not all of these are important, and some can
be trivial. When learning about adjunctions in general, or about a particular
adjunction, it is a good idea to sort out all its little bits and pieces.

154
Adjunctions
5.2.1 An algebraic example
An involution algebra is a structure
(A, (·)•)
carried by a set A where (·)• is an involution on this carrier. In other words
(·)• is a 1-placed operation on A with
a•• = a
for each a ∈A. An involution morphism between involution algebras
A
φ
- B
is a function, as indicated, such that
φ(a•) = φ(a)•
for each a ∈A. This gives us the category
Inv
of involution algebras and involution morphisms.
Let
Set  U
Inv
be the underlying functor, the forgetful functor that loses the involution. We
show that U has adjoints on both sides
Set
Σ
-

U
Π
-
Inv
and these are quite different.
Before we begin to construct these adjoints let’s see where this example
comes from. There are three levels of generalization each of which is worth
analysing in its own right.
For the ﬁrst level recall the notion of a (right) R-set for a monoid R. An
involution algebra is nothing more than an R-set for an appropriate monoid R.
(Can you see which one?) The forgetful functor
Set 
Set-R
has both a left adjoint and a right adjoint. We look at this in Chapter 6. For the
next level consider an arbitrary morphism
S
f
- R

5.2. Adjunctions illustrated
155
between monoids. This induces a functor
Set-S 
Set-R
called restriction of scalars. This functor has both a left adjoint and a right
adjoint. When S is the trivial monoid this example reduces to the previous one.
Finally let f, as above, be a ring morphism. This induces a restriction of scalars
functor between the module categories.
Mod-S 
Mod-R
Again this has both a left adjoint and a right adjoint. In this case the left adjoint
is given by a tensor product, and the right adjoint is an enriched hom-functor.
All of these adjunctions are worth looking at some time.
Here we concentrate on the involutary case. From now on in this block the
only algebras and morphisms we meet are involutary, so we drop the qualiﬁer
‘involution’.
To produce the two adjoints it will help if we let
Set
Inv
X, Y, . . .
Objects
A, B, . . .
f, g, . . . , k, . . .
Arrows
φ, ψ, . . . , λ, . . .
range over the indicated gadgets.
We describe the initial parts of the two constructions in parallel.
For each set X let
ΣX = X + X
ΠX = X × X
that is
ΣX = {(x, i) | x ∈X, i = 0, 1}
ΠX = {(x, y) | x, y ∈X}
the set of {0, 1}-tagged elements of X, and the set of ordered pairs from X. It
is not hard to furnish each of these with an involution. For ΣX we ﬂip the tag,
and for ΠX we swap the components.
We require both Σ and Π to be functors to Inv. Given a function
Y
k
- X
what should
ΣY
Σ(k)- ΣX
ΠY
Π(k)- ΠX
be? We soon ﬁnd the answer, but verifying that it does produce morphisms
takes a bit of work. Think about this before you continue.

156
Adjunctions
This gives us two of the four components of each of the two adjunctions.
Next we require an inverse pair of assignments
f
- f ♯
φ
- φ♯
Set[X, UA]
Inv[ΣX, A]
Inv[A, ΠX]
Set[UA, X]
ψ♭
ψ
g♭
g
for each set X and each algebra A. This needs some thought.
For the left hand bijection it helps if we set
a(i) =
(
a• if i = 1
a if i = 0
for each a ∈A and tag i. In particular we have
a(i)• = a(1−i) = a•(i)
φ(a(i)) = φ(a)(i)
for each a ∈A, tag i, and morphism φ. For the right hand bijection remember
that φ is a morphism. You should now think about these constructions for a
while, and do Exercises 5.2.1 and 5.2.2.
Of course, this doesn’t quite prove that each of
 Σ, U, (·)♯, (·)♭

 U, π, (·)♯, (·)♭

is an adjunction. We need to show that each (·)♯and each (·)♭is natural. How-
ever, let’s leave that until we have a better idea of what that means.
Exercises
5.2.1
Describe the action of Σ and Π on functions, and verify that each result
is a morphism.
5.2.2
Set up the two inverse pairs of bijections (·)♯and (·)♭. At this stage
don’t worry about the required naturality.
5.2.2 A set-theoretic example
In this block we describe an easy example of an adjunction where the category
Set is both the source and target. We have met most of the components before.
We do this example here because in the next block we produce an enriched
version with Set replaced by Top. That has more content, but much of the
gadgetry is the same as in this Set example.
Let I be a ﬁxed set. We know that
−× I
is an endo-functor on Set. We show that this functor has a right adjoint and

5.2. Adjunctions illustrated
157
this is another functor that we already know. It is the hom-functor Set[I, −].
Thus, we attach to each set Y the set of all functions
I
- Y
from I to Y . To do that we use what at ﬁrst may seem an odd notation. For
each set Y let
I ⇒Y
be the set of all functions from I to Y . This gives us two endo-functors
−× I
I ⇒−
on Set. Recall that each function
X2
k - X1
Y1
l
- Y2
is sent to
X2 × I
- X1 × I
I ⇒Y1
- I ⇒Y2
(x, i)
- (k(x), i)
p
- l ◦p
respectively.
To show that
−× I
⊣I ⇒−
we at least require an inverse pair of bijections.
f
- f ♯
Set[X, I ⇒Y ]
Set[X × I, Y ]
g♭
g
for each pair X, Y of sets. This is an almost trivial exercise. In many math-
ematical situations we wouldn’t even distinguish between f and f ♯, nor be-
tween g and g♭. We should also prove that each of (·)♯and (·)♭is natural. For
this example, that is not difﬁcult, but let’s leave it until we have more of an
understanding of what it entails.
For the record let us state the result we are aiming at.
5.2.1 Theorem
For each set I, we have
−× I ⊣I ⇒−
an adjunction of endo-functors on Set.
As with any adjunction, this one has a unit and a counit
X
ηX- I ⇒(X × I)
(I ⇒Y ) × I
ϵY- Y
natural in X and Y , respectively. Here these are more or less obvious.

158
Adjunctions
Exercises
5.2.3
Write down the deﬁnitions of (·)♯and (·)♭. These two assignments are
little more than inserting or omitting brackets.
5.2.4
Write down the unit and counit, and show that each is natural.
5.2.3 A topological example
In this block we re-do the adjunction of Block 5.2.2 with Set replaced by
Top. As we will see, this is not entirely straightforward. We need to impose
appropriate conditions on the pivotal object I.
With this kind of result there are two interacting themes, a general and a
particular. The general theme is that of the categorical constructions and cal-
culations. Here we ﬁnd that most of these have been done in Block 5.2.2. That
is why we did that simple example before this one. The particular theme is
that of handling the topological restrictions. It is useful whenever possible to
separate the two themes. Category theory is good at handling the generalities.
By separating these from the particularities we see more clearly the speciﬁc
content of a result.
As in the Set example, in this Top case there are three players, the central
ﬁxed object I and the two varying objects X and Y . Here all three of X, I, Y
are topological spaces, and any functor we produce must return topological
spaces and continuous maps.
Let
(X, OX)
(I, OI)
(Y, OY )
be topological spaces with carried families of open sets, the topologies. We
know that the cartesian product X × I carries the product topology. This is the
smallest topology for which the two projections
X × I
- X
X × I
- I
are continuous. Thus for each U ∈OX and W ∈OI the product U × W is
open in X × I, and this set of products forms a subbase of the whole topology.
This space X ×I with these two continuous projections form a product wedge
in Top. Thus we have an endo-functor
−× I
on Top. Our aim is to ﬁnd a right adjoint to this functor. And we want this to
be an enriched hom-functor.

5.2. Adjunctions illustrated
159
For spaces I and Y let
I ⇒Y
be the set of all continuous maps from I to Y . This is smaller than the set of
all functions from I to Y , so perhaps we should use a different notation. But
we won’t. However, if you do become confused then try a slightly different
notation. With I ﬁxed this certainly gives a functor
Top I ⇒−- Set
but this isn’t good enough. The functor must output to Top, not just Set. This
means we have to ﬁnd a way of topologizing (I ⇒Y ).
Let
KI
be the family of compact subsets K of I. Before we continue make sure you
know what a compact subset is. Don’t go all quasi; it’s bad for you!
5.2.2 Deﬁnition
For K ∈KI and V ∈OY let
⟨K, V ⟩
be the set of continuous maps
I
θ
- Y
θ[K] ⊆V
with the indicated property, that is θ(i) ∈V for all i ∈K. The compact open
topology on (I ⇒Y ) has the family of all ⟨K, V ⟩as a subbase.
This certainly topologizes (I ⇒Y ), but we want (I ⇒−) to be an endo-
functor on Top, so we also need an action on arrows.
Consider any map ψ between two spaces, as on the left.
Y1
ψ
- Y2
(I ⇒Y1)
Ψ- (I ⇒Y2)
θ
- ψ ◦θ
This induces an assignment Ψ between the two function spaces, as on the right.
We check that Ψ is continuous. Consider any K ∈KI and V ∈OY2. We need
Ψ← ⟨K, V ⟩

to be open in I ⇒Y1. But a simple calculation gives
Ψ← ⟨K, V ⟩

= ⟨K, ψ←(V )⟩
which is open in (I ⇒Y1) since ψ is continuous. (Do that calculation.)

160
Adjunctions
This gives the arrow assignment for (I ⇒−), and the functorial properties
are almost immediate.
We have a pair of endo-functors on Top, but these don’t necessarily form
an adjoint pair. For that we need I to be a particular kind of space.
Read the following deﬁnition carefully.
5.2.3 Deﬁnition
A topological space I is locally compact if for each situa-
tion
r ∈V ∈OI
we have
r ∈W ⊆K ⊆V
for some K ∈KI and W ∈OI.
With these preliminaries we have the following. We prove this shortly.
5.2.4 Theorem
For each locally compact space I, we have
−× I ⊣I ⇒−
an adjunction of endo-functors on Top.
Theorem 5.2.4 is important in its own right, but it also has an important
reﬁnement. Consider the case where I is the real interval [0, 1], and we modify
the two spaces
X × I
I ⇒Y
to produce the
suspension space of X
loop space of Y
respectively. A loop in the space Y is a continuous map
ℓ: I
- Y
with ℓ(0) = ℓ(1). We consider the set of all such loops as a subspace of I ⇒Y .
We modify the product space X × I by pinching together all points
(x, 0)
for x ∈X
and all points
(x, 1)
for x ∈X
to obtain two pinch points. Technically we take a certain quotient space of
X × I. It can be shown that

5.2. Adjunctions illustrated
161
Suspension ⊣Loop
by adding to the proof of Theorem 5.2.1. (There are some technicalities that I
have omitted, but this description is not too far from the truth.)
The proof of Theorem 5.2.4 will take some time. We will do it in little bits
as we get to know the general categorical notions. The overall method of proof
is the same as for Theorem 5.2.1 with an extra layer of complexity. We must
check that various functions are continuous.
Throughout we ﬁx I, an arbitrary locally compact space.
The ﬁrst thing we must do is set up an inverse pair of assignments
φ
- φ♯
Top[X, I ⇒Y ]
Top[X × I, Y ]
ψ♭
ψ
for arbitrary spaces X and Y . In fact we use the same trick as for the Set case.
Thus we set
ψ♭(x)(i) = ψ(x, i)
φ♯(x, i) = φ(x)(i)
for each x ∈X and i ∈I. Of course, we must show that φ♯and ψ♭are
continuous, but once we have done that the rest of the proof is trivial (as for
the Set case).
We look ﬁrst at the construction
ψ♭
ψ
since this doesn’t make use of the local compactness of I. We are given a
continuous function
X × I
ψ - Y
where X × I carries the product topology. Since ψ is continuous we see that
for each x ∈X the function
ψ(x, ·) : I
- Y
is continuous. Thus we may deﬁne a function
ψ♭: X
- (I ⇒Y )
by
ψ♭(x)(i) = ψ(x, i)
for each x ∈X and i ∈I. Our job is to show that ψ♭is continuous, where
(I ⇒Y ) carries the compact open topology.

162
Adjunctions
5.2.5 Lemma
For each pair X and Y of topological spaces, and each con-
tinuous map
X × I
ψ - Y
the induced function
X
ψ♭- (I ⇒Y )
as deﬁned above is continuous.
Proof
Consider any subbasic open set
⟨K, V ⟩
of (I ⇒Y ), where
K ∈KI
V ∈OY
are the two components. We require
ψ←
♭
 ⟨K, V ⟩

to be open in X. Consider any member s of this set. We require
s ∈U ⊆ψ←
♭
 ⟨K, V ⟩

for some U ∈OX. We have
ψ♭(s) ∈⟨K, V ⟩
that is
ψ(s, i) = ψ♭(s)(i) ∈V
for i ∈K. We now use the continuity of ψ and the compactness of K.
Next we look at the construction
φ
- φ♯
and this does make use of the local compactness of I.
5.2.6 Lemma
Let I be a locally compact topological space. For each pair X
and Y of topological spaces, and for each continuous map
X
φ- (I ⇒Y )
where (I ⇒Y ) carries the compact open topology, there is a continuous map
X × I
φ♯
- Y

5.2. Adjunctions illustrated
163
given by
φ♯(x, i) = φ(x)(i)
for each x ∈X and i ∈I.
Proof
Consider any V ∈OY and any member
(s, r) ∈φ♯←(V )
of the inverse image of V across φ♯. Remembering how X × I is topologized,
it sufﬁces to produce open neighbourhoods
s ∈U ∈OX
r ∈W ∈OI
such that
U × W ⊆φ♯←(V )
holds. We satisfy the conditions in turn.
We know that
φ(s) : I
- Y
is continuous, and hence
φ(s)←(V )
is open on I. But
φ(s)(r) = φ♯(s, r) ∈V
so that
r ∈φ(s)←(V )
and hence the local compactness of I gives
r ∈W ⊆K ⊆φ(s)←(V )
for some K ∈KI and W ∈OI. This W is one of the open sets we need.
The pair K and V give us a subbasic open set
⟨K, V ⟩
of I ⇒Y . Thus, since φ is continuous, we see that
U = φ← ⟨K, V ⟩

is open in X. We check that this is the other open set we need.

164
Adjunctions
This sets up the inverse pair of bijections for a given pair X, Y . However, we
need these bijections to be natural for variation of X and Y . We can postpone
a proof of that for a while until we have analysed the general notion in more
detail. However, I can tell you that the proof is exactly the same as for the Set
case. There is no more work to be done.
Exercises
5.2.5
Fill in the details required to show that (I ⇒−) is an endo-functor on
Top. Many of the calculations are the same as the Set case.
5.2.6
Complete the proof of Lemma 5.2.5. As a hint, for a ﬁxed s let i range
through K to obtain an open covering of K.
5.2.7
Complete the proof of Lemma 5.2.6. As a hint, observe that for i ∈I
we have
i ∈K =⇒i ∈φ(s)←(V ) =⇒φ(s)(i) ∈V
and hence s ∈U.
5.2.8
For the Top adjunction write down the unit and the counit, and show
that each is natural.
5.3 Adjunctions uncoupled
In this and the next two sections we look at various aspects of Deﬁnition 5.1.1.
As we do this you should keep going back to the examples of Section 5.2. This
will help you understand the general notions. The Set example is always a
good place to start, but you should also investigate at least one of the other two
examples.
To form an adjunction the data
(F, G, (·)♯, (·)♭)
must satisfy two requirements: the bijection requirement and the naturality
requirement. The bijection requirement is easy to understand. The naturality
requirement needs to be looked at.
The naturality property can be split into several smaller parts. Furthermore,
these can be put together in different ways, sometimes in tandom with unit
or counit properties, to determine an adjunction. We begin to look at these
combinations in this section.

5.3. Adjunctions uncoupled
165
Table 5.1 The various requirements for an adjunction
(Bij) For all
Src
Trg
A
objects
S
A
f - GS
arrows
FA
g - S
from the indicated categories, both
(f ♯)♭= f
(g♭)♯= g
hold.
(Nat) For all
Src
Trg
B
A
objects
S
T
B
k - A
S
l
- T
arrows
A
f
- GS
FA
g
- S
from the indicated categories, both
(♯)
(G(l) ◦f ◦k)♯= l ◦f ♯◦F(k)
G(l) ◦g♭◦k = (l ◦g ◦F(k))♭
(♭)
hold.
The bijection requirement, (Bij), is given in Table 5.1. It merely says that
for each pair of objects A ∈Src and S ∈Trg, the two assignments
f
- f ♯
Src[A, GS]
Trg[FA, S]
g♭
g
form an inverse pair of bijections. Each of (·)♯and (·)♭determines the other.
Thus in any particular example it sufﬁces to mention just one of them, and say
that it is a bijection. Its inverse is the other one.
The naturality requirement, (Nat), is more complicated. It says that each of
the transposition assignments (·)♯and (·)♭is natural. But what does that mean?

166
Adjunctions
Recall that we may form a product category
Src × Trg
whose objects are pairs
(A, S)
of objects A ∈Src and S ∈Trg. We won’t say what the arrows are just yet,
and you will see why in a moment. The two functors F and G give functors F
and G
(A, S)
F
- Trg[FA, S]
Src × Trg
- Set
(A, S)
G
- Src[A, GS]
to the category of sets. Now you can see that we have to be a bit careful. Arrow
sets have different variance, namely
[Contra , Co]
in the two positions. Technically we are dealing with a pair of functors
Srcop × Trg
F
-
G
- Set
where we use the opposite of Src. The naturality requirement (Nat) says that
(·)♯and (·)♭provide natural isomorphisms between F and G.
That does describe the requirements, but let’s look more closely.
Consider a pair of arrows from the two categories.
B
k
- A
S
l
- T
Notice how we have anticipated the contravariance on the Src component. The
pair (k, l) form an arrow in the product category
Srcop × Trg
which is the source of both F and G. Using (k, l) we obtain the pair of com-
muting diagrams in Set given in Table 5.2. Each arrow
A
f
- GS
of Src
FA
g
- S
of Trg
is sent to
B
G(l) ◦f ◦k- GT
FB
l ◦g ◦F(k)- T

5.3. Adjunctions uncoupled
167
Table 5.2 Two commuting diagrams in Set
Each pair (k, l) of arrows induces two commuting diagrams
B
k - A
S
l - T
(A, GS)
(FA, S)
(B, GS)
−◦k

(A, GT)
G(l) ◦−
-
(FB, S)
−◦F(k)

(FA, T)
l ◦−
-
(B, GT)
λ
?
−◦k

G(l) ◦−
-
(FB, T)
ρ
?
−◦F(k)

l ◦−
-
where the components are as follows.
(A, GS) = Src[A, GS]
(FA, S) = Trg[FA, S]
(B, GS) = Src[B, GS]
(FB, S) = Trg[FB, S]
(A, GT) = Src[A, GT]
(FA, T) = Trg[FA, T]
(B, GT) = Src[B, GT]
(FB, T) = Trg[FB, T]
λ = G(l) ◦−◦k
ρ = l ◦−◦F(k)
respectively
Now, for given k and l, consider the two paths from G to F.
f
- f♯
Src[A, GS]
(·)♯
- Trg[FA, S]
Src[B, GT]
?
(·)♯
- Trg[FB, T]
?
l ◦f ♯◦F(k)
?
G(l) ◦f ◦k
?
- (G(l) ◦f ◦k)♯
The naturality of (·)♯is that these two paths agree for all k, l, f. In the same
way, the naturality of (·)♭is that the two paths
g♭
g
Src[A, GS] 
(·)♭
Trg[FA, S]
G(l) ◦g♭◦k
?
Src[B, GT]
?

(·)♭
Trg[FB, T]
?
(l ◦g ◦F(k))♭
l ◦g ◦F(k)
?
agree for all k, l, g.

168
Adjunctions
The naturality requirement, (Nat), is given in Table 5.1. It is stated as two
identities
(♯)
(♭)
in the arrows k, l, f, g. You should note the type and naming of these arrows.
We invoke these identities many times, and we can’t always use matching let-
ters. And sometimes we need only some of the arrows. In this account we try to
stick to the notation used in (Nat). However, sometimes we have to use differ-
ent letters for the arrows, and sometimes these seem to appear out of position.
By Exercise 3.4.4, if each component of a natural transformation is a bijec-
tion, then the inverse is also natural. This simpliﬁes (Nat).
5.3.1 Lemma
In the presence of (Bij), each of the two identities (♯), (♭) of
(Nat) implies the other.
Proof
Assuming (♯) let’s check (♭). For this we need arrows k, l, g of the
indicated type. Let f = g♭to obtain the fourth arrow. From (Bij) we have
g = f ♯. Using (♯) at the second step we have
(G(l) ◦g♭◦k)♯= (G(l) ◦f ◦k)♯= l ◦f ♯◦F(k) = l ◦g ◦F(k)
so that
G(l) ◦g♭◦k = (l ◦g ◦F(k))♭
by a second use of (Bij).
This shows that in (Nat) only one of the two identities (♯) and (♭) is needed.
So why did we bother to state both? Because some particular examples are
best handled using one condition rather than the other. In fact, we can go even
further. We can decompose each of (♯) and (♭) into two bits, and use various
combinations of these bits. By taking either k or l to be an identity arrow we
obtain four instances of (♯) and (♭).
(♯↑)
(G(l) ◦f)♯= l ◦f ♯
(♭↑)
g♭◦k = (g ◦F(k)♭
(♯↓)
(f ◦k)♯= f ♯◦F(k)
(♭↓)
G(l) ◦g♭= (l ◦g)♭
In these each occurring arrow has the type given in (Nat). Also, each condition
is quantiﬁed. For instance, (♯↑) says
For each pair of arrows
A
f
- GS
S
l
- T
we have ...

5.3. Adjunctions uncoupled
169
and requires only two arrows, as indicated.
The following gives many of the combinations you may meet.
5.3.2 Lemma
Consider a pair of functors
Src
F -

G
Trg
and a pair of assignments (·)♯and (·)♭satisfying (Bij). Then
(♯↑) ⇐⇒(♭↓)
(♯↓) ⇐⇒(♭↑)
and the data form an adjunction precisely when one of the four pairs
(♯↑), (♭↑)
(♯↑), (♯↓)
(♭↑), (♭↓)
(♯↓), (♭↓)
of conditions holds.
Proof
The proof of the top two equivalences is more or less the same as that
of Lemma 5.3.1. We take
k = idA
l = idS
as appropriate. Similarly, every adjunction satisﬁes each of the four conditions
(♯↑), (♯↓), (♭↑), (♭↓).
It remains to verify that any one of the four pairs ensures that we have an
adjunction. Let’s look at the pair (♯↑), (♯↓). It sufﬁces to show
(♯↑), (♯↓) =⇒(♯)
and then invoke Lemma 5.3.1. Consider arrows k, l, f as in (Nat). Using (♯↑)
and then (♯↓) we have
(G(l) ◦f ◦k)♯= l ◦(f ◦k)♯= l ◦f ♯◦F(k)
as required. Notice that (♯↑) is applied to the pair
B
f ◦k- GS
S
l
- T
which is allowed by the quantiﬁed condition.
As you can see, there are several combinations of the structured data
(F, G, (·)♯, (·)♭)
which lead to an adjunction. It is best not to try to remember the details, but
merely that there are variants.

170
Adjunctions
Exercises
5.3.1
Deﬁnition 5.1.1 requires that the bijections (·)♯, (·)♭are natural for vari-
ation of both A and S. In Lemma 5.3.1 both A and S vary at the same time.
What happens if we ﬁx one of A, S and let the other vary? What conditions
arise out of that kind of naturality?
5.3.2
Consider the two algebraic constructions of Block 5.2.1. For both cases
show that each of the two assignments (·)♯and (·)♭is natural. In each case draw
the square that must commute.
5.3.3
Consider the set-theoretic construction of Block 5.2.2. Show that each
of the two assignments (·)♯and (·)♭is natural. In each case draw the square
that must commute.
5.3.4
Consider the topological construction of Block 5.2.3. Show that the two
assignments (·)♯and (·)♭are natural. In each case draw the square that must
commute. Did you notice something about the proof?
5.4 The unit and the counit
In Section 5.1 the unit and the counit of an adjunction made a brief appearance,
but were not part of the ofﬁcial gadgetry discussed in Section 5.2. In fact,
the unit and counit are important attributes of an adjunction, and can be more
important than the transposition assignments. When appropriately restricted
they can determine the adjunction.
5.4.1 Deﬁnition
Given an adjunction, as in Deﬁnition 5.1.1, we set
ηA = (idF A)♭
ϵS = (idGS)♯
for each
Src-object A
Trg-object S
to obtain arrows
A
ηA- (G ◦F)A
(F ◦G)S
ϵS- S
the
unit
counit
of the adjunction. (Note that ‘counit’ is pronounced ‘co-unit’.)
This section is devoted to an analysis of these gadgets. Naturally, we begin
with their most important property.

5.4. The unit and the counit
171
5.4.2 Lemma
The unit and the counit of an adjunction are natural.
Proof
We deal with the unit. The counit is dealt with in a similar way.
Consider any arrow
B
k
- A
of Src. We must show that the square
B
ηB - (G ◦F)B
ηB = (idF B)♭
A
k
?
ηA
- (G ◦F)A
(G ◦F)(k)
?
ηA = (idF A)♭
commutes, that is we must check that
(G ◦F)(k) ◦ηB = ηA ◦k
holds. To do this we use the identity (♭) of (Nat) twice, but in different instan-
tiations.
Thus with
B
idB - B
FB
F(k)- FA
FB
idF B
- FB
and then
B
k
- A
FA
idF A- FA
FA
idF A
- FA
we have
G(F(k)) ◦(idF B)♭= (F(k) ◦idF B)♭= (idF A ◦F(k))♭= (idF A)♭◦k
as required. The central step is a trivial property of identity arrows.
Once we know the unit or counit of an adjunction, we can retrieve the trans-
position assignments.

172
Adjunctions
5.4.3 Lemma
Given an adjunction, as in Deﬁnition 5.1.1, we have
f ♯= ϵS ◦F(f)
g♭= G(g) ◦ηA
for all arrows f and g as in (Nat).
Proof
We verify the left hand equality. Given an arrow
A
f
- GS
we apply (♯↓) with the following component arrows.
(k)
A
f
- GS
(f)
GS
idGS
- GS
Thus
f ♯= (idGS ◦f)♯= (idGS)♯◦F(f) = ϵS ◦F(f)
as required.
By remembering Deﬁnition 5.4.1 and setting
f = ηA
g = ϵS
we obtain an important particular case of this result.
5.4.4 Corollary
Given an adjunction, as in Deﬁnition 5.1.1, we have
ϵF A ◦F(ηA) = idF A
G(ϵS) ◦ηGS = idGS
for each Src-object A and Trg-object S.
These are important identities, because in appropriate circumstances they
determine the adjunction.
5.4.5 Theorem
Let
Src
F -

G
Trg
be a pair of functors, and let
IdSrc
η - G ◦F
F ◦G
ϵ - IdTrg
be natural transformations satisfying the identities of Corollary 5.4.4. Then η
and ϵ are the unit and counit of a unique adjunction F ⊣G.

5.4. The unit and the counit
173
Proof
By Lemma 5.4.3, if this data does arise from an adjunction then
f ♯= ϵS ◦F(f)
g♭= G(g) ◦ηA
for all arrows
A
f
- GS
FA
g
- S
of Src and Trg, respectively. Thus it sufﬁces to show that these two assign-
ments (·)♯, (·)♭form an inverse pair of bijections which satisfy (Nat).
The given naturality of η ensures that
A
ηA- (G ◦F)A
GS
f
?
ηGS
- (G ◦F ◦G)S
G(F(f))
?
commutes. With this and one of the given conditions we have
(f ♯)♭= (ϵS ◦F(f))♭
by
the deﬁnition of (·)♯
= G(ϵS ◦F(f)) ◦ηA
by
the deﬁnition of (·)♭
= G(ϵS) ◦G(F(f)) ◦ηA
by
the functorality of G
= G(ϵS) ◦ηGS ◦f
by
the above naturality
= idGS ◦f
by
the given right hand identity
= f
by
the neutral property of idGS
to give one half of the bijection property. The other half (g♭)♯= g is proved in
the same way.
The required naturality can be veriﬁed in several ways. Let’s go for (♯).
Consider arrows k, l, f as in (Nat). The naturality of ϵ ensures
(F ◦G)S
ϵS- S
(F ◦G)T
F(G(l))
?
ϵT
- T
l
?
commutes. Using this we have
l ◦f ♯◦F(k) = l ◦ϵS ◦F(f) ◦F(k)
by the deﬁnition of (·)♯
= l ◦ϵS ◦F(f ◦k)
by the functorality of F
= ϵT ◦F(G(l)) ◦F(f ◦k) by the naturality from above
= ϵT ◦F(G(l) ◦f ◦k)
by the functorality of F
= (G(l) ◦f ◦k)♯
by the deﬁnition of (·)♯
to give (♯). The identity (♭) can be veriﬁed in the same way.

174
Adjunctions
For any particular adjunction only some of the data
(F, G, (·)♯, (·)♭, η, ϵ)
is needed. However, given an adjunction you should get into the habit of work-
ing out what each component is.
Exercises
5.4.1
Show that the counit of an adjunction is natural.
5.4.2
Show how to retrieve the transposition (·)♭from the unit η.
5.4.3
Do the other half of the proof of Theorem 5.4.5.
5.4.4
Consider the two algebraic constructions of Block 5.2.1.
Show that for each set X and algebra A there are assignments
X
ηX- (U ◦Σ)X
(Σ ◦U)A
δA- A
(U ◦Π)X
ϵX- X
A
ζA- (Π ◦U)A
where δA and ζA are morphisms.
Show that each of the families η, ϵ, δ, ζ is a natural transformation.
5.4.5
For the two algebraic constructions of Block 5.2.1, verify directly the
identities of Lemma 5.4.3 and Corollary 5.4.4. In each case draw the composite
arrow that is dealt with.
5.4.6
For the set-theoretic and topological constructions of Blocks 5.2.2 and
5.2.3, verify directly the identities of Lemma 5.4.3 and Corollary 5.4.4. In each
case draw the composite arrow that is dealt with.
5.5 Free and cofree constructions
Adjunctions can arise in several different guises and even disguises, and some
of these don’t look at all like the ofﬁcial notion. These differences are probably
the reason why the general notion wasn’t recognized earlier. In this section we
look at two such examples. You will recognize the notions from earlier. They
are the idea of the universal
free
cofree
solution across a functor which now need not be forgetful. (Note that ‘cofree’
is pronounced ‘co-free’.)

5.5. Free and cofree constructions
175
I am going to describe the two notions in parallel. I suggest that you read just
one side ﬁrst, and perhaps the free side is easier. Once you are almost happy
with that, go through the other side. You should note the symmetry between
the two sides. At the ﬁrst reading do not try to connect the ideas with that of
an adjunction, even though some of the notation is the same. We will sort that
out later.
For both notions we again have a pair
Src
Trg
of categories. But now we have just one functor
free
cofree
Src 
G
Trg
Src
F - Trg
depending on which side we are considering, as indicated. Often in particular
examples this is a forgetful functor, but it need not be.
The idea is that we want to convert each
Src-object A
Trg-object S
into an object of the other category. Furthermore, we want to do this in the
most economical fashion. Thus we pose two problems, the
free problem
cofree problem
respectively. (In fact, we don’t say what the problem is, we merely say what a
solution is.)
For the problem a solution is an arrow
A
f
- GS
FA
g
- S
comparing a
Src-object A
Trg-object S
with a transposed
Trg-object S
Src-object A
respectively. Note the direction of the comparison. It is from Src to Trg in
both problems. The difference between the two problems is the object that is
transported to the other side.

176
Adjunctions
We look for a universal solution to the problem which applies to each
Src-object A
Trg-object S
respectively. We might think of this as a uniform universal solution. Thus we
look for an object assignment
Src
Trg
Src
Trg
A
- FA
GS 
S
together with a selected arrow
A
ηA- (G ◦F)A
(F ◦G)S
ϵS- S
for each object. Observe that, as yet, part of the solution is just an object as-
signment, not a functor. (Eventually we show that it is a functor, but that is not
part of the required solution.)
So far these gadgets merely select a solution to the problem. We want a
universal solution, a solution through which each other solution must factor
uniquely.
5.5.1 Deﬁnition
The notions of a
free
cofree
solution are deﬁned in unison as in Table 5.3. You should read each column
separately, perhaps starting with the free (left hand) column.
This deﬁnition looks quite complicated. The way to remember it is
For each f there is an f ♯such
that the triangle commutes.
For each g there is a g♭such
that the triangle commutes.
and then let the parent object A or S vary.
In due course we will see that having a free or cofree solution is equivalent
to the given functor having an adjoint on the appropriate side. In fact, some-
times Deﬁnition 5.5.1 is taken as the ofﬁcial deﬁnition of an adjunction, and
that is certainly a useful way of remembering some of the facets of adjunc-
tions. However, there are certain generalizations of the notion of an adjunction
(where the sets of arrows are given some other structure). In those circum-
stances the free/cofree version doesn’t work so well.
In this section we do two things. We show ﬁrst how an adjunction gives a
free and a cofree solution. Then we show how every free and cofree solution
arises from an adjunction.

5.5. Free and cofree constructions
177
Table 5.3 Free and Cofree solutions
Free
Cofree
Let
Src 
G
Trg
be a functor and consider
A
- FA
an object assignment in the
other direction.
A Src-indexed family
A
ηA- (G ◦F)A
of Src-arrows forms a
G-free
solution if for each Src-arrow
A
f - GS
with S ∈Trg, there is a
unique Trg-arrow
FA
f ♯- S
such that
A
f
- GS
(G ◦F)A
G(f ♯)
-
ηA
-
commutes.
Let
Src
F - Trg
be a functor and consider
GS 
S
an object assignment in the
other direction.
A Trg-indexed family
(F ◦G)S
ϵS- S
of Trg-arrows form a
F-cofree
solution if for each Trg-arrow
FA
g - S
with A ∈Src, there is a
unique Src-arrow
A
g♭- GS
such that
FA
g
- S
(F ◦G)S
ϵS
-
F(g♭)
-
commutes.

178
Adjunctions
5.5.2 Theorem
Let
Src
F -
⊣

G
Trg
be an adjunction with associated gadgets in standard notation.
The object assignment F, the unit η, and the transposition (·)♯provide the
data for a G-free solution.
The object assignment G, the counit ϵ, and the transposition (·)♭provide the
data for an F-cofree solution.
Proof
We look at the free result.
Consider any arrow
A
f
- GS
of Src. We ﬁrst check that
A
f
- GS
(G ◦F)A
G(f ♯)
-
ηA
-
does commute (and then consider the required uniqueness). We use the selec-
tion of arrows
A
idA - A
FA
f ♯
- S
FA
idF A
- FA
and then apply (♭) of (Nat). Thus
G(f ♯) ◦ηA = G(f ♯) ◦(idF A)♭◦idA = (f ♯◦idF A ◦F(idA))♭= (f ♯)♭= f
as required.
For the uniqueness we consider any arrow
FA
g
- S
for which
f = G(g) ◦ηA
and show that, in fact, g = f ♯. We use the selection of arrows
A
idA - A
FA
g
- S
FA
idF A
- FA

5.5. Free and cofree constructions
179
and then apply (♭) of (Nat). Thus
f = G(g) ◦ηA
= G(g) ◦(idF A)♭
= G(g) ◦(idF A)♭◦idA
= (g ◦idF A ◦F(idA))♭= g♭
and hence
g = (g♭)♯= f ♯
by a use of (Bij).
This shows that each adjunction gives universal solutions of both parities.
The more important result is that every universal solution must arise from an
adjunction.
5.5.3 Theorem
Let
Src 
G
Trg
be a functor, and suppose
F
η
(·)♯
is the data that provides a G-free solution. Then the object assignment F ﬁlls
out to a functor for which
F ⊣G
with (·)♯as the transposition assignment and η as the unit.
Proof
The proof is quite long, but not very deep. There are many small parts
each of which is straightforward. The G-free solution says
For each arrow f (of a certain kind), there is a
unique arrow f ♯(to do a certain job).
and it is this uniqueness that is important. We use it some 8 or 9 times.
We must ﬁrst produce an arrow assignment to create the functor F. Consider
any arrow
B
k
- A
of Src, so that an arrow
FB
F(k)- FA
is required together with some appropriate properties.

180
Adjunctions
Let f be the composite
B
k
- A
ηA- (G ◦F)A
and consider the commuting square
B
k
- A
(□)
(G ◦F)B
ηB
?
G(f ♯)
- (G ◦F)A
ηA
?
provided by the G-free solution. Here we have
FB
f ♯
- FA
and we take this to be F(k). Thus, we set
F(k) = (η ◦k)♯
for each Src-arrow k, as above.
This gives an arrow assignment. We show that F is a functor. We check that
F passes across composition, and preserves identity arrows.
Consider a composite
C
l
- B
k
- A
with
m = k ◦l
in Src. We require
F(m) = F(k) ◦F(l)
in Trg. Remember what F(m) is. It is the unique arrow
FC
- FA
such that
C
m
- A
(G ◦F)C
ηC
?
G(F(m))
- G(◦F)A
ηA
?

5.5. Free and cofree constructions
181
commutes. But, by construction of F(k) and F(l), both of the squares
C
l
- B
k
- A
(G ◦F)C
ηC
?
G(F(l))
- (G ◦F)B
ηB
?
G(F(k))
- (G ◦F)A
ηA
?
commute, and hence
C
m
- A
(G ◦F)C
ηC
?
G(F(k) ◦F(l)) = G(F(k)) ◦G(F(l))
- G(◦F)A
ηA
?
commutes (for we know that G is a functor). The uniqueness now gives
F(k ◦l) = F(m) = F(k) ◦F(l)
which is what we want.
We must check that F preserves identity arrows, that is
F(idA) = idF A
for each object A of Src. But F(idA) is the unique arrow
FA
g - FA
such that
A
idA
- A
(G ◦F)A
ηA
?
G(g)
- (G ◦F)A
ηA
?
commutes. Since
G(idF A) = id(G◦F )A
we see that
g = idF A
does make this latest square commute, and hence
F(idA) = g = idF A
by yet another appeal to the uniqueness.

182
Adjunctions
This gives us a functor F, and the commuting square (□) shows that η is
natural. We now check that
F ⊣G
using the assignment (·)♯.
We look ﬁrst at (Bij). Fix A ∈Src and S ∈Trg. We certainly have an
assignment
Src[A, GS]
- Trg[FA, S]
f
- f ♯
between the indicated arrow sets.We show that this is a bijection (and then (·)♭
is its inverse). By deﬁnition of G-free, for each arrow
A
f
- GS
the arrow
FA
g = f ♯
- S
must ensure that
A
f
- GS
(▽)
(G ◦F)A
G(g)
-
ηA
-
commutes, and is the unique arrow to do this.
To show that (·)♯is injective, suppose
f ♯
1 = f ♯
2
for two arrows taken from Src[A, GS]. Then
f1 = G(f ♯
1) ◦ηA = G(f ♯
1) ◦ηA = f2
as required. To show that (·)♯is surjective, consider any arrow g taken from
Trg[FA, S]. Let
f = G(g) ◦ηA
so that (▽) commutes. But now, by the uniqueness we have
f ♯= g
to give the required result.

5.5. Free and cofree constructions
183
Next we verify (Nat). We already have (Bij) so it sufﬁces to check (♯). To
this end consider arrows
B
k
- A
S
l
- T
A
f
- GS
and let
h = (G(l) ◦f ◦k)♯
so that
h = l ◦f ♯◦F(k)
is our problem. By construction, h is the unique arrow
FB
h - T
such that
B
- A
f
- GS
G(l)- GT
(G ◦F)B
G(h)
-
ηB
-
commutes. Now consider the diagram
B
- A
f
- GS
G(l)- GT
(G ◦F)B
ηB
?
(G ◦F)(k)
- (G ◦F)A
G(f ♯)
-
ηA
-
and observe that the left hand square and central triangle do commute. Since
G is a functor, this gives a commuting triangle
B
- A
f
- GS
G(l)- GT
(G ◦F)B
G(l ◦f ♯◦F(k))
-
ηB
-
and hence once again the uniqueness is the answer to our problem.

184
Adjunctions
Don’t go away just yet, for we haven’t quite ﬁnished. Read the statement of
the result again. This says that under the given circumstances we have
F ⊣G
with (·)♯as the transposition assignment and with η as the unit. We still have
this last clause to verify.
We require
ηA = (idF A)♭
for each object A of Src. With S = FA, consider the arrow
A
ηA - GS
of Src. What is the job done by η♯. It is the unique arrow
FA
g
- S
such that
A
ηA
- GS
(G ◦F)A
G(g)
-
ηA
-
commutes. But clearly, since
G(idF A) = idGS
we see that
g = idF A
does this job, and hence
η♯
A = idF A
by a ﬁnal appeal to uniqueness. Since (·)♭is the inverse of (·)♯, we have
ηA = (η♯
A)♭= (idF A)♭
as required.
Now you can relax, but not too much. You have to do the cofree proof.

5.5. Free and cofree constructions
185
Exercises
5.5.1
Finish the proof of Theorem 5.5.2. That is, do the cofree part.
5.5.2
Do the cofree analogue of Theorem 5.5.3.
5.5.3
In this exercise the forgetful functor has been omitted. You should insert
it where necessary.
Consider the algebraic construction of Block 5.2.1. Using the object assign-
ment X
- ΣX given there, and the function
X
ηX - ΣX
given by Exercise 5.4.4, show that for each function
X
f
- A
from a set to an algebra, there is a unique morphism
ΣX
f ♯
- A
such that the following commutes in Set.
X
f - A
ΣX f ♯
-
ηX
-
This shows that ΣX is the free algebra generated by X, via ηX.
5.5.4
In this exercise the forgetful functor has been omitted. You should insert
it where necessary.
Consider the algebraic construction of Block 5.2.1. Using the object assign-
ment X
- ΠX given there, and the function
ΠX
ϵX - X
given by Exercise 5.4.4, show that for each function
A
g
- X
from an algebra to a set, there is a unique morphism
A
g♭- ΠX

186
Adjunctions
such that the following commutes in Set.
A
f - X
ΠX ϵX
-
g♭
-
This shows that ΠX is the cofree algebra co-generated by X, via ϵX.
5.5.5
Verify the free and cofree properties for the constructions of Blocks
5.2.2 and 5.2.3.
5.6 Contravariant adjunctions
We have looked at adjoint pairs of covariant functors. There is a similar notion
for contravariant functors. In some ways this is easier because the notions are
completely symmetric between the two component functors.
5.6.1 Deﬁnition
Let
Alg
S - Spc
Alg  A
Spc
be a pair of contravariant functors between a pair of categories These form a
contravariant adjunction if for each
Alg-object A
Spc-object S
there is a bijective correspondence
Alg[A, AS]
Spc[S, SA]
f
- f σ
φα 
φ
between the two arrow sets. Furthermore, this correspondence must be natural
for variation of A and S.
The notation here is chosen to be suggestive. The two categories
Alg
Spc
are often of an
algebraic
spatial
nature. Each of the two functors
A
S
is named after its target.

5.6. Contravariant adjunctions
187
As with a covariant adjunction, each identity arrow
AS
idAS- AS
SA
idSA- SA
can be transferred to the other side to produce arrows
A
h- (A ◦S)A
S
η - (S ◦A)S
the analogues of the unit. Often one or both of these form a representation of
the parent object in terms of a gadget of the other kind. At the heart of many
representation results there is a contravariant adjunction. Exercise 5.6.2 looks
at some of the details of this.
The required naturality is worth looking at. Consider a pair of arrows
B
l
- A
T
λ
- S
from the two categories. These induce a square
f
Alg[A, AS] 
- Spc[S, SA]
φ
f •?
Alg[B, AS]
?

- Spc[T, SB]
?
ψ•?
between the arrow sets, which must commute. Here, for arrows f and φ as
indicated, we have
f • = A(λ) ◦f ◦l
φ• = S(l) ◦φ ◦λ
and we require
f •α = f σ•
φα• = φ•σ
to hold.
Exercises
5.6.1
In this exercise we ﬁrst set up two contravariant functors
Pos
Υ - Top
Pos  O
Top
between the category of posets and monotone functions and the category of
topological spaces and continuous maps. We then show that these form a con-
travariant adjunction.
(a) The functor O views the topology OS of a space S as a poset. Where
have you seen this functor before?

188
Adjunctions
(b) For each poset A let ΥA be the family of upper sections of A. For each
ﬁnite subset a of A let ⟨a⟩be the subset of ΥA given by
p ∈⟨a⟩⇐⇒a ⊆p
for p ∈ΥA. Show that these subsets form a base for a topology on ΥA.
(c) Show that for each monotone function
A
f
- B
between posets, the inverse image map
ΥB φ = f ←
- ΥA
is continuous (relative to the carried topologies), and hence Υ is a contravariant
functor.
(d) Show that the two functors form a contravariant adjunction.
(e) Describe the two units and show that each is an arrow of the appropriate
category.
(f) Can you see a neater way of setting up this adjunction?
5.6.2
In this exercise we look at the idea of a schizophrenically induced con-
travariant adjunction. Not all the details are dealt with, so we take some on
trust.
Suppose we have two Set-based categories.
Alg
Spc
Thus each object is a furnished set and each arrow is a function of a certain
kind. In many examples one has an algebraic nature and the other has a spatial
nature, hence the notation used here. Suppose we have a gadget ⋆which lives
in both categories. That is, we have a set that can be furnished in two ways to
produce an Alg-object or a Spc-object. This is the schizophrenic object.
For each
A ∈Alg
S ∈Spc
we have arrow sets
Alg[A, ⋆]
Spc[S, ⋆]
in other words we have contravariant hom-functors
Alg
- Set
Spc
- Set

5.6. Contravariant adjunctions
189
where the behaviour on arrows is via composition. The nature of ⋆enables us
to enrich
SA = Alg[A, ⋆]
AS = Spc[S, ⋆]
so that they are objects of
Spc
Alg
respectively. This step is not routine; it is concerned with the non-categorical
aspects of the situation under analysis. We don’t worry about the details here.
When the construction works these enrichments are compatible with composi-
tion, to give a pair of contravariant functors
Alg
S - Spc
Spc
A - Alg
between the categories. The functorial behaviour is simply that of a hom-
functor. The enrichments are carried along almost without effort.
This exercise shows these functors form a contravariant adjunction.
(a) Show that for each pair of objects A ∈Alg and S ∈Spc there is a
bijective correspondence
Alg[A, AS]
Spc[S, SA]
f <
> φ
between the two arrow sets. (To do this ﬁrst curry the function types and then
chip the inputs, but don’t make a meal of it.)
(b) Show that this correspondence is natural for variation of A and S. You
need only worry about the Set aspects.
(c) Write down the two units
A
hA- (A ◦S)A
S
ηS- (S ◦A)S
for arbitrary A ∈Alg and S ∈Spc.

6
Posets and monoid sets
In this last chapter we look at some examples of adjunctions. These are divided
into two groups. In Sections 6.1 to 6.6 we look at two ways that a poset can
be completed. In Sections 6.7 to 6.11 we look at two ways that a set can be
converted into an R-set for a given monoid R. For both groups most of the
details are left as exercises.
Finally, in Section 6.12 several small projects are suggested. Each is to mod-
ify one of the various adjunctions discussed earlier. All the answers are known,
but some of them are not as well-known as they should be.
6.1 Posets and complete posets
Let Pos be the category of posets and monotone maps. We have used this on
several occasions to illustrate various notions. We are concerned here also with
the class of complete posets, those which have all suprema and all inﬁma. At
ﬁrst sight these appear to form a subcategory of Pos, but a closer look shows
they are the objects of two categories. We need to take some care with the
comparison arrows between complete posets. Each of these two subcategories
is reﬂective in Pos. We look at the details of these two reﬂections.
Exercises
6.1.1
Let
S
f
- T
be a monotone map between two complete posets. Find a necessary and suf-
ﬁcient condition that f has a right adjoint. What about the existence of a left
adjoint?

6.2. Two categories of complete posets
191
6.2 Two categories of complete posets
Let’s collect together the various standard notions that we need.
6.2.1 Deﬁnition
Le S be an arbitrary poset, and let X be an arbitrary subset
of S. A
upper
lower
bound for X in S is an element a ∈S such that
x ≤a
a ≤x
for each x ∈X.
The
supremum W X
inﬁmum V X
of X in S is an upper bound a such that
a ≤b
b ≤a
for each other
upper
lower
bound of X. In other words, it is the
least upper
greatest lower
bound of X in S.
Of course, any given X ⊆S need not have an upper bound in S. Even if
it does, it need not have a supremum in S. Similarly, it need not have a lower
bound, and even if it does, it need not have an inﬁmum. Thus the existence of
such elements imposes a restriction on the poset S.
6.2.2 Deﬁnition
A poset S is
W -complete
V -complete
if
W X
V X
exists for each subset X of S.
The following simple observation is sometimes a surprise.
6.2.3 Lemma
A poset S is W-complete if and only if it is V-complete.

192
Posets and monoid sets
The two properties of Deﬁnition 6.2.2 are equivalent. So why don’t we sim-
ply refer to a complete poset rather than try to distinguish between two kinds?
That is the common practice, and we will follow that here. However, when we
try to make a category out of complete posets we ﬁnd there are at least two
possibilities. For those categories we need the terminology of Deﬁnition 6.2.2.
6.2.4 Deﬁnition
Let S, T be a pair of complete posets. A
W -morphism
V -morphism
between the two is a monotone map
S
f
- T
such that
f(W X) = W f[X]
f(V X) = V f[X]
for each X ⊆S.
Here f[·] indicates the direct image function across f. Thus
f(W X) = W{f(x) | x ∈X}
f(V X) = V{f(x) | x ∈X}
are the two extra restrictions on the monotone function f. However, you should
note that a W-morphism need not be a V-morphism, and conversely.
Almost trivially, these respective morphisms are closed under composition,
so the following makes sense.
6.2.5 Deﬁnition
Complete posets are the objects of the two categories
Sup
Inf
and the arrows are the
W -morphisms
V -morphisms
respectively.
Trivially, we have a pair of forgetful functors
Pos 
Sup
Pos 
Inf
and we aim to produce a left adjoint for each of these. Thus we require two
kinds of completion processes for posets.

6.2. Two categories of complete posets
193
Exercises
6.2.1
When does
W ∅
W S
V ∅
V S
exist in a poset S, and in each case what is the element?
6.2.2
Find examples of a poset S and a subset X where X has
an upper
a lower
bound but
W X
V X
does not exist. Can you ﬁnd such examples in a ﬁnite poset?
6.2.3
Prove Lemma 6.2.3.
6.2.4
Find an example of a W-morphism that is not a V-morphism.
Find an example of a monotone map between complete posets that is not a
W-morphism.
6.3 Sections of a poset
To complete a poset we use certain of its subsets.
6.3.1 Deﬁnition
Let S be an arbitrary poset. A subset X ⊆S is
a lower section
an upper section
of S if,
x ∈X
y ≤x

=⇒y ∈X
x ∈X
x ≤y

=⇒y ∈X
for all x, y ∈S.
Observe that
X lower =⇒X′ upper
X upper =⇒X′ lower
where ( · )′ produces the complement in S. Thus there is a bijective correspon-
dence between the lower sections and the upper sections of S.

194
Posets and monoid sets
6.3.2 Deﬁnition
Let S be an arbitrary poset. For each X ⊆S we let
↓X
↑X
be the
lower section
upper section
generated by X. Thus
y ∈↓X ⇐⇒(∃x ∈X)[y ≤x]
y ∈↑X ⇐⇒(∃x ∈X)[x ≤y]
for each y ∈S.
We also let
↓a = ↓{a}
↑a = ↑{a}
be the principal
lower
upper
section generated by the element a ∈S. Thus
y ∈↓a ⇐⇒y ≤a
y ∈↑a ⇐⇒a ≤y
for each y ∈S.
The family of all lower sections of S is a poset under inclusion. We use this
poset as the object assignment of at least two functors.
6.3.3 Deﬁnition
For each poset S we let LS be the poset of all lower sections
of S under inclusion.
It is easy to show that LS is closed under arbitrary unions and intersection,
and so LS is a complete poset. We use this to form two completions of S.
6.3.4 Deﬁnition
For each poset S and element a ∈S we set
η∃
S(a) = ↓a
η∀
S(a) = (↑a)′
to obtain the assignments
S
η∃
S - LS
S
η∀
S - LS
respectively.
It is easy to show that each of η∃
S and η∀
S is monotone, although the second
one does require just a little bit more thought.

6.4. Two completions
195
Exercises
6.3.1
Show the following for an arbitrary poset.
The union of a family of lower sections is a lower section.
Each lower section is the union of a family of principal lower sections.
The intersection of a family of lower sections is a lower section.
6.3.2
Show that each of η∃
S and η∀
S is monotone.
What about the assignment a
- ↑a?
6.4 The two completions
For each poset S the associated poset LS of lower sections is closed under
arbitrary unions and intersection, and so is a complete poset. Also S is con-
nected to LS by two different monotone maps η∃and η∀. We investigate the
properties of these maps, and in due course we show they are reﬂecting maps.
6.4.1 Lemma
Let S be an arbitrary poset. We have
↓X = S η∃[X]
(↑X)′ = T η∀[X]
for each subset X ⊆S.
This ensures that η∃, η∀are ‘sufﬁciently epic’ in the following sense.
6.4.2 Lemma
For each poset S and each parallel pair
LS
g
-
h
- T
of
W -morphisms
V -morphisms
to a complete poset T, we have
g ◦η∃= h ◦η∃=⇒g = h
g ◦η∀= h ◦η∀=⇒g = h
respectively.
It is now easy to obtain the two completions. Notice how the following gives
two versions of ‘freely generated by’ a poset.

196
Posets and monoid sets
6.4.3 Theorem
For each poset S and monotone map
S
f
- T
to a complete poset T, there is a unique
W -morphism
V -morphism
LS
f ♯
- T
such that
S
- T
LS
f ♯
-
η
-
commutes where
η = η∃
η = η∀
for the respective cases.
Proof
By Lemma 6.4.2 there is at most one such morphism f ♯. Thus it suf-
ﬁces to exhibit one such morphism. For each X ∈LS let
f ♯(X) = W f[X]
f ♯(X) = V f[X′]
for the respective cases. Almost trivially this function makes the triangle com-
mute. We must show that f ♯is a morphism of the appropriate kind. Thus we
required
f ♯  S X

= W f ♯[X]
f ♯  T X

= V f ♯[X]
for each collection X of lower sections of S. These follow by straightforward
calculations but a little more care is required for the ∀-case.
Exercises
6.4.1
Prove Lemma 6.4.1.
6.4.2
Prove Lemma 6.4.2.
6.4.3
Complete the proof of Theorem 6.4.3.

6.5. Three endofunctors on Pos
197
6.5 Three endo-functors on Pos
In the usual way Theorem 6.4.3 induces a pair of functors
Pos
- Sup
Pos
- Inf
each of which is the left adjoint to the corresponding forgetful functor. In this
section we look at the induced composite covariant endo-functors on Pos
Pos
- Sup
- Pos
Pos
- Inf
- Pos
together with an associated contravariant endo-functor. Curiously each one has
the same object assignment, namely
S
- LS
the one that sends each poset to its poset of lower sections. This means we have
to devise different names to distinguish between the three.
The contravariant functor is the easiest to describe, as follows.
6.5.1 Deﬁnition
For each poset S let
IS = LS
be the set of lower sections of S. For each monotone map
S
f
- T
let
LS I(f)
LT
f ←(Y ) 
Y
be the induced inverse image function.
It is a simple exercise to show that I(f) is monotone. (In fact, this is a par-
ticular case of the observation that each continuous map between topological
spaces induces a monotone map between the topologies.) It is just as easy to
show that I is an endo-functor on Pos.
Next we deal with the two covariant endo-functors on Pos.
6.5.2 Deﬁnition
For each poset S let
∃S = LS
∀S = LS
be the set of lower sections of S. For each monotone map
S
f
- T

198
Posets and monoid sets
let
LS
∃(f)- LT
LS
∀(f) - LT
X
- ↓f[X]
X
-  ↑f[X′]
′
be the modiﬁed direct image function and the twisted direct image function,
respectively.
There are one or two things to be checked here. We ﬁrst observe that
b ∈∃(f)(X) ⇐⇒(∃x ∈S)[b ≤f(x) & x ∈X]
b ∈∀(f)(X) ⇐⇒(∀x ∈S)[f(x) ≤b ⇒x ∈X]
for each X ∈LS and b ∈T. Using these we can check that each of ∃and ∀is
an endo-functor on Pos. We can also check that these are the functors induced
by the completion functors
Pos
- Sup
Pos
- Inf
respectively.
What is the point of this? There is more here than we ﬁrst see.
6.5.3 Lemma
For each monotone map
S
f
- T
between posets, the three induced monotone maps
LS
∃(f) -
 I(f)
∀(f)
-
LT
form a double poset adjunction.
Proof
We require
∃(f)(X) ⊆Y ⇐⇒X ⊆I(f)(Y )
I(f)(Y ) ⊆X ⇐⇒Y ⊆∀(f)(X)
for all X ∈LS and Y ∈LT.
Exercises
6.5.1
Verify the explicit quantiﬁer descriptions of ∃(f) and ∀(f).
Use these to show that each of ∃(f) and ∀(f) is monotone.
Use these descriptions to show that ∃and ∀are endo-functors on Pos.
6.5.2
Complete the proof of Lemma 6.5.3.

6.6. Long strings of adjunctions
199
6.6 Long strings of adjunctions
Lemma 6.5.3 shows that each monotone map
S
f
- T
between a pair of posets induces two adjunctions
LS
∃(f) ⊣I(f) ⊣∀(f) - LT
between the posets of lower sections. Thus we produce a monotone map I(f)
which has both a left and a right adjoint. Furthermore, a simple example shows
that these two adjoints need not be the same. Thus there are strings of adjunc-
tions of length 2. This suggests a question. Can there be longer strings of ad-
junctions? In this section we see that there are, and there is one very important
example of such strings.
Suppose we start with a poset adjunction.
S
f
-

g
T
We may apply the construction of Lemma 6.5.3 to each of f, g in turn, and so
produce two strings of adjunction of length 2.
LS
∃(f) -
 I(f)
∀(f)
-
LT
LT
∃(g) -
 I(g)
∀(g)
-
LS
What is the connection between these two strings?
6.6.1 Lemma
For each poset adjunction f ⊣g, as above, we have
I(f) = ∃(g)
∀(f) = I(g)
and the two induced 2-strings can be merged.
Each 1-string adjunction f ⊣g produces a 3-string adjunction
LS
∃(f)
-

I(f) = ∃(g)
∀(f) = I(g)
-

∀(g)
LT
between the two posets of lower sections. We may repeat this as in Table 6.1.

200
Posets and monoid sets
Table 6.1 A poset development
S
δ - LS
∃-
 I
∀-
L2S
∃2 -
 ∃I
I2 -
 I∀
∀2 -
L3S
∃3 -
∃2I
∃I2-
 I3
I2∀-
I∀2
∀3 -
L4S
∃4 -
...
 I4
...
∀4 -
Suppose we start with a 2-string f ⊣g ⊣h of adjunctions. This induces a
5-string of adjunctions
LS
∃(f) ⊣I(f)=∃(g) ⊣∀(f)=I(g)=∃(h) ⊣∀(g)=I(h) ⊣∀(h) - LT
between the two posets of lower sections. This indicates that we can generate
arbitrarily long strings of adjunctions between posets.
We start from any monotone map between posets
S
- T
which we need not name. We hit this once with the construction of Lemma
6.6.1 to produce a 2-string between the ﬁrst level completions.
LS
∃⊣I ⊣∀
LT
Here we haven’t even written in the arrows. We now hit this with the construc-
tion to produce three 2-two strings between the second level completions, the
posets of lower section of the poset of lower sections.
∃2 ⊣I∃⊣∀∃
L2S
∃I ⊣I2 ⊣∀I
L2T
∃∀⊣I∀⊣∀2
We know these merge to produce a 4-string of adjunctions.
L2S
∃2 ⊣∃I ⊣I2 ⊣I∀⊣∀2
L2T
Here we have made a choice in the way we name these arrows. We now hit this
to produce a 6-string of adjunctions.
L2S
∃3 ⊣∃2I ⊣∃I2 ⊣I3 ⊣I2∀⊣I∀2 ⊣∀3
L2T
We hit this again to produce an 8-string, then a 10-string, and so on.

6.6. Long strings of adjunctions
201
Table 6.2 The simplicial category
0
δ0
0
- 1
δ1
1
-
δ1
0
- 2
δ2
2
-
δ2
1
-
δ1
0
-
3
δ3
3
-
δ3
2
-
δ3
1
-
δ3
0
-
4
· · ·
1 
σ1
0
2

σ2
1

σ2
0
3

σ3
2

σ3
2

σ3
0
4
· · ·
Of course, we haven’t yet checked that there are no more equalities between
the arrows beyond those we have indicated. To do that let’s look at a particular
case.
Suppose we start from
S
δ
- LS
an arbitrary poset S and an arbitrary monotone map δ to its poset of lower
sections. By repeatedly hitting this we generate the development of Table 6.1.
Let’s consider a particular case of this. Let us take the empty poset for S. Then
each of
∅, L∅, L2∅, L2∅, L3∅, . . .
is linearly ordered with 0, 1, 2, 3, . . . members. We can think of them as the
natural numbers. There is only one possible map δ, the empty map. Thus we
generate the collection of monotone maps as in Table 6.2. This is the simplicial
category, an important gadget in algebraic geometry.
Exercises
6.6.1
Find an example of a monotone map f for which the two induced
monotone maps ∃(f), ∀(f) are not the same.
6.6.2
Prove Lemma 6.6.1.
6.6.3
Look up the standard construction of the simplicial category and check
that it is the same as that in Table 6.2.

202
Posets and monoid sets
6.7 Two adjunctions for R-sets
In the second part of this chapter we look at the category Set-R of R-sets and
two adjunctions between it and the category Set of sets. These adjunctions
convert each set into a free R-set and the cofree R-set, respectively. In this
section we set up the basics and then get down to business in the next sections.
We have seen the notion of a monoid before, but there is no harm in repeating
the deﬁnition.
6.7.1 Deﬁnition
A monoid is a structure
(R, ·, 1)
where R is a set furnished with an associative binary operation and a neutral
element for the operation.
As is the custom, we usually hide the furnishings and speak of ‘a monoid
R’. We don’t display the operation symbol in compounds, we write rs for r · s
for elements r, s ∈R. Using this convention we see that
(rs)t = r(st)
1r = r = r1
are the axioms for a monoid. Here, and below, we let r, s, t range over R.
Because of the associativity we often leave out brackets and write
rst
for the two left hand compounds.
You can think of a monoid as a ring with the addition missing. Much of
what we do here can be extended to rings, but sometimes that is quite a bit
more complicated.
We now ﬁx a monoid R.
6.7.2 Deﬁnition
A right R-set is a set A with a right R-action
A, R
- A
a, r
- ar
an operation that combines an element a ∈A with an element r ∈R to return
an element ar ∈A. This action is required to satisfy
(as)r = a(sr)
a1 = a
for each a ∈A and r, s ∈R.
Notice that we are using concatenation for at least two different operations.
If you ﬁnd this confusing then for a while insert a different symbol for each
different use of concatenation.

6.7. Two adjunctions for R-sets
203
There is also a notion of a left R-set, where the action operates on the other
side. We don’t need those so here ‘R-set’ means ‘right R-set’.
6.7.3 Deﬁnition
Given two R-sets A and B, an R-morphism
A
l
- B
is a function l, as indicated, such that
l(ar) = l(a)r
for each a ∈A and r ∈R.
This gives us the category
Set-R
of R-sets and R-morphisms. Because here there is no danger of confusion we
often say ‘morphism’ in place of ‘R-morphism’.
We compare the category Set-R with the category
Set
of sets and functions. Since each R-set A is a set furnished with some structure
indexed by R, there is a forgetful functor
Set U
Set-R
which sends each R-set to its carrying set, and each R-morphism to its carrying
function. In other words U forgets all the structure. In the following sections
we show that U has a left adjoint and a right adjoint
Set
Σ
-

U
Π
-
Set-R
and so obtain two adjunctions
Σ ⊣U ⊣Π
which, for convenience, we refer to as the
upper
lower
adjunction, respectively.
We could quite quickly demonstrate the existence of these adjunctions but
that is not the aim here. The purpose is to provide fairly simple illustrations of

204
Posets and monoid sets
all the various aspects of adjunctions. We look at all the bits of gadgetry to see
exactly what they do in these particular examples.
Many of the details are left as exercises.
Because the functor U is forgetful we often omit to name it. For instance,
for an R-set A we sometimes write ΣA or ΠA for (Σ ◦U)A or (Π ◦U)A,
respectively. If you ﬁnd this confusing then insert U in the places where you
think it should be.
Several kinds of algebras, a set furnished with some operations, are R-sets
for a particular monoid R. We have met one of these before, and Exercise
6.7.1 gives three more. You may ﬁnd it helpful to sort out the details for these
particular monoids as you read the following sections.
Exercises
6.7.1
Consider the following four kinds of algebras.
(a) An involution algebra is a structure
(A, (·)•)
a•• = a
as on the left where the identity on the right holds for all a ∈A.
(b) An idempotent algebra is a structure
(A, (·)•)
a•• = a•
as on the left where the identity on the right holds for all a ∈A.
(c) A 2-step involution algebra is a structure
(A, (·)•, •(·))
a•• = •a
•(a•) = (•a)•
••a = a
as on the left where the identities on the right hold for all a ∈A.
(d) A 2-step idempotent algebra is a structure
(A, (·)•, •(·))
a•• = •a
••a = a•
•(a•) = (•a)• = a
as on the left where the identities on the right hold for all a ∈A.
Show that each of these algebras is an R-set for a particular monoid R,
which you should describe in detail.
Produce another examples of this kind of algebra.

6.8. The upper left adjoint
205
6.8 The upper left adjoint
In this section we produce the functor Σ but, as yet, we don’t show it is left
adjoint to U. We also produce assignments
X
ηX- (U ◦Σ)X
(Σ ◦U)
ϵA- A
for each set X and each R-set A. In due course we see that these are the
unit and the counit of the upper adjunction Σ ⊣U. We don’t attempt a direct
analysis, we wander around gathering all the relevant properties.
6.8.1 Deﬁnition
For each set X let
ΣX = X × R
the set of ordered pairs (x, r) for x ∈X, r ∈R. Also let
ΣX, R
- ΣX
(x, r), s
- (x, rs)
for each x ∈X and r, s ∈R.
It is easy to check that ΣX with this action is an R-set. In due course we
will show that ΣX is the free R-set generated by X. On general grounds it
then follows that Σ is the object assignment of a functor from Set to Set-R.
Here we don’t rely on that. We produce the arrow assignment directly.
6.8.2 Deﬁnition
For each function
Y
g
- X
between sets let
ΣY
Σ(g)- ΣX
be given by
Σ(g)(y, r) = (g(y), r)
for each y ∈Y and r ∈R.
We need to check that Σ(g) is an R-morphism, and the two assignment
combine to form a functor. These details are left as exercises.
We now produce assignments
X
ηX- (U ◦Σ)X
(Σ ◦U)
ϵA- A
for each set X and each R-set A. These turn out to be the unit and the counit
of the upper adjunction Σ ⊣U.

206
Posets and monoid sets
We begin by looking at η.
6.8.3 Deﬁnition
For each set X let ηX as on the left
X
ηX- (U ◦Σ)X
ηX(x) = (x, 1)
be the function given by the assignment on the right for each x ∈X.
This is just a function, it need not have any morphism properties.
Consider any (x, r) ∈ΣX. Remembering the action on Σ we have
(x, r) = (x, 1r) = (x, 1)r = ηX(x)r
to show how ηX picks out a generating set of ΣX.
6.8.4 Lemma
For each set X the assignment ηX is ‘sufﬁciently epic’. That
is,
f ◦ηX = g ◦ηX =⇒f = g
for each parallel pair
ΣX
f -
g
- A
of R-morphisms.
The following shows that ΣX is the free R-set generated by X via ηX.
6.8.5 Theorem
For each function
X
g
- A
from a set X to an R-set A, there is a unique R-morphism
ΣX
g♯
- A
such that
X
g - A
ΣX g♯
-
ηX
-
commutes in Set.
As is usual in this kind of situation, we have omitted the underlying functor
U. If you ﬁnd this confusing, then simply insert U at the appropriate places

6.8. The upper left adjoint
207
How can we prove Theorem 6.8.5? By Lemma 6.8.4 there is at most one
such morphism g♯, so it sufﬁces to exhibit one. Consider any element
(x, r) = ηX(x)r
of ΣX. Remembering that g♯must be an R-morphism we have
g♯(x, r) = g♯(ηX(x)r) = g♯(ηX(x))r =
 g♯◦ηX

(x)r = g(x)r
which shows us the only possible function that will work.
On general grounds Theorem 6.8.5 ensures that the object assignment Σ of
Deﬁnition 6.8.1 ﬁlls out to a functor
Set
Σ- Set-R
for which
IdSet
η•- (U ◦Σ)
is natural. We can check that this functor Σ is the one we ﬁrst thought of, and
show by direct calculation that η is natural. For this second part we need to
check that each function g induces a commuting square
Y
ηY - ΣY
X
g ?
ηX
- ΣX
Σ(g)
?
in Set. This is more or less trivial.
Let us now look at the counit. In some ways this is more interesting.
6.8.6 Deﬁnition
For each R-set A let ϵA, as on the left,
(Σ ◦U)A
ϵA- A
ϵA(a, r) = ar
be the function given as on the right for each a ∈A and r ∈R.
This construction starts with an R-set A. We forget its structure to produce
a set UA and then we furnish that as an R-set using Σ. Thus we obtain an
R-set of pairs (a, r) for a ∈A and r ∈R. This shows that the construction
of ϵA does make sense, as a function. However, we need to check that ϵA is an
R-morphism. In other words, we require
ϵA
 (a, r)s

=
 ϵA(a, r)

s
for all a ∈A and r, s ∈R. This follows by unravelling the deﬁnitions.

208
Posets and monoid sets
We need to check that ϵ• is natural.
(Σ ◦U)
ϵ•- IdSet-R
In other words, we need to check that for each R-morphism f the square
ΣA
ϵA - A
ΣB
Σ(f) ?
ϵB
- B
f?
commutes. A proof of this is not exactly strenuous.
Exercises
6.8.1
Show that Deﬁnition 6.8.1 does produce an R-set ΣX.
6.8.2
Show Deﬁnitions 6.8.1 and 6.8.2 give a functor from Set to Set-R.
6.8.3
Prove Lemma 6.8.4.
6.8.4
Prove Theorem 6.8.5.
6.8.5
Show that the arrow assignment of the functor Σ ensured by Theorem
6.8.5 is that given by Deﬁnition 6.8.2.
6.8.6
Prove directly that the unit η is natural.
6.8.7
Show that the construction of Deﬁnition 6.8.6 does produce an R-
morphism.
6.8.8
Prove directly that the counit ϵ is natural.
6.8.9
Show that for each R-morphism
ΣX
f - A
from a free R-set to an arbitrary R-set, there is a unique function
X
f♭- UA
such that
ΣX
f
- A
(Σ ◦U)A
ϵA
-
Σ(f♭)
-
commutes in Set-R.

6.9. The upper adjunction
209
6.9 The upper adjunction
We have a pair of functors
Set
Σ -

U
Set-R
and our aim is to show that these form an adjoint pair. We have produced
natural transformations
X
ηX- (U ◦Σ)X
(Σ ◦U)A
ϵA- A
which we hope will be the unit and counit of the adjunction. In fact, Theorem
6.8.5 or Exercise 6.8.9 is enough to ensure we do have such an adjunction. In
this section we show that we don’t need either of those results. We use Theorem
5.4.5. Thus we show
ϵΣX ◦Σ(ηX) = idΣX
U(ϵA) ◦ηUA = idUA
for each set X and R-set A. These are not difﬁcult to verify, but the left hand
identity does require a bit more care. Let’s have a look at that.
We need to understand the composite
ΣX
Σ(ηX)- (Σ ◦U ◦Σ)X
ϵΣX- ΣX
for an arbitrary set X. Now ΣX is a set of ordered pairs (x, r) for x ∈X and
r ∈R. This means that
(Σ ◦U ◦Σ)X
is a set of ordered pairs (l, r) where l is already an ordered pair. Starting with
(x, r) ∈ΣX we use Σ(ηX) to produce such a pair (l, r) in the central compo-
nent, and then hit this with ϵΣX to produce an ordered pair in ΣX. We need to
check that this is the starting ordered pair.
In the remainder of this section we look at the upper transitions to obtain
what is usually taken as the ‘ofﬁcial’ deﬁnition of an adjunction. We set up an
inverse pair of transformations
Set[X, UA]
(·)♮
-

(·)♭
Set-R[ΣX, A]
for each set X and R-set A, and show these are natural for variations of the
objects. We also check directly various other properties associated with such
transitions.

210
Posets and monoid sets
At the function level what might the two transitions be?
g
- g♯
(X →A)
(X × R →A)
f♭
f
The simplest suggestion seems to be
g♯(x, r) = g(x)r
f♭(x) = f(x, 1)
for each x ∈X and r ∈R. We are going to check directly that these are the
correct functions. But before we do that let’s use what we have already done
to give a quick proof of correctness. By Lemma 5.4.3 we know that we must
have
g♯= ϵA ◦Σ(g)
f♭= U(f) ◦ηX
for each function g and morphism f, as above. By unravelling these com-
pounds we see that the suggestions above are correct.
We now go through the details of the direct veriﬁcations.
Consider any function
g : X
- A
as above. Thus X is an arbitrary set but A is (the carrier of) an R-set. The
suggested construction certainly gives a function
g♯: ΣX
- A
but we require this to be an R-morphism, that is
g♯ (x, r)s

= g♯(x, r)s
for each x ∈X and r, s ∈R. This follows by a simple calculation.
Next consider any morphism
ΣX
f - A
as above. The construction does give a function
f♭: X
- A
as we want.
We require these two transitions to form an inverse pair, that is
g♯
♭= g
f♭
♯= f
for each function g and morphism f, as above. These follow by simple calcu-
lations, but the right hand one does have just a little more content.

6.9. The upper adjunction
211
Finally, we check the naturality of these two transition assignments. Of
course since each is the inverse of the other we need only check that one is
natural, but it is instructive to do both calculations.
We check the two conditions (♯) and (♭) of Tables 5.1 and 5.2 on pages 165
and 167. Those tables uses a slightly different notation, so let’s start again.
For (♯) consider the square
X
Set[X, UA]
(·)♯
- Set-R[ΣX, A]
A
Y
k
6
Set[Y, UB]
U(l) ◦−◦k
?
(·)♯
- Set-R[ΣY, B]
l ◦−◦Σ(k)
?
B
l
?
induced by a function k and a morphism l, as indicated. We must show that
this square commutes, that is
 U(l) ◦g ◦k
♯=
 l ◦g♯◦Σ(k)

for each function
X
g
- A
from the top left hand corner. To check this we evaluate both sides at an arbi-
trary member (y, r) of ΣY , and remember that l is a morphism.
For (♭) consider the square
X
Set[X, UA] 
(·)♭
Set-R[ΣX, A]
A
Y
k
6
Set[Y, UB]
U(l) ◦−◦k
?

(·)♭
Set-R[ΣY, B]
l ◦−◦Σ(k)
?
B
l
?
induced by a function k and a morphism l, as indicated. We must show that
this square commutes, that is
 l ◦f♭◦k

=
 l ◦f ◦Σ(k)

♭
for each morphism
ΣX
f - A
from the top right hand corner.To check this we evaluate both sides at an arbi-
trary member y of Y .

212
Posets and monoid sets
This completes the discussion of
Σ ⊣U
the upper adjunction.
Exercises
6.9.1
Verify the two identities involving η and ϵ that ensure we do have an
adjunction.
6.9.2
For the suggested transitions show that
g♯= ϵA ◦Σ(g)
f♭= U(f) ◦ηX
do hold for each function g and morphism f, as above.
6.9.3
Show that for each function g, as above, the suggested function g♯is a
morphism.
6.9.4
Show that (·)♯and (·)♭form an inverse pair of transitions.
6.9.5
Show that each of the transitions (·)♯and (·)♭is natural.
6.10 The lower right adjoint
We now turn to the lower adjunction.
Π ⊣U
Remember that the functors seem to go the wrong way, so the re-drawn picture
Set-R
U
-

Π
Set
might help us to avoid a bit of confusion. In this section we produce the functor
Π, but we don’t start to deal with the adjunction properties. We also produce
assignments
A
ηA- (Π ◦U)A
(U ◦Π)X
ϵX- X
for each R-set A and set X. Eventually we see that these are the unit and the
counit of the lower adjunction Π ⊣U. However, as with the upper adjunction
we ﬁrst wander around their properties getting to know them.
The construction Π must convert an arbitrary set X into an R-set ΠX. To
do that we ﬁrst need the carrier.

6.10. The lower right adjoint
213
6.10.1 Deﬁnition
For each set X let
ΠX = Set[UR, X]
the set of all functions
h : R
- X
from the set R to X.
We need to furnish ΠX as an R-set. At ﬁrst the construction and notation
we use might look odd, but you will soon see why we use it.
6.10.2 Deﬁnition
For each set X, each function
h : R
- X
and each r ∈R, let
hr : R
- X
be the function given by
hr(s) = h(rs)
for each s ∈R.
This certainly produces an assignment
ΠX, R
- ΠX
h, r
- hr
and a couple of simple calculations shows that it is an R-action. This is the
object assignment of the functor. Here is the arrow assignment.
6.10.3 Deﬁnition
For each function
X
g
- Y
let
ΠX
Π(g)- ΠY
be the function given by composition, that is
Π(g)(h) = g ◦h
for each h ∈ΠX.

214
Posets and monoid sets
Of course, we need Π(g) to be an R-morphism, that is
Π(g)
 hr
=
 Π(g)(h)
r
for each h ∈ΠX and r ∈R. This follows by evaluating both sides at an
arbitrary s ∈R.
We need to know that the two assignments Π combine to form a functor. In
fact, at this stage there is nothing we have to prove. Observe that at the Set
level Π is just the hom-functor
Set[UR, −]
induced by the set R. We have checked that both the object assignment and
the arrow assignment do the right thing, so we have what we want. This is an
example of an enriched hom-functor.
We now produce assignments
A
ηA- (Π ◦U)A
(U ◦Π)X
ϵX- X
for each R-set A and set X. Eventually we see that these are the unit and the
counit of the lower adjunction Π ⊣U.
What might these two assignments be? Once we think about it we see that
there is not much choice. Consider a ∈A. We require a function
ηA(a) : R
- A
which can be evaluated at an arbitrary r ∈R. For ϵX consider any typical
h ∈(U ◦Π)X, an arbitrary function
h : R
- X
from which we must obtain an element of X. The choices are obvious.
6.10.4 Deﬁnition
For each R-set A and set X let
A
ηA- (Π ◦U)A
(U ◦Π)X
ϵX- X
be the functions given by
ηA(a)(r) = ar
ϵX(h) = h(1)
for each a ∈A, r ∈R, and h ∈ΠX.
We want ηA to be an R-morphism. Remembering how (Π◦U)A is structured
this requirement is
ηA(ar) = ηA(a)r
for all a ∈A and r ∈R. This can be checked by evaluating both sides at an
arbitrary member of R.

6.10. The lower right adjoint
215
There are some properties that η and ϵ must have. We look at η ﬁrst.
We require the family η• of morphisms to be natural. Thus the square
A
ηA - ΠA
B
f
?
ηB
- ΠB
Π(f)
?
must commute for each morphism f. This requirement is
ηB ◦f = Π(f) ◦ηA
in equational form. To check this we evaluate both sides at an arbitrary a ∈A
to produce a pair of functions
R
- B
which must be equal. So we evaluate each of these at an arbitrary r ∈R.
In the usual way the existence of a unit with an appropriate universal prop-
erty ensures we do have an adjunction.
6.10.5 Theorem
For each R-set A, set X and morphism
A
f - ΠX
there is a unique function
UA
f ♯
- X
such that
A
f
- ΠX
(Π ◦U)A
Π(f ♯)
-
ηA
-
commutes in Set-R.
Proof
Let’s ﬁrst show that there is at most one such function f ♯.
Suppose there is some such f ♯. Then
Π(f ♯) ◦ηA = f
and hence
Π(f ♯)(ηA(a)) = f(a)

216
Posets and monoid sets
for each a ∈A. This gives
f ♯◦ηA(a) = f(a)
by the construction of Π. Each of the two sides of this equality is a function
R
- A, and hence we may evaluate at 1. Remembering the construction of
η this gives
f ♯(a) = f ♯(ηA(a)(1)) = f(a)(1)
to determine f ♯uniquely.
We use this as the deﬁnition of the function f ♯, so all that remains is to show
that the induced triangle does commute.
We now check the various properties of ϵX. Since U is the forgetful functor
we see that
ΠX
ϵX - X
is just a function, so we do not require any morphisms properties. We do re-
quire that the whole family ϵ• is natural. The induced square
ΠX
ϵX - X
ΠY
Π(g)
?
ϵY
- Y
g
?
must commute, that is
ϵY ◦Π(g) = g ◦ϵX
in equational form. To check this we evaluate both sides at an arbitrary member
h : R
- X of the top left hand corner of the square.
These functions ϵ• are part of a cofree construction. Here are some of the
details of that.
6.10.6 Lemma
For each set X the assignment ϵX is ‘sufﬁciently monic’ in
the sense that
ϵX ◦k = ϵX ◦l =⇒k = l
for each parallel pair
A
k -
l
- ΠX
of R-morphisms.

6.10. The lower right adjoint
217
Proof
Assuming
ϵX ◦k = ϵX ◦l
we have
ϵX
 k(a)

= ϵX
 l(a)

that is
k(a)(1) = l(a)(1)
for each a ∈A. Each of k, l is a 2-step function
A
- R
- X
so we require
k(a)(r) = l(a)(r)
for each a ∈A and r ∈R. By remembering how ΠX is structured we see how
the above identity leads to this more general identity.
A few more calculations gives the following factorization result.
6.10.7 Theorem
For each function
A
g
- X
from an R-set A to a set X, there is a unique morphism
A
g♭- ΠX
such that
A
g
- X
ΠX
ϵX
-
g♭
-
commutes in Set.
Proof
By Lemma 6.10.6 there is at most one such morphism g♭.
Whatever it is ♭is a 2-step function
A
- R
- X
which must be evaluated ﬁrst at an arbitrary a ∈A and then at an arbitrary
r ∈R to return a value in X. There is an obvious choice for such a function.
A few calculations shows that this choice does work.
As set up in this section the families η• and ϵ• don’t seem to be doing any-
thing special. Of course, later we will see that they are the unit and counit of
an adjunction.

218
Posets and monoid sets
Exercises
6.10.1
Show that for each set X the construction of ΠX does produce an
R-set.
6.10.2
Show that the construction of Deﬁnition 6.10.3 really does produce an
R-morphism.
6.10.3
Show that the construction of Deﬁnition 6.10.4 does produce a mor-
phism ηA.
6.10.4
Show that the family η• of morphisms is natural.
6.10.5
Complete the proof of Theorem 6.10.5.
6.10.6
Show that the family ϵ• of morphisms is natural.
6.10.7
Complete the proof of Lemma 6.10.6.
6.10.8
Complete the proof of Theorem 6.10.7.
6.11 The lower adjunction
We have a pair of functors
Set-R
U -

Π
Set
and our aim is to show that these form an adjoint pair. We have produced
natural transformations
A
ηa- (Π ◦U)A
(U ◦Π)X
ϵx- X
which we will show are the unit and counit of the adjunction. In fact, Theorems
6.10.5 and 6.10.7 are enough to do this. However, in this section we don’t take
that route. We use Theorem 5.4.5. Thus we show
ϵΠA ◦U(ηA) = idUA
Π(ϵx) ◦ηΠX = idΠX
for each R-set A and set X.
The left hand equality follows by evaluating each side at an arbitrary a ∈
A. The calculations are straightforward. The right hand equality follows by a
similar method but does require a little more care.

6.11. The lower adjunction
219
We have a composite
ΠX
ηΠX- (Π ◦U ◦Π)X
Π(ϵX)- ΠX
for an arbitrary set X. We evaluate this at an arbitrary member
h : R
- X
of ΠX to produce another member of ΠX. We evaluate this at an arbitrary
member r ∈R and hope to show that the result is h(r).
In the remainder of this section we look at the ‘ofﬁcial’ deﬁnition of an
adjunction. We require an inverse pair of transitions
Set-R[A, ΠX]
(·)♮
-

(·)♭
Set[UA, X]
for each R-set A and set X, and these must be natural for variations of the
objects. We also check directly various other properties associated with such
transitions. In fact, we already know what these assignments must be, since
they must ﬁt into Theorems 6.10.5 and 6.10.7. Thus we will show that the
following two constructions do the job.
6.11.1 Deﬁnition
For each R-set A and set X, and each
morphism
function
A
f - ΠX
A
g
- X
we set
f ♯(a) = f(a)(1)
g♭(a)(r) = g(ar)
for each a ∈A and r ∈R.
At the Set-level we do have
f ♯: A
- X
g♭: A
- R
- X
and our job now is to check all the other requirements.
By Lemma 5.4.3 if Deﬁnition 6.11.1 is correct, then we must have
f ♯= ϵx ◦U(f)
g♭= Π(g) ◦ηA
for each morphism f and function g, as above. By unravelling these com-
pounds we see that the suggestions above are correct.
We now go through the various other details of the direct veriﬁcations.
At some point we have to show that these two transition form an inverse
pair, that is
f ♯
♭= f
g♭
♯= g

220
Posets and monoid sets
for each morphism f and function g. These are not difﬁcult to verify, but one
of them does require a little bit of thought.
The next thing we should check is that (·)♭does return a morphism. To do
this we remember how a cofree R-set ΠX is structured.
Finally, we check the naturality of these two transition assignments. As
usual, since each is the inverse of the other we need only check that one is
natural, but it is instructive to do both calculations. We check the conditions
(♯) and (♭) of Tables 5.1 and 5.2 on pages 165 and 167.
For (♯) consider the square
A
Set-R[A, ΠX]
(·)♯
- Set[UA, X]
X
B
k
6
Set-R[B, ΠY ]
Π(l) ◦−◦k
?
(·)♯
- Set[UB, Y ]
l ◦−◦U(k)
?
Y
l
?
induced by a morphism k and a function l, as indicated. We must show that
this square commutes, that is
 Π(l) ◦f ◦k
♯=
 l ◦f ♯◦U(k)

for each morphism
A
f - ΠX
from the top left hand corner. To check this we evaluate both sides at an arbi-
trary member b ∈B.
For (♭) consider the square
A
Set-R[A, ΠX] 
(·)♭
Set[UA, X]
X
B
k
6
Set-R[B, ΠY ]
Π(l) ◦−◦k
?

(·)♭
Set[UB, Y ]
l ◦−◦U(k)
?
Y
l
?
induced by a morphism k and a function l, as indicated. We must show that
this square commutes, that is
Π(l) ◦g♭◦k =
 l ◦g ◦U(k)

♭
for each function
A
g - ΠX

6.12. Some ﬁnal projects
221
from the top right hand corner. To check this we evaluate both sides ﬁrst at an
arbitrary b ∈B and then an arbitrary r ∈R.
This completes the discussion of
U ⊣Π
the lower adjunction.
Exercises
6.11.1
Verify the two identities involving ϵ and η that ensure we do have an
adjunction.
6.11.2
For the suggested transitions show that
f ♯= ϵx ◦U(f)
g♭= Π(g) ◦ηA
do hold for each morphism f and function g, as above.
6.11.3
Show that (·)♯and (·)♭form an inverse pair of transitions.
6.11.4
Show that for each function g, as above, the suggested function g♭is
a morphism.
6.11.5
Show that each of the transitions (·)♯and (·)♭is natural.
6.12 Some ﬁnal projects
In this ﬁnal section I will suggest various problems you might want to look
at. In each case the solution is known, but you will learn something from your
investigations. For most of the problems there is something extra that has to be
done.
There are various reﬁnements of the constructions of Sections 6.1 to 6.4.
For instance, suppose we do not need to complete a poset fully, but require
only suprema or inﬁma for ﬁnite subsets. This can be obtained by modifying
the two constructions, but there is something extra that has to be done. Such a
completion may not be achievable in one step. For another variant, suppose we
want to produce suprema for directed sets. What do we do?
There is another aspect of these completions that we should not ignore. Sup-
pose we want to complete a poset in some sense and that poset already has
some suprema or inﬁma. Suppose we wish to preserve some of these in the
constructed poset. What do we do? In the literature you will ﬁnd a construc-
tion, the MacNeille completion, which completes a poset and preserves any
suprema that the given poset may have. That is not the answer, for that con-
struction is not functorial.

222
6. Posets and monoid sets
There are two extensions of the constructions of Sections 6.7 to 6.11.
For the ﬁrst of these consider an arbitrary monoid morphism
S
φ
- R
between a pair of monoids. Associated with the two monoids we have a pair of
categories
Set-S
Set-R
the S-sets and the R-sets respectively. Observe that if S is the singleton monoid
then φ is uniquely determined and Set-S is just Set.
The morphism φ induces a functor
Set-S 
Φ
Set-R
the restriction of scalars which we have met before. The construction of Φ is
part of Exercise 3.3.14. This functor has a left and a right adjoint
Set-S
Σ
-

Φ
Π
-
Set-R
which you should sort out. When S is the singleton monoid this reduces to the
double adjunction of Sections 6.7 to 6.11.
This can be generalized even further. Consider a ring morphism
S
φ
- R
between a pair of rings. We have the two associated categories
Mod-S
Mod-R
of modules over S and R, respectively. The morphism φ induces a functor
Mod-S 
Φ
Mod-R
also called restriction of scalars. This has a left and a right adjoint
Mod-S
Σ
-

Φ
Π
-
Mod-R
where Σ is given by a tensor product and Π is an enriched hom-functor. There
are several parts of mathematics, both algebraic and geometric, where these
functors are needed.

Bibliography
J. Adamek, H. Herrlich, and G. E. Strecker (2004): Abstract and Concrete Cate-
gories: The Joy of Cats, published online.
S. Awodey (2010): Category Theory (Second Edition), Oxford University Press.
M. Barr and C. Wells (1985): Toposes, Triples and Theories, Springer.
M. Barr and C. Wells (1990): Category Theory for Computing Science, Prentice
Hall.
A. J. Berrick and M. E. Keating (2000): Categories and Modules, Cambridge
University Press.
F. Borceux (1994): Handbook of Categorical Algebra, three volumes, Cambridge
University Press.
S. Eilenberg and S. MacLane (1945): General theory of natural equivalences,
Transactions of the American Mathematical Society, 58, 231–294.
F. William Lawvere and Stephen H. Schanuel (1997): Conceptual Mathematics,
A First Introduction to Categories, Cambridge University Press.
S. Mac Lane (1998): Categories for the Working Mathematician (Second Edition),
Springer.
C. McClarty (1995): Elementary Categories, Elementary Toposes, Oxford Uni-
versity Press.
B. Mitchell (1965): Theory of Categories, Academic Press.
B. Pareigis (1970): Categories and Functors, Academic Press.

Index
Notation
C
an arbitrary category, 1
C
op
opposite of category C, 32
c
C
presheaves on a category, 96
C ↓arrow category from C, 19
C ∇category of ∇-diagrams from C, 115
(C ↓S) slice category over S, 20
(S ↓C) slice category under S, 20
(U ↓L) comma category, 86
C[A, B] hom-set from A to B
in category C, 4
[A, B] hom-set from A to B, 4
HomC [A, B] hom-set from A to B
in category C, 5
Arw
the arrows of a category, 1
Obj
the objects of a category, 1
source of an arrow, 2
target of an arrow, 2
−◦−composition of arrows, 3
idA identity arrow on A, 3
idA identity arrow on A, 3
1A identity arrow on A, 3
Src source category of a functor, 73
Trg
target category of a functor, 73
∆diagonal functor, 78
∇as a template, 108, 113
(I, E) a template, 112
I nodes of a template, 112
E edges of a template, 112
(Bij) a property on an adjunction, 164
(Nat) a property on an adjunction, 164
−⊣−adjunction
between categories, 149
between posets, 17
f[·] direct image across f, 80
f←(·) inverse image across f, 80
LS poset of lower sections of a poset S, 152,
194
bS
presheaves on a poset, 27
∃an endo-functor
on Pos, 197
on Set, 79
I an endo-functor
on Pos, 197
on Set, 79
∀an endo-functor
on Pos, 197
on Set, 79
Particular categories
AGrp abelian groups, 28
Ch(Mod-R) chain complexes over R, 28
CMon commutative monoids, 141
Eqv
equivalence relations, 137
Fld
ﬁelds and morphisms, 47
Grp groups and morphisms, 8
Idm integral domains and morphisms, 47
Inf
complete posets and V-morphisms, 192
Inv
involution algebras, 154, 204
Mod-R right R-modules and morphisms, 13
MON
monoid set categories and functors,
88
Mon monoids and morphisms, 9
Pfn sets and partial functions, 11
Pno peano structures, 14
Pos posets and monotone maps, 10
Pos⊣posets and poset adjunctions, 17
Pospp posets and projection pairs, 24
Pre presets and monotone maps, 10
Pth(∇) path category of a graph, 113

Index
225
RelA sets and relations as arrows, 16
R-Mod
left R-modules and morphisms, 13
Rng
rings and morphism, 8
R-Set left R-monoid sets and morphisms,
13
Set sets and functions, 7
SetD sets with a distinguished subset, 14,
134
Set⊥pointed sets and point preserving
functions, 15
Set-R right R-monoid sets and morphisms,
13, 203
Sup complete posets and W-morphisms, 192
Top topological spaces and continuous
maps, 8
Top2 hausdorff spaces and continuous maps,
42
VectK
vector spaces over a ﬁeld K and
linear transformations, 8
Terminology
abstract nonsense, 72
action
of a monoid on a set, 13
adjunction
between category, 149, 151
between poset, 17
arrow category, 19
arrow-class, 4
balanced category, 40
bimorphism, 40
biproduct, 55
butty category, 26
cell
of a diagram, 35
chain complex, 28
choice function, 131
cocone, 49
codomain of an arrow, 2
coequalizer, 57
cofree solution, 176
commuting diagram, 5, 35
compact open topology, 159
cone, 49
conﬂuent poset, 143
contravariant, 74
coproduct
of two objects, 50
counit
of an adjunction, 150
covariant, 74
diagonal functor, 78, 118
diagram, 2, 5, 35
commuting, 5, 35
directed
poset, 143
pre-ordered set, 117
directed graph, 22, 113
domain of an arrow, 2
edge of a directed graph, 113
element
global, 46
epic, 37
split, 39
equalizer, 57
ﬁnal object, 45
forgetful functor, 76
free solution, 176
functor, 73, 74
contravariant, 74
covariant, 74
forgetful, 76
hom, 77
furnished set, 5, 8
furnishings, 5, 8
global element, 46
graph
as a directed graph, 22
morphism, 22
used as a template, 113
hom-functor, 77
hom-set, 4
horizontal composition, 106
idempotent algebra, 204
2-step, 204
initial object, 45
inverse pair
of isomorphisms, 40
involution algebra, 154, 204
2-step, 204
isomorphism, 40
kernel
of a function
as an equivalence relation, 60

226
Index
locally compact space, 160
loop space, 160
lower section
of a poset, 193
of a preset, 24
make equal, 56
map
as another name for arrow, 2
mediating arrow, 50, 57, 66, 121
mediator, 50, 57, 66, 121
monic, 37
split, 39
monoid, 8, 202
monoid set, 202
monotone map, 10
morphism
as another name for arrow, 2
natural
for variation of, 90
isomorphism, 91
transformation, 91
naturally equivalent, 91
node of a directed graph, 113
object
ﬁnal, 45
initial, 45
terminal, 45
zero, 46
opposite
of a category, 32
parallel pair of arrows, 5
partial function, 11
posets, 10
W-complete, 191
V-complete, 191
and monotone maps, 10
and poset adjunctions, 17
and projection pairs, 24
presets, 10
presheaf
on a category, 96
on a poset, 27
product
of two categories, 19
of two objects, 50
pullback, 65
pushout, 65
restriction of scalars, 155, 222
retraction
a kind of arrow, 39
section
a kind of arrow, 39
a kind of subset of a preset
lower, 24
upper, 81
semigroup, 8
sets
with a distinguished subset, 14
slice category, 20
solution
to a posed problem, 64
source of an arrow, 2
specialization order, 81
split
epic, 39
monic, 39
structured set, 8
suspension space, 160
target of an arrow, 2
template, 19, 113
terminal object, 45
thread, 131
transposition assignment, 151
unit
of an adjunction, 150
universal solution
to a posed problem, 66, 121
upper section
of a poset, 193
of a preset, 81
upwards directed pre-ordered set, 117
vertical composition, 106
wedge, 49
Yoneda completion, 96
zero object, 46

