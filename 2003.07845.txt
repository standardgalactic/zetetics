PowerNorm: Rethinking Batch Normalization in Transformers
Sheng Shen * 1 Zhewei Yao * 1 Amir Gholami 1 Michael W. Mahoney 1 Kurt Keutzer 1
Abstract
The standard normalization method for neural
network (NN) models used in Natural Language
Processing (NLP) is layer normalization (LN).
This is different than batch normalization (BN),
which is widely-adopted in Computer Vision. The
preferred use of LN in NLP is principally due to
the empirical observation that a (naive/vanilla)
use of BN leads to signiﬁcant performance degra-
dation for NLP tasks; however, a thorough un-
derstanding of the underlying reasons for this is
not always evident. In this paper, we perform
a systematic study of NLP transformer models
to understand why BN has a poor performance,
as compared to LN. We ﬁnd that the statistics
of NLP data across the batch dimension exhibit
large ﬂuctuations throughout training. This re-
sults in instability, if BN is naively implemented.
To address this, we propose Power Normaliza-
tion (PN), a novel normalization scheme that re-
solves this issue by (i) relaxing zero-mean nor-
malization in BN, (ii) incorporating a running
quadratic mean instead of per batch statistics to
stabilize ﬂuctuations, and (iii) using an approxi-
mate backpropagation for incorporating the run-
ning statistics in the forward pass.
We show
theoretically, under mild assumptions, that PN
leads to a smaller Lipschitz constant for the loss,
compared with BN. Furthermore, we prove that
the approximate backpropagation scheme leads
to bounded gradients. We extensively test PN for
transformers on a range of NLP tasks, and we
show that it signiﬁcantly outperforms both LN
and BN. In particular, PN outperforms LN by
0.4/0.6 BLEU on IWSLT14/WMT14 and 5.6/3.0
PPL on PTB/WikiText-103. We make our code
publicly available at https://github.com/
sIncerass/powernorm.
*Equal contribution 1UC Berkeley. Correspondence to: Amir
Gholami <amirgh@berkeley.edu>.
Proceedings of the 37 th International Conference on Machine
Learning, Vienna, Austria, PMLR 119, 2020. Copyright 2020 by
the author(s).
1. Introduction
Normalization has become one of the critical components
in Neural Network (NN) architectures for various machine
learning tasks, in particular in Computer Vision (CV) and
Natural Language Processing (NLP). However, currently
there are very different forms of normalization used in CV
and NLP. For example, Batch Normalization (BN) (Ioffe
& Szegedy, 2015) is widely adopted in CV, but it leads to
signiﬁcant performance degradation when naively used in
NLP. Instead, Layer Normalization (LN) (Ba et al., 2016) is
the standard normalization scheme used in NLP. All recent
NLP architectures, including Transformers (Vaswani et al.,
2017), have incorporated LN instead of BN as their default
normalization scheme. In spite of this, the reasons why BN
fails for NLP have not been clariﬁed, and a better alternative
to LN has not been presented.
In this work, we perform a systematic study of the chal-
lenges associated with BN for NLP, and based on this we
propose Power Normalization (PN), a novel normalization
method that signiﬁcantly outperforms LN. In particular, our
contributions are as follows:
• We ﬁnd that there are clear differences in the batch
statistics of NLP data versus CV data. In particular, we
observe that batch statistics for NLP data have a very
large variance throughout training. This variance exists
in the corresponding gradients as well. In contrast,
CV data exhibits orders of magnitude smaller variance.
See Figure 2 and 3 for a comparison of BN in CV and
NLP.
• To reduce the variation of batch statistics, we mod-
ify typical BN by relaxing zero-mean normalization,
and we replace the variance with the quadratic mean.
We denote this scheme as PN-V. We show theoreti-
cally that PN-V preserves the ﬁrst-order smoothness
property as in BN; see Lemma 2.
• We show that using running statistics for the quadratic
mean results in signiﬁcantly better performance, up to
1.5/2.0 BLEU on IWSLT14/WMT14 and 7.7/3.4 PPL
on PTB/WikiText-103, as compared to BN; see Table 1
and 2. We denote this scheme as PN. Using running
statistics requires correcting the typical backpropaga-
tion scheme in BN. As an alternative, we propose an
arXiv:2003.07845v2  [cs.CL]  28 Jun 2020

PowerNorm: Rethinking Batch Normalization in Transformers
approximate backpropagation to capture the running
statistics. We show theoretically that this approximate
backpropagation leads to bounded gradients, which is
a necessary condition for convergence; see Theorem 4.
• We perform extensive tests showing that PN also
improves performance on machine translation and
language modeling tasks, as compared to LN. In
particular, PN outperforms LN by 0.4/0.6 BLEU
on IWSLT14/WMT14, and by 5.6/3.0 PPL on
PTB/WikiText-103. We emphasize that the improve-
ment of PN over LN is without any change of hyper-
parameters.
• We analyze the behaviour of PN and LN by comput-
ing the Singular Value Decomposition of the resulting
embedding layers, and we show that PN leads to a
more well-conditioned embedding layer; see Figure 6.
Furthermore, we show that PN is robust to small-batch
statistics, and it still achieves higher performance, as
opposed to LN; see Figure 5.
Feature
Batch Dimension
Sentence Length
Layer Normalization
Feature
Batch Dimension
Sentence Length
Batch/Power Normalization
Figure 1. The illustration of layer normalization (left) and
batch/power normalization (right). The entries colored in blue
show the components used for calculating the statistics.
2. Related Work
Normalization is widely used in modern deep NNs such
as ResNet (He et al., 2016), MobileNet-V2 (Sandler et al.,
2018), and DenseNet (Huang et al., 2017) in CV, as well
as LSTMs (Hochreiter & Schmidhuber, 1997; Ba et al.,
2016), transformers (Vaswani et al., 2017), and transformer-
based models (Devlin et al., 2019; Liu et al., 2019) in NLP.
There are two main categories of normalization: weight
normalization (Salimans & Kingma, 2016; Miyato et al.,
2018; Qiao et al., 2019) and activation normalization (Ioffe
& Szegedy, 2015; Jarrett et al., 2009; Krizhevsky et al.,
2012; Ba et al., 2016; Ulyanov et al., 2016; Wu & He, 2018;
Li et al., 2019). Here, we solely focus on the latter, and we
brieﬂy review related work in CV and NLP.
Normalization in Computer Vision
Batch Normaliza-
tion (BN) (Ioffe & Szegedy, 2015) has become the de-facto
normalization for NNs used in CV. BN normalizes the ac-
tivations (feature maps) by computing channel-wise mean
and variance across the batch dimension, as schematically
shown in Figure 1. It has been found that BN leads to
robustness with respect to sub-optimal hyperparameters
(e.g., learning rate) and initialization, and it generally re-
sults in more stable training for CV tasks (Ioffe & Szegedy,
2015). Following the seminal work of (Ioffe & Szegedy,
2015), there have been two principal lines of research: (i)
extensions/modiﬁcations of BN to improve its performance,
and (ii) theoretical/empirical studies to understand why BN
helps training.
With regard to (i), it was found that BN does not per-
form well for problems that need to be trained with small
batches, e.g., image segmentation (often due to memory
limits) (Zagoruyko & Komodakis, 2016; Lin et al., 2017;
Goldberger et al., 2005). The work of (Ioffe, 2017) proposed
batch renormalization to remove/reduce the dependence of
batch statistics to batch size. It was shown that this approach
leads to improved performance for small batch training as
well as cases with non-i.i.d. data. Along this direction, the
work of (Singh & Shrivastava, 2019) proposed “EvalNorm,”
which uses corrected normalization statistics. Furthermore,
the recent work of (Yan et al., 2020) proposed “Moving
Average Batch Normalization (MABN)” for small batch BN
by replacing batch statistics with moving averages.
There has also been work on alternative normalization tech-
niques, and in particular Layer Normalization (LN), pro-
posed by (Ba et al., 2016). LN normalizes across the chan-
nel/feature dimension as shown in Figure 1. This could be
extended to Group Norm (GN) (Wu & He, 2018), where
the normalization is performed across a partition of the fea-
tures/channels with different pre-deﬁned groups. Instance
Normalization (IN) (Ulyanov et al., 2016) is another tech-
nique, where per-channel statistics are computed for each
sample.
With regard to (ii), there have been several studies to under-
stand why BN helps training in CV. The original motivation
was that BN reduces the so-called “Internal Covariance
Shift” (ICS) (Ioffe & Szegedy, 2015). However, this expla-
nation was viewed as incorrect/incomplete (Rahimi, 2017).
In particular, the recent study of (Santurkar et al., 2018)
argued that the underlying reason that BN helps training is
that it results in a smoother loss landscape. This was later
conﬁrmed for deep NN models by measuring the Hessian
spectrum of the network with/without BN (Yao et al., 2019).
Normalization in Natural Language Processing
De-
spite the great success of BN in CV, the large computation
and storage overhead of BN at each time-step in recurrent

PowerNorm: Rethinking Batch Normalization in Transformers
neural networks (RNNs) made it impossible/expensive to de-
ploy for NLP tasks (Cooijmans et al., 2017). To address this,
the work of (Cooijmans et al., 2017; Hou et al., 2019) used
shared BN statistics across different time steps of RNNs.
However, it was found that the performance of BN is signif-
icantly lower than LN for NLP. For this reason, LN became
the default normalization technique, even for the recent
transformer models introduced by (Vaswani et al., 2017).
Only limited recent attempts were made to compare LN
with other alternatives or investigate the reasons behind the
success of LN in transformer models. For instance, (Zhang
& Sennrich, 2019) proposes RMSNorm, which removes the
re-centering invariance in LN and performs re-scaling invari-
ance with the root mean square summed of the inputs. They
showed that this approach achieves similar performance
to LN, but with smaller (89% to 64%) overhead. Further-
more, (Nguyen & Salazar, 2019) studies different variants
of weight normalization for transformers in low-resource
machine translation. The recent work of (Xu et al., 2019)
studies why LN helps training, and in particular it ﬁnds that
the derivatives of LN help recenter and rescale backward
gradients. From a different angle, (Zhang et al., 2019b;a)
try to ascribe the beneﬁts of LN to solving the exploding
and vanishing gradient problem at the beginning of train-
ing. They also propose two properly designed initialization
schemes which also enjoy that property and are able to
stabilize training for transformers.
However, most of these approaches achieve similar or
marginal improvement over LN. More importantly, there is
still not a proper understanding of why BN performs poorly
for transformers applied to NLP data. Here, we address
this by systematically studying the BN behavior through-
out training; and, based on our results, we propose Power
Normalization (PN), a new normalization method that sig-
niﬁcantly outperforms LN for a wide range of tasks in NLP.
3. Batch Normalization
Notation. We denote the input of a normalization layer as
X P RBˆd, where d is the embedding/feature size and B
is the batch size1. We denote L as the ﬁnal loss of the NN.
The i-th row (column) of a matrix, e.g., X, is denoted by
Xi,: (X:,i). We also write the i-th row of the matrix as
its lower-case version, i.e., xi “ Xi,:. For a vector y, yi
denotes the i-th element in y.
Without other speciﬁcation: (i) for two vector x P Rd and
y P Rd, we denote xy as the element-wise product, x ` y
as the element-wise sum, and xx, yy as the inner product;
1For NLP tasks, we ﬂatten sentences/word in one dimension,
i.e., the batch size actually corresponds to all non-padded words
in a training batch.
Algorithm 1 Batch Normalization (Every Iteration)
begin Forward Propagation:
Input: X P RBˆd
Output: Y P RBˆd
µB “ 1
B
řB
i“1 xi
// Get mini-batch mean
σ2
B “ 1
B
řB
i“1pxi ´ µBq2 // Get mini-batch variance
|
X “ X´µB
σB
// Normalize
Y “ γ d |
X ` β
// Scale and shift
µ “ αµ ` p1 ´ αqµB
// Update running mean
σ2 “ ασ2 ` p1 ´ αqσ2
B
// Update running variance
begin Backward Propagation:
Input: BL
BY P RBˆd
Output: BL
BX P RBˆd
BL
BX based on Eq. 3
// Gradient of X
Inference: Y “ γ d X´µ
σ
` β
(ii) for a vector y P Rd and a matrix X P RBˆd, we denote
ydX as ry1X:,1, ..., ydA:,ds and y`X as ry`X1,:; ...; y`
XB,:s; and (iii) for a vector y P Rd, y ą C means that each
entry of y is larger than the constant C, i.e., yi ą C for all
i.
3.1. Formulation of Batch Normalization
We brieﬂy review the formulation of BN (Ioffe & Szegedy,
2015). Let us denote the mean (variance) of X along the
batch dimension as µB P Rd (σ2
B P Rd). The batch dimen-
sion is illustrated in Figure 1. The BN layer ﬁrst enforces
zero mean and unit variance, and it then performs an afﬁne
transformation by scaling the result by γ, β P Rd, as shown
in Algorithm 1.
The Forward Pass (FP) of BN is performed as follows. Let
us denote the intermediate result of BN with zero mean and
unit variance as |
X, i.e.,
|
X “ X ´ µB
σB
.
(1)
The ﬁnal output of BN, Y , is then an afﬁne transformation
applied to |
X:
Y “ γ d |
X ` β.
(2)
The corresponding Backward Pass (BP) can then be derived
as follows. Assume that the derivative of L with respect to
Y is given, i.e., BL
BY is known. Then, the derivative with
respect to input can be computed as:
BL
Bxi “ γ
σB
BL
Byi ´
γ
σBB
ÿ
jPB
p
BL
Byj
loomoon
from µB: gµ
` BL
Byj
ˇxjˇxi
loooomoooon
from σ2
B: gσ2
q.
(3)
See Lemma 6 in Appendix C for details. We denote the
terms contributed by µB and σ2
B as gµ and gσ2, respectively.

PowerNorm: Rethinking Batch Normalization in Transformers
20%
40%
60%
80%
100%
Percent of Training Epochs
0.00
0.01
0.02
0.03
0.04
0.05
0.06
0.07
1
d||
B||
CIFAR10
IWSLT14
20%
40%
60%
80%
100%
Percent of Training Epochs
0
1
2
3
4
5
6
1
d||
2
2
B||
CIFAR10
IWSLT14
Figure 2. The average Euclidean distance between the batch statistics (µB, σ2
B) and the running statistics (µ, σ2) stored in ﬁrst BN during
forward pass for ResNet20 on Cifar-10 and Transformer on IWLST14. We can clearly see that the ResNet20 statistics have orders of
magnitude smaller variation than the running statistics throughout training. However, the corresponding statistics in TransformerBN
exhibit very high variance with extreme outliers. This is true both for the mean (shown in the left) as well as variance (shown in right).
This is one of the contributing factors to the low performance of BN in transformers.
In summary, there are four batch statistics in BN, two in
FP and two in BP. The stability of training is highly depen-
dent on these four parameters. In fact, naively implement-
ing the BN as above for transformers leads to poor perfor-
mance. For example, using transformer with BN (denoted
as TransformerBN) results in 1.1 and 1.4 lower BLEU score,
as compared to the transformer with LN (TransformerLN),
on IWSLT14 and WMT14, respectively; see Table 1.
This is signiﬁcant performance degradation, and it stems
from instabilities associated with the above four batch
statistics. To analyze this, we studied the batch statistics
using the standard setting of ResNet20 on Cifar-10 and
TransformerBN on IWSLT14 (using a standard batch size
of 128 and tokens of 4K, respectively). In the ﬁrst experi-
ment, we probed the ﬂuctuations between batch statistics,
µB/σB, and the corresponding BN running statistics, µ/σ,
throughout training. This is shown for the ﬁrst BN layer
of ResNet20 on Cifar-10 and TransformerBN on IWSLT14
in Figure 2. Here, the y-axis shows the average Euclidean
distance between batch statistics (µB, σB) and the running
statistics (µ, σ), and the x-axis is different epochs of train-
ing, where we deﬁne the average Euclidean distance as
distpµB, µq “ 1
d}µB ´ µ}.
The ﬁrst observation is that TransformerBN shows signiﬁ-
cantly larger distances between the batch statistics and the
running statistics than ResNet20 on Cifar-10, which exhibits
close to zero ﬂuctuations. Importantly, this distance between
σB and σ signiﬁcantly increases throughout training, but
with extreme outliers. During inference, we have to use the
running statistics. However, such large ﬂuctuations would
lead to a large inconsistency between statistics of the testing
data and the BN’s running statistics.
The second observation comes from probing the norm of gµ
and gσ2 deﬁned in Eq. 3, which contribute to the gradient
backpropagation of input. These results are shown in Figure
3, where we report the norm of these two parameters for
ResNet20 and TransformerBN. For TransformerBN, we can
see very large outliers that actually persist throughout train-
ing. This is in contrast to ResNet20, for which the outliers
vanish as training proceeds.
4. Power Normalization
Based on our empirical observations, we propose Power
Normalization (PN), which effectively resolves the perfor-
mance degradation of BN. This is achieved by incorporating
the following two changes to BN. First, instead of enforcing
unit variance, we enforce unit quadratic mean for the acti-
vations. The reason for this is that we ﬁnd that enforcing
zero-mean and unit variance in BN is detrimental due to the
large variations in the mean, as discussed in the previous
section. However, we observe that unlike mean/variance,
the unit quadratic mean is signiﬁcantly more stable for trans-
formers. Second, we incorporate running statistics for the
quadratic mean of the signal, and we incorporate an approxi-
mate backpropagation method to compute the corresponding
gradient. We ﬁnd that the combination of these two changes
leads to a signiﬁcantly more effective normalization, with
results that exceed LN, even when the same training hyper-
parameters are used. Below we discuss each of these two
components.
4.1. Relaxing Zero-Mean and Enforcing Quadratic
Mean
Here, we describe the ﬁrst modiﬁcation in PN. As shown
in Figure 2 and 3, µB and gµ exhibit signiﬁcant number of
large outliers, which leads to inconsistencies between train-
ing and inference statistics. We ﬁrst address this by relaxing
the zero-mean normalization, and we use the quadratic mean
of the signal, instead of its variance. The quadratic mean
exhibits orders of magnitude smaller ﬂuctuations, as shown

PowerNorm: Rethinking Batch Normalization in Transformers
20%
40%
60%
80%
100%
Percent of Training Epochs
0.0
0.1
0.2
0.3
0.4
0.5
1
d||g ||
CIFAR10
IWSLT14
20%
40%
60%
80%
100%
Percent of Training Epochs
0.0
0.2
0.4
0.6
0.8
1.0
1.2
1
d||g
2||
CIFAR10
IWSLT14
Figure 3. The average gradient norm of the input of the ﬁrst BN layer contributed by µB and σB for ResNet20 on Cifar10 and
TransformerBN on IWSLT14 during the BP (note that d “ 16 for Cifar-10 and d “ 512 for IWSLT experiment). It can be clearly
seen that the norm of gµ and gσ2 for ResNet20 has orders of magnitude smaller variation throughout training, as compared to that for
TransformerBN. Also, the outliers for ResNet20 vanish at the end of training, which is in contrast to TransformerBN, for which the outliers
persist. This is true both for gµ (shown in left) as well as gσ2 (shown in right).
20%
40%
60%
80%
100%
0
1
2
3
4
5
6
1
d||
2
2
B||
BN
PN-V
0
1
2
3
4
5
6
1
d||
2
2
B||
20%
40%
60%
80%
100%
0.0
0.2
0.4
0.6
0.8
1.0
1.2
1
d||g
2||
BN
PN-V
0.0
0.2
0.4
0.6
0.8
1.0
1.2
1
d||g
2||
Figure 4. Results for Transformer on IWSLT14. (Left) The average Euclidean distance between batch statistics (σB, ψB) and the running
statistics (σ, ψ) stored in ﬁrst BN/PN-V during forward propagation (FP). (Right) The average norm of gradient of the input of the ﬁrst
BN/PN-V contributed by σB/ψB. During FP, ψB has much smaller variations of running statistics, as compared to σB, as shown in left,
It can also be clearly seen that during BP, the norm of gψ2 exhibits many fewer outliers, as compared to gσ2, throughout the training.
in Figure 4. We refer to this normalization (i.e., no zero
mean and unit quadratic mean enforcement) as PN-V, de-
ﬁned as follows.
Deﬁnition 1 (PN-V). Let us denote the quadratic mean of
the batch as ψB
2 “
1
B
řB
i“1 x2
i . Furthermore, denote x
X
as the signal scaled by ψB, i.e.,
x
X “ X
ψB .
(4)
Then, the output of PN-V is deﬁned as
Y “ γ d x
X ` β,
(5)
where γ P Rd and β P Rd are two parameters (vectors) in
PN-V (which is the same as in the afﬁne transformation
used in BN).
Note that here we use the same notation Y as the output
in Eq. 2 without confusion.
The corresponding BP of PN-V is as follows:
BL
Bxi “
γ
ψB
BL
Byi ´
γ
BψB
ÿ
jPB
BL
Byj
ˆxjˆxi
loooomoooon
from ψB2: gψ2
.
(6)
See Lemma 8 in Appendix C for the full details. Here,
gψ2 is the gradient attributed by ψB
2. Note that, compared
to BN, there exist only two batch statistics in FP and BP:
ψB
2 and gψ2. This modiﬁcation removes the two unstable
factors corresponding to µB and σB in BN (gµ, and gσ2
in Eq. 3). This modiﬁcation also results in signiﬁcant per-
formance improvement, as reported in Table 1 for IWSLT14
and WMT14. By directly replacing BN with PN-V (de-
noted as TransformerPN-V), the BLEU score increases from
34.4 to 35.4 on IWSLT14, and 28.1 to 28.5 on WMT14.
These improvements are signiﬁcant for these two tasks. For
example, (Zhang et al., 2019b;a) only improves the BLEU
score by 0.1 on IWSLT14.
As mentioned before, ψB exhibits orders of magnitude
smaller variations, as compared to σB. This is shown in Fig-

PowerNorm: Rethinking Batch Normalization in Transformers
ure 4, where we report the distance between the running
statistics for σ, distpσ2
B, σ2q, and ψ, distpψB
2, ψ2q. Simi-
larly during BP, we compute the norm of gσ2 and gψ2, and
we report it in Figure 4 throughout training. It can be clearly
seen that during BP, the norm of gψ2 exhibits many fewer
outliers as compared to gσ2.
In (Santurkar et al., 2018), the authors provided theoretical
results suggesting that employing BN in DNNs can lead to
a smaller Lipschitz constant of the loss.
It can be shown that PN-V also exhibits similar behaviour,
under mild assumptions. In more detail, let us denote the
loss of the NN without normalization as pL. With mild
assumptions, (Santurkar et al., 2018) shows that the norm
of BL
BX (with BN) is smaller than the norm of B p
L
BX . Here, we
show that, under the same assumptions, PN-V can achieve
the same results that BN does. See Appendix C for details,
including the statement of Assumption 9.
Lemma 2 (The effect of PN-V on the Lipschitz constant of
the loss). Under Assumption 9, we have
} BL
BX:,i }2 “
γ2
i
pψBq2
i
˜
} B pL
BX:,i }2 ´ x B pL
BX:,i ,
x
X:,i
?
B
y2
¸
.
(7)
See the proof in Appendix C. Note that x
B p
L
BX:,i ,
x
X:,i
?
B y2 is non-
negative, and hence the Lipschitz constant of L is smaller
than that of pL if γi ď pψBqi. This is what we observe in
practice, as shown in Appendix B.
4.2. Running Statistics in Training
Here, we discuss the second modiﬁcation in PN. First
note that even though TransformerPN-V outperforms
TransformerBN, it still can not match the performance of
LN. This could be related to the larger number of outliers
present in ψB, as shown in Figure 4. A straightforward
solution to address this is to use running statistics for the
quadratic mean (denoted as ψ2), instead of using per batch
statistics, since the latter changes in each iteration. How-
ever, using running statistics requires modiﬁcation of the
backpropagation, which we described below.
Deﬁnition 3 (PN). Denote the inputs/statistics at the t-th
iteration by ¨ptq, e.g., Xptq is the input data at t-th iteration.
In the forward propagation, the following equations are
used for the calculation:
x
Xptq “ Xptq
ψpt´1q ,
(8)
Y ptq “ γ d x
Xptq ` β,
(9)
pψptqq2 “ pψpt´1qq2 ` p1 ´ αqpψB
2 ´ pψpt´1qq2q.
(10)
Here, 0 ă α ă 1 is the moving average coefﬁcient in the
forward propagation, and ψB is the statistic for the current
batch. Since the forward pass evolves running statistics,
Algorithm 2 Power Normalization (Every Iteration)
begin Forward Propagation:
Input: X P RBˆd
Output: Y P RBˆd
ψB
2 “ 1
B
řB
i“1 x2
i
// Get mini-batch statistics
x
X “ X
ψ
// Normalize
Y “ γ d x
X ` β
// Scale and shift
ψ2 “ αψ2 ` p1 ´ αqψB
2
// Update running
statistics
begin Backward Propagation:
Input: BL
BY P RBˆd
Output: BL
BX P RBˆd
BL
B x
X “ γ d BL
BY
// Intermediate Gradient
Ă
X1 “ BL
B x
X ´ ν x
X
// Intermediate Estimated Gradient
BL
BX “
Ă
X1
ψ
// Gradient of X
ν “ νp1 ´ p1 ´ αqΓq ` p1 ´ αqΛ
// See
Definition 3 for Γ and Λ
Inference: Y “ γ d X
ψ ` β
the backward propagation cannot be accurately computed—
namely, the accurate gradient calculation needs to track
back to the ﬁrst iteration. Here, we propose to use the
following approximated gradient in backward propagation:
pĂ
Xptqq1 “
BL
B x
Xptq ´ νpt´1q d x
Xptq,
(11)
BL
BXptqq “ pĂ
Xptqq1
ψpt´1q ,
(12)
νptq “ νpt´1qp1 ´ p1 ´ αqΓptqq ` p1 ´ αqΛptq,
(13)
where
Γptq
“
1
B
řB
i“1 ˆxptq
i ˆxptq
i
and
Λptq
“
1
B
řB
i“1
BL
Bˆxptq
i ˆxptq
i .
This backpropagation essentially uses running statistics by
computing the gradient of the loss w.r.t. the quadratic mean
of the current batch, rather than using the computationally
infeasible method of computing directly the gradient w.r.t.
running statistics of the quadratic mean. Importantly, this
formulation leads to bounded gradients which is necessary
for convergence, as shown below.
Theorem 4 (Gradient of L w.r.t. X is bounded in PN). For
any datum point of Ă
X (i.e. Ă
Xi,:), the gradients computed
from Eq. 11 are bounded by a constant.
Furthermore, the gradient of Xi,: is also bounded, as
given Eq. 12.
See the proof in Appendix C. The pseudo-code for PN
algorithm is presented in Algorithm 2.

PowerNorm: Rethinking Batch Normalization in Transformers
5. Results
5.1. Experiment Setup
We compare our PN method with LN and BN for a variety
of sequence modeling tasks: Neural Machine Translation
(MT); and Language Modeling (LM). We implement our
code for MT using fairseq-py (Ott et al., 2019), and (Ma
et al., 2019) for LM tasks. For a fair comparison, we directly
replace the LN in transformers (TransformerLN) with BN
(TransformerBN) or PN (TransformerPN) without varying
the position of each normalization layer or changing the
training hyperparameters.
For all the experiments, we use the pre-normalization setting
in (Wang et al., 2019), where the normalization layer is
located right before the multi-head attention module and
point-wise feed-forward network module. Following (Wang
et al., 2019), we generally increase the learning rate by a
factor of 2.0, relative to the common post-normalization
transformer (Vaswani et al., 2017). Below we discuss tasks
speciﬁc settings. 2
Neural Machine Translation
We evaluate our methods
on two widely used public datasets: IWSLT14 German-
to-English (De-En) and WMT14 English-to-German (En-
De) dataset. We follow the settings reported in (Ott et al.,
2018). We use transformer big architecture for WMT14
(4.5M sentence pairs) and small architecture for IWSLT14
(0.16M sentence pairs). For inference, we average the last
10 checkpoints, and we set the length penalty to 0.6/1.0, and
the beam size to 4/5 for WMT/IWSLT, following (Ott et al.,
2019). All the other hyperparamters (learning rate, dropout,
weight decay, warmup steps, etc.) are set identically to the
ones reported in the literature for LN (i.e., we use the same
hyperparameters for BN/PN).
Language
Modeling
We
experiment
on
both
PTB (Mikolov et al., 2011) and Wikitext-103 (Mer-
ity et al., 2017), which contain 0.93M and 100M tokens,
respectively. We use three layers tensorized transformer
core-1 for PTB and six layers tensorized transformer
core-1 for Wikitext-103, following (Ma et al., 2019).
Furthermore, we apply the multi-linear attention mech-
anism with masking, and we report the ﬁnal testing set
perplexity (PPL).3
5.2. Experiment Results
Neural Machine Translation
We use BLEU (Papineni
et al., 2002) as the evaluation metric for MT. Following
standard practice, we measure tokenized case-sensitive
2More detailed experimental settings and comparisons between
normalization methods are provided in Appendix A, B.3.
3We also report the validation perplexity in Appendix B.
Model
IWSLT14
WMT14
small
big
Transformer (Vaswani et al., 2017)
34.4
28.4
DS-Init (Zhang et al., 2019a)
34.4
29.1
Fixup-Init (Zhang et al., 2019b)
34.5
29.3
Scaling NMT (Ott et al., 2018)
/
29.3
Dynamic Conv (Wu et al., 2019)
35.2
29.7
Transformer + LayerDrop (Fan et al., 2020)
/
29.6
Pre-Norm TransformerLN
35.5
29.5
Pre-Norm TransformerBN
34.4
28.1
Pre-Norm TransformerPN-V
35.5
28.5
Pre-Norm TransformerPN
35.9
30.1
Table 1. MT performance (BLEU) on IWSLT14 De-En and
WMT14 En-De testsets. Using PN-V instead of BN signiﬁcantly
improves the performance, but LN still outperforms. However, PN
achieves much higher BLEU scores, as compared to LN.
BLEU and case-insensitive BLEU for WMT14 En-De and
IWSLT14 De-En, respectively. For a fair comparison, we
do not include other external datasets. All the transform-
ers in Table 1 are using six encoder layers and six decoder
layers.
The results are reported in Table 1. In the ﬁrst section of
rows, we report state-of-the-art results for these two tasks
with comparable model sizes. In the second section of rows,
we report the results with different types of normalization.
Notice the signiﬁcant drop in BLEU score when BN is used
(34.4/28.1), as opposed to LN (35.5/29.5). Using PN-V in-
stead of BN helps reduce this gap, but LN still outperforms.
However, the results corresponding to PN exceeds LN re-
sults by more than 0.4/0.6 points, This is signiﬁcant for these
tasks. Comparing with other concurrent works like DS-Init
and Fixup-Init (Zhang et al., 2019a;b), the improvements in
TransformerPN are still signiﬁcant.
Model
PTB
WikiText-103
Test PPL
Test PPL
Tied-LSTM (Inan et al., 2017)
48.7
48.7
AWD-LSTM-MoS (Yang et al., 2018)
56.0
29.2
Adaptive Input (Baevski & Auli, 2019)
57.0
20.5
Transformer-XLbase (Dai et al., 2019)
54.5
24.0
Transformer-XLlarge (Dai et al., 2019)
–
18.3
Tensor-Transformer1core (Ma et al., 2019)
57.9
20.9
Tensor-Transformer2core (Ma et al., 2019)
49.8
18.9
Tensor-Transformer1core + LN
53.2*
20.9*
Tensor-Transformer1core + BN
60.7
27.2
Tensor-Transformer1core + PN-V
55.3
21.3
Tensor-Transformer1core + PN
47.6
17.9
Table 2.
Results with state-of-the-art methods on PTB and
WikiText-103. ’-’ indicates no reported results in that setting,
’˚’ indicates the results are from our own implementation. PN
achieves 5.6/3 points lower testing PPL on PTB and WikiTest-103,
respectively, compared to LN.

PowerNorm: Rethinking Batch Normalization in Transformers
Language Modeling
We report the LM results in Table 2,
using the tensorized transformer proposed in (Ma et al.,
2019). Here we observe a similar trend. Using BN re-
sults in a signiﬁcant degradation, increasing testing PPL by
more than 7.5/6.3 for PTB/WikiText-103 datasets (achiev-
ing 60.7/27.2 as opposed to 53.2/20.9). However, when we
incorporate the PN normalization, we achieve state-of-the-
art results for these two tasks (for these model sizes and
without any pre-training on other datasets). In particular,
PN results in 5.6/3 points lower testing PPL, as compared
to LN. Importantly, note that using PN we achieve better
results than (Ma et al., 2019), with the same number of
parameters.
5.3. Analysis
512
1k
2k
4k
Batch Size (#tokens in each batch) for IWSLT14
34.6
34.8
35.0
35.2
35.4
35.6
35.8
BLEU
PN
LN
PN-V
BN
Figure 5. Ablation study of the performance of PN, PN-V, LN
and BN on IWSLT14 trained using different batch sizes. Note
that the performance of PN consistently outperforms LN. In the
meanwhile, PN-V can only match the result of LN when mini-
batch gets to 4K. Among all the settings, BN behaves poorly and
abnormally across different mini-batches.
The Effect of Batch Size for Different Normalization
To understand better the effects of our proposed methods
PN and PN-V, we change the batch size used to collect
statistics in BN, LN, and PN. To this end, we keep the total
batch size constant at 4K tokens, and we vary the mini-batch
size used to collect statistics from 512 to 4K. Importantly,
note that we keep the total batch size constant at 4K, and
we use gradient accumulation for smaller mini-batches. For
example, for the case with mini-batch of 512, we use eight
gradient accumulations. The results are reported in Figure
5. We can observe that BN behaves poorly and abnormally
across different mini-batches. Noticeably, after relaxing
the zero-mean normalization in BN and replacing the vari-
ance estimation with quadratic mean, PN-V matches the
performance of LN for 4K mini-batch and consistently out-
performs BN. However, it underperforms LN. In contrast,
we can see that PN consistently achieves higher results
under different mini-batch settings.
Representation Power of learned Embedding
To inves-
tigate further the performance gain of PN, we compute the
Singular Value Decomposition of the embedding layers, as
proposed by (Gao et al., 2019), which argued that the singu-
lar value distribution could be used as a proxy for measuring
representational power of the embedding layer. It has been
argued that having fast decaying singular values leads to
limiting the representational power of the embeddings to a
small sub-space. If this is the case, then it may be preferable
to have a more uniform singular value distribution (Wang
et al., 2020). We compute the singular values for word em-
bedding matrix of LN and PN, and we report the results
in Figure 6. It can be clearly observed that the singular
values corresponding to PN decay more slowly than those
of LN. Intuitively, one explanation for this might be that
PN helps by normalizing all the tokens across the batch
dimension, which can result in a more equally distributed
embeddings. This may illustrate one of the reasons why PN
outperforms LN.
0
200
400
600
800
1000
The Index of Sigular Value
0.0
0.2
0.4
0.6
0.8
1.0
Normalized Singular Value
PN
LN
Figure 6. Singular values of embedding matrix trained with
LN/PN on WMT14. We normalize the singular values of each
matrix so that they are comparable with the largest one as 1. Note
that the singular values corresponding to PN decay more slowly
than those of LN.
6. Conclusion
In this work, we systematically analyze the ineffectiveness
of vanilla batch normalization (BN) in transformers. Com-
paring NLP and CV, we show evidence that the batch statis-
tics in transformers on NLP tasks have larger variations.
This further leads to the poor performance of BN in trans-
formers. By decoupling the variations into FP and BP com-
putation, we propose PN-V and PN to alleviate the vari-
ance issue of BN in NLP. We also show the advantages of
PN-V and PN, both theoretically and empirically. Theoreti-
cally, PN-V preserves the ﬁrst-order smoothness property
as in BN. The approximate backpropagation of PN leads to
bounded gradients. Empirically, we show that PN outper-
forms LN in neural machine translation (0.4/0.6 BLEU on

PowerNorm: Rethinking Batch Normalization in Transformers
IWSLT14/WMT14) and language modeling (5.6/3.0 PPL
on PTB/WikiText-103) by a large margin. We also conduct
further analysis of the effect of PN-V/PN/BN/LN under
different batch size settings to show the signiﬁcance of sta-
tistical estimations, and we investigate the representation
power of learned embeddings matrix by LN/PN to illustrate
the effectiveness of PN.
Acknowledgments
This work was supported by funds from Intel and Samsung.
We are grateful to support from Google Cloud, Google
TFTC team, as well as support from the Amazon AWS.
We would like to acknowledge ARO, DARPA, NSF, and
ONR for providing partial support of this work. We are also
grateful to Zhuohan Li, Zhen Dong, Yang Liu, the members
of Berkeley NLP, and the members of the Berkeley RISE
Lab for their valuable feedback.
References
Ba, J. L., Kiros, J. R., and Hinton, G. E. Layer normalization.
arXiv preprint arXiv:1607.06450, 2016.
Baevski, A. and Auli, M. Adaptive input representations for
neural language modeling. In ICLR, 2019.
Cooijmans, T., Ballas, N., Laurent, C., G¨ulc¸ehre, C¸ ., and
Courville, A. Recurrent batch normalization. In ICLR,
2017.
Dai, Z., Yang, Z., Yang, Y., Carbonell, J. G., Le, Q., and
Salakhutdinov, R. Transformer-xl: Attentive language
models beyond a ﬁxed-length context. In ACL, 2019.
Devlin, J., Chang, M.-W., Lee, K., and Toutanova, K. Bert:
Pre-training of deep bidirectional transformers for lan-
guage understanding. In NAACL, 2019.
Fan, A., Grave, E., and Joulin, A. Reducing transformer
depth on demand with structured dropout. In ICLR, 2020.
Gao, J., He, D., Tan, X., Qin, T., Wang, L., and Liu, T.
Representation degeneration problem in training natural
language generation models. In ICLR, 2019.
Goldberger, J., Hinton, G. E., Roweis, S. T., and Salakhut-
dinov, R. R. Neighbourhood components analysis. In
NeurIPS, 2005.
He, K., Zhang, X., Ren, S., and Sun, J. Deep residual
learning for image recognition. In CVPR, 2016.
Hochreiter, S. and Schmidhuber, J. Long short-term memory.
Neural computation, 1997.
Hou, L., Zhu, J., Kwok, J., Gao, F., Qin, T., and Liu, T.-
y. Normalization helps training of quantized lstm. In
NeurIPS, 2019.
Huang, G., Liu, Z., Van Der Maaten, L., and Weinberger,
K. Q. Densely connected convolutional networks. In
CVPR, 2017.
Inan, H., Khosravi, K., and Socher, R. Tying word vectors
and word classiﬁers: A loss framework for language
modeling. In ICLR, 2017.
Ioffe, S. Batch renormalization: Towards reducing mini-
batch dependence in batch-normalized models.
In
NeurIPS, 2017.
Ioffe, S. and Szegedy, C. Batch normalization: Accelerating
deep network training by reducing internal covariate shift.
In ICML, 2015.
Jarrett, K., Kavukcuoglu, K., Ranzato, M., and LeCun, Y.
What is the best multi-stage architecture for object recog-
nition? In ICCV, 2009.
Krizhevsky, A., Sutskever, I., and Hinton, G. E. Imagenet
classiﬁcation with deep convolutional neural networks.
In NeurIPS, 2012.
Li, B., Wu, F., Weinberger, K. Q., and Belongie, S. Posi-
tional normalization. In NeurIPS, 2019.
Lin, T.-Y., Goyal, P., Girshick, R., He, K., and Doll´ar, P.
Focal loss for dense object detection. In ICCV, 2017.
Liu, Y., Ott, M., Goyal, N., Du, J., Joshi, M., Chen, D.,
Levy, O., Lewis, M., Zettlemoyer, L., and Stoyanov, V.
Roberta: A robustly optimized bert pretraining approach.
arXiv preprint arXiv:1907.11692, 2019.
Ma, X., Zhang, P., Zhang, S., Duan, N., Hou, Y., Zhou,
M., and Song, D. A tensorized transformer for language
modeling. In NeurIPS, 2019.
Merity, S., Xiong, C., Bradbury, J., and Socher, R. Pointer
sentinel mixture models. In ICLR, 2017.
Mikolov, T., Deoras, A., Kombrink, S., Burget, L., and
ˇCernock`y, J. Empirical evaluation and combination of
advanced language modeling techniques.
In INTER-
SPEECH, 2011.
Miyato, T., Kataoka, T., Koyama, M., and Yoshida, Y. Spec-
tral normalization for generative adversarial networks. In
ICLR, 2018.
Nguyen, T. Q. and Salazar, J. Transformers without tears:
Improving the normalization of self-attention.
arXiv
preprint arXiv:1910.05895, 2019.
Ott, M., Edunov, S., Grangier, D., and Auli, M. Scaling neu-
ral machine translation. In Machine Translation, 2018.

PowerNorm: Rethinking Batch Normalization in Transformers
Ott, M., Edunov, S., Baevski, A., Fan, A., Gross, S., Ng,
N., Grangier, D., and Auli, M. fairseq: A fast, extensible
toolkit for sequence modeling. In NAACL: Demonstra-
tions, 2019.
Papineni, K., Roukos, S., Ward, T., and Zhu, W.-J. Bleu: a
method for automatic evaluation of machine translation.
In ACL, 2002.
Qiao, S., Wang, H., Liu, C., Shen, W., and Yuille, A. Weight
standardization. arXiv preprint arXiv:1903.10520, 2019.
Rahimi, A. Nuerips 2017 test-of-time award presentation,
December 2017.
Salimans, T. and Kingma, D. P. Weight normalization: A
simple reparameterization to accelerate training of deep
neural networks. In NeurIPS, 2016.
Sandler, M., Howard, A., Zhu, M., Zhmoginov, A., and
Chen, L.-C. Mobilenetv2: Inverted residuals and linear
bottlenecks. In CVPR, 2018.
Santurkar, S., Tsipras, D., Ilyas, A., and Madry, A. How
does batch normalization help optimization? In NeurIPS,
2018.
Sennrich, R., Haddow, B., and Birch, A. Neural machine
translation of rare words with subword units. In ACL,
2016.
Singh, S. and Shrivastava, A. Evalnorm: Estimating batch
normalization statistics for evaluation. In ICCV, 2019.
Ulyanov, D., Vedaldi, A., and Lempitsky, V. Instance nor-
malization: The missing ingredient for fast stylization.
arXiv preprint arXiv:1607.08022, 2016.
Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones,
L., Gomez, A. N., Kaiser, Ł., and Polosukhin, I. Attention
is all you need. In NeurIPS, 2017.
Wang, L., Huang, J., Huang, K., Hu, Z., Wang, G., and Gu,
Q. Improving neural language generation with spectrum
control. In ICLR, 2020.
Wang, Q., Li, B., Xiao, T., Zhu, J., Li, C., Wong, D. F.,
and Chao, L. S. Learning deep transformer models for
machine translation. In ACL, 2019.
Wu, F., Fan, A., Baevski, A., Dauphin, Y., and Auli, M. Pay
less attention with lightweight and dynamic convolutions.
In ICLR, 2019.
Wu, Y. and He, K. Group normalization. In ECCV, 2018.
Xu, J., Sun, X., Zhang, Z., Zhao, G., and Lin, J. Under-
standing and improving layer normalization. In NeurIPS,
2019.
Yan, J., Wan, R., Zhang, X., Zhang, W., Wei, Y., and Sun, J.
Towards stabilizing batch statistics in backward propaga-
tion of batch normalization. In ICLR, 2020.
Yang, Z., Dai, Z., Salakhutdinov, R., and Cohen, W. W.
Breaking the softmax bottleneck: A high-rank rnn lan-
guage model. In ICLR, 2018.
Yao, Z., Gholami, A., Keutzer, K., and Mahoney, M. W. Py-
Hessian: Neural networks through the lens of the Hessian.
arXiv preprint arXiv:1912.07145, 2019.
Zagoruyko, S. and Komodakis, N. Wide residual networks.
arXiv preprint arXiv:1605.07146, 2016.
Zhang, B. and Sennrich, R. Root mean square layer normal-
ization. In NeurIPS, 2019.
Zhang, B., Titov, I., and Sennrich, R.
Improving deep
transformer with depth-scaled initialization and merged
attention. In EMNLP, 2019a.
Zhang, H., Dauphin, Y. N., and Ma, T. Residual learning
without normalization via better initialization. In ICLR,
2019b.

PowerNorm: Rethinking Batch Normalization in Transformers
A. Training Details
A.1. Machine Translation.
Dataset
The training/validation/test sets for the IWSLT14 dataset contain about 153K/7K/7K sentence pairs, respectively.
We use a vocabulary of 10K tokens based on a joint source and target byte pair encoding (BPE) (Sennrich et al., 2016). For
the WMT14 dataset, we follow the setup of (Vaswani et al., 2017), which contains 4.5M training parallel sentence pairs.
Newstest2014 is used as the test set, and Newstest2013 is used as the validation set. The 37K vocabulary for WMT14 is
based on a joint source and target BPE factorization.
Hyperparameter
Given the unstable gradient issues of decoders in NMT (Zhang et al., 2019a), we only change all the
normalization layers in the 6 encoder layers from LN to BN/PN, and we keep all the 6 decoder layers to use LN. For
TransformerPN-V big and TransformerBN big (not TransformerPN big), we use the synchronized version, where each
FP and BP will synchronize the mean/variance/quadratic mean of different batches at different nodes. For PN, we set the
α in the forward and backward steps differently, and we tune the best setting over 0.9/0.95/0.99 on the validation set. To
control the scale of the activation, we also involve a layer-scale layer (Zhang & Sennrich, 2019) in each model setting before
the normalization layer. The warmup scheme for accumulating ψ is also employed, as suggested in (Yan et al., 2020) .
Speciﬁcally, we do not tune the warmup steps, but we set it identical to the warmup steps for the learning rate schedule in
the optimizer (Vaswani et al., 2017). We set dropout as 0.3/0.0 for Transformer big/small model, respectively. We use
the Adam optimizer and follow the optimizer setting and learning rate schedule in (Wang et al., 2019). We set the maximum
number of updates following (Ott et al., 2018) to be 300k for WMT and 100k for IWSLT. We used early stopping to stop
the experiments by showing no improvement over the last 10/5 epochs. For the big model, we enlarge the batch size and
learning rate, as suggested in (Ott et al., 2019), to accelerate training. We employ label smoothing of value ϵls “ 0.1 in all
experiments. We implement our code for MT using fairseq-py (Ott et al., 2019).
Evaluation
We use BLEU4 (Papineni et al., 2002) as the evaluation metric for MT. Following standard practice, we
measure tokenized case-sensitive BLEU and case-insensitive BLEU for WMT14 En-De and IWSLT14 De-En, respectively.
For a fair comparison, we do not include other external datasets. For inference, we average the last 10 checkpoints, and we
set the length penalty to 0.6/1.0 and beam size to 4/5 for WMT/IWSLT, following (Ott et al., 2019).
A.2. Language Modeling.
Dataset
PTB (Mikolov et al., 2011) has 0.93M training tokens, 0.073M validation words, and 0.082M test word. Wikitext-
103 (Merity et al., 2017) contains 0.27M unique tokens, and 100M training tokens from 28K articles, with an average length
of 3.6K tokens per article. We use the same evaluation scheme that was provided in (Dai et al., 2019).
Hyperparameter
We use three layers tensorized transformer core-1 for PTB and six layers tensorized transformer core-1
for Wikitext-103, following (Ma et al., 2019). This means there exists only one linear projection in multi-linear attention.
We replace every LN layer with a PN layer. For PN, we set the α in forward and backward differently, and we tune the best
setting over 0.9/0.95/0.99 on the validation set. The warmup scheme and layer-scale are also the same as the hyperparameter
setting introduced for machine translation. We set the dropout as 0.3 in all the datasets. The model is trained using 30
epochs for both PTB and WikiText-103. We use the Adam optimizer, and we follow the learning rate setting in (Ma et al.,
2019). We set the warmup steps to be 4000 and label smoothing to be ϵls “ 0.1 in all experiments.
B. Extra Results
B.1. Empirical Results for Lemma 2.
Under Assumption 9, mentioned in Section 4.1 and discussed in Appendix C.1, we show
} BL
BX:,i
}2 “
γ2
i
pψBq2
i
`
} B pL
BX:,i
}2 ´ x B pL
BX:,i
,
x
X:,i
?
B
y2˘
.
Given that x
B p
L
BX:,i ,
x
X:,i
?
B y2 is non-negative, the Lipschitz constant of L is smaller than that of pL if γi ď pψBqi. Here, we
4https://github.com/moses-smt/mosesdecoder/blob/master/scripts/generic/multi-bleu.perl

PowerNorm: Rethinking Batch Normalization in Transformers
report the empirical results to show that γi ď pψBqi holds for each i P t1, 2, ..., du on IWSLT14; see Figure 7. Observe
that the Lipschitz constant of L is smaller than that of pL empirically in our setting.
Layer 1
Layer 2
Layer 3
Layer 4
Layer 5
Layer 6
0.0
0.2
0.4
0.6
0.8
1.0
B
=
B
Figure 7. The empirical results of the distribution of
γ
pψBq P Rd in different layers of TransformerPN-V on IWSLT14. Given that
γi ď pψBqi holds for each i P t1, 2, ..., du, Lemma 2 holds as well.
B.2. Validation Results on Language Modeling.
Model
PTB
WikiText-103
Val PPL
Test PPL
Val PPL
Test PPL
Tied-LSTM (Inan et al., 2017)
75.7
48.7
–
48.7
AWD-LSTM-MoS (Yang et al., 2018)
58.1
56.0
29.0
29.2
Adaptive Input (Baevski & Auli, 2019)
59.1
57.0
19.8
20.5
Transformer-XLbase (Dai et al., 2019)
56.7
54.5
23.1
24.0
Transformer-XLlarge (Dai et al., 2019)
–
–
–
18.3
Tensor-Transformer1core (Ma et al., 2019)
55.4
57.9
23.6
20.9
Tensor-Transformer2core (Ma et al., 2019)
54.3
49.8
19.7
18.9
Tensor-Transformer1core + LN
58.0*
53.2*
22.7*
20.9*
Tensor-Transformer1core + BN
71.7
60.7
28.4
27.2
Tensor-Transformer1core + PN-V
59.7
55.3
23.6
21.3
Tensor-Transformer1core + PN
51.6
47.6
18.3
17.9
Table 3. Additional Validation and Test results with state-of-the-art results on PTB and WikiText-103. ’-’ indicates no reported results in
that setting, ’˚’ indicates that the results are from our own implementation. PN achieves 5.6/3.0 points lower testing PPL on PTB and
WikiTest-103, respectively, as compared to LN.
B.3. More Comparisons.
As shown in B.3, we present more comparison results for different normalization method including Moving Average Batch
Normalizatio (MABN) (Yan et al., 2020), Batch Renormalization (BRN) (Ioffe, 2017), and Group Normalization (GN)
(Wu & He, 2018). We can observe that BRN/MABN/PN-V is better than BN but worse than LN, which suggests the small
batch-size setting (main focus of (Yan et al., 2020; Ioffe, 2017; Wu & He, 2018)) may have similar characteristic of the
setting in NLP, where there exists large variance across batches. Obviously, GN performs the best among the previous
proposed methods given LN can be viewed as the special case of GN (group number as 1). 5 Throughout the comparisons,
5We empirically found that setting group number the same as head number leads to the best performance.

PowerNorm: Rethinking Batch Normalization in Transformers
Model
IWSLT14
PTB
TransformerBN
34.4
60.7
TransformerBRN
34.7
58.3
TransformerMABN
34.9
57.2
TransformerLN
35.5
53.2
TransformerGN
35.7
51.7
TransformerPN-V
35.5
55.3
TransformerPN
35.9
47.6
Table 4. (Left) NMT performance (BLEU) on IWSLT14 De-En. (Right) LM performance (Test PPL) on PTB.
PN still performs the best in the two tasks, which may validate the effectiveness of our method.
C. Theoretical Results
In this section, we discuss the theoretical results on BN and PN. We assume γ and β to be constants for our analysis on BN,
PN-V and PN.
Since the derivative of loss L w.r.t. Y is known as BL
BY , trivially, we will have γ d BL
B |
X “ BL
BY . Also, it is not hard to get the
following fact.
Fact 5. The derivatives of µB and σ2
B w.r.t. xi are
BµB
Bxi
“ 1
B
and
Bσ2
Bxi
“ 2
B pxi ´ µBq.
(14)
We are now ready to show the derivative of L w.r.t. xi under BN.
Lemma 6 (Derivative of L w.r.t. xi in BN). Based on the Fact 5, it holds that
BL
Bxi
“ 1
σB
BL
Bˇxi
´
1
σBB
ÿ
jPB
BL
Bˇxj
p1 ` ˇxjˇxiq.
(15)
Proof. Based on chain rule, we will have
BL
Bxi
“ BL
Bˇxi
Bˇxi
Bxi
`
ÿ
jPB
p BL
Bˇxj
Bˇxj
BµB
BµB
Bxi
` BL
Bˇxj
Bˇxj
BσB
BσB
Bxi
q
“ 1
σB
BL
Bˇxi
`
ÿ
jPB
BL
Bˇxj
p Bˇxj
BµB
1
B ` Bˇxj
Bσ2
B
2
B pxi ´ µBqq
“ 1
σB
BL
Bˇxi
´
1
σBB
ÿ
jPB
BL
Bˇxj
p1 ` xi ´ µB
σB
xj ´ µB
σB
q
“ 1
σB
BL
Bˇxi
´
1
σBB
ÿ
jPB
BL
Bˇxj
p1 ` ˇxjˇxiq.
(16)
Replacing BL
B |
X by γ d BL
BY , we can get Eq. 3.
In the following, we will ﬁrst discuss the theoretical properties of PN-V in Appendix C.1; and then we discuss how to use
running statistics in the forward propagation and how to modify the corresponding backward propagation in Appendix C.2.
C.1. Proof of PN-V
Before showing the gradient of L w.r.t. xi under PN-V, we note the following fact, which is not hard to establish.

PowerNorm: Rethinking Batch Normalization in Transformers
Fact 7. The derivatives of ψB w.r.t. xi are,
BψB
2
Bxi
“ 2
B xi.
(17)
With the help of Fact 7, we can prove the following lemma
Lemma 8 (Derivative of L w.r.t. xi in PN-V). Based on the Fact 7, it holds that that
BL
Bxi
“
1
ψB
BL
Bˆxi
´
1
BψB
ÿ
jPB
BL
Bˆxj
ˆxjˆxi.
(18)
Proof. Based on chain rule, we will have
BL
Bxi
“ BL
Bˆxi
Bˆxi
Bxi
`
ÿ
jPB
BL
Bˆxj
Bˆxj
BψB
2
BψB
2
Bxi
“ BL
Bˆxi
Bˆxi
Bxi
`
ÿ
jPB
BL
Bˆxj
p´1
2
xj
ψB
3 q2xi
B
“
1
ψB
BL
Bˆxi
´
1
BψB
ÿ
jPB
BL
Bˆxj
ˆxjˆxi.
(19)
Replacing BL
B x
X by γ d BL
BY , we can get Eq. 6.
In order to show the effect of PN-V on the Lipschitz constant of the loss, we make the following standard assumption, as
in (Santurkar et al., 2018).
Assumption 9. Denote the loss of the non-normalized neural network, which has the same architecture as the PN-V
normalized neural network, as pL. We assume that
BL
Byi
“ B pL
Bxi
,
(20)
where yi is the i-th row of Y .
Based on these results, we have the following proof of Lemma 2, which was stated in Section 4.
Proof of Lemma 2. Since all the computational operator of the derivative is element-wise, here we consider d “ 1 for
notational simplicity6. When d “ 1, Lemma 8 can be written as
BL
Bxi
“
1
ψB
BL
Bˆxi
´
1
BψB
x BL
Bx
X
, x
Xyˆxi.
(21)
Therefore, we have
BL
BX “
1
ψB
BL
Bx
X
´
1
BψB
x BL
Bx
X
, x
Xyx
X.
(22)
Since
}x
X}2 “
ř
iPB ˆxi
1
B
ř
iPB ˆxi
“ B,
(23)
6For d ě 2, we just need to separate the entry and prove them individually.

PowerNorm: Rethinking Batch Normalization in Transformers
the following equation can be obtained
} BL
BX }2 “
1
ψB
2 } BL
Bx
X
´ x BL
Bx
X
,
x
X
?
B
y
x
X
?
B
}2
“
1
ψB
2
`
} BL
Bx
X
}2 ´ 2x BL
Bx
X
, x BL
Bx
X
,
x
X
?
B
y
x
X
?
B
y ` }x BL
Bx
X
,
x
X
?
B
y
x
X
?
B
y}2˘
“
1
ψB
2
`
} BL
Bx
X
}2 ´ x BL
Bx
X
,
x
X
?
B
y2˘
“ γ2
ψB
2
`
} BL
BY }2 ´ x BL
BY ,
x
X
?
B
y2˘
“ γ2
ψB
2
`
} B pL
BX }2 ´ x B pL
BX ,
x
X
?
B
y2˘
.
(24)
C.2. Proof of PN
In order to prove that after the replacement of
BL
BpXptqq with Eq. 12, the gradient of the input is bounded, we need the
following assumptions.
Assumption 10. We assume that
}ˆxi} ď C1 and } BL
Bˆxi
} ď C2,
(25)
for all input datum point and all iterations. We also assume that the exponentially decaying average of each element of ˆxi is
bounded away from zero,
p1 ´ αq
tÿ
j“0
αt´jˆxiˆxi ą C3 ą 0, @t,
(26)
where we denote α as the decay factor for the backward pass. In addition, we assume that α satisﬁes
pC1q2 ă
1
1 ´ α.
(27)
W.l.o.g., we further assume that every entry of ψptq is bounded below, i.e.
C0 ă ψptq,
@t.
(28)
If we can prove or νptq is bounded by some constant C4 (the ofﬁcial proof is in Lemma 11), then it is obvious to prove the
each datum point of Ă
X1 is bounded.
Based on these results, we have the following proof of Theorem 4, which was stated in Section 4.

PowerNorm: Rethinking Batch Normalization in Transformers
Proof of Theorem 4. It is easy to see that
}Ă
X1
i,:}2 “ } BL
Bˆxptq
i
´ νpt´1qˆxptq
i }2
“ x BL
Bˆxptq
i
´ νpt´1qˆxptq
i , BL
Bˆxptq
i
´ νpt´1qˆxptq
i y
“ } BL
Bˆxptq
i
}2 ` }νpt´1qˆxptq
i }2 ´ 2x BL
Bˆxptq
i
, νpt´1qˆxptq
i y
ď } BL
Bˆxptq
i
}2 ` }νpt´1q}2}ˆxptq
i }2 ´ 2x BL
Bˆxptq
i
, νpt´1qˆxptq
i y
ď } BL
Bˆxptq
i
}2 ` }νpt´1q}2}ˆxptq
i }2 ` 2} BL
Bˆxptq
i
}}νpt´1qˆxptq
i }
ď } BL
Bˆxptq
i
}2 ` }νpt´1q}2}ˆxptq
i }2 ` 2} BL
Bˆxptq
i
}}νpt´1q}}ˆxptq
i }
ď pC2q2 ` pC1q2pC4q3 ` C1C2C4
All these inequalities come from Cauchy-Schwarz inequity and the fact that
pa1b1q2 ` ... ` padbdq2 ď pa2
1 ` ... ` a2
dqpb2
1 ` ... ` b2
dq.
In the ﬁnal step of Theorem 4, we directly use that νptq is uniformly bounded (each element of νptq is bounded) by C4. The
exact proof is shown in below.
Lemma 11. Under Assumption 10, νptq is uniformly bounded.
Proof. For simplicity, denote BL
Bˆxi as ˆx1
i. It is not hard to see,
}Γptq}2 “ 1
B2 }
B
ÿ
i“1
ˆxptq
i ˆxptq
i }2
“ 1
B2 x
B
ÿ
i“1
ˆxptq
i ˆxptq
i ,
B
ÿ
i“1
ˆxptq
i ˆxptq
i y
ď 1
B2 pB2 max
j txˆxptq
j ˆxptq
j , ˆxptq
i ˆxptq
i yuq
ď pC1q2.
Similarly, we will have }Λptq} ď C1C2 as well as p1 ´ αq řt
j“0 αt´jΓpjqΓpjq ą C3. We have
νptq “ p1 ´ p1 ´ αqΓptqqνpt´1q ` p1 ´ αqΛptq
“ p1 ´ p1 ´ αqΓptqqpp1 ´ p1 ´ αqΓpt´1qqνpt´2q ` p1 ´ αqΛpt´1qq ` p1 ´ αqΛptq
...
“ p1 ´ αq
tÿ
j“0
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq.
Then,
1
p1 ´ αq2 }νptq}2 “x
tÿ
j“0
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq,
tÿ
j“0
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jqy.

PowerNorm: Rethinking Batch Normalization in Transformers
Notice that with the deﬁnition,
Γpmq “ 1
B
B
ÿ
i“1
ˆxpmq
i
ˆxpmq
i
,
(29)
we will have that all entries of Γpmq are positive, for m P t0, 1, ..., tu. It is clear that when all entries of Λpmq, for
m P t0, 1, ..., tu, have the same sign (positive or negative), the above equation achieves its upper bound. W.l.o.g., we assume
they are all positive.
Since 0 ă α ă 1, it is easy to see that, when K “ rplogp p1´αqC3
2C1C1 q{ logpαqqs, then the following inequality holds,
p1 ´ αq
8
ÿ
j“K
αj ă
C3
2C1C1
.
(30)
Since }Γpkq} ď C1, the value of any entry of Γpkq is also bounded by C1. Therefore, based on this and Eq. 30, when t ą K,
we will have
p1 ´ αq
tÿ
k“t´K`1
αt´k ΓpkqΓpkq “ p1 ´ αq
tÿ
k“0
αt´k ΓpkqΓpkq ´ p1 ´ αq
t´K
ÿ
k“0
αt´k ΓpkqΓpkq
ą C3⃗1 ´ p1 ´ αq
t´K
ÿ
k“0
αt´k }Γpkq}}Γpkq}
ą C3⃗1 ´ p1 ´ αqC1C1⃗1
t´K
ÿ
k“0
αt´k
“ C3⃗1 ´ p1 ´ αqC1C1⃗1
tÿ
k“K
αk
ą C3⃗1 ´ p1 ´ αqC1C1⃗1
8
ÿ
k“K
αk
ą C3⃗1 ´ C3⃗1
2
“ C3⃗1
2 ,
(31)
where ⃗1 is the unit vector. Then, for t ą K, we can bound from below the arithmetic average of the K corresponding items
of Γ,
pC1q2 ą 1
K
K´1
ÿ
k“0
Γpt´kqΓpt´kq ą
1
αK´1
K´1
ÿ
k“0
αkΓpt´kqΓpt´kq
“
1
αK´1
tÿ
k“t´K`1
αt´1ΓpkqΓpkq
ą
C3
2p1 ´ αqαK´1 “ C5 ą 0.
(32)
This inequality shows that after the ﬁrst K items, for any K consecutive Γpkq, the average of them will exceeds a constant
number, C5. Therefore, for any t ą T ą K, we will have
1
T ´ K
T ´K
ÿ
k“0
Γpt´kqΓpt´kq ą tT ´ K
K
upK
1
T ´ K qC5 ą C5
2 .
(33)
Let us split řt
j“0
` śj´1
k“0p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq into two parts: (i) řt
j“K
` śj´1
k“0p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq,
and (ii) řK´1
j“0
` śj´1
k“0p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq. From so on, we will discuss how we deal with these two parts
respectively.

PowerNorm: Rethinking Batch Normalization in Transformers
Case 1: řt
j“K
` śj´1
k“0p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq
Notice that for 0 ă aj ă 1, the following inequality can be proven
with simply induction,
k´1
ź
j“0
p1 ´ ajq ď p1 ´ 1
k
k´1
ÿ
j“0
αjqk.
(34)
Replacing aj with p1 ´ αqΓpt´j`1q, we will have
tÿ
j“K
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq ď
tÿ
j“K
`
p1 ´ p1 ´ αq
j
j´1
ÿ
k“0
Γpt´k`1qq
˘jΛpt´jq
ď
tÿ
j“K
`
p1 ´ p1 ´ αqC5
2 q
˘jΛpt´jq
ď
tÿ
j“K
`
p1 ´ p1 ´ αqC5
2 q
˘jC1C2
ď
2
p1 ´ αqC5
C1C2 “ C6.
(35)
Here the second inequality comes from Eq. 33, and the third inequality comes form the the fact each entry of Λpmq is smaller
than C1C2, given }Λpmq} ď C1C2. The ﬁnal inequality comes from Eq. 31, where 0 ă C5 ă pC1q2 ă 1{p1 ´ αq, then we
can have 0 ă
`
1 ´ p1 ´ αqC5{2
˘
ă 1.
Case 2: řK´1
j“0
` śj´1
k“0p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq
It is easy to see
K´1
ÿ
j“0
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq ď
K´1
ÿ
j“0
` j´1
ź
k“0
p⃗1q
˘
Λpt´jq
ď KC1C2.
(36)
Combining Case 1 and 2, we have
1
p1 ´ αq2 }νptq}2 “ x
tÿ
j“0
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jq,
tÿ
j“0
` j´1
ź
k“0
p1 ´ p1 ´ αqΓpt´k`1qq
˘
Λpt´jqy
ď xC6⃗1 ` KC1C2⃗1, C6⃗1 ` KC1C2⃗1y ă C7,
(37)
which indicates }νptq} is bounded and C4 “ p1 ´ αq?C7.

