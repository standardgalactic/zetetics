Author
Tom Peham
k01604054
Submission
Institute for Integrated
Circuits
Thesis Supervisor
Univ.-Prof. Dr. Robert
Wille
Assistant Thesis Supervisor
DI Lukas Burgholzer
February 2022
JOHANNES KEPLER
UNIVERSITY LINZ
Altenbergerstraße 69
4040 Linz, Austria
www.jku.at
DVR 0093696
Equivalence Checking
of Quantum Circuits
with the ZX-Calculus
Master Thesis
to obtain the academic degree of
Diplom-Ingenieur
in the Master’s Program
Computer Science

Statutory Declaration
I hereby declare that the thesis submitted is my own unaided work, that I have not used
other than the sources indicated, and that all direct and indirect sources are acknowledged
as references.
This printed thesis is identical with the electronic version submitted.
Linz, February 2022
February 2022
Tom Peham
i/59

Abstract
As state-of-the-art quantum computers are capable of running increasingly complex
algorithms, the need for automated methods to design and test potential applications
rises. Equivalence checking of quantum circuits is an important, yet hardly automated,
task in the development of the quantum software stack. Recently, new methods have
been proposed that tackle this problem from widely different perspectives. One of them is
based on the ZX-calculus, a graphical rewriting system for quantum computing. However,
the power and capability of this equivalence checking method has barely been explored.
The aim of this work is to evaluate the ZX-calculus as a tool for equivalence checking of
quantum circuits. To this end, it is demonstrated how the ZX-calculus-based approach
to equivalence checking can be expanded in order to verify the results of compilation
flows and optimizations on quantum circuits. It is also shown that the ZX-calculus based
method is not complete — especially for quantum circuits with ancillary qubits. In order
to properly evaluate the proposed method we conduct a detailed case study by comparing
it to a prominent method in equivalence checking based on decision diagrams.
Kurzfassung
Da moderne Quantencomputer in der Lage sind, immer komplexer werdende Algorith-
men auszuführen, steigt der Bedarf an Methoden zum automatisierten Entwurf und
Testen von potentiellen Anwendungen. Die Verifikation von Quantenschaltkreisen ist
eine wichtige, jedoch kaum automatisierte, Aufgabe in der Entwicklung des Quanten-
Software-Stacks. Kürzlich wurden neue Methoden vorgeschlagen, die dieses Problem aus
February 2022
Tom Peham
ii/59

ganz unterschiedlichen Perspektiven angehen. Eine davon basiert auf dem ZX-Kalkül,
einem grafischen Reduktionssystem für Quantencomputer. Die Leistungsfähigkeit und
das Potential dieses Verifikationsverfahrens wurde bisher allerdings kaum erforscht. Ziel
dieser Arbeit ist die Evaluierung des ZX-Kalküls als Methode zur Verifikations von Quan-
tenschaltkreisen. Dazu wird gezeigt, wie der auf dem ZX-Kalkül basierende Ansatz zur
Verifikation erweitert werden kann um die Ergebnisse von Kompilierungsabläufen und
Optimierungen von Quantenschaltkreisen zu verifizieren. Es wird auch gezeigt, dass die
auf dem ZX-Kalkül basierende Methode nicht vollständig ist—insbesondere für Quan-
tenschaltkreise mit Hilfs-Qubits. Um die vorgeschlagene Methode adäquat zu bewerten,
wird eine detaillierte Fallstudie durchgeführt bei der sie mit einem bekannten Äquiva-
lenzprüfungsverfahren, basierend auf Entscheidungsdiagrammen, verglichen wird.
February 2022
Tom Peham
iii/59

Contents
1. Introduction
1
2. Background
4
2.1.
Quantum Computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
2.2.
Quantum Circuit Compilation . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.3.
Quantum Circuit Optimization . . . . . . . . . . . . . . . . . . . . . . . . .
11
3. Equivalence Checking
14
4. Equivalence Checking using the ZX-Calculus
18
4.1.
Background
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
4.2.
Equivalence Checking Graph-like ZX-diagrams
. . . . . . . . . . . . . . .
21
4.3.
Handling Inaccuracies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
4.4.
Handling Permutations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
4.5.
Handling Ancillaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
4.6.
Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
5. Equivalence Checking using Decision Diagrams
34
6. Case Study
38
6.1.
Experimental Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
6.2.
Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
7. Conclusion
46
A. Full Simplification of Clifford ZX-diagram
53
B. Proofs
54
B.1. Proof of Lemma 3.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
B.2. Proof of Equation (4.10)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
B.3. Completeness of Algorithm 2 for Clifford Circuits . . . . . . . . . . . . . .
56
February 2022
Tom Peham
iv/59

List of Figures
2.1.
X, Y and Z bases on the Bloch sphere . . . . . . . . . . . . . . . . . . . . . .
6
2.2.
GHZ state preparation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.3.
Decomposition of the Toffoli gate in Clifford+T . . . . . . . . . . . . . . . .
10
2.4.
Compilation of GHZ state preparation circuit . . . . . . . . . . . . . . . . .
11
2.5.
Decompositions of the multi-controlled Toffoli gate
. . . . . . . . . . . . .
12
4.1.
Axioms of the scalar-free ZX-calculus
. . . . . . . . . . . . . . . . . . . . .
21
4.2.
ZX-diagrams of GHZ state preparation circuits . . . . . . . . . . . . . . . .
22
4.3.
Equivalence checking with the ZX-calculus in the presence of few small errors 30
4.4.
ZX-diagrams of the multi-controlled Toffoli gate . . . . . . . . . . . . . . .
32
4.5.
Counterexample to the completeness of Algorithm 3 . . . . . . . . . . . . .
33
5.1.
Decision diagrams
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
5.2.
Verifying equivalence with decision diagrams
. . . . . . . . . . . . . . . .
36
6.1.
Random benchmark runtimes for differing gate count . . . . . . . . . . . .
43
6.2.
Random benchmark runtimes for differing qubit count . . . . . . . . . . .
44
February 2022
Tom Peham
v/59

List of Tables
6.1.
Slightly optimized reversible circuits
. . . . . . . . . . . . . . . . . . . . .
40
6.2.
Highly optimized reversible circuits . . . . . . . . . . . . . . . . . . . . . .
41
6.3.
Common quantum algorithms
. . . . . . . . . . . . . . . . . . . . . . . . .
42
February 2022
Tom Peham
vi/59

1. Introduction
Quantum computing [1] has had a surge in research endeavors by academia and industry
in the recent years. While quantum computers have not reached a stage of wide-spread
practical usability yet, they promise to outperform classical computers in various im-
portant tasks, such as unstructured search, integer factorization, optimization problems,
the simulation of molecules, and more [2, 3, 4, 5, 6, 5, 7]. To keep pace with the rapid
developments in quantum hardware, various tools have been developed that help in
designing corresponding applications.
Initially, a quantum computation is described as a sequence of (high-level) quantum
gates—somewhat similar to a classical C program. However, just like assembly for a
classical processor, the actual machine instructions that may be performed on a given
quantum processor are generally restricted to a small (low-level) gate-set and might
only allow interactions between specific pairs of qubits. Therefore, in order to execute
a given circuit on quantum hardware, it needs to be compiled to a representation that
adheres to all constraints imposed by the targeted device [8, 9, 10, 11]. Since quantum
computers are heavily affected by noise and decoherence, it is paramount to optimize
circuits as much as possible in order to maximize the expected fidelity when running the
circuit [12, 13, 14, 15, 16].
Since the compiled quantum circuit might be altered drastically from its original high-level
description, it is of utmost importance that the circuit to be executed on the hardware
still implements the same functionality as originally intended. Verification of compilation
results or, more generally, equivalence checking of quantum circuits, turns out to be an
extremely complex, even QMA-complete1 [17], task and is in dire need of automation.
Although, various methods have been proposed [18, 19, 20, 21, 22, 23, 24, 25] that tackle
1QMA is the quantum computing analogue to NP. Indeed, NP is a subset of QMA
February 2022
Tom Peham
1/59

the equivalence checking problem from completely different perspectives, a baseline
indicating which paradigm is suited best for which use-case is yet to be established.
One method for equivalence checking of quantum circuits is based on the ZX-calculus [26,
22, 27, 28], a graphical calculus used for reasoning about quantum computing. While some
results on this equivalence checking method exist [28], it was introduced as more of a
side-note in the original work than a fully-fledged method. At the time of writing, the only
publicly available implementation of this algorithm is written in Python [29]. Therefore it
is difficult to assess the performance of this method due to the inherently slower runtime
of the Python interpreter when compared to a compiled language like C++. This makes it
somewhat difficult to compare the method with other established equivalence checking
algorithms. Furthermore, issues unique to design automation in quantum computing,
like inaccurate representations of complex number, different logical-to-physical qubit
mappings and ancillary qubits, have not been addressed in the ZX-calculus framework.
Apart from practical considerations, theoretical aspects have also hardly been investigated
so far. It is not known for what class of circuits the equivalence checking method based on
the ZX-calculus is complete, i.e., whether it can actually prove the equivalence of any two
equivalent quantum circuits.
Motivated by that, the aim of this work is twofold. Firstly, to establish whether the
ZX-calculus provides a solid equivalence checking methodology, we review the current
state of the art in equivalence checking with the ZX-calculus. To expand on this, we discuss
how this method can be augmented to handle inaccurate representations of complex
numbers arising from compilation and optimization processes, deal with alterations of
the input and output layout of a circuit that happen during compilation, and integrate
ancillary qubits into the equivalence checking procedure. We provide first results on the
completeness of this equivalence checking algorithm. Secondly, in order to empirically
show that the ZX-calculus is a practically relevant method in equivalence checking, we
conduct a detailed case-study to establish a baseline for the current state of the art in
equivalence checking of quantum circuits considering a large range of benchmarks. To this
end, we re-implemented the ZX-calculus based equivalence checking algorithm in C++
and expanded it with the capabilities mentioned above. We compare this implementation
with another state-of-the-art equivalence checking method based on quantum decision
diagrams [30, 25, 31, 32, 33, 34].
February 2022
Tom Peham
2/59

Overall, we show that the ZX-calculus can be adapted to verify the results of compilation
flows effectively and that it performs on par with the decision diagram based method in
many cases. However, both methods have domains where they clearly outperform the
other. Since we show that the ZX-calculus based approach may fail to prove the equiv-
alence of two equivalent quantum circuits, it cannot be used to prove non-equivalence
of quantum circuits—only to give an indication of non-equivalence. All in all, we con-
clude that neither method is clearly better than the other but that they rather serve as
complementary methods to each other that are best used in conjunction.
The remainder of this thesis is structured as follows: Chapter 2 provides the necessary
background and motivates the necessity of equivalence checking routines in quantum
computing. Then, Chapter 3 describes the equivalence checking problem in detail. Based
on that, Chapter 4 recapitulates the theory of the ZX-calculus and explains the state-of-the
art equivalence checking algorithm based on the ZX-calculus in detail and shows how
the method can be expanded to handle more relevant equivalence checking problems in
quantum circuit compilation and optimization. There we also prove that the ZX-calculus
based equivalence checking method is complete for Clifford circuits but not complete in
general—failing to prove the equivalence of a simple example. To set up the case study,
Chapter 5 describes quantum decision diagrams and how they are used in equivalence
checking. The results of the case study are then summarized in Chapter 6. Finally,
Chapter 7 concludes this thesis.
February 2022
Tom Peham
3/59

2. Background
To keep this thesis self contained, the following sections provide a brief overview of
quantum computing and quantum circuit compilation. We refer the interested reader to
the provided references for a more thorough introduction.
2.1. Quantum Computing
In classical computing, information is encoded in classical bits that can be either 0 or 1.
Analogously, in quantum computing, quantum bits (or qubits in short) are used which can
be either in the |0⟩or |1⟩state (in Dirac notation). Contrary to the classical domain, qubits
can also be in a superposition of multiple states. Formally, the state |ϕ⟩of a qubit is written
as
|ϕ⟩= α0 |0⟩+ α1 |1⟩= α0
[︄
1
0
]︄
+ α1
[︄
0
1
]︄
=
[︄
α0
α1
]︄
α0, α1 ∈C, |α0|2 + |α1|2 = 1.
(2.1)
The numbers α0 and α1 are called amplitudes. The squares of these amplitudes are of special
importance as they can be interpreted as probabilites. Observing or measuring a qubit
directly effects the state of the qubit. Measuring a qubit destroys the superposition and
the qubit is changed to be either in the |0⟩or |1⟩state. The number |α0|2 (|α1|2) is the
probability that |ϕ⟩is in state |0⟩(|1⟩) when observed.
There are three orthonormal bases that are of special importance in quantum computing.
Definition 2.1. The Z-, X- and Y-bases are defined as follows:
• Z-basis: |0⟩, |1⟩
February 2022
Tom Peham
4/59

• X-basis: |+⟩:=
1
√
2(|0⟩+ |1⟩), |−⟩:=
1
√
2(|0⟩−|1⟩)
• Y-basis: |R⟩:=
1
√
2(|0⟩+ i |1⟩), |L⟩:=
1
√
2(|0⟩−i |1⟩)
Although a qubit is a two-dimensional complex vector, the restriction that |α0|2 + |α1|2 = 1
makes it possible to visualize a qubit in three-dimensional space. Written in polar form
(with α0 = aeiγ and α1 = beiψ), Equation (2.1) becomes
|ϕ⟩= aeiγ |0⟩+ beiψ |1⟩
a, b, γ, ψ ∈R, a2|e2iγ| + b2|e2iψ| = 1.
(2.2)
Since |e2iθ| = 1 for any θ ∈R the side condition simplifies to a2 + b2 = 1. Therefore, (a, b)
is a point on the unit circle and we can write a = cos θ
2, b = sin θ
2 for some θ ∈R. With
this Equation (2.2) can be simplified to
|ϕ⟩= eiγ(cos θ
2 + ei(ψ−γ) sin θ
2).
(2.3)
In quantum computing, factors such as eiγ in this equation are called global phases and are
negligible because they cannot be physically observed through measurements. Setting
ω = ψ −γ and neglecting the global phase, the qubit can finally be written as
|ϕ⟩= cos θ
2 |0⟩+ eiω sin θ
2 |1⟩.
(2.4)
The numbers θ and ω, interpreted as the azimuthal and polar angles in a spherical
coordinate system, describe a point on the unit sphere in three dimensions. This sphere is
referred to as the Bloch sphere. Figure 2.1 shows the depictions of the Z-, X- and Y-bases
from Definition 2.1. This also explains the naming of these bases, as the two vectors in each
basis are just the intersections of the Bloch sphere with the respective euclidean coordinate
axis.
The change-of-basis matrix converting between the Z- and X-basis is especially important
in quantum computing.
February 2022
Tom Peham
5/59

Figure 2.1.: X, Y and Z bases on the Bloch sphere
Definition 2.2. The Hadamard transform is defined by the matrix H =
1
√
2
[︄
1
1
1
−1
]︄
.
The Hadamard transform maps between Z-basis states and X-basis states, i.e.,
H |0⟩=
1
√
2 |0⟩+ 1
√
2 |1⟩=: |+⟩and
H |1⟩=
1
√
2 |0⟩−1
√
2 |1⟩=: |−⟩.
The basis states of multi-qubit systems are obtained as the tensor product of single
qubit states.
So a basis state of a 3-qubit system would for example be written as
|1⟩⊗|1⟩⊗|0⟩= |110⟩=: |6⟩. In general, an n-qubit state |ϕ⟩is described by a linear
combination of basis states, i.e.,
2n−1
∑
i=0
αi |i⟩with
2n−1
∑
i=0
|αi|2 = 1 and αi ∈C.
February 2022
Tom Peham
6/59

Not every state of n qubits can be factored into a tensor product of single-qubit basis-states.
The Bell states are an example of this, e.g., the first Bell state Φ+ =
1
√
2(|00⟩+ |11⟩) cannot
be factored. This property is called entanglement. Entanglement and superposition are key
factors that make quantum computing such a promising technology.
Any operation manipulating the state of a quantum system must again yield a valid
quantum state. As a consequence, any such operation U must be unitary, i.e., it must obey
the equation UU† = U†U = I where U† is the conjugate transpose of U and I is the identity
transformation.
Example 2.1. The Hadamard transform is a unitary transformation because
HH† = 1
2
[︄
1
1
1
−1
]︄[︄
1
1
1
−1
]︄
=
[︄
1
0
0
1
]︄
= I.
An important unitary acting on two qubits is the controlled Not or CNOT gate. It is defined by
the matrix
[︃1 0 0 0
0 1 0 0
0 0 0 1
0 0 1 0
]︃
and flips the second qubit (the target) when the first qubit (the control) is in
state |1⟩.
The Hadamard gate and the CNOT gate can be used to create a Bell state. To achieve this,
two qubits q0 and q1 are prepared in the |0⟩state. Therefore, the system is initially in the
state |00⟩. After applying the Hadamard gate to q0 (and the identity I to q1), the system is in
the state
1
√
2(|00⟩+ |10⟩). The matrix that maps |00⟩to this state is obtained by computing the
tensor product of the matrices acting on the individual qubits: H ⊗I =
1
√
2
[︃1 0 1 0
0 1 0 1
1 0 -1 0
0 1 0 -1
]︃
. Finally,
performing a CNOT gate with control qo and target q1 produces the state
1
√
2(|00⟩+ |11⟩). The
matrix that prepares the Bell state is obtained by multiplying the matrices and performing the
appropriate tensor products: CNOT ·(H ⊗I) =
1
√
2
[︃1 0 1 0
0 1 0 1
0 1 0 -1
1 0 -1 0
]︃
.
A quantum computation is a unitary transformation acting on some initial state (usually
the qubits are all prepared to be in the |0⟩state). Instead of writing the system matrix (i.e.,
the unitary describing the behaviour of the whole circuit) explicitly, a common way to
describe the unitary evolution of a quantum system is through quantum circuit notation [1].
There, qubits are represented by wires and operations (called gates) are annotated as boxes
and circles on the wires. The evolution of the initial state is read from left to right. Thus, a
February 2022
Tom Peham
7/59

q2 : |0⟩
c2
q1 : |0⟩
c1
q0 : |0⟩
H
•
•
c0
(a) GHZ state preparation circuit G
1
√
2
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
1
1
1
1
1
1
1
1
1
-1
1
-1
1
-1
1
-1
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
(b) System matrix U of G
Figure 2.2.: GHZ state preparation
quantum circuit G is described as a sequence of gates g0 . . . gm−1 with m ∈N. Due to their
unitary nature, quantum circuits are inherently reversible. More specifically, the inverse
of a quantum circuit G = g0 . . . gm−1 is obtained by inverting each gate and reversing the
order of operations, i.e., G† = g†
m−1 . . . g†
0.
Example 2.2. The circuit G in Fig. 2.2a represents a 3-qubit system. The box annotated with H is
a Hadamard transform on qubit q0 and the connected circles and dots are CNOT gates with q0 as
control and q1 and q2 as target qubit, respectively. The circuit maps |000⟩to
1
√
2 |000⟩+
1
√
2 |111⟩,
the well-known GHZ state [35]. The system matrix describing the unitary this circuit realizes is
given in Fig. 2.2b.
Contrary to the classical domain, these circuits should not be thought of as representing
electrical circuits in any shape or form. The sequence of gates should be thought of
as operations applied over time to the state of the qubits. On actual hardware, like a
superconducting quantum computer, the qubits are fixed in place [36, 37]. How the gates
are realized depends on the architecture in question. In the case of superconducting qubits,
all operations are performed by electromagnetic pulses.
Because of this limitation it is important to know what operations are actually needed to
produce arbitrary unitaries. An important class of circuits are the so-called Pauli gates.
Definition 2.3. The Pauli gates are defined as follows:
X :=
[︄
0
1
1
0
]︄
Y :=
[︄
0
−i
i
0
]︄
Z :=
[︄
1
0
0
−1
]︄
February 2022
Tom Peham
8/59

Pauli gates pop up all the time in quantum computing and quantum information theory.
They are also part of another important gate-set.
Definition 2.4. The Clifford group is the group generated by the gates {H, CNOT, S} (where
S =
[︂
1
0
0 ei π
2
]︂
) together with the group operation of matrix multiplication. Quantum circuits
composed entirely of Clifford gates are called Clifford circuits or Stabilizer circuits.
Clifford circuits can be efficiently simulated on a classical computer, a result known as
the Gottesman-Knill Theorem [38]. It is therefore not surprising that Clifford circuits are
not sufficient for general quantum computing. As an example for a unitary that is not
included in the Clifford group take the T gate (where T =
[︂
1
0
0 ei π
4
]︂
). Nevertheless, Stabilizer
circuits play an important role in error correction [39, 40].
The T gate and the list of generators for the Clifford group together form a universal gate-
set, meaning any unitary can be approximated by this gate-set to an arbitrary degree.
Another important universal gate-set is composed of arbitrary rotations around the
bloch sphere, RX(θ) :=
[︃
cos θ
2
-i sin θ
2
-i sin θ
2
cos θ
2
]︃
, RY(θ) :=
[︃
cos θ
2 - sin θ
2
- sin θ
2 cos θ
2
]︃
, RZ(θ) :=
[︃
cos -i θ
2
0
0
cos i θ
2
]︃
,
the CNOT gate and the phase shift gate P(φ) =
[︂
1 0
0 eiφ
]︂
.
Another important class of circuits are the reversible circuits. These are circuits that imple-
ment bijective mappings between (multi-qubit) Z-basis states. Because of this their system
matrices are simply permutation matrices. The last gate we want to introduce in this section
is the Toffoli, Controlled-CNOT or CCNOT gate. It is a three qubit gate with the following
matrix
TOFF =
⎡
⎢⎢⎣
1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0
⎤
⎥⎥⎦.
As the name Controlled-CNOT suggests, this gate performs a NOT (or Pauli X) operation
if both of the control qubits are in the |1⟩state. This is a particularly important gate in the
domain of reversible computing where it constitutes a universal gate, i.e. any reversible
circuit can be composed entirely of Toffoli gates [41]. Together with the Hadamard gate
it also forms a universal gate-set for quantum computing [42]. Its more relevant use in
quantum computing is in the construction of classical oracles that appear in, for example,
Grover’s search and Shor’s algorithm [2, 3].
February 2022
Tom Peham
9/59

q2 :
•
•
•
T
•
q1 :
•
•
T
T†
q0 :
H
T†
T
T†
T
H
Figure 2.3.: Decomposition of the Toffoli gate in Clifford+T
2.2. Quantum Circuit Compilation
Quantum algorithms are typically designed at a rather high abstraction level without
considering specific hardware restrictions. In order to execute a conceptual quantum
algorithm on an actual device, it has to be compiled to a representation that conforms to
all restrictions imposed by the targeted device. Since quantum computers typically only
support a limited gate-set, every high-level operation has to be decomposed into that gate-
set [43, 44, 45]. This can sometimes significantly increase the size of the circuit. Figure 2.3
shows an examplary decomposition of the Toffoli gate in the Clifford+T gate-set.
In addition, many architectures (such as those based on superconducting qubits) restrict
the pairs of qubits that operations may be applied to. Hence, it is necessary to map the de-
composed circuit to the device such that it adheres to the device’s coupling constraints [46,
47, 48]. In general, this is accomplished by establishing a mapping between the circuit’s
logical qubits and the device’s physical qubits. Since it is generally not possible to deter-
mine a conforming mapping in a static fashion, SWAP gates are inserted into the circuit
that allow to dynamically change the logical-to-physical qubit mapping over the course of
the compilation.
Example 2.3. Consider again the GHZ preparation circuit shown in Figure 2.2a and assume
it shall be mapped to the 5-qubit, linear architecture shown on the left-hand side of Figure 2.4.
Assume that, initially, logical qubit qi is mapped to physical qubit Qi for 0 ≤i ≤2. Then, the first
two operations can be directly applied, while the last operation cannot—due to the fact that Q0 and
Q2 are not directly connected on the architecture. Hence, a SWAP operation between Q2 and Q1 is
introduced, which allows to execute the final gate. At the end of the circuit q0 is measured on Q0,
q1 on Q2 and q2 on Q1.
February 2022
Tom Peham
10/59

Q0
Q1
Q2
Q3
Q4
q0 ↦→
q1 ↦→
q2 ↦→
c0
c2
c1
Initial layout
SWAP decomposition
Output permutation
Architecture
×
×
H
•
•
•
•
•
Figure 2.4.: Compilation of GHZ state preparation circuit
2.3. Quantum Circuit Optimization
Through decomposition and mapping, even small quantum circuits can significantly
increase in size. In classical computing circuits are usually optimized in order to require
less space, time or energy. While time is still an important factor in quantum computing,
this is because of a different reason. The coherence time of a quantum mechanical system
is the time for which the system remains quantum-mechanically coherent [1]. When this
time is exceeded, the system collapses into some basis state and is therefore no longer in
superposition and qubits are not entangled anymore. The decoherence time essentially
puts a limit on the maximum number of operations that can be performed on a quantum
system before it collapses.
Another factor unique to quantum computing is the gate error rate. Gates are difficult to
realize precisely in practice. Every operation performed on qubits potentially introduces
some error. This is often quantified using the fidelity F, which measures the distance
between two quantum states. The gate fidelity [1] is then a measure of the fidelity of the
quantum state after applying a noisy gate compared to the quantum state if an ideal
(noiseless) gate was applied. The higher the gate fidelity, the better the implementation of
the gate. Some gates are easier to realize then others. On superconducting architectures,
CNOT error is the dominating error factor. At the time of writing, for example, the single-
qubit Pauli-X error on the IBMQ Montreal quantum computer was 2.003 × 10−4 on the
physical qubit Q0 compared to the CNOT error between qubit Q0 and Q1 of 2.276 × 10−3.
February 2022
Tom Peham
11/59

· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
· · ·
q3 :
RZ ( π
8 )
•
•
•
•
q2 :
RZ ( π
8 )
RZ (−π
8 )
•
•
•
q1 :
RZ ( π
8 )
RZ (−π
8 )
RZ ( π
8 )
RZ (−π
8 )
•
q0 :
H
RZ ( π
8 )
RZ (−π
8 )
RZ ( π
8 )
•
•
•
•
•
•
RZ (−π
8 )
RZ ( π
8 )
RZ (−π
8 )
RZ ( π
8 )
RZ (−π
8 )
H
(a) Multi-controlled Toffoli without ancillary qubits
q3 :
•
•
q2 :
•
•
•
•
q1 :
•
•
•
T
•
q0 :
H
T†
T
T†
T
H
a0 :
H
T
T†
T
T†
H
•
•
T
T†
H
T
T†
T
T†
H
(b) Multi-controlled Toffoli gate with ancillary qubits
Figure 2.5.: Decompositions of the multi-controlled Toffoli gate
Because of the coherence time and gate errors, it is important to optimize the number
of elementary gate operations used in a quantum algorithm. It is not just a matter of
execution time but of whether a meaningful result can be obtained at all from the execution
of a quantum algorithm on a specific architecture. Many opimization schemes exist and
optimization of quantum circuits is still an active area of research [49, 15, 14].
The simplest of these optimization schemes is the single-qubit gate fusion. Since any single
qubit unitary represents a rotation of the Bloch sphere, any sequence of such gates also
represents a rotation. Instead of performing each rotation separately, the complete rotation
can be performed at once.
Another kind of optimization involves using ancillary qubits. Ancillary qubits are addi-
tional qubits apart from those required for the quantum algorithm. They can act as a sort
of “working memory” to allow for a more compact representation of certain quantum
gates or algorithms. Because the value of ancillary qubits is only important during the
computation, they are not measured and do not factor into the final result.
Example 2.4. Consider the quantum circuit in Figure 2.5a which represents a multi-controlled
Toffoli gate with three control qubits. This gate performs a Pauli X gate on the last qubit if and
only if all the previous qubits are in the |1⟩state. Otherwise it acts as the identity on all qubits.
Figure 2.5b shows an implementation of this gate with the addition of one ancillary qubit. This is
February 2022
Tom Peham
12/59

now a quantum circuit acting on five qubits with a higher total gate count, using 33 compared to
the 31 of the original circuit. This circuit uses less CNOT gates however, needing only 12 CNOT
operations compared to the 14 of the previous circuit. This trade-off is desirable because of the
higher gate error of CNOT gates.
Of course, optimizations are also employed in conjunction with compilation methods to
optimize a compiled circuit while still obeying all restrictions enforced by the hardware.
But sometimes optimizations are done before mapping. In fact, some available optimiza-
tion methods are not designed to handle hardware specific restrictions [28]. Therefore,
equivalence checking methods are not only relevant when verifying the result of a compi-
lation from a high-level description but also when verifying the results of optimizations
of an uncompiled circuit or even just verifying the equivalence of high-level description
with an uncompiled optimized version of the high-level description.
Eventually, compilation and optimization yields a new circuit that might look quite
different to the original high-level description. It is essential for the successful execution
of a quantum computation to verify that the compiled circuit still implements the same
functionality as the original one. To this end, methods to check the equivalence of quantum
circuits are necessary.
February 2022
Tom Peham
13/59

3. Equivalence Checking
In order to discuss equivalence checking methods for quantum circuits we first need to
precisely define the equivalence checking problem and aspects unique to equivalence
checking in the quantum realm—namely permutations of the input and output layout
of a quantum circuit, inaccuracies stemming from working with complex numbers, and
ancillary qubits.
In its simplest form the equivalence checking problem for quantum circuits is defined as
follows.
Definition 3.1. In general, given two quantum circuits
G = g0 . . . gm−1 and G′ = g′
0 . . . g′
m′−1
with corresponding system matrices
U = Um−1 · · · U0 and U′ = U′
m′−1 · · · U′
0,
the equivalence checking problem for quantum circuits asks whether
U = eiθU′ or, equivalently, U†U′ = eiθI,
where θ ∈(−π, π] denotes a physically unobservable global phase.
So, in principle, checking the equivalence of two quantum circuits reduces to the construc-
tion and the comparison of the respective system matrices. While this is straight-forward
conceptually, it quickly becomes an increasingly difficult task due to the size of the in-
volved matrices scaling exponentially with the number of qubits. Equivalence checking of
quantum circuits has even been shown to be QMA-complete [17].
February 2022
Tom Peham
14/59

Even this definition is lacking when talking about the results of compilation flows. Compi-
lation and optimization can alter a circuit in such a way that two circuits can be considered
equal even if they are not equivalent according to Definition 3.1, i.e., if they have different
system matrices.
Firstly, there are numerical inaccuracies. This is one of the biggest, yet hardly talked about,
practical issues when actually conducting equivalence checking. Because quantum gates
are described by matrices over C, they are hard to accurately represent in memory. Usually,
these matrices are stored using floating point numbers which leads to imprecisions and
rounding errors. Therefore, comparing two matrices for exact equality becomes pointless
in many practical cases. Instead, the Hilbert-Schmidt inner product can be used to quantify
the similarity between two matrices. Let tr denote the trace of a matrix, i.e., the sum of its
diagonal elements. Then, because tr(I) = 2n for the identity transformation on n qubits,
one can check whether | tr(U†U′)| ≈2n in order to conclude the equivalence of both
circuits up to a given tolerance.
Secondly, compilation flows introduce SWAP operations into a circuit such that the re-
sulting circuit conforms to the hardware topology. These techniques use a circuit’s initial
layout and output permutation as an additional degree of freedom for saving SWAP
operations, as, e.g., illustrated in Example 2.3. Because of these SWAPs, two circuits
might only be equivalent up to a reordering of the qubits. Hence, in order to verify the
equivalence of compilation flow results, any equivalence checking routine must be able to
handle these kind of permutations and accurately track which gate is performed on which
qubit.
Lastly, as discussed in Section 2.3, sometimes it is necessary to check the equivalence of
two circuits that might not even operate on the same number of qubits due to the use
of ancillary qubits. Ideally an equivalence checking routine can also handle those cases.
The difficulty comes from the fact that quantum circuits with differing numbers of qubits
cannot represent the same unitary. Indeed, their unitaries do not even have the same
dimensions. Ancillary qubits have a constant initial state, being either in the |0⟩or |1⟩
state. We are going to assume that ancilla qubits appear after all other qubits in the circuit,
meaning that in a circuit with n qubits q0, · · · qn−1 and 0 ≤i < n ancilla qubits, the ancillae
are the qubits qn−i−1, · · · , qn−1.
February 2022
Tom Peham
15/59

We want to define the equivalence checking problem for circuits with ancillary qubits.
Let’s first consider the case of a single ancillary qubit.
Lemma 3.1. Let U be a unitary acting on n + 1 qubits (where the n + 1-st qubit is the ancillary
qubit) such that U acts as identity on the n + 1-st qubit if it is in state |c⟩∈{|0⟩, |1⟩}. More
precisely, if |ϕ⟩= ∑n−1
i=0 αi |i⟩, αi ∈C then U(|ϕ⟩⊗|c⟩) = |ϕ′⟩⊗|c⟩, where |ϕ′⟩= ∑n−1
i=0 α′
i |i⟩
is the state of the first n qubits after applying U to |ϕ⟩. We define the ancilla-free matrix Uanc of
U as
Uanc =
2n−1
∑
i=0
2n−1
∑
j=0
(⟨c| ⊗⟨i| U |j⟩⊗|c⟩) |i⟩⟨j| .
Then the following equation holds
U(|ϕ⟩⊗|c⟩) = (Uanc ⊗I)(|ϕ⟩⊗|c⟩),
(3.1)
where I is the single-qubit identity matrix.
When there is more than one ancillary qubit involved, the construction in Equation (3.1)
can be applied repeatedly until all ancillaries have been “summed out” to obtain the
unitary acting on the remaining qubits.
With this the equivalence checking problem of circuits using ancillary qubits can be stated
as follows.
Definition 3.2. Given two quantum circuits
G = g0 . . . gm−1 and G′ = g′
0 . . . g′
m′−1
with ancillaries qubits with corresponding system matrices
U = Um−1 · · · U0 and U′ = U′
m′−1 · · · U′
0,
the equivalence checking problem for quantum circuits asks whether
Uanc = eiθU′
anc or, equivalently, U†
ancU′
anc = eiθI,
where θ ∈(−π, π] denotes a physically unobservable global phase.
February 2022
Tom Peham
16/59

Example 3.1. We can trivially use a CNOT gate as a Pauli X gate by treating the control qubit as
an ancillary with constant state |1⟩. This can be shown using the construction in Equation (3.1).
To conform with our construction that the ancilla is the last qubit, we consider the matrix of a
CNOT where the target is on qubit 0.
[︃1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
]︃
= |00⟩⟨00| + |01⟩⟨11| + |10⟩⟨10| + |11⟩⟨01|
By way of Equation (3.1) we obtain
[︃1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
]︃
anc
= ⟨10|
[︃1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
]︃
|01⟩|0⟩⟨0| + ⟨11|
[︃1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
]︃
|01⟩|1⟩⟨0|
+ ⟨10|
[︃1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
]︃
|11⟩|0⟩⟨1| + ⟨11|
[︃1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0
]︃
|11⟩|1⟩⟨1|
= |1⟩⟨0| + |0⟩⟨1| =
[︄
0
1
1
0
]︄
= X
In order to avoid the emergence of a verification gap as for classical systems, automated
software solutions for equivalence checking of quantum circuits have to be developed.
To this end, various methods have been proposed [18, 19, 20, 21, 22, 23, 24, 25]. However,
most of them either only work on small circuits, lack publicly available implementations,
or are based on paradigms established in classical computing that do not take the full
picture of quantum computing into account. Few methods exist that approach equivalence
checking entirely from the perspective of quantum computing [24, 22, 23]. Even these
existing approaches view the equivalence checking problem from completely different
perspectives and a baseline indicating which paradigm is suited best for which use-case is
yet to be established.
February 2022
Tom Peham
17/59

4. Equivalence Checking using the
ZX-Calculus
The ZX-calculus [26, 50] is a graphical notation for quantum circuits equipped with a
powerful set of rewrite rules that enable diagrammatic reasoning about quantum comput-
ing. It has been successfully applied to quantum circuit compilation and optimization [22,
27, 28] and to some extent also to equivalence checking of quantum circuits [28]. The
algorithm for equivalence checking using the ZX-calculus was only mentioned briefly
in [28] and has not been adapted to handle numerical inaccuracies, permutations of input
and output layout of a compiled circuit and ancillary qubits as mentioned in Chapter 3. In
short, more work is needed to handle equivalence checking of compilation results with
the ZX-calculus. In this chapter we are going to discuss how this can be done as well
as provide first results on the (in-)completeness of the ZX-calculus based equivalence
checking algorithm.
In order to do this, we are first going to introduce the necessary background on the
ZX-calculus and the current state-of-the-art algorithm in equivalence checking with the
ZX-calculus.
4.1. Background
A ZX-diagram is made up of colored nodes (called spiders) that are connected by wires
(representing qubits, similar to quantum circuit notation). Each spider can either be green
(Z-spider
) or red (X-spider
) and is optionally attributed a scalar phase.
ZX-diagrams can be composed just like quantum circuits. Horizontal composition or
concatentation (denoted ◦) is achieved by connecting the outputs of one diagram to the
input of another. The bare wire “
” acts as the identity for concatenation. Vertical
February 2022
Tom Peham
18/59

composition (denoted ⊗) is achieved by simply “stacking” two diagrams on top of each
other. The empty diagram
acts as the identity for vertical composition. Additionally, a
ZX-diagram can carry a global phase that is annotated along the diagram. Since global
phases are negligible in most cases, they are frequently omitted from ZX-diagrams and
equations in the ZX-calculus usually hold up to a global phase. A spider with a phase of
±π is called a Pauli spider. A spider with a phase α ∈{k π
2 | k ∈Z} is called a Clifford spider.
A Clifford spider that is not a Pauli spider is called a proper Clifford spider. A ZX-diagram
consisting entirely of Clifford (Pauli) spiders is called a Clifford (Pauli) ZX-diagram.
Any quantum circuit can be interpreted as a ZX-diagram. The reverse of this statement is
not true, i.e. not every ZX-diagram can be interpreted as a quantum circuit because the
ZX-diagram does not necessarily encode a unitary transformation. Every ZX-diagram
does, however, have an interpretation as a linear map.
Definition 4.1. The interpretation function J·K : ZX-diagrams ↦→⋃︁
n,m∈N Cn,m, where
ZX-diagrams denotes the sets of all ZX-diagrams, assigns to each ZX-diagram its corresponding
linear map in ⋃︁
n,m∈N Cn,m. The linear map corresponding to the Z- and X-spiders are as follows:
•
...
α
... = |0 . . . 0⟩⟨0 . . . 0| + eiα |1 . . . 1⟩⟨1 . . . 1|
•
...
α
... = |+ · · · +⟩⟨+ · · · +| + eiα |−· · · −⟩⟨−· · · −|
Any linear map can then be built up from these spiders by connecting and stacking diagrams.
Spiders without inputs are called states, whereas spiders with no outputs are called effects.
Interpreted as linear maps, states represent column vectors whereas effects represent row
vectors. A ZX-diagram without inputs or outputs represents a number. This can be clearly
seen from Definition 4.1 as a ZX-diagrams without inputs or outputs represents a matrix
in C0,0 which are just the complex numbers.
Example 4.1. Some important gates introduced in Chapter 2 as ZX-diagrams:
Pauli X :
π
Pauli Z :
π
Pauli Y :
π
π
X −basis : {
,
π }
Z −basis : {
,
π }
Y −basis : {
π
2
,
3π
2
}
S :
π
2
CNOT :
T :
π
4
Hadamard gate :
π
2
π
2
π
2
=
February 2022
Tom Peham
19/59

Because the Hadamard transform appears quite often in ZX-diagrams, the Hadamard box
serves as a short notation. Later we are going to need many Hadamard boxes. In those cases,
an edge with a Hadamard box is abbreviated with a blue-dotted line. Such an edge is called a
Hadamard edge.
Even though the wires connected to spiders can be thought of as inputs and outputs, the
"only connectivity matters" paradigm of the ZX-calculus makes this distinction redundant.
This is formalized by the two special constructs
(cup) and
(cap) that satisfy the
"yanking-equations", i.e.,
=
=
.
(4.1)
These constructs have the following interpretation as linear maps.
J
K = |00⟩+ |11⟩
J K = ⟨00| + ⟨11|
These constructs are therefore equal to the well-known Bell state and Bell-effect [1] up to a
scalar factor. Caps and cups also allow for the definition of the trace of a diagram.
Definition 4.2. The trace of a ZX-diagram D is defined as the diagram resulting from connecting
the i-th output to the i-th input for all 0 ≤i < n.
tr
(︄
...
...
D
)︄
=
...
...
...
D
The real power of ZX-diagrams becomes evident when adding rewrite rules to the lan-
guage. The axioms of the scalar-free ZX-calculus are given in Fig. 4.1.
Example 4.2. To give a feel for how to work with ZX-diagrams, we are going to prove the well-
known equivalence of a SWAP with 3 CNOT operations (as shown in Fig. 2.4). For this, we first
February 2022
Tom Peham
20/59

...
α
...
...
β
...
...
(f)
= ...
α+β
...
α
...
...
(h)
=
α
...
...
(id)
=
(hh)
=
...
...
(b)
=
α
...
(c)
=
...
π
α
...
(π)
=
π
−α
π
Figure 4.1.: Axioms of the scalar-free ZX-calculus
need to prove the following rule, which is sometimes listed explicitly among the axioms for the
ZX-calculus but can also be derived from the axioms as follows
(f)
=
(b)
=
(c)
=
=
.
(4.2)
With this we can proceed with
=
(b)
=
(f)
=
(4.2)
=
.
(4.3)
4.2. Equivalence Checking Graph-like ZX-diagrams
Equivalence checking with the ZX-calculus can be done in one of two ways, by either
rewriting the diagram of both circuits into one another (as in Ex. 4.2) or by inverting one
diagram, composing the diagrams and simplifying as much as possible. This is sometimes
called an equivalence checking miter. If the composed diagram simplifies to a diagram
composed only of bare wires, it is either the identity or contains swaps, i.e., resembles a
permutation.
Example 4.3. Consider again the circuits G from Fig. 2.2a and G′ from Fig. 2.4. Their respective
ZX-diagrams are shown in Fig. 4.2a and Fig. 4.2b. Since all phases in all spiders are 0, the
inverse of each diagram is obtained by just reversing the diagram. Using the rewrite rules of the
ZX-calculus to prove the identity of the circuits proceeds as follows:
February 2022
Tom Peham
21/59

(a) ZX-diagram of Circuit G
(b) ZX-diagram of Circuit G′
Figure 4.2.: ZX-diagrams of GHZ state preparation circuits
(4.3)
=
=
(hh)
=
(f)=
(4.2)
=
(id)
=
(f)=
(4.2)
=
(id)
=
The diagram contains a SWAP which permutes qubit Q1 and Q2. Since this is what we expect from
the output permutation shown in Figure 2.4 it can be concluded that the circuits are equivalent.
This example shows that the ZX-calculus cannot only show the equivalence of circuits
but that it can also provide a proof certificate in the form of the order of rewrite rules that
are applied to derive the identity. A natural question to ask is whether the ZX-calculus
is powerful enough to derive the identity for any pair of functionally equivalent circuits.
The good news is that the ruleset provided in this paper is complete for circuits solely
composed of Clifford gates [51]. The bad news is that, in order to achieve completeness
for universal quantum computing, the ruleset has to be extended with a rule involving
complicated iterated trigonometric functions [52], which makes it difficult to apply in
automated reasoning.
In order to employ ZX-diagrams in automated equivalence checking, it would be ideal to
have a convergent rewrite system, meaning that it is terminating and uniquely normalizing.
The rewrite system in Figure 4.1 does not constitute such a rewrite system as can be seen
in the proof of Equation (4.2). In order to prove the equivalence of the two diagrams,
the original diagram had to be transformed into a more complicated diagram consisting
of more spiders and edges than the original. Because of this fact it is hard to know
which rule in Figure 4.1 should be applied in a given rewrite situation. A solution would
be to recursively apply all rewrites to a diagram to check if at some point the desired
diagram is derived. But this procedure is, firstly, intractable because of the exponential
number of diagrams generated and, secondly, not guaranteed to terminate at all. This
necessitates the definition of a rewrite system suitable for automated reasoning. In [27],
February 2022
Tom Peham
22/59

the authors introduce an alternative structure for ZX-diagrams coupled with additional
rewrite rules.
Definition 4.3. A ZX-diagram is graph-like when:
1. All spiders are Z-spiders.
2. Z-spiders are only connected via Hadamard edges.
3. There are no parallel Hadamard edges or self-loops.
4. Every input or output is connected to a Z-spider and every Z-spider is connected to at most
one input or output.
In graph-like ZX-diagrams, a spider connected to an input or output is called a boundary spider.
Otherwise it is called an interior spider.
Most importantly, every ZX-diagram is equal to a graph-like ZX-diagram [27]. Every
ZX-diagram can be rewritten to its equivalent graph-like form using the basic rules given
in Figure 4.1. Instead of rigorously defining this rewriting procedure we give an intuition
with the following example.
Example 4.4. The ZX-diagram of the GHZ state preparation circuit from Figure 4.2a can easily
be transformed to its equivalent graph-like form by applying rules (id) and (h) from right to left.
=
=
=
=
For graph-like ZX-diagrams two important rewrite rules are defined:
± π
2
...
α1
αn
...
...
α2
αn−1
...
...
=
...
α1∓π
2
αn∓π
2
...
...
α2∓π
2
αn−1∓π
2
...
...
(4.4)
February 2022
Tom Peham
23/59

jπ
kπ
...
α1
γ1
...
β1
...
...
αn
γl
...
βm
...
...
...
...
=
...
α1+kπ
γ1+jπ
...
...
αn+kπ
γl+jπ
...
β1+(j+k+1)π
...
βm+(j+k+1)π
...
...
...
...
(4.5)
These can be derived using the rules in Figure 4.1. For a proof we refer to [27]. As discussed
in [27], these two rules are sufficient to remove any interior proper Clifford spider. To
further reduce the number of interior Pauli spiders in the diagram, an additional rule is
introduced that allows for the removal of interior Pauli spiders connected to boundary
spiders.
jπ
α
...
α1
αn
...
...
...
=
α
jπ
...
α1
αn
...
...
...
(4.6)
In this scenario the right-hand side of Equation (4.6) can be simplified with Equation (4.5).
This is discussed further when we are talking about equivalence checking of circuits
containing non-Clifford gates. In case the boundary spider is a Pauli spider, a simpler
version of this rule suffices.
jπ
kπ
...
α1
αn
...
...
...
=
jπ
...
α1
αn
...
...
...
(4.7)
While eliminating spiders, applications of Equation (4.4) and Equation (4.5) introduce new
edges between spiders in the diagram. This can sometimes lead to parallel edges between
two spiders. These can be simplified using the following set of rules.
...
α
β
... =
...
α
β
...
α
...
=
α
...
α
...
=
α+ π
2
...
(4.8)
Repeatedly applying the rules in Equation (4.4), Equation (4.5) and Equation (4.6) until
no more matches are found, interspersed with applications of Equation (4.8), eventually
February 2022
Tom Peham
24/59

Algorithm 1 Simplification of graph-like Clifford ZX-diagrams
Input: Clifford ZX-diagram D in graph-like form
Output: Simplified ZX-diagram
while Rules can be applied do
while Rules can be applied do
Remove interior proper Clifford spiders in D using Equation (4.4)
Remove parallel edges in D using Equation (4.8)
Remove interior pairs of Pauli spiders in D using Equation (4.5)
Remove parallel edges in D using Equation (4.8)
end while
Remove Pauli spiders connected to boundary spiders in D using Equation (4.6) or Equa-
tion (4.7)
Remove parallel edges in D using Equation (4.8)
end while
Output D
produces a ZX-diagram that does not contain interior proper Clifford spiders, adjacent
pairs of interior Pauli spiders or interior Pauli spiders adjacent to a boundary spider [27].
This procedure is described in Algorithm 1.
This algorithm terminates because every rule in Equation (4.4), Equation (4.5) and Equa-
tion (4.6) removes at least 1 interior Clifford spider. Because Algorithm 1 performs all
simplifications on Clifford ZX-diagrams, the resulting simplified diagram does not contain
any interior spiders. This simplification strategy is the basis of the decision procedure of
Algorithm 2. We are going to see in Section 4.6 that this procedure is sufficient for proving
the (non-)equivalence of any two (non-)equivalent Clifford circuits.
In the case of circuits containing non-Clifford gates a new construct is needed that allows
for extraction of non-Clifford phases.
Definition 4.4. A ZX-diagram of the form
α
... n is called an n-ary phase gadget. Such a phase
gadget is called a Pauli gadget if α ∈{kπ | k ∈Z} and a Clifford gadget if α ∈{k π
2 | k ∈Z}.
We have already seen a phase gadget in Equation (4.6) where a non-Pauli angle was
extracted into a unary phase gadget. Thus gadgetizing a spider can enable further simplifi-
cations. More specifically Equation (4.6) can immediately be followed by Equation (4.5) to
remove an interior Pauli spider.
February 2022
Tom Peham
25/59

Algorithm 2 Proving equivalence of Clifford circuits
Input: Clifford Circuits G, G′
Output:
TRUE if G and G′ can be proven to be equivalent or FALSE other-
wise
D ←ZX-diagram of G
D′ ←ZX-diagram of G′
M ←D† ◦D′
Convert M to graph-like form
Simplify M using Algorithm 1
while Rules can be applied do
Remove identity spiders using (id)
Fuse spiders using (f)
Remove double Hadamards using (hh)
end while
if M consists only of wires then
Output True
else
Output False
end if
α
jπ
...
α1
γ1
...
...
αn
γl
...
...
...
(4.5)
=
α
...
α1
γ1+jπ
...
...
αn
γl+jπ
...
...
...
This application of Equation (4.5) introduces an n-ary phase gadget. The main simplifi-
cation loop in Algorithm 1 reduces a non-Clifford ZX-diagram into a diagram where all
phase gadgets are non-Clifford. This follows from the fact that Algorithm 1 removes all
interior Clifford spiders. To remove these non-Clifford phase gadgets, the following rules
are needed [28]:
α
β
... =
α+β
...
(4.9)
α
kπ
α1
...
β
jπ
αn
...
...
=
α1
...
(−1)kα+(−1)jβ
αn
...
...
(4.10)
The last rule is a variation of (GF) from [28] and is easily proven using the axioms of
the ZX-calculus. The proof is given in Appendix B. Equation (4.10) in combination with
February 2022
Tom Peham
26/59

Algorithm 3 Simplification of graph-like ZX-diagrams
Input: ZX-diagram D in graph-like form
Output: Simplified ZX-diagram
while Rules can be applied do
Use Algorithm 1 to remove interior Clifford and Pauli spiders or transform Pauli spiders into
phase gadgets
Remove phase gadgets using Equation (4.9) and Equation (4.10)
Use Algorithm 1 to remove interior Clifford and Pauli spiders not connected to boundary
spiders
Remove Pauli spiders connected to boundary non-Pauli spiders using Equation (4.6) and
Equation (4.5)
end while
Output D
Equation (4.6) covers the rules (P2) and (P3) from [28]. Thus one rule less is needed. This
version is also slightly more general than those rules because it can handle cases where
the phase gadget gets the π phase from other simplifications than Equation (4.5). It should
be noted however that these rules are equivalent and Equation (4.10) is just as powerful.
Since both Equation (4.9) and Equation (4.10) remove one phase gadget from the circuit,
they can be used to further reduce graph-like ZX-diagrams. Using these rules, a variation
of the ZX-simplify algorithm from [28] can be defined. The full procedure is given in
Algorithm 3.
With these rewrite rules in place, we have everything needed in order to use the ZX-
calculus for equivalence checking of quantum circuits. Analogous to Algorithm 2 we
can use Algorithm 3 as the basis of a decision procedure. This algorithm is given in
Algorithm 4.
It is an open question whether this algorithm is complete, i.e. whether for any two
equivalent quantum circuits G and G′ this algorithm can conclude that the circuits are
equivalent. The correctness of this algorithm follows from correctness of the ZX-calculus,
i.e. this algorithm never concludes that two non-equivalent quantum circuits G and G′
are equivalent. This also implies that if Algorithm 4 does conclude that G and G′ are
equivalent, then they must indeed be equivalent.
February 2022
Tom Peham
27/59

Algorithm 4 Proving equivalence of quantum circuits
Input: Quantum Circuits G, G′
Output: TRUE if G and G′ are equivalent or FALSE otherwise
D ←ZX-diagram of G
D′ ←ZX-diagram of G′
M ←D† ◦D′
Convert M to graph-like form
Simplify M using Algorithm 3
while Rules can be applied do
Remove identity spiders using (id)
Fuse spiders using (f)
Remove double Hadamards using (hh)
end while
if M consists only of wires then
Output True
else
Output False
end if
4.3. Handling Inaccuracies
The equivalence checking routine of Algorithm 4 is an exact method (as long as phases
are expressed as fractions of π). Hence, when considering two quantum circuits G and G′
where G′ is equivalent to G up to some small error, the equivalence checking routine of
Algorithm 4 is unable to conclude equivalence. But can anything be concluded about the
reduced ZX-diagram of G†G′ produced by Algorithm 3?
To give an intuition, consider the Clifford+T circuit given in Figure 4.3a. Introducing an
error of 10−15 in the phase of two spiders and checking the equivalence of the original and
the erroneous circuit yields the ZX-diagram shown in Figure 4.3b. The phases indicated
with ∼α means that the phase is α ± 10−15. It is not at all obvious that this diagram is
close to the identity. However, if we were to round the phases (for example rounding
π ± 10−15 to π) and simplified further we would indeed be able to derive the identity.
This idea leads to the equivalence checking routine in Algorithm 5. This algorithm is
obviously not correct in a formal sense, i.e. it can attest two non-equivalent circuits to be
equivalent, but that is the whole point. The tolerance parameter ϵ can be used to tune the
February 2022
Tom Peham
28/59

Algorithm 5 Proving equivalence of quantum circuits containing small errors
Input: Quantum Circuits G, G′, Tolerance ϵ
Output: TRUE if G and G′ are equivalent or FALSE if G and G′ are not equiva-
lent
D ←ZX-diagram of G
D′ ←ZX-diagram of G′
M ←D† ◦D′
Convert M to graph-like form
Simplify M using Algorithm 3
if M contains spiders with non-zero phase then
round phases in M to nearest fraction of π with distance less then ϵ
Simplify M using Algorithm 3
end if
while Rules can be applied do
Remove identity spiders using (id)
Fuse spiders using (f)
Remove double Hadamards using (hh)
end while
if M consists only of wires then
Output True
else
Output False
end if
degree to which errors are allowed. However, it does not give any indication about the
absolute error.
To clarify this point, consider a ZX-diagram M after simplification with Algorithm 3 and
the corresponding ZX-diagram M′ obtained after rounding and simplifying again. The
tolerance ϵ can not be used to assess tr(JD†KJD′K) — the Hilbert-Schmidt inner product
discussed in Chapter 3.
A question one might ask about Algorithm 5 is why the rounding doesn’t already occur on
the diagrams D and D′. The reason is that even phases that are not nice fractions of π (or
very small fractions) might cancel during simplification due to the rules in Equation (4.9)
and Equation (4.10). Thus rounding before simplifying would increase the total error
made during the equivalence check.
This way of handling inaccuracies is still lacking. As discussed above it is hard to gauge
the tolerance required in order to ensure the absolute error allowed is within some bound.
Given the ZX-diagram M after simplification with Algorithm 3, how can we determine
February 2022
Tom Peham
29/59

π
4
π
2
3π
4
π
2
π
π
2
π
2
π
4
π
2
π
2
π
2
(a) ZX-diagram of Clifford+T circuit
π
2
∼0
3π
2
3π
2
∼0
π
2
(b) Reduced diagram with errors
Figure 4.3.: Equivalence checking with the ZX-calculus in the presence of few small errors
whether | tr(JMK)| ≈2n? Definition 4.2 shows how the trace is defined in terms of ZX-
diagrams. Unfortunately this definition is hardly helpful if we want to actually compute
the trace. In order to compute the trace, further simplifications have to be made after the
inputs and outputs have been connected. This doesn’t necessarily enable the ZX-diagram
to be simplified to a point where calculations are practical. A possible solution to this
problem is to leave the ZX-calculus framework entirely. ZX-diagrams are, in essence,
tensor networks [50, 53]. Therefore methods from the tensor network domain can be used
to compute the trace of a ZX-diagram.
4.4. Handling Permutations
Handling SWAPs in ZX-diagrams is a trivial matter. Since SWAPs are nothing but edges
connecting spiders acting on different qubits, they do not add much complexity to a
ZX-diagram. To correct permutations of the initial layout, it has to be ensured that wires
are connected accordingly when constructing D† ◦D′ in Algorithm 4. But since SWAPs
incur such little overhead in ZX-diagrams, the initial layout can also just be encoded into
the original diagrams themselves before performing the equivalence check. The wires can
then be connected in the usual fashion, i.e. by connecting the i-th output wire of D† with
the i-th input wire of D′.
Output permutations can be handled in a similar fashion as with decision diagrams, by
comparing the permutation of wires after fully simplifying D† ◦D′ with the expected
permutation. Once again the permutation can also just be handled by encoding the SWAPs
directly into the diagrams.
As discussed in Section 2.2, permutations of input and output layouts are performed in
order to save CNOT gates that need to be executed on the quantum hardware. When
converting a compiled circuit to a ZX-diagram, Equation (4.3) can be used to reconstruct
February 2022
Tom Peham
30/59

compiled SWAP gates if they are not optimized away. Since a SWAP in the ZX-calculus is
only a crossing of the wires, this reconstruction can greatly improve the performance of
the equivalence check, decreasing runtime by up to two orders of magnitude.
4.5. Handling Ancillaries
In the ZX-calculus the equivalence checking problem using ancillaries is reducible to
the ancilla-free case in a straight forward fashion. Remember that ancillaries are qubits
that have constant initial state and end in the same state. In Lemma 3.1 we illustrated
the formal construction of the unitary that arises from fixing one input and output to a
specific state in the original circuit. This is easily done in the diagrammatic language of
the ZX-diagram, by replacing each input and output belonging to an ancilla qubit by the
respective state and effect, which are just X-spiders with a phase of either 0 or π.
Example 4.5. In Example 3.1 we illustrated how a CNOT gate can be used as a Pauli X gate by
using the control of the gate as an ancillary with state |1⟩using Lemma 3.1. In the ZX-calculus
the proof only requires basic applications of the axioms of the ZX-calculus. We start by applying
the |1⟩state and effect to the ancillary line and proceed to simplify.
→
π
π
(π)
=
π
π
π
(f)=
π
π
π
Because
π
π =
the right-hand side indeed implements a Pauli X gate (
π
).
4.6. Completeness
As mentioned previously, it is not known if Algorithm 4 is able to prove (non-)equivalence
between any two (non-)equivalent quantum circuits or for which classes of circuits it can
prove (non-)equivalence. We are going to address both of these open problems.
As the ZX-calculus is complete for Clifford ZX-diagrams, it is not surprising that Algo-
rithm 4 is also complete for Clifford ZX-diagrams.
February 2022
Tom Peham
31/59

π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
(a) Multi-controlled Toffoli without ancillary qubits
π
4
‧ π
4
π
4
‧ π
4
π
4
π
4
‧ π
4
π
4
‧ π
4
π
4
‧ π
4
π
4
‧ π
4
π
4
‧ π
4
(b) Multi-controlled Toffoli with ancillary qubits
Figure 4.4.: ZX-diagrams of the multi-controlled Toffoli gate
Theorem 4.1. Given two quantum circuits G and G′ only containing Clifford gates, Algorithm 4
outputs True if and only if G = G′, otherwise it outputs False.
Proof. The proof of Theorem 4.1 involves many diagram manipulations and is therefore
somewhat technical. The full proof is given in Appendix B.
Theorem 4.1 establishes a baseline for what equivalences can be proven via automated
reasoning with the ZX-calculus. Next we want to look at completeness from a different
perspective, by showing that Algorithm 4 is not sufficient for proving the equivalence of
arbitrary equivalent circuits. In particular, we are going to show that this algorithm is not
even sufficient for proving equivalence of reversible circuits.
Theorem 4.2. There exist two circuits G and G′ that are equivalent in the sense of Definition 3.2
but whose equivalence cannot be shown by Algorithm 4.
Proof. Unfortunately the proof of this theorem is not achieved through cunning manipula-
tion of diagrams, kets and bras but by brute-force calculation. Consider the ZX-diagrams
in Figure 4.4 which are the ZX-diagrams of the circuits in Figure 2.5 where the ancillary
qubit’s input and output has been set to |0⟩=
. Taking the adjoint of the diagram
in Figure 4.4a, and concatenating the two diagrams, yields the diagram in Figure 4.5a.
Simplifying this diagram with algorithm Algorithm 3, yields the diagram in Figure 4.5b.
No further simplifications can be made using Algorithm 3 but this diagram is clearly not
February 2022
Tom Peham
32/59

‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
4
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
‧ π
8
‧ π
4
π
4
‧ π
4
π
4
π
4
‧ π
4
π
4
‧ π
4
π
4
‧ π
4
π
4
‧ π
4
π
4
‧ π
4
(a) Miter of multi-controlled Toffoli ZX-diagrams
‧ π
8
π
8
‧ π
8
π
8
π
8
‧ π
8
π
8
‧ π
8
π
8
π
4
π
4
‧ π
4
π
4
‧ π
4
π
8
π
4
‧ π
8
‧ π
4
‧ π
4
π
4
‧ π
8
‧ π
8
π
8
π
8
‧ π
4
‧ π
4
π
4
(b) Reduced miter
Figure 4.5.: Counterexample to the completeness of Algorithm 3
the identity. It can be checked by (tedious) computation of the corresponding matrices that
the ZX-diagram in Figure 4.5a does actually implement the identity transformation.
Interestingly no counterexample has been found when considering ancilla-free circuits.
What is the difference between ancilla-free circuits and circuits like the one in Figure 4.4b?
This might be because the ZX-diagrams in Figure 4.4b and Figure 4.5a do not admit a
focused gFlow in the sense of Definition 3.4 in [27]. Every ZX-diagram obtained from a
quantum circuit does admit a focused gFlow and concatenating ZX-diagrams with a fo-
cused gFlow again yields a diagram with a focused gFlow (see Lemma 3.7 in [27]). Indeed
Figure 4.5a does not admit a focused gFlow. The circuit extraction algorithm from [27] is
not able to extract a circuit from this diagram. However, this is mere speculation and inves-
tigating the relation of focused gFlow to the equivalence checking power of Algorithm 4
remains a topic for further research.
It is not surprising at all that Algorithm 4 is not complete in general. Because the equiva-
lence checking problem is QMA-complete and since QMA is a subset of NP, it would be
entirely unexpected that Algorithm 4 solves the equivalence checking problem, given that
this algorithm runs in polynomial time [28]. But the proof by counterexample shows that
it cannot even show the equivalence of two circuits (involving ancillaries) even when they
are fairly simple.
February 2022
Tom Peham
33/59

5. Equivalence Checking using Decision
Diagrams
In Chapter 2 we saw that the dimension of the system matrix of a quantum circuit grows
exponentially in the number of qubits. And while quantum circuits can, in theory, perform
arbitrary unitary operations on qubits, in practice the system matrix of a quantum circuit
often exhibits a lot of structure. Decision diagrams [30, 25, 31, 32, 33, 34] have proven
effective in efficiently representing and manipulating quantum states and transformations
in many cases. By exploiting redundancies in the vectors and matrices, it is often possible
to significantly reduce the necessary memory, sometimes even exponentially. This also
makes them great candidates for use in quantum circuit verification and a lot of progress
has been made in this field [54, 55, 56, 57, 58].
In order to compare the ZX-calculus based approach to equivalence checking with the one
based on decision diagrams this chapter reviews the current state of the art in decision
diagram based equivalence checking. Instead of a rigorous definition of decision diagrams
we give an intuition by showing their construction.
Given a square matrix U, the matrix is divided into equally-sized submatrices U =
[︂
U00
U01
U10
U11
]︂
, where Uij denotes the action of U given the considered qubit is mapped from
j to i. Every (sub-)matrix is represented by a node in the decision diagram and an edge
is created for each Uij connecting its node to the node representing U. This procedure is
then recursively applied to each of the matrices Uij until only complex numbers remain—
thus building up the decision diagram. If any two submatrices are identical up to a
constant factor their corresponding decision diagrams can be identified with each other
and, therefore, do not have to be represented twice. The complex-valued factors are
stored as edge-weights in the diagram. This sharing of structure is what allows compact
representations of the functionality of many quantum circuits.
February 2022
Tom Peham
34/59

2
1
1
0
0
(a) System Matrix U
n-1
...
0
(b) n-qubit Identity
Figure 5.1.: Decision diagrams
Example 5.1. Consider again the system matrix shown in Figure 2.2b. We can see that U00 = U01
and U10 = (−1)U11. The decision diagram for the system matrix is given in Fig. 5.1a. To this end,
we adopt the decision diagram visualization method proposed in [59], where thickness and color of
an edge represent the edge weight’s magnitude and phase, respectively. Obviously, the decision
diagram representation is much more compact than the whole matrix.
Decision diagrams are predestined for verification, because they are canonical (with
respect to a particular variable order and normalization criterion), i.e., there are no two
different decision diagrams for the same functionality. Once the decision diagrams for both
circuits G and G′ in question are constructed, it suffices to compare their root pointers and
the corresponding top edge weight [31]. While this is true in theory, the diagrams might
not be exactly identical due to numerical imprecisions (as discussed in Chapter 3). Thus,
further, potentially expensive, operations might be necessary to decide the equivalence of
both circuits. Furthermore, the resulting decision diagrams are still exponentially large in
the worst case.
If G and G′ are equivalent, then it holds that G†G′ = I, i.e., concatenating one circuit with
the inverse of the other implements the identity. Since the identity has a perfectly compact
representation as a decision diagram, being linear in the number of qubits (as shown
in Figure 5.1b), the decision diagram for the combined circuit G′G† can be constructed
instead. However, building up the decision diagram of G′G† sequentially from left to
right might still result in an exponentially large decision diagram, since eventually the
whole decision diagram for G′ is constructed in the middle of the computation. The
February 2022
Tom Peham
35/59

2
1
0
initial
layout of G
Q2 ←[ q2
Q1 ←[ q1
Q0 ←[ q0
q2
q1
q0
q2
q1
q0
output
permutation of G
•
•
H
initial
layout of G′
q2 ↦→Q2
q1 ↦→Q1
q0 ↦→Q0
q1
q2
q0
q1
q2
q0
output
permutation of G′
×
×
H
•
•
Permution
change
•
Identity
Linear
Slightly Complex
Large
Exponential
Figure 5.2.: Verifying equivalence with decision diagrams
solution is to start constructing the functionality of the combined circuit from the “middle”
and alternating between applications of G† and G′, such that the decision diagram being
constructed remains as close to the identity as possible [24].
The strategy when to choose gates from which circuit is dictated by an oracle. If more
information about the relation between G and G′ is known, a more sophisticated oracle
can be employed, e.g., for verifying the results of compilation flows [55]. This method
also makes it easier to check equivalence of circuits up to some precision using the inner
product tr(U†U′), since the product U†U′ is inherently constructed during the equivalence
check—saving a potentially expensive decision diagram multiplication.
As discussed in Chapter 3, a compiled circuit might act on different qubits than the original
circuit due to the logical-to-physical qubit mapping. This can be accounted for by tracking
the permutation of each circuit’s qubits throughout the equivalence check and applying
all operators according to that permutation. During this process, any SWAP operation can
be translated to a change of the corresponding permutation. To maximize this potential,
deconstructed SWAP operations (as in Figure 2.4) are reconstructed. In the end, the tracked
permutation is compared to the expected one and SWAP operations are executed to correct
any potential mismatch. In this fashion, circuits with permuted inputs and/or outputs can
be verified using the same methodology. The initial layout and the output permutation
need to be known a-priori in order to properly check the equivalence of circuits.
Example 5.2. Consider the circuits G and G′ shown in Fig. 2.2a and Fig. 2.4, respectively. Fig. 5.2
shows an example of how the two circuits are verified using the decision diagram based approach
described above. Note that the decomposed SWAP has been reconstructed in G′.
February 2022
Tom Peham
36/59

The equivalence checking process starts off with the identity diagram (shown in the middle of
Figure 5.2). Then, gates are applied in an alternating fashion from G† and G′. First, the Hadamard
from G† is applied to the decision diagram. After applying the corresponding Hadamard from G′
the diagram is reduced back to the identity. Then, the CNOT gates on both sides are applied and
the diagram is again back to the identity. After applying the last operation from the left, instead of
applying the SWAP gate to the decision diagram, the tracked permutation of G′ is updated. Because
of the tracked permutation the last CNOT gate on the right-hand side is applied to qubits Q2 and
Q0 instead of Q1 and Q0—again yielding the identity. In the end, the tracked permutation is
compared to the expected one. Because they are identical, no corrections have to be made. Since the
final decision diagram resembles the identity, it can be concluded that the circuits are equivalent.
February 2022
Tom Peham
37/59

6. Case Study
The basic equivalence checking routine in Algorithm 4 is publicly available via the Python
library pyzx [29]. Since pyzx does not support layout permutations, inaccuracies or an-
cillary qubits, and because Python is inherently slower than a compiled programming
language, the ZX-calculus based equivalence checking algorithm has been re-implemented
in C++. This re-implementation has additional features that allow for handling of the men-
tioned problems. The decision diagram based equivalence checker is publicly available
via the Python library QCEC (which is part of the JKQ toolset [60]). Even though both
methods are presented as out-of-the-box solutions, some precautions still have to made
to allow for a fair comparison. To this end, we first describe the experimental setup and,
afterwards, provide a detailed discussion on the obtained results.
6.1. Experimental Setup
While there is no explicit configuration for the ZX-calculus equivalence checker, QCEC
has different methods with their respective parameters based on [24, 56, 54]. For all the
evaluations, we compare the ZX-calculus based equivalence checking routine with the
combined approach as presented in [24]. For QCEC, we run the equivalence checking
routine described in Chapter 5 in parallel with a sequence of 16 simulation runs. If the
simulations manage to prove non-equivalence of the circuits, the equivalence checking
routine is terminated early.
In order to compare both methods, various benchmarks have been considered. QCEC has
been previously evaluated on a benchmark set of reversible circuits (from [61]) which are
mapped to suitable quantum architectures. We also use these in our evaluation as well as
a selection of common quantum circuits.
February 2022
Tom Peham
38/59

All benchmarks are provided in the form of QASM [62] files, which serves as a common
language for both tools. All circuits have been compiled using qiskit-terra 0.18.3, either
with the optimization level O1 or O2 depending on the benchmark set.
For each benchmark we consider three configurations. First, two circuits that are indeed
equivalent are used as input. Then, two instances are created where errors are injected
into one of the circuits—one with a random gate removed and one where the control and
target of one CNOT gate has been swapped.
The benchmark set of reversible circuits is compiled to the to the 65-qubit IBM Manhattan
architecture using optimization level O0 (no optimizations), O1 (slight optimizations) and
O2 (advanced optimizations). The circuits compiled to O1 and O2 were checked against
the unoptimized compiled circuit.
For the quantum circuits we distinguish two use-cases: The first is concerned with veri-
fying the compilation result of a high-level circuit. To this end, the circuits are compiled
to the 65-qubit IBM Manhattan architecture with a gate-set comprised of arbitrary single
qubit rotations and the CNOT gate. The second use-case is about verifying the equivalence
of two different implementations of the same functionality—an original circuit and an
optimized version (O2).
In the following, we summarize the results of our evaluations by means of a representative
subset of benchmarks. The results for the reversible benchmarks are shown in Table 6.1
and Table 6.2. The results for the quantum benchmarks are shown in Table 6.3.
For further analysis on the influence of the size of the circuits on the runtimes of the
equivalence checking routines, we consider a set of random quantum circuits comprised
of CNOT, Hadamard and T gates with specific numbers of qubits and gates. Every gate in
this set of benchmarks has a 20% chance of being a Hadamard gate and a 20% chance of
being a T gate. For this benchmark set only equivalent instances have been considered.
Every circuit has been checked twice, once against a slightly optimized version (O1)
and once against a highly optimized version (O2).The resulting runtimes can be seen in
Figure 6.1 and Figure 6.2.
All computations were conducted on a 4.2 GHz Intel i7-7700K machine running Ubuntu
18.04 and 32 GiB main memory. Each benchmark was run with a hard timeout of 1 h for
each method.
February 2022
Tom Peham
39/59

Table 6.1.: Slightly optimized reversible circuits
Benchmark
Equivalent
1 Gate Missing
Flipped CNOT
Name
n
|G|
|G′|
tzx[s]
tqcec[s]
tzx[s]
tqcec[s]
tzx[s]
tqcec[s]
9symml-195
20
15701
13662
8.04
7.37
2.04
0.12
8.25
0.11
dist-223
20
22778
19458
11.82
11.88
24.65
0.16
9.13
0.17
clip-206
53
23782
20872
12.53
20.49
2.18
0.29
8.92
0.31
hwb7-61
20
14680
12557
13.45
1.56
0.56
0.11
13.68
0.10
life-238
20
12114
10441
13.55
3.78
1.57
0.10
9.92
0.09
hwb7-60
20
14096
12167
19.24
0.83
1.14
0.10
51.74
0.11
alu2-199
53
21474
19007
19.76
28.05
2.04
0.26
19.16
0.29
sym9-193
20
15944
13327
21.70
6.17
1.89
0.11
24.64
0.11
example2-231
53
22017
19411
23.63
18.36
5.12
0.27
25.64
0.25
hwb7-59
20
18435
15616
40.81
2.53
0.75
0.18
20.55
0.15
sym9-148
20
17061
14044
75.53
0.60
6.59
0.11
34.26
0.11
urf2-277
20
33348
30940
76.59
3.36
2.03
0.26
77.75
0.26
add6-196
53
30296
25460
82.48
14.94
3.13
0.38
95.46
0.34
urf2-153
20
55243
47155
214.21
210.77
6.54
0.35
162.52
0.39
hwb8-117
20
23596
20697
259.78
1.54
43.95
0.22
27.28
0.17
hwb8-116
20
23353
20996
274.82
2.68
18.58
0.15
272.41
0.16
urf2-161
20
100189
92597
403.99
5.08
5.48
0.69
25.83
1.32
hwb8-114
20
45079
38733
453.13
38.64
16.01
0.31
40.13
0.36
hwb8-118
20
52692
45784
521.59
63.61
85.34
0.43
617.56
0.39
urf2-154
20
52432
44615
587.01
145.44
7.97
0.54
16.57
0.49
hwb8-115
20
45247
39172
734.52
30.47
9.78
0.28
467.74
0.28
hwb8-113
20
52905
46230
1211.62
68.62
22.03
0.46
1476.73
0.37
urf5-159
20
65250
57099
1325.16
45.17
25.78
0.39
659.13
0.46
plus63mod4096-163
53
94520
82195
>3600
87.94
48.61
1.28
>3600
0.94
plus63mod8192-164
53
125612
111720
>3600
412.22
>3600
1.22
78.41
1.60
urf3-279
20
172651
157462
>3600
416.96
158.13
1.38
>3600
1.50
urf1-150
20
156575
134216
>3600
>3600
51.37
1.06
3084.44
1.34
urf6-281
20
98462
94097
>3600
>3600
604.79
1.30
>3600
1.28
6.2. Discussion
Both methods managed to prove the correct result for all considered circuits where a result
is obtained within the given time frame. As discussed before, this is not guaranteed by the
theory of the ZX-calculus. On the other hand, the question of completeness for the decision
diagram based approach is trivial. Decision diagrams are a canonical representation of a
matrix. Thus, if the combined circuit G†G′ has the identity system matrix, the decision
diagram for G†G′ has to be the identity decision diagram as well.
For the set of reversible benchmarks, the two methods finished within 10 s of each other
for 92 % of benchmark instances in the case of equivalent instances for both optimization
levels. The remaining reversible benchmarks and circuits containing large reversible parts
February 2022
Tom Peham
40/59

Table 6.2.: Highly optimized reversible circuits
Benchmark
Equivalent
1 Gate Missing
Flipped CNOT
Name
n
|G|
|G′|
tzx[s]
tqcec[s]
tzx[s]
tqcec[s]
tzx[s]
tqcec[s]
9symml-195
20
15701
13159
42.82
5.41
1.96
0.13
2.39
0.13
dist-223
20
22778
18721
16.44
11.96
3.45
0.16
2.49
0.17
clip-206
53
23782
21407
11.14
15.65
2.00
0.43
1.37
0.39
hwb7-61
20
14680
12741
34.99
0.52
0.47
0.18
0.46
0.17
life-238
20
12114
9869
8.73
2.80
1.12
0.10
0.69
0.10
alu2-199
53
21474
19080
26.23
4.27
7.00
0.31
6.23
0.36
sym9-193
20
15944
13908
7.76
11.21
1.41
0.14
1.07
0.13
example2-231
53
22017
19207
38.71
51.12
3.13
0.31
3.40
0.31
hwb7-59
20
18435
16027
15.68
1.24
0.46
0.15
0.50
0.16
sym9-148
20
17061
14002
284.87
0.96
1.07
0.11
1.08
0.11
urf2-277
20
33348
29711
68.28
16.10
2.95
0.32
2.68
0.31
add6-196
53
30296
26201
154.88
30.21
10.77
0.45
11.97
0.43
urf2-153
20
55243
46103
296.04
42.08
3.12
0.48
3.18
0.43
hwb8-117
20
23596
20413
123.04
17.21
2.56
0.20
3.03
0.20
hwb8-116
20
23353
20519
323.72
13.97
11.78
0.17
10.28
0.18
urf2-161
20
100189
91018
405.14
122.92
3.11
1.15
3.16
1.33
hwb8-114
20
45079
38398
1263.37
9.11
10.15
0.33
10.63
0.35
hwb8-118
20
52692
44901
712.38
13.65
8.40
0.68
5.93
0.41
urf2-154
20
52432
44306
1150.70
20.02
5.53
0.57
5.54
0.52
hwb8-115
20
45247
38205
269.99
13.15
6.26
0.40
8.26
0.32
hwb8-113
20
52905
45833
1036.07
11.59
15.25
0.41
16.68
0.48
urf5-159
20
65250
56089
2369.23
18.12
21.70
0.52
30.52
0.47
plus63mod4096-163
53
94520
83835
>3600
1249.90
78.66
1.27
73.99
1.12
plus63mod8192-164
53
125612
111258
>3600
>3600
313.11
1.49
300.36
1.61
urf3-279
20
172651
153474
>3600
>3600
40.35
1.40
40.53
1.75
urf1-150
20
156575
132898
>3600
>3600
103.27
1.17
105.97
1.16
urf6-281
20
98462
88750
>3600
>3600
198.70
1.36
187.00
1.32
in their high-level description (such as Grover’s algorithm and the Quantum Random
Walk) favor the decision diagram-based approach. These circuits can be exactly compiled
to polynomially-sized quantum circuits comprised only of Clifford+T gates, i.e., circuits
only using Hadamard (H), Phase (S), CNOT (CX), and T gates. As a consequence, the
respective functionalities (i.e., the system matrices) possess lots of structure that can be
exploited by decision diagrams and, additionally, only feature a very limited set of complex
numbers which limits the effect of numerical instabilities. In contrast, the ZX-calculus
based approach does not benefit from this structure very much.
For circuits containing no or smaller reversible parts (such as the QFT or Quantum
Phase Estimation), the ZX-calculus approach fairs much better in comparison to decision
diagrams. The main obstacle in these cases is that the considered algorithms feature many
rotation gates with arbitrarily small rotation angles. Due to numerical instabilities and
February 2022
Tom Peham
41/59

Table 6.3.: Common quantum algorithms
Benchmark
Equivalent
1 Gate Missing
Flipped CNOT
Name
n
|G|
|G′|
tzx[s]
tqcec[s]
tzx[s]
tqcec[s]
tzx[s]
tqcec[s]
Compiled Circuits
Grover
6
1606
2803
0.39
3.40
0.31
0.04
0.47
0.04
Grover
7
4732
8476
1.24
0.30
3.03
0.14
4.16
0.14
Grover
8
12482
22860
12.15
0.91
5.11
0.42
189.61
0.39
QFT
23
1311
3741
0.06
2.00
0.05
>3600
0.05
902.99
QFT
38
3591
10449
0.32
>3600
0.20
>3600
0.21
>3600
Random-Walk
7
6523
8955
150.36
0.24
9.35
0.14
55.44
0.16
Random-Walk
8
14084
19755
1289.13
0.57
455.58
0.33
687.95
0.31
Random-Walk
9
29325
41942
>3600
1.31
1001.93
0.59
2477.31
0.50
QPE-Exact
22
1217
3006
0.83
0.10
0.78
>3600
0.79
0.82
QPE-Exact
39
3823
11552
3.19
>3600
2.89
>3600
2.92
>3600
GHZ
65
130
493
0.06
<0.01
0.06
<0.01
0.59
0.01
Graph State
62
403
2041
0.36
0.17
0.43
0.17
0.35
0.17
Optimized Circuits
Grover
8
12479
12287
8.00
0.04
2.11
0.24
9.837
0.04
Grover
9
37193
36881
82.9446
0.14
3.02
129.56
145.574
0.17
Grover
10
104977
104501
779.291
0.42
72.05
> 3600
90.68
41.24
Grover
11
308074
307322
2178.13
0.07
2316.00
588.62
2264.67
281.j04
QFT
32
2544
2482
1.43
0.04
1.49
3.57
1.89
14.53
QFT
43
4601
4502
2.86
10.837
2.86
17.78
2.81
1.02
QFT
44
4818
4702
3.01
>3600
3.05
1.27
2.90
1.21
QFT
75
14136
11013
1.23
>3600
1.30
>3600
1.26
>3600
Random-Walk
7
2351
1906
140.90
0.02
11.86
0.10
212.527
0.02
Random-Walk
8
4648
3925
2175.39
0.04
78.91
62.15
149.49
0.11
Random-Walk
9
9249
7987
>3600
0.09
245.39
0.11
>3600
0.11
rounding errors, it might happen that two decision diagram nodes that should be identical
in theory, differ by a small margin in practice. As a consequence, inherent redundancies in
the underlying representations cannot be captured accurately anymore. Thus, while the
resulting decision diagram is very close to the identity with respect to the Hilbert-Schmidt
norm, it might grow exponentially large in the worst case. In contrast, ZX-diagrams are
not susceptible to such exponential growth under numerical errors.
The above observations are similar in the case of non-equivalent instances. Although
runtimes for both methods are generally lower, the relative performances are still similar.
Since the resulting decision diagram is almost guaranteed to not be very close to the
identity during the equivalence check, the alternating scheme discussed cannot be as
efficient as in the equivalent case. Due to this, QCEC resorts to simulations of the circuit
with random inputs which, as shown in [24], are expected to show the non-equivalence
February 2022
Tom Peham
42/59

(a) ZX-calculus equivalence checker O1
(b) QCEC O1
(c) ZX-calculus equivalence checker O2
(d) QCEC O2
Figure 6.1.: Random benchmark runtimes for differing gate count
within a few simulations. Yet, the complexity of decision diagram-based simulation is still
exponential in the worst case. The rewriting approach of the ZX-calculus is less volatile
to errors in the circuit. During the equivalence check, the combined circuit diagram is
simplified as much as possible until no more rules can be applied. Depending on the
severity and kind of error, the procedure stops sooner or later.
What Table 6.3 also shows is the volatility of the decision diagram based approach. Run-
times can increase dramatically for the same type of type of circuit with differing number
of qubits. As soon as the intermediate decision diagram does not admit a compact repre-
sentation, applying gates to it is a costly operation. This volatility is shown more detailed
in the case of random Clifford+T benchmarks. Figure 6.1 and Figure 6.2 show the run-
times of equivalence checking random Clifford+T circuits with increasing gate count and
number of qubits.
In Figure 6.1 the different lines correspond to benchmarks with differing qubit counts.
If a data point is at 3600s in the graph this indicates that the equivalence check took
February 2022
Tom Peham
43/59

(a) ZX-calculus equivalence checker O1
(b) QCEC O1
(c) ZX-calculus equivalence checker O2
(d) QCEC O2
Figure 6.2.: Random benchmark runtimes for differing qubit count
longer than the timeout limit of 3600s or—in the case of decision diagrams— it means
that the memory limit has been exceeded. If after a certain point only timeouts occur,
the corresponding entries are not listed in the plots in order to make them easier to read.
In Figure 6.2 different lines correspond to benchmarks with differing gate counts in the
original circuit. With O1 an average of 0.9% of gates where optimized away. With O2 an
average of 6.1% of gates where optimized away.
Both Figure 6.1 and Figure 6.2 clearly show that the equivalence checking routine based
on the ZX-calculus has a clear correlation between runtime and the size of the circuits,
whether that size is due to the number of gates or qubits. Although there are some simpler
instances where the runtime decreases, the general trend can be clearly seen. Figure 6.1
also further support the claim in [28] that the complexity of Algorithm 3 is between O(n)
and O(n2) where n is the number of gates in the circuit.
On the other hand, the plots for QCEC show no such correlation. Whether QCEC manages
to prove equivalence for a circuit only depends on the specific circuit in question after a
February 2022
Tom Peham
44/59

certain circuits size and complexity has been reached. This is not too surprising—decision
diagrams can blow up to exponential size with respect to the number of qubits. This
volatility can hardly be held against decision diagrams though. After all, Figure 6.1 and
Figure 6.2 show runtimes for random benchmarks, i.e. circuits that do not exhibit much
structure. This volatility is actually a positive feature of the decision diagram based
approach. If this method yields a result at all it usually does so using significantly less
time than the ZX-calculus based method and is therefore able to prove equivalence of
some very large circuits where the worst case complexity of O(n3) of the ZX-calculus
based approach leads to long runtimes.
This shows that the two methods are complementary and are best used in tandem, espe-
cially for more optimized circuits. For circuits with many qubits but a smaller number of
gates, the ZX-calculus based approach performs more favourably. For even larger circuits
the problem itself is too complex to be solved even in polynomial time for the ZX-calculus
based approach. In this case the decision diagram based method might still be able to
show equivalence by keeping the intermediate decision diagrams small. Because the size
of the ZX-diagram during the equivalence check with Algorithm 4 is bounded by the size
of the original circuit (the number of spiders is strictly decreasing) the ZX-calculus based
equivalence checking method has a low memory footprint. It can therefore easily be used
in parallel with the decision diagram based method without using too many resources.
February 2022
Tom Peham
45/59

7. Conclusion
In this work, we examined the viability and effectiveness of the ZX-calculus for equivalence
checking of quantum circuits. By improving the state of the art to be able to handle
inaccurate representations of complex numbers, permutations of the input and output
layout of a circuit and ancillary qubits, we can now verify the results of compilation flows
with the ZX-calculus. We have also discussed the limitations of the ZX-calculus based
approach which prevents it from being a general equivalence checking method.
To give empirical results on the practicality of the ZX-calculus in equivalence checking
we have conducted a case study comparing the ZX-calculus based equivalence checker
with one based on decision diagrams. While they show similar performance in many
cases, they differ in key areas. Decision diagrams show significant benefits for circuits
containing large reversible parts, such as oracles or adders. The sensibility of decision
diagrams to numerical imprecision makes them hard to use on quantum algorithms
that cannot be exactly represented using floating points, such as algorithms relying on
arbitrary rotation angles, due to the potential blow-up of the intermediate representation.
The ZX-calculus based equivalence checking procedure is less sensitive to this and is
useful in showing equivalence in these cases. However, the ZX-calculus tends to be more
suitable for verifying smaller building blocks than whole quantum algorithms due to the
large number of involved gates. In conclusion, we can see that decision diagrams and
the ZX-calculus can serve as complementary approaches for the equivalence checking
problem.
February 2022
Tom Peham
46/59

Bibliography
[1]
Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Infor-
mation. Cambridge University Press, 2010 (cit. on pp. 1, 7, 11, 20).
[2]
Lov K. Grover. “A Fast Quantum Mechanical Algorithm for Database Search”. In:
pacm (1996), pp. 212–219 (cit. on pp. 1, 9).
[3]
Peter W. Shor. “Polynomial-Time Algorithms for Prime Factorization and Discrete
Logarithms on a Quantum Computer”. In: SIAM Journal on Computing (1997) (cit. on
pp. 1, 9).
[4]
M. Cerezo et al. Variational Quantum Algorithms. Dec. 16, 2020. arXiv: 2012.09265
(cit. on p. 1).
[5]
Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. A Quantum Approximate Opti-
mization Algorithm. Nov. 14, 2014. arXiv: 1411.4028 [quant-ph] (cit. on p. 1).
[6]
Dylan Herman et al. A Survey of Quantum Computing for Finance. Jan. 18, 2022. arXiv:
2201.02773 [quant-ph, q-fin] (cit. on p. 1).
[7]
Jacob Biamonte et al. “Quantum Machine Learning”. In: Nature 549.7671 (Sept. 2017),
pp. 195–202. arXiv: 1611.09347 (cit. on p. 1).
[8]
Seyon Sivarajah et al. “T|ket>: A Retargetable Compiler for NISQ Devices”. In:
Quantum Science and Technology (Nov. 11, 2020) (cit. on p. 1).
[9]
Matthew Amy and Vlad Gheorghiu. “Staq—A Full-Stack Quantum Processing
Toolkit”. In: Quantum Science and Technology 5.3 (June 2020), p. 034016 (cit. on p. 1).
[10]
Kaitlin N. Smith and Mitchell A. Thornton. “A Quantum Computational Com-
piler and Design Tool for Technology-Specific Targets”. In: Int’l Symp. on Computer
Architecture. 2019, pp. 579–588 (cit. on p. 1).
[11]
Thomas Häner et al. “A Software Methodology for Compiling Quantum Programs”.
In: Quantum Science and Technology 3.2 (Feb. 2018), p. 020501 (cit. on p. 1).
February 2022
Tom Peham
47/59

[12]
Wakaki Hattori and Shigeru Yamashita. “Quantum Circuit Optimization by Chang-
ing the Gate Order for 2D Nearest Neighbor Architectures”. In: Rc_conf. Rc_conf.
2018, pp. 228–243 (cit. on p. 1).
[13]
Zahra Sasanian and D. Michael Miller. “Reversible and Quantum Circuit Optimiza-
tion: A Functional Approach”. In: Rc_conf. Rc_conf. Ed. by Robert Glück and Tetsuo
Yokoyama. 2013, pp. 112–124 (cit. on p. 1).
[14]
Toshinari Itoko et al. “Optimization of Quantum Circuit Mapping Using Gate
Transformation and Commutation”. In: Integration 70 (Jan. 1, 2020), pp. 43–50 (cit. on
pp. 1, 12).
[15]
Yunseong Nam et al. “Automated Optimization of Large Quantum Circuits with
Continuous Parameters”. In: npj Quantum Information (May 10, 2018) (cit. on pp. 1,
12).
[16]
Benjamin A. Cordier et al. Biology and Medicine in the Landscape of Quantum Advan-
tages. Dec. 16, 2021. arXiv: 2112.00760 [quant-ph, q-bio] (cit. on p. 1).
[17]
Dominik Janzing, Pawel Wocjan, and Thomas Beth. ““Non-identity Check” Is QMA-
complete”. In: International Journal of Quantum Information 03.03 (Sept. 1, 2005),
pp. 463–473 (cit. on pp. 1, 14).
[18]
S. Yamashita and I. L. Markov. “Fast Equivalence-Checking for Quantum Circuits”.
In: Int’l Symp. on Nanoscale Architectures. Int’l Symp. on Nanoscale Architectures.
June 2010 (cit. on pp. 1, 17).
[19]
Robert Wille, Nils Przigoda, and Rolf Drechsler. “A Compact and Efficient SAT
Encoding for Quantum Circuits”. In: Africon. Africon. Sept. 2013 (cit. on pp. 1, 17).
[20]
Xin Hong et al. Approximate Equivalence Checking of Noisy Quantum Circuits. Mar. 22,
2021. arXiv: 2103.11595 [quant-ph]. URL: http://arxiv.org/abs/2103.11595
(cit. on pp. 1, 17).
[21]
George F. Viamontes, Igor L. Markov, and John P. Hayes. “Checking Equivalence of
Quantum Circuits and States”. In: Iccad. Iccad. 2007 (cit. on pp. 1, 17).
[22]
Alexander Cowtan, Will Simmons, and Ross Duncan. A Generic Compilation Strategy
for the Unitary Coupled Cluster Ansatz. July 20, 2020. arXiv: 2007.10515 (cit. on pp. 1,
2, 17, 18).
February 2022
Tom Peham
48/59

[23]
Matthew Amy. “Towards Large-Scale Functional Verification of Universal Quantum
Circuits”. In: International Conference on Quantum Physics and Logic. International
Conference on Quantum Physics and Logic. Jan. 2019 (cit. on pp. 1, 17).
[24]
Lukas Burgholzer and Robert Wille. “Advanced Equivalence Checking for Quantum
Circuits”. In: tcad (2021) (cit. on pp. 1, 17, 36, 38, 42).
[25]
S.-A. Wang et al. “An XQDD-based Verification Method for Quantum Circuits”. In:
Ieice. 2008, pp. 584–594 (cit. on pp. 1, 2, 17, 34).
[26]
John van de Wetering. ZX-calculus for the Working Quantum Computer Scientist.
Dec. 27, 2020. arXiv: 2012.13966 (cit. on pp. 2, 18).
[27]
Ross Duncan et al. Graph-Theoretic Simplification of Quantum Circuits with the ZX-
calculus. Sept. 16, 2019. arXiv: 1902.03178 (cit. on pp. 2, 18, 22, 23, 24, 25, 33).
[28]
Aleks Kissinger and John van de Wetering. “Reducing T-count with the ZX-calculus”.
In: Physical Review A (Aug. 11, 2020) (cit. on pp. 2, 13, 18, 26, 27, 33, 44).
[29]
Aleks Kissinger and John van de Wetering. “PyZX: Large Scale Automated Dia-
grammatic Reasoning”. In: Quantum Physics and Logic. Vol. 318. 2019, pp. 229–241
(cit. on pp. 2, 38).
[30]
George F. Viamontes et al. “Gate-Level Simulation of Quantum Circuits”. In: Aspdac.
Aspdac. 2003, pp. 295–301 (cit. on pp. 2, 34).
[31]
Philipp Niemann et al. “QMDDs: Efficient Quantum Function Representation and
Manipulation”. In: tcad (2016) (cit. on pp. 2, 34, 35).
[32]
D.M. Miller and M.A. Thornton. “QMDD: A Decision Diagram Structure for Re-
versible and Quantum Circuits”. In: Ismvl. Ismvl. 2006 (cit. on pp. 2, 34).
[33]
Alwin Zulehner and Robert Wille. “Advanced Simulation of Quantum Computa-
tions”. In: tcad (2019) (cit. on pp. 2, 34).
[34]
Alwin Zulehner, Stefan Hillmich, and Robert Wille. “How to Efficiently Handle
Complex Values? Implementing Decision Diagrams for Quantum Computing”. In:
Iccad. Iccad. 2019 (cit. on pp. 2, 34).
[35]
Daniel M. Greenberger, Michael A. Horne, and Anton Zeilinger. Going Beyond Bell’s
Theorem. Dec. 6, 2007. arXiv: 0712.0921 (cit. on p. 8).
[36]
M. H. Devoret and R. J. Schoelkopf. “Superconducting Circuits for Quantum In-
formation: An Outlook”. In: Science 339.6124 (Mar. 8, 2013), pp. 1169–1174 (cit. on
p. 8).
February 2022
Tom Peham
49/59

[37]
M. H. Devoret, A. Wallraff, and J. M. Martinis. Superconducting Qubits: A Short
Review. Nov. 6, 2004. arXiv: cond-mat/0411174. URL: http://arxiv.org/abs/cond-
mat/0411174 (visited on 01/31/2022) (cit. on p. 8).
[38]
Scott Aaronson and Daniel Gottesman. “Improved Simulation of Stabilizer Circuits”.
In: Physical Review A 70.5 (Nov. 30, 2004), p. 052328 (cit. on p. 9).
[39]
Simon J. Devitt, Kae Nemoto, and William J. Munro. “Quantum Error Correction
for Beginners”. In: Reports on Progress in Physics 76.7 (July 1, 2013), p. 076001. arXiv:
0905.2794 (cit. on p. 9).
[40]
Daniel Gottesman. “Stabilizer Codes and Quantum Error Correction.” Caltech, 1997
(cit. on p. 9).
[41]
Tommaso Toffoli. “Reversible Computing”. In: Automata, Languages and Programming.
Vol. 85. Springer, 1980, pp. 632–644 (cit. on p. 9).
[42]
Dorit Aharonov. A Simple Proof That Toffoli and Hadamard Are Quantum Universal.
Jan. 9, 2003. arXiv: quant- ph/0301040. URL: http://arxiv.org/abs/quant-
ph/0301040 (visited on 01/31/2022) (cit. on p. 9).
[43]
G. Vidal and C. M. Dawson. “Universal Quantum Circuit for Two-Qubit Transfor-
mations with Three Controlled-NOT Gates”. In: Physical Review A 69.1 (Jan. 8, 2004),
p. 010301 (cit. on p. 10).
[44]
Adriano Barenco et al. “Elementary Gates for Quantum Computation”. In: Physical
Review A (Nov. 1, 1995) (cit. on p. 10).
[45]
Dmitri Maslov. “On the Advantages of Using Relative Phase Toffolis with an Appli-
cation to Multiple Control Toffoli Optimization”. In: Physical Review A 93.2 (Feb. 10,
2016), p. 022311 (cit. on p. 10).
[46]
Robert Wille, Lukas Burgholzer, and Alwin Zulehner. “Mapping Quantum Circuits
to IBM QX Architectures Using the Minimal Number of SWAP and H Operations”.
In: Dac. Dac. 2019 (cit. on p. 10).
[47]
Prakash Murali et al. “Noise-Adaptive Compiler Mappings for Noisy Intermediate-
Scale Quantum Computers”. In: Int’l Conf. on Architectural Support for Programming
Languages and Operating Systems. Int’l Conf. on Architectural Support for Program-
ming Languages and Operating Systems. Apr. 4, 2019 (cit. on p. 10).
February 2022
Tom Peham
50/59

[48]
Gushu Li, Yufei Ding, and Yuan Xie. “Tackling the Qubit Mapping Problem for
NISQ-era Quantum Devices”. In: Int’l Conf. on Architectural Support for Programming
Languages and Operating Systems. Int’l Conf. on Architectural Support for Program-
ming Languages and Operating Systems. 2019 (cit. on p. 10).
[49]
Kesha Hietala et al. A Verified Optimizer for Quantum Circuits. 2019. arXiv: 1912.02250
(cit. on p. 12).
[50]
Bob Coecke and Aleks Kissinger. “Picturing Quantum Processes”. In: Diagrammatic
Representation and Inference. Ed. by Peter Chapman et al. Lecture Notes in Computer
Science. Springer International Publishing, 2018 (cit. on pp. 18, 30).
[51]
Miriam Backens. The ZX-calculus Is Complete for Stabilizer Quantum Mechanics. July 26,
2013. arXiv: 1307.7025 (cit. on p. 22).
[52]
Renaud Vilmart. A Near-Optimal Axiomatisation of ZX-Calculus for Pure Qubit Quan-
tum Mechanics. Dec. 21, 2018. arXiv: 1812.09114 (cit. on p. 22).
[53]
Jacob D. Biamonte and Ville Bergholm. “Tensor Networks in a Nutshell”. In: 2017.
arXiv: 1708.00006 (cit. on p. 30).
[54]
Lukas Burgholzer, Rudy Raymond, and Robert Wille. “Verifying Results of the IBM
Qiskit Quantum Circuit Compilation Flow”. In: Int’l Conf. on Quantum Computing
and Engineering. Int’l Conf. on Quantum Computing and Engineering. 2020 (cit. on
pp. 34, 38).
[55]
Lukas Burgholzer and Robert Wille. “Verifying the Results of Quantum Circuit Com-
pilation Flows”. In: Int’l Workshop on Quantum Compilation (IWQC). Int’l Workshop
on Quantum Compilation (IWQC). 2020 (cit. on pp. 34, 36).
[56]
Lukas Burgholzer, Richard Kueng, and Robert Wille. “Random Stimuli Generation
for the Verification of Quantum Circuits”. In: Aspdac. Aspdac. Jan. 2021 (cit. on
pp. 34, 38).
[57]
Lukas Burgholzer and Robert Wille. “The Power of Simulation for Equivalence
Checking in Quantum Computing”. In: Dac. Dac. 2020 (cit. on p. 34).
[58]
Lukas Burgholzer and Robert Wille. “Improved DD-based Equivalence Checking of
Quantum Circuits”. In: Aspdac. Aspdac. 2020 (cit. on p. 34).
[59]
Robert Wille, Lukas Burgholzer, and Michael Artner. “Visualizing Decision Dia-
grams for Quantum Computing”. In: Date. Date. Feb. 2021 (cit. on p. 35).
February 2022
Tom Peham
51/59

[60]
Robert Wille, Stefan Hillmich, and Lukas Burgholzer. “JKQ: JKU Tools for Quantum
Computing”. In: Iccad. Iccad. 2020 (cit. on p. 38).
[61]
Robert Wille et al. “RevLib: An Online Resource for Reversible Functions and
Reversible Circuits”. In: Ismvl. Ismvl. 2008, pp. 220–225 (cit. on p. 38).
[62]
Andrew W. Cross et al. OpenQASM 3: A Broader and Deeper Quantum Assembly
Language. 2021. arXiv: 2104.14722 [quant-ph] (cit. on p. 39).
February 2022
Tom Peham
52/59

A. Full Simplification of Clifford
ZX-diagram
The following is a step-by-step proof that the ZX-diagrams in Figure 4.2 are equivalent
(up to output permutation) using Algorithm 1. In each step the spiders to which a rule is
applied are marked with a star.
⋆
⋆
=
⋆
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
⋆
(4.8)
=
⋆
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
⋆
(4.8)
=
⋆
⋆
⋆
(4.7)
=
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
(4.8)
=
⋆
⋆
⋆
(4.7)
=
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
⋆
(4.7)
=
⋆
⋆
⋆
⋆
(4.5)
=
⋆
⋆
⋆
(4.8)
=
⋆
⋆=
⋆
⋆
⋆
(id)
=
(hh)
=
February 2022
Tom Peham
53/59

B. Proofs
B.1. Proof of Lemma 3.1
Proof.
(Uanc ⊗I) |ϕ0 · · · ϕn−1c⟩= (Uanc ⊗I)(|ϕ⟩⊗(|c⟩))
= (Uanc |ϕ⟩) ⊗(I |c⟩)
= (
2n−1
∑
i=0
2n−1
∑
j=0
⟨c| ⟨i| U |j⟩|c⟩|i⟩⟨j| |ϕ⟩) ⊗|c⟩
= (
2n−1
∑
i=0
2n−1
∑
j=0
⟨c| ⟨i| U |j⟩|c⟩|i⟩αj) ⊗|c⟩
= (
2n−1
∑
i=0
⟨c| ⟨i| U (
2n−1
∑
j=0
αj |j⟩) |c⟩|i⟩) ⊗|c⟩
= (
2n−1
∑
i=0
⟨c| ⟨i| U (|ϕ⟩|c⟩) |i⟩) ⊗|c⟩
= (
2n−1
∑
i=0
⟨c| ⟨i|
⃓⃓ϕ′⟩︁|c⟩|i⟩) ⊗|c⟩
= (
2n−1
∑
i=0
⟨c| ⟨i|
⃓⃓ϕ′⟩︁|c⟩|i⟩) ⊗|c⟩
= (
2n−1
∑
i=0
⟨c| α′
i |c⟩|i⟩) ⊗|c⟩
= (⟨c| |c⟩
∑
i∈{0,··· ,2n−1}
α′
i |i⟩) ⊗|c⟩
= (⟨c| |c⟩
⃓⃓ϕ′⟩︁) ⊗|c⟩=
⃓⃓ϕ′⟩︁⊗|c⟩=
⃓⃓ϕ′⟩︁|c⟩= U(|ϕ⟩|c⟩)
Here we have used the fact that ⟨c| |c⟩= 1 and ∑2n−1
i=0 ⟨ϕ| |i⟩⟨i| = |ϕ⟩.
February 2022
Tom Peham
54/59

B.2. Proof of Equation (4.10)
We want to show
α
kπ
α1
...
β
jπ
αn
...
...
=
α1
...
(−1)kα+(−1)jβ
αn
...
...
.
Proof. Without loss of generality, assume that j = 0. There are two cases: k = 0 and k = 1.
Since all phases are given modulo 2π these are the only relevant cases.
• Case k = 0:
α
α1
...
β
αn
...
...
(h)
=
α
α1
...
β
αn
...
...
(f)=
α
α1
...
β
αn
...
...
(b)
=
α
α1
...
β
αn
...
...
(f)=
α1
...
α+β
αn
...
...
(h)
=
α1
...
α+β
αn
...
...
• Case k = 1:
α
π
α1
...
β
αn
...
...
(f)=
α
π
α1
...
β
αn
...
...
(h)
=
α
π
α1
...
β
αn
...
...
(π)
=
−α
α1
...
β
αn
...
...
Now we are in the same situation as in the previous case but with a phase of −α and
we obtain the ZX-diagram
α1
...
−α+β
αn
...
...
.
Because the phase gadgets are symmetric, similar reasoning applies when j = 1.
February 2022
Tom Peham
55/59

B.3. Completeness of Algorithm 2 for Clifford Circuits
In order to prove completeness of Algorithm 2 we first need to show that Algorithm 1,
which is responsible for most of the simplifications done in Algorithm 2, transforms each
Clifford ZX-diagram that represents the identity into a special form.
Lemma B.1. Let D be a Clifford ZX-diagram with n inputs and outputs such that JDK = In.
Then the ZX-diagram obtained by simplifying D with Algorithm 1 has the following structure:
...
,
where the two
on each line indicate that there must be exactly one Hadamard box on either
the input or output of a qubit.
Proof. Algorithm 1 removes every interior Clifford spider and since all spiders are Clifford,
there are no more interior spiders left after simplifying. After simplification D must
therefore be of the form
j0π
2
k0π
2
jn−1π
2
kn−1π
2
...
...
...
...
...
,
i.e. a Clifford ZX-diagram with only boundary spiders, where all boundary spiders
(that are in fact connected) are connected via Hadamard edges and where there must
be exactly one Hadamard box on each line. In fact this structure is independent of the
fact that JDK = In — every Clifford ZX-Diagram has this form after simplification with
Algorithm 1. W.l.o.g. assume that the Hadamard boxes are all on the left-hand side and
call this diagram Dsimp
In order to prove Lemma B.1, we need to show ji = ki = 0 for all 0 ≤i < n and that there
are no connections between spiders on different lines. To break this problem into simpler
sub-problems we are going to use the following helpful trick:
February 2022
Tom Peham
56/59

j0π
2
k0π
2
jn−1π
2
kn−1π
2
...
...
...
...
...
(h)
=
j0π
2
k0π
2
jn−1π
2
kn−1π
2
...
...
...
...
...
(c)=
jn−1π
2
kn−1π
2
...
...
...
...
...
(h)
=
jn−1π
2
kn−1π
2
...
...
...
...
...
(f)=
jn−1π
2
kn−1π
2
...
...
...
The spider fusion in the last equality is due to the fact that all spiders in the second row
have a phase of 0 and all the spiders they are connected to are Z-spiders (all spiders in
the diagram are Z-spiders). With this trick we can effectively eliminate a line from the
diagram because the diagram manipulations only effect the connections from the first row
and not the connections between other rows. The rest of the diagram still has to act as the
identity on the rest of the qubits. This is due to the fact that if JDsimpK = J
... K then
j0π
2
k0π
2
jn−1π
2
kn−1π
2
...
...
...
...
...
=
...
.
If two ZX-diagrams have the same interpretation they can be replaced with each other in
every context. This is a simple consequence of the soundness of the ZX-calculus.
With the introduced trick we can effectively reduce Dsimp until only one line remains. In
this case the remaining line
jtπ
2
ktπ
2
still has to represent the identity. We prove
that jt = kt = 0 by concrete calculation of the matrix of the diagram.
J
jtπ
2
ktπ
2
K (h)
= J
jtπ
2
ktπ
2
K = (|+⟩⟨+| + eijt π
2 |−⟩⟨−|)(|0⟩⟨0| + eikt π
2 |1⟩⟨1|) =
1
2
[︄
1 + eijt π
2
(1 −eijt π
2 )eikt π
2
1 −eijt π
2
(1 + eijt π
2 )eikt π
2
]︄
February 2022
Tom Peham
57/59

Since this matrix has to equal
[︄
1
0
0
1
]︄
the constraints force eijt π
2 = eikt π
2 = 1 which can only
be true if jt = kt = 0. Thus we can conclude that all spiders in Dsimp have a phase of 0.
To show that no spiders belonging to different lines can be connected, we use our trick
again. But this time we reduce down to two lines.
The Hadamard edges between spiders on different lines may or may not exist. We are
going to see that for the purpose of this proof we do not need to make a case distinction on
all possible combinations of connections. Using a similar strategy as for the line removal
trick we obtain
(h)
=
(c)=
(h)
=
(f)=
(h)
=
Since this diagram has to be the identity on each line and we input
in the first line and
on the second line, they also have to be the output on their respective lines. But this
can only be the case if the diagonal connection between the first and second line does not
exist. Therefore there is also no connection in the original diagram, i.e. it has to look like
.
Similar reasoning can be applied to conclude that the remaining inter-line connections
cannot exist if the diagram is equal to the identity diagram.
We have proven that all phases in Dsimp are 0 and that there are no connections between
spiders on different lines. Therefore Dsimp looks like
February 2022
Tom Peham
58/59

...
.
Due to symmetry the proof still works if some of the Hadamard boxes are at the outputs.
Using Lemma B.1 we can now proceed to prove Theorem 4.1.
Proof. If G ̸= G′ then it follows immediately from the correctness of the ZX-calculus that
Algorithm 2 outputs False and vice-versa..
If G = G′ then the ZX-diagram D resulting from concatenating the ZX-diagram G† and
G′ also represents the identity, i.e. JDK = I. Since D was constructed from two Clifford
circuits, it is also Clifford. By Lemma B.1, D is simplified by subroutine Algorithm 1 to
...
.
The simplification loop performed after Algorithm 1 removes identity spiders, fuses
spiders and cancels adjacent Hadamard boxes as much as possible. Thus the diagram is
further simplified. W.l.o.g. assume again that all Hadamard boxes are on the left-hand
side. Then,
...
(id)
=
...
(hh)
=
...
Since this diagram is comprised of only bare wires, Algorithm 2 outputs True.
February 2022
Tom Peham
59/59

