BRICS NS-01-2
Brookes & Mislove (eds.): MFPS ‚Äô01 Preliminary Proceedings
BRICS
Basic Research in Computer Science
Preliminary Proceedings of the 17th Annual Conference on
Mathematical Foundations
of Programming Semantics
MFPS ‚Äô01
Aarhus, Denmark, May 24‚Äì27, 2001
Stephen Brookes
Michael Mislove
(editors)
BRICS Notes Series
NS-01-2
ISSN 0909-3206
May 2001

Copyright c‚Éù2001,
Stephen Brookes & Michael Mislove
(editors).
BRICS, Department of Computer Science
University of Aarhus. All rights reserved.
Reproduction of all or part of this work
is permitted for educational or research use
on condition that this copyright notice is
included in any copy.
See back inner page for a list of recent BRICS Notes Series publications.
Copies may be obtained by contacting:
BRICS
Department of Computer Science
University of Aarhus
Ny Munkegade, building 540
DK‚Äì8000 Aarhus C
Denmark
Telephone: +45 8942 3360
Telefax:
+45 8942 3255
Internet:
BRICS@brics.dk
BRICS publications are in general accessible through the World Wide
Web and anonymous FTP through these URLs:
http://www.brics.dk
ftp://ftp.brics.dk
This document in subdirectory NS/01/2/

Electronic Notes in Theoretical Computer Science
Volume 45
Mathematical Foundations of Programming Semantics
Seventeenth Annual Conference
Aarhus University
Aarhus, Denmark
May 23 ‚Äì 26, 2001
Guest Editors:
S. Brookes
M. Mislove
Preliminary Proceedings
Final Proceedings will be available at
http://www.elsevier.nl/locate/entcs/volume45.html

ii

Table of Contents
Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . v
Dedication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .vii
A Relationship between Equilogical Spaces and Type Two EÔ¨Äectivity. . . . . . . . . . . .1
Andrej Bauer
Transfer Principles for Reasoning About Concurrent Programs . . . . . . . . . . . . . . . . 23
Stephen Brookes
Time Stamps for Fixed-Point Approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
Daniel Damian
A New Approach to Quantitative Domain Theory. . . . . . . . . . . . . . . . . . . . . . . . . . . . .55
Lei Fan
A Concurrent Graph Semantics For Mobile Ambients . . . . . . . . . . . . . . . . . . . . . . . . . 67
Fabio Gadducci & Ugo Montanari
Regular-Language Semantics for a Call-by-Value Programming Language . . . . . . 85
Dan R. Ghica
Typing Correspondence Assertions for Communication Protocols. . . . . . . . . . . . . . .99
Andrew D. Gordon & Alan JeÔ¨Ärey
Pseudo-commutative Monads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
Martin Hyland & John Power
Stably Compact Spaces and Closed Relations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .133
Achim Jung, Mathias Kegelmann & M. Andrew Moshier
A Game Semantics of Idealized CSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
J. Laird
Unique Fixed Points in Domain Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Keye Martin
A Generalisation of Stationary Distributions, and Probabilistic Program Algebra
189
A. K. McIver
A Selective CPS Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
Lasse R. Nielsen
iii

Semantics for Algebraic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
Gordon Plotkin & John Power
An Algebraic Foundation for Graph-based Diagrams in Computing. . . . . . . . . . . .237
John Power & Kostantinos Tourlas
Comparing Control Constructs by Double-barrelled CPS Transforms . . . . . . . . . . 249
Hayo Thielecke
Distance and Measurement in Domain Theory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .265
Pawel Waszkiewicz
iv

Foreword
These are the preliminary proceedings of the Seventeenth Conference on the Math-
ematical Foundations of Programming Semantics. The meeting consists of seven
invited talks, given by the following:
Olivier Danvy
Joshua Guttman
BRICS
Mitre
Neil Jones
Kim Larsen
DIKU
Aalborg
Prakash Panangaden
Jan Rutten
McGill
CWI
Glynn Winskel
Cambridge
There also are three special sessions, whose topics are:
‚Ä¢ A session honoring Neil Jones, organized by Olivier Danvy and David
Schmidt. This session begins with an invited address by Professor Danvy,
and includes talks by Radhia Cousot, John Hannan, John Hughes,
David Schmidt and Peter Sestoft.
‚Ä¢ A session on model checking organized by Gavin Lowe. This commences
with an invited talk by Kim Larsen, and includes talks by Jos¬¥e Deshar-
nais, Michael Huth, Henrik Jensen, Marta Kwiatkowska, and
Gavin Lowe,
‚Ä¢ A session on security, organized by Catherine Meadows.
This com-
mences with an invited talk by Joshua Guttman, and includes talks by An-
drew Gordon and Alan Jeffrey, Gavin Lowe, Thomas Jensen,
Catherine Meadows, and Andre Scedrov.
The remainder of the program is made up of papers selected by the Program Com-
mittee from those selected from the submission in response to the Call for Papers.
The Program Committee was co-chaired by Stephen Brookes and Michael
Mislove, and included
Lars Birkedal
Rance Cleaveland
ITU
SUNY, Stony Brook
Marcelo Fiore
Matthew Hennessy
Cambridge
Sussex
Alan Jeffrey
Achim Jung
DePaul
Birmingham
Gavin Lowe
Catherine Meadows
Oxford
NRL
Peter O‚ÄôHearn
Susan Older
Queen Mary & WestÔ¨Åeld
Syracuse
v

Dusco Pavlovic
Uday Reddy
Kestrel
Birmingham
Giuseppe Rosolini
Davide Sangiorgi
Genoa
INRIA
Andre Scedrov
Pennsylvania
This year‚Äôs meeting is being hosted by Aarhus University, with the local arrangements
being carried out by Professors Olivier Danvy and Andrzej Filinski. We are grateful
to these colleagues for their having so eÔ¨Éciently overseen the local arrangements.
The Organizers also express their appreciation to Karen Kj√¶r M√∏ller, the chief
secretary at BRICS for her help with the meeting.
The meeting is being supported by BRICS and by the U. S. OÔ¨Éce of Naval
Research. We are grateful to both organizations for making the meeting possible,
and we especially thank Dr. R. F. Wachter at ONR who has provided continued
support for the MFPS series.
Stephen Brookes
Michael Mislove
Conference Co-chairs
vi

Dedication
The Organizers of the MFPS series dedicate these Proceedings to Neil Jones
for his continuing inspiration to researchers in theoretical computer science. Neil
has been a regular participant in the MFPS series, having been one of the invited
speakers at the 1987 meeting, and having regularly participated in the series. MFPS
appreciates the continued inspiration that his research results have provided, and
that his talks at MFPS have so clearly elucidated.
vii


MFPS
17
Preliminary
Version
A
Relationship
b
et
w
een
Equilogical
Spaces
and
T
yp
e
Tw
o
Eectivit
y
Andrej
Bauer
1
Institut
Mittag-L
eer
The
R
oyal
Swe
dish
A
c
ademy
of
Scienc
es
Abstract
In
this
pap
er
I
compare
t
w
o
w
ell
studied
approac
hes
to
top
ological
seman
tics|
the
domain-theoretic
approac
h,
exemplied
b
y
the
category
of
coun
tably
based
equilogical
spaces,
Equ,
and
T
yp
e
Tw
o
Eectivit
y
,
exemplied
b
y
the
category
of
Baire
space
represen
tations,
Rep
(B
).
These
t
w
o
categories
are
b
oth
lo
cally
cartesian
closed
extensions
of
coun
tably
based
T
0
-spaces.
A
natural
question
to
ask
is
ho
w
they
are
related.
First,
w
e
sho
w
that
Rep(B
)
is
equiv
alen
t
to
a
full
coreectiv
e
sub
category
of
Equ,
consisting
of
the
so-called
0-equilogical
spaces.
This
establishes
a
pair
of
adjoin
t
functors
b
et
w
een
Rep(B
)
and
Equ.
The
inclusion
Rep(B
)
!
Equ
and
its
coreection
ha
v
e
man
y
desirable
prop
erties,
but
they
do
not
preserv
e
exp
onen
tials
in
general.
This
means
that
the
cartesian
closed
structures
of
Rep(B
)
and
Equ
are
essen
tially
dieren
t.
Ho
w
ev
er,
in
a
second
comparison
w
e
sho
w
that
Rep(B
)
and
Equ
do
share
a
common
cartesian
closed
sub
category
that
con
tains
all
coun
tably
based
T
0
-spaces.
Therefore,
the
domain-theoretic
approac
h
and
TTE
yield
equiv
alen
t
top
ological
seman
tics
of
computation
for
all
higher-order
t
yp
es
o
v
er
coun
tably
based
T
0
-spaces.
W
e
consider
sev
eral
examples
in
v
olving
the
natural
n
um
b
ers
and
the
real
n
um
b
ers
to
demonstrate
ho
w
these
comparisons
mak
e
it
p
ossible
to
transfer
results
from
one
setting
to
another.
1
In
tro
duction
In
this
pap
er
I
compare
t
w
o
approac
hes
to
top
ological
seman
tics|the
domain-
theoretic
approac
h,
exemplied
b
y
the
category
of
coun
tably
based
e
quilo
gic
al
sp
ac
es
[6,23],
Equ,
and
T
yp
e
Two
Ee
ctivity
(TTE)
[27,26,25
,14],
exemplied
b
y
the
category
of
Bair
e
sp
ac
e
r
epr
esentations,
Rep(B
).
These
framew
orks
ha
v
e
b
een
extensiv
ely
studied,
alb
eit
b
y
t
w
o
somewhat
separate
researc
h
com-
m
unities.
The
presen
t
pap
er
relates
the
t
w
o
approac
hes
and
helps
transfer
results
b
et
w
een
them.
1
E-mail:
Andrej.Bauer@an
dre
j.
co
m,
URL:
http://andrej.co
m
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Ba
uer
Domain-theoretic
mo
dels
of
computation
arise
from
the
idea
that
the
re-
sult
of
a
(p
ossibly
innite)
computation
is
appr
oximate
d
b
y
the
nite
stages
of
the
computation.
As
the
computation
progresses,
the
nite
stages
appro
x-
imate
the
nal
result
ev
er
so
b
etter.
This
leads
to
a
form
ulation
of
partially
ordered
spaces,
called
domains,
in
whic
h
ev
ery
elemen
t
is
the
suprem
um
of
the
distinguished
\nite"
elemen
ts
that
are
b
elo
w
it.
W
e
recommend
[1]
and
[24
]
for
an
in
tro
duction
to
domain
theory
.
The
TTE
framew
ork
arises
from
the
study
of
(p
ossibly
innite)
computa-
tions
p
erformed
b
y
T
uring
mac
hines
that
read
innite
input
tap
es
and
write
results
on
innite
output
tap
es.
If
w
e
view
input
and
output
tap
es
as
a
se-
quences
of
natural
n
um
b
ers,
then
T
uring
mac
hines
corresp
ond
to
computable
partial
op
erators
on
the
Baire
space
B
=
N
N
.
W
e
obtain
a
purely
top
ological
mo
del
of
computation
b
y
considering
all
c
ontinuous
partial
op
erators
on
B
,
not
just
the
computable
ones.
W
e
recommend
[27]
for
an
in
tro
duction
to
TTE.
The
use
of
equilogical
spaces
as
an
exemplication
of
the
domain-theoretic
approac
h
to
top
ological
seman
tics
needs
an
explanation.
Already
in
the
orig-
inal
man
uscript
[23]
Scott
sho
w
ed
that
equilogical
spaces
are
equiv
alen
t
to
partial
equiv
alence
relations
(PERs)
on
algebraic
lattices.
He
also
pro
v
ed
that
the
category
of
algebraic
domains
is
a
cartesian
closed
sub
category
of
equilogical
spaces,
and
it
is
not
hard
to
see
that
the
same
holds
for
con
tin
u-
ous
lattices.
In
[6,5]
w
e
sho
w
ed
that
equilogical
spaces
are
a
generalization
of
domain
theory
with
totalit
y
[9,8
,7,20,21].
The
crucial
observ
ation
needed
for
those
results
is
that
equilogical
spaces
are
equiv
alen
t
to
the
category
of
dense
PERs
on
algebraic
domains
(a
PER
on
a
domain
is
said
to
b
e
dense
if
its
ex-
tension
is
a
dense
subset
of
the
domain).
The
equiv
alence
remains
if
w
e
tak
e
dense
PERs
on
con
tin
uous
domains
instead.
In
this
sense,
it
is
fair
to
sa
y
that
equilogical
spaces
generalize
sev
eral
domain-theoretic
framew
orks
and
con
tain
a
n
um
b
er
of
imp
ortan
t
categories
of
domains
that
ha
v
e
b
een
studied,
but
of
course
not
all
of
them.
In
this
pap
er
w
e
fo
cus
solely
on
the
coun
tably
based
equilogical
spaces,
and
call
them
simply
\equilogical
spaces".
As
the
am
bien
t
category
of
TTE
w
e
tak
e
the
category
of
Baire
space
repre-
sen
tations,
Rep
(B
),
whic
h
is
dened
in
Section
3.
Con
temp
orary
form
ulations
of
TTE
often
use
the
Can
tor
space
in
place
of
the
Baire
space,
but
since
w
e
are
not
concerned
with
computational
complexit
y
here,
it
do
es
not
matter
whic
h
one
w
e
use
b
ecause
they
yield
in
equiv
alen
t
categories.
W
e
call
Baire
space
represen
tations
just
\represen
tations".
Equilogical
spaces
and
represen
tations
b
oth
form
lo
cally
cartesian
closed
extensions
of
the
category
of
coun
tably
based
T
0
-spaces,
!
T
op
0
.
Th
us
they
are
b
oth
app
ealing
mo
dels
of
computation
on
top
ological
spaces.
This
is
wh
y
it
is
imp
ortan
t
from
the
programming
seman
tics
p
oin
t
of
view
to
understand
precisely
ho
w
they
are
related.
The
general
framew
ork
within
whic
h
w
e
carry
out
the
comparison
is
realiz-
abilit
y
theory
,
since
Equ
and
PER(B
)
are
just
realizabilit
y
mo
dels;
the
former
is
equiv
alen
t
to
the
PER
mo
del
on
the
Scott-Plotkin
graph
mo
del
P
N
,
whereas
2

Ba
uer
the
latter
is
equiv
alen
t
to
the
PER
mo
del
on
the
Second
Kleene
Algebra
B
.
W
e
can
then
use
Longley's
theory
of
applicativ
e
morphisms
b
et
w
een
partial
com-
binatory
algebras
(PCAs)
to
compare
the
t
w
o
PER
mo
dels
[17].
While
this
ma
y
b
e
the
most
general
and
elegan
t
tec
hnique
that
could
b
e
used
to
compare
other
seman
tic
framew
orks
as
w
ell,
it
has
a
distinctly
an
ti-top
ological
a
v
or.
But
w
e
can
translate
all
the
results
from
realizabilit
y
bac
k
in
to
the
language
of
top
ology
,
whic
h
is
precisely
what
w
e
do.
This
immediately
giv
es
us
the
rst
result:
a
simple
top
ological
description
of
Rep(B
),
without
an
y
men
tion
of
the
partial
com
binatory
structure
of
the
Second
Kleene
Algebra.
F
rom
the
top
ological
description
of
Rep(B
)
so
obtained,
it
is
apparen
t
that
Rep(B
)
is
equiv
alen
t
to
a
full
sub
category
of
Equ.
This
sub
category
is
denoted
b
y
0Equ
and
consists
of
all
the
0-e
quilo
gic
al
sp
ac
es,
whic
h
are
those
equilogical
spaces
whose
underlying
top
ological
spaces
are
0-dimensional.
The
inclusion
I
:
0Equ
!
Equ
has
a
coreection
D
:
Equ
!
0Equ.
These
t
w
o
functors
ha
v
e
man
y
desirable
prop
erties,
but
they
do
not
preserv
e
the
function
spaces
in
general.
W
e
compare
Equ
and
Rep(B
)
in
another
w
a
y
,
b
y
demonstrating
that
they
share
a
common
cartesian
closed
sub
category
that
con
tains
all
coun
tably
based
T
0
-spaces.
This
sub
category
w
as
disco
v
ered
b
y
Menni
and
Simpson
[19
,18]
as
the
category
of
!
-pr
oje
cting
T
0
-quotients,
and
b
y
Sc
hr
oder
[22
]
as
the
category
of
se
quential
T
0
-sp
ac
es
with
admissible
r
epr
esentations.
W
e
pro
v
e
that
these
t
w
o
categories
coincide.
Therefore,
the
domain-theoretic
approac
h
and
TTE
yield
equiv
alen
t
top
ological
seman
tics
of
computation
for
all
higher-order
t
yp
es
o
v
er
coun
tably
based
T
0
-spaces.
Finally
,
w
e
discuss
v
arious
consequences
and
the
p
oten
tial
for
transfer
of
results
b
et
w
een
the
t
w
o
settings,
in
particular
with
resp
ect
to
the
natural
n
um
b
ers,
the
real
n
um
b
ers,
and
their
higher-order
function
spaces.
The
pap
er
is
organized
as
follo
ws.
In
Section
1
w
e
review
the
basic
def-
initions
and
facts
ab
out
equilogical
spaces
and
!
-pro
jecting
quotien
ts.
In
Section
3
w
e
review
Baire
space
represen
tations
and
admissible
represen
ta-
tions.
Sections
4
and
5
con
tain
the
t
w
o
comparisons
of
Equ
and
Rep(B
).
In
Section
6
w
e
obtain
v
arious
transfer
results
b
et
w
een
the
t
w
o
settings.
The
material
presen
ted
here
is
part
of
m
y
Ph.D.
dissertation
[4],
written
under
the
sup
ervision
of
Dana
Scott.
The
omitted
pro
ofs
can
b
e
found
in
the
dissertation.
I
gratefully
ac
kno
wledge
helpful
discussions
ab
out
this
topic
with
Stev
en
Aw
o
dey
,
Lars
Birk
edal,
P
eter
Lietz,
Alex
Simpson,
Matthias
Sc
hr
oder,
and
Dana
Scott.
P
eter
and
I
found
the
equiv
alence
of
0-equilogical
spaces
and
Baire
space
represen
tations
together.
I
could
ha
v
e
nev
er
pro
v
ed
the
coinci-
dence
of
!
-pro
jecting
quotien
ts
and
admissible
represen
tations
without
talking
to
Matthias
and
Alex.
I
also
thank
the
kno
wledgeable
anon
ymous
referee
for
helpful
suggestions
on
ho
w
to
b
etter
presen
t
the
material.
3

Ba
uer
2
Equilogical
Spaces
and
!
-pro
jecting
Quotien
ts
An
e
quilo
gic
al
sp
ac
e
w
as
dened
b
y
Scott
[23
,6]
to
b
e
a
T
0
-space
with
an
equiv
alence
relation.
Here
w
e
are
only
in
terested
in
c
ountably
b
ase
d
e
quilo
g-
ic
al
sp
ac
es,
whic
h
are
coun
tably
based
T
0
-spaces
with
equiv
alence
relations.
W
e
denote
the
category
of
coun
tably
based
T
0
-spaces
and
con
tin
uous
maps
b
y
!
T
op
0
.
W
e
omit
the
qualier
\coun
tably
based"
from
no
w
on,
unless
w
e
are
explicitly
dealing
with
spaces
that
are
not
coun
tably
based.
More
precisely
,
an
equilogical
space
is
a
pair
X
=
(jX
j;

X
)
where
jX
j
2
!
T
op
0
and

X
is
an
equiv
alence
relation
on
the
underlying
set
of
jX
j.
The
asso
ciate
d
quotient
of
an
equilogical
space
X
is
the
top
ological
quotien
t
kX
k
=
jX
j=
X
.
The
canonical
quotien
t
map
jX
j
!
kX
k
is
denoted
b
y
q
X
.
Note
that
kX
k
need
not
b
e
T
0
or
coun
tably
based.
A
morphism
f
:
X
!
Y
b
et
w
een
equilogical
spaces
X
and
Y
is
a
con
tin
uous
map
f
:
kX
k
!
kY
k
that
is
tr
acke
d
b
y
some
(not
necessarily
unique)
con
tin
uous
map
g
:
jX
j
!
jY
j,
whic
h
means
that
the
follo
wing
diagram
comm
utes:
jX
j
g
/
q
X

jY
j
q
Y

kX
k
f
/
kY
k
An
y
map
g
that
app
ears
in
the
top
ro
w
of
suc
h
a
diagram
is
e
quivariant,
or
extensional,
meaning
that,
for
all
x;
y
2
jX
j,
x

X
y
implies
g
x

Y
g
y
.
2
The
category
of
equilogical
spaces
and
morphisms
b
et
w
een
them
is
denoted
b
y
Equ.
An
exp
onential
of
X
and
Y
is
an
ob
ject
E
=
Y
X
with
a
morphism
e
:
E

X
!
Y
,
called
the
evaluation
map,
suc
h
that,
for
all
Z
and
f
:
Z

X
!
Y
,
there
exists
a
unique
map
e
f
:
Z
!
E
,
called
the
tr
ansp
ose
of
f
,
suc
h
that
the
follo
wing
diagram
comm
utes:
E

X
e
"E
E
E
E
E
E
E
E
E
E
E
E
E
E
Z

X
e
f

1
X
O
f
/
Y
A
we
ak
exp
onential
is
dened
in
the
same
w
a
y
but
without
the
uniqueness
requiremen
t
for
e
f
.
A
category
is
said
to
b
e
c
artesian
close
d
when
it
has
the
terminal
ob
ject,
nite
pro
ducts,
and
all
exp
onen
tials.
It
is
lo
c
al
ly
c
artesian
close
d
when
ev
ery
slice
is
cartesian
closed.
2
W
e
could
dene
morphisms
b
et
w
een
equilogical
spaces
to
b
e
equiv
alence
classes
of
equiv-
arian
t
maps,
whic
h
is
the
original
denition
from
[23
].
4

Ba
uer
The
category
Equ
is
equiv
alen
t
to
the
PER
mo
del
PER
(P
N
)
[4,
Theo-
rem
4.1.3],
whic
h
is
a
regular
lo
cally
cartesian
closed
category
.
This
equiv
a-
lence
giv
es
us
a
description
of
exp
onen
tials
in
Equ,
though
a
v
ery
impractical
one.
A
somewhat
b
etter
description
can
b
e
obtained
as
follo
ws.
Supp
ose
X
and
Y
are
equilogical
spaces,
and
(W
;
e)
is
a
w
eak
exp
onen
tial
of
jX
j
and
jY
j
in
!
T
op
0
.
Dene
a
relation

E
on
W
b
y
f

E
g
(
)
8
x;
y
2
jX
j
:
(
x

X
y
=
)
e(f
;
x)

Y
e(g
;
y
))
:
Let
E
=
(jE
j;

E
)
b
e
the
equilogical
space
whose
underlying
space
is
jE
j
=

f
2
W


f

E
f
	

W
:
It
is
easy
to
c
hec
k
that
E
with
the
morphism
induced
b
y
the
ev
aluation
map
e
:
jE
j

jX
j
!
jY
j
is
the
exp
onen
tial
of
X
and
Y
[4,
Prop
osition
4.1.7].
The
category
!
T
op
0
has
w
eak
exp
onen
tials,
th
us
the
follo
wing
construction
sho
ws
that
Equ
has
exp
onen
tials.
It
w
ould
b
e
desirable
to
ha
v
e
a
go
o
d
theory
of
w
eak
exp
onen
tials
of
top
ological
spaces,
as
that
w
ould
giv
e
us
b
etter
descriptions
of
exp
onen
tials
in
Equ.
In
certain
cases
(w
eak)
exp
onen
tials
ha
v
e
go
o
d
descrip-
tions.
F
or
example,
if
jX
j
is
lo
cally
compact
and
Hausdor,
then
the
space
of
con
tin
uous
maps
W
=
C
(jX
j;
jY
j)
with
the
compact-op
en
top
ology
together
with
the
usual
ev
aluation
map
is
an
exp
onen
tial
of
jX
j
and
jY
j
in
!
T
op
0
.
Ev
ery
coun
tably
based
T
0
-space
X
can
b
e
view
ed
as
an
equilogical
space
(X
;
=
X
)
where
=
X
is
equalit
y
on
X
.
This
denes
a
full
and
faithful
inclusion
functor
I
:
!
T
op
0
!
Equ
.
The
inclusion
preserv
es
nite
limits,
copro
ducts,
and
all
exp
onen
tials
that
already
exist
in
!
T
op
0
.
Preserv
ation
of
exp
onen
tials
follo
ws
directly
from
the
ab
o
v
e
description
of
exp
onen
tials
in
Equ.
There
is
the
asso
ciate
d
quotient
functor
Q
:
Equ
!
T
op
that
maps
an
equilogical
space
X
to
the
asso
ciated
quotien
t
QX
=
kX
k
and
a
morphism
f
:
X
!
Y
to
the
con
tin
uous
map
Qf
=
f
:
kX
k
!
kY
k.
Here
T
op
is
the
category
of
al
l
top
ological
spaces
and
con
tin
uous
maps,
b
ecause
the
asso
ciated
quotien
t
need
not
b
e
coun
tably
based
or
T
0
.
Clearly
,
Q
is
a
faithful
functor,
and
it
is
not
hard
to
o
see
that
it
is
not
full.
Menni
and
Simpson
[19,18
]
sho
w
ed
that
there
is
a
largest
sub
category
C
of
Equ
suc
h
that
Q
restricted
to
C
is
full.
They
w
ork
ed
with
equilogical
spaces
built
from
all
coun
tably
based
top
ological
spaces,
as
opp
osed
to
just
T
0
-spaces,
but
their
results
hold
when
w
e
restrict
them
to
T
0
-spaces.
W
e
are
restricting
to
T
0
-spaces
b
ecause
Sc
hr
oder
pro
v
ed
his
results
for
T
0
-spaces.
Belo
w
w
e
summarize
the
relev
an
t
ndings
from
[19
,18].
Denition
2.1
A
subset
S

X
of
a
top
ological
space
X
is
se
quential
ly
op
en
when
ev
ery
sequence
with
limit
in
S
is
ev
en
tually
in
S
.
A
top
ological
space
X
is
a
se
quential
sp
ac
e
when
ev
ery
sequen
tially
op
en
set
V

X
is
op
en
in
X
.
The
category
of
sequen
tial
spaces
and
con
tin
uous
maps
b
et
w
een
them
is
denoted
b
y
Seq.
5

Ba
uer
Theorem
2.2
Se
quential
sp
ac
es
form
a
c
artesian
close
d
c
ate
gory
that
c
on-
tains
!
T
op
0
.
The
inclusion
!
T
op
0
!
Seq
pr
eserves
nite
limits
and
al
l
exp
o-
nentials
that
alr
e
ady
exist
in
!
T
op
0
.
Pro
of.
This
is
w
ell
kno
wn
and
follo
ws
from
the
fact
that
Seq
is
a
reectiv
e
sub
category
of
the
cartesian-closed
category
Lim
of
limit
sp
ac
es
[15],
and
the
reection
preserv
es
pro
ducts.
2
Denition
2.3
Let
X
2
!
T
op
0
and
q
:
X
!
Y
b
e
a
con
tin
uous
map.
Then
q
is
said
to
b
e
!
-pr
oje
cting
when
for
ev
ery
Z
2
!
T
op
0
and
ev
ery
con
tin
uous
map
f
:
Z
!
Y
there
exists
a
lifting
g
:
Z
!
X
suc
h
that
f
=
q
√Ü
g
.
An
equilogical
space
X
is
!
-pr
oje
cting
when
the
canonical
quotien
t
map
q
X
:
jX
j
!
kX
k
is
!
-pro
jecting.
The
full
sub
category
of
Equ
on
the
!
-
pro
jecting
equilogical
spaces
is
denoted
b
y
EPQ
0
.
Let
PQ
0
b
e
the
category
of
those
T
0
-spaces
Y
for
whic
h
there
exists
an
!
-pro
jecting
map
q
:
X
!
Y
.
The
name
PQ
0
stands
for
\!
-pro
jecting
quotien
t",
and
EPQ
0
stands
for
\equilogical
!
-pro
jecting
quotien
t".
Theorem
2.4
(Menni
&
Simpson
[19])
The
c
ate
gory
PQ
0
is
a
c
artesian
close
d
sub
c
ate
gory
of
Seq
,
EPQ
0
is
a
c
artesian
close
d
sub
c
ate
gory
of
Equ
,
and
the
c
ate
gories
PQ
0
and
EPQ
0
ar
e
e
quivalent
via
the
r
estriction
of
the
asso
ciate
d
quotient
functor
Q
:
EPQ
0
!
PQ
0
.
Pro
of.
See
[19].
In
fact,
Menni
and
Simpson
pro
v
e
that
PQ
0
is
the
largest
common
sub
category
C
of
Equ
and
T
op
suc
h
that
Q
restricted
to
C
is
full.
2
3
T
yp
e
Tw
o
Eectivit
y
In
this
section
w
e
review
the
basic
setup
of
T
yp
e
Tw
o
Eectivit
y
.
The
Baire
space
B
=
N
N
is
the
set
of
all
innite
sequences
of
natural
n
um
b
ers,
equipp
ed
with
the
pro
duct
top
ology
.
Let
N

b
e
the
set
of
all
nite
sequences
of
natural
n
um
b
ers.
The
length
of
a
nite
sequence
a
is
denoted
b
y
jaj.
If
a;
b
2
N

w
e
write
a
v
b
when
a
is
a
prex
of
b.
Similarly
,
w
e
write
a
v

when
a
is
a
prex
of
an
innite
sequence

2
B
.
A
coun
table
top
ological
base
for
B
consists
of
the
basic
op
en
sets,
for
a
2
N

,
a::B
=

a::



2
B
	
=


2
B


a
v

	
:
The
expression
a::
denotes
the
concatenation
of
the
nite
sequence
a
2
N

with
the
innite
sequence

2
B
.
W
e
write
n::

instead
of
[n]::
for
n
2
N
and

2
B
.
The
base

a::B


a
2
N

	
is
a
clop
en
coun
table
base
for
the
top
ology
of
B
,
whic
h
means
that
B
is
a
coun
tably
based
0-dimensional
T
0
-space.
Recall
that
a
space
is
0-dimensional
when
its
clop
en
subsets
form
a
base
for
its
top
ology
.
A
0-dimensional
T
0
-space
is
alw
a
ys
Hausdor.
In
order
to
obtain
a
simple
top
ological
description
of
Baire
space
represen-
tations,
w
e
need
to
c
haracterize
subspaces
of
B
and
those
partial
con
tin
uous
6

Ba
uer
maps
B
*
B
that
can
b
e
enco
ded
as
elemen
ts
of
B
.
This
is
accomplished
b
y
the
Em
b
edding
and
Extension
Theorems
for
B
,
whic
h
w
e
pro
v
e
next.
Theorem
3.1
(Em
b
edding
Theorem
for
B
)
A
top
olo
gic
al
sp
ac
e
is
a
0-
dimensional
c
ountably
b
ase
d
T
0
-sp
ac
e
if,
and
only
if,
it
emb
e
ds
into
B
.
Pro
of.
Clearly
,
ev
ery
subspace
of
B
is
a
coun
tably
based
0-dimensional
T
0
-
space.
Supp
ose
X
is
a
coun
tably
based
0-dimensional
T
0
-space
with
a
coun
t-
able
base

U
k


k
2
N
	
of
clop
en
sets.
Dene
the
map
e
:
X
!
B
b
y
ex
=
n
2
N
:
(
if
x
2
U
n
then
1
else
0)
:
It
is
easy
to
c
hec
k
that
e
is
a
top
ological
em
b
edding.
2
F
or
top
ological
spaces
X
and
Y
,
a
partial
map
f
:
X
*
Y
is
said
to
b
e
c
ontinuous
when
the
restriction
to
its
domain
f
:
dom(f
)
!
Y
is
a
con
tin
uous
(total)
map,
where
dom(f
)
is
equipp
ed
with
the
subspace
top
ology
inherited
from
X
.
There
is
no
requiremen
t
that
dom
(f
)
b
e
an
op
en
subset
of
X
.
W
e
consider
partial
con
tin
uous
maps
B
*
B
and
c
haracterize
those
that
can
b
e
enco
ded
as
elemen
ts
of
B
.
Giv
en
a
nite
sequence
of
n
um
b
ers
a
=
[a
0
;
:
:
:
;
a
k
 1
],
let
seq
a
b
e
the
enco
ding
of
a
as
a
natural
n
um
b
er,
for
example
seq
[a
0
;
:
:
:
;
a
k
 1
]
=
k
 1
Y
i=0
p
i
1+a
i
;
where
p
i
is
the
i-th
prime
n
um
b
er.
F
or

2
B
let
n
=
seq
[
0;
:
:
:
;

(n
 1)].
F
or

;

2
B
,
dene

?

b
y

?

=
n
(
)
9
m
2
N
:
 
(
m)
=
n
+
1
^
8
k
<
m
:

(
k
)
=
0

:
If
there
is
no
m
2
N
that
satises
the
ab
o
v
e
condition,
then

?

is
undened.
Th
us,
?
is
a
partial
op
eration
B

B
*
N
.
It
is
con
tin
uous
b
ecause
the
v
alue
of

?

dep
ends
only
on
nite
prexes
of

and

.
The
c
ontinuous
function
applic
ation

j

:
B

B
!
N
*
N
is
dened
b
y
(
j

)n
=

?
(n::
)
:
The
Baire
space
B
together
with
j
is
a
partial
com
binatory
algebra,
where

j

is
considered
to
b
e
undened
when

j

is
not
a
total
function,
see
[13]
for
details.
Ev
ery

2
B
represen
ts
a
partial
function


:
B
*
B
dened
b
y



=

j

:
W
e
sa
y
that
a
partial
map
f
:
B
*
B
is
r
e
alize
d
when
there
exists

2
B
suc
h
that
f
=


.
Suc
h
an

is
called
a
r
e
alizer
for
f
.
Because
j
is
a
con
tin
uous
op
eration,
a
realized
map
is
alw
a
ys
con
tin
uous,
although
not
ev
ery
partial
7

Ba
uer
con
tin
uous
map
is
realized.
Recall
that
a
G
√Ü
-set
is
a
set
that
is
equal
to
a
coun
table
in
tersection
of
op
en
sets.
Prop
osition
3.2
If
U

B
is
a
G
√Ü
-set
then
the
function
u
:
B
*
B
dene
d
by
u
=
(
n
:
N
:
1

2
U
;
undene
d
otherwise
is
r
e
alize
d.
Pro
of.
The
set
U
is
a
coun
table
in
tersection
of
coun
table
unions
of
basic
op
en
sets,
U
=
T
i2N
S
j
2N
a
i;j
::B
.
Dene
a
sequence

2
B
for
all
i;
j
2
N
b
y

(seq
(i::a
i;j
))
=
2,
and
set

n
=
0
for
all
other
argumen
ts
n.
Clearly
,
if



is
total
then
its
v
alue
is
n:
1,
so
w
e
only
need
to
v
erify
that
dom(

)
=
U
.
If

2
dom
(

)
then

?
(i::
)
is
dened
for
ev
ery
i
2
N
,
therefore
there
exists
ci
2
N
suc
h
that

(seq
(i::
[
0;
:
:
:
;

(ci)]))
=
2,
whic
h
implies
that

2
a
i;ci
.
Hence

2
T
i2N
a
i;ci
::B

U
.
Con
v
ersely
,
if

2
U
then
for
ev
ery
i
2
N
there
exists
some
ci
2
N
suc
h
that

2
a
i;ci
.
F
or
ev
ery
i
2
N
,

(seq
(i::[
0;
:
:
:
;

(ci)]))
=
2,
therefore
(


)i
=

?
(i::

)
=
1.
Hence

2
dom(

).
2
Corollary
3.3
Supp
ose

2
B
and
U

B
is
a
G
√Ü
-set.
Then
ther
e
exists

2
B
such
that



=



for
al
l

2
dom(

)
\
U
and
dom(

)
=
U
\
dom(

).
Pro
of.
By
Prop
osition
3.2
there
exists

2
B
suc
h
that
for
all

2
B



=
(
n
:
N
:
1

2
U
;
undened
otherwise
:
It
su√Üces
to
sho
w
that
the
function
f
:
B
*
B
dened
b
y
(f

)n
=
((


)n)

((


)n)
is
realized.
This
is
so
b
ecause
co
ordinate-wise
m
ultiplication
of
sequences
is
realized,
and
so
are
pairing
and
comp
osition.
2
Theorem
3.4
(Extension
Theorem
for
B
)
(a)
Every
p
artial
c
ontinuous
map
B
*
B
c
an
b
e
extende
d
to
a
r
e
alize
d
one.
(b)
The
r
e
alize
d
p
artial
maps
B
*
B
ar
e
pr
e
cisely
those
c
ontinuous
p
artial
maps
whose
domains
ar
e
G
√Ü
-sets.
Pro
of.
(a)
Supp
ose
f
:
B
*
B
is
a
partial
con
tin
uous
map.
Consider
the
set
A

N


N
2
dened
b
y
A
=

ha;
i;
j
i
2
N


N
2


a::
B
\
dom(f
)
6=
;
and
8

2
(a::B
\
dom(f
))
:
(
(f

)i
=
j
)
	
:
8

Ba
uer
If
ha;
i;
j
i
2
A,
ha
0
;
i;
j
0
i
2
A
and
a
v
a
0
then
j
=
j
0
b
ecause
there
exists

2
a
0
::B
\
dom(f
)

a::B
\
dom(f
)
suc
h
that
j
=
(f

)i
=
j
0
.
W
e
dene
a
sequence

2
B
as
follo
ws.
F
or
ev
ery
ha;
i;
j
i
2
A
let
(seq
(i::
a))
=
j
+
1,
and
for
all
other
argumen
ts
let
n
=
0.
Supp
ose
that
(seq
(i::a))
=
j
+
1
for
some
i;
j
2
N
and
a
2
N

.
Then
for
ev
ery
prex
a
0
v
a,
(seq
(i::a
0
))
=
0
or
(seq
(i::a
0
))
=
j
+
1.
Th
us,
if
ha;
i;
j
i
2
A
and
a
v

then

?
(i::

)
=
j
.
W
e
sho
w
that
(


)i
=
(f

)i
for
all

2
dom(f
)
and
all
i
2
N
.
Because
f
is
con
tin
uous,
for
all

2
dom(f
)
and
i
2
N
there
exists
ha;
i;
j
i
2
A
suc
h
that
a
v

and
(f

)i
=
j
.
No
w
w
e
get
(


)i
=
(
j

)i
=

?
(i::

)
=
j
=
(f

)i.
(b)
First
w
e
sho
w
that


is
a
con
tin
uous
map
whose
domain
is
a
G
√Ü
-set.
It
is
con
tin
uous
b
ecause
the
v
alue
of
(


)n
dep
ends
only
on
n
and
nite
prexes
of

and

.
The
domain
of


is
the
G
√Ü
-set
dom(

)
=


2
B


8
n
2
N
:
(
(
j

)n
dened
)
	
=
\
n2N


2
B


(
j

)n
dened
	
=
\
n2N
[
m2N


2
B



?
(n::

)
=
m
	
:
Eac
h
of
the
sets


2
B



?
(n::
)
=
m
	
is
op
en
b
ecause
?
and
::
are
con
tin-
uous
op
erations.
No
w
let
f
:
B
*
B
b
e
a
partial
con
tin
uous
function
whose
domain
is
a
G
√Ü
-set.
By
part
(a)
of
this
theorem
there
exists

2
B
suc
h
that
f

=



for
all

2
dom(f
).
By
Corollary
3.3
there
exists
 
2
B
suc
h
that
dom(
 
)
=
dom(f
)
and

 

=



for
ev
ery

2
dom(f
).
2
A
Bair
e
sp
ac
e
r
epr
esentation,
or
simply
a
r
epr
esentation,
is
a
partial
sur-
jection
√Ü
S
:
B
*
S
,
where
S
is
a
set.
A
represen
tation
√Ü
S
:
B
*
S
of
a
set
S
induces
a
quotien
t
top
ology
on
S
,
dened
b
y
U

S
op
en
(
)
√Ü
 1
S
(U
)
op
en
in
dom(√Ü
S
)
:
W
e
denote
b
y
kS
k
the
top
ological
space
S
with
the
quotien
t
top
ology
induced
b
y
√Ü
S
.
A
r
e
alize
d
map
f
:
(S;
√Ü
S
)
!
(T
;
√Ü
T
)
is
a
function
f
:
S
!
T
suc
h
that
there
exists
a
partial
con
tin
uous
map
g
:
B
*
B
whic
h
trac
ks
f
,
meaning
that
dom(f
)

dom(g
)
and
that,
for
ev
ery

2
dom(f
),
f
(√Ü
S

)
=
√Ü
T
(g

).
A
realized
map
f
is
alw
a
ys
con
tin
uous
as
map
f
:
kS
k
!
kT
k.
The
category
of
Baire
space
represen
tations
and
realized
maps
is
denoted
b
y
Rep(B
).
The
category
Rep(B
)
is
equiv
alen
t
to
the
PER
mo
del
PER(B
)
where
B
is
equipp
ed
with
the
structure
of
the
Second
Kleene
Algebra.
The
ob
jects
of
PER(B
)
are
partial
equiv
alence
relations
on
B
.
If
A
is
a
PER
on
B
w
e
denote
it
b
y
A
when
w
e
think
of
it
as
an
ob
ject
and
b
y
=
A
when
w
e
think
of
it
as
a
binary
relation.
F
or
A;
B
2
PER(B
),
w
e
sa
y
that

2
B
r
e
alizes
a
morphism
[
]
:
A
!
B
when,
for
all

;

2
B
,
if

=
A

,
then

j

and

j

are
dened,
and

j

=
B

j

.
Here

and

0
realize
the
same
morphism,
[
]
=
[
0
],
when,
for
all

;

2
B
,

=
A

implies

j

=
B

0
j

.
The
equiv
alence
of
Rep(B
)
and
9

Ba
uer
PER(B
)
assigns
to
eac
h
represen
tation
√Ü
S
:
B
*
S
the
PER
=
S
dened
b
y

=
S

(
)
√Ü
S
(
)
=
√Ü
S
(
)
:
If
f
:
(S;
√Ü
S
)
!
(T
;
√Ü
T
)
is
a
realized
map
in
Rep(B
),
trac
k
ed
b
y
g
:
B
*
B
,
then
b
y
Extension
Theorem
3.4
there
exists

2
B
suc
h
that


is
a
con
tin
uous
extension
of
g
.
Under
the
equiv
alence
Rep(B
)
'
PER(B
),
the
morphism
f
corresp
onds
to
the
morphism
[

].
The
most
relev
an
t
consequence
of
this
equiv
alence
is
that
Rep
(B
)
is
a
regular
lo
cally
cartesian
closed
category
,
since
ev
ery
PER
mo
del
on
a
PCA
is
suc
h
a
category
[4].
F
or
example,
the
exp
o-
nen
tial
B
A
of
PERs
A;
B
2
PER(B
)
is
dened
b
y

=
B
A

0
(
)
8

;

2
B
:
(

=
A

=
)
(
j

)
#
=
B
(
0
j

)
#
)
:
Unfortunately
,
this
description
of
exp
onen
tials
in
not
v
ery
helpful
in
particular
cases,
and
it
completely
obscures
the
top
ological
prop
erties
of
exp
onen
tials.
In
man
y
imp
ortan
t
cases
b
etter
descriptions
are
a
v
ailable,
cf.
Theorem
4.5.
In
TTE
w
e
are
t
ypically
in
terested
in
represen
tations
of
top
ological
spaces,
rather
than
arbitrary
sets.
F
or
this
reason
it
is
imp
ortan
t
to
represen
t
a
top
ological
space
X
with
a
represen
tation
(X
;
√Ü
X
)
whic
h
has
a
reasonable
relation
to
the
top
ology
of
X
.
An
ob
vious
requiremen
t
is
that
the
original
top
ology
of
X
should
coincide
with
the
quotien
t
top
ology
of
kX
k.
Ho
w
ev
er,
as
is
w
ell
kno
wn
b
y
the
sc
ho
ol
of
TTE,
this
requiremen
t
is
to
o
w
eak
b
ecause
it
allo
ws
ill-b
eha
v
ed
represen
tations.
A
desirable
condition
on
represen
tations
of
top
ological
spaces
is
that
all
con
tin
uous
maps
b
et
w
een
them
b
e
realized.
Th
us,
w
e
are
led
to
further
restricting
the
allo
w
able
represen
tations
of
top
ological
spaces
as
follo
ws.
Denition
3.5
An
admissible
r
epr
esentation
of
a
top
ological
space
X
is
a
partial
con
tin
uous
quotien
t
map
√Ü
:
B
*
X
suc
h
that
ev
ery
partial
con
tin
uous
map
f
:
B
*
X
can
b
e
factored
through
√Ü
.
This
means
that
there
exists
g
:
B
*
B
suc
h
that
f

=
√Ü
(g

)
for
all

2
dom(f
).
The
main
eect
of
this
denition
is
that
if
√Ü
X
:
B
*
X
and
√Ü
Y
:
B
*
Y
are
admissible
represen
tations,
then
ev
ery
con
tin
uous
map
f
:
X
!
Y
is
realized,
and
con
v
ersely
,
ev
ery
realizer
that
resp
ects
√Ü
X
and
√Ü
Y
induces
a
con
tin
uous
map
X
!
Y
.
The
requiremen
t
that
and
admissible
represen
tation
√Ü
:
B
*
X
b
e
a
quo-
tien
t
map
implies
that
X
is
a
sequen
tial
space,
since
it
is
a
quotien
t
of
the
sequen
tial
space
dom(√Ü
).
It
is
easy
to
sho
w
that
an
y
t
w
o
admissible
repre-
sen
tations
are
isomorphic
in
Rep(B
).
An
ob
vious
question
to
ask
is
whic
h
sequen
tial
spaces
ha
v
e
admissible
represen
tations.
Denition
3.6
Let
AdmSeq
b
e
the
full
sub
category
of
Seq
on
those
sequen
tial
T
0
-spaces
that
ha
v
e
admissible
represen
tations.
3
3
It
is
b
eliev
ed
that
the
T
0
requiremen
t
is
inessen
tial
for
the
results
pro
v
ed
here,
but
that
10

Ba
uer
Sc
hr
oder
[22
]
has
c
haracterized
AdmSeq
as
follo
ws.
Denition
3.7
[Sc
hr
oder
[22]]
A
pseudob
ase
for
a
space
X
is
a
family
B
of
subsets
of
X
suc
h
that
whenev
er
hx
n
i
n2N
!
O
(X
)
x
1
and
x
1
2
U
2
O
(X
)
then
there
exists
B
2
B
suc
h
that
x
1
2
B

U
and
hx
n
i
n2N
is
ev
en
tually
in
B
.
Theorem
3.8
(Sc
hr
oder
[22
])
A
se
quential
T
0
-sp
ac
e
has
an
admissible
r
ep-
r
esentation
if,
and
only
if,
it
has
a
c
ountable
pseudob
ase.
F
rom
Sc
hr
oder's
pro
of
of
Theorem
3.8
w
e
get
a
sp
ecic
admissible
rep-
resen
tation
√Ü
for
a
T
0
-space
X
with
a
coun
table
pseudobase

B
k


k
2
N
	
,
dened
b
y
√Ü
(
)
=
x
(
)
8
k
2
N
:
(
x
2
B
k
)
^
8
U
2
O
(X
)
:
(
x
2
U
=
)
9
k
2
N
:
B
k

U
)
:
The
ab
o
v
e
form
ula
sa
ys
that

is
a
√Ü
-represen
tation
of
x
when

en
umerates
(indices
of
)
a
sequence
of
pseudobasic
op
en
neigh
b
orho
o
ds
of
x
that
get
arbi-
trarily
small.
In
case
X
is
a
T
0
-space
with
a
coun
table
base

U
k


k
2
N
	
,
w
e
ma
y
use
an
equiv
alen
t
but
simpler
admissible
represen
tation
√Ü
0
,
dened
b
y
√Ü
0
(
)
=
x
(
)

U
k


k
2
N
	
=

U
n


n
2
N
^
x
2
U
n
	
:
The
ab
o
v
e
form
ula
sa
ys
that

is
a
√Ü
0
-represen
tation
of
x
when
it
en
umerates
the
basic
op
en
neigh
b
orho
o
ds
of
x.
If
X
2
AdmSeq
then
its
admissible
represen
tation
is
determined
up
to
iso-
morphism
in
Rep(B
).
Therefore,
AdmSeq
is
equiv
alen
t
to
the
full
sub
category
of
Rep(B
)
on
the
admissible
represen
tations,
so
that
AdmSeq
can
b
e
though
t
of
as
a
sub
category
of
Rep(B
).
The
follo
wing
result
b
y
Sc
hr
oder
[22
]
tells
us
that
the
inclusion
of
AdmSeq
in
to
Rep(B
)
preserv
es
the
cartesian
closed
structure.
Theorem
3.9
(Sc
hr
oder
[22
])
L
et
(X
;
√Ü
X
)
and
(Y
;
√Ü
Y
)
b
e
admissible
r
epr
e-
sentations
for
se
quential
T
0
-sp
ac
es
X
and
Y
.
Then
the
pr
o
duct
(X
;
√Ü
X
)

(Y
;
√Ü
Y
)
forme
d
in
Rep(B
)
is
an
admissible
r
epr
esentation
of
the
pr
o
duct
X

Y
forme
d
in
Seq,
and
similarly
the
exp
onential
(Y
;
√Ü
Y
)
(X
;√Ü
X
)
forme
d
in
Rep(B
)
is
an
admissible
r
epr
esentation
for
the
exp
onential
Y
X
forme
d
in
Seq.
4
Rep
(B
)
as
a
sub
category
of
Equ
In
this
section
w
e
describ
e
Rep(B
)
as
a
full
sub
category
of
equilogical
spaces.
W
e
then
study
the
prop
erties
of
the
inclusion
Rep(B
)
!
Equ.
Denition
4.1
A
0-e
quilo
gic
al
sp
ac
e
is
an
equilogical
space
whose
underlying
top
ological
space
is
0-dimensional.
The
category
0Equ
is
the
full
sub
category
of
Equ
on
0-equilogical
spaces.
has
not
b
een
c
hec
k
ed
y
et.
11

Ba
uer
Th
us
0Equ
is
formed
just
lik
e
Equ,
where
w
e
use
0Dim
instead
of
!
T
op
0
.
Theorem
4.2
The
c
ate
gories
0Equ,
Rep(B
),
and
PER(B
)
ar
e
e
quivalent.
Pro
of.
W
e
sho
w
that
0Equ
and
PER(B
)
are
equiv
alen
t,
since
w
e
already
kno
w
that
PER(B
)
and
Rep(B
)
are
equiv
alen
t.
By
Em
b
edding
Theorem
3.1
for
B
,
a
coun
tably
based
T
0
-space
is
0-dimensional
if,
and
only
if,
it
em
b
eds
in
B
.
Th
us
ev
ery
0-equilogical
space
is
isomorphic
to
one
whose
underlying
top
ological
space
is
a
subspace
of
B
.
This
mak
e
it
clear
that
equiv
alence
relations
on
0-dimensional
coun
tably
based
T
0
-spaces
corresp
ond
to
partial
equiv
alence
relations
on
B
.
Morphisms
w
ork
out,
to
o,
since
b
y
the
Extension
Theorem
for
B
3.4
ev
ery
partial
con
tin
uous
map
on
B
can
b
e
extended
to
a
realized
one.
2
The
inclusion
functor
I
:
0Equ
!
Equ
has
a
righ
t
adjoin
t
D
:
Equ
!
0Equ,
whic
h
is
dened
as
follo
ws.
F
or
ev
ery
coun
tably
based
T
0
-space
X
there
exists
an
admissible
represen
tation
√Ü
X
:
B
*
X
.
The
subspace
X
0
=
dom(√Ü
)

B
is
a
coun
tably
based
0-dimensional
Hausdor
space.
No
w
if
X
=
(jX
j;

X
)
is
an
equilogical
space,
let
D
X
=
(X
0
;

D
X
)
where
a

D
X
b
if,
and
only
if,
√Ü
X
a

X
√Ü
X
b.
If
f
:
X
!
Y
is
a
morphism
in
Equ,
trac
k
ed
b
y
g
:
jX
j
!
jY
j,
then
D
f
is
the
morphism
trac
k
ed
b
y
a
con
tin
uous
map
h
:
X
0
!
Y
0
that
trac
ks
g
:
X
!
Y
,
as
sho
wn
in
the
follo
wing
comm
utativ
e
diagram:
X
0
h
/
√Ü
X

Y
0
√Ü
Y

X
g
/
Y
Suc
h
a
map
h
exists
b
ecause
√Ü
X
and
√Ü
Y
w
ere
c
hosen
to
b
e
admissible
repre-
sen
tations.
The
main
prop
erties
of
the
adjoin
ts
I
a
D
are
summarized
in
the
follo
wing
theorem.
Theorem
4.3
(i)
F
unctors
I
and
D
ar
e
a
se
ction
and
a
r
etr
action,
i.e.,
D
√Ü
I
is
natur
al
ly
e
quivalent
to
1
0Equ
.
(ii)
I
is
ful
l
and
faithful
and
pr
eserves
c
ountable
c
olimits
and
limits
(which
ar
e
pr
e
cisely
al
l
the
limits
and
c
olimits
that
exist
in
Equ).
(iii)
D
is
faithful
and
pr
eserves
c
ountable
limits
and
c
olimits
(which
ar
e
pr
e-
cisely
al
l
the
limits
and
c
olimits
that
exist
in
0Equ).
(iv)
D
is
not
ful
l,
but
its
r
estriction
to
EPQ
0
is
ful
l.
Pro
of.
(i)
This
follo
ws
b
y
a
general
category-theoretic
argumen
t
from
the
fact
that
I
is
full
and
faithful,
cf.
the
dual
of
[11,
Prop
osition
3.4.1].
(ii)
It
is
ob
vious
that
I
is
full
and
faithful
since
it
is
just
the
inclusion
functor
of
a
full
sub
category
.
It
preserv
es
colimits
b
ecause
it
is
a
left
adjoin
t,
12

Ba
uer
and
it
preserv
es
limits
b
ecause
the
inclusion
0Dim
!
!
T
op
0
do
es.
(iii)
It
is
ob
vious
that
D
is
faithful,
and
it
preserv
es
limits
b
ecause
it
is
a
righ
t
adjoin
t.
That
D
preserv
es
nite
colimits
can
b
e
v
eried
explicitly
,
and
it
also
follo
ws
from
[17,
Prop
osition
2.5.11].
That
D
preserv
es
coun
table
copro
ducts
holds
b
ecause
a
coun
table
copro
duct
of
admissible
represen
tations
is
again
an
admissible
represen
tation.
(iv)
If
D
w
ere
full
then
b
y
[11
,
Prop
osition
3.4.3]
it
w
ould
follo
w
that
the
counit
of
the
adjunction

:
I
√Ü
D
!
1
Equ
is
a
natural
isomorphism,
whic
h
ob
viously
is
not
the
case.
F
or
example,

R
is
not
a
natural
isomorphism,
where
R
are
the
real
n
um
b
ers
equipp
ed
with
the
Euclidean
top
ology
,
b
ecause
ev
ery
morphism
R
!
I
(D
R
)
is
constan
t,
as
it
m
ust
b
e
trac
k
ed
b
y
a
con
tin
uous
map
from
R
in
to
the
0-dimensional
Hausdor
space
jI
(D
R
)j.
Ho
w
ev
er,
when
D
is
restricted
to
EPQ
0
then
w
e
can
sho
w
that
it
is
full
as
follo
ws.
Supp
ose
X
;
Y
2
EPQ
0
,
and
let
r
X
:
X
0
!
jX
j
and
r
Y
:
Y
0
!
jY
j
b
e
admissible
represen
tations.
Supp
ose
f
:
D
X
!
D
Y
is
a
morphism
trac
k
ed
b
y
a
con
tin
uous
map
g
:
X
0
!
Y
0
.
The
situation
is
sho
wn
in
the
follo
wing
diagram:
X
0
g
/
r
X

Y
0
r
Y

jX
j
h
/
q
X

jY
j
q
Y

kX
k
f
/
kY
k
Because
q
Y
is
!
-pro
jecting,
f
is
trac
k
ed
b
y
an
arro
w
h
:
jX
j
!
jY
j
so
that
the
lo
w
er
square
comm
utes.
Therefore
f
is
a
morphism
in
Equ
,
hence
D
f
=
f
.
2
Remark
4.4
Since
I
and
D
b
oth
preserv
e
all
limits
and
colimits
that
exist,
one
w
onders
whether
they
ha
v
e
an
y
further
adjoin
ts.
4
This
do
es
not
seem
to
b
e
the
case.
One
migh
t
try
em
b
edding
the
categories
Equ
and
Rep(B
)
in
to
larger
categories
and
extending
I
and
D
,
in
hop
e
that
the
\missing"
adjoin
t
can
b
e
obtained
that
w
a
y
.
This
idea
w
as
w
ork
ed
out
in
[2]
for
a
general
applicativ
e
retraction
I
a
D
b
et
w
een
PER
mo
dels.
The
PER
mo
dels
w
ere
em
b
edded
in
to
suitable
top
oses
of
shea
v
es
o
v
er
PCAs.
The
adjunction
I
a
D
then
extends
to
an
adjunction
at
the
lev
el
of
top
oses,
with
a
further
righ
t
adjoin
t.
This
mak
es
it
p
ossible
to
apply
the
logical
transfer
principle
from
[3]
to
sho
w
that
a
certain
class
of
rst-order
sen
tences
is
v
alid
in
the
in
ternal
logic
of
Equ
if,
and
only
if,
it
is
v
alid
in
the
in
ternal
logic
of
Rep
(B
).
The
next
question
to
ask
is
whether
I
and
D
preserv
e
an
y
exp
onen
tials.
4
Note
that
Equ
and
0Equ
are
only
c
ountably
complete
and
co
complete
so
that
w
e
cannot
directly
apply
the
Adjoin
t
F
unctor
Theorem.
13

Ba
uer
Theorem
4.5
(i)
F
unctor
D
r
estricte
d
to
EPQ
0
pr
eserves
exp
onentials.
(ii)
If
X
;
Y
2
0Equ
and
ther
e
exists
in
!
T
op
0
a
0-dimensional
we
ak
exp
onen-
tial
of
jX
j
and
jY
j,
then
I
pr
eserves
the
exp
onential
Y
X
.
(iii)
F
unctor
I
pr
eserves
the
natur
al
numb
ers
obje
ct
N
,
the
exp
onentials
N
N
and
2
N
,
and
the
obje
ct
R
c
of
Cauchy
r
e
als.
(iv)
F
unctor
I
do
es
not
pr
eserve
exp
onentials
in
gener
al.
In
p
articular,
it
do
es
not
pr
eserve
N
N
N
.
Pro
of.
(i)
This
follo
ws
from
results
obtained
in
Section
5,
and
so
w
e
p
ostp
one
the
pro
of
un
til
then.
It
can
b
e
found
on
page
16.
(ii)
If
W
2
0Dim
is
a
w
eak
exp
onen
tial
of
X
and
Y
in
!
T
op
0
,
then
it
is
also
a
w
eak
exp
onen
tial
of
X
and
Y
in
0Dim.
Therefore,
the
construction
of
Y
X
from
W
in
Equ,
as
describ
ed
in
Section
2
coincides
with
the
one
in
0Equ.
(iii)
The
Baire
space
N
N
and
the
Can
tor
space
2
N
b
oth
satisfy
the
condition
from
(ii).
The
real
n
um
b
ers
ob
ject
R
c
is
a
regular
quotien
t
of
N

2
N
[4,
Prop
osition
5.5.3],
and
the
left
adjoin
t
I
preserv
es
it
b
ecause
it
preserv
es
N
,
2
N
,
pro
ducts,
and
co
equalizers.
(iv)
Let
X
=
N
N
N
in
0Equ,
and
let
Y
=
N
N
N
in
Equ.
The
space
jX
j
is
a
Hausdor
space.
The
space
jY
j
is
the
subspace
of
the
total
elemen
ts
of
the
Scott
domain
D
Y
=
[N
?
!
!
N
?
].
The
equiv
alence
relation
on
jY
j
is
the
consistency
relation
of
D
Y
restricted
to
jY
j.
Supp
ose
f
:
jY
j
!
jX
j
repre-
sen
ted
an
isomorphism,
and
let
g
:
jX
j
!
jY
j
represen
t
its
in
v
erse.
Because
f
is
monotone
in
the
sp
ecialization
order
and
jX
j
has
a
trivial
sp
ecialization
order,
a

Y
b
implies
f
x
=
f
y
.
Therefore,
g
√Ü
f
:
jY
j
!
jY
j
is
an
equiv
arian
t
retraction.
By
[4
,
Prop
osition
4.1.8],
Y
is
a
top
ological
ob
ject.
By
[4,
Corol-
lary
4.1.9],
this
w
ould
mean
that
the
top
ological
quotien
t
kY
k
is
coun
tably
based,
but
it
is
not,
as
is
w
ell
kno
wn.
Another
w
a
y
to
see
that
Y
cannot
b
e
top
ological
is
to
observ
e
that
Y
is
an
exp
onen
tial
of
the
Baire
space,
but
the
Baire
space
is
not
exp
onen
tiable
in
!
T
op
0
,
and
in
particular
N
N
N
is
not
a
top
ological
ob
ject
in
Equ.
2
Remark
4.6
In
[2]
w
e
used
a
logical
transfer
principle
b
et
w
een
Equ
and
Rep(B
)
to
pro
v
e
that
I
do
es
not
preserv
e
R
c
R
c
either.
As
already
men
tioned
in
the
in
tro
duction,
w
e
could
obtain
the
results
of
this
section
b
y
applying
Longley's
theory
of
applicativ
e
adjunctions
b
et
w
een
applicativ
e
morphisms
of
partial
com
binatory
algebras
[17
].
Lietz
[16
]
used
this
approac
h
to
compare
the
realizabilit
y
top
oses
RT
(P
N
)
and
RT(B
).
5
A
Common
Sub
category
of
Equ
and
Rep(B
)
In
Sections
2
and
3
w
e
sa
w
that
sequen
tial
spaces
con
tain
cartesian
closed
sub
categories
PQ
0
and
AdmSeq
whic
h
are
also
cartesian
closed
sub
categories
14

Ba
uer
of
Equ
and
Rep(B
),
resp
ectiv
ely
.
In
this
section
w
e
pro
v
e
that
PQ
0
and
AdmSeq
are
the
same
category
.
Lemma
5.1
Supp
ose
B
=

B
i


i
2
N
	
is
a
c
ountable
pseudob
ase
for
a
c
ount-
ably
b
ase
d
T
0
-sp
ac
e
Y
.
L
et
X
b
e
a
rst-c
ountable
sp
ac
e
and
f
:
X
!
Y
a
c
on-
tinuous
map.
F
or
every
x
2
X
and
every
neighb
orho
o
d
V
of
f
x
ther
e
exists
a
neighb
orho
o
d
U
of
x
and
i
2
N
such
that
f
x
2
f
(U
)

B
i

V
.
Pro
of.
Note
that
the
elemen
ts
of
the
pseudobase
do
not
ha
v
e
to
b
e
op
en
sets,
so
this
is
not
just
a
trivial
consequence
of
con
tin
uit
y
of
f
.
W
e
pro
v
e
the
lemma
b
y
con
tradiction.
Supp
ose
there
w
ere
x
2
X
and
a
neigh
b
orho
o
d
V
of
f
x
suc
h
that
for
ev
ery
neigh
b
orho
o
d
U
of
x
and
for
ev
ery
i
2
N
,
if
B
i

V
then
f

(U
)
6
B
i
.
Let
U
0

U
1




b
e
a
descending
coun
table
neigh
b
orho
o
d
system
for
x.
Let
p
:
N
!
N
b
e
a
surjectiv
e
map
that
attains
eac
h
v
alue
innitely
often,
that
is
for
all
k
;
j
2
N
there
exists
i

k
suc
h
that
pi
=
j
.
F
or
ev
ery
i
2
N
,
if
B
pi

V
then
f

(U
i
)
6
B
pi
.
Therefore,
for
ev
ery
i
2
N
there
exists
x
i
2
U
i
suc
h
that
if
B
pi

V
then
f
x
i
62
B
pi
.
The
sequence
hx
n
i
n2N
con
v
erges
to
x,
hence
hf
x
n
i
n2N
con
v
erges
to
f
x.
Because
B
is
a
pseudobase
there
exists
j
2
N
suc
h
that
B
j

V
and
hf
x
n
i
n2N
is
ev
en
tually
in
B
j
,
sa
y
from
the
k
-th
term
on
w
ards.
There
exists
i

k
suc
h
that
pi
=
j
.
No
w
w
e
get
f
x
i
2
B
pi

V
,
whic
h
is
a
con
tradiction.
2
Theorem
5.2
PQ
0
and
AdmSeq
ar
e
the
same
c
ate
gory.
Pro
of.
It
w
as
indep
enden
tly
observ
ed
b
y
Sc
hr
oder
that
PQ
0
is
a
full
sub
cat-
egory
of
AdmSeq
,
whic
h
is
the
easier
of
the
t
w
o
inclusions.
The
pro
of
go
es
as
follo
ws.
Supp
ose
q
:
X
!
Y
is
an
!
-pro
jecting
quotien
t
map.
W
e
need
to
sho
w
that
Y
is
a
sequen
tial
space
with
an
admissible
represen
tation.
It
is
sequen
tial
b
ecause
it
is
a
quotien
t
of
a
sequen
tial
space.
There
exists
an
admissible
represen
tation
√Ü
X
:
B
*
X
.
Let
√Ü
Y
=
q
√Ü
√Ü
X
.
Supp
ose
f
:
B
*
Y
is
a
con
tin
uous
partial
map.
Because
q
is
!
-pro
jecting
f
lifts
though
X
,
and
b
ecause
√Ü
X
is
an
admissible
represen
tation,
it
further
lifts
through
B
.
It
remains
to
pro
v
e
the
con
v
erse,
namely
that
if
a
sequen
tial
T
0
-space
X
has
an
admissible
represen
tation
then
there
exists
an
!
-pro
jecting
quotien
t
q
:
Y
!
X
.
Since
X
has
an
admissible
represen
tation
it
has
a
coun
table
pseudobase
B
=

B
i


i
2
N
	
,
b
y
Theorem
3.8.
The
p
o
w
erset
P
N
ordered
b
y
inclusion
is
an
algebraic
lattice.
W
e
equip
it
with
the
Scott
top
ology
,
whic
h
is
generated
b
y
the
subbasic
op
en
sets
"n
=

a
2
P
N


n
2
a
	
,
n
2
N
.
Let
q
:
P
N
*
X
b
e
a
partial
map
dened
b
y
q
a
=
x
(
)
(8
n
2
a
:
x
2
B
n
)
^
8
U
2
O
(X
)
:
(x
2
U
=
)
9
n
2
a
:
B
n

U
)
:
The
map
q
is
w
ell
dened
b
ecause
q
a
=
x
and
q
a
=
y
implies
that
x
and
y
share
the
same
neigh
b
orho
o
ds,
so
they
are
the
same
p
oin
t
of
the
T
0
-space
X
.
F
urthermore,
q
is
surjectiv
e
b
ecause
B
is
a
pseudobase.
T
o
see
that
p
is
15

Ba
uer
con
tin
uous,
supp
ose
pa
=
x
and
x
2
U
2
O
(X
).
There
exists
n
2
N
suc
h
that
x
2
B
n

U
.
If
n
2
b
2
dom(p)
then
pb
2
B
n

U
.
Therefore,
a
2
"n
and
p

("n)

B
n

U
,
whic
h
means
that
p
is
con
tin
uous.
Let
Y
=
dom(p).
Let
us
sho
w
that
q
:
Y
!
X
is
!
-pro
jecting.
Supp
ose
f
:
Z
!
X
is
a
con
tin
uous
map
and
Z
2
!
T
op
0
.
Dene
a
map
g
:
Z
!
P
N
b
y
g
z
=

n
2
N


9
U
2
O
(Z
)
:
(
z
2
U
^
f

(U
)

B
n
)
	
:
The
map
g
is
con
tin
uous
almost
b
y
denition.
Indeed,
if
g
z
2
"
n
then
there
exists
a
neigh
b
orho
o
d
U
of
z
suc
h
that
f

(U
)

B
n
,
but
then
g

(U
)
2
"n.
T
o
nish
the
pro
of
w
e
need
to
sho
w
that
f
z
=
p(g
z
)
for
all
z
2
Z
.
If
n
2
g
z
then
f
z
2
B
n
b
ecause
there
exists
U
2
O
(Z
)
suc
h
that
z
2
U
and
f

(U
)

B
n
.
If
f
z
2
V
2
O
(X
)
then
b
y
Lemma
5.1
there
exists
U
2
O
(Z
)
and
n
2
N
suc
h
that
z
2
U
and
f

(U
)

B
n

U
.
Hence,
n
2
g
z
.
This
pro
v
es
that
f
z
=
p(g
z
).
2
Remark
5.3
Matthias
Sc
hr
oder
has
sho
w
ed
recen
tly
that
if
a
sequen
tial
T
0
-
space
X
arises
as
a
top
ological
quotien
t
of
a
subspace
of
B
,
then
X
has
an
admissible
represen
tation.
This
result
implies
Theorem
5.2,
and
also
giv
es
a
v
ery
nice
c
haracterization
of
EPQ
0
:
it
is
precisely
the
category
of
all
T
0
-spaces
that
are
top
ological
quotien
ts
of
coun
tably
based
T
0
-spaces.
The
relationships
b
et
w
een
the
categories
are
summarized
b
y
the
follo
wing
diagram:
Seq
Equ
'
PER(P
N
)
D
a

!
T
op
0
/
PQ
0
=
AdmSeq
4i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
*U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
U
O
0Equ
'
Rep(B
)
'
PER(B
)
I
O
(1)
The
unlab
eled
arro
ws
are
full
and
faithful
inclusions,
preserv
e
coun
table
limits,
and
coun
table
copro
ducts.
The
inclusion
!
T
op
0
!
PQ
0
preserv
es
all
exp
onen-
tials
that
happ
en
to
exist
in
!
T
op
0
,
and
the
other
three
unlab
eled
inclusions
preserv
e
cartesian
closed
structure.
The
righ
t-hand
triangle
in
v
olving
the
t
w
o
inclusions
and
the
coreection
D
comm
utes
up
to
natural
isomorphism
(and
the
one
in
v
olving
the
inclusion
I
do
es
not).
W
e
still
o
w
e
the
pro
of
of
Theorem
4.5(i),
namely
,
that
D
restricted
to
EPQ
0
preserv
es
exp
onen
tials.
But
this
is
no
w
ob
vious,
since
the
righ
t-hand
triangle
in
v
olving
D
comm
utes.
6
T
ransfer
Results
b
et
w
een
Equ
and
Rep
(B
)
The
corresp
ondence
(1)
explains
wh
y
domain-theoretic
computational
mo
dels
agree
so
w
ell
with
computational
mo
dels
studied
b
y
TTE|as
long
as
w
e
16

Ba
uer
only
build
spaces
b
y
taking
pro
ducts,
copro
ducts,
exp
onen
tials,
and
regular
subspaces,
starting
from
coun
tably
based
T
0
-spaces,
w
e
remain
in
PQ
0
,
the
common
cartesian
closed
core
of
equilogical
spaces
and
TTE.
As
a
rst
example
of
a
transfer
result,
w
e
translate
a
c
haracterization
of
Kleene-Kreisel
coun
table
functionals
[12]
from
Equ
to
Rep(B
).
In
[6]
w
e
pro
v
ed
that
the
iterated
exp
onen
tials
N
,
N
N
,
N
N
N
,
:
:
:
of
the
natural
n
um
b
ers
ob
ject
N
in
Equ
are
precisely
the
Kleene-Kreisel
coun
table
functionals.
Because
N
is
the
natural
n
um
b
ers
ob
ject
in
Rep(B
)
as
w
ell,
and
it
b
elongs
to
PQ
0
,
the
same
hierarc
h
y
app
ears
in
Rep(B
).
Prop
osition
6.1
In
Rep(B
),
the
hier
ar
chy
of
exp
onentials
N
,
N
N
,
N
N
N
,
:
:
:
,
built
fr
om
the
natur
al
numb
ers
obje
ct
N
,
c
orr
esp
onds
to
the
Kle
ene-Kr
eisel
c
ountable
functionals.
As
a
second
example,
w
e
consider
transfer
b
et
w
een
the
internal
lo
gics
of
Equ
and
Rep(B
).
Because
Equ
and
Rep(B
)
are
equiv
alen
t
to
realizabilit
y
mo
dels
PER(P
N
)
and
PER(B
),
resp
ectiv
ely
,
they
admit
a
realizabilit
y
in
ter-
pretation
of
rst-order
in
tuitionistic
logic.
This
has
b
een
w
ork
ed
out
in
detail
in
[4].
It
is
often
adv
an
tageous
to
w
ork
in
the
in
ternal
logic,
b
ecause
it
lets
us
argue
abstractly
and
conceptually
ab
out
ob
jects
and
morphisms.
W
e
nev
er
ha
v
e
to
men
tion
explicitly
the
realizers
of
morphisms
or
the
underlying
top
o-
logical
spaces,
whic
h
mak
es
argumen
ts
more
p
erspicuous.
Ev
ery
map
that
can
b
e
dened
in
the
in
ternal
logic
is
automatically
realized
(and
computable,
if
w
e
w
ork
with
the
computable
v
ersions
of
the
realizabilit
y
mo
dels).
Supp
ose
w
e
w
an
t
to
use
in
ternal
logic
to
construct
a
particular
map
f
:
X
!
Y
where
X
;
Y
2
PQ
0
.
F
or
example,
w
e
migh
t
w
an
t
to
dene
the
denite
in-
tegration
op
erator
I
:
R
[0;1]
!
R
,
I
f
=
Z
1
0
f
(x)
dx
:
It
ma
y
happ
en
that
X
and
Y
are
m
uc
h
more
amenable
to
the
in
ternal
logic
of
Rep
(B
)
than
to
the
in
ternal
logic
of
Equ,
or
vice
v
ersa.
In
suc
h
a
case
w
e
can
pic
k
whic
hev
er
in
ternal
logic
is
b
etter
and
w
ork
in
it,
b
ecause
if
a
map
f
:
X
!
Y
is
denable
in
one
in
ternal
logic,
then
it
exists
as
a
morphism
in
b
oth
Equ
and
Rep(B
).
Let
us
see
ho
w
this
applies
in
the
case
of
denite
in
tegration.
The
real
n
um-
b
ers
R
are
m
uc
h
b
etter
b
eha
v
ed
in
Rep(B
)
than
in
Equ,
b
ecause
R
can
b
e
c
har-
acterized
in
the
in
ternal
logic
of
Rep(B
)
as
the
Cauchy
c
omplete
A
r
chime
de
an
eld,
whic
h
giv
es
us
all
the
prop
erties
of
R
w
e
could
wish
for.
On
the
other
hand,
in
the
in
ternal
logic
of
Equ,
R
do
es
not
seem
to
b
e
c
haracterizable
at
all,
and
it
do
es
not
ev
en
satisfy
the
Arc
himedean
axiom
8
x
2
R
:
9
n
2
N
:
x
<
n
;
b
ecause
in
Equ
there
is
no
c
ontinuous
c
hoice
map
c
:
R
!
N
that
w
ould
17

Ba
uer
satisfy
x
<
cx
for
all
x
2
R
.
5
This
mak
es
it
impractical
to
argue
ab
out
R
in
the
in
ternal
logic
of
Equ
.
The
situation
with
the
space
R
[0;1]
of
con
tin
uous
real
function
on
the
unit
in
terv
al
is
similar|it
is
m
uc
h
b
etter
b
eha
v
ed
in
the
in
ternal
logic
of
Rep(B
)
than
in
the
in
ternal
logic
of
Equ
.
In
particular,
in
Rep(B
)
the
statemen
t
\ev
ery
map
f
:
[0;
1]
!
R
is
uniformly
con
tin
uous"
is
v
alid,
whereas
it
is
not
v
alid
in
the
in
ternal
logic
of
Equ.
This
mak
es
it
clear
that
the
in
ternal
logic
of
Rep(B
)
is
the
b
etter
c
hoice.
Indeed,
in
the
in
ternal
logic
of
Rep(B
)
denite
in
tegral
ma
y
b
e
dened
in
the
usual
w
a
y
as
a
limit
of
Riemann
sums.
The
con
v
ergence
of
Riemann
sums
can
then
b
e
pro
v
ed
constructiv
ely
b
ecause
Rep(B
)
\b
eliev
es"
that
all
maps
from
[0;
1]
to
R
are
uniformly
con
tin
uous.
Once
w
e
ha
v
e
constructed
the
denite
in
tegral
op
erator
I
:
R
[0;1]
!
R
in
Rep
(B
),
w
e
can
transfer
it
to
Equ
via
PQ
0
.
7
Conclusion
Let
me
conclude
b
y
commen
ting
on
the
follo
wing
comparison
of
domain
theory
and
TTE
from
W
eihrauc
h's
recen
tly
published
b
o
ok
on
computable
analysis
[27
,
Section
9.8,
p.
267]:
\The
domain
approac
h
dev
elop
ed
so
far
is
consisten
t
with
TTE.
Roughly
sp
eak-
ing,
a
domain
(for
the
real
n
um
b
ers)
con
tains
appro
ximate
ob
jects
as
w
ell
as
precise
ob
jects
whic
h
are
treated
in
separate
sets
in
TTE.
A
computable
do-
main
function
m
ust
map
also
all
appro
ximate
ob
jects
reasonably
.
In
man
y
cases,
constructing
a
domain
whic
h
corresp
onds
to
giv
en
represen
tation
still
is
a
di√Ü-
cult
task.
Concepts
for
handling
m
ulti-v
alued
functions
and
for
computational
complexit
y
ha
v
e
not
y
et
b
een
dev
elop
ed
for
the
domain
approac
h.
The
elegan
t
handling
of
higher
t
yp
e
functions
in
domain
theory
can
b
e
sim
ulated
in
TTE
b
y
means
of
function
space
represen
tations
[√Ü
!
√Ü
0
]
(Denition
3.3.13).
T
o
date,
there
seems
to
b
e
no
con
vincing
reason
to
learn
domain
theory
as
a
prerequisite
for
computable
analysis."
The
presen
t
pap
er
pro
vides
a
precise
mathematical
comparison
of
TTE
and
the
domain
approac
h,
as
exemplied
b
y
equilogical
spaces.
The
corre-
sp
ondence
(1)
giv
es
us
a
clear
picture
ab
out
the
relationships
b
et
w
een
the
domain
approac
h
and
TTE.
Ov
erall,
it
supp
orts
the
claim
that
these
t
w
o
ap-
proac
hes
are
consisten
t,
at
least
as
far
as
computabilit
y
on
PQ
0
is
concerned.
Indeed,
domains
are
built
from
the
appro
ximate
as
w
ell
as
the
precise
ob
jects,
and
I
join
W
eihrauc
h
in
p
oin
ting
out
that
it
is
a
go
o
d
idea
to
distin-
guish
the
precise
ob
jects
from
the
appro
ximate
ones.
In
domain
theory
this
is
most
easily
done
b
y
taking
seriously
domains
with
totality,
or
more
generally
PERs
on
domains,
whic
h
leads
to
the
notion
of
equilogical
spaces
and
domain
represen
tations,
whic
h
w
ere
studied
b
y
Blanc
k
[10
].
5
The
Arc
himedean
axiom
is
v
alid
in
Rep(B
)
b
ecause
there
is
a
con
tin
uous
c
hoice
map
jD
Rj
!
N
suc
h
that
[a]
<
ca
for
all
a
2
jD
Rj,
where
[a]
the
real
n
um
b
er
represen
ted
b
y
the
realizer
a.
The
p
oin
t
is
that
ca
ma
y
dep
end
on
the
realizer
a.
18

Ba
uer
I
hop
e
that
the
adjoin
t
functors
I
and
D
b
et
w
een
Equ
and
Rep(B
)
will
ease
the
task
of
constructing
a
domain
whic
h
corresp
onds
to
a
giv
en
represen
tation.
P
o
w
er-domains
are
the
domain-theoretic
mo
dels
of
non-deterministic
com-
putation,
and
I
b
eliev
e
they
could
b
e
used
to
mo
del
m
ulti-v
alued
functions.
In
this
pap
er
w
e
did
not
consider
the
computational
complexit
y
or
ev
en
computabilit
y
in
Equ
and
Rep(B
).
In
[4]
the
inclusion
Rep
(B
)
!
Equ
and
its
coreection
are
constructed
for
the
computable
v
ersions
of
equilogical
spaces
and
TTE,
from
whic
h
w
e
ma
y
conclude
that
computabilit
y
in
domain
theory
is
essen
tially
the
same
as
in
TTE.
By
Theorem
4.5,
the
higher
t
yp
e
function
spaces
in
equilogical
spaces
do
not
generally
agree
with
the
corresp
onding
function
space
represen
tations
in
TTE.
Ho
w
ev
er,
the
t
w
o
approac
hes
to
higher
t
yp
es
do
agree
on
an
imp
or-
tan
t
class
of
spaces,
namely
the
category
PQ
0
,
whic
h
con
tains
all
coun
tably
based
T
0
-spaces,
therefore
also
all
coun
tably
based
con
tin
uous
and
algebraic
domains.
Higher
t
yp
es
seem
not
to
catc
h
a
lot
of
in
terest
in
the
TTE
com-
m
unit
y
.
This
ma
y
b
e
b
ecause
the
descriptions
of
higher
t
yp
es
in
terms
of
represen
tations
can
get
quite
un
wieldy
and
are
hard
to
w
ork
with.
The
the-
ory
of
cartesian
closed
categories
and
the
in
ternal
logic
of
Rep(B
)
ough
t
to
b
e
helpful
here,
as
they
allo
ws
us
to
talk
ab
out
the
higher
t
yp
es
abstractly
,
without
ha
ving
to
refer
to
their
represen
tations
all
the
time.
After
all,
higher
t
yp
es
cannot
b
e
ignored
in
computable
analysis:
real
n
um
b
ers
are
a
quotien
t
of
t
yp
e
1,
in
tegration
and
dieren
tiation
op
erators
ha
v
e
t
yp
e
2,
solving
a
dif-
feren
tial
equation
is
a
t
yp
e
3
pro
cess,
and
still
higher
t
yp
es
are
reac
hed
when
w
e
study
spaces
of
distributions
and
op
erators
on
Hilb
ert
spaces.
Finally
,
is
there
a
con
vincing
reason
to
learn
domain
theory
as
a
prereq-
uisite
for
computable
analysis?
By
Theorem
4.2,
Rep(B
)
is
a
full
sub
category
of
Equ.
This
ma
y
suggest
the
view
that
the
domain
approac
h
is
more
general
than
TTE.
A
t
an
y
rate,
they
are
not
comp
eting
approac
hes.
They
t
with
eac
h
other
v
ery
w
ell,
and
eac
h
has
its
adv
an
tages:
domain
theory
handles
higher
t
yp
es
more
elegan
tly
and
is
more
general
than
TTE,
whereas
TTE
pro
vides
a
more
con
v
enien
t
in
ternal
logic
and
handles
questions
ab
out
com-
putational
complexit
y
b
etter.
So
wh
y
not
learn
b
oth,
and
a
bit
of
category
theory
,
realizabilit
y
,
and
constructiv
e
logic
on
top?
References
[1]
Amadio,
R.
and
P
.-L.
Curien,
\Domains
and
Lam
b
da-Calculi,"
Cam
bridge
T
racts
in
Theoretical
Computer
Science
46,
Cam
bridge
Univ
ersit
y
Press,
1998.
[2]
Aw
o
dey
,
S.
and
A.
Bauer,
She
af
top
oses
for
r
e
alizability
(2000),
a
v
ailable
at
http://andrej.com/papers
.
[3]
Aw
o
dey
,
S.,
L.
Birk
edal
and
D.
Scott,
L
o
c
al
r
e
alizability
top
oses
and
a
mo
dal
lo
gic
for
c
omputability,
in:
L.
Birk
edal,
J.
v
an
Oosten,
G.
Rosolini
and
D.
Scott,
19

Ba
uer
editors,
T
utorial
Workshop
on
R
e
alizability
Semantics,
FL
oC'99,
T
r
ento,
Italy,
1999,
Electronic
Notes
in
Theoretical
Computer
Science
23
(1999).
[4]
Bauer,
A.,
\The
Realizabilit
y
Approac
h
to
Computable
Analysis
and
T
op
ology
,"
Ph.D.
thesis,
Carnegie
Mellon
Univ
ersit
y
(2000),
a
v
ailable
as
CMU
tec
hnical
rep
ort
CMU-CS-00-164
and
at
http://andrej.com/thesis.
[5]
Bauer,
A.
and
L.
Birk
edal,
Continuous
functionals
of
dep
endent
typ
es
and
e
quilo
gic
al
sp
ac
es,
in:
Computer
Scienc
e
L
o
gic
2000,
2000,
a
v
ailable
at
http:
//andrej.com/papers.
[6]
Bauer,
A.,
L.
Birk
edal
and
D.
Scott,
Equilo
gic
al
sp
ac
es,
Preprin
t
submitted
to
Elsevier
(1998).
[7]
Berger,
U.,
T
otal
sets
and
obje
cts
in
domain
the
ory,
Annals
of
Pure
and
Applied
Logic
60
(1993),
pp.
91{117,
a
v
ailable
at
http://www.mathematik.
uni-
muenchen.de/~berger/
arti
cles
/ap
al/d
iss.
dvi
.Z.
[8]
Berger,
U.,
\Con
tin
uous
F
unctionals
of
Dep
enden
t
and
T
ransitiv
e
T
yp
es,"
Habilitationssc
hrift,
Ludwig-Maximilians-Univ
ersit
at
M

unc
hen
(1997).
[9]
Berger,
U.,
Ee
ctivity
and
density
in
domains:
A
survey,
,
23
(2000).
[10]
Blanc
k,
J.,
\Computabilit
y
on
T
op
ological
Spaces
b
y
Eectiv
e
Domain
Represen
tations,"
Ph.D.
thesis,
Departmen
t
of
Mathematics,
Uppsala
Univ
ersit
y
(1997).
[11]
Borceux,
F.,
\Handb
o
ok
of
Categorical
Algebra
I.
Basic
Category
Theory
,"
Encyclop
edia
of
Mathematics
and
Its
Applications
51,
Cam
bridge
Univ
ersit
y
Press,
1994.
[12]
Kleene,
S.,
Countable
functionals,
in:
Constructivity
in
Mathematics,
1959,
pp.
81{100.
[13]
Kleene,
S.
and
R.
V
esley
,
\The
F
oundations
of
In
tuitionistic
Mathematics,
esp
ecially
in
relation
to
recursiv
e
functions,"
North-Holland
Publishing
Compan
y
,
1965.
[14]
Kreitz,
C.
and
K.
W
eihrauc
h,
The
ory
of
r
epr
esentations,
Theoretical
Computer
Science
38
(1985),
pp.
35{53.
[15]
Kurato
wski,
C.,
\T
op
ologie,"
W
arsza
w
a,
1952.
[16]
Lietz,
P
.,
Comp
aring
r
e
alizability
over
P
!
and
K
2
(1999),
a
v
ailable
at
http:
//www.mathematik.tu-
darm
stad
t.de
/~l
ietz
/com
p.p
s.gz
.
[17]
Longley
,
J.,
\Realizabilit
y
T
op
oses
and
Language
Seman
tics,"
Ph.D.
thesis,
Univ
ersit
y
of
Edin
burgh
(1994).
[18]
Menni,
M.
and
A.
Simpson,
The
lar
gest
top
olo
gic
al
sub
c
ate
gory
of
c
ountably-
b
ase
d
e
quilo
gic
al
sp
ac
es,
in:
Pr
eliminary
Pr
o
c
e
e
dings
of
MFPS
XV,
1999,
a
v
ailable
at
http://www.dcs.ed.ac.uk
/hom
e/al
s/R
esea
rch/
.
20

Ba
uer
[19]
Menni,
M.
and
A.
Simpson,
T
op
olo
gic
al
and
limit-sp
ac
e
sub
c
ate
gories
of
c
ountably-b
ase
d
e
quilo
gic
al
sp
ac
es
(2000),
submitted
to
Math.
Struct.
in
Comp.
Science.
[20]
Normann,
D.,
Cate
gories
of
domains
with
totality
(1998),
a
v
ailable
at
http:
//www.math.uio.no/~dnorm
ann/
.
[21]
Normann,
D.,
The
c
ontinuous
functionals
of
nite
typ
es
over
the
r
e
als,
Preprin
t
Series
19,
Univ
ersit
y
of
Oslo
(1998).
[22]
Sc
hr
oder,
M.,
A
dmissible
r
epr
esentations
of
limit
sp
ac
es,
in:
J.
Blanc
k,
V.
Brattk
a,
P
.
Hertling
and
K.
W
eihrauc
h,
editors,
Computability
and
Complexity
in
A
nalysis,
Informatik
Beric
h
te
272
(2000),
pp.
369{388,
cCA2000
W
orkshop,
Sw
ansea,
W
ales,
Septem
b
er
17{19,
2000.
[23]
Scott,
D.,
A
new
c
ate
gory?
(1996),
unpublished
Man
uscript.
Av
ailable
at
http:
//www.cs.cmu.edu/Groups/
LTC/
.
[24]
Stolten
b
erg-Hansen,
V.,
I.
Lindstr
om
and
E.
Grior,
\Mathematical
Theory
of
Domains,"
Num
b
er
22
in
Cam
bridge
T
racts
in
Computer
Science,
Cam
bridge
Univ
ersit
y
Press,
1994.
[25]
W
eihrauc
h,
K.,
T
yp
e
2
r
e
cursion
the
ory,
Theoretical
Computer
Science
38
(1985),
pp.
17{33.
[26]
W
eihrauc
h,
K.,
\Computabilit
y
,"
EA
TCS
Monographs
on
Theoretical
Computer
Science
9,
Springer,
Berlin,
1987.
[27]
W
eihrauc
h,
K.,
\Computable
Analysis,"
Springer-V
erlag,
2000.
21

22

MFPS
17
Preliminary
Version
T
ransfer
Principles
for
Reasoning
Ab
out
Concurren
t
Programs
Stephen
Bro
ok
es
Dep
artment
of
Computer
Scienc
e
Carne
gie
Mel
lon
University
Pittsbur
gh,
USA
Abstract
In
previous
w
ork
w
e
ha
v
e
dev
elop
ed
a
tr
ansition
tr
ac
e
seman
tic
framew
ork,
suitable
for
shared-memory
parallel
programs
and
async
hronously
comm
unicating
pro
cesses,
and
abstract
enough
to
supp
ort
comp
ositional
reasoning
ab
out
safet
y
and
liv
eness
prop
erties.
W
e
no
w
use
this
framew
ork
to
formalize
and
generalize
some
tec
hniques
used
in
the
literature
to
facilitate
suc
h
reasoning.
W
e
iden
tify
a
se
quential-to-
p
ar
al
lel
tr
ansfer
the
or
em
whic
h,
when
applicable,
allo
ws
us
to
replace
a
piece
of
a
parallel
program
with
another
co
de
fragmen
t
whic
h
is
se
quential
ly
equiv
alen
t,
with
the
guaran
tee
that
the
safet
y
and
liv
eness
prop
erties
of
the
o
v
erall
program
are
unaected.
Tw
o
co
de
fragmen
ts
are
said
to
b
e
sequen
tially
equiv
alen
t
if
they
satisfy
the
same
partial
and
total
correctness
prop
erties.
W
e
also
sp
ecify
b
oth
coarse-
grained
and
ne-grained
v
ersion
of
trace
seman
tics,
assuming
dieren
t
degrees
of
atomicit
y
,
and
w
e
pro
vide
a
c
o
arse-to-ne-gr
aine
d
tr
ansfer
the
or
em
whic
h,
when
applicable,
allo
ws
replacemen
t
of
a
co
de
fragmen
t
b
y
another
fragmen
t
whic
h
is
c
o
arsely
equiv
alen
t,
with
the
guaran
tee
that
the
safet
y
and
liv
eness
prop
erties
of
the
o
v
erall
program
are
unaected
ev
en
if
w
e
assume
ne-grained
atomicit
y
.
Both
of
these
results
p
ermit
the
use
of
a
simpler,
more
abstract
seman
tics,
together
with
a
notion
of
seman
tic
equiv
alence
whic
h
is
easier
to
establish,
to
facilitate
reasoning
ab
out
the
b
eha
vior
of
a
parallel
system
whic
h
w
ould
normally
require
the
use
of
a
more
sophisticated
seman
tic
mo
del.
1
In
tro
duction
It
is
w
ell
kno
wn
that
syn
tax-directed
reasoning
ab
out
b
eha
vioral
prop
erties
of
parallel
programs
tends
to
b
e
complicated
b
y
the
com
binatorial
explosion
1
This
researc
h
is
sp
onsored
in
part
b
y
the
National
Science
F
oundation
(NSF)
under
Gran
t
No.
CCR-9988551.
The
views
and
conclusions
con
tained
in
this
do
cumen
t
are
those
of
the
author,
and
should
not
b
e
in
terpreted
as
represen
ting
the
o√Ücial
p
olicies,
either
expressed
or
implied,
of
the
NSF
or
the
U.S.
go
v
ernmen
t.
2
Email:
brookes@cs.cmu.e
du
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Br
ookes
inheren
t
in
k
eeping
trac
k
of
dynamic
in
teractions
b
et
w
een
co
de
fragmen
ts.
Simple
pro
of
metho
dologies
based
on
state-transformation
seman
tics,
suc
h
as
Hoare-st
yle
logic,
do
not
adapt
easily
to
the
parallel
setting,
b
ecause
they
abstract
a
w
a
y
from
in
teraction
and
only
retain
information
ab
out
the
initial
and
nal
states
observ
ed
in
a
computation.
A
more
sophisticated
seman
tic
mo
del
is
required,
in
whic
h
an
accurate
accoun
t
can
b
e
giv
en
of
in
teraction.
T
race
seman
tics
pro
vides
a
mathematical
framew
ork
in
whic
h
suc
h
rea-
soning
ma
y
b
e
carried
out
[2,3,4,5].
The
trace
set
of
a
program
describ
es
all
p
ossible
patterns
of
in
teraction
b
et
w
een
the
program
and
its
\en
vironmen
t",
assuming
fair
execution
[9].
One
can
dene
b
oth
a
c
o
arse-gr
aine
d
trace
se-
man
tics,
in
whic
h
assignmen
t
and
b
o
olean
expression
ev
aluation
are
assumed
to
b
e
executed
atomically
,
and
a
ne-gr
aine
d
trace
seman
tics,
in
whic
h
reads
and
writes
(to
shared
v
ariables)
are
assumed
to
b
e
atomic.
T
race
seman
tics
can
b
e
dened
denotationally
,
and
is
ful
ly
abstr
act
with
resp
ect
to
a
notion
of
program
b
eha
vior
whic
h
subsumes
partial
correctness,
total
correctness,
safet
y
prop
erties,
and
liv
eness
prop
erties
[2].
T
o
some
exten
t
program
pro
ofs
ma
y
b
e
facilitated
b
y
a
n
um
b
er
of
la
ws
of
program
equiv
alence,
v
alidated
b
y
trace
seman
tics,
whic
h
allo
w
us
to
deduce
prop
erties
of
a
program
b
y
analyzing
instead
a
seman
tically
equiv
alen
t
pro-
gram
with
simpler
structure.
The
use
of
a
succinct
and
compact
notation
for
trace
sets
(based
on
extended
regular
expressions)
can
also
help
streamline
program
analysis.
Y
et
the
problem
remains
that
in
general
the
trace
set
of
a
program
can
b
e
di√Ücult
to
manipulate
and
hard
to
use
to
establish
correct-
ness
prop
erties.
T
race
sets
tend
to
b
e
rather
complex
mathematical
ob
jects,
since
a
trace
set
describ
es
al
l
p
ossible
in
teractions
b
et
w
een
the
program
and
any
p
oten
tial
en
vironmen
t.
F
or
the
same
reason,
b
oth
the
coarse-
and
the
ne-grained
trace
seman
tics
induce
a
rather
discriminating
notion
of
seman
tic
equiv
alence,
and
few
la
ws
of
equiv
alence
familiar
from
the
sequen
tial
setting
also
hold
in
all
parallel
con
texts.
It
can
therefore
b
e
di√Ücult
to
establish
trace
equiv
alence
of
programs
merely
b
y
direct
manipulation
of
the
seman-
tic
denitions,
or
b
y
using
trace-theoretic
la
ws
of
program
equiv
alence
in
a
syn
tax-directed
manner.
In
practice,
parallel
systems
ough
t
to
b
e
designed
carefully
to
ensure
that
the
in
teractions
b
et
w
een
comp
onen
t
pro
cesses
are
highly
disciplined
and
con-
strained.
Moreo
v
er,
when
analyzing
the
prop
erties
of
co
de
to
b
e
run
in
tigh
tly
con
trolled
con
texts,
w
e
ough
t
to
b
e
able
to
w
ork
within
a
simpler
seman
tic
mo
del
(or,
at
least,
within
a
reduced
subset
of
the
trace
seman
tics)
whose
simplicit
y
reects
this
discipline.
Corresp
ondingly
,
whenev
er
w
e
kno
w
that
a
program
fragmen
t
will
b
e
used
in
a
limited
form
of
con
text,
w
e
w
ould
lik
e
to
b
e
able
to
emplo
y
forms
of
reasoning
whic
h
tak
e
adv
an
tage
of
the
limitations.
F
or
example,
w
e
migh
t
kno
w
that
a
piece
of
co
de
is
going
to
b
e
used
\sequen
tially"
inside
a
parallel
program
(in
a
manner
to
b
e
made
precise
so
on)
and
w
an
t
to
use
Hoare-st
yle
reasoning
ab
out
this
co
de
in
establishing
safet
y
and
liv
eness
prop
erties
of
the
whole
program.
It
is
not
generally
safe
24

Br
ookes
to
do
so,
since
la
ws
of
program
equiv
alence
that
hold
in
the
sequen
tial
setting
cease
to
b
e
v
alid
in
parallel
languages
b
ecause
of
the
p
oten
tial
for
in
terference
b
et
w
een
concurren
tly
executing
co
de.
Y
et
lo
c
al
variables
can
only
b
e
accessed
b
y
pro
cesses
o
ccurring
within
a
syn
tactically
prescrib
ed
scop
e,
and
cannot
b
e
c
hanged
b
y
an
y
other
pro
cesses
running
concurren
tly
,
so
w
e
ough
t
to
b
e
able
to
tak
e
adv
an
tage
of
this
non-in
terference
prop
ert
y
to
simplify
reasoning
ab
out
co
de
whic
h
only
aects
lo
cal
v
ariables.
In
particular,
when
lo
cal
v
ariables
are
only
ev
er
used
sequen
tially
,
in
a
con
text
whose
syn
tactic
structure
guaran
tees
that
no
more
than
one
pro
cess
ev
er
gains
concurren
t
access,
w
e
should
b
e
able
to
emplo
y
Hoare-st
yle
reasoning
familiar
from
the
sequen
tial
setting.
W
e
w
ould
lik
e
to
kno
w
the
exten
t
to
whic
h
this
idea
can
b
e
made
precise,
and
when
this
tec
hnique
is
applicable.
In
a
similar
v
ein,
it
is
usually
regarded
as
realistic
to
assume
ne-grained
atomicit
y
when
trying
to
reason
ab
out
program
b
eha
vior,
but
more
con
v
enien
t
to
mak
e
the
less
realistic
but
simplifying
assumption
of
coarse
gran
ularit
y
,
since
this
assumption
ma
y
help
to
reduce
the
com
binatorial
explosion.
W
e
w
ould
lik
e
to
b
e
able
to
iden
tify
conditions
under
whic
h
it
is
safe
to
do
so.
A
n
um
b
er
of
ad
ho
c
tec
hniques
ha
v
e
b
een
prop
osed
along
these
lines
in
the
literature,
usually
without
detailed
consideration
of
seman
tic
foundations
[1].
Their
common
aim
is
to
facilitate
concurren
t
program
analysis
b
y
allo
wing
replacemen
t
of
a
co
de
fragmen
t
b
y
another
piece
of
co
de
with
\simpler"
b
e-
ha
vioral
prop
erties
that
p
ermit
an
easier
correctness
pro
of.
In
this
pap
er
w
e
use
the
trace-theoretic
framew
ork
to
formalize
and
gener-
alize
some
of
these
tec
hniques.
By
pa
ying
careful
atten
tion
to
the
underlying
seman
tic
framew
ork
w
e
are
able
to
recast
these
tec
hniques
in
a
more
precise
manner
and
w
e
can
b
e
more
explicit
ab
out
the
(syn
tactic
and
seman
tic)
as-
sumptions
up
on
whic
h
their
v
alidit
y
rests.
Since
these
tec
hniques
allo
w
us
to
deduce
program
equiv
alence
prop
erties
based
on
one
seman
tic
mo
del
b
y
means
of
reasoning
carried
out
on
top
of
a
dieren
t
seman
tic
mo
del,
w
e
refer
to
our
results
as
tr
ansfer
principles.
W
e
pro
vide
transfer
principles
sp
ecically
designed
to
address
the
t
w
o
example
scenarios
used
for
motiv
ation
ab
o
v
e:
a
se
quential-to-p
ar
al
lel
transfer
principle
allo
wing
use
of
Hoare-st
yle
reasoning,
and
a
c
o
arse-to-ne
transfer
principle
go
v
erning
the
use
of
coarse
seman
tics
in
ne-grained
pro
ofs
of
correctness.
Our
w
ork
can
b
e
seen
as
further
progress
to
w
ards
a
theory
of
c
ontext-
sensitive
development
of
p
ar
al
lel
pr
o
gr
ams,
building
on
earlier
w
ork
of
Cli
Jones
[8]
and
spurred
on
b
y
the
recen
t
Ph.
D.
thesis
of
J

uergen
Dingel
[7].
W
e
fo
cus
our
atten
tion
initially
on
some
metho
dological
ideas
presen
ted
in
Greg
Andrews's
b
o
ok
on
concurren
t
programming
[1].
Later
w
e
in
tend
to
explore
more
fully
the
p
oten
tial
of
our
framew
ork
as
a
basis
for
further
generalization
and
to
extend
our
results
to
co
v
er
some
of
the
con
textual
renemen
t
ideas
in
tro
duced
b
y
Dingel.
In
this
preliminary
v
ersion
of
the
pap
er
w
e
omit
explicit
details
of
the
underlying
trace
seman
tics,
whic
h
the
reader
can
nd
in
[2],
and
w
e
omit
25

Br
ookes
most
of
the
pro
ofs,
whic
h
require
detailed
use
of
the
seman
tic
denitions.
2
Syn
tax
2.1
The
pr
o
gr
amming
language
Our
parallel
programming
language
is
describ
ed
b
y
the
follo
wing
abstract
grammar
for
commands
c,
in
whic
h
b
ranges
o
v
er
b
o
olean-v
alued
expressions,
e
o
v
er
in
teger-v
alued
expressions,
x
o
v
er
iden
tiers,
a
o
v
er
atomic
commands
(nite
sequences
of
assignmen
ts),
and
d
o
v
er
declarations.
The
syn
tax
for
expressions
is
con
v
en
tional
and
is
assumed
to
include
the
usual
primitiv
es
for
arithmetic
and
b
o
olean
op
erations.
c
::=
skip
j
x:
=e
j
c
1
;
c
2
j
if
b
then
c
1
else
c
2
j
while
b
do
c
j
lo
cal
d
in
c
j
a
w
ait
b
then
a
j
c
1
kc
2
d
::=
x
=
e
j
d
1
;
d
2
a
::=
skip
j
x:
=e
j
a
1
;
a
2
A
command
of
form
a
w
ait
b
then
a
is
a
c
onditional
atomic
action,
and
causes
the
execution
of
a
without
in
terruption
when
executed
in
a
state
satisfying
the
test
expression
b;
when
executed
in
a
state
in
whic
h
b
is
false
the
command
idles.
.
A
se
quential
pr
o
gr
am
is
just
a
command
con
taining
no
a
w
ait
and
no
par-
allel
comp
osition.
Assume
giv
en
the
standard
denitions
of
free
(e)
and
free
(b),
the
set
of
iden
tiers
o
ccurring
free
in
an
expression.
W
e
will
use
the
standard
denitions
of
free
(c)
and
free
(d)
for
the
sets
of
iden
tiers
o
ccurring
free
in
a
command
or
a
declaration,
and
dec
(d),
the
set
of
iden
tiers
declared
b
y
d.
2.2
Par
al
lel,
atomic,
and
se
quential
c
ontexts
A
c
ontext
is
a
command
whic
h
ma
y
con
tain
a
syn
tactic
\hole"
(denoted
[ ])
suitable
for
insertion
of
another
command.
F
ormally
,
the
set
of
(parallel)
con
texts,
ranged
o
v
er
b
y
C
,
is
describ
ed
b
y
the
follo
wing
abstract
grammar,
in
whic
h
c
1
;
c
2
again
range
o
v
er
commands:
C
::
=
[ ]
j
skip
j
x:
=
e
j
C
;
c
2
j
c
1
;
C
j
if
b
then
C
else
c
2
j
if
b
then
c
1
else
C
j
while
b
do
C
j
lo
cal
d
in
C
j
a
w
ait
b
then
a
j
C
kc
2
j
c
1
kC
26

Br
ookes
Note
that
our
abstract
grammar
for
con
texts
only
allo
ws
at
most
one
hole
to
app
ear
in
an
y
particular
con
text.
It
w
ould
b
e
straigh
tforw
ard
to
adopt
a
more
general
notion
of
m
ulti-holed
con
text,
but
the
tec
hnical
details
w
ould
b
ecome
more
in
v
olv
ed
and
in
an
y
case
there
is
no
signican
t
loss
of
generalit
y
.
W
e
also
in
tro
duce
the
notion
of
an
atomic
c
ontext,
i.e.
a
parallel
con
text
whose
hole
o
ccurs
inside
the
b
o
dy
of
an
a
w
ait
command.
W
e
will
use
A
to
range
o
v
er
atomic
con
texts.
A
se
quential
c
ontext
is
a
limited
form
of
con
text
in
whic
h
the
hole
nev
er
app
ears
in
parallel.
W
e
can
c
haracterize
the
set
of
sequen
tial
con
texts,
ranged
o
v
er
b
y
S
,
as
follo
ws:
S
::=
[ ]
j
skip
j
x:=e
j
S
;
c
2
j
c
1
;
S
j
if
b
then
S
else
c
2
j
if
b
then
c
1
else
S
j
while
b
do
S
j
lo
cal
d
in
S
j
a
w
ait
b
then
a
j
c
1
kc
2
The
imp
ortan
t
p
oin
t
in
this
denition
is
that
c
1
kS
is
not
a
sequen
tial
con
text
ev
en
when
S
is
sequen
tial,
but
w
e
do
allo
w
\harmless"
uses
of
parallelism
inside
sequen
tial
con
texts,
as
for
example
in
(c
1
kc
2
);
[ ].
The
k
ey
feature
is
that
sequen
tialit
y
of
S
ensures
that
when
w
e
ll
the
hole
with
a
command
w
e
ha
v
e
the
guaran
tee
that
the
command
will
not
b
e
executed
concurren
tly
with
an
y
of
the
rest
of
the
co
de
in
S
.
W
e
write
C
[c]
for
the
command
obtained
b
y
inserting
c
in
to
the
hole
of
C
.
W
e
use
similar
notation
A[a]
for
the
result
of
inserting
an
atomic
command
a
in
to
an
atomic
con
text
A,
and
S
[c]
for
the
result
of
inserting
a
(parallel)
command
c
in
to
a
sequen
tial
con
text
S
.
It
is
easy
to
dene
the
set
free
(C
)
of
iden
tiers
o
ccurring
free
in
a
con
text
C
,
as
usual
b
y
structural
induction.
Similarly
w
e
let
free
(S
)
and
free
(A)
b
e
the
sets
of
iden
tiers
o
ccurring
free
in
sequen
tial
con
text
S
and
in
atomic
con
text
A.
Con
texts
ma
y
also
ha
v
e
a
binding
eect,
since
the
hole
in
a
con
text
ma
y
o
ccur
inside
the
scop
e
of
one
or
more
(nested)
declarations,
and
free
o
ccur-
rences
of
iden
tiers
in
a
co
de
fragmen
t
ma
y
b
ecome
b
ound
after
insertion
in
to
the
hole.
F
or
example,
the
con
text
lo
cal
y
=
0
in
([ ]ky
:=z
+
1)
binds
y
,
but
not
z
.
On
the
other
hand,
the
con
text
(lo
cal
y
=
0
in
c
1
)k([ ];
c
2
)
do
es
not
bind
an
y
iden
tier,
since
the
hole
do
es
not
o
ccur
inside
a
sub
command
of
lo
cal
form.
T
o
b
e
precise
ab
out
this
p
ossibilit
y
w
e
mak
e
the
follo
wing
denition.
W
e
also
mak
e
use
of
analogous
notions
for
sequen
tial
con
texts
and
for
atomic
27

Br
ookes
con
texts,
whic
h
ma
y
b
e
dened
in
the
ob
vious
analogous
w
a
y
.
Although
w
e
will
not
pro
v
e
this
here,
it
follo
ws
from
the
denition
that
(except
for
the
case
of
a
degenerate
con
text
with
no
hole)
for
all
con
texts
C
and
commands
c,
free
(C
[c])
=
free
(C
)
[
(free
(c)
 bound
(C
)).
Denition
2.1
F
or
a
con
text
C
,
let
bound
(C
)
b
e
the
set
of
iden
tiers
for
whic
h
there
is
a
binding
declaration
enclosing
the
hole
in
C
,
dened
as
follo
ws:
bound
([ ])
=
;
bound
(x:
=e)
=
;
bound
(C
;
c
2
)
=
bound
(c
1
;
C
)
=
bound
(C
)
bound
(if
b
then
C
else
c
2
)
=
bound
(if
b
then
c
1
else
C
)
=
bound
(C
)
bound
(while
b
do
C
)
=
bound
(C
)
bound
(a
w
ait
b
then
a)
=
;
bound
(C
kc
2
)
=
bound
(c
1
kC
)
=
bound
(C
)
bound
(lo
cal
d
in
C
)
=
bound
(C
)
[
dec(d)
3
Seman
tics
3.1
Op
er
ational
semantics
W
e
assume
con
v
en
tional
coarse-grained
and
ne-grained
op
erational
seman
tics
for
expressions
and
commands
[2].
In
b
oth
cases
command
congurations
ha
v
e
the
form
hc;
si,
where
c
is
a
command
and
s
is
a
state.
A
state
s
determines
a
(nite,
partial)
function
from
iden
tiers
to
v
ariables,
and
a
\store"
mapping
v
ariables
to
their
\curren
t"
in
teger
v
alues.
A
transition
of
form
hc;
si
!
hc
0
;
s
0
i
represen
ts
the
eect
of
c
p
erforming
an
atomic
step
enabled
in
state
s,
resulting
in
a
c
hange
of
state
to
s
0
,
with
c
0
remaining
to
b
e
executed.
A
terminal
conguration,
in
whic
h
all
parallel
comp
onen
t
commands
ha
v
e
terminated,
is
represen
ted
b
y
a
(nal)
state
s.
In
a
ne-grained
seman
tics
reads
and
writes
to
v
ariables
are
atomic,
but
assignmen
ts
and
b
o
olean
condition
ev
aluations
need
not
b
e.
In
a
coarse-grained
seman
tics,
assignmen
ts
and
b
o
olean
expressions
are
atomic.
A
c
omputation
of
a
command
c
is
a
nite
sequence
of
transitions,
ending
in
a
terminal
conguration,
or
an
innite
sequence
of
transitions
that
is
fair
to
all
parallel
comp
onen
t
commands
of
c.
(W
e
ma
y
also
refer
to
a
ne-gr
aine
d
c
omputation
or
a
c
o
arse-gr
aine
d
c
omputation,
when
w
e
need
to
b
e
precise
ab
out
whic
h
gran
ularit
y
assumption
is
relev
an
t.)
W
e
write
hc;
si
!

hc
0
;
s
0
i
to
indicate
a
nite,
p
ossibly
empt
y
,
sequence
of
transitions;
and
hc;
si
!
!
to
indicate
the
existence
of
a
(w
eakly)
fair
innite
computation
starting
from
a
28

Br
ookes
giv
en
conguration.
An
inter
active
c
omputation
is
a
nite
or
innite
sequence
of
transitions
in
whic
h
the
state
ma
y
b
e
c
hanged
b
et
w
een
steps,
represen
ting
the
eect
of
other
commands
executing
in
parallel.
There
is
an
analogous
notion
of
fairness
for
in
teractiv
e
computations.
A
computation
is
just
an
in
terference-free
in
teractiv
e
computation,
that
is,
an
in
teractiv
e
computation
in
whic
h
no
external
c
hanges
o
ccur.
3.2
State-tr
ansformation
semantics
and
se
quential
e
quivalenc
e
Denition
3.1
The
standard
state-transformation
seman
tics
for
programs,
denoted
M,
is
c
haracterized
op
erationally
b
y:
M(c)
=
f(s;
s
0
)
j
hc;
si
!

s
0
g
[
f(s;
?)
j
hc;
si
!
!
g:
Denition
3.2
Tw
o
programs
c
1
and
c
2
are
se
quential
ly
e
quivalent,
written
c
1

M
c
2
,
if
and
only
if
M(c
1
)
=
M(c
2
).
As
is
w
ell
kno
wn,
sequen
tial
equiv
alence
is
a
congruence
with
resp
ect
to
the
sequen
tial
subset
of
our
programming
language.
In
fact,
for
all
parallel
programs
c
1
and
c
2
,
and
all
se
quential
con
texts
S
,
c
1

M
c
2
,
S
[c
1
]

M
S
[c
2
]:
Ho
w
ev
er,
the
analogous
prop
ert
y
fails
to
hold
for
p
ar
al
lel
con
texts,
b
ecause,
for
example,
w
e
ha
v
e:
x:
=x
+
2

M
x:=x
+
1;
x:
=
x
+
1
but
x:
=x
+
2ky
:
=x
6
M
(x:
=x
+
1;
x:
=x
+
1)ky
:
=x:
3.3
T
r
ac
e
semantics
A
transition
trace
of
a
program
c
is
a
nite
or
innite
sequence
of
steps,
eac
h
step
b
eing
a
pair
of
states
that
represen
ts
the
eect
of
a
nite
se-
quence
of
atomic
actions
p
erformed
b
y
the
program.
A
particular
trace
(s
0
;
s
0
0
)(s
1
;
s
0
1
)
:
:
:
(s
n
;
s
0
n
)
:
:
:
of
c
represen
ts
a
p
ossible
fair
in
teractiv
e
compu-
tation
of
c
in
whic
h
the
in
ter-step
state
c
hanges
(from
s
0
0
to
s
1
,
and
so
on)
are
assumed
to
b
e
caused
b
y
pro
cesses
executing
concurren
tly
to
c.
T
races
are
\complete",
represen
ting
an
en
tire
in
teractiv
e
computation,
rather
than
\par-
tial"
or
\incomplete".
A
trace
is
interfer
enc
e-fr
e
e
if
the
state
nev
er
c
hanges
b
et
w
een
successiv
e
steps
along
the
trace,
i.e.
in
the
notation
used
ab
o
v
e
when
w
e
ha
v
e
s
0
i
=
s
i+1
for
all
i.
An
in
terference-free
trace
represen
ts
a
sequence
of
snapshots
of
the
state
tak
en
during
an
in
terference-free
fair
computation.
Again
w
e
obtain
b
oth
a
coarse-grained
notion
of
trace,
based
on
the
coarse
in
terpretation
of
atomicit
y
and
the
coarse-grained
op
erational
seman
tics,
and
a
ne-grained
notion
of
trace,
based
on
the
ne
in
terpretation
of
atomicit
y
and
the
ne-grained
op
erational
seman
tics.
Both
coarse-
and
ne-grained
trace
29

Br
ookes
seman
tics
in
terpret
conditional
atomic
actions
a
w
ait
b
then
a
as
atomic.
The
coarse-grained
trace
seman
tics,
whic
h
w
e
will
denote
T
c
o
arse
,
also
assumes
that
assignmen
ts
and
b
o
olean
expression
ev
aluations
are
atomic.
The
ne-
grained
seman
tics,
denoted
T
ne
,
assumes
only
that
reads
and
writes
to
simple
v
ariables
are
atomic.
In
the
rest
of
this
pap
er,
when
stating
a
result
whic
h
holds
for
b
oth
ne-
and
coarse-grained
seman
tics,
w
e
ma
y
use
T
to
stand
for
either
v
ersion
of
the
trace
seman
tic
function.
T
race
seman
tics
can
b
e
dened
comp
ositionally
,
and
w
e
note
in
particular
that
the
traces
of
c
1
kc
2
are
obtained
b
y
forming
fair
merges
of
a
trace
of
c
1
with
a
trace
of
c
2
,
and
the
traces
of
c
1
;
c
2
are
obtained
b
y
concatenating
a
trace
of
c
1
with
a
trace
of
c
2
,
closing
up
under
stuttering
and
m
um
bling
as
required.
The
traces
of
lo
cal
x
=
e
in
c
do
not
c
hange
the
v
alue
of
(the
\global"
v
ersion
of
)
x,
and
are
obtained
b
y
pro
jection
from
traces
of
c
in
whic
h
the
v
alue
of
(the
\lo
cal"
v
ersion
of
)
x
is
nev
er
altered
b
et
w
een
steps.
A
parallel
program
denotes
a
trace
set
closed
under
t
w
o
natural
conditions
termed
stuttering
and
mumbling,
whic
h
corresp
ond
to
our
use
of
a
step
to
rep-
resen
t
nite
sequences
of
actions:
idle
or
stuttering
steps
of
form
(s;
s)
ma
y
b
e
inserted
in
to
traces,
and
whenev
er
t
w
o
adjacen
t
steps
(s;
s
0
)(s
0
;
s
00
)
share
the
same
in
termediate
state
they
can
b
e
com
bined
to
pro
duce
a
m
um
bled
trace
whic
h
instead
con
tains
the
step
(s;
s
00
).
The
closure
prop
erties
ensure
that
trace
seman
tics
is
ful
ly
abstr
act
with
resp
ect
to
a
notion
of
b
eha
vior
whic
h
assumes
that
w
e
can
observ
e
the
state
during
execution.
As
a
result
trace
seman
tics
supp
orts
comp
ositional
reasoning
ab
out
safet
y
and
liv
eness
prop
er-
ties.
Safet
y
prop
erties
t
ypically
assert
that
no
\bad"
state
ev
er
o
ccurs
when
a
pro
cess
is
executed,
without
in
terference,
from
an
initial
state
satisfying
some
pre-condition.
A
liv
eness
prop
ert
y
t
ypically
asserts
that
some
\go
o
d"
state
ev
en
tually
o
ccurs.
When
t
w
o
pro
cesses
ha
v
e
the
same
trace
sets
it
follo
ws
that
they
satisfy
iden
tical
sets
of
safet
y
and
liv
eness
prop
erties,
in
all
parallel
con
texts.
3.4
Fine-
and
c
o
arse-gr
aine
d
semantic
e
quivalenc
es
When
using
coarse-grained
seman
tics
one
can
safely
use
algebraic
la
ws
of
arithmetic
to
simplify
reasoning
ab
out
program
b
eha
vior.
F
or
instance,
in
coarse-grained
trace
seman
tics
the
assignmen
ts
x:=x
+
x
and
x:=2

x
are
equiv
alen
t.
This
feature
can
b
e
used
to
considerable
adv
an
tage
in
program
analysis.
Ho
w
ev
er,
coarse
gran
ularit
y
is
in
general
an
unrealistic
assumption
since
implemen
tations
of
parallel
programming
languages
do
not
generally
guaran
tee
that
assignmen
ts
are
indeed
executed
indivisibly
.
The
ne-grained
trace
seman
tics
is
closer
in
practice
to
con
v
en
tional
imple-
men
tations,
but
less
con
v
enien
t
in
program
analysis.
When
using
ne-grained
seman
tics
one
cannot
assume
with
impunit
y
that
algebraic
la
ws
of
expression
equiv
alence
remain
v
alid.
F
or
instance,
the
assignmen
ts
x:=x
+
x
and
x:
=
2

x
are
not
equiv
alen
t
in
ne-grained
trace
seman
tics;
this
reects
the
fact
that
30

Br
ookes
the
former
reads
x
t
wice,
so
that
if
x
is
c
hanged
during
execution
(sa
y
from
0
to
1),
the
v
alue
assigned
ma
y
b
e
0;
1
or
2,
whereas
the
latter
assignmen
t
(under
the
same
circumstances)
w
ould
assign
either
0
or
2.
It
should
b
e
clear
from
the
ab
o
v
e
discussion,
ev
en
without
seeing
all
of
the
seman
tic
denitions,
that
despite
the
connotations
suggested
b
y
our
use
of
\ne"
vs.
\coarse",
these
t
w
o
trace
seman
tic
v
arian
ts
induce
inc
omp
ar
able
notions
of
seman
tic
equiv
alence.
Let
us
write
c
1

c
o
arse
c
2
,
T
c
o
arse
(c
1
)
=
T
c
o
arse
(c
2
)
c
1

ne
c
2
,
T
ne
(c
1
)
=
T
ne
(c
2
)
F
or
instance,
w
e
ha
v
e
already
seen
a
pair
of
programs
whic
h
are
equiv
alen
t
in
coarse-grained
seman
tics
but
not
in
ne-grained:
x:
=x
+
x

c
o
arse
x:
=2

x;
x:=x
+
x
6
ne
x:
=2

x;
so
that
c
1

c
o
arse
c
2
do
es
not
alw
a
ys
imply
c
1

ne
c
2
.
The
con
v
erse
implication
also
fails,
as
sho
wn
b
y
the
programs
x:
=x
+
x
and
lo
cal
y
=
0;
z
=
0
in
(y
:
=x;
z
:
=x;
x:=y
+
z
)
These
are
equiv
alen
t
in
ne-grained
but
not
in
coarse-grained
seman
tics.
Despite
the
incomparabilit
y
of
ne-grained
equiv
alence
and
coarse-grained
equiv
alence,
for
an
y
particular
program
c
the
coarse-grained
trace
set
will
b
e
a
subset
of
its
ne-grained
traces:
T
c
o
arse
(c)

T
ne
(c);
so
that
it
is
reasonable
to
refer
to
the
coarse-grained
seman
tics
as
\simpler".
W
e
also
remark
that
the
state-transformation
seman
tics
of
a
parallel
pro-
gram
is
determined
b
y
its
trace
seman
tics,
in
fact
b
y
its
interfer
enc
e-fr
e
e
traces,
since
(s;
s
0
)
2
M(c)
if
and
only
if
(s;
s
0
)
2
T
ne
(c),
and
(s;
?)
2
M(c)
if
and
only
if
there
is
an
innite
in
terference-free
trace
in
T
ne
(c)
b
eginning
from
state
s.
(Here
w
e
adopt
the
usual
pun
of
viewing
(s;
s
0
)
sim
ultaneously
as
a
p
air
b
elonging
to
M(c)
and
as
a
tr
ac
e
of
length
1
b
elonging
to
T
(c).
Suc
h
a
trace
is
trivially
in
terference-free.)
Eac
h
trace
equiv
alence
is
a
congruence
for
the
en
tire
parallel
language,
so
that
for
all
con
texts
C
and
parallel
commands
c
1
and
c
2
w
e
ha
v
e:
c
1

c
o
arse
c
2
,
C
[c
1
]

c
o
arse
C
[c
2
]
c
1

ne
c
2
,
C
[c
1
]

ne
C
[c
2
]
Moreo
v
er,
c
1

ne
c
2
implies
c
1

M
c
2
,
but
the
con
v
erse
implication
is
not
generally
v
alid.
4
Reads
and
writes
of
a
command
T
o
prepare
the
ground
for
our
transfer
principles,
w
e
rst
need
to
dene
for
eac
h
parallel
program
c
the
multiset
reads
(c)
of
iden
tier
o
ccurrences
whic
h
31

Br
ookes
app
ear
free
in
non-atomic
sub-expressions
of
c.
It
is
vital
here,
as
suggested
b
y
the
terminology
,
to
k
eep
trac
k
of
ho
w
man
y
references
the
program
mak
es,
to
eac
h
iden
tier.
W
e
need
only
b
e
concerned
with
non-atomic
subphrases,
since
these
are
the
only
ones
whose
execution
ma
y
b
e
aected
b
y
concurren
t
activit
y
.
W
e
also
need
to
refer
to
the
analogous
notions
for
expressions
and
for
declarations;
since
w
e
ha
v
e
not
pro
vided
a
full
grammar
for
expressions
w
e
will
giv
e
details
only
for
a
few
k
ey
cases,
whic
h
su√Üce
for
understanding
all
of
the
examples
whic
h
follo
w
and
whic
h
con
v
ey
the
general
ideas.
F
or
precise
mathematical
purp
oses,
w
e
ma
y
think
of
a
m
ultiset
as
a
set
of
iden
tiers
equipp
ed
with
a
non-negativ
e
m
ultiplicit
y
coun
t.
In
the
empt
y
m
ultiset
ev
ery
iden
tier
has
m
ultiplicit
y
0.
When
M
1
and
M
2
are
m
ultisets,
w
e
let
M
1
[
+
M
2
b
e
the
m
ultiset
union
in
whic
h
m
ultiplicities
are
added,
and
M
1
[
max
M
2
b
e
the
m
ultiset
union
in
whic
h
m
ultiplicities
are
com
bined
using
max.
That
is,
an
iden
tier
x
whic
h
o
ccurs
n
1
times
in
M
1
and
n
2
times
in
M
2
will
o
ccur
n
1
+
n
2
times
in
M
1
[
+
M
2
and
max
(n
1
;
n
2
)
times
in
M
1
[
max
M
2
.
W
e
write
f
jxj
g
for
the
singleton
m
ultiset
con
taining
a
single
o
ccurrence
of
x.
W
e
also
write
f
j
j
g
for
the
empt
y
m
ultiset.
The
cardinalit
y
of
a
m
ultiset
M
is
denoted
jM
j.
Eac
h
v
ersion
of
union
is
symmetric
and
asso
ciativ
e:
M
1
[
+
M
2
=
M
2
[
+
M
1
M
1
[
+
(M
2
[
+
M
3
)
=
(M
1
[
+
M
2
)
[
+
M
3
M
1
[
max
M
2
=
M
2
[
max
M
1
M
1
[
max
(M
2
[
max
M
3
)
=
(M
1
[
max
M
2
)
[
max
M
3
In
addition,
[
max
is
idemp
oten
t:
M
[
max
M
=
M
Ob
viously
[
+
is
not
idemp
oten
t.
The
empt
y
m
ultiset
is
a
unit
for
b
oth
forms
of
union,
since
M
[
+
f
j
j
g
=
M
[
max
f
j
j
g
=
M
:
Giv
en
a
m
ultiset
M
and
a
set
X
of
iden
tiers,
w
e
dene
M
 X
to
b
e
the
m
ultiset
obtained
from
M
b
y
remo
ving
all
o
ccurrences
of
iden
tiers
in
X
,
and
w
e
let
M
\
X
b
e
the
m
ultiset
consisting
of
those
mem
b
ers
of
M
whic
h
are
also
in
X
,
with
the
same
m
ultiplicities
as
they
ha
v
e
in
M
.
W
e
are
no
w
ready
to
dene
the
read
m
ultiset
of
an
expression.
Again
w
e
include
only
a
few
represen
tativ
e
cases.
Note
that
w
e
will
use
the
additiv
e
form
of
m
ultiset
union
for
an
expression
of
form
e
1
+
e
2
(and
also,
in
general,
for
expressions
built
with
binary
op
erators),
b
ecause
w
e
w
an
t
to
coun
t
the
n
um
b
er
of
times
an
iden
tier
needs
to
b
e
read
during
the
ev
aluation
of
an
expression.
32

Br
ookes
Denition
4.1
The
m
ultiset
reads
(e)
of
free
iden
tier
o
ccurrences
in
an
ex-
pression
e
is
giv
en
inductiv
ely
b
y:
reads
(n)
=
f
j
j
g
reads
(x)
=
f
jxj
g
reads
(e
1
+
e
2
)
=
reads
(e
1
)
[
+
reads
(e
2
)
A
similar
denition
can
b
e
giv
en
for
b
o
olean
expressions.
Denition
4.2
The
m
ultiset
reads
(d)
of
free
iden
tier
o
ccurrences
in
a
dec-
laration
d
is
giv
en
inductiv
ely
b
y:
reads
(x
=
e)
=
reads
(e)
reads
(d
1
;
d
2
)
=
reads
(d
1
)
[
max
(reads
(d
2
)
 dec
(d
1
))
Here
w
e
com
bine
using
maxim
um
since
d
ma
y
require
the
separate
ev
alu-
ation
of
sev
eral
sub-expressions.
No
w
w
e
can
pro
vide
the
denition
for
commands:
Denition
4.3
The
m
ultiset
reads
(c)
of
free
iden
tier
o
ccurrences
read
b
y
command
c
is
giv
en
inductiv
ely
b
y:
reads
(skip)
=
f
j
j
g
reads
(x:=e)
=
reads
(e)
reads
(c
1
;
c
2
)
=
reads
(c
1
kc
2
)
=
reads
(c
1
)
[
max
reads
(c
2
)
reads
(if
b
then
c
1
else
c
2
)
=
reads
(b)
[
max
(reads
(c
1
)
[
max
reads
(c
2
))
reads
(while
b
do
c)
=
reads
(b)
[
max
reads
(c)
reads
(a
w
ait
b
then
a)
=
f
j
j
g
reads
(lo
cal
d
in
c)
=
reads
(d)
[
max
(reads
(c)
 dec
(d))
Again
w
e
use
the
maxim
um-forming
union
op
eration
to
com
bine
the
coun
ts
from
all
sub-expression
ev
aluations.
Notice
that
w
e
regard
an
a
w
ait
command
as
ha
ving
no
reads,
b
ecause
it
will
b
e
executed
atomically
and
its
eect
will
therefore
b
e
imm
une
from
concurren
t
in
terference.
Next
w
e
dene
the
set
writes
(c)
of
iden
tier
o
ccurrences
whic
h
o
ccur
free
in
c
as
targets
of
assignmen
ts.
It
will
turn
out
that
w
e
do
not
need
an
accurate
coun
t
of
ho
w
man
y
times
an
individual
iden
tier
is
assigned,
just
the
kno
wledge
of
whether
or
not
eac
h
iden
tier
is
assigned
to:
ev
en
once
is
bad
enough.
Our
denition
ensures
that
x
2
writes
(c)
if
and
only
if
there
is
at
least
one
free
o
ccurrence
of
x
in
c
in
a
sub-command
of
the
form
x:
=e.
Denition
4.4
The
set
writes
(c)
of
iden
tiers
o
ccurring
freely
as
targets
of
33

Br
ookes
assignmen
t
in
c
is
giv
en
b
y:
writes
(skip
)
=
;
writes
(x:
=
e)
=
fxg
writes
(c
1
;
c
2
)
=
writes
(c
1
kc
2
)
=
writes
(c
1
)
[
writes
(c
2
)
writes
(if
b
then
c
1
else
c
2
)
=
writes
(c
1
)
[
writes
(c
2
)
writes
(while
b
do
c)
=
writes
(c)
writes
(a
w
ait
b
then
a)
=
writes
(a)
writes
(lo
cal
d
in
c)
=
writes
(c)
 dec(d)
5
Concurren
t
reads
and
writes
of
a
con
text
Next
w
e
dene,
for
eac
h
parallel
con
text
C
,
the
pair
crw(C
)
=
(R
;
W
),
where
R
is
the
set
of
iden
tiers
whic
h
o
ccur
free
in
ev
aluation
con
texts
concurren
t
to
a
hole
of
C
,
and
W
is
the
set
of
iden
tiers
o
ccurring
free
in
assigning
con-
texts
concurren
t
to
a
hole.
As
usual
the
denition
is
inductiv
e.
It
su√Üces
to
w
ork
with
sets
here
rather
than
m
ultisets,
since
what
matters
for
our
presen
t
purp
oses
is
whether
or
not
the
con
text
ma
y
c
hange
an
iden
tier's
v
alue
concur-
ren
tly
while
whatev
er
command
o
ccupies
the
hole
is
running,
not
ho
w
man
y
times
the
con
text
ma
y
do
this;
ev
en
once
is
bad
enough.
Denition
5.1
The
concurren
t-reads-and-writes
of
a
con
text
C
are
giv
en
b
y:
crw
([ ])
=
crw
(skip
)
=
crw
(x:=e)
=
(;;
;)
crw
(C
;
c
2
)
=
crw
(c
1
;
C
)
=
crw
(C
)
crw
(if
b
then
c
1
else
C
)
=
crw(if
b
then
C
else
c
2
)
=
crw
(C
)
crw
(while
b
do
C
)
=
crw(C
)
crw
(a
w
ait
b
then
a)
=
(;;
;)
crw
(lo
cal
d
in
C
)
=
crw
(C
)
crw
(ckC
)
=
crw(C
kc)
=
(R
[
reads
(c);
W
[
writes
(c));
where
(R
;
W
)
=
crw
(C
)
Note
that
the
clause
for
lo
cal
d
in
C
ma
y
include
in
the
concurren
t
reads
and
writes
some
of
the
iden
tiers
declared
b
y
d;
when
co
de
is
inserted
in
to
the
con
text
o
ccurrences
of
these
iden
tiers
b
ecome
b
ound,
but
w
e
still
need
to
kno
w
if
and
ho
w
the
co
de
uses
these
iden
tiers
concurren
tly
.
34

Br
ookes
6
T
ransfer
principles
W
e
no
w
state
some
fundamen
tal
prop
erties
of
trace
seman
tics,
whic
h
formalize
the
sense
in
whic
h
the
b
eha
vior
of
a
parallel
program
dep
ends
only
on
the
v
alues
of
its
free
iden
tiers.
W
e
sa
y
that
t
w
o
states
s
and
s
0
agr
e
e
on
a
set
X
of
iden
tiers
if
they
map
eac
h
iden
tier
in
this
set
to
(v
ariables
whic
h
ha
v
e)
the
same
in
teger
v
alue.
These
prop
erties
are
analogues
in
the
parallel
setting
of
\Agreemen
t"
prop
erties
familiar
from
the
sequen
tial
setting.
Their
pro
ofs
are
straigh
tforw
ard
structural
inductions
based
on
the
trace
seman
tic
denitions.
Theorem
6.1
L
et

b
e
a
tr
ac
e
of
c
and
(s;
s
0
)
b
e
a
step
of

.
Then
s
agr
e
es
with
s
0
on
al
l
identiers
not
in
writes
(c).
2
Theorem
6.2
L
et
(s
0
;
s
0
0
)(s
1
;
s
0
1
)
:
:
:
(s
n
;
s
0
n
)
:
:
:
b
e
a
tr
ac
e
of
c.
Then
for
every
se
quenc
e
of
states
t
0
;
t
1
;
:
:
:
;
t
n
;
:
:
:
such
that
for
al
l
i

0,
t
i
agr
e
es
with
s
i
on
X

reads
(c),
ther
e
is
a
tr
ac
e
(t
0
;
t
0
0
)(t
1
;
t
0
1
)
:
:
:
(t
n
;
t
0
n
)
:
:
:
of
c
such
that
for
al
l
i

0,
t
0
i
agr
e
es
with
t
i
on
X
[
writes
(c).
2
Ha
ving
set
up
the
relev
an
t
bac
kground
denitions
and
this
k
ey
agreemen
t
lemma
w
e
can
no
w
presen
t
the
transfer
principles
to
whic
h
w
e
ha
v
e
b
een
leading.
6.1
A
tr
ansfer
principle
for
atomic
c
ontexts
The
rst
one
is
almost
to
o
ob
vious
to
include:
it
su√Üces
to
use
sequen
tial
reasoning
ab
out
an
y
co
de
used
in
a
syn
tactically
atomic
con
text.
This
holds
in
b
oth
coarse-
and
ne-grained
seman
tics,
so
w
e
will
use

T
to
stand
for
either
form
of
trace
equiv
alence.
Theorem
6.3
If
A
is
an
atomic
c
ontext
and
a
1

M
a
2
,
then
A[a
1
]

T
A[a
2
].
Pro
of.
The
traces
of
a
w
ait
b
then
a
dep
end
only
on
the
\atomic"
traces
of
a,
i.e.
on
the
traces
of
a
whic
h
represen
t
unin
terrupted
complete
executions;
and
(s;
s
0
)
is
an
atomic
trace
of
a
i
(s;
s
0
)
2
M(a).
2
6.2
A
se
quential
tr
ansfer
principle
The
next
transfer
principle
iden
ties
conditions
under
whic
h
sequen
tial
equiv
a-
lence
of
co
de
fragmen
ts
can
safely
b
e
relied
up
on
to
establish
trace
equiv
alence
of
parallel
programs.
Theorem
6.4
If
free
(c
1
)
[
free
(c
2
)

bound
(C
),
and
(R
;
W
)
=
crw
(C
),
and
jreads
(c
i
)
\
W
j
+
jwrites
(c
i
)
\
R
j
=
0;
i
=
1;
2
then
c
1

M
c
2
)
C
[c
1
]

T
C
[c
2
]:
2
35

Br
ookes
It
is
w
orth
noting
that
the
pro
visos
built
in
to
this
theorem
are
essen
tial.
If
w
e
omit
the
lo
cal
declaration
around
the
con
text
the
result
b
ecomes
in
v
alid,
since
the
assumption
that
c
1
and
c
2
are
sequen
tially
equiv
alen
t
is
not
strong
enough
to
imply
that
c
1
and
c
2
are
trace
equiv
alen
t.
And
if
w
e
try
to
use
the
co
de
fragmen
ts
in
a
con
text
with
whic
h
it
in
teracts
non-trivially
again
the
result
fails:
when
c
1
and
c
2
are
sequen
tially
equiv
alen
t
it
do
es
not
follo
w
that
lo
cal
d
in
(ckc
1
)
and
lo
cal
d
in
(ckc
2
)
are
trace
equiv
alen
t
for
all
c,
ev
en
if
d
declares
all
of
the
free
iden
tiers
of
c
1
and
c
2
.
A
sp
ecic
coun
terexample
is
obtained
b
y
considering
the
commands
c
1
:
x:=x
+
1;
x:=x
+
1
c
2
:
x:=x
W
e
ha
v
e
reads
(c
i
)
=
f
jxj
g,
writes
(c
i
)
=
fxg.
Let
C
b
e
the
con
text
lo
cal
x
=
0
in
(([ ]kx:
=2);
y
:
=x):
Then
bound
(C
)
=
fxg
and
crw
(C
)
=
(;;
fxg).
Using
the
notation
of
the
theorem,
w
e
ha
v
e
jreads
(c
i
)
\
W
j
=
1;
jwrites
(c
i
)
\
R
j
=
0
so
that
the
assumption
is
violated.
And
it
is
easy
to
see
that
c
1

M
c
2
,
but
C
[c
1
]

T
y
:=0
or
y
:=
1
or
y
:=
2
C
[c
2
]

T
y
:=0
or
y
:=
2
so
that
C
[c
1
]
6
T
C
[c
2
].
3
Another
example
sho
ws
that
the
other
half
of
the
assumption
cannot
b
e
relaxed.
Consider
c
1
:
x:=1;
while
true
do
skip
c
2
:
x:=2;
while
true
do
skip
Let
C
b
e
the
con
text
lo
cal
x
=
0
in
([ ]ky
:=x):
Then
bound
(C
)
=
fxg,
free
(c
i
)
=
writes
(c
i
)
=
fxg,
and
reads
(c
i
)
=
f
j
j
g.
Moreo
v
er
c
1

M
c
2
,
since
M(c
i
)
=
f(s;
?)
j
s
2
Sg
(i
=
1;
2).
W
e
ha
v
e
jreads
(c
i
)
\
W
j
=
0;
jwrites
(c
i
)
\
R
j
=
1
so
that
the
assumption
is
violated
again.
And
w
e
also
ha
v
e
C
[c
1
]

T
(y
:
=0
or
y
:=1);
while
true
do
skip
C
[c
2
]

T
(y
:
=0
or
y
:=2);
while
true
do
skip
3
Although
our
programming
language
did
not
include
a
non-deterministic
c
hoice
op
erator
c
1
or
c
2
it
is
con
v
enien
t
to
use
it
as
here,
to
sp
ecify
a
command
that
b
eha
v
es
lik
e
c
1
or
lik
e
c
2
;
in
terms
of
trace
sets
w
e
ha
v
e
T
(c
1
or
c
2
)
=
T
(c
1
)
[
T
(c
2
),
a
similar
equation
holiding
in
coarse-
and
in
ne-grained
v
ersions.
36

Br
ookes
so
that
C
[c
1
]
6
T
C
[c
2
].
The
ab
o
v
e
theorem
is
alw
a
ys
applicable
in
the
sp
ecial
case
where
the
con-
text
is
sequen
tial.
W
e
therefore
state
the
follo
wing:
Corollary
6.5
If
S
is
a
se
quential
c
ontext,
and
free
(c
1
)[free
(c
2
)

bound
(S
),
then
c
1

M
c
2
)
S
[c
1
]

T
S
[c
2
]:
Pro
of.
When
S
is
sequen
tial
w
e
can
sho
w,
b
y
induction
on
the
structure
of
S
,
that
crw
(S
)
=
(;;
;).
2
T
o
illustrate
the
b
enets
of
these
results,
note
that
man
y
simple
la
ws
of
sequen
tial
equiv
alence
are
w
ell
kno
wn,
and
tend
to
b
e
tak
en
for
gran
ted
when
reasoning
ab
out
sequen
tial
programs.
Note
in
particular
the
follo
wing
instances
of
de
Bakk
er's
la
ws
of
(sequen
tial)
equiv
alence
[6],
whic
h
can
b
e
used
to
simplify
sequences
of
assignmen
ts:
x:
=x

M
skip
x:
=e
1
;
x:=e
2

M
x:
=
[e
1
=x]e
2
x
1
:=e
1
;
x
2
:=e
2

M
x
2
:=e
2
;
x
1
:=e
1
;
if
x
1
62
free
(e
2
)
&
x
2
62
free
(e
1
)
&
x
1
6=
x
2
These
la
ws
fail
to
hold
in
the
parallel
setting,
and
b
ecome
unsound
when

M
is
replaced
b
y

ne
or

c
o
arse
.
Our
result
sho
ws
the
exten
t
to
whic
h
suc
h
la
ws
ma
y
safely
b
e
used
when
reasoning
ab
out
the
safet
y
and
liv
eness
prop
erties
of
p
ar
al
lel
programs,
p
oin
ting
out
su√Ücien
t
conditions
under
whic
h
sequen
tial
analysis
of
k
ey
co
de
fragmen
ts
is
enough
to
ensure
correctness
of
a
parallel
program.
6.3
A
c
o
arse-
to
ne-gr
aine
d
tr
ansfer
principle
Finally
,
w
e
no
w
consider
what
requiremen
ts
m
ust
b
e
satised
in
order
to
safely
emplo
y
coarse-grained
trace-based
reasoning
in
establishing
ne-grained
equiv
alences.
This
ma
y
b
e
b
enecial,
as
remark
ed
earlier,
since
for
a
giv
en
co
de
fragmen
t
the
coarse-grained
trace
set
forms
a
(usually
prop
er)
subset
of
the
ne-grained
trace
set
and
ma
y
therefore
p
ermit
a
streamlined
analysis.
This
is
esp
ecially
imp
ortan
t
for
co
de
whic
h
ma
y
b
e
executed
concurren
tly
,
since
it
ma
y
help
minimize
the
com
binatorial
analysis.
Indeed,
Andrews
[1]
supplies
a
series
of
examples
of
proto
cols
in
whic
h
a
\ne-grained"
solution
to
a
parallel
programming
problem
(suc
h
as
m
utual
exclusion)
is
deriv
ed
b
y
syn
tactic
transformation
from
a
\coarse-grained"
solution
whose
correctness
is
view
ed
as
easier
to
establish.
Common
to
all
of
these
examples
is
the
desire
to
app
eal
to
coarse-grained
reasoning
when
trying
to
establish
correctness
in
the
ne-grained
setting.
W
e
b
egin
with
a
so-called
\at-most-once"
prop
ert
y
that
Andrews
uses
informally
to
facilitate
the
analysis
and
dev
elopmen
t
of
a
collection
of
m
utual
37

Br
ookes
exclusion
proto
col
designs.
The
relev
an
t
denitions
from
Andrews,
adapted
to
our
setting,
are
as
follo
ws:

An
expression
b
(or
e)
has
the
at-most-once
prop
ert
y
if
it
refers
to
at
most
one
iden
tier
that
migh
t
b
e
c
hanged
b
y
another
pro
cess
while
the
expression
is
b
eing
ev
aluated,
and
it
refers
to
this
iden
tier
at
most
once.

An
assignmen
t
x:
=e
has
the
at-most-once
prop
ert
y
if
either
e
has
the
at-
most-once
prop
ert
y
and
x
is
not
read
b
y
another
pro
cess,
or
if
e
do
es
not
refer
to
an
y
iden
tier
that
ma
y
b
e
c
hanged
b
y
another
pro
cess.

A
command
c
has
the
at-most-once
prop
ert
y
if
ev
ery
assignmen
t
and
b
o
olean
test
o
ccurring
non-atomically
in
c
has
the
at-most-once
prop
ert
y
.
An
o
ccurrence
is
atomic
if
it
is
inside
a
sub
command
of
form
a
w
ait
b
then
a.
Andrews's
metho
dology
is
based
on
the
idea
that
if
a
command
has
the
at-
most-once
prop
ert
y
then
it
su√Üces
to
assume
coarse-grained
execution
when
reasoning
ab
out
its
b
eha
vior,
since
there
will
b
e
no
discernible
dierence
with
ne-grained
execution.
Ho
w
ev
er,
the
ab
o
v
e
c
haracterization
of
an
at-most-
once
prop
ert
y
is
only
informal
and
sligh
tly
imprecise,
in
particular
in
relying
on
implicit
analysis
of
the
con
text
in
whic
h
co
de
is
to
b
e
executed.
W
e
will
couc
h
our
transfer
principle
in
sligh
tly
more
sp
ecic
but
general
terms
based
on
a
precise
reform
ulation
of
this
prop
ert
y
,
referring
to
the
crw
denition
from
ab
o
v
e.
Theorem
6.6
If
free
(c
1
)
[
free
(c
2
)

bound
(C
),
and
(R
;
W
)
=
crw
(C
),
and
either
jreads
(c
i
)
\
W
j
=
0
or
jreads
(c
i
)
\
W
j
=
1
&
jwrites
(c
i
)
\
(R
[
W
)j
=
0;
i
=
1;
2
then
c
1

c
o
arse
c
2
)
C
[c
1
]

ne
C
[c
2
]:
2
Th
us
our
formal
v
ersion
of
the
at-most-once
prop
ert
y
can
b
e
read
as
requir-
ing
that
the
command
reads
at
most
one
o
ccurrence
of
an
iden
tier
written
concurren
tly
b
y
the
con
text,
and
if
it
reads
one
then
none
of
its
writes
aect
an
y
iden
tier
whic
h
is
either
read
or
written
concurren
tly
b
y
the
con
text.
Our
insistence
in
the
ab
o
v
e
theorem
that
the
co
de
b
eing
analyzed
(c
1
and
c
2
)
only
aects
lo
cal
v
ariables,
i.e.
iden
tiers
whic
h
b
ecome
b
ound
when
the
co
de
is
inserted
in
to
the
con
text,
is
reected
in
Andrews's
setting
b
y
an
assumption
that
all
pro
cesses
ha
v
e
lo
cal
registers.
Again
w
e
sho
w
that
the
built-in
pro
visos
imp
osing
lo
calit
y
and
the
at-
most-once
prop
ert
y
cannot
b
e
dropp
ed.
Firstly
,
ev
ery
program
has
the
at-most-once
prop
ert
y
,
trivially
,
for
the
con
text
[ ].
But
the
assumption
that
c
1

c
o
arse
c
2
is
insu√Ücien
t
to
ensure
that
c
1

ne
c
2
.
Th
us
the
result
b
ecomes
in
v
alid
if
w
e
omit
the
lo
calization
around
the
con
text.
38

Br
ookes
T
o
illustrate
the
need
for
the
at-most-once
assumption,
let
the
programs
c
1
and
c
2
b
e
y
:=
x
+
x
and
y
:
=2

x.
These
programs
are
clearly
coarsely
equiv
alen
t.
Let
C
b
e
the
con
text
lo
cal
x
=
0;
y
=
0
in
(([ ]kx:
=1);
z
:
=y
):
Of
course
c
1
refers
t
wice
to
x,
whic
h
is
assigned
to
b
y
the
con
text
concurren
tly;
c
1
do
es
not
satisfy
the
at-most-once
prop
ert
y
for
C
.
Moreo
v
er
w
e
can
see
that
lo
cal
x
=
0;
y
=
0
in
((y
:
=x
+
xkx:
=
1);
z
:
=y
)

ne
z
:=0
or
z
:
=1
or
z
:
=
2
lo
cal
x
=
0;
y
=
0
in
((y
:
=2

xkx:
=
1);
z
:
=y
)

ne
z
:=0
or
z
:
=2
so
that
C
[c
1
]
6
ne
C
[c
2
].
Also
note
that
the
other
w
a
y
for
the
assumption
to
fail
is
when
c
1
(sa
y)
b
oth
reads
and
writes
to
a
concurren
tly
accessed
iden
tier.
F
or
instance,
let
c
1
b
e
x:
=x
and
c
2
b
e
a
w
ait
true
then
x:
=
x.
Let
C
b
e
the
con
text
lo
cal
x
=
0
in
(([ ]kx:
=1);
y
:
=
x)
Then
w
e
ha
v
e
jreads
(c
i
)
\
W
j
=
1
and
jwrites
(c
i
)
\
(R
[
W
)j
>
0.
And
c
1

c
o
arse
c
2
.
But
C
[c
1
]

ne
y
:=0
or
y
:=
1,
and
C
[c
2
]

ne
y
:
=1.
It
is
also
w
orth
remarking
that
the
ab
o
v
e
principle
cannot
b
e
strengthened
b
y
replacing
the
assumption
that
c
1
and
c
2
are
c
o
arsely
e
quivalent
with
the
w
eak
er
assumption
that
c
1
and
c
2
are
se
quential
ly
e
quivalent.
F
or
example,
let
c
1
and
c
2
b
e
y
:=1;
while
true
do
skip
and
y
:
=2;
while
true
do
skip
:
Let
C
b
e
the
con
text
lo
cal
y
=
0
in
([ ]kz
:
=y
).
Then
w
e
ha
v
e
reads
(c
i
)
=
;,
writes
(c
i
)
=
fy
g,
crw
(C
)
=
(fy
g;
fz
g),
bound
(C
)
=
fy
g.
Moreo
v
er,
c
1

M
c
2
holds,
since
M(c
i
)
=
f(s;
?)
j
s
2
Sg,
i
=
1;
2.
Ho
w
ev
er,
C
[c
1
]

ne
(z
:
=0
or
z
:
=1)
and
C
[c
2
]

ne
(z
:
=0
or
z
:=2);
so
that
C
[c
1
]
6
ne
C
[c
2
].
The
coarse-
to
ne-grained
transfer
theorem
giv
en
ab
o
v
e
generalizes
some
more
ad
ho
c
argumen
ts
based
on
o
ccurrence-coun
ting
in
Andrews's
b
o
ok,
re-
sulting
in
a
single
general
principle
in
whic
h
the
crucial
underlying
pro
visos
are
made
explicit.
T
o
mak
e
the
connection
with
Andrews's
examples
more
precise,
note
the
follo
wing
sp
ecial
cases
of
our
theorem,
whic
h
app
ear
in
paraphrase
in
Andrews:

If
b
refers
at
most
once
to
iden
tiers
written
concurren
tly
(b
y
the
con
text),
then
a
w
ait
b
then
skip
can
b
e
replaced
b
y
while
:b
do
skip
(throughout
39

Br
ookes
the
program).
This
rule
ma
y
b
e
used
to
justify
replacemen
t
of
a
conditional
atomic
action
with
a
(non-atomic)
busy-w
ait
lo
op.

If
x:=e
has
the
at-most-once
prop
ert
y
(for
the
con
text)
then
the
assignmen
t
x:
=e
can
b
e
replaced
b
y
its
atomic
v
ersion
a
w
ait
true
then
x:=e
(through-
out
the
program).
This
rule
ma
y
b
e
used
to
simplify
reasoning
ab
out
the
p
oten
tial
for
in
teraction
b
et
w
een
pro
cesses.
7
Conclusions
and
future
w
ork
W
e
ha
v
e
iden
tied
conditions
under
whic
h
it
is
safe
to
emplo
y
\sequen
tial"
reasoning
ab
out
co
de
fragmen
ts
while
trying
to
establish
\parallel"
correct-
ness
prop
erties
suc
h
as
safet
y
and
liv
eness.
W
e
ha
v
e
also
iden
tied
conditions
go
v
erning
the
safe
use
of
coarse-grained
reasoning
in
pro
ving
ne-grained
prop-
erties.
These
transfer
principles
can
b
e
seen
as
supplying
a
seman
tic
foundation
for
some
of
the
ideas
b
ehind
Andrews's
proto
col
analysis,
and
a
p
oten
tial
basis
for
further
generalization
and
the
systematic
dev
elopmen
t
of
tec
hniques
to
p
ermit
easier
design
and
analysis
of
parallel
programs.
W
e
plan
to
extend
our
ideas
and
results
to
co
v
er
a
wider
v
ariet
y
of
examples,
including
some
of
the
proto
cols
discussed
b
y
Dingel.
It
w
ould
also
b
e
in
teresting
to
explore
the
relationship
b
et
w
een
our
approac
h
and
Dingels'
notion
of
con
text-sensitiv
e
appro
ximation.
These
results
p
ermit
the
use
of
a
simpler,
more
abstract
seman
tics,
together
with
a
notion
of
seman
tic
equiv
alence
whic
h
is
easier
to
establish,
to
facilitate
reasoning
ab
out
the
b
eha
vior
of
a
parallel
system.
It
w
ould
b
e
in
teresting
to
in
v
estigate
the
p
ossible
utilit
y
of
transfer
principles
in
impro
ving
the
e√Üciency
of
mo
del-c
hec
king
for
nite-state
concurren
t
systems.
8
Ac
kno
wledgemen
ts
The
anon
ymous
referees
made
a
n
um
b
er
of
helpful
suggestions.
The
author
w
ould
also
lik
e
to
thank
his
former
Ph.D.
studen
t,
J

urgen
Dingel,
whose
thesis
researc
h
pro
vides
a
stim
ulus
for
the
w
ork
rep
orted
here.
References
[1]
Andrews,
G.,
Concurr
ent
Pr
o
gr
amming:
Principles
and
Pr
actic
e.
Benjamin/
Cummings
(1991).
[2]
Bro
ok
es,
S.,
F
ul
l
abstr
action
for
a
shar
e
d-variable
p
ar
al
lel
language.
Information
and
Computation
127(2),
145{163
(June
1996).
[3]
Bro
ok
es,
S.,
The
essenc
e
of
Par
al
lel
Algol.
Pro
c.
11th
IEEE
Symp
osium
on
Logic
in
Computer
Science,
IEEE
Computer
So
ciet
y
Press,
164{173
(1996).
T
o
app
ear
in
Information
and
Computation.
40

Br
ookes
[4]
Bro
ok
es,
S.,
Ide
alize
d
CSP:
Combining
Pr
o
c
e
dur
es
with
Communic
ating
Pr
o
c
esses.
Mathematical
F
oundations
of
Programming
Seman
tics,
13
th
Conference,
Marc
h
1997.
Electronic
Notes
in
Theoretical
Computer
Science
6,
Elsevier
Science
(1997).
URL:
http://www.elsevier.nl/
locate/
entcs/volume6.html.
[5]
Bro
ok
es,
S.,
Communic
ating
Par
al
lel
Pr
o
c
esses.
In:
Mil
lenium
Persp
e
ctives
in
Computer
Scienc
e,
Pro
ceedings
of
the
Oxford-Microsoft
Symp
osium
in
honour
of
Professor
Sir
An
ton
y
Hoare,
edited
b
y
Jim
Da
vies,
Bill
Rosco
e,
and
Jim
W
o
o
dco
c
k,
P
algra
v
e
Publishers
(2000).
[6]
de
Bakk
er,
J.,
Axiom
systems
for
simple
assignment
statements.
In
Symp
osium
on
Semantics
of
A
lgorithmic
L
anguages,
edited
b
y
E.
Engeler.
Springer-V
erlag
LNCS
v
ol.
181,
1{22
(1971).
[7]
Dingel,
J.,
Systematic
p
ar
al
lel
pr
o
gr
amming.
Ph.
D.
thesis,
Carnegie
Mellon
Univ
ersit
y
,
Departmen
t
of
Computer
Science
(Ma
y
2000).
[8]
Jones,
C.
B.,
T
entative
steps
towar
ds
a
development
metho
d
for
interfering
pr
o
gr
ams,
A
CM
T
ransactions
on
Programming
Languages
and
Systems,
5(4):576{619
(1983).
[9]
P
ark,
D.,
On
the
semantics
of
fair
p
ar
al
lelism.
In
A
bstr
act
Softwar
e
Sp
e
cic
ations,
edited
b
y
D.
Bjrner,
Springer-V
erlag
LNCS
v
ol.
86,
504{526
(1979).
[10]
P
ark,
D.,
Concurr
ency
and
automata
on
innite
se
quenc
es.
Springer
LNCS
v
ol.
104
(1981).
41

42

MFPS
17
Preliminary
Version
Time
Stamps
for
Fixed-P
oin
t
Appro
ximation
Daniel
Damian
BRICS
1
Dep
artment
of
Computer
Scienc
e,
University
of
A
arhus
Building
540,
Ny
Munke
gade,
DK-8000
A
arhus
C,
Denmark
E-mail:
damian@brics.dk
Abstract
Time
stamps
w
ere
in
tro
duced
in
Shiv
ers's
PhD
thesis
for
appro
ximating
the
re-
sult
of
a
con
trol-o
w
analysis.
W
e
sho
w
them
to
b
e
suitable
for
computing
program
analyses
where
the
space
of
results
(e.g.,
con
trol-o
w
graphs)
is
large.
W
e
formalize
time-stamping
as
a
top-do
wn,
xed-p
oin
t
appro
ximation
algorithm
whic
h
main-
tains
a
single
cop
y
of
in
termediate
results.
W
e
then
pro
v
e
the
correctness
of
this
algorithm.
1
In
tro
duction
1.1
A
bstr
act
interpr
etation
and
xe
d-p
oint
c
omputation
Abstract
in
terpretation
[6,10
]
is
a
framew
ork
for
systematic
deriv
ation
of
pro-
gram
analyses.
In
this
framew
ork,
the
standard
seman
tics
of
a
program
is
appro
ximated
b
y
an
abstract
seman
tics.
The
abstract
seman
tics
sim
ulates
the
standard
seman
tics
and
is
used
to
extract
prop
erties
of
the
actual
run-
time
b
eha
vior
of
the
program.
Abstract
in
terpretation
often
yields
program
analyses
sp
ecied
b
y
a
set
of
recursiv
e
equations.
F
ormally
,
the
analysis
is
dened
as
the
least
xed
p
oin
t
of
a
functional
o
v
er
a
sp
ecic
lattice.
Analyzing
a
program
then
amoun
ts
to
computing
suc
h
a
least
xed
p
oin
t.
The
design
and
analysis
of
algorithms
for
computing
least
xed
p
oin
ts
has
th
us
b
ecome
a
classic
researc
h
topic.
This
article
presen
ts
a
top-do
wn
algorithm
that
computes
an
appro
ximate
solution
for
a
sp
ecic
class
of
program
analyses.
This
class
includes
analyses
of
programs
with
dynamic
con
trol-o
w,
namely
programs
whose
con
trol-o
w
is
determined
b
y
the
run-time
v
alues
of
program
v
ariables.
Suc
h
programs
are
common,
for
instance,
in
higher-order
and
ob
ject-orien
ted
languages.
1
Basic
Researc
h
in
Computer
Science
(www.brics.dk),
funded
b
y
the
Danish
National
Researc
h
F
oundation.
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

D
amian
The
common
problem
of
analyzing
programs
with
dynamic
con
trol
o
w
is
to
compute
a
static
appro
ximation
of
the
dynamic
con
trol
o
w
graph.
The
o
w
information
is
usually
represen
ted
as
a
table
mapping
eac
h
program
p
oin
t
to
the
set
of
p
oin
ts
that
form
p
ossible
outgoing
edges
from
that
p
oin
t.
The
analysis
ma
y
compute
o
w
information
either
as
a
separate
phase,
or
as
an
in-
tegral
comp
onen
t
of
the
abstract
in
terpretation.
In
an
y
case,
o
w
information
is
itself
computed
as
a
least
xed
p
oin
t
of
a
functional.
An
algorithm
for
computing
a
solution
is
met
with
a
di√Ücult
practical
constrain
t:
due
to
the
p
oten
tial
size
of
the
con
trol-o
w
graph
em
b
edded
in
the
result
of
the
analysis,
one
cannot
aord
to
main
tain
m
ultiple
in
termedi-
ate
results.
The
time-stamps
based
algorithm
considered
here
only
needs
to
main
tain
a
single
in
termediate
analysis
result
throughout
the
computation.
1.2
The
time-stamping
te
chnique
The
time-stamping
tec
hnique
has
b
een
previously
in
tro
duced
in
Shiv
ers's
PhD
thesis
[19]
on
con
trol-o
w
analysis
for
Sc
heme,
based
on
ideas
from
Hudak
and
Y
oung's
\memoized
p
ending
analysis"
[20].
Using
time
stamps
Shiv
ers
implemen
ts
a
top-do
wn
algorithm
whic
h
computes
an
appro
ximation
of
the
original
analysis
but
do
es
not
main
tain
m
ultiple
in
termediate
results.
The
algorithm
ensures
termination
b
y
relying
on
the
required
monotonicit
y
of
the
abstract
seman
tics
and
b
y
using
time
stamps
on
abstract
en
vironmen
ts.
It
obtains
an
appro
ximation
b
y
using
increasingly
appro
ximate
en
vironmen
ts
on
the
sequen
tial
analysis
of
program
paths.
T
o
our
kno
wledge,
Shiv
ers's
thesis
con
tains
the
only
description
of
the
time-stamping
tec
hnique.
The
thesis
pro
vides
a
formal
accoun
t
of
some
of
the
transformations
p
erformed
on
the
abstract
con
trol-o
w
seman
tics
in
order
to
obtain
an
e√Ücien
t
implemen
tation
(as,
for
instance,
the
\aggressiv
e
cuto
"
approac
h).
The
in
tro
duction
of
time
stamps,
ho
w
ev
er,
remains
only
informally
describ
ed.
In
particular,
his
accoun
t
of
the
time-stamps
algorithm
[19,
Chap-
ter
6]
relies
on
the
prop
ert
y
that
the
recursion
sets
computed
b
y
the
mo
died
algorithm
are
included
in
the
recursion
sets
computed
b
y
the
basic
algorithm.
Suc
h
prop
ert
y
relies
on
the
monotonicit
y
of
the
original
seman
tics,
and
the
relationship
with
the
algorithm
mo
died
to
use
a
single-threaded
en
vironmen
t
remains
unclear.
Our
w
ork:
W
e
formalize
the
time-stamps
based
appro
ximation
algorithm
as
a
generic
xed-p
oin
t
appro
ximation
algorithm,
and
w
e
pro
v
e
its
correctness.
1.3
Overview
The
rest
of
the
article
is
organized
as
follo
ws:
In
Section
2
w
e
describ
e
the
time-stamps
based
appro
ximation
algorithm.
In
Section
2.1
w
e
dene
the
class
of
recursiv
e
equations
on
whic
h
the
algorithm
is
applicable.
In
Section
2.2
w
e
44

D
amian
describ
e
the
in
tuition
b
ehind
the
time
stamps.
W
e
pro
ceed
in
Section
3
to
formalize
the
time-stamps
based
algorithm
(Section
3.1)
and
pro
v
e
its
correct-
ness
(Section
3.2).
In
Section
3.3
w
e
estimate
the
complexit
y
of
the
algorithm.
In
Section
4
w
e
sho
w
ho
w
to
extend
the
algorithm
to
a
wider
class
of
analyses.
In
Section
5
w
e
review
related
w
ork
and
in
Section
6
w
e
conclude.
2
The
time-stamps
based
appro
ximation
algorithm
2.1
A
class
of
r
e
cursive
e
quations
W
e
consider
a
class
of
recursiv
e
equations
whic
h
mo
del
abstract
in
terpretations
that
gather
information
ab
out
a
program
b
y
sim
ulating
its
execution.
W
e
can
abstract
the
program
as
a
set
of
no
des
in
a
graph.
W
e
consider
that
a
giv
en
program
p
induces
a
nite
set
of
program
p
oin
ts
L
ab
.
T
ransitions
from
a
program
p
oin
t
to
another
are
describ
ed
as
directed
edges
in
the
graph.
The
abstract
seman
tics
collects
information
as
an
elemen
t
b

of
a
complete
lattice
A
(w
e
assume
that
A
has
nite
heigh
t).
T
ypically
,
suc
h
analysis
information
is
in
the
form
of
a
cac
he
whic
h
collects
information
of
in
terest
on
program
p
oin
ts
and
v
ariables.
In
our
setting,
at
a
program
p
oin
t
`
2
L
ab
,
with
in
termediate
analysis
information
b
,
the
result
of
the
analysis
is
computed
from
some
lo
cal
analysis
information
and
from
the
union
of
results
obtained
b
y
follo
wing
all
p
ossible
outgoing
paths.
F
or
instance,
at
a
branc
hing
statemen
t
with
an
unkno
wn
b
o
olean
condition,
w
e
analyze
b
oth
branc
hes
and
merge
the
results.
In
higher-
order
languages,
at
a
function
call
(e
0
e
1
),
w
e
analyze
as
man
y
outgoing
paths
as
the
n
um
b
er
of
functions
the
expression
e
0
can
ev
aluate
to.
The
c
hoice
of
a
sp
ecic
outgoing
path
determines
a
sp
ecic
up
date
of
the
analysis
information.
F
or
instance,
b
y
c
ho
osing
one
of
the
functions
that
ma
y
b
e
called
at
an
application
p
oin
t,
one
up
dates
the
information
asso
ciated
to
the
formal
parameter
with
the
information
asso
ciated
to
the
actual
parameter.
W
e
consider
therefore
that
lo
cal
analysis
information
is
dened
as
a
mono-
tone
function
B
:
(L
ab

A)
!
A,
and
that
the
analysis
information
asso
ciated
with
an
edge
is
giv
en
b
y
a
monotone
function
V
:
(L
ab

L
ab

A)
!
A.
Suc
h
functions
V
corresp
ond,
for
instance,
to
Sagiv,
Reps
and
Horo
witz's
en
viron-
men
t
transformers
[17],
but
they
can
also
mo
del
monotone
framew
orks
[12
,13].
In
an
y
case,
w
e
are
mo
deling
a
form
of
collecting
analyses
[6,18
],
as
w
e
merge
the
execution
information
to
the
already
computed
information
when
follo
wing
an
edge.
T
o
mo
del
dynamic
con
trol
o
w,
w
e
assume
that,
at
a
sp
ecic
no
de
`
and
in
the
presence
of
already
computed
analysis
information
b
,
the
set
of
p
ossible
outgoing
edges
is
describ
ed
b
y
a
monotone
function
R
:
(L
ab

A)
!
P
(L
ab
):
edges
are
formed
from
the
curren
t
no
de
`
and
the
elemen
ts
of
R
(`;
b
).
A
generic
analysis
function
F
:
(L
ab

A)
!
A
ma
y
therefore
b
e
dened
b
y
the
45

D
amian
follo
wing
recursiv
e
equation:
F
(`;
b

)
=
B
(`;
b
)
t
G
`
0
2R(`;
b

)
F
(`
0
;
b

t
V
(`;
`
0
;
b
));
()
If
the
functions
B
,
R
and
V
are
monotone
on
b

(L
ab
is
essen
tially
a
at
domain),
it
can
b
e
easily
sho
wn
that
Equation
()
has
solutions.
Giv
en
the
starting
p
oin
t
of
the
program
`
0
and
some
initial
(p
ossibly
empt
y)
analysis
information
b

0
,
w
e
are
in
terested
in
computing
a
v
alue
F
(`
0
;
b

0
),
where
F
is
the
least
solution
of
Equation
().
It
is
usually
more
exp
ensiv
e
to
compute
the
en
tire
function
F
as
the
least
solution
of
Equation
().
Naturally
,
w
e
w
an
t
to
implemen
t
a
program
that
computes
the
v
alue
of
F
on
a
sp
ecic
pair
(`;
b

).
In
order
to
compute
the
v
alue
F
(`;
b

),
one
needs
to
con
trol
termination
(rep
eating
sequences
of
pairs
(`;
b
)
migh
t
app
ear)
and
one
also
needs
to
sa
v
e
in
termediate
copies
of
the
curren
t
analysis
information
b

when
the
curren
t
no
de
`
has
m
ultiple
outgoing
edges.
Memoization
ma
y
b
e
an
easy
solution
for
con
trolling
termination.
When
the
space
of
analysis
results
is
large,
ho
w
ev
er,
the
cost
of
main
taining
the
mem-
oization
table,
coupled
with
the
cost
of
sa
ving
in
termediate
results,
leads
to
a
prohibitiv
ely
exp
ensiv
e
implemen
tation.
W
e
can
use
Shiv
ers's
time-stamping
tec
hnique
[19]
to
solv
e
these
t
w
o
problems,
as
long
as
w
e
are
satised
with
an
appro
ximation
of
F
(`
0
;
b

0
).
2.2
The
intuition
b
ehind
time
stamps
W
e
presen
t
a
pseudo-co
de
form
ulation
of
the
algorithm
in
order
to
informally
describ
e
the
time-stamping
tec
hnique.
W
e
will
prop
erly
formalize
the
algo-
rithm
and
pro
v
e
its
correctness
in
Section
3.
W
e
assume
that
w
e
can
compute
the
functions
B
,
R
and
V
whic
h
dene
a
instance
of
the
analysis.
The
pseudo-co
de
of
the
time-stamps
based
appro
ximation
algorithm
is
giv
en
in
Figure
1.
The
time-stamps
based
algorithm
uses
a
time
coun
ter
t
(initialized
with
0)
and
a
table

whic
h
asso
ciates
to
eac
h
program
p
oin
t
`
a
time
stamp

[`],
initialized
with
0.
W
e
compute
the
result
of
the
analysis
in
to
a
global
v
ariable
b
,
whic
h
is
initialized
with
b

0
.
Otherwise
said,
w
e
lift
the
b

parameter
out
of
the
F
function.
The
time
coun
ter
t
and
the
time-stamps
table

(mo
deled
as
an
arra
y
of
in
tegers)
are
also
global
v
ariables.
The
function
U
up
dates
the
global
analysis
with
fresh
information:
if
new
results
are
computed,
the
time
coun
ter
is
incremen
ted
b
efore
they
are
added
in
the
global
analysis.
The
function
F
implemen
ts
the
time-stamps
based
appro
ximation.
T
o
compute
the
v
alue
of
F
(`),
w
e
rst
compute
the
lo
cal
information
B
(`
0
;
b
)
and
add
the
result
in
to
the
global
analysis.
W
e
then
compute
the
set
of
outgoing
no
des
R
(`
0
;
b
).
F
or
eac
h
outgoing
no
de
`
0
2
R
(`
0
;
b
),
se
quential
ly,
w
e
compute
the
execution
information
V
(`;
`
0
;
b
)
along
the
edge
(`;
`
0
),
w
e
add
its
result
to
b

and
w
e
then
call
F
(`
0
).
Because
all
the
calls
to
F
on
the
second
or
later
branc
hes
are
made
46

D
amian
global
b

:
A;
t
:
N;

:
N
a
rra
y
fun
U
(
b

1
)
=
if
b

1
6v
b

then
t
:=
t
+
1;
b

:=
b

t
b

1
fun
F
(`)
=
if

[`]
6=
t
then

[`]
:=
t;
U
(B
(`;
b
));
fo
reach
`
0
in
R
(`;
b
)
U
(V
(`;
`
0
;
b
));F
(`
0
)
Fig.
1.
Time-stamps
based
appro
ximation
algorithm
with
a
p
ossibly
larger
b

,
an
appro
ximation
ma
y
o
ccur.
Eac
h
time
b

is
increased
b
y
addition
of
new
information,
w
e
incremen
t
the
time
coun
ter.
Eac
h
time
w
e
call
F
on
a
program
p
oin
t
`,
w
e
record
the
curren
t
v
alue
of
the
time
coun
ter
in
the
time-stamps
table
at
`'s
slot,
i.e.,

[`]
:=
t.
W
e
use
the
time-stamps
table
to
con
trol
the
termination.
If
the
function
F
is
called
on
a
p
oin
t
`
suc
h
that

[`]
=
t,
then
there
has
already
b
een
a
call
to
F
on
`,
and
the
en
vironmen
t
has
not
b
een
up
dated
since.
Therefore,
no
fresh
information
is
going
to
b
e
added
to
the
en
vironmen
t
b
y
this
call,
and
w
e
can
simply
return
without
p
erforming
an
y
computation.
Suc
h
correctness
argumen
t
is
only
informal,
though.
In
his
thesis,
Shiv-
ers
[19]
mak
es
a
detailed
description
of
the
time-stamps
tec
hnique
in
the
con-
text
of
a
con
trol-o
w
analysis
for
Sc
heme.
He
pro
v
es
that
memoization
(the
so-called
\aggressiv
e
cuto
"
metho
d)
preserv
es
the
results
of
the
analysis.
The
in
tro
duction
of
time-stamps
and
the
appro
ximation
obtained
b
y
collecting
re-
sults
in
a
global
v
ariable
remain
only
informally
justied.
In
the
next
section
w
e
pro
vide
a
formal
description
of
the
time-stamps
based
appro
ximation
al-
gorithm
and
w
e
pro
v
e
its
correctness.
3
A
formalization
of
the
time-stamps
based
algorithm
3.1
State-p
assing
r
e
cursive
e
quations
W
e
formalize
the
algorithm
and
the
time-stamping
tec
hnique
as
a
new
set
of
recursiv
e
equations.
The
equations
describ
e
precisely
the
computational
steps
of
the
algorithm.
They
are
designed
suc
h
that
their
solution
can
b
e
immediately
related
with
the
seman
tics
of
an
implemen
tation
of
the
algorithm
from
Figure
1
in
a
standard
programming
language.
In
the
same
time,
they
dene
an
appro
ximate
solution
of
Equation
()
on
the
page
b
efore.
W
e
pro
v
e
that
the
solution
of
the
new
equations
is
indeed
an
appro
ximation
of
the
original
form.
The
equations
are
mo
deling
a
state-passing
computation.
The
global
state
of
the
computation
con
tains
the
analysis
information
b

,
the
time-stamps
table

and
the
time
coun
ter
t.
The
time-stamps
table
is
mo
deled
b
y
a
function
47

D
amian
F
0
(`;
(
b

;

;
t)
)
=
if

(`)
=
t
then
(
b
;

;
t)
else
let
f`
1
;
:
:
:
;
`
n
g
=
R
(`;
b
)
(
b

0
;

0
;
t
0
)
=
U
(B
(`;
b
);
(
b
;

[`
7!
t];
t))
(
b

1
;

1
;
t
1
)
=
F
0
(`
1
;
U
(V
(`;
`
1
;
b

0
);
(
b

0
;

0
;
t
0
)))
.
.
.
(
b

n
;

n
;
t
n
)
=
F
0
(`
n
;
U
(V
(`;
`
n
;
b

n 1
);
(
b

n 1
;

n 1
;
t
n 1
)))
in
(
b

n
;

n
;
t
n
)
U
(
b

1
;
(
b

;

;
t)
)
=
if
b

1
6v
b

then
(
b

t
b

1
;

;
t
+
1)
else
(
b

;

;
t)
Fig.
2.
Time-stamps
based
appro
ximation
equation

2
L
ab
!
N:
(
b
;

;
t)
2
States
=
(A

(L
ab
!
N)

N)
Unlik
e
in
the
standard
denotational
seman
tics,
w
e
consider
N
with
the
usual
ordering
on
natural
n
um
b
ers.
Therefore
States
is
an
innite
domain
con
taining
innite
ascending
c
hains.
T
o
limit
the
heigh
t
of
ascending
c
hains,
w
e
restrict
the
space
to
reect
more
precisely
the
set
of
p
ossible
states
in
the
computation:
States
=
f(
b
;

;
t)
2
(A

(L
ab
!
N)

N)jt

h(
b
)
^
8`
2
L
ab
:
(`)

tg
Here
the
function
h(
b

)
denes
\the
length
of
the
longest
c
hain
of
elemen
ts
of
A
b
elo
w
b
".
Informally
,
the
restriction
accoun
ts
for
the
fact
that
w
e
incremen
t
t
eac
h
time
w
e
add
information
in
to
b
.
Starting
from
b

=
?
and
t
=
0,
t
is
alw
a
ys
smaller
than
the
longest
ascending
path
from
b
ottom
to
b

in
A.
The
second
condition
accoun
ts
for
the
fact
that
the
time-stamps
table
records
time
stamps
smaller
than
or
equal
to
the
v
alue
of
the
time
coun
ter.
The
recursiv
e
equations
that
dene
the
time-stamps
appro
ximation
are
stated
in
Figure
2.
They
dene
a
function
F
0
:
(L
ab

States
)
!
States
that
mo
dels
a
state-passing
computation.
It
is
easy
to
sho
w
that
U
:
(A

States
)
!
States
is
w
ell-dened
(on
the
restricted
space
of
states).
The
existence
of
solutions
for
the
equations
from
Figure
2
can
then
b
e
easily
established,
also
due
to
the
monotonicit
y
of
B
,
V
and
R
.
Note
also
that
the
order
in
whic
h
the
elemen
ts
of
the
set
of
outgoing
no
des
R
(`;
b
)
are
pro
cessed
remains
unsp
ecied.
This
asp
ect
do
es
not
aect
our
further
dev
elopmen
t,
while
lea
ving
ro
om
for
impro
ving
the
ev
aluation
strategy
.
The
main
reason
for
the
restriction
on
the
states
and
for
the
non-standard
48

D
amian
seman
tics
is
that
w
e
restrict
the
denition
of
the
function
to
the
strictly-
terminating
instances.
It
is
easy
to
sho
w
that
F
0
terminates
on
an
y
initial
program
p
oin
t
and
initial
state.
In
fact,
suc
h
initial
conguration
determines
a
trace
of
states
whic
h
w
e
use
to
sho
w
that
the
function
F
0
computes
a
safe
appro
ximation
of
the
analysis.
3.2
Corr
e
ctness
The
correctness
of
the
time-stamps
based
algorithm,
i.e.,
the
fact
that
it
com-
putes
an
appro
ximation
of
the
function
dened
b
y
Equation
()
on
page
46,
is
established
b
y
the
follo
wing
theorem.
Theorem
3.1
F
or
any
`
2
L
ab
and
b

2
A:
F
(`;
b

)
v

1
(F
0
(`;
(
b

;
`:0;
1)
))
The
theorem
is
pro
v
en
in
t
w
o
steps.
First,
w
e
sho
w
that
using
time
stamps
to
con
trol
recursion
do
es
not
c
hange
the
result
of
the
analysis.
In
this
sense,
w
e
consider
an
in
termediate
equation
dening
a
function
F
00
:
(L
ab

States
)
!
A.
F
00
(`;
(
b

;

;
t)
)
=
if

(`)
=
t
then
?
else
B
(`;
b
)
t
G
`
0
2R(`;
b

)
F
00
(`
0
;
U
(V
(`;
`
0
;
b
);
(
b
;

[`
7!
t];
t)))
W
e
sho
w
that
the
function
F
00
computes
the
same
analysis
as
the
function
dened
b
y
Equation
().
Lemma
3.2
L
et
`
2
L
ab
b
e
a
pr
o
gr
am
p
oint
and
(
b
;

;
t)
2
States
.
L
et
S
=
f`
0
2
L
ab
j
(`
0
)
=
tg.
Then
we
have:
F
00
(`;
(
b

;

;
t)
)
t
G
`
0
2S
F
(`
0
;
b
)
=
F
(`;
b

)
t
G
`
0
2S
F
(`
0
;
b
)
Lemma
3.2
is
pro
v
ed
using
a
w
ell-founded
induction
on
states:
essen
tially
,
F
0
0
(`;
(
b

;

;
t)
)
mak
es
recursiv
e
calls
on
F
00
on
states
strictly
ab
o
v
e
(
b
;

;
t).
As
an
instance
of
the
Lemma
3.2
w
e
obtain:
Corollary
3.3
8`
2
L
ab
;
b

2
A:F
(`;
b
)
=
F
00
(`;
(
b
;
`:0;
1)
)
W
e
sho
w
that
the
time-stamps
algorithm
computes
an
appro
ximation
of
the
function
F
0
0
.
Lemma
3.4
8
(
b
;

;
t)
2
States
;
`
2
L
ab
:F
00
(`;
(
b
;

;
t))
v

1
(F
0
(`;
(
b
;

;
t)))
The
pro
of
of
Lemma
3.4
relates
the
recursion
tree
from
the
denition
of
function
F
00
and
the
trace
of
states
in
the
computation
of
F
0
.
In
essence,
the
49

D
amian
v
alue
of
F
00
(`;
(
b
;

;
t))
is
comp
osed
from
the
union
of
a
tree
of
v
alues
of
the
from
B
(`
i
;
b

i
).
W
e
sho
w
b
y
induction
on
the
depth
of
the
tree
that
eac
h
of
these
v
alues
is
accum
ulated
in
the
nal
result
at
some
p
oin
t
on
the
trace
of
states
in
the
computation
of
F
0
.
Com
bining
the
t
w
o
lemmas
w
e
obtain
the
statemen
t
of
Theorem
3.1.
Ev
en
if
w
e
ha
v
e
used
non-standard
ordering
and
domains
when
dening
the
solutions
of
the
equations
in
Figure
2,
sho
wing
that
the
function
F
0
agrees
on
the
starting
conguration
with
a
standard
seman
tic
denition
of
the
algorithm
in
Figure
1
is
trivial
and
is
not
part
of
the
curren
t
presen
tation.
3.3
Complexity
estimates
Let
us
assume
that
computing
the
function
U
tak
es
m
time
units,
and
that
B
,
R
and
V
can
b
e
computed
in
constan
t
time
(one
time
unit).
The
time-
coun
ter
can
b
e
incremen
ted
at
most
h(A)
times,
where
the
function
h
denes
the
heigh
t
(giv
en
b
y
the
longest
ascending
c
hain)
of
the
lattice
A.
In
the
w
orst
case,
b
et
w
een
t
w
o
incremen
ts,
eac
h
edge
in
the
graph
ma
y
b
e
explored,
and
for
eac
h
edge
w
e
migh
t
sp
end
m
time
units
in
computing
the
U
function.
Th
us,
computing
F
0
(`;
(
b

;
`:0;
1)
)
has
a
w
orst-case
complexit
y
of
O
(jL
ab
j
2

m

h(A)).
Space-wise,
it
is
immediate
to
see
that
at
most
t
w
o
elemen
ts
of
A
are
in
memory
at
an
y
giv
en
time:
the
global
v
alue
b

and
one
temp
orary
v
alue
created
at
eac
h
call
of
B
or
V
.
The
temp
orary
v
alue
is
not
of
a
concern
though:
in
most
usual
cases,
the
size
of
the
results
of
B
or
V
is
one
order
of
magnitude
smaller
than
the
size
of
b
.
The
w
orst-case
space
complexit
y
is
also
driv
en
b
y
the
exploration
of
edges.
It
is
immediate
to
see
that
eac
h
edge
migh
t
put
aside
b
et
w
een
t
w
o
up
dates
of
the
global
en
vironmen
t.
Denoting
with
S
(A)
the
size
of
an
elemen
t
in
A,
the
w
orst-case
space
complexit
y
migh
t
b
e
O
(S
(A)
+
jL
ab
j
2

h(A)).
It
seems
apparen
t
ho
w
ev
er
that
man
y
of
the
edges
put
aside
are
redundan
t.
W
e
are
curren
tly
exploring
p
ossibilities
of
remo
ving
some
of
these
redundancies.
4
An
extension
The
time-stamps
metho
d
has
originally
b
een
presen
ted
in
the
setting
of
o
w
analysis
of
Sc
heme
programs
in
con
tin
uation-passing
st
yle
(CPS)
[19].
Indeed,
the
form
ulation
of
the
equations
facilitate
the
analysis
of
a
computation
that
\nev
er
returns".
In
their
pap
er
on
CPS
v
ersus
direct
st
yle
in
program
anal-
ysis
[16],
Sabry
and
F
elleisen
also
use
a
memoization
tec
hnique
to
compute
the
result
of
their
constan
t
propagation
for
a
higher-order
language
in
direct
st
yle.
W
e
can
apply
the
time-stamps
based
tec
hnique
to
Sabry
and
F
elleisen's
analysis
in
order
to
compute
a
more
e√Ücien
tly
an
appro
ximate
solution.
In
order
to
do
so,
w
e
extend
the
applicabilit
y
of
time-stamps
based
algorithm
to
functions
whic
h,
after
follo
wing
a
set
of
edges,
return
to
the
curren
t
p
oin
t
and
50

D
amian
restart
an
analysis
o
v
er
a
new
er
set
of
edges.
W
e
consider
equations
of
the
follo
wing
form:
F
(`;
b
)
=
let
b

1
=
B
(`;
b
)
t
F
`
0
2R(`;
b

)
F
(`
0
;
b

t
V
(`;
`
0
;
b
))
in
B
0
(`;
b

1
)
t
F
`
0
2R
0
(`;
b

1
)
F
(`
0
;
b

1
t
V
0
(`;
`
0
;
b

1
))
Indeed,
in
order
to
mo
del
the
analysis
of
a
term
lik
e
let
x
=
V
1
V
2
in
M
,
Sabry
and
F
elleisen's
analysis
explores
all
p
ossible
functions
that
can
b
e
called
in
the
header
of
the
let,
joins
the
results
and,
afterw
ards,
analyzes
the
term
M
.
The
algorithm
is
straigh
tforw
ardly
extended
to
accoun
t
for
the
second
call
with
another
iteration
o
v
er
R
0
(`;
b

1
).
The
pro
of
of
correctness
extends
as
w
ell.
It
is
remark
able
that
despite
the
more
complicated
form
ulation
of
the
equations,
the
complexit
y
of
the
algorithm
remains
the
same,
due
to
the
b
ounds
imp
osed
b
y
the
time-stamps.
The
b
enet
of
applying
the
time-stamps
based
algorithm
to
Sabry
and
F
elleisen's
analysis
is
that
it
yields
a
more
e√Ücien
t
algorithm
than
their
pro-
p
osed
memoization-based
implemen
tation
(for
the
reasons
outlined
in
Sec-
tion
2.1).
The
appro
ximation
obtained
is
still
precise
enough.
In
particular,
the
time-stamps
based
analysis
is
able
to
distinguish
returns.
Consider
for
instance
the
follo
wing
example
(also
due
to
Sabry
and
F
elleisen):
let
f
=
x:x
x
1
=
f
1
x
2
=
f
2
in
x
1
The
time-stamps
based
analysis
computes
a
solution
in
whic
h
x
1
(and,
there-
fore,
the
result
of
the
en
tire
expression)
is
b
ound
to
1,
and
x
2
is
b
ound
to
>.
In
con
trast,
a
constrain
t-based
data-o
w
analysis
[13]
is
only
able
to
compute
a
solution
in
whic
h
b
oth
x
1
and
x
2
are
b
ound
to
>.
F
ormally
,
it
is
relativ
ely
easy
to
sho
w
that
the
time-stamps
based
con-
stan
t
propagation
is
alw
a
ys
computing
a
result
at
least
as
go
o
d
as
a
standard
constrain
t-based
data-o
w
analysis.
The
details
are
omitted
from
this
article.
Note
that
the
impro
v
emen
t
in
the
qualit
y
o
v
er
the
constrain
t-based
analysis
comes
at
a
price
in
the
w
orst-case
time
and
space
complexit
y
.
5
Related
w
ork
A
n
um
b
er
of
authors
describ
e
algorithms
for
computing
least
xed
p
oin
ts
as
solutions
to
program
analyses
using
c
haotic
iteration,
whic
h
are
also
adapted
to
compute
appro
ximation
b
y
using
widenings
or
narro
wings
[6
].
O'Keefe's
b
ottom-up
algorithm
[14]
has
inspired
a
signican
t
n
um
b
er
of
articles,
where
the
con
v
ergence
sp
eed
is
impro
v
ed
using
rened
strategies
on
c
ho
osing
the
next
iteration,
or
exploiting
lo
calit
y
prop
erties
of
the
sp
ecications
[1,11
,15].
51

D
amian
Suc
h
algorithms
ha
v
e
also
b
een
applied
to
languages
with
dynamic
con-
trol
o
w.
Chen,
Harrison
and
Yi
[4]
dev
elop
ed
adv
anced
tec
hniques
suc
h
as
\w
aiting
for
all
successors",
\leading
edge
rst",
\susp
end
ev
aluation",
whic
h
impro
v
e
the
b
eha
vior
of
the
b
ottom-up
algorithm
when
applied
to
suc
h
lan-
guages.
In
a
subsequen
t
w
ork
[3],
the
authors
use
reac
habilit
y
information
to
implemen
t
a
tec
hnique
called
\con
text
pro
jection"
whic
h
reduces
the
amoun
t
of
abstract
information
asso
ciated
to
eac
h
program
p
oin
t.
In
con
trast,
time
stamps
appro
ximate
the
solution,
b
y
main
taining
only
one
global
con
text
com-
mon
to
all
program
p
oin
ts.
Other
algorithms
that
address
languages
with
dynamic
o
w
ha
v
e
b
een
de-
v
elop
ed
in
the
con
text
of
strictness
analysis.
Clac
k
and
P
eyton-Jones
[5]
ha
v
e
in
tro
duced
the
fron
tier-based
algorithm.
The
algorithm
reduces
space
usage
b
y
represen
ting
the
solution
only
with
a
subset
of
relev
an
t
v
alues.
The
tec
h-
nique
has
b
een
dev
elop
ed
for
binary
lattices.
Hun
t's
PhD
thesis
[9]
con
tains
a
generalization
to
distributiv
e
lattices.
The
top-do
wn
vs.
b
ottom-up
asp
ects
of
xed-p
oin
t
algorithms
for
abstract
in
terpretation
of
logic
programs
ha
v
e
b
een
in
v
estigated
b
y
Le
Charlier
and
V
an
Hen
tenryc
k.
The
t
w
o
authors
ha
v
e
dev
elop
ed
a
generic
top-do
wn
algorithm
xed-p
oin
t
algorithm
[2],
and
ha
v
e
compared
it
with
the
alternativ
e
b
ottom-
up
strategy
.
The
ev
aluation
strategy
of
their
algorithm
is
similar
to
the
time-
stamps
based
one
in
this
article.
In
con
trast,
ho
w
ev
er,
since
their
algorithm
precisely
computes
the
least
xed
p
oin
t,
it
also
main
tains
m
ultiple
v
alues
from
the
lattice
of
results.
F
ec
h
t
and
Seidl
[7]
design
the
time-stamps
solv
er
\WR
T"
whic
h
com
bines
the
b
enets
of
b
oth
the
top-do
wn
and
b
ottom-up
approac
hes.
The
algorithm
also
uses
time
stamps,
in
a
dieren
t
manner
though:
the
time
stamps
are
used
to
in
terpret
the
algorithm's
w
orklist
as
a
priorit
y
queue.
Our
tec
hnique
uses
time
stamps
simply
to
con
trol
the
termination
of
the
computation.
In
a
sequel
pap
er
[8],
the
authors
deriv
e
a
xed-p
oin
t
algorithm
for
distributiv
e
constrain
t
systems
and
use
it,
for
instance,
to
compute
a
o
w
graph
expressed
as
a
set
of
constrain
ts.
6
Conclusion
W
e
ha
v
e
presen
ted
a
p
olynomial-time
algorithm
for
appro
ximating
the
least
xed
p
oin
t
of
a
certain
class
of
recursiv
e
equations.
The
algorithm
uses
time
stamps
to
con
trol
recursion
and
a
v
oids
duplication
of
analysis
information
o
v
er
program
branc
hes
b
y
reusing
in
termediate
results.
The
time-stamping
tec
hnique
has
originally
b
een
in
tro
duced
b
y
Shiv
ers
in
his
PhD
thesis
[19].
T
o
the
b
est
of
our
kno
wledge,
the
idea
has
not
b
een
pursued.
W
e
ha
v
e
presen
ted
a
formalization
of
the
tec
hnique
and
w
e
ha
v
e
pro
v
en
its
correctness.
Sev
eral
issues
regarding
the
time-stamps
based
algorithm
migh
t
b
e
w
orth
further
study
.
F
or
instance,
it
is
noticeable
that
the
order
in
whic
h
the
outgo-
ing
edges
are
pro
cessed
at
a
certain
no
de
migh
t
aect
the
result
of
the
analysis.
52

D
amian
Designing
an
impro
v
ed
strategy
for
selection
of
no
des
is
w
orth
in
v
estigating.
Also,
as
w
e
observ
ed
in
Section
3.3,
an
edge
migh
t
b
e
pro
cessed
sev
eral
times
indep
enden
tly
,
eac
h
time
with
a
larger
analysis
information.
This
suggests
that
some
of
the
pro
cessing
migh
t
b
e
redundan
t.
W
e
are
curren
tly
in
v
estigat-
ing
suc
h
a
p
ossible
impro
v
emen
t
of
the
algorithm,
and
its
correctness
pro
of.
7
Ac
kno
wledgmen
ts
I
am
grateful
to
Olivier
Dan
vy
,
Da
vid
T
oman
and
Zhe
Y
ang
for
commen
ts
and
discussion
on
this
article.
Thanks
are
also
due
to
the
anon
ymous
referees
for
their
commen
ts.
References
[1]
Bourdoncle,
F.,
E√Ücient
chaotic
iter
ation
str
ate
gies
with
widenings,
in:
Pr
o
c
e
e
dings
of
the
International
Confer
enc
e
on
F
ormal
Metho
ds
in
Pr
o
gr
amming
and
their
Applic
ations,
Lecture
Notes
in
Computer
Science
735
(1993),
pp.
128{141.
[2]
Charlier,
B.
L.
and
P
.
V.
Hen
tenryc
k,
A
universal
top-down
xp
oint
algorithm,
T
ec
hnical
Rep
ort
CS{92{25,
Bro
wn
Univ
ersit
y
,
Pro
vidence,
Rho
de
Island
(1992).
[3]
Chen,
L.-L.
and
W.
L.
Harrison,
A
n
e√Ücient
appr
o
ach
to
c
omputing
xp
oints
for
c
omplex
pr
o
gr
am
analysis,
in:
Pr
o
c
e
e
dings
of
the
8th
A
CM
International
Confer
enc
e
on
Sup
er
c
omputing
(1994),
pp.
98{106.
[4]
Chen,
L.-L.,
W.
L.
Harrison
and
K.
Yi,
E√Ücient
c
omputation
of
xp
oints
that
arise
in
c
omplex
pr
o
gr
am
analysis,
Journal
of
Programming
Languages
3
(1995),
pp.
31{68.
[5]
Clac
k,
C.
and
S.
L.
P
eyton
Jones,
Strictness
analysis|a
pr
actic
al
appr
o
ach,
in:
J.-P
.
Jouannaud,
editor,
Confer
enc
e
on
F
unctional
Pr
o
gr
amming
L
anguages
and
Computer
A
r
chite
ctur
e,
Lecture
Notes
in
Computer
Science
201
(1985),
pp.
35{49.
[6]
Cousot,
P
.
and
R.
Cousot,
A
bstr
act
interpr
etation:
a
unie
d
lattic
e
mo
del
for
static
analysis
of
pr
o
gr
ams
by
c
onstruction
or
appr
oximation
of
xp
oints,
in:
R.
Sethi,
editor,
Pr
o
c
e
e
dings
of
the
F
ourth
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
(1977),
pp.
238{252.
[7]
F
ec
h
t,
C.
and
H.
Seidl,
A
n
even
faster
solver
for
gener
al
systems
of
e
quations,
in:
R.
Cousot
and
D.
A.
Sc
hmidt,
editors,
Pr
o
c
e
e
dings
of
3r
d
Static
A
nalysis
Symp
osium,
Lecture
Notes
in
Computer
Science
1145
(1996),
pp.
189{204.
[8]
F
ec
h
t,
C.
and
H.
Seidl,
Pr
op
agating
dier
enc
es:
A
n
e√Ücient
new
xp
oint
algorithm
for
distributive
c
onstr
aint
systems,
in:
C.
Hankin,
editor,
Pr
o
c
e
e
dings
of
the
7th
Eur
op
e
an
Symp
osium
on
Pr
o
gr
amming,
Lecture
Notes
in
Computer
Science
1381
(1998),
pp.
90{104.
53

D
amian
[9]
Hun
t,
S.,
\Abstract
In
terpretation
of
F
unctional
Languages:
F
rom
Theory
to
Practice,"
Ph.D.
thesis,
Departmen
t
of
Computing,
Imp
erial
College
of
Science
T
ec
hnology
and
Medicine,
London,
UK
(1991).
[10]
Jones,
N.
D.
and
F.
Nielson,
A
bstr
act
interpr
etation:
A
semantics-b
ase
d
to
ol
for
pr
o
gr
am
analysis,
in:
S.
Abramsky
,
D.
M.
Gabba
y
and
T.
S.
E.
Maibaum,
editors,
Semantic
Mo
del
ling,
The
Handb
o
ok
of
Logic
in
Computer
Science
4
(1995),
pp.
527{636.
[11]
Jrgensen,
N.,
Finding
xp
oints
in
nite
function
sp
ac
es
using
ne
e
de
dness
analysis
and
chaotic
iter
ation,
in:
B.
L.
Charlier,
editor,
Static
A
nalysis,
n
um
b
er
864
in
Lecture
Notes
in
Computer
Science
(1994),
pp.
329{345.
[12]
Kam,
J.
B.
and
J.
D.
Ullman,
Monotone
data
ow
analysis
fr
ameworks,
Acta
Informatica
7
(1977),
pp.
305{317.
[13]
Nielson,
F.,
H.
R.
Nielson
and
C.
Hankin,
\Principles
of
Program
Analysis,"
Springer-V
erlag,
1999.
[14]
O'Keefe,
R.
A.,
Finite
xe
d-p
oint
pr
oblems,
in:
J.-L.
Lassez,
editor,
L
o
gic
Pr
o
gr
amming,
Pr
o
c
e
e
dings
of
the
F
ourth
International
Confer
enc
e
(1987),
pp.
729{743.
[15]
Rosendahl,
M.,
Higher-or
der
chaotic
iter
ation
se
quenc
es,
in:
M.
Bruyno
oghe
and
J.
P
enjam,
editors,
Pr
o
c
e
e
dings
of
the
5th
International
Symp
osium
on
Pr
o
gr
amming
L
anguage
Implementation
and
L
o
gic
Pr
o
gr
amming,
n
um
b
er
714
in
Lecture
Notes
in
Computer
Science
(1993),
pp.
332{345.
[16]
Sabry
,
A.
and
M.
F
elleisen,
Is
c
ontinuation-p
assing
useful
for
data
ow
analysis?,
in:
V.
Sark
ar,
editor,
Pr
o
c
e
e
dings
of
the
A
CM
SIGPLAN'94
Confer
enc
e
on
Pr
o
gr
amming
L
anguages
Design
and
Implementation,
SIGPLAN
Notices,
V
ol.
29,
No
6
(1994),
pp.
1{12.
[17]
Sagiv,
S.,
T.
W.
Reps
and
S.
Horwitz,
Pr
e
cise
interpr
o
c
e
dur
al
dataow
analysis
with
applic
ations
to
c
onstant
pr
op
agation,
Theoretical
Computer
Science
167
(1996),
pp.
131{170.
[18]
Sc
hmidt,
D.
A.,
Natur
al-semantics-b
ase
d
abstr
act
interpr
etation,
in:
A.
Mycroft,
editor,
Static
A
nalysis,
n
um
b
er
983
in
Lecture
Notes
in
Computer
Science
(1995),
pp.
1{18.
[19]
Shiv
ers,
O.,
\Con
trol-Flo
w
Analysis
of
Higher-Order
Languages,"
Ph.D.
thesis,
Sc
ho
ol
of
Computer
Science,
Carnegie
Mellon
Univ
ersit
y
,
Pittsburgh,
P
ennsylv
ania
(1991),
T
ec
hnical
Rep
ort
CMU-CS-91-145.
[20]
Y
oung,
J.
and
P
.
Hudak,
Finding
xp
oints
on
function
sp
ac
es,
T
ec
hnical
Rep
ort
Y
ALEEU/DCS/RR-505,
Y
ale
Univ
ersit
y
,
New
Ha
v
en,
CT
(1986).
54

MFPS
17
Preliminary
Version
A
New
Approac
h
to
Quan
titativ
e
Domain
Theory
Lei
F
an
1;2
Dep
artment
of
Mathematics
Capital
Normal
University
Beijing
100037,
P.R.China
Abstract
This
pap
er
in
tro
duces
a
new
approac
h
to
the
theory
of

-categories
enric
hed
b
y
a
frame.
The
approac
h
com
bines
ideas
from
v
arious
areas
suc
h
as
generalized
ul-
trametric
domains,

-categories,
constructiv
e
analysis,
and
fuzzy
mathematics.
As
the
basic
framew
ork,
w
e
use
the
W
agner's

-category
[18
,19
]
with
a
frame
instead
of
a
quan
tale
with
unit.
The
ob
jects
and
morphisms
in
the
category
will
b
e
called
L-F
uzzy
p
osets
and
L-F
uzzy
monotone
mappings,
resp
ectiv
ely
.
Moreo
v
er,
w
e
in
tro-
duce
concepts
of
adjoin
ts
and
a
kind
of
con
v
ergence
in
an
L-F
uzzy
p
oset
that
mak
es
the
theory
\constructiv
e"
or
\computable".
1
In
tro
duction
Quan
titativ
e
Domain
Theory
has
attracted
m
uc
h
atten
tion
[4],
[15],
[17
],
and
[18
].
Amongst
these
dev
elopmen
ts,
K.W
agner's
theory
of

-categories
is
most
general,
and
J.J.M.M.Rutten's
theory
of
generalized
ultrametric
domains
is
closest
to
the
standard
domain
theory
.
So
it
is
natural
to
think
that
some
of
the
prop
erties
ab
out
the
latter,
esp
ecially
those
that
closely
connected
with
the
op
erational
and
top
ological
prop
erties
of
the
unit
in
terv
al
[0,1],
ma
y
not
b
e
generalized
to
the
theory
of

-categories
without
restricted
conditions
on
the
v
alued
quan
tale.
Of
course
this
is
righ
t
in
general,
but
it
is
not
alw
a
ys
true
as
K.W
agner's
w
ork
sho
ws.
In
this
pap
er
w
e
pro
vide
more
examples
to
further
supp
ort
this
observ
ation.
In
section
2,
w
e
review
some
materials
essen
tial
for
this
pap
er.
As
the
basis
w
e
use
W
agner's

-category
[18
]
with
a
frame
instead
of
a
comm
utativ
e
quan
tale
with
unit.
Ho
w
ev
er,
the
metho
d
used
in
this
pap
er
applies
to
the
1
This
w
ork
is
supp
orted
b
y
China
National
Natural
Science
F
oundations
2
Email:
fanlei63@hotmail
.c
om
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Lei
F
an
general
case.
The
ob
jects
and
morphisms
in
the
category
will
b
e
called
L-
F
uzzy
p
osets
and
L-F
uzzy
monotone
mappings
resp
ectiv
ely
b
ecause
w
e
hop
e
to
stress
the
fuzzy
view
that
this
pap
er
tak
es.
W
e
then
pro
v
e
a
represen
tation
theorem
whic
h
sho
ws
that
ev
ery
L-F
uzzy
preordered
set
can
b
e
represen
ted
b
y
a
family
of
preorders
on
that
set
prop
erly
glued
together.
In
the
end
of
the
section,
w
e
prop
ose
a
theory
of
adjoin
t
pairs
on
L-F
uzzy
monotone
mappings
whic
h
is
a
generalization
of
Rutten's
theory
of
metric
adjoin
t
pairs.
In
section
3,
w
e
in
tro
duce
a
theory
of
con
v
ergence
in
L-F
uzzy
p
osets.
The
theory
is
based
on
a
simple
idea
from
constructiv
e
analysis,
that
is,
replacing
the
arbitrary

>
0
with
a
prop
er
\computable"
sequence
suc
h
as
f1=ng.
So
our
w
ork
can
b
e
seen
as
a
constructiv
e
v
ersion
of
W
agner's
theory
of
liminf
con
v
ergence.
In
the
nal
section,
w
e
dev
elop
a
theory
for
recursiv
e
domain
equations
in
the
category
of
L-F
uzzy
p
osets
and
L-F
uzzy
adjoin
t
pairs,
follo
wing
the
metho
ds
of
J.J.M.M.Rutten
[15].
2
LF
-p
osets
and
LF
-monotone
mappings
First,
w
e
review
some
basic
concepts
from
the
theory
of

-categories
in
a
sligh
tly
dieren
t
form,
see
[19
]
for
details.
Note
that
w
e
use
a
frame
instead
of
a
comm
utativ
e
quan
tale
with
unit.
In
what
follo
ws,
(L;
)
will
denote
a
xed
non
trivial
frame
(or
complete
Heyting
algebra)
with
maximal
elemen
t
1
and
minimal
elemen
t
0.
F
or
a;
b
2
L,
the
meet,
union
and
implication
in
L
will
b
e
denoted
b
y
a
^
b,
a
_
b
and
a
!
b
resp
ectiv
ely
.
Denition
2.1
Let
X
b
e
a
non-empt
y
set,
e
:
X

X
 !
L
a
mapping.
e
is
called
an
L-F
uzzy
pr
e
or
der
on
X
if
it
satises
the
follo
wing
conditions:
1.
for
all
x
2
X
;
e(x;
x)
=
1;
2.
for
all
x;
y
;
z
2
X
;
e(x;
z
)
^
e(x;
y
)

e(y
;
z
):
The
pair
(X
;
e)
or
X
is
called
an
L-F
uzzy
pr
e
or
der
e
d
set.
If
e
satises
the
additional
condition
3.
for
all
x;
y
2
X
;
e(x;
y
)
=
e(y
;
x)
=
1
)
x
=
y
;
then
it
is
called
an
L-F
uzzy
p
artial
or
der
on
X
and
(X
;
e)
is
called
an
L-F
uzzy
p
artial
or
der
e
d
set
(abbreviated
as
L-F
uzzy
p
oset
or
LF-p
oset
).
4.
Let
(X
;
e
X
)
and
(Y
;
e
Y
)
b
e
L-F
uzzy
preordered
sets,
f
:
X
 !
Y
a
mapping.
f
is
called
an
L-F
uzzy
monotone
mapping
if
for
all
x;
y
2
X
,
e
Y
(f
(x);
f
(y
))

e
X
(x;
y
):
The
category
of
LF
-preordered
sets
(LF
-p
osets)
and
LF
-monotone
map-
pings
will
b
e
denoted
b
y
LF-Pre
(LF-POS).
Remark
2.2
(1)
If
L
=
f0;
1g,
then
the
category
LF-Pre
(LF-POS)
can
b
e
iden
tied
with
the
category
Pre
(POS)
of
ordinary
preordered
sets
56

Lei
F
an
(partially
ordered
sets)
and
monotone
mappings.
(2)
If
L
=
[0;
1],
then
the
category
LF-Pre
(LF-POS)
can
b
e
iden
tied
with
the
category
Gums
(Qums)
of
Rutten's
generalized
ultrametric
spaces
(quasi
ultrametric
spaces)
and
non-expansiv
e
mappings
through
the
relation
dened
b
elo
w:
e(x;
y
)
=
1
 d(x;
y
);
x;
y
2
X
:
In
tuitiv
ely
,
e(x;
y
)
is
in
terpreted
as
the
degree
of
x

y
.
This
partially
justies
the
term
L-F
uzzy.
Of
course,
there
are
other
reasons
for
that.
See
the
follo
wing
Example
2.3(2),[10
],
[11],
and
[13]
for
more
information.
Example
2.3
(1)
Let
(X
;
)
b
e
a
preordered
set.
F
or
x;
y
2
X
,
let
e

(x;
y
)
=
1
(
)
x

y
:
Then
(X
;
e

)
is
an
L-F
uzzy
preordered
set.
Moreo
v
er,
(X
;
e

)
is
an
L-
F
uzzy
p
oset
when

is
a
partial
order
on
X
.
(2)
Let
A
:
X
 !
L
b
e
an
L-F
uzzy
set
on
X
.
F
or
x;
y
2
X
,
let
e
A
(x;
y
)
=
A(x)
!
A(y
):
Then
(X
;
e
A
)
is
an
L-F
uzzy
preordered
set.
In
particular,
ev
ery
frame
L
can
b
e
seen
as
an
L-F
uzzy
preordered
set
b
y
letting
X
=
L
and
A
=
id
L
.
Let
(X
;
e
X
)
and
(Y
;
e
Y
)
b
e
L-F
uzzy
preordered
sets,
and
Y
X
=
[X
!
Y
]
=
ff
j
f
:
X
 !
Y
is
L-monotone
g:
W
e
can
mak
e
Y
X
as
an
L-F
uzzy
preordered
set
b
y
dening
E
Y
X
(f
;
g
)
=
^
fe
Y
(f
(x);
g
(x))
j
x
2
X
g;
f
;
g
2
Y
X
:
Moreo
v
er,
w
e
dene
the
noise
b
et
w
een
f
and
g
as
√Ü
hf
;
g
i
=
E
X
X
(id
X
;
g
√Ü
f
)
^
E
Y
Y
(f
√Ü
g
;
id
Y
):
Let
(X
;
e)
b
e
an
L-F
uzzy
preordered
set
and
x;
y
2
X
,
a
2
L.
Dene
a
relation
v
a
on
X
as
follo
ws:
x
v
a
y
(
)
e(x;
y
)

a.
Then
it
is
easy
to
c
hec
k
that
v
a
is
a
preorder
on
X
for
all
a
2
L.
In
fact
w
e
ha
v
e:
Theorem
2.4
(The
de
c
omp
osition
the
or
em)
L
et
(X
;
e)
b
e
an
L-F
uzzy
pr
e-
or
der
e
d
set.
Then
(1)
If
a

b,
then
v
b
v
a
.
(2)
F
or
al
l
S

L,
if
a
=
W
S
,
then
v
a
=
T
f
s
j
s
2
S
g.
(3)
F
or
al
l
x;
y
2
X
,
e(x;
y
)
=
W
fa
2
L
j
x
v
a
y
g.
57

Lei
F
an
Mor
e
over,
if
f
:
X
 !
Y
is
a
mapping
b
etwe
en
L-F
uzzy
pr
e
or
der
e
d
sets,
then
f
is
L-monotone
if
and
only
if
for
al
l
a
2
L,
f
:
(X
;
v
a
)
 !
(Y
;
v
a
)
is
monotone,
that
is,
x
v
a
y
=
)
f
(x)
v
a
f
(y
).
2
Theorem
2.5
(The
r
epr
esentation
the
or
em)
L
et
X
b
e
a
set
and
F
=
fR
a
j
a
2
Lg
a
family
of
pr
e
or
ders
on
X
with
the
fol
lowing
pr
op
erties:
(1)
if
a

b,
then
R
b

R
a
;
(2)
for
al
l
S

L,
R
a
=
T
fR
s
j
s
2
S
g
when
a
=
W
S
.
Then
(X
;
e
F
)
is
an
L-F
uzzy
pr
e
or
der
e
d
set,
wher
e
e
F
(x;
y
)
=
_
fa
2
L
j
(x;
y
)
2
R
a
g;
x;
y
2
X
:
Mor
e
over,
supp
ose
that
X
;
Y
ar
e
sets
with
F
=
fR
a
j
a
2
Lg,
G
=
fT
a
j
a
2
Lg
satisfying
pr
op
erties
(1)
and
(2)
ab
ove,
and
f
:
X
 !
Y
a
mapping
such
that
for
al
l
a
2
L,
f
:
(X
;
R
a
)
 !
(Y
;
T
a
)
is
monotone.
Then
f
:
(X
;
e
F
)
 !
(Y
;
e
G
)
is
an
L-monotone
mapping.
2
The
pro
of
of
ab
o
v
e
Theorems
are
routine.
It
is
in
teresting
to
note
that
Theorem
2.4
and
Theorem
2.5
can
b
e
rephrased
in
the
language
of
(pre-)shea
v
es
as
follo
ws.
Recall
that
a
pr
eshe
af
on
L
is
a
con
tra
v
arian
t
functor
F
:
L
 !
Set
from
L
(seen
as
a
category)
to
the
cate-
gory
Set
of
sets
and
mappings.
One
obtains
a
C
-presheaf
if
one
replaces
Set
with
a
more
general
category
C
with
prop
er
structures.
Let
P
O
(X
)
denote
the
p
oset
(so
a
category)
of
all
preorders
on
set
X
with
subset
inclusion
as
the
order.
Then
it
is
easy
to
see
that
condition
(1)
in
Theorem
2.5
is
equiv
alen
t
to
sa
ying
that
F
=
fR
a
j
a
2
Lg
is
a
P
O
(X
)-
presheaf
on
L
and
condition
(2)
is
exactly
the
sheaf
condition.
It
is
w
ell
kno
w
that
the
theory
of
adjoin
t
pairs
pla
ys
an
essen
tial
role
in
domain
theory
.
J.J.M.M.Rutten
[15]
and
F.Alesi
et
al.
[2]
established
a
truly
quan
titativ
e
v
ersion
of
the
classical
theory
of
adjoin
ts.
W
e
will
no
w
set
up
a
theory
of
adjoin
ts
ab
out
LF
-
monotone
mappings
that
is
a
generalization
to
Rutten's.
F
or
a;
b;

2
L,
set
a

b
=
(a
!
b)
^
(b
!
a)
and
a


b
,
a

b


.
In
informal
fuzzy
logic
terms,
a

b
is
the
\degree"
of
equiv
alence
of
prop
ositions
a
and
b,
whereas
a


b
means
that
a
and
b
are
equiv
alen
t
\up
to
degree

"
at
least.
Denition
2.6
Let
(X
;
e
X
)
and
(Y
;
e
Y
)
b
e
LF
-preordered
sets,
f
:
X
 !
Y
and
g
:
Y
 !
X
LF
-monotone
mappings
and

2
L.
If
for
all
x
2
X
,
y
2
Y
,
e
Y
(f
(x);
y
)


e
X
(x;
g
(y
));
then
f
;
g
is
called
an

-adjoin
t
pair,
and
denoted
b
y
f
a

g
.
Theorem
2.7
L
et
(X
;
e
X
)
and
(Y
;
e
Y
)
b
e
LF
-pr
e
or
der
e
d
sets,
f
:
X
 !
Y
and
g
:
Y
 !
X
LF
-monotone
mappings
and

2
L.
Then
the
fol
lowing
58

Lei
F
an
c
onditions
ar
e
e
quivalent:
(1)
f
a

g
;
(2)
√Ü
hf
;
g
i


1;
(3)
for
al
l
x
2
X
,
y
2
Y
,



,
f
(x)


y
,
x


g
(y
);
(4)
id
X
v

g
√Ü
f
,
f
√Ü
g
v

id
Y
.
2
The
essen
tial
part
of
the
pro
of
is
a
simple
result
from
frame
theory
as
b
elo
w.
Lemma
2.8
L
et
L
b
e
a
fr
ame
and
a;
b;

2
L.
The
the
fol
lowing
c
onditions
ar
e
e
quivalent:
(1)
a


b;
(2)
a
^

=
b
^

;
(3)
a
!

=
b
!

;
(4)
for
al
l

2
L;



;


a
,


b.
3
A
Theory
of
Con
v
ergence
in
LF
-p
osets
In
this
section,
w
e
in
tro
duce
a
theory
of
con
v
ergence
in
LF
-p
osets.
It
is
based
on
a
v
ery
simple
and
in
tuitiv
e
idea
from
constructiv
e
analysis,
that
is,
w
e
replace
arbitrary

>
0
with
a
computable
sequence
decreasing
to
0
(suc
h
as
f1=ng)
for
all
practical
purp
oses,
see
[3]
for
example.
W
e
generalize
the
idea
to
LF
-p
osets.
In
fact,
the
resulting
theory
is
a
sp
ecial
case
of
W
agner's
liminf
theory
of
con
v
ergence.
Denition
3.1
Let

=
(
n
)
n2!
b
e
an
increasing
sequence
in
L
and
W
f
n
j
n
2
!
g
=
1.
Then

is
called
a
testing
se
quenc
e.
Example
3.2
(1)
Let
L
=
f0;
1g
and
for
all
n
2
!
,

n
=
1.
Then

=
(
n
)
is
a
testing
sequence
in
L.
This
corresp
onds
to
the
classical
theory
based
on
preordered
sets.
(2)
Let
L
=
[0;
1]
and
for
all
n
2
!
,

n
=
1
 (1=n).
Then

=
(
n
)
is
a
testing
sequence
in
L.
This
corresp
onds
to
Rutten's
generalized
ultrametric
theory
.
(3)
Let
L
=
!
[
f!
g
and
for
all
n
2
!
,

n
=
n.
Then

=
(
n
)
is
a
testing
sequence
in
L.
This
corresp
onds
to
Mon
teiro's
theory
of
sfe
(sets
with
families
of
equiv
alence),
see
[14
]
for
the
details.
Denition
3.3
Let
(X
;
e)
b
e
a
non-empt
y
LF
-p
oset,
(x
n
)
n2!
a
sequence
in
X
.
(1)
(x
n
)
is
said
to
b
e
con
v
erging
to
x
with
r
esp
e
ct
to

(
-con
v
erges
to
x,
briey)
and
denoted
b
y
x
=

-
lim
x
n
if
there
exists
an
x
2
X
suc
h
that
59

Lei
F
an
for
ev
ery
N
2
!
and
a
2
X
,
^
nN
e(x
n
;
a)


N
e(x;
a):
(2)
(x
n
)
is
called
a
(forwar
d)
Cauchy
se
quenc
e
with
r
esp
e
ct
to

(
-Cauchy
se
quenc
e,
briey)
if
for
ev
ery
N
2
!
and
m

n

N
,
e(x
n
;
x
m
)


N
,
or
equiv
alen
tly
,
e(x
n
;
x
n+1
)


N
for
all
n

N
.
(3)
(X
;
e)
is
called

-c
omplete
if
ev
ery

-Cauc
h
y
sequence
in
X
con
v
erges.
The
category
of

-complete
LF
-p
osets
and
LF
-monotone
mappings
will
b
e
denote
b
y

-CPO.
Remark
3.4
An
anon
ymous
referee
p
oin
ts
out
to
the
author
that
the
con-
v
ergence
w.r.t

is
a
sp
ecial
instance
of
the
notion
of
w
eigh
ted-(co)limit
from
enric
hed
category
theory
,
see
[5].
F
or
the
case
of
metric
spaces
see
[16].
Example
3.5
Let
L
=
f0;
1g,
and

is
the
testing
sequence
in
Example
3.2(1).
Then
a
sequence
(x
n
)
in
X
has
the
limit
x
w.r.t

if
and
only
if
that
x
is
the
least
upp
er
b
ound
of
the
set
fx
n
j
n
2
!
g.
Moreo
v
er,
(x
n
)
is

-Cauc
h
y
if
and
only
if
it
is
an
increasing
sequence
in
X
.
So
w
e
ha
v
e:
Theorem
3.6
L
et
X
b
e
a
p
oset
se
en
as
an
LF
-p
oset
as
in
Example
2.3(1)
and

b
e
the
testing
se
quenc
e
dene
d
in
Example
3.2(1).
Then
X
is

-c
omplete
if
and
only
if
it
is
an
!
-dcp
o.
2
Theorem
3.7
L
et
(X
;
e)
b
e
an
LF
-p
oset,
(x
n
)
a
se
quenc
e
in
X
and
x
2
X
.
Then
x
=

-
lim
x
n
if
and
only
if
the
fol
lowing
c
onditions
hold:
(1)
V
nN
e(x
n
;
x)


N
;
N
2
!
;
(2)
V
nN
e(x
n
;
a)

e(x;
a);
N
2
!
;
a
2
X
.
2
Corollary
3.8
L
et
(x
n
)
b
e
a
se
quenc
e
in
X
and
x
2
X
.
If
x
=

-
lim
x
n
then:
(1)
n

N
;
e(x
n
;
x)


N
;
N
2
!
;
(2)
If
x
0
2
X
such
that
the
c
ondition
(1)
holds
then
e(x;
x
0
)
=
1.
2
The
conditions
(1)
and
(2)
in
Corollary
3.8
can
b
e
in
terpreted
in
order-
theoretic
terms
as
follo
ws:
(1')
for
all
N
2
!
,
n

N
,
x
n
v

N
x,
(2')
If
x
0
2
X
suc
h
that
the
condition
(1')
holds,
then
x
v

N
x
0
.
In
other
w
ords,
x
is
the
least
upp
er
b
ound
of
set
fx
n
j
n
2
!
;
n

N
g
at
the
lev
el

N
for
all
N
2
!
.
Theorem
3.9
L
et
L
b
e
a
fr
ame
se
en
as
an
LF
-p
oset
as
in
Example
2.3(2)
and
let

b
e
a
testing
se
quenc
e
in
L.
If
(x
n
)
is
an

-Cauchy
se
quenc
e
in
L,
then

-
lim
x
n
=
_
^
fx
n
j
N
2
!
;
n

N
g:
In
p
articular,
L
is

-c
omplete
as
an
LF
-p
oset.
2
60

Lei
F
an
Denition
3.10
Let
(X
;
e
X
),
(Y
;
e
Y
)
b
e
LF
-p
osets
and
f
:
(X
;
e
X
)
 !
(Y
;
e
Y
)
b
e
an
LF
-monotone
mapping.
(1)
f
is
called

-c
ontinuous
if
for
ev
ery
con
v
ergen
t
sequence
(x
n
)
in
X
,
(f
(x
n
))
is
a
con
v
ergen
t
sequence
in
Y
,
and
f
(
-
lim
x
n
)
=

-
lim
f
(x
n
):
The
set
C
(X
;
Y
)
of
all

-con
tin
uous
mappings
from
X
to
Y
is
an
LF
-
p
oset
to
o
when
it
is
seen
as
a
subset
of
Y
X
=
[X
!
Y
].
(2)
f
is
called

-appr
oximate
if
for
all
x;
y
2
X
,
N
2
!
,
e(x;
y
)


N
=
)
e(f
(x);
f
(y
))


N
+1
:
The
term
\appro
ximate"
w
as
coined
b
y
L.Mon
teiro
in
[14].
It
is
a
con-
structiv
e
form
of
con
traction
mapping
in
the
theory
of
metric
spaces.
Remark
3.11
It
is
w
ell
kno
w
that
ev
ery
con
traction
mapping
is
con
tin
uous
in
the
standard
metric
space.
But
it
is
not
true
in
the
presen
t
case.
In
fact,

-con
tin
uous
and

-appro
ximate
mappings
are
incomparable.
Theorem
3.12
Supp
ose
X
;
Y
ar
e
LF
-p
osets
and
Y
is

-c
omplete.
Then
C
(X
;
Y
)
is
also

-c
omplete.
2
Theorem
3.13
(Fixed
P
oin
t
Theorem)
L
et
(X
;
e)
b
e
an

-c
omplete
LF
-
p
oset
and
f
:
X
 !
X
an
LF
-monotone
mapping.
(1)
If
f
is

-c
ontinuous
and
ther
e
exists
an
x
2
X
such
that
e(x;
f
(x))
=
1,
then
f
has
a
xe
d
p
oint.
(2)
If
f
is

-c
ontinuous
and

-appr
oximate
and
ther
e
exists
an
x
2
X
such
that
e(x;
f
(x))


0
,
then
f
has
a
xe
d
p
oint.
2
The
pro
of
of
Theorem
3.13
is
similar
to
the
corresp
onding
result
of
gener-
alized
ultrametric
spaces,
see
Theorem
6.3
in
[15].
4
Domain
Equations
in
the
category

-CPO
In
this
section,
w
e
dev
elop
a
theory
for
solving
domain
equations
in
the
cate-
gory
of

-complete
LF
-p
osets
and
LF
-adjoin
t
pairs
follo
wing
the
metho
ds
of
J.M.Rutten
[15].
Pro
ofs
of
results
in
this
section
are
similar
to
the
cases
of
generalized
ultrametric
spaces,
see
[6]
for
details.
As
basic
framew
ork
w
e
use
the
category

-CPO
P
(P
stand
for
pairs)
of

-complete
LF
-p
osets
and

-con
tin
uous
LF
-adjoin
t
pairs,
that
is,
ob
jects
in

-
CPO
P
are

-complete
LF
-p
osets
and
morphisms
in

-CPO
P
are
pairs
hf
;
g
i
:
X
 !
Y
,
where
f
:
X
 !
Y
and
g
:
Y
 !
X
are

-con
tin
uous
mappings.
The
comp
osition
of
morphisms
is
dened
as
usual:
if
hf
;
g
i
:
X
 !
Y
,
hh;
k
i
:
Y
 !
Z
are
morphisms
in

-CPO
P
,
then
hf
;
g
i
√Ü
hh;
k
i
=
hh
√Ü
f
;
g
√Ü
k
i.
61

Lei
F
an
Denition
4.1
(1)
A
sequence
X
0
hf
0
;g
0
i
 !
X
1
hf
1
;g
1
i
 !



in

-CPO
P
is
called
an

-Cauchy
chain
if
for
ev
ery
N
2
!
and
n

N
,
f
n
a

N
g
n
,
or
equiv
alen
tly
,
√Ü
hf
n
;
g
n
i


N
1.
(2)
Let
X
0
hf
0
;g
0
i
 !
X
1
hf
1
;g
1
i
 !



b
e
an

-Cauc
h
y
c
hain
in

-CPO
P
.
A
cone
of
the
c
hain
is
a
sequence
fh
k
;

k
i
:
X
k
!
X
g
of
morphisms
in

-CPO
P
suc
h
that
h
k
;

k
i
=
h
k
+1
;

k
+1
i
√Ü
hf
k
;
g
k
i
for
ev
ery
k
2
!
.
(3)
A
cone
fh
k
;

k
i
:
X
k
!
X
g
is
a
colimit
if
it
is
initial,
that
is,
for
ev
ery
other
cone
fh
0
k
;

0
k
i
:
X
k
!
X
0
g,
there
exists
an
unique
morphism
hf
;
g
i
:
X
 !
X
0
suc
h
that
h
0
k
;

0
k
i
=
h
k
;

k
i
√Ü
hf
;
g
i
for
ev
ery
k
2
!
.
W
e
will
use
the
follo
wing
con
v
en
tions.
F
or
all
k
;
l
2
!
,
k
<
l
,
f
k
l
=
f
l
 1
√Ü



f
k
+1
√Ü
f
k
;
g
k
l
=
g
k
√Ü
g
k
+1



g
l
1
:
Note
that
f
k
;k
+1
=
f
k
,
g
k
;k
+1
=
g
k
.
Theorem
4.2
L
et
X
0
hf
0
;g
0
i
 !
X
1
hf
1
;g
1
i
 !



b
e
an

-Cauchy
chain
in

-CPO
P
and
fh
k
;

k
i
:
X
k
 !
X
g
a
c
one
of
the
chain.
Then
fh
k
;

k
ig
is
a
c
olimit
if
and
only
if
the
fol
lowing
c
onditions
hold:
(1)

k
√Ü

k
=

-
lim
l
>k
(g
k
l
√Ü
f
k
l
)
for
every
k
2
!
.
(2)

-
lim
(
k
√Ü

k
)
=
id
X
.
2
Theorem
4.3
Every

-Cauchy
chain
in

-CPO
P
has
an
unique
c
olimit
c
one.2
Denition
4.4
Supp
ose
F
:
LF
 POS
 !
LF
 POS
b
e
a
functor
and
F
X
Y
:
Y
X
 !
F
(Y
)
F
(X
)
denote
the
mapping
f
7!
F
(f
)
for
LF
-p
osets
X
;
Y
.
(1)
F
is
said
to
b
e
lo
cal
LF
-monotone
if
F
X
Y
is
LF
-monotone
for
an
y
LF
-
p
osets
X
;
Y
.
(2)
F
is
said
to
b
e
lo
cal

-c
ontinuous
if
F
X
Y
is

-con
tin
uous
for
an
y
LF
-
p
osets
X
;
Y
.
62

Lei
F
an
(3)
F
is
said
to
b
e
lo
cal

-appr
oximate
if
F
X
Y
is

-appro
ximate
for
an
y
LF
-
p
osets
X
;
Y
.
Ev
ery
functor
F
:
LF
 POS
 !
LF
 POS
can
b
e
extended
to
a
func-
tor
F
P
:

-CPO
P
 !

-CPO
P
as
follo
ws:
F
P
(X
)
=
F
(X
)
for
ev
ery
ob
ject
X
in

-CPO
P
and
F
P
(hf
;
g
i)
=
hF
(f
);
F
(g
)i
for
ev
ery
morphism
hf
;
g
i
in

-CPO
P
.
The
functor
F
P
:

-CPO
P
 !

-CPO
P
is
said
to
b
e
lo
c
al
LF-
monotone
(lo
c
al

-c
ontinuous,
lo
c
al

-appr
oximate,
resp
ectiv
ely)
if
the
corre-
sp
onding
functor
F
is.
Theorem
4.5
L
et
F
P
:

-CPO
P
 !

-CPO
P
b
e
the
functor
dene
d
as
ab
ove.
Then:
(1)
If
F
is
lo
c
al
LF
-monotone,
then
√Ü
(F
P
(hf
;
g
i))
=
√Ü
hF
(f
);
F
(g
)i

√Ü
hf
;
g
i
for
every
morphism
hf
;
g
i
in

-CPO
P
.
(2)
If
F
is
lo
c
al

-appr
oximate,
then
√Ü
hf
;
g
i


N
=
)
√Ü
hF
(f
);
F
(g
)i


N
+1
for
every
morphism
√Ü
hf
;
g
i
in

-CPO
P
and
N
2
!
.
2
As
the
case
of
generalized
ultrametric
spaces,
w
e
can
no
w
giv
e
a
categorical
v
ersion
of
the
Theorem
3.13.
Theorem
4.6
(The
xe
d
p
oint
ther
o
em,
c
ate
goric
al
version)
L
et
F
P
:

-
CPO
P
 !

-CPO
P
b
e
a
functor.
(1)
If
F
is
lo
c
al

-c
ontinuous
and
ther
e
exists
an
obje
ct
X
and
a
morphism
hf
;
g
i
:
X
 !
F
(X
)
of

-CPO
P
such
that
f
a
g
.
Then
ther
e
exists
an
obje
ct
Y
of

-CPO
P
satisfying
that
F
(Y
)

=
Y
.
(2)
If
F
is
lo
c
al

-c
ontinuous
and

-appr
oximate
and
ther
e
exists
an
obje
ct
X
and
a
morphism
hf
;
g
i
:
X
 !
F
(X
)
of

-CPO
P
such
that
f
a

0
g
.
Then
ther
e
exists
an
obje
ct
Y
of

-CPO
P
satisfying
that
F
(Y
)

=
Y
.
2
Ac
kno
wledgemen
t
The
author
is
grateful
to
Professors
M.
Mislo
v
e,
G.-Q.
Zhang,
and
referees
for
their
in
v
aluable
help
to
correct
n
umerous
errors,
impro
v
e
the
presen
tation
and
mak
e
commen
ts.
References
[1]
Abramsky
,
S.,
A.
Jung,
Domain
theory
,
in
S.Abramsky
,
D.Gabba
y
,
T.Maibaum,
editors,
\Handb
o
ok
of
Logic
in
Computer
Science",
v
ol.3,
pp.1-168,
Oxford
Univ
ersit
y
Press,
1995.
63

Lei
F
an
[2]
Alesi,
F.,
P
.
Baldan,
G.
Belle
and
J.J.M.M.
Rutten,
Solutions
of
functorial
and
non-functorial
metric
domain
equations,
Electronic
Notes
in
Theoretical
Computer
Science
1
(1995).
URL:
http://www.elsevier.nl/
locate/entcs/volume1.htm
l.
[3]
Bishop,
E.,
D.
Bridges,
\Constructiv
e
Analysis",
Springer-V
erlag
1985.
[4]
Bonsangue,
M.M.,
F.v
an
Breugel,
J.J.M.M.Rutten,
Generalized
Ultrametric
spaces:
completion,
top
ology
,
and
p
o
w
erdomains
via
the
Y
oneda
em
b
edding,
Theoretical
Computer
Science
193
(1998),
pp.1-51.
[5]
Borceux,
F.,
G.
M.
Kelly
,
A
notion
of
limit
for
enric
hed
categories,
Bull.
Austral.
Math.
So
c.
12
(1975),
pp.49-72.
[6]
F
an,
L.,
Some
Questions
in
Domain
Theory
,
Ph.D
Thesis,
Capital
Normal
Univ
ersit
y
2001.
(In
Chinese)
[7]
Flagg,
B.,
R.
Kopp
erman,
Con
tin
uit
y
Spaces:
Reconciling
Domains
and
Metric
Spaces,
Theoretical
Computer
Science
177
(1997),
pp.111-138.
[8]
Flagg,
B.,
R.
Kopp
erman,
Fixed
p
oin
ts
and
reexiv
e
domain
equations
in
categories
of
con
tin
uit
y
spaces,
Electronic
Notes
in
Theoretical
Computer
Science
1
(1995).
URL:
http://www.elsevier.nl/lo
cat
e/en
tcs/
volume1.html.
[9]
Flagg,
B.,
P
.
S

underhauf
and
K.
W
agner.
A
Logical
Approac
h
to
Quan
titativ
e
Domain
Theory
.
Preprin
t
Submitted
to
Elsevier,
1996.
[10]
Gra
yson,
R.
J.,
Heyting-v
alued
seman
tics,
in
G.Lotti
et
al.,
editors,
Logic
Collo
quium'
82,
pp.181-208,
Elservier
Science
1983.
[11]
H
ohle,
U.,
F
uzzy
sets
and
sub
ob
jects,
in
A.
Jones
et
al.,
editors,
\F
uzzy
Sets
and
Applications",
pp.69-76,
D.Reidel
Publishing
Compan
y
1986.
[12]
La
wv
ere,
F.
W.,
Metric
Spaces,
Generalized
Logic
and
Closed
Categories,
Rend.
Sem.
Mat.
e.
Fisico
di
Milano
43
(1973),
pp.135-166.
[13]
Lo
w
en,
R.,
Mathematics
and
F
uzziness,
in
A.Jones
et
al.,
editors,
\F
uzzy
Sets
and
Applications",
pp.3-38,
D.Reidel
Publishing
Compan
y
1986.
[14]
Mon
teiro,
L.,
Seman
tic
domains
based
on
sets
with
families
of
equiv
alences,
Electronic
Notes
in
Theoretical
Computer
Science
11(1996).
URL:
http://www.elsevier.nl/loc
ate
/ent
cs/v
olu
me11
.htm
l.
[15]
Rutten,
J.J.M.M.,
Elemen
ts
of
generalized
ultrametric
domain
theory
,
Theoreotical
Computer
Science,
170(1996),
pp.349-381.
[16]
Rutten,
J.J.M.M.,
W
eigh
ted
colimits
and
formal
balls
in
generalized
metric
spaces,
T
op
ology
and
its
Applications
89
(1998),
pp.179-202.
[17]
Sm
yth,
M.
B.,
Quasi-Uniformities:
Reconciling
Domains
with
Metric
Space,
Mathematical
F
oundations
of
Programming
Language
Seman
tics,
Lecture
Notes
in
Computer
Science,
Springer-V
erlag
1987.
64

Lei
F
an
[18]
W
agner,
K.,
Solving
Recursiv
e
Domain
Equations
With
Enric
hed
Categories,
Ph.D
Thesis,
Carnegie
Mellon
Univ
ersit
y
1994.
[19]
W
agner,
K.,
Liminf
con
v
ergence
in

-categories,
Theoretical
Computer
Science,
to
app
ear.
[20]
Zheng,
Chongy
ou,
L.
F
an,
H.
B.
Cui,
\F
rame
and
Con
tin
uous
Lattices"(2nd
edition),
Capital
Normal
Univ
ersit
y
Press,
Beijing
2000.
(In
Chinese)
65

66

MFPS
17
Preliminary
Version
A
Concurren
t
Graph
Seman
tics
F
or
Mobile
Am
bien
ts
F
abio
Gadducci,
Ugo
Mon
tanari
1
Dip
artimento
di
Informatic
a,
Universit
a
di
Pisa
Corso
Italia
40,
Pisa,
Italy
Email:
fgadducci,ugog@di.unipi.it
Abstract
W
e
presen
t
an
enco
ding
for
nite
pro
cesses
of
the
mobile
am
bien
ts
calculus
in
to
term
graphs,
pro
ving
its
soundness
and
completeness
with
resp
ect
to
the
original,
in
terlea
ving
op
erational
seman
tics.
With
resp
ect
to
most
of
the
other
approac
hes
for
the
graphical
implemen
tation
of
calculi
with
name
mobilit
y
,
our
term
graphs
are
unstructured
(that
is,
non
hierarc
hical),
th
us
a
v
oiding
an
y
\encapsulation"
of
pro
cesses.
The
implication
is
t
w
ofold.
First
of
all,
it
allo
ws
for
the
reuse
of
standard
graph
rewriting
theory
and
to
ols
for
sim
ulating
the
reduction
seman
tics.
More
im-
p
ortan
tly
,
it
allo
ws
for
the
sim
ultaneous
execution
of
indep
enden
t
reductions,
whic
h
are
nested
inside
am
bien
ts,
th
us
oering
a
concurren
t
seman
tics
for
the
calculus.
Key
wor
ds:
concurren
t
graph
rewriting,
graphical
enco
ding
of
pro
cess
calculi,
mobile
am
bien
ts,
reduction
seman
tics.
1
In
tro
duction
After
the
dev
elopmen
t
of
so-called
optimal
implemen
tation
of
-calculus,
man
y
authors
prop
osed
graphical
presen
tation
for
calculi
with
name
mobilit
y
,
in
par-
ticular
for
the

-calculus
[24].
These
prop
osals
usually
in
tro
duce
a
syn
tactical
notation
for
graphs,
then
they
map
pro
cesses
in
to
graphs
via
that
notation.
With
a
few
exceptions
[13,27],
the
resulting
graphical
structures
are
eminen
tly
hierarc
hical
(that
is,
roughly
,
eac
h
no
de/edge/lab
el
is
itself
a
structured
en
tit
y
,
and
p
ossibly
a
graph),
th
us
forcing
the
dev
elopmen
t
of
ad-ho
c
mec
hanisms
for
graph
rewriting,
in
order
to
sim
ulate
pro
cess
reduction.
1
Researc
h
partly
supp
orted
b
y
the
EC
TMR
Net
w
ork
Gener
al
The
ory
of
Gr
aph
T
r
ansfor-
mation
Systems
(getgra
ts);
b
y
the
EC
Esprit
W
G
Applic
ations
of
Gr
aph
T
r
ansformations
(appligraph);
and
b
y
the
Italian
MURST
Pro
ject
T
e
oria
del
la
Conc
orr
enza,
Linguaggi
di
Or
dine
Sup
erior
e
e
Struttur
e
di
Tipi
(tosca).
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Gadducci
and
Mont
anari
In
this
pap
er
w
e
presen
t
instead
a
general
prop
osal
for
mapping
pro
cesses
of
calculi
with
name
mobilit
y
in
to
unstructured,
non-hierarc
hical
graphs.
As
the
main
example
w
e
c
hose
mobile
am
bien
ts
[6],
partly
for
its
rising
p
opularit
y
in
the
comm
unit
y
,
while
still
lac
king
an
analysis
of
its
concurrency
features;
and
partly
b
ecause
the
complex
name
handling
presen
ted
b
y
its
reduction
rules
highligh
ts
the
p
o
w
er
of
our
framew
ork.
In
fact,
w
e
b
eliev
e
that
the
in
tuitiv
e
app
eal
of
non-hierarc
hical
graphs,
and
the
lo
cal
nature
of
the
asso
ciated
rewriting
mec
hanism,
ma
y
help
cast
some
ligh
t
on
the
distributed
features
of
the
calculus.
T
o
this
end,
our
rst
step
is
to
pro
v
e
the
soundness
and
correctness
of
our
enco
ding
of
pro
cesses
in
to
graphs,
in
the
sense
that
t
w
o
pro
cesses
are
structurally
equiv
alen
t
if
and
only
if
the
corresp
onding
graphs
are
isomorphic.
Our
second
step
is
to
pro
v
e
that
the
enco
ding
is
faithful
with
resp
ect
to
the
reduction
seman
tics,
in
the
sense
that
standard
graph
rewriting
tec
hniques
ma
y
no
w
b
e
used
to
sim
ulate
reduction
steps
on
pro
cesses
b
y
sequences
of
rewrites
on
their
enco
dings.
One
of
the
additional
adv
an
tages
of
form
ulating
the
reduction
seman
tics
of
mobile
am
bien
ts
in
terms
of
graph
rewriting
is
the
existence
of
a
w
ell-
dev
elop
ed
concurren
t
seman
tics
[1],
whic
h
extends
the
concurren
t
seman
tics
of
P
etri
nets
and
whic
h
allo
ws
to
deriv
e
graph
pro
cesses,
ev
en
t
structures
and
prime
algebraic
domains
from
graph
transformation
systems.
A
concurren
t
seman
tics
puts
an
upp
er
limit
to
the
amoun
t
of
parallelism
that
is
in
trinsic
in
the
reductions,
and
moreo
v
er
it
allo
ws
to
deriv
e
causalit
y
links
b
et
w
een
reduction
steps,
whic
h
can
b
e
useful
in
b
etter
understanding
the
b
eha
viour
of
a
pro
cess,
e.g.
with
resp
ect
to
securit
y
and
non-in
terference.
The
pap
er
has
the
follo
wing
structure:
In
Section
2
w
e
recall
the
mobile
am
bien
ts
calculus,
and
w
e
discuss
t
w
o
alternativ
e
reduction
seman
tics.
In
Sec-
tion
3
w
e
in
tro
duce
a
set-theoretical
presen
tation
for
(rank
ed
term)
graphs,
and
w
e
dene
t
w
o
op
erations
on
them,
namely
se
quential
and
p
ar
al
lel
c
omp
o-
sition
[7,8].
These
op
erations
are
used
in
Section
4
to
form
ulate
our
enco
ding
for
pro
cesses
of
the
mobile
am
bien
t
calculus,
whic
h
is
then
pro
v
ed
to
b
e
sound
and
complete
with
resp
ect
to
structural
congruence.
Finally
,
in
Section
5
w
e
recall
the
basic
to
ols
of
graph
rewriting,
according
to
the
dpo
approac
h,
and
w
e
sho
w
ho
w
four
simple
graph
rewriting
rules
allo
w
for
sim
ulating
the
reduction
seman
tics
of
the
mobile
am
bien
ts
calculus.
W
e
then
argue
ho
w
the
informa-
tion
on
causal
dep
endencies
b
et
w
een
rewriting
steps
oered
b
y
the
concurren
t
seman
tics
of
graph
rewriting
ma
y
b
e
used
for
detecting
interfer
enc
es
among
pro
cess
reductions,
according
to
the
taxonom
y
prop
osed
in
[22].
W
e
close
the
pap
er
with
a
few
remarks,
concerning
the
relev
ance
of
mapping
pro
cesses
in
to
unstructured
graphs
from
the
p
oin
t
of
view
of
parallelism;
the
generalit
y
of
the
approac
h,
and
its
relationship
with
ongoing
w
ork
on
the
graphical
presen-
tation
of
algebraic
formalisms;
and
nally
,
the
w
a
y
to
extend
our
results,
in
order
to
handle
recursiv
e
pro
cesses.
68

Gadducci
and
Mont
anari
P
=
Q
for
P
;
Q

-con
v
ertible;
P
j
Q
=
Q
j
P
;
P
j
(Q
j
R
)
=
(P
j
Q)
j
R
;
P
j
0
=
P
;
(
n)(
m)P
=
(
m)(
n)P
(
n)(P
j
Q)
=
P
j
(
n)Q
for
n
62
fn(P
):
(
n)m[P
]
=
m[(
n)P
]
for
n
6=
m
Fig.
1.
The
set
of
axioms
without
deadlo
c
k
detection
(
n)0
=
0
Fig.
2.
The
additional
axiom
for
deadlo
c
k
detection
2
Structural
congruences
for
mobile
am
bien
ts
This
section
shortly
in
tro
duces
the
nite,
comm
unication-free
fragmen
t
of
the
mobile
am
bien
ts
calculus,
its
structural
equiv
alence
and
the
asso
ciated
reduc-
tion
seman
tics.
In
addition,
w
e
describ
e
t
w
o
alternativ
e
structural
equiv
alences
for
the
calculus,
pro
ving
that
the
asso
ciated
reduction
seman
tics
are
in
fact
\coinciden
t",
in
a
w
a
y
to
b
e
made
precise
later
on,
to
the
original
seman
tics.
2.1
The
original
c
alculus
Denition
2.1
(pro
cesses)
L
et
N
b
e
a
set
of
atomic
names,
r
ange
d
over
by
m;
n;
o;
:
:
:
.
A
pro
cess
is
a
term
gener
ate
d
by
the
fol
lowing
syntax
P
::=
0
;
n[P
];
M
:P
;
(
n)P
;
P
1
j
P
2
for
the
set
of
capabilities
M
::=
in
n;
out
n;
open
n:
We
let
P
;
Q;
R
;
:
:
:
r
ange
over
the
set
Pr
o
c
of
pr
o
c
esses.
W
e
assume
the
standard
denitions
for
the
set
of
free
names
of
a
pro
cess
P
,
denoted
b
y
fn(P
).
Similarly
for

-con
v
ertibilit
y
,
with
resp
ect
to
the
r
estriction
op
erators
(
n).
Using
these
denitions,
the
dynamic
b
eha
viour
of
a
pro
cess
P
is
describ
ed
as
a
relation
o
v
er
abstr
act
pr
o
c
esses
,
i.e.,
a
relation
obtained
b
y
closing
a
set
of
basic
rules
under
structural
congruence.
Denition
2.2
(reduction
seman
tics)
The
reduction
relation
for
pr
o-
c
esses
is
the
r
elation
R
m

Pr
oc

Pr
oc,
close
d
under
the
structur
al
c
ongruenc
e

=
induc
e
d
by
the
set
of
axioms
in
Figur
e
1
and
Figur
e
2,
inductively
gener
ate
d
by
the
fol
lowing
set
of
axioms
and
infer
enc
e
rules
m[n[out
m:P
j
Q]
j
R
]
!
n[P
j
Q]
j
m[R
]
n[in
m:P
j
Q]
j
m[R
]
!
m[n[P
j
Q]
j
R
]
open
n:P
j
n[Q]
!
P
j
Q
P
!
Q
(
n)P
!
(
n)Q
P
!
Q
P
j
R
!
Q
j
R
P
!
Q
n[P
]
!
n[Q]
wher
e
P
!
Q
me
ans
that
hP
;
Qi
2
R
m
.
69

Gadducci
and
Mont
anari
(
n)M
:P
=
M
:(
n)P
for
n
62
fn
(M
)
Fig.
3.
The
additional
axiom
for
capabilit
y
oating
2.2
Two
alternative
structur
al
c
ongruenc
es
An
imp
ortan
t
no
v
elt
y
in
calculi
with
name
mobilit
y
is
the
use
of
structural
congruence
for
presen
ting
the
reduction
seman
tics.
This
is
in
tuitiv
ely
app
eal-
ing,
since
abstr
act
pro
cesses
allo
ws
for
a
simple
represen
tation
(that
is,
mo
dulo
a
suitable
equiv
alence)
of
the
spatial
distribution
of
a
system.
Man
y
equiv-
alences,
though,
ma
y
b
e
tak
en
in
to
accoun
t.
Let
us
denote
resp
ectiv
ely
as
P
!
d
Q
the
reduction
relation
obtained
b
y
closing
the
inference
rules
pre-
sen
ted
in
Denition
2.2
with
resp
ect
to
the
structural
congruence,
denoted
b
y

=
d
,
induced
b
y
the
set
of
axioms
in
Figure
1;
and
b
y
P
!
f
Q
the
reduction
relation
obtained
b
y
closing
the
inference
rules
presen
ted
in
Denition
2.2
with
resp
ect
to
the
structural
congruence,
denoted
b
y

=
f
,
induced
b
y
the
set
of
axioms
in
Figure
1
and
Figure
3.
The
rst
equiv
alence

=
d
is
ner
than

=
,
since
it
just
forbids
the
iden
ti-
cation
of
the
deadlo
c
k
ed
pro
cesses
0
and
(
n)0.
Nev
ertheless,
the
mapping
from
abstract
pro
cesses
according
to

=
d
,
in
to
abstract
pro
cesses
according
to

=
,
faithfully
preserv
es
the
reduction
seman
tics,
as
stated
b
y
next
theorem.
Prop
osition
2.3
(deadlo
c
k
and
reductions)
L
et
P
;
Q
b
e
pr
o
c
esses.
(1)
If
P
!
d
Q,
then
P
!
Q.
Vic
e
versa,
(2)
if
P
!
Q,
then
ther
e
exists
a
pr
o
c
ess
R
such
that
P
!
d
R
and
Q

=
R
.
In
other
terms,
the
mapping
do
es
not
add
reductions.
Sometimes,
these
kinds
of
mapping
are
also
called
tr
ansition
pr
eserving
morphisms
[11
],
a
sp
e-
cial
form
of
the
general
notion
of
op
en
map
[18
].
A
similar
prop
ert
y
is
satised
b
y
the
mapping
from
abstract
pro
cesses
according
to

=
d
,
in
to
abstract
pro-
cesses
according
to

=
f
,
adding
the
distributivit
y
of
restriction
with
resp
ect
to
capabilit
y
(that
is,
letting
the
restrictions
oat
to
the
top
of
a
term).
Prop
osition
2.4
(distributivit
y
and
reductions)
L
et
P
;
Q
b
e
pr
o
c
esses.
(1)
If
P
!
d
Q,
then
P
!
f
Q.
Vic
e
versa,
(2)
if
P
!
f
Q,
then
ther
e
exists
a
pr
o
c
ess
R
such
that
P
!
d
R
and
Q

=
f
R
.
Our
main
theorem
will
presen
t
an
alternativ
e
c
haracterization
of
the
rela-
tion
!
f
b
y
means
of
graph
rewriting
tec
hniques.
3
Graphs
and
term
graphs
W
e
op
en
the
section
recalling
the
denition
of
(rank
ed)
term
graphs:
W
e
refer
to
[5,7]
for
a
detailed
in
tro
duction,
as
w
ell
as
for
a
comparison
with
standard
denitions
suc
h
as
[3].
In
particular,
w
e
assume
in
the
follo
wing
a
c
hosen
signature
(;
S
),
for

a
set
of
op
erators,
and
S
a
set
of
sorts,
suc
h
that
the
arity
of
an
op
erator
in

is
a
pair
(!
s
;
!
t
),
for
!
s
;
!
t
strings
in
S

.
70

Gadducci
and
Mont
anari
Denition
3.1
(graphs)
A
lab
elled
graph
d
(over
(;
S
))
is
a
ve
tuple
d
=
hN
;
E
;
l
;
s;
ti,
wher
e
N
,
E
ar
e
the
sets
of
no
des
and
edges;
l
is
the
p
air
of
lab
eling
functions
l
e
:
E
!
,
l
n
:
N
!
S
;
s;
t
:
E
!
N

ar
e
the
source
and
target
functions;
and
such
that
for
e
ach
e
dge
e
2
dom(l
),
the
arity
of
l
e
(e)
is
(l

n
(s(e));
l

n
(t(e))),
i.e.,
e
ach
e
dge
pr
eserves
the
arity
of
its
lab
el.
With
an
abuse
of
notation,
in
the
denition
ab
o
v
e
w
e
let
l

n
denote
the
extension
of
the
function
l
n
from
no
des
to
strings
of
no
des.
Moreo
v
er,
w
e
denote
the
comp
onen
ts
of
a
graph
d
b
y
N
d
,
E
d
,
l
d
,
s
d
and
t
d
.
Denition
3.2
(graph
morphisms)
L
et
d,
d
0
b
e
gr
aphs.
A
(graph)
mor-
phism
f
:
d
!
d
0
is
a
p
air
of
functions
f
n
:
N
d
!
N
d
0
,
f
e
:
E
d
!
E
d
0
that
pr
eserves
the
lab
eling,
sour
c
e
and
tar
get
functions.
In
order
to
inductiv
ely
dene
an
enco
ding
for
pro
cesses,
w
e
need
to
dene
some
op
erations
o
v
er
graphs.
The
rst
step
is
to
equip
them
with
suitable
\handles"
for
in
teracting
with
an
en
vironmen
t,
built
out
of
other
graphs.
Denition
3.3
((rank
ed)
term
graphs)
L
et
d
r
;
d
v
b
e
gr
aphs
with
no
e
dges.
A
(d
r
;
d
v
)-rank
ed
graph
(a
graph
of
rank
(d
r
;
d
v
))
is
a
triple
g
=
hr
;
d;
v
i,
for
d
a
gr
aph
and
r
:
d
r
!
d,
v
:
d
v
!
d
the
inje
ctive
ro
ot
and
v
ariable
morphisms.
L
et
g
,
g
0
b
e
r
anke
d
gr
aphs
of
the
same
r
ank.
A
rank
ed
graph
morphism
f
:
g
!
g
0
is
a
gr
aph
morphism
f
d
:
d
!
d
0
b
etwe
en
the
underlying
gr
aphs
that
pr
eserves
the
r
o
ot
and
variable
morphisms.
Two
gr
aphs
g
=
hr
;
d;
v
i
and
g
0
=
hr
0
;
d
0
;
v
0
i
of
the
same
r
ank
ar
e
isomorphic
if
ther
e
exists
a
rank
ed
graph
isomorphism

:
g
!
g
0
.
A
(d
r
;
d
v
)-r
anke
d
term
gr
aph
G
is
an
isomorphism
class
of
(d
r
;
d
v
)-r
anke
d
gr
aphs.
With
an
abuse
of
notation,
w
e
sometimes
refer
to
the
no
des
in
the
image
of
the
v
ariable
(ro
ot)
morphism
as
v
ariables
(ro
ots,
resp
ectiv
ely).
Moreo
v
er,
w
e
often
use
the
same
sym
b
ols
of
rank
ed
graphs
to
denote
term
graphs,
so
that
e.g.
G
d
r
d
v
denotes
a
term
graph
of
rank
(d
r
;
d
v
).
Denition
3.4
(sequen
tial
and
parallel
comp
osition)
L
et
G
d
i
d
v
,
H
d
r
d
i
b
e
term
gr
aphs.
Their
sequen
tial
comp
osition
is
the
term
gr
aph
G
d
i
d
v
;
H
d
r
d
i
of
r
ank
(d
r
;
d
v
)
obtaine
d
by
rst
the
disjoint
union
of
the
gr
aphs
underlying
G
and
H
,
and
se
c
ond
the
gluing
of
the
r
o
ots
of
G
with
the
c
orr
esp
onding
variables
of
H
.
L
et
G
d
r
d
v
,
H
d
0
r
d
0
v
b
e
term
gr
aphs,
such
that
d
v
\
d
0
v
=
;.
Their
parallel
comp
o-
sition
is
the
term
gr
aph
G
d
r
d
v

H
d
0
r
d
0
v
of
r
ank
(d
r
[
d
0
r
;
d
v
[
d
0
v
)
obtaine
d
by
rst
the
disjoint
union
of
the
gr
aphs
underlying
G
and
H
,
and
se
c
ond
the
gluing
of
the
r
o
ots
of
G
with
the
c
orr
esp
onding
r
o
ots
of
H
.
2
2
Let
G
d
i
d
v
=
hr
;
d;
v
i
and
H
d
r
d
i
=
hr
0
;
d
0
;
v
0
i
b
e
term
graphs.
Then,
G;
H
=
hr
00
;
d
00
;
v
00
i,
for
d
00
the
disjoin
t
union
of
d
and
d
0
,
mo
dulo
the
equiv
alence
on
no
des
induced
b
y
r
(x)
=
v
0
(x)
for
all
x
2
N
d
i
,
and
r
00
:
d
r
!
d
00
,
v
00
:
d
v
!
d
00
the
uniquely
induced
arro
ws.
Let
no
w
G
d
r
d
v
=
hr
;
d;
v
i
and
H
d
0
r
d
0
v
=
hr
0
;
d
0
;
v
0
i
b
e
term
graphs.
Then,
G

H
=
hr
00
;
d
00
;
v
00
i,
for
d
00
the
disjoin
t
union
of
d
and
d
0
,
mo
dulo
the
equiv
alence
on
no
des
induced
b
y
r
(x)
=
r
0
(x)
for
all
x
2
N
d
r
\
N
d
0
r
,
and
r
00
:
d
r
[
d
0
r
!
d
00
;
v
00
:
d
v
[
d
0
v
!
d
00
the
uniquely
induced
arro
ws.
71

Gadducci
and
Mont
anari



1
o
√Ü
/
f
?
 
/
√Ü
2
o

3
o
1
/

1
o
2
/
√Ü
/
g
/

√Ü
2
o
3
/

3
o



1
o
√Ü
/
f
=
/
/
√Ü
/
g
/
 
√Ü
2
o

3
o
Fig.
4.
Tw
o
term
graphs,
and
their
sequen
tial
comp
osition
Note
that
the
t
w
o
op
erations
are
dened
on
\concrete"
graphs.
Nev
erthe-
less,
the
result
is
clearly
indep
enden
t
of
the
c
hoice
of
the
represen
tativ
e,
and
it
implies
that
b
oth
parallel
and
sequen
tial
comp
osition
are
asso
ciativ
e.
Example
3.5
(sequen
tial
comp
osition)
L
et
us
c
onsider
the
signatur
e
(
e
;
S
e
),
for
S
e
=
fs
1
;
s
2
g
and

e
=
ff
:
s
1
s
2
!
s
1
s
2
s
1
;
g
:
s
2
!
s
2
s
1
g.
Two
term
gr
aphs,
built
out
of
the
signatur
e
(
e
;
S
e
),
ar
e
shown
in
Figur
e
4.
The
no
des
in
the
domain
of
the
r
o
ot
(variable)
morphism
ar
e
depicte
d
as
a
vertic
al
se
quenc
e
on
the
right
(left,
r
esp
e
ctively);
e
dges
ar
e
r
epr
esente
d
by
their
lab
el,
fr
om
wher
e
arr
ows
p
ointing
to
the
tar
get
no
des
le
ave,
and
to
wher
e
the
arr
ows
fr
om
the
sour
c
e
no
de
arrive.
The
r
o
ot
and
variable
morphisms
ar
e
r
epr
esente
d
by
dotte
d
arr
ows,
dir
e
cte
d
fr
om
right-to-left
and
left-to-right,
r
esp
e
ctively.
The
term
gr
aph
on
the
left
has
r
ank
(f1;
2;
3g;
;),
ve
no
des
and
one
e
dge
(lab
el
le
d
by
f
);
the
term
gr
aph
on
the
midd
le
has
r
ank
(f1;
2;
3g;
f1;
2;
3g),
four
no
des
and
one
e
dge
(lab
el
le
d
by
g
).
F
or
gr
aphic
al
c
onvenienc
e,
in
the
underlying
gr
aph
the
no
des
of
sort
s
1
ar
e
denote
d
by
,
those
of
sort
s
2
by
√Ü.
Se
quential
c
omp
osition
of
term
gr
aphs
is
p
erforme
d
by
matching
the
r
o
ots
of
the
rst
gr
aph
with
the
variables
of
the
se
c
ond
one,
as
shown
by
the
term
gr
aph
on
the
right:
It
has
r
ank
(f1;
2;
3)g;
;),
six
no
des
and
two
e
dges,
and
it
is
obtaine
d
by
se
quential
ly
c
omp
osing
the
other
two.
A
(term
gr
aph)
expr
ession
is
a
term
o
v
er
the
signature
con
taining
all
rank
ed
term
graphs
as
constan
ts,
and
parallel
and
sequen
tial
comp
osition
as
binary
op
erators.
An
expression
is
wel
l-forme
d
if
all
o
ccurrences
of
b
oth
parallel
and
sequen
tial
comp
osition
are
dened
for
the
rank
of
the
argumen
t
sub-
expressions,
according
to
Denition
3.4;
the
r
ank
of
an
expression
is
then
computed
inductiv
ely
from
the
rank
of
the
term
graphs
app
earing
in
it,
and
its
value
is
the
term
graph
obtained
b
y
ev
aluating
all
op
erators
in
it.
4
Channels
as
wires:
from
pro
cesses
to
term
graphs
The
rst
step
in
our
implemen
tation
is
to
enco
de
pro
cesses
in
to
term
graphs,
built
out
of
a
suitable
signature
(
m
;
S
m
),
and
pro
ving
that
the
enco
ding
preserv
es
structural
con
v
ertibilit
y
.
Then,
standard
graph
rewriting
tec
hniques
are
used
for
sim
ulating
the
reduction
mec
hanism.
The
set
of
sorts
S
m
con
tains
the
elemen
ts
s
p
and
s
a
.
The
rst
sym
b
ol
is
reminiscen
t
of
the
w
ord
pr
o
c
ess
,
since
the
elemen
ts
of
sort
s
p
can
b
e
considered
as
pro
cesses
reac
hed
b
y
a
transition.
The
second
sort,
s
a
,
is
reminiscen
t
of
ambient
,
and
the
elemen
ts
of
this
sort
corresp
ond
to
names
of
the
calculus.
72

Gadducci
and
Mont
anari
e
/

/
op
 
/

e
o
√Ü
n
o
e
/

e
o
n
/
√Ü

e
o
Fig.
5.
T
erm
graphs
op
n
(for
op
2
famb;
in;
open;
outg),

n
and
0.
op
/

e
o
√Ü
n
o
n
/
√Ü
n
o
Fig.
6.
T
erm
graphs
op
(for
op
2
fg
o;
idl
eg),
new
n
e
id
n
.
The
op
erators
are
fin
:
s
p
!
s
p
s
a
;
out
:
s
p
!
s
p
s
a
;
open
:
s
p
!
s
p
s
a
g
[
famb
:
s
p
!
s
p
s
a
g
[
fg
o
:

!
s
p
;
idl
e
:

!
s
p
g.
The
elemen
ts
of
the
rst
set
sim
ulate
the
capabilities
of
the
calculus;
the
amb
op
erator
sim
ulates
am
bien
ts.
Note
that
there
is
no
op
erator
for
sim
ulating
name
restriction;
instead,
the
op
erators
go
and
id
le
are
syn
tactical
devices
for
detecting
the
status
of
those
no
des
in
the
source
of
an
edge
lab
eled
amb
,
th
us
a
v
oiding
to
p
erform
an
y
reduction
b
elo
w
the
outermost
capabilit
y
op
erator,
as
sho
wn
in
Section
5.
The
second
step
is
the
c
haracterization
of
a
class
of
graphs,
suc
h
that
all
pro
cesses
can
b
e
enco
ded
in
to
an
expression
con
taining
only
those
graphs
as
constan
ts,
and
parallel
and
sequen
tial
comp
osition
as
binary
op
erators.
Th
us,
let
us
consider
a
name
e
62
N
:
Our
c
hoice
is
depicted
in
Figure
5
and
Figure
6.
Denition
4.1
(enco
ding
for
pro
cesses)
L
et
P
b
e
a
pr
o
c
ess,
and
let
 b
e
a
set
of
names,
such
that
fn(P
)

 .
The
enco
ding
JP
K
g
o
 maps
a
pr
o
c
ess
P
into
a
term
gr
aph,
as
dene
d
b
elow
by
structur
al
induction,
JP
K
g
o
 =
JP
K
 
g
o
J0K
 =
0

(
N
o2 new
o
)
Jn[P
]K
 =
(JP
K
 
idl
e);
(amb
n

(
N
o2 id
o
))
JM
:P
K
 =
JP
K
 ;
(M
n

(
N
o2 id
o
))
for
M
c
ap
ability
with
fn(M
)
=
fng
J(
n)P
K
 =
JP
f
m
=
n
gK
fmg[ ;
(
m

(
N
o2 id
o
))
for
name
m
62
 JP
j
QK
 =
JP
K
 
JQK
 wher
e
we
assume
the
standar
d
denition
for
name
substitution.
Th
us,
the
mapping
prexes
the
term
graph
JP
K
 with
the
o
ccurrence
of
a
\ready"
tag,
the
go
op
erator:
It
will
denote
an
activ
ating
p
oin
t
for
reduction.
The
mapping
is
w
ell-dened,
in
the
sense
that
the
result
is
indep
enden
t
of
the
c
hoice
of
the
name
m
in
the
last
rule;
moreo
v
er,
giv
en
a
set
of
names
 ,
the
enco
ding
JP
K
g
o
 of
a
pro
cess
P
is
a
term
graph
of
rank
(feg
[
 ;
;).
Example
4.2
(a
graphical
view
of
rew
alls)
We
pr
esent
the
implemen-
tation
of
a
r
ewal
l
ac
c
ess,
as
pr
op
ose
d
by
Car
del
li
and
Gor
don
[6].
First,
some
gr
aphic
al
c
onventions.
The
enc
o
ding
of
a
pr
o
c
ess
P
is
a
term
gr
aph
G
=
JP
K
fk
g
73

Gadducci
and
Mont
anari
idl
e

g
o





j
[Q]
j
fk
g
/_
_
:
M P S U V X Z [ ] ` b
k

/
open
/
/

/
amb
/
$H
H
H
H
H

e
o
√Ü
k
o
Fig.
7.
T
erm
graph
for
Ag
ent(Q)
=
k
[open
k
:Q].
idl
e
 
g
o





j
[P
]
j
fk
g
/_
_
$
S V Y Z [ \ \ \ [ Z Y V S

/
open
/


/
amb
/
!

e
o
idl
e
 
√Ü

/
in
/
;

/
amb
N
/
√Ü
k
o

/
in
>
@A
BC
O
Fig.
8.
T
erm
graph
for
F
ir
ew
al
l
(P
)
=
(
w
)(w
[open
k
:P
]
j
k
[in
k
:in
w
:0]).
g
o
 

/
in
/
 

/
out
/
 

e
o
√Ü
√Ü
m
o
Fig.
9.
T
erm
graph
enco
ding
for
b
oth
(
n)out
m:in
n:0
and
out
m:(
n)in
n:0.
of
r
ank
(fe;
k
g;
;):
We
r
epr
esent
it
by
cir
cling
the
expr
ession,
fr
om
wher
e
two
dashe
d
arr
ows
le
ave,
dir
e
cte
d
to
the
r
o
ots
of
G
(henc
e,
to
the
no
des
of
G
p
ointe
d
by
e
and
k
,
r
esp
e
ctively).
The
term
gr
aph
Jk
[open
k
:Q]K
g
o
fk
g
is
shown
in
Figur
e
7.
The
pr
o
c
ess
(
w
)(w
[open
k
:P
]
j
k
[in
k
:in
w
:0]),
simulating
a
r
ewal
l,
is
inste
ad
implemente
d
by
the
r
anke
d
term
gr
aph
in
Figur
e
8.
The
mapping
J K
g
o
 is
not
surjectiv
e,
b
ecause
there
are
term
graphs
of
rank
(feg
[
 ;
;)
that
are
not
the
image
of
an
y
pro
cess;
nev
ertheless,
our
enco
ding
is
sound
and
complete,
as
stated
b
y
the
prop
osition
b
elo
w.
Prop
osition
4.3
L
et
P
,
Q
b
e
pr
o
c
esses,
and
let
 b
e
a
set
of
names,
such
that
fn(P
)
[
fn(Q)

 .
Then,
P

=
f
Q
if
and
only
if
JP
K
g
o
 =
JQK
g
o
 .
Our
enco
ding
is
th
us
sound
and
complete
with
resp
ect
to
equiv
alence

=
f
.
It
is
easy
to
see
e.g.
that
the
pro
cesses
(
n)out
m:in
n:0
and
out
m:(
n)in
n:0,
for
n
6=
m,
are
mapp
ed
to
the
same
term
graph,
represen
ted
in
Figure
9.
5
Reductions
as
graph
rewrites
W
e
op
en
the
section
recalling
the
basic
to
ols
of
the
double-pushout
(dpo)
approac
h
to
graph
rewriting,
as
presen
ted
in
[9,10
],
and
in
tro
ducing
a
mild
generalization
of
its
w
ell-understo
o
d
pr
o
c
ess
semantics
[1].
W
e
then
pro
vide
a
graph
rewriting
system
R
m
for
mo
deling
the
reduction
seman
tics
of
mobile
am
bien
ts.
Finally
,
w
e
discuss
the
concurren
t
features
of
the
rewriting
system
R
m
,
as
captured
b
y
the
pro
cess
seman
tics,
arguing
that
they
enhance
the
anal-
ysis
of
the
causal
dep
endencies
among
the
p
ossible
reductions
p
erformed
b
y
a
74

Gadducci
and
Mont
anari
d
L
p
:
m
L

(1)
d
K
r
/
l
o
m
K

(2)
d
R
m
R

d
G
d
D
r

/
l

o
d
H
Fig.
10.
A
dpo
direct
deriv
ation
mobile
am
bien
t
pro
cess,
with
resp
ect
to
the
original
in
terlea
ving
seman
tics.
5.1
T
o
ols
of
dpo
gr
aph
r
ewriting
Denition
5.1
(graph
pro
duction
and
deriv
ation)
A
graph
pro
duction
p
:

is
c
omp
ose
d
of
a
pro
duction
name
p
and
of
a
sp
an
of
gr
aph
morphisms

=
(d
L
l
 
 d
K
r
 !
d
R
).
A
graph
transformation
system
(or
gts)
G
is
a
set
of
pr
o
ductions,
al
l
with
dier
ent
names.
Thus,
when
appr
opriate,
we
denote
a
pr
o
duction
p
:

using
only
its
name
p.
A
gr
aph
pr
o
duction
p
:
(d
L
l
 
 d
K
r
 !
d
R
)
is
injectiv
e
if
l
is
inje
ctive.
A
gr
aph
tr
ansformation
system
G
is
injectiv
e
if
al
l
its
pr
o
ductions
ar
e
so.
A
double-pushout
diagr
am
is
like
the
diagr
am
depicte
d
in
Figur
e
10,
wher
e
top
and
b
ottom
ar
e
sp
ans
and
(1)
and
(2)
ar
e
pushout
squar
es
in
the
c
ate
gory
G
;S
of
gr
aphs
and
gr
aph
morphisms
(over
the
signatur
e
(;
S
)).
Given
a
pr
o
duction
p
:
(d
L
l
 
 d
K
r
 !
d
R
),
a
direct
deriv
ation
fr
om
d
G
to
d
H
via
pr
o
duction
p
and
triple
m
=
hm
L
;
m
K
;
m
R
i
is
denote
d
by
d
G
p=m
=
)
d
H
.
A
deriv
ation
(of
length
n)

in
a
gts
G
is
a
nite
se
quenc
e
of
dir
e
ct
derivations
d
G
0
p
1
=m
1
=
)
:
:
:
p
n
=m
n
=
)
d
G
n
wher
e
p
1
;
:
:
:
;
p
n
ar
e
pr
o
ductions
of
G
.
Op
erationally
,
the
application
of
a
pro
duction
p
to
a
graph
d
G
consists
of
three
steps.
First,
the
match
m
L
:
d
L
!
d
G
is
c
hosen,
pro
viding
an
o
ccurrence
of
d
L
in
d
G
.
Then,
all
ob
jects
of
G
matc
hed
b
y
d
L
 l
(d
K
)
are
remo
v
ed,
leading
to
the
c
ontext
gr
aph
d
D
.
Finally
,
the
ob
jects
of
d
R
 r
(d
K
)
are
added
to
d
D
,
obtaining
the
deriv
ed
graph
d
H
.
The
role
of
the
interfac
e
graph
d
K
in
a
rule
is
to
c
haracterize
the
elemen
ts
of
the
graph
to
b
e
rewritten
that
are
read
but
not
consumed
b
y
a
direct
deriv
a-
tion.
Suc
h
a
distinction
is
imp
ortan
t
when
considering
c
oncurr
ent
deriv
ations,
p
ossibly
dened
as
an
equiv
alence
class
of
concrete
deriv
ations
up-to
so-called
shift
e
quivalenc
e
[9],
iden
tifying
(as
for
the
analogous,
b
etter-kno
wn
p
ermu-
tation
e
quivalenc
e
of
-calculus)
those
deriv
ations
whic
h
dier
only
for
the
sc
heduling
of
indep
enden
t
steps.
Roughly
,
the
equiv
alence
states
the
in
ter-
c
hangeabilit
y
of
t
w
o
direct
deriv
ations
d
1
=
)
d
2
=
)
d
3
if
they
act
either
on
disjoin
t
parts
of
d
1
,
or
on
parts
that
are
in
the
image
of
the
in
terface
graphs.
A
more
concrete,
y
et
equiv
alen
t
notion
of
abstract
deriv
ation
for
a
gts
is
obtained
b
y
means
of
the
so-called
pr
o
c
ess
semantics
.
As
for
the
similar
notion
on
P
etri
nets
[15],
a
graph
pro
cess
represen
ts
a
description
for
a
deriv
ation
that
abstracts
from
the
ordering
of
causally
unrelated
steps
(as
it
is
the
case
for
shift
75

Gadducci
and
Mont
anari
d
L
1
p
1
:
m
L
1 
d
K
1
l
1
o
r
1 /
m
K
1
d
R
1
m
R
1
44444
d
L
i
p
i
:
m
Li

d
K
i
l
io
r
i /
m
K
i
R
i
m
R
i
11111
d
L
n
p
n
:
m
L
n

d
K
n
l
n
o
r
n/
m
K
n

d
R
n
m
R
n

d
G
0
.
d
D
1
l

1o
r

1
/
&
d
G
1
$
:::
d
G
i 1

d
D
i
l

i
o
r

i
/

d
G
i

:::
d
G
n 1
z
d
D
n
l

n
o
r

n/
x
d
G
n
p
d

Fig.
11.
Colimit
construction
for
deriv
ation

=
d
G
0
p
1
=m
1
=
)
:
:
:
p
n
=m
n
=
)
d
G
n
p
a
:
a
/

ks

+3
c
/

p
b
:
b
A

ks

+3
d
@

{ 


">>>>>>
|       
#>>>>>>
b
@
a
/

ks
b
@

+3
b
@
c
/

ks
c
/

+3
d
@
c
/

Fig.
12.
The
deriv
ation

ex
=
d
G
0
p
a
=m
a
=
)
d
G
a
p
b
=m
b
=
)
d
G
b
equiv
alence),
and
that
oers
at
the
same
time
a
concrete
represen
tativ
e
for
a
class
of
equiv
alen
t
deriv
ations.
The
denition
b
elo
w
sligh
tly
generalizes
[1].
Denition
5.2
(graph
pro
cesses)
L
et
G
b
e
an
inje
ctive
gts,
and
let

b
e
a
derivation
d
G
0
p
1
=m
1
=
)
:
:
:
p
n
=m
n
=
)
d
G
n
of
length
n
(upp
er
p
art
of
Figur
e
11).
The
(gr
aph)
pr
o
c
ess
()
asso
ciate
d
to
the
derivation

is
the
n
+
1-tuple
ht
G
0
;
hp
1
;

1
i;
:
:
:
;
hp
n
;

n
ii:
Each

i
is
a
triple
ht
L
i
;
t
K
i
;
t
R
i
i,
and
the
gr
aph
mor-
phisms
t
x
i
:
d
x
i
!
d

,
for
x
i
2
fL
i
;
K
i
;
R
i
g
and
i
=
1;
:
:
:
;
n,
ar
e
those
uniquely
induc
e
d
by
the
c
olimit
c
onstruction
shown
in
Figur
e
11.
L
et
,

0
b
e
two
derivations
of
length
n,
b
oth
originating
fr
om
gr
aph
d
G
0
.
They
ar
e
pro
cess
equiv
alen
t
if
the
asso
ciate
d
gr
aph
pr
o
c
esses
ar
e
isomorphic,
i.e.,
if
ther
e
exists
a
gr
aph
isomorphism


:
d

!
d

0
and
a
bije
ctive
function

p
:
f1;
:
:
:
;
ng
!
f1;
:
:
:
;
ng,
such
that
pr
o
ductions
p
i
and
p
0

p
(i)
c
oincide
for
al
l
i
=
1;
:
:
:
;
n,
and
al
l
the
involve
d
diagr
ams
c
ommute.
3
A
graph
pro
cess
asso
ciated
to
a
deriv
ation

th
us
includes,
b
y
means
of
the
colimit
construction
and
of
the
morphisms
t
x
i
,
the
action
of
eac
h
single
pro
duction
p
i
on
the
graph
d

.
>F
rom
the
image
of
eac
h
d
x
i
is
then
p
ossible
to
reco
v
er
a
suitable
partial
order
among
the
direct
deriv
ations
in
,
whic
h
faith-
fully
mirrors
the
causal
relationship
among
them.
F
or
example,
let
(
ex
;
S
ex
)
b
e
the
one-sorted
signature
con
taining
just
four
constan
ts,
namely
fa;
b;
c;
dg;
and
let
G
ex
b
e
the
gts
con
taining
t
w
o
rules,
roughly
rewriting
a
in
to
c
and
b
in
to
d.
The
deriv
ation

ex
is
represen
ted
in
Figure
12,
where,
for
the
sak
e
of
readabilit
y
,
graph
morphisms
are
simply
depicted
as
thic
k
arro
ws.
3
Explicitly
,


√Ü
t
G
0
=
t
0
G
0
,
and


√Ü
t
x
i
=
t
0
x

p
(i)
for
x
i
2
fL
i
;
K
i
;
R
i
g
and
i
=
1;
:
:
:
;
n.
76

Gadducci
and
Mont
anari
a
#
/ /
p
a
/ /
c
{

b
;
/ /
p
b
/ /
d
c
Fig.
13.
Compact
represen
tation
for
the
pro
cess
(
ex
)
g
o
!
g
o
-

2
/
open
/
%J
J
J
J

3

1
/
amb
9t
t
t
t
/
√Ü
n
g
o
 
g
o
-

2

3

1
√Ü
n
g
o
/
1

2
3
√Ü
n
Fig.
14.
The
rewriting
rule
for
open
n:P
j
n[Q]
!
P
j
Q
g
o
 

1
/
out
/
8

2
/
amb
/
 

3
/
amb
/
 

4
√Ü
n
√Ü
m
g
o
 

3
/
amb
/
 

4

1

2
√Ü
m
√Ü
n
g
o
 

3
/
amb
/
 

4

1
2
/
amb
<zzzz
 
√Ü
m
√Ü
n
Fig.
15.
The
rewriting
rule
for
m[n[out
m:P
j
Q]
j
R
]
!
m[R
]
j
n[P
j
Q]
The
pro
cess
(
ex
)
can
b
e
describ
ed
as
in
Figure
13,
extending
the
graph
d

ex
with
t
w
o
shaded
b
o
xes:
They
are
lab
elled
p
a
and
p
b
,
in
order
to
mak
e
explicit
the
mappings
t
x
i
(hence,
the
action
of
the
rules
on
the
initial
graph).
Th
us,
(the
application
of
)
the
pro
duction
p
a
consumes
the
a
edge
(it
is
in
the
image
of
t
L
a
,
but
not
in
the
image
of
t
K
a
),
and
this
is
denoted
b
y
the
dotted
arro
w
from
a
in
to
p
a
;
it
then
reads
the
only
no
de
(whic
h
is
indeed
in
the
image
of
t
K
a
),
denoted
b
y
the
dotted
arro
w
with
no
head;
and
nally
,
it
creates
the
c
edge,
denoted
b
y
the
dotted
arro
w
in
to
c.
Similarly
,
(the
application
of
)
the
pro
duction
p
b
consumes
the
b
edge,
reads
the
no
de
and
creates
the
d
edge.
W
e
feel
conden
t
that
our
example
underlines
the
connection
b
et
w
een
the
pro
cess
seman
tics
for
graphs,
and
the
standard
pro
cess
seman
tics
for
P
etri
nets.
This
compact
represen
tation
is
further
argued
up
on
on
Section
5.3.
5.2
A
gr
aph
r
ewriting
system
for
ambients
W
e
nally
in
tro
duce
in
this
section
the
graph
rewriting
system
R
m
.
W
e
rst
discuss
informally
its
set
of
pro
ductions,
then
stating
more
precisely
ho
w
its
rewrites
sim
ulate
the
op
erational
b
eha
viour
of
pro
cesses.
The
rule
p
open
:
(d
Lo
l
o
 
 d
K
o
r
o
 !
d
Ro
)
for
sync
hronizing
an
op
en
edge
with
a
relev
an
t
am
bien
t
o
ccurrence
is
presen
ted
in
Figure
14:
the
graph
on
the
left-hand
side
(cen
ter,
righ
t-hand
side)
is
d
Lo
(d
K
o
and
d
Ro
,
resp
ectiv
ely);
the
action
of
the
rule
(that
is,
the
span
of
graph
morphisms)
is
in
tuitiv
ely
describ
ed
b
y
the
no
de
iden
tiers.
Both
amb
and
op
en
edges
disapp
ear
after
77

Gadducci
and
Mont
anari
g
o

g
o
 

3
/
amb
/
 

4

1
/
in
/
=

2
/
amb
=z
z
z
 
√Ü
m
√Ü
n
g
o

g
o
 

3
/
amb
/
 

4

1

2
√Ü
m
√Ü
n
g
o
 
g
o
 

1
2
/
amb
/


3
/
amb
/


4
√Ü
n
√Ü
m
Fig.
16.
The
rewriting
rule
for
m[P
]
j
n[in
m:Q
j
R
]
!
m[n[Q
j
R
]
j
P
]
idle
-
g
o
!

1
/
amb
/
$J
J
J
J

2
√Ü
n
g
o
!

1
/
amb
/
%K
K
K
K

2
√Ü
n
g
o
-
g
o
!

1
/
amb
/
%K
K
K
K

2
√Ü
n
Fig.
17.
The
rewriting
rule
for
br
o
adc
asting
reduction,
and
all
the
connected
no
des
are
coalesced.
Notice
that
the
reduction
cannot
happ
en
unless
b
oth
the
no
de
shared
in
the
sync
hronization
and
the
no
de
under
the
amb
prex
are
activ
ated,
i.e.,
are
lab
elled
b
y
the
go
mark.
After
reduction,
also
the
no
de
under
the
op
en
prex
b
ecomes
activ
ated.
The
o
ccurrence
of
the
no
des
in
the
in
terface
graph
allo
ws
for
applying
the
rule
in
ev
ery
p
ossible
con
text.
Similarly
,
the
o
ccurrence
of
the
go
op
erators
allo
ws
for
the
sim
ultaneous
execution
of
other
deriv
ations
using
these
\tags",
since
the
\read"
p
olitics
for
edges
in
the
in
terface
implies
that
e.g.
more
than
one
pair
of
distinct
resources
ma
y
sync
hronize
at
the
top
lev
el.
Let
us
consider
no
w
the
rules
p
out
and
p
in
,
for
sim
ulating
the
out
and
in
reductions
of
the
calculus,
presen
ted
in
Figure
15
and
Figure
16.
As
for
the
p
open
rule,
the
action
of
the
t
w
o
pro
ductions
is
describ
ed
b
y
the
no
de
iden
tiers.
It
is
relev
an
t
that
the
am
bien
ts
link
ed
with
iden
tier
n
are
rst
consumed
and
then
re-created
b
y
the
rules,
as
they
do
not
b
elong
to
the
in
terface
graphs.
On
the
con
trary
,
the
am
bien
ts
link
ed
with
iden
tier
m
are
just
read,
and
this
implies
that
e.g.
more
than
one
reduction
ma
y
act
sim
ultaneously
on
that
am
bien
t:
This
fact
will
b
e
further
conrmed
when
discussing
the
pro
cess
seman
tics
for
the
gts
R
m
in
Section
5.3.
Finally
,
let
p
br
oad
b
e
the
rule
in
Figure
17.
It
has
no
corresp
ondence
in
the
reduction
seman
tics,
and
its
purp
ose
is
broadcasting
the
activ
ation
mark
to
a
tree
of
am
bien
ts,
whenev
er
its
ro
ot
b
ecomes
activ
ated.
An
o
ccurrence
of
the
go
op
erator,
denoting
an
activ
ating
p
oin
t
for
the
pro
cess
reduction,
p
ermeates
in
to
the
external
am
bien
t,
reac
hing
the
in
ternal
no
de
lab
elled
b
y
iden
tier
1.
Of
course,
the
propagation
cannot
pro
ceed
when
a
capabilit
y
prex
is
reac
hed.
Let
the
expression
d
G
=
)

b
d
H
denote
that
d
H
is
obtained
b
y
a
nite
n
um-
b
er
of
applications
of
the
broadcasting
rule
p
br
oad
to
d
G
.
W
e
can
nally
state
the
main
theorems
of
the
pap
er,
concerning
the
soundness
and
completeness
of
our
enco
ding
with
resp
ect
to
the
reduction
seman
tics.
Theorem
5.3
(enco
ding
preserv
es
reductions)
L
et
P
,
Q
b
e
pr
o
c
esses,
78

Gadducci
and
Mont
anari
g
o
 
g
o
!
g
o
!




j
[P
]
j
/_
_

1
/
amb
/
$I
I
I
I

2
/
amb
/
$J
J
J
J

3




j
[Q]
j
/_
_

4
/
open
:u
u
u
u
u
/
√Ü
n
open
/
:t
t
t
t
t
√Ü
m




j
[R]
j
/_
_

5
4
)
g
o
+




j
[P
]
j
/_
_
_
_
1
5

2
3;4




j
[Q]
j
3
f q 	
q
√Ü
n




j
[R]
j
6
l 


√Ü
m
Fig.
18.
Sim
ultaneous
application
of
nested,
y
et
causally
unrelated
reductions
and
let
 b
e
a
set
of
names
such
that
fn(P
)

 .
If
the
r
e
duction
P
!
f
Q
is
entaile
d,
then
R
m
entails
a
derivation
f
jP
j
g
 =
)

b
d
G
=
)
d
H
,
such
that
f
jQj
g
 =
)

b
d
H
.
In
tuitiv
ely
,
pro
cess
reduction
is
sim
ulated
b
y
rst
applying
a
sequence
of
broadcasting
rules,
th
us
enabling
(b
y
the
propagation
of
the
go
op
erator)
those
ev
en
ts
whose
activ
ating
p
oin
t
is
nested
inside
one
or
more
am
bien
ts,
and
then
sim
ulating
the
actual
reduction
step.
The
mapping
f
jP
j
g
 in
tro
duced
in
the
statemen
t
of
the
theorem
denotes
the
graph
(that
is,
a
represen
tativ
e
of
the
equiv
alence
class
of
isomorphic
graphs)
underlying
the
term
graph
JP
K
g
o
 .
Theorem
5.4
(enco
ding
do
es
not
add
reductions)
L
et
P
b
e
a
pr
o
c
ess,
and
let
 b
e
a
set
of
names
such
that
fn(P
)

 .
If
R
m
entails
a
derivation
f
jP
j
g
 =
)

b
d
G
=
)
d
H
,
then
ther
e
exists
a
pr
o
c
ess
Q
such
that
P
!
f
Q
is
entaile
d
and
f
jQj
g
 =
)

b
d
H
.
5.3
On
c
ausal
dep
endency
and
simultane
ous
exe
cution
W
e
argued
in
the
In
tro
duction
that
the
concurren
t
seman
tics
of
gts's
ma
y
shed
some
ligh
t
in
the
understanding
of
pro
cess
b
eha
viour
for
mobile
am
bien
ts.
It
is
in
fact
an
ob
vious
consideration
that
b
y
our
enco
ding
w
e
can
equip
mobile
am
bien
ts
with
a
concurren
t
seman
tics,
simply
considering
for
eac
h
pro-
cess
P
of
the
calculus
the
classes
of
pro
cess
equiv
alen
t
deriv
ations
asso
ciated
to
the
graph
f
jP
j
g
fn
(P
)
.
This
is
in
tuitiv
ely
conrmed
b
y
the
analysis
of
a
rather
simple
pro
cess,
namely
,
S
=
m[n[P
]
j
open
n:Q]
j
open
m:R
.
The
pro
cess
S
ma
y
ob
viously
p
erform
t
w
o
reductions,
op
ening
either
the
am
bien
t
m,
or
the
am
bien
t
n:
These
reductions
should
b
e
considered
as
indep
enden
t,
since
they
act
on
nested,
y
et
causally
unrelated
o
ccurrences
of
an
am
bien
t.
This
inde-
p
endence
b
ecomes
explicit
in
the
graph
d
S
,
obtained
b
y
applying
t
wice
the
broadcasting
rule
to
f
jS
j
g
fm;ng
,
and
depicted
on
the
left-hand-side
of
Figure
18
(forgetting
for
the
sak
e
of
clarit
y
the
subscripts
and
the
dashed
arro
ws
lea
ving
from
the
graphs
underlying
[
[
P
]
]
fm;ng
and
[
[
Q]
]
fm;ng
and
directed
to
either
m
or
n).
Pro
duction
p
open
ma
y
no
w
b
e
applied
t
wice,
reducing
either
those
edges
link
ed
with
the
no
de
n,
or
those
link
ed
with
the
no
de
m,
th
us
sim
ulating
the
reductions
originating
from
S
.
These
rewrites
ma
y
b
e
executed
in
an
y
order,
resulting
in
t
w
o
dieren
t
deriv
ations,
whic
h
are
nev
ertheless
pro
cess
equiv
a-
len
t.
The
resulting
graph
is
depicted
on
the
righ
t-hand
side
of
Figure
18.
79

Gadducci
and
Mont
anari
g
o





j
[P
]
j
/_
_

1
/
out
/
@A
BCO

2
/
amb

<
√Ü
n




j
[R]
j
/_
_

3
/
amb
/
!

4




j
[Q]
j
/_
_

5
/
out
/
8

6
/
amb
O
<
√Ü
o
√Ü
m
)
g
o





j
[P
]
j
/_
_

1=2
/
amb

<
√Ü
n




j
[R]
j
/_
_

3
/
amb
/
>

4
√Ü
m




j
[Q]
j
/_
_

5=6
/
amb
O
<
√Ü
o
Fig.
19.
Sim
ultaneous
application
of
nested
reductions
sharing
an
am
bien
t
Let
us
consider
no
w
a
more
complex
example,
and
let
T
b
e
the
pro
cess
m[n[out
m:P
]
j
o[out
m:Q]
j
R
],
whic
h
can
b
e
reduced
in
to
n[P
]
j
m[R
]
j
o[Q]
b
y
applying
t
wice
the
out
reduction
on
am
bien
t
m,
and
depicted
in
Figure
19.
The
t
w
o
rules
ma
y
b
e
applied
sim
ultaneously
,
since
the
o
ccurrence
of
the
amb
op
erator,
link
ed
to
the
no
de
with
iden
tier
m,
is
shared.
The
pro
cess
resulting
from
the
colimit
construction
of
Figure
11,
if
represen
ted
as
in
Figure
13,
con
tains
t
w
o
ev
en
ts:
The
rst
one
consumes
the
out
edge
link
ed
with
no
des
1,
2
and
m,
and
the
amb
edge
link
ed
with
no
des
2,
3
and
n;
reads
the
amb
edge
link
ed
with
no
des
3,
4
and
m
(and
all
the
related
no
des);
and
creates
the
amb
edge
link
ed
with
no
des
1
=
2,
4
and
n.
Symmetrically
,
the
other
consumes
the
out
edge
link
ed
with
no
des
5,
6
and
m,
and
the
amb
edge
link
ed
with
no
des
6,
3
and
o;
reads
the
amb
edge
link
ed
with
no
des
3,
4
and
m
(and
all
the
related
no
des);
and
creates
the
amb
edge
link
ed
with
no
des
5
=
6,
4
and
o.
Let
U
b
e
the
pro
cess
m[n[out
m:P
]
j
open
n:R
].
This
is
listed
b
y
Levi
and
Sangiorgi
[22
]
as
an
example
of
gr
ave
interfer
enc
e
,
represen
ting
a
situation
in
the
calculus
that
should
b
e
deprecated,
and
actually
\should
b
e
regarded
as
a
programming
error".
The
execution
of
the
in
ternal
out
reduction
on
the
am
bien
t
m
destro
ys
the
p
ossibilit
y
to
p
erform
the
execution
of
the
external
op
en
reduction
on
the
am
bien
t
n,
and
vice
v
ersa.
This
is
conrmed
b
y
the
analysis
of
the
graph
in
the
middle
of
Figure
20,
obtained
b
y
applying
t
wice
the
broadcasting
rule
to
f
jU
j
g
 .
The
t
w
o
deriv
ations
originating
from
that
graph,
and
sim
ulating
the
execution
of
the
t
w
o
reductions,
are
represen
ted
on
the
righ
t-hand-side
(the
in
ternal
out
)
and
on
the
left-hand-side
(the
external
op
en
).
These
deriv
ations
can
not
b
e
extended
with
additional
steps,
in
order
to
b
ecome
pro
cess
equiv
alen
t.
This
situation
is
usually
describ
ed
b
y
sa
ying
that
the
t
w
o
deriv
ations
denote
a
symmetric
c
onict
of
ev
en
ts.
More
in
terestingly
,
let
us
consider
an
apparen
tly
similar
instance
of
gra
v
e
in
terference,
represen
ted
b
y
the
pro
cess
V
=
m[n[out
m:P
]
j
Q]
j
open
m:R
.
The
external
op
en
reduction
on
am
bien
t
m
destro
ys
the
p
ossibilit
y
to
p
erform
the
in
ternal
out
reduction
on
the
same
am
bien
t,
but
the
vic
e
versa
do
es
not
hold
.
After
the
execution
of
the
in
ternal
out
reduction,
an
external
op
en
ma
y
b
e
p
erformed,
and
the
t
w
o
applications
of
p
open
represen
t
the
same
event
.
Since
the
o
ccurrence
of
the
amb
op
erator
is
only
read
b
y
p
out
of
Figure
15,
the
same
op
erator
is
a
v
ailable
after
the
rewriting
step.
W
e
are
th
us
facing
an
asymmetric
c
onict
,
lifting
the
notion
from
a
recen
t
extension
of
the
ev
en
t
80

Gadducci
and
Mont
anari
g
o
 
g
o
 




j
[P
]
j
/

1
/
out
/
@A
BCO
2

3
5
/
amb
/
 

4




j
[R]
j
A
_ ` s 
√Ü
n
√Ü
m
(
g
o
 
g
o
 
g
o
 




j
[P
]
j
/

1
/
out
/
@A
BCO

2
/
amb
/
#

3
/
amb
/
 

4




j
[R]
j
/_
_
_

5
/
open
/
?
√Ü
n
√Ü
m
)
g
o
 
g
o
 

3
/
amb
/
 

4




j
[R]
j
/

5
/
open
/
>
√Ü
n
√Ü
m




j
[P
]
j
/

1
2
/
amb
N
BC
O
g
o
?
Fig.
20.
Gra
v
e
in
terference
as
symmetric
conict




j
[Q]
j
#F
F
g
o





j
[P
]
j
/

1
/
out
/
@A
BC
O

2
/
amb
/
 

3
/
amb
/
 

4
√Ü
n
√Ü
m




j
[R]
j
/_
_
_

5
/
open
A
B
)




j
[Q]
j
"D
D
g
o
 

3
/
amb
/
 

4




j
[P
]
j
/

1
2
/
amb
;
/
√Ü
n
√Ü
m




j
[R]
j
/

5
/
open
A
B
)




j
[Q]
j
/
=< O ^ _
g
o
 
3

4
5




j
[P
]
j
/

1
2
/
amb
>
/
√Ü
n




j
[R]
j
_
_
_
_
_
_

O
√Ü
m
Fig.
21.
Gra
v
e
in
terference
as
asymmetric
conict
structures
formalism
[2].
The
graph
f
jV
j
g
fm;ng
is
represen
ted
on
the
left-hand
side
of
Figure
21;
the
graphs
obtained
b
y
rst
the
application
of
p
out
,
and
then
of
p
open
,
are
represen
ted
on
the
cen
ter
and
on
the
righ
t-hand
side
of
the
gure.
6
Conclusions
and
F
urther
W
orks
W
e
presen
ted
an
enco
ding
for
nite,
comm
unication-free
pro
cesses
of
the
mo-
bile
am
bien
ts
calculus
in
to
term
graphs,
pro
ving
its
soundness
and
complete-
ness
with
resp
ect
to
the
original,
in
terlea
ving
op
erational
seman
tics.
With
resp
ect
to
most
of
the
other
approac
hes
for
the
graphical
implemen-
tation
of
calculi
with
name
mobilit
y
(see
e.g.
Milner's

-nets
[23],
P
arro
w
's
inter
action
diagr
ams
[26
],
Gardner's
pr
o
c
ess
fr
ameworks
[14],
Hasega
w
a's
shar-
ing
gr
aphs
[16
],
Mon
tanari
and
Pistore's
presen
tation
of

-calculus
b
y
dpo
rules
[25
]
or
K
onig
spider
c
alculus
[21];
an
exception
are
Y
oshida's
c
oncur-
r
ent
c
ombinators
[27
]),
w
e
considered
unstructured
(that
is,
non
hierarc
hical)
graphs,
th
us
a
v
oiding
an
y
\encapsulation"
of
pro
cesses.
The
implication
is
t
w
ofold.
First
of
all,
it
allo
ws
the
reuse
of
standard
graph
rewriting
theory
and
to
ols
for
sim
ulating
the
reduction
seman
tics,
suc
h
as
e.g.
the
dpo
formal-
ism
and
the
hops
programming
system
[20].
More
imp
ortan
tly
,
it
allo
ws
for
the
sim
ultaneous
execution
of
indep
enden
t
reductions,
whic
h
are
nested
inside
am
bien
ts,
and
p
ossibly
share
some
resource.
While
this
feature
is
less
relev
an
t
for
e.g.
the

-calculus,
where
eac
h
pro
cess
can
b
e
considered
just
a
soup
of
disjoin
t
sequen
tial
agen
ts
(m
uc
h
in
the
spirit
of
Berry's
and
Boudol's
cham
approac
h
[4]),
it
is
relev
an
t
in
the
presen
t
con
text,
where
am
bien
ts
are
nested,
and
y
et
can
b
e
\p
ermeated"
b
y
a
reduction.
A
rst,
rough
analysis
is
p
er-
81

Gadducci
and
Mont
anari
e
/

/
m in
/

e
o
x
/
√Ü
=
m out
 
/

e
o
√Ü
n
o
Fig.
22.
T
erm
graphs
for
input
(x)
and
async
hronous
output
hni
actions.
formed
in
Section
5.3,
and
w
e
plan
to
extend
our
preliminary
considerations
to
a
non-deterministic
concurren
t
seman
tics
for
mobile
am
bien
ts,
m
uc
h
in
the
spirit
of
the
ev
en
t
structure
seman
tics
dev
elop
ed
in
[1].
Our
enco
ding
can
b
e
extended
to
reco
v
er
the
comm
unication
primitiv
es,
as
long
as
w
e
restrict
comm
unication
to
name
passing:
The
graphs
for
enco
ding
input
and
async
hronous
output
actions
are
depicted
in
Figure
22.
In
fact,
w
e
feel
conden
t
that
an
y
calculus
with
name
mobilit
y
ma
y
nd
a
presen
tation
within
our
formalism,
along
the
line
of
the
enco
ding
for
mobile
am
bien
ts.
The
calculus
should
of
course
con
tain
a
parallel
op
erator
whic
h
is
asso
ciativ
e,
com-
m
utativ
e
and
with
an
iden
tit
y;
moreo
v
er,
its
op
erational
seman
tics
should
b
e
reduction-lik
e
(i.e.,
expressed
b
y
unlab
elled
transitions),
and
the
rules
should
nev
er
substitute
a
free
name
for
another,
so
that
name
substitution
can
b
e
handled
b
y
no
de
coalescing
(with
a
mec
hanism
reminiscen
t
of
name
fusion
).
It
should
b
e
noted
that
an
y
monoidal
category
with
a
suitable
enric
hmen
t
(namely
,
where
eac
h
ob
ject
a
is
equipp
ed
with
t
w
o
monoidal
transformations
a
!
a

a
and
1
!
a,
making
it
a
monoid
)
could
b
e
used
as
a
sound
mo
del
for
the
enco
ding.
The
relev
an
t
thing
is
that,
among
this
class
of
mo
dels,
(a
suitable
sub-category
of
)
the
category
R
G
;S
of
graphs
as
ob
jects,
and
rank
ed
graphs
as
morphisms,
is
the
initial
one
[5,7],
so
that
Prop
osition
4.3
is
just
a
corollary
of
this
general
result.
Our
w
ork
is
th
us
tigh
tly
link
ed
with
ongo-
ing
researc
h
on
the
graphical
presen
tations
for
categorical
formalisms,
as
e.g.
on
pr
emonoidal
[17]
and
tr
ac
e
d
monoidal
[19
]
categories.
More
imp
ortan
tly
,
also
graph
pro
cesses
ma
y
b
e
equipp
ed
with
an
algebraic
structure
[8,12],
th
us
pro
viding
a
formalism
for
denoting
also
reductions
in
mobile
am
bien
ts.
As
for
the
niteness
conditions,
it
is
a
dieren
t
matter.
In
fact,
it
is
a
di√Ü-
cult
task
to
reco
v
er
the
b
eha
viour
of
pro
cesses
including
a
r
eplic
ation
op
erator,
since
replication
is
a
global
op
eration,
in
v
olving
the
duplication
of
necessarily
unsp
ecied
sub-pro
cesses,
and
it
is
hence
hard
to
mo
del
via
graph
rewriting,
whic
h
is
an
eminen
tly
lo
cal
pro
cess.
Nev
ertheless,
our
framew
ork
allo
ws
for
the
mo
deling
of
r
e
cursive
pro
cesses,
that
is,
dened
using
constan
t
in
v
o
cation,
so
that
a
pro
cess
is
a
family
of
judgmen
ts
of
the
kind
A
=
P
.
Th
us,
eac
h
pro-
cess
is
compiled
in
to
a
dieren
t
graph
transformation
system,
adding
to
the
four
basic
rewriting
rules
a
new
pro
duction
p
A
for
eac
h
constan
t
A,
in
tuitiv
ely
sim
ulating
the
unfolding
step
f
jAj
g
 )
f
jP
j
g
 ,
for
a
suitable
 .
References
[1]
P
.
Baldan,
A.
Corradini,
H.
Ehrig,
M.
L
ow
e,
U.
Mon
tanari,
and
F.
Rossi.
Concurren
t
seman
tics
of
algebraic
graph
transformation.
In
H.
Ehrig,
H.-
82

Gadducci
and
Mont
anari
J.
Kreo
wski,
U.
Mon
tanari,
and
G.
Rozen
b
erg,
editors,
Handb
o
ok
of
Gr
aph
Gr
ammars
and
Computing
by
Gr
aph
T
r
ansformation,
v
olume
3,
pages
107{187.
W
orld
Scien
tic,
1999.
[2]
P
.
Baldan,
A.
Corradini,
and
U.
Mon
tanari.
An
ev
en
t
structure
seman
tics
for
P/T
con
textual
nets:
Asymmetric
ev
en
t
structures.
In
M.
Niv
at,
editor,
F
oundations
of
Softwar
e
Scienc
e
and
Computation
Structur
es,
Lect.
Notes
in
Comp.
Science,
pages
63{80.
Springer
V
erlag,
1998.
Revised
v
ersion
to
app
ear
in
Information
and
Computation
.
[3]
H.P
.
Barendregt,
M.C.J.D.
v
an
Eek
elen,
J.R.W.
Glauert,
J.R.
Kenna
w
a
y
,
M.J.
Plasmeijer,
and
M.R.
Sleep.
T
erm
graph
reduction.
In
J.W.
de
Bakk
er,
A.J.
Nijman,
and
P
.C.
T
relea
v
en,
editors,
Par
al
lel
A
r
chite
ctur
es
and
L
anguages
Eur
op
e,
v
olume
259
of
L
e
ct.
Notes
in
Comp.
Scienc
e,
pages
141{158.
Springer
V
erlag,
1987.
[4]
G.
Berry
and
G.
Boudol.
The
c
hemical
abstract
mac
hine.
The
or
et.
Comput.
Sci.,
96:217{248,
1992.
[5]
R.
Bruni,
F.
Gadducci,
and
U.
Mon
tanari.
Normal
forms
for
algebras
of
connections.
The
or
et.
Comput.
Sci.,
2001.
T
o
app
ear.
Av
ailable
at
http:
//www.di.unipi.it/~ugo/t
iles
.ht
ml.
[6]
L.
Cardelli
and
A.
Gordon.
Mobile
am
bien
ts.
In
M.
Niv
at,
editor,
F
oundations
of
Softwar
e
Scienc
e
and
Computation
Structur
es,
v
olume
1378
of
L
e
ct.
Notes
in
Comp.
Scienc
e,
pages
140{155.
Springer
V
erlag,
1998.
[7]
A.
Corradini
and
F.
Gadducci.
An
algebraic
presen
tation
of
term
graphs,
via
gs-monoidal
categories.
Applie
d
Cate
goric
al
Structur
es,
7:299{331,
1999.
[8]
A.
Corradini
and
F.
Gadducci.
Rewriting
on
cyclic
structures:
Equiv
alence
b
et
w
een
the
op
erational
and
the
categorical
description.
Informatique
Th

eorique
et
Applic
ations/The
or
etic
al
Informatics
and
Applic
ations,
33:467{
493,
1999.
[9]
A.
Corradini,
U.
Mon
tanari,
F.
Rossi,
H.
Ehrig,
R.
Hec
k
el,
and
M.
L
ow
e.
Algebraic
approac
hes
to
graph
transformation
I:
Basic
concepts
and
double
pushout
approac
h.
In
G.
Rozen
b
erg,
editor,
Handb
o
ok
of
Gr
aph
Gr
ammars
and
Computing
by
Gr
aph
T
r
ansformation,
v
olume
1.
W
orld
Scien
tic,
1997.
[10]
F.
Drew
es,
A.
Hab
el,
and
H.-J.
Kreo
wski.
Hyp
eredge
replacemen
t
graph
grammars.
In
G.
Rozen
b
erg,
editor,
Handb
o
ok
of
Gr
aph
Gr
ammars
and
Computing
by
Gr
aph
T
r
ansformation,
v
olume
1.
W
orld
Scien
tic,
1997.
[11]
G.
F
errari
and
U.
Mon
tanari.
T
o
w
ards
the
unication
of
mo
dels
for
concurrency
.
In
A.
Arnold,
editor,
T
r
e
es
in
A
lgebr
a
and
Pr
o
gr
amming,
v
olume
431
of
L
e
ct.
Notes
in
Comp.
Scienc
e,
pages
162{176.
Springer
V
erlag,
1990.
[12]
F.
Gadducci,
R.
Hec
k
el,
and
M.
Llabr

es.
A
bi-categorical
axiomatisation
of
concurren
t
graph
rewriting.
In
M.
Hofmann,
D.
P
a
vlo
vi

c,
and
G.
Rosolini,
editors,
Cate
gory
The
ory
and
Computer
Scienc
e,
v
olume
29
of
Ele
ctr
onic
Notes
in
The
or
etic
al
Computer
Scienc
e.
Elsevier
Sciences,
1999.
Av
ailable
at
http:
//www.elsevier.nl/locate
/ent
cs/
volu
me29
.ht
ml/.
83

Gadducci
and
Mont
anari
[13]
F.
Gadducci
and
U.
Mon
tanari.
Comparing
logics
for
rewriting:
Rewriting
logic,
action
calculi
and
tile
logic.
The
or
et.
Comput.
Sci.,
2001.
T
o
app
ear.
Av
ailable
at
http://www.di.unipi.it/~
ugo/
tile
s.h
tml.
[14]
Ph.
Gardner.
F
rom
pro
cess
calculi
to
pro
cess
framew
orks.
In
C.
P
alamidessi,
editor,
Concurr
ency
The
ory,
v
olume
1877
of
L
e
ct.
Notes
in
Comp.
Scienc
e,
pages
69{88.
Springer
V
erlag,
2000.
[15]
U.
Golz
and
W.
Reisig.
The
non-sequen
tial
b
eha
viour
of
Petri
nets.
Information
and
Contr
ol,
57:125{147,
1983.
[16]
M.
Hasega
w
a.
Mo
dels
of
Sharing
Gr
aphs.
PhD
thesis,
Univ
ersit
y
of
Edin
burgh,
Departmen
t
of
Computer
Science,
1997.
[17]
A.
Jerey
.
Premonoidal
categories
and
a
graphical
view
of
programs.
T
ec
hnical
rep
ort,
Sc
ho
ol
of
Cognitiv
e
and
Computing
Sciences,
Univ
ersit
y
of
Sussex,
1997.
Av
ailable
at
http://www.cogs.susx.ac.
uk/u
sers
/al
anje
/pre
mon
/.
[18]
A.
Jo
y
al,
M.
Nielsen,
and
G.
Winsk
el.
Bisim
ulation
from
op
en
maps.
Information
and
Computation,
127:164{185,
1996.
[19]
A.
Jo
y
al,
R.H.
Street,
and
D.
V
erit
y
.
T
raced
monoidal
categories.
Mathematic
al
Pr
o
c
e
e
dings
of
the
Cambridge
Philosophic
al
So
ciety,
119:425{446,
1996.
[20]
W.
Kahl.
The
term
graph
programming
system
HOPS.
In
R.
Berghammer
and
Y.
Lakhnec
h,
editors,
T
o
ol
Supp
ort
for
System
Sp
e
cic
ation,
Development
and
V
eric
ation,
Adv
ances
in
Computing
Science,
pages
136{149.
Springer
V
erlag,
1999.
Av
ailable
at
http://ist.unibw-
muenchen.
de/k
ahl/
HOP
S/.
[21]
B.
K
onig.
Description
and
V
eric
ation
of
Mobile
Pr
o
c
esses
with
Gr
aph
R
ewriting
T
e
chniques.
PhD
thesis,
T
ec
hnisc
he
Univ
ersit
at
M

unc
hen,
1999.
[22]
F.
Levi
and
D.
Sangiorgi.
Con
trolling
in
terference
in
am
bien
ts.
In
T.
Reps,
editor,
Principles
of
Pr
o
gr
amming
L
anguages,
pages
352{364.
A
CM
Press,
2000.
[23]
R.
Milner.
Pi-nets:
A
graphical
formalism.
In
D.
Sannella,
editor,
Eur
op
e
an
Symp
osium
on
Pr
o
gr
amming,
v
olume
788
of
L
e
ct.
Notes
in
Comp.
Scienc
e,
pages
26{42.
Springer
V
erlag,
1995.
[24]
R.
Milner,
J.
P
arro
w,
and
D.
W
alk
er.
A
calculus
of
mobile
pro
cesses.
Part
I
and
I
I.
Information
and
Computation,
100:1{77,
1992.
[25]
U.
Mon
tanari
and
M.
Pistore.
Concurren
t
seman
tics
for
the

-calculus.
In
S.
Bro
ok
es,
M.
Main,
A.
Melton,
and
M.
Mislo
v
e,
editors,
Mathematic
al
F
oundations
of
Pr
o
gr
amming
Semantics,
v
olume
1
of
Ele
ctr
onic
Notes
in
Computer
Scienc
e.
Elsevier,
1995.
[26]
J.
P
arro
w.
In
teraction
diagrams.
Nor
dic
Journal
of
Computing,
2:407{443,
1995.
[27]
N.
Y
oshida.
Graph
notation
for
concurren
t
com
binators.
In
T.
Ito
and
A.
Y
oneza
w
a,
editors,
The
ory
and
Pr
actic
e
of
Par
al
lel
Pr
o
gr
amming,
v
olume
907
of
L
e
ct.
Notes
in
Comp.
Scienc
e,
pages
393{412.
Springer
V
erlag,
1994.
84

MFPS
17
Preliminary
Version
Regular-Language
Seman
tics
for
a
Call-b
y-V
alue
Programming
Language
Dan
R.
Ghica
1;2
Dep
artment
of
Computing
and
Information
Scienc
e,
Que
en
's
University,
Kingston,
Ontario,
Canada
K7L
3N6
Abstract
W
e
explain
ho
w
game
seman
tics
can
b
e
used
to
reason
ab
out
term
equiv
alence
in
a
nitary
imp
erativ
e
rst
order
language
with
arra
ys.
F
or
this
language,
the
game-
seman
tic
in
terpretation
of
t
yp
es
and
terms
is
fully
c
haracterized
b
y
their
sets
of
complete
pla
ys.
Because
these
sets
are
regular
o
v
er
the
alphab
et
of
mo
v
es,
they
are
represen
table
b
y
(extended)
regular
expressions.
The
formal
apparatus
of
game
seman
tics
is
greatly
simplied
but
the
go
o
d
theoretical
prop
erties
of
the
mo
del
are
preserv
ed.
The
principal
adv
an
tage
of
this
approac
h
is
that
it
is
mathematically
elemen
tary
,
while
fully
formalized.
Since
language
equiv
alence
for
regular
languages
is
decidable,
this
metho
d
of
pro
ving
term
equiv
alence
is
suitable
for
automation.
1
In
tro
duction
In
the
last
decade
the
use
of
game
seman
tics
in
the
analysis
of
programming
languages
has
yielded
n
umerous
remark
able
theoretical
results.
Most
imp
or-
tan
tly
,
this
inno
v
ativ
e
approac
h
led
to
fully
abstract
mo
dels
for
languages
that
ha
v
e
b
een
under
seman
tic
scrutin
y
for
decades,
suc
h
as
PCF
[10
,2]
and
idealized
Algol
[4,6].
The
theoretical
success
of
game
seman
tics
is
w
ell
com-
plemen
ted
b
y
an
elegan
tly
articulated
and
in
tuitiv
e
conceptual
asso
ciation
b
et
w
een
k
ey
language
features
(suc
h
as
m
utable
state
or
con
trol)
and
neat
com
binatorial
constrain
ts
on
strategies
(suc
h
as
inno
c
enc
e
or
br
acketing
)[3
].
There
is,
ho
w
ev
er,
a
frustrating
asp
ect
of
game
seman
tics.
While
the
mo
d-
els
prop
osed
are
fully
abstract,
whic
h
means
that
in
principle
they
correctly
v
alidate
all
program
equiv
alences
and
inequiv
alences,
they
are
at
the
same
time
so
in
tricate
that
applying
them
to
that
end
is
often
a
Gordian
task.
What
is
needed
is
an
adequate
notation
that
w
ould
allo
w
a
c
alculus
of
games,
1
This
author
ac
kno
wledges
the
supp
ort
of
a
NSER
C
PGSB
gran
t.
2
Email:
ghica@cs.queensu
.c
a
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Ghica
to
mak
e
pro
ofs
less
prolix
and
more
formal.
While
a
wieldy
and
accessible
calculus
that
captures
the
full
p
o
w
er
of
games
ma
y
b
e
unattainable,
calculi
for
restricted
y
et
non-trivial
subsets
of
game-based
mo
dels
are
v
ery
handy
.
They
illustrate
the
game
seman
tics
in
an
applied
setting,
making
the
sub
ject
more
accessible
to
those
who
nd
its
abstractness
daun
ting.
But,
more
imp
or-
tan
tly
,
suc
h
calculi
can
actually
serv
e
as
a
foundation
for
a
new
and
practical
approac
h
to
program
analysis,
predicated
on
solid
theoretical
results.
A
simi-
lar
a
v
en
ue
of
researc
h,
but
as
applied
to
static
analysis,
is
explored
b
y
Hankin
and
Malacaria
[8,9
].
In
a
previous
pap
er
[7
]
w
e
sho
w
ed
ho
w
a
greatly
simplied
games
mo
del
of
idealized
Algol
can
b
e
used
to
giv
e
elemen
tary
pro
ofs
to
seman
tically
relev
an
t
putativ
e
equiv
alences
that
ha
v
e
b
een
an
imp
ortan
t
part
of
the
study
of
the
language
[12].
This
pap
er
follo
ws
a
similar
approac
h,
but
fo
cuses
on
a
dieren
t
language,
an
imp
erativ
e
call-b
y-v
alue
rst
order
language
with
arra
ys.
This
language
is
imp
ortan
t
from
a
practical
p
oin
t
of
view;
it
is
the
idiom
in
whic
h
man
y
common
programs,
for
example
for
searc
hing
or
sorting,
are
written.
F
or
this
language
w
e
presen
t
what
w
e
b
eliev
e
to
b
e
a
practicable
seman
tic
cal-
culus
whic
h
can
b
e
used
for
v
alidating
term
(subprogram)
equiv
alences.
Since
equiv
alen
t
subprograms
can
b
e
replaced
in
an
y
con
text,
without
restrictions,
the
tec
hnique
presen
ted
here
can
b
e
applied
to
b
oth
program
dev
elopmen
t
through
renemen
t
and
to
program
main
tenance.
W
e
are
optimistic
ab
out
the
practical
application
of
suc
h
a
tec
hnique
b
ecause
it
is
mathematically
ele-
men
tary
and
calculational,
b
oth
features
considered
essen
tial
requiremen
ts
for
a
\p
opular
seman
tics"
[15].
Moreo
v
er,
this
calculus
is
fully
formal.
Because
it
is
based
on
regular
expressions,
language
equiv
alence
is
decidable,
whic
h
mak
es
it
suitable
for
automation.
2
F
oil:
a
rst
order
imp
erativ
e
language
In
this
pap
er
w
e
are
concerned
with
a
simple,
protot
ypical,
programming
language
that
can
b
e
found
at
the
core
of
most
of
to
da
y's
imp
erativ
e
lan-
guages.
It
com
bines
the
features
of
the
simple
imp
erativ
e
language
(m
utable
lo
cal
v
ariables,
con
trol
structures)
with
a
recursion-free
rst-order
pro
cedure
mec
hanism
based
on
the
simply
t
yp
ed
call-b
y-v
alue
lam
b
da
calculus,
and
an
elemen
tary
data
structure
facilit
y
(arra
ys).
The
data
sets
of
F
oil
are
nite,
as
is
the
case
with
realistic
programming
languages.
The
decision
to
set
aside
higher
order
pro
cedures
and
recursion
is
dictated
b
y
the
need
to
conne
the
formalism
to
regular
expressions
only;
they
are
not
expressiv
e
enough
to
rep-
resen
t
these
more
p
o
w
erful
features.
Another
restriction
is
to
allo
w
only
un-
curried
functions,
but
this
is
only
for
the
sak
e
of
simplicit
y
of
presen
tation.
Curried
functions
can
b
e
readily
added
and
explicated
within
the
b
ounds
of
the
same
formalism.
F
oil
has
three
kinds
of
t
yp
es:
return
t
yp
es,
argumen
t
t
yp
es
and
function
t
yp
es.
The
return
t
yp
es
are
the
most
elemen
tary
,
and
can
b
e
returned
b
y
86

Ghica
functions.
They
are
the
\v
alues"
of
the
language:
b
o
oleans,
naturals
and
a
t
yp
e
of
commands,
v
oid,
similar
to
that
in
C
or
Ja
v
a.

::=
b
o
ol
j
nat
j
v
oid:
The
argumen
t
t
yp
es
include
the
return
t
yp
es
plus
all
the
other
t
yp
es
that
can
b
e
passed
as
argumen
ts
to
functions,
whic
h
are
v
ariables,
arra
ys
and
tuples:

::=

j
v
ar
j
arra
y
[n]
j



;
n
2
N
:
The
t
yp
es
ab
o
v
e
and
function
t
yp
es,
from
argumen
t
to
return
t
yp
es,
form
the
t
yp
e
system
of
the
language:

::=

j

!

:
The
terms
of
the
language
are
asso
ciated
with
t
yping
judgmen
ts
of
the
form:

1
:

1
;

2
:

2
;
:
:
:
;

k
:

k
`
M
:

;
where

i
are
free
v
ariables.
The
terms
of
the
language
are
constan
ts,
op
erators,
free
v
ariables,
con
trol
structures,
command
comp
osition,
v
ariable
declaration,
arra
y
declaration,
ar-
ra
y
elemen
t
selection,
assignmen
t,
dereferencing
and
function
declaration
and
application
(Figure
1).
3
Game
seman
tics
of
F
oil
The
reader
is
not
exp
ected
to
b
e
familiar
with
game
seman
tics
in
order
to
understand
this
article.
Also,
it
is
not
p
ossible
to
condense
suc
h
a
ric
h
topic
in
a
few
pages,
but
go
o
d
and
comprehensiv
e
in
tro
ductory
material
is
a
v
ailable
[3
].
The
sp
ecic
games
mo
del
used
to
in
terpret
F
oil
and
on
whic
h
w
e
base
the
presen
t
regular
language
mo
del
is
the
one
dev
elop
ed
b
y
Abramsky
and
McCusk
er
[5,1].
In
this
section
w
e
will
only
in
tro
duce
some
of
the
k
ey
in
tuitiv
e
concepts
of
game
seman
tics,
esp
ecially
as
applied
to
call-b
y-v
alue
games.
The
concept
of
game
emplo
y
ed
b
y
game
seman
tics
is
a
broad
one:
\an
activit
y
conducted
according
to
prescrib
ed
rules."
Computation
is
represen
ted
as
a
dialogical
game
b
et
w
een
t
w
o
protagonists:
Player
(P)
represen
ts
the
program
and
Opp
onent
(O)
represen
ts
the
en
vironmen
t,
or
the
con
text,
in
whic
h
the
program
is
run.
The
in
teraction
b
et
w
een
O
and
P
consists
of
a
sequence
of
mo
v
es,
go
v
erned
b
y
rules.
F
or
example,
O
and
P
need
to
tak
e
turns
and
ev
ery
mo
v
e
needs
to
b
e
justie
d
b
y
a
preceding
mo
v
e.
The
mo
v
es
are
of
t
w
o
kinds,
questions
and
answers
;
one
of
the
rules
constraining
the
in
terpla
y
is
that
ev
ery
answ
er
m
ust
corresp
ond
to
the
last
unansw
ered
question
(br
acketing
).
T
o
ev
ery
t
yp
e
in
the
language
corresp
onds
a
game
;
that
is,
the
set
of
all
p
ossible
sequences
of
mo
v
es,
together
with
the
w
a
y
in
whic
h
they
are
87

Ghica
n
:
nat
true
:
b
o
ol
false
:
b
o
ol
skip
:
v
oid
div
erge
:

M
:
nat
N
:
nat
M
+
N
:
nat
M
:
nat
N
:
nat
M
=
N
:
b
o
ol
M
:
b
o
ol
N
:
b
o
ol
M
and
N
:
b
o
ol
M
:
b
o
ol
N
:
v
oid
P
:
v
oid
if
M
then
N
else
P
:
v
oid
M
:
b
o
ol
N
:
v
oid
while
M
do
N
:
v
oid
M
:
v
oid
N
:

M
;
N
:

M
:
v
ar
N
:
nat
M
:=
N
:
v
oid
M
:
v
ar
!M
:
nat
[
1
:

1
]



[
k
:

k
]
.
.
.
.
M
:


1
:
:
:

k
:

1
:
:
:

k
:M
:

1






k
!

M
1
:

1



M
k
:

k
(M
1
;
:
:
:
;
M
k
)
:

1






k
[
:
v
ar]
.
.
.
.
M
:
v
oid
new

in
M
:
v
oid


:
arra
y
[n]

.
.
.
.
M
:
v
oid
new
[
n]
in
M
:
v
oid
F
:

!

M
:

F
M
:


:
arra
y
[n]
N
:
nat
[N
]
:
v
ar
Fig.
1.
T
erms
and
t
yping
judgmen
ts
justied
within
the
sequence.
A
program
is
represen
ted
as
a
set
of
sequences
of
mo
v
es
in
the
appropriate
game,
more
precisely
as
a
str
ate
gy
for
that
game:
a
predetermined
w
a
y
for
P
to
resp
ond
to
O's
mo
v
es.
The
seman
tic
mo
dels
whic
h
pro
vide
full
abstraction
for
call-b
y-name
languages
are
dev
elop
ed
within
this
general
games
framew
ork.
In
an
inuen
tial
pap
er,
Moggi
sho
w
ed
that
call-b
y-v
alue
languages
are
in-
terpreted
in
a
Cartesian
Closed
Category
(CCC)
with
copro
ducts
and
a
str
ong
monad
[13].
If
a
CCC
has
innite
co-pro
ducts
then
its
free
completion
under
co-pro
duct
pro
duces
the
required
monadic
structure.
The
games
framew
ork
forms
indeed
a
CCC,
with
games
as
ob
jects
and
strategies
as
morphisms,
and
McCusk
er
sho
w
ed
ho
w
co-pro
duct
games
can
b
e
added
[11].
These
t
w
o
ideas
are
incorp
orated
in
[5]
to
create
a
category
of
games
suitable
for
in
ter-
preting
call-b
y-v
alue
languages.
Arriving
at
the
concrete
call-b
y-v
alue
games
presen
ted
here
is
only
a
matter
of
carrying
out
in
enough
detail
the
categorical
construction.
The
resulting
games
are,
ho
w
ev
er,
in
teresting
in
their
o
wn
righ
t
b
ecause
they
oer
some
basic
insigh
t
in
to
call-b
y-v
alue
computation.
A
t
yp
e
is
not
88

Ghica
represen
ted
b
y
a
game,
but
b
y
a
family
of
games.
A
strategy
in
terpreting
a
term
has
t
w
o
distinct
stages,
a
pr
oto
c
ol
stage
in
whic
h
one
of
the
mem
b
ers
of
the
family
is
selected,
follo
w
ed
b
y
a
pla
y
in
the
selected
game.
In
tuitiv
ely
,
this
mirrors
the
fact
that,
in
call-b
y-v
alue,
all
argumen
ts
are
ev
aluated
exactly
once
b
efore
the
b
o
dy
of
the
function
is
ev
aluated.
Accordingly
,
free
iden
tiers
can
ha
v
e
only
one
v
alue
throughout
the
ev
aluation
of
a
term.
In
con
trast,
call-
b
y-name
allo
ws
iden
tiers
to
corresp
ond
to
dieren
t
v
alues
at
v
arious
p
oin
ts
in
the
ev
aluation.
This
p
oin
t
is
illustrated
b
y
the
follo
wing
example:
f
:
nat
!
nat
;
x
:
nat
`
f(x)
:
nat.
F
or
call-b
y-name
a
t
ypical
pla
y
is:
f
:
nat
!
nat
x
:
nat
`
f(x)
:
nat
q
q
q
q
n
n
q
q
n
0
n
0
m
m
O
asks
for
the
v
alue
of
f(x);
P
asks
for
the
v
alue
returned
b
y
f
;
O
asks
for
the
argumen
t
of
f
;
P
asks
for
the
v
alue
of
x;
O
answ
ers
n;
P
rela
ys
that
answ
er
bac
k
to
O;
O
asks
again
for
the
argumen
t
of
f
and
the
same
cycle
rep
eats;
O
answ
ers
with
m
to
the
v
alue
returned
b
y
f
;
P
rela
ys
that
answ
er
bac
k
to
O,
answ
ering
the
initial
question.
Notice
that
in
the
course
of
the
pla
y
the
v
alue
of
x
can
b
e
requested
sev
eral
times,
and
since
the
answ
er
is
giv
en
b
y
O
it
ma
y
c
hange.
No
w
let
us
lo
ok
at
the
same
term
ev
aluated
under
call-b
y-v
alue:
f
:
nat
!
nat
x
:
nat
`
f(x)
:
nat
?
?
n
?(n)
?(n)
m
m
The
mo
v
es
under
the
`
sym
b
ol
are
not
part
of
the
pla
y
,
but
they
are
some
of
the
concealed
activities
that
are
part
of
the
proto
col.
The
pla
y
is:
O
asks
for
the
v
alue
of
f(x);
as
a
result
of
the
proto
col,
P
asks
for
the
v
alue
of
f
in
c
omp
onent
n;
O
answ
ers
m;
P
rela
ys
the
answ
er
bac
k,
answ
ering
the
initial
question.
Only
part
of
the
proto
col
is
sho
wn:
P
asks
in
what
comp
onen
t
should
89

Ghica
the
pla
y
pro
ceed;
O
answ
ers
with
a
comp
onen
t
index
n
for
x;
P
requests
that
the
game
should
con
tin
ue
in
comp
onen
t
n.
In
[5]
it
w
as
sho
wn
that
this
games
framew
ork
giv
es
a
fully
abstract
mo
del
for
call-b
y-v
alue.
Moreo
v
er,
b
y
relaxing
one
of
the
constrain
ts
on
strategies
(inno
c
enc
e
)
the
same
article
sho
ws
ho
w
a
fully
abstract
mo
del
for
an
imp
er-
ativ
e
language
with
ML-st
yle
data
references
can
b
e
dened,
using
a
go
o
d-
variable
non-inno
cen
t
strategy
to
mo
del
m
utable
store.
These
ideas
are
fur-
ther
expanded
in
[1]
to
sho
w
that
dropping
another
constrain
t
on
strategies
(visibility
)
giv
es
rise
to
a
fully
abstract
mo
del
for
general
references
(references
to
data,
pro
cedures,
higher
order
functions,
other
references).
4
Regular
language
seman
tics
of
t
yp
es
A
game
for
a
t
yp
e,
or
a
strategy
for
a
term,
is
fully
c
haracterized
b
y
its
set
of
pla
ys
together
with
the
w
a
y
mo
v
es
are
justied.
But
if
the
language
is
su√Ücien
tly
restricted
then
there
is
only
one
w
a
y
in
whic
h
mo
v
es
can
b
e
justied
within
a
pla
y
sequence|F
oil
is
suc
h
a
restricted
language.
This
means
that
suc
h
languages
can
b
e
fully
c
haracterized
b
y
pla
ys
tak
en
to
b
e
sequences
of
mo
v
es
only
.
Moreo
v
er,
the
sequences
of
mo
v
es
are
regular
sets,
so
they
can
b
e
denoted
b
y
(extended)
regular
expressions.
This
is
an
approac
h
w
e
to
ok
b
efore,
in
dealing
with
Algol
[7].
F
or
the
restricted
language,
extended
regular
expressions
giv
e
a
con
v
enien
t,
compact,
fully
formal
calculus,
quite
handy
in
dening
the
seman
tics
of
actual
programs.
The
regular-language
seman
tics
arises
out
of
the
mo
del
in
[5],
b
y
w
orking
out
the
details
of
the
categorical
construction.
Denition
4.1
The
set
R
A
of
extende
d
r
e
gular
expr
essions
R
over
a
nite
alphab
et
A
is
dene
d
as:
R
::=
;
j

j
a;
a
2
A
Constants
;
R
::=
R

R
j
R
+
R
j
R
\
R
Op
er
ators
;
R
::=
R

Iter
ation;
R
::=
R
j
A
0
;
A
0

A
Hiding;
R
::=
R
hv
i
Indexing
:
Most
of
the
ab
o
v
e
are
standard
regular
expression
constructs,
to
whic
h
w
e
add
in
tersection
and
t
w
o
new
op
erations,
hiding
and
indexing.
The
latter
are
op
erations
on
regular
languages
that
can
b
e
carried
out
directly
at
the
lev
el
of
regular
expressions.
Hiding
represen
ts
a
restriction
of
a
regular
expression
to
a
subset
of
its
alphab
et
b
y
remo
ving
all
the
o
ccurrences
of
sym
b
ols
in
the
restricted
alphab
et;
its
language
is
the
set
of
sequences
of
the
original
languages
with
all
the
elemen
ts
of
A
0
deleted.
Indexing
is
dened
as
the
tagging
of
the
rst
sym
b
ol
a
of
an
y
sequence
in
the
language
with
the
string
90

Ghica
J
K
=
 P
c2C

P
c



P
k
2K

R

(k
)

;
where:
J
K
:
P
v

=
?

v
;
R

=
;
K

=
f?g;
C
v
oid
=
f?g
C
nat
=
f0;
1;
:
:
:
;
n
N
g
=
N
;
C
b
o
ol
=
ftt
;

g
J
1


2
K
:
P
c

1

2
=
?

c;
C

1

2
=
C

1

C

2
R

1

2
(k
)
=
(
R

1
(k
)
if
k
2
K

1
R

2
(k
)
if
k
2
K

2
;
K

1

2
=
K

1
]
K

2
Jv
arK
:
P
v
ar
=
?

?;
C
v
ar
=
f?
g;
K
v
ar
=
N
[
f?
g
R
v
ar
=
P
m2N
r
e
ad

m
+
P
m2N
write
(m)?
q
arra
y
[n]
y
:
P
arra
y
[n]
=
?

?;
C
arra
y
[n]
=
f?
g
K
arra
y
[n]
=
fiji
<
ng
[
fiji
<
ng

N
R
arra
y
[n]
=
P
m2N
i<n
r
e
ad
(i)
m
+
P
m2N
i<n
write
(i;
m)?
J
!

K
:
P

!
=
?

?
;
C

!
=
f?g
R

!
=
P
c2K

!
 q
(c)

P
d2C

R

hci

d


;
K

!
=
C

Fig.
2.
Seman
tics
of
F
oil
t
yp
es
v
,
resulting
in
a(uv
),
where
u
is
the
pre-existing
tag
of
R
,
p
ossibly
empt
y
().
A
regular-language
represen
tation
of
the
game
seman
tics
of
F
oil
is
dened
as
follo
ws.
With
t
yp
es
w
e
asso
ciate
games,
represen
ted
as
regular
languages
o
v
er
an
alphab
et
denoting
the
mo
v
es.
With
terms
w
e
asso
ciate
strategies,
represen
ted
as
regular
languages
o
v
er
the
disjoin
t
sum
of
the
alphab
ets
of
the
t
yp
es
of
the
free
iden
tiers
and
the
term
itself.
As
men
tioned
in
the
previous
sections,
a
call-b
y-v
alue
game
for
a
t
yp
e

has
t
w
o
stages:
a
proto
col-game
P
c

follo
w
ed
b
y
a
comp
onen
t-game
R

=
P
k
2K

R

(k
).
The
proto
col
part
of
the
pla
y
corresp
onds
to
the
co-pro
duct
structure
whic
h
forms
the
monad,
t
ying
together
the
v
arious
comp
onen
ts.
A
pla
y
in
the
proto
col
game
alw
a
ys
has
the
form
?

c
for
c
2
C

.
W
e
call
C

the
set
of
c
omp
onent-sele
cting
moves.
The
rst
mo
v
e
in
a
pla
y
in
the
comp
onen
t
game
R

has
the
form
m(k
),
where
k
2
K

.
W
e
call
K

the
set
of
c
omp
onent-dening
moves
;
ev
ery
suc
h
comp
onen
t
is
represen
ted
b
y
the
regular
language
R

(k
).
Notice
that
C

and
K

are
distinct
sets.
If
sets
C
or
K
only
ha
v
e
one
elemen
t
(?),
w
e
will
often
omit
it
as
an
index.
The
regular
language
seman
tics
of
F
oil
t
yp
es
is
the
one
giv
en
in
Figure
2.
F
or
v
oid,
nat
and
b
o
ol
the
denition
is
straigh
tforw
ard.
V
ariables
v
ar
are
the
pro
duct
of
an
acceptor
and
an
expression
t
yp
e,
not
reied
in
the
actual
language.
Arra
ys
of
size
n
are
iden
tied
with
pro
ducts
of
n
v
ariables.
Pro
ving
91

Ghica
these
regular
expressions
correctly
represen
t
games
is
tedious,
but
routine.
In
the
case
of
pro
duct
and
function
t
yp
es
it
is
required
that
the
alphab
ets
(sets
of
mo
v
es)
of
the
t
yp
es
in
v
olv
ed
are
disjoin
t.
This
is
ac
hiev
ed
b
y
system-
atically
tagging
all
the
mo
v
es
in
eac
h
alphab
et
with
tags
uniquely
asso
ciated
with
eac
h
t
yp
e
o
ccurrence.
5
Regular
language
seman
tics
of
terms
T
erms
in
F
oil
are
in
terpreted
as
families
of
r
e
gular
expr
essions,
represen
ting
the
call-b
y-v
alue
strategies.
They
ha
v
e
the
follo
wing
form,
where
P
and
R
are
the
proto
col
and
the
comp
onen
t
parts:
J
1
:

1
;
:
:
:
;

n
:

n
`
M
:

K
=
]
c2
Q
in
C

i
n
P
k
2K

P
c;k
M

R
M
(k
)

o
:
F
ree
iden
tiers
are
in
terpreted
as:
J
:

`

:

K
:
P
c;k

:

=
P
c

;
k
2
K

;
R

=
R

[m=mm

][n=n

n];
for
all
mo
v
es
m
of
o
dd
index
in
the
pla
y
(the
O-mo
v
es)
and
n
of
ev
en
index
(P-mo
v
es).
Since
in
the
regular
expressions
mo
v
es
alw
a
ys
o
ccur
in
pairs,
this
substitution
can
b
e
carried
out
directly
on
the
regular
expression
dening
the
pla
ys.
This
\doubling-up"
of
mo
v
es
is
the
represen
tation
of
the
imp
ortan
t
c
opy-c
at
strategy
of
game
seman
tics.
The
new
tag

is
mean
t
to
dieren
tiate
b
et
w
een
the
t
w
o
o
ccurrences
of
t
yp
e

,
in
the
en
vironmen
t
and
in
the
term
itself.
F
or
example:
Jx
:
nat
`
x
:
nat
K
=
f?

n


j
n
2
N
g
;
Jf
:
nat
!
nat
`
f
:
nat
!
nat
K
=

??
R

f
	
=
n
??

P
i;n2N
q
(i)q
(i)
f
n
f

n


o
:
F
or
all
basic
constan
ts
of
the
language
w
e
ha
v
e
R
=

and:
P
n
:
nat
=
?

n;
P
true
:
b
o
ol
=
?

tt
;
P
div
erge
:

=
;;
P
skip
:
v
oid
=
?

?;
P
false
:
b
o
ol
=
?


:
Binary
arithmetic,
logic
and
arithmetic-logic
op
erators
can
b
e
in
terpreted
as
abbreviations
in
v
olving
predened
functions,
for
whic
h
the
seman
tics
of
ap-
plication
(to
b
e
dened
later)
will
b
e
used
to
comp
ose
the
meanings
of
sub-
phrases:
J+
:
nat

nat
!
nat
K
:
P
m;n
+
=
?

?;
R
+
(m;
n)
=
?(m;
n)
(m
+
n);
with
m;
n
2
N
.
Similarly
for
all
other
op
erators.
Sequencing
is:
92

Ghica
J ;
 :
v
oid

v
oid
!
v
oidK
:
P
;
=
?

?;
R
;
=
;
J ;
 :
v
oid

nat
!
natK
:
P
;
=
X
n2N
?

n;
R
;
=
:
Assignmen
t
and
dereferencing
are
resp
ectiv
ely:
J := :
v
ar

nat
!
v
oid
K
:
P
n
:=
=
?

?;
R
:=
(n)
=
write
(n)?
;
J! :
v
ar
!
natK
:
P
!
=
?

?;
R
!
=
X
n2N
r
e
ad
n:
Abstraction
is
dened
as
explicitly
reindexing
the
regular
expressions
denoting
the
meaning
of
a
term
M
with
the
comp
onen
t
mo
v
es
of
the
t
yp
es
of
iden
tiers
abstracted
o
v
er:
J `

1
:
:
:

k
:

1






k
:M
:

1






k
!

K
:
P
k

=
?

?;
R

(k
)
=
Qhk
i;
k
2
Y
in
C

i
;
Q
2
J ;

1
:

1
;
:
:
:
;

k
:

k
`
M
K
:
The
most
imp
ortan
t,
and
the
most
complex,
is
the
meaning
of
application:
J `
M
N
:

K
:
P
M
N
=
?P
c
0
N

R
0
M
(c)[xy
=R
x;y
N
];
R
M
N
=

where
?P
c
0
N
cR
N
2
J 00
`
N
:

K
;
R
N
=
X
x;y
xR
x;y
N

y
??
X
c
q
(c)R
0
M
(c)
2
J 0
`
M
:

!

K
;
R

=
X
x;y
xy
:
The
regular
expressions
and
regular
expression
families
in
v
olv
ed
in
the
deni-
tion
ab
o
v
e
are
w
ell
dened
in
general,
with
one
exception.
If
N
is
a
div
erging
term
then
either
one
of
P
c
0
N
and
R
N
ma
y
b
e
;
with
the
other
arbitrary
,
;
b
eing
a
zero-elemen
t
for
concatenation.
This
am
biguit
y
is
resolv
ed
b
y
alw
a
ys
c
ho
osing
P
c
0
N
=
;,
to
b
e
consisten
t
with
the
fact
that
P
div
erge
=
;,
as
presen
ted
earlier.
The
c
hoice
for
R
N
is
then
irrelev
an
t,

b
y
con
v
en
tion.
The
seman
tics
of
application
is
deriv
ed
directly
from
the
game
seman
tics
as
w
ell,
more
precisely
from
comp
ositions
of
strategies.
In
comp
osing
strate-
gies,
whic
h
is
ho
w
application
is
in
terpreted,
the
mo
v
es
in
the
game
(t
yp
e
o
ccurrence)
through
whic
h
comp
osition
is
realized
serv
e
as
\triggers"
whic
h
switc
h
the
thread
of
execution
b
et
w
een
the
t
w
o
strategies.
In
our
particular
case,
whenev
er
suc
h
a
mo
v
e
x
o
ccurs,
a
regular
expression
denoting
the
trace
of
execution
for
the
argumen
t
is
inserted
in
the
regular
expression
denoting
the
b
o
dy
of
the
function,
up
to
the
p
oin
t
where
another
con
text-switc
hing
mo
v
e
y
o
ccurs.
In
the
pro
cess
of
comp
osing
strategies
all
trigger
mo
v
es
are
subsequen
tly
hidden.
Here,
the
k
ey
tec
hnique
is
to
decomp
ose
a
regular
ex-
pression
in
to
smaller
regular
expressions
and,
using
systematic
substitution
and
concatenation,
create
the
regular
expressions
corresp
onding
to
the
result.
This
tec
hnique
will
b
e
also
used
in
dening
the
regular
language
seman
tics
of
terms
whic
h
are
not
abbreviations.
Since
functions
are
not
curried
w
e
need
to
dene
pairing.
It
reects
the
left-to-righ
t
order
of
argumen
t
ev
aluation
in
function
call,
sp
ecic
to
F
oil:
93

Ghica
q
 `
(M
;
N
)
:



0
y
:
P
(c;c
0
)(k
;k
0
)
M
;N
=
?
Q
c;k
M
Q
c
0
;k
0
N
(c;
c
0
);
R
M
;N
(k
;
k
0
)
=
 R
M
(k
)
+
R
N
(k
0
)


where
P
c;k
M
=
?
Q
c;k
M

c;
P
c;k
0
N
=
?Q
c
0
;k
0
N
c
0
:
Branc
hing
and
lo
oping
are
dened
directly
,
not
as
abbreviations:
Jif
B
then
M
else
N
K
:
P
if
=
(?P
tt
B
P
0
M

?)
+
(?P

B
P
0
N
?);
R
if
=
;
Jwhile
B
do
M
K
:
P
while
=
?(P
tt
B
P
0
M
)

P

B
?;
R
while
=
;
where
:
P
B
=
X
v
2ftt
;
g
?
P
v
B
v
;
P
M
=
?P
0
M

?;
P
N
=
?P
0
N
?
:
The
seman
tics
of
if
is
directly
sp
ecied
in
the
games
seman
tics.
Lo
oping
in
game
seman
tics
is
dened
as
an
abbreviation
using
the
recursion
com
binator.
A
general
recursion
com
binator
is
not
sp
ecied
in
this
treatmen
t,
but
the
xed
p
oin
t
can
b
e
calculated
b
y
hand;
the
seman
tics
of
while
ab
o
v
e
is
the
result
of
that
calculation.
Arra
y
elemen
t
access
is
also
directly
dened:
J `
[N
]
:
v
arK
:
P
k
[N
]
=
?P
k
0
N

?;
R
[N
]
(k
)
=
X
m2N
r
e
ad
(k
)m
+
X
m2N
write
(k
;
m)?
;
where
P
k
0
N
=
?P
k
N
k
:
Finally
,
as
in
the
case
of
Algol,
lo
cal
v
ariables
are
realized
b
y
imp
osing
a
go
o
d
variable
restriction
on
the
pla
ys
and
b
y
hiding
the
actions
of
the
lo
cal
v
ariables.
Go
o
d-v
ariable
b
eha
viour
simply
means
that
the
last
v
alue
written
in
a
v
ariable
will
b
e
the
next
v
alue
read
from
that
v
ariable;
this
restriction
is
imp
osed
using
in
tersection
with
the
follo
wing
regular
expression,
asso
ciated
with
a
v
ariable
:


=
A




A



P
n2N
write
(n)

?

A


(r
e
ad


n


A


)



;
where
A

=
fr
e
ad

;
write
(n)

;
n

;
?

jn
2
N
g
is
the
set
of
all
mo
v
es
tagged
b
y
,
i.e.
all
mo
v
es
in
v
olving
v
ariable
.
Therefore
lo
cal
v
ariable
denition
is:
Jnew

in
M
K
=
f
(

\
Q)
j
A

j
Q
2
JM
K
g
:
F
or
similar
reasons,
the
meaning
of
arra
y
declaration
is:
Jnew
[
n]
in
M
K
=
(

\
in

[i]
\
Q





S
in
A
[i]





Q
2
J
M
K
)
;

[i]
=
A
[i]



A
[i]


P
n2N
write
(n;
i)


?

A
[i]

(r
e
ad
(i)

n

A
[i]

)



;
i

n:
This
concludes
the
seman
tic
denition
of
F
oil.
W
e
can
state
that:
Lemma
5.1
(Represen
tation)
The
r
e
gular
language
semantics
of
F
oil
is
a
ful
ly
c
orr
e
ct
r
epr
esentation
of
the
games
and
str
ate
gies
use
d
in
the
game
semantic
mo
del.
94

Ghica
F
rom
this,
it
follo
ws
directly
from
[5]
that:
Theorem
5.2
(F
ull
Abstraction)
The
r
e
gular
language
semantics
of
F
oil
is
ful
ly
abstr
act,
i.e.
two
terms
of
F
oil
ar
e
e
quivalent
if
and
only
if
they
denote
the
same
family
of
r
e
gular
languages:
F
or
all
 `
P
;
Q
:

;
P

Q
(
)
J
P
K
=
JQK
:
In
addition,
since
the
represen
tation
is
b
y
regular
languages,
for
whic
h
language
equalit
y
is
decidable,
it
follo
ws
directly
that:
Theorem
5.3
(Decidabilit
y)
Equivalenc
e
of
two
terms
of
F
oil
is
de
cidable.
6
Example
of
reasoning
Since
one
of
the
stated
purp
oses
of
this
article
is
to
pro
vide
a
basis
for
a
new
and
p
oten
tially
practical
to
ol,
w
e
think
it
is
imp
ortan
t
to
sho
w
in
some
detail
an
example.
Space
constrain
ts
prev
en
t
us
from
presen
ting
a
realistic
program,
so
w
e
will
instead
pro
v
e
a
simple,
but
theoretically
imp
ortan
t,
equiv
alence
of
F
oil:
f
:
nat
!
v
oid;
v
:
nat
`
new
x
in
x
:=
v;
f(!x)

v
oid
f(v):
Pr
o
of:
Jx
:
v
ar
`
x
:
v
ar
K
:
P
x
=
?

?;
R
x
=
X
n2N
r
e
ad

r
e
ad
x
n
x
n
+
X
m2N
write
(m)write
(m)
x
?
x

?
Jx
:
v
ar
`!x
:
nat
K
:
P
!x
=
?
X
n2N

r
e
ad
x
n
x
n;
R
!x
=

Jf
:
nat
!
v
oid
`
f
:
nat
!
v
oid
K
:
P
f
=
??
;
R
f
=
 P
i2N
q
(i)
q
(i)
f

?
f
?


J
f
:
nat
!
v
oid;
x
:
v
ar
`
f(!x)
:
natK
:
P
f
(!x)
=
?
X
n2N
r
e
ad
x
n
x

 q
(n)
f
?
f


?;
R
f
(!x)
=

Jv
:
nat;
x
:
v
ar
`
x
:=
v
:
v
oid
K
:
P
v
x:=v
=
?
write
(v
)
x

?
x

?;
R
x:=v
=

J
f
:
nat
!
v
oid;
v
:
nat
;
x
:
v
ar
`
x
:=
v;
f(!x)
:
v
oid
K
:
P
v
x:=v
;f
(!x)
=
?write
(v
)
x
?
x

X
n2N
r
e
ad
x
n
x

 q
(n)
f
?
f


?;
R
x:=v
;f
(!x)
=

95

Ghica
Jf
:
nat
!
v
oid;
v
:
nat
`
new
x
in
x
:=
v;
f(!x)
:
v
oidK
:
P
v
=
?
write
(v
)
x

?
x

r
e
ad
x
v
x

 q
(v
)
f
?
f


?
=
?
 q
(v
)
f
?
f


?;
R
=
:
Therefore:
Jf
:
nat
!
v
oid;
v
:
nat
`
new
x
in
x
:=
v;
f(!x)
:
v
oidK
=
n
?
 q
(v
)
f
?
f



?


v
2
N
o
=
Jf
:
nat
!
v
oid;
v
:
nat
`
f(v)
:
v
oid
K
:
7
Conclusion
W
e
ha
v
e
presen
ted
a
games-based
regular
language
seman
tics
for
an
imp
erativ
e
language
with
rst
order
pro
cedures
using
call-b
y-v
alue
function
application,
with
arra
ys
and
v
ariables
passed
b
y-reference.
The
mo
del
is
obtained
directly
from
the
game
seman
tic
mo
del
[5,1]
b
y
w
orking
out
the
details
of
the
category-
theoretical
presen
tation
and
b
y
observing
that
m
uc
h
of
the
games
apparatus
(justication
p
oin
ters,
etc.)
is
unnecessary
in
handling
the
presen
t
language
subset.
Tw
o
imp
ortan
t
and
useful
features
of
imp
erativ
e
programs
with
pro-
cedures,
recursion
and
p
oin
ters,
are
omitted.
A
xed-p
oin
t
com
binator
can
not
b
e
dened
using
regular
languages
only
,
but
xed
p
oin
ts
of
functions
can
b
e
calculated
\b
y
hand,"
as
w
e
did
in
dealing
with
the
while
construct.
Data
p
oin
ters
also
can
not
b
e
represen
ted
directly
using
the
presen
t
formalism,
but
they
could
b
e
in
principle
enco
ded
using
arra
ys
and
arra
y
indices|but
this
metho
d
has
limitations.
Ac
kno
wledgemen
t
Guy
McCusk
er's
suggestions
and
explanations
w
ere
essen
tial
in
the
writing
of
this
pap
er,
I
o
w
e
him
a
great
deal.
I
w
ould
lik
e
to
thank
Bob
T
ennen
t
for
his
supp
ort
and
encouragemen
t.
Man
y
thanks
are
due
to
the
anon
ymous
referees
for
pro
viding
insigh
tful
commen
ts
and
p
ertinen
t
corrections.
References
[1]
Abramsky
,
S.,
K.
Honda
and
G.
McCusk
er,
A
ful
ly
abstr
act
game
semantics
for
gener
al
r
efer
enc
es,
in:
Pr
o
c
e
e
dings,
Thirte
enth
A
nnual
IEEE
Symp
osium
on
L
o
gic
in
Computer
Scienc
e,
1998.
[2]
Abramsky
,
S.,
P
.
Malacaria
and
R.
Jagadeesan,
F
ul
l
abstr
action
for
PCF,
Lecture
Notes
in
Computer
Science
789
(1994),
pp.
1{59.
[3]
Abramsky
,
S.
and
G.
McCusk
er,
Game
semantics,
lecture
notes,
1997
Marktob
erdorf
summer
sc
ho
ol
(a
v
ailable
from
http://www.dcs.ed.ac.uk/
home/samson/mdorf97.ps.g
z).
96

Ghica
[4]
Abramsky
,
S.
and
G.
McCusk
er,
Line
arity,
sharing
and
state:
a
ful
ly
abstr
act
game
semantics
for
Ide
alize
d
Algol
with
active
expr
essions,
in:
O'Hearn
and
T
ennen
t
[14
]
pp.
297{329,
t
w
o
v
olumes.
[5]
Abramsky
,
S.
and
G.
McCusk
er,
Cal
l-by-value
games,
in:
CSL:
11th
Workshop
on
Computer
Scienc
e
L
o
gic,
LNCS
1414,
1998,
pp.
1{17.
[6]
Abramsky
,
S.
and
G.
McCusk
er,
F
ul
l
abstr
action
for
Ide
alize
d
Algol
with
p
assive
expr
essions,
Theoretical
Computer
Science
227
(1999),
pp.
3{42.
[7]
Ghica,
D.
R.
and
G.
McCusk
er,
R
e
asoning
ab
out
ide
alize
d
algol
using
r
e
gular
languages,
in:
Pr
o
c
e
e
dings
of
27th
International
Col
lo
quium
on
A
utomata,
L
anguages
and
Pr
o
gr
amming
ICALP
2000,
LNCS
1853
(2000),
pp.
103{116.
[8]
Hankin,
C.
and
P
.
Malacaria,
Gener
alise
d
owcharts
and
games,
Lecture
Notes
in
Computer
Science
1443
(1998).
[9]
Hankin,
C.
and
P
.
Malacaria,
Non-deterministic
games
and
pr
o
gr
am
analysis:
an
applic
ation
to
se
curity,
in:
Pr
o
c
e
e
dings,
F
ourte
enth
A
nnual
IEEE
Symp
osium
on
L
o
gic
in
Computer
Scienc
e,
1999
pp.
443{452.
[10]
Hyland,
J.
M.
E.
and
C.-H.
L.
Ong,
On
ful
l
abstr
action
for
PCF:
I,
II
and
III,
Information
and
Computation
163
(2000).
[11]
McCusk
er,
G.,
\Games
and
F
ull
Abstraction
for
a
F
unctional
Metalanguage
with
Recursiv
e
T
yp
es,"
Distinguished
Dissertations,
Springer-V
erlag
Limited,
1998.
[12]
Mey
er,
A.
R.
and
K.
Sieb
er,
T
owar
ds
ful
ly
abstr
act
semantics
for
lo
c
al
variables:
pr
eliminary
r
ep
ort,
in:
Confer
enc
e
R
e
c
or
d
of
the
Fifte
enth
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages
(1988),
pp.
191{
203,
reprin
ted
as
Chapter
7
of
[14
].
[13]
Moggi,
E.,
Notions
of
c
omputation
and
monads,
Information
and
Computation
93
(1991),
pp.
55{92.
[14]
O'Hearn,
P
.
W.
and
R.
D.
T
ennen
t,
editors,
\Algol
-lik
e
Languages,"
Progress
in
Theoretical
Computer
Science,
Birkh
auser,
Boston,
1997,
t
w
o
v
olumes.
[15]
Sc
hmidt,
D.
A.,
On
the
ne
e
d
for
a
p
opular
formal
semantics,
A
CM
SIGPLAN
Notices
32
(1997),
pp.
115{116.
97

98

MFPS
17
Preliminary
Version
T
yping
Corresp
ondence
Assertions
for
Comm
unication
Proto
cols
Andrew
D.
Gordon
Micr
osoft
R
ese
ar
ch,
Cambridge
Alan
Jerey
DePaul
University,
Chic
ago
Abstract
W
o
o
and
Lam
prop
ose
corresp
ondence
assertions
for
sp
ecifying
authen
ticit
y
prop
er-
ties
of
securit
y
proto
cols.
The
only
prior
w
ork
on
c
hec
king
corresp
ondence
assertions
dep
ends
on
mo
del-c
hec
king
and
is
limited
to
nite-state
systems.
W
e
prop
ose
a
de-
p
enden
t
t
yp
e
and
eect
system
for
c
hec
king
corresp
ondence
assertions.
Since
it
is
based
on
t
yp
e-c
hec
king,
our
metho
d
is
not
limited
to
nite-state
systems.
This
pap
er
presen
ts
our
system
in
the
simple
and
general
setting
of
the

-calculus.
W
e
sho
w
ho
w
to
t
yp
e-c
hec
k
correctness
prop
erties
of
example
comm
unication
proto
cols
based
on
secure
c
hannels.
In
a
related
pap
er,
w
e
extend
our
system
to
the
more
complex
and
sp
ecic
setting
of
c
hec
king
cryptographic
proto
cols
based
on
encrypted
messages
sen
t
o
v
er
insecure
c
hannels.
1
In
tro
duction
Corresp
ondence
Assertions
T
o
a
rst
appro
ximation,
a
corresp
ondence
assertion
ab
out
a
comm
unication
proto
col
is
an
in
ten
tion
that
follo
ws
the
pattern:
If
one
principal
ev
er
reac
hes
a
certain
p
oin
t
in
a
proto
col,
then
some
other
principal
has
previously
reac
hed
some
other
matc
hing
p
oin
t
in
the
proto
col.
W
e
record
suc
h
in
ten
tions
b
y
annotating
the
program
represen
ting
the
proto
col
with
lab
elled
assertions
of
the
form
b
egin
L
or
end
L.
These
assertions
ha
v
e
no
eect
at
run
time,
but
notionally
indicate
that
a
principal
has
reac
hed
a
certain
p
oin
t
in
the
proto
col.
The
follo
wing
more
accurately
states
the
in
ten
tion
recorded
b
y
these
annotations:
If
the
program
em
b
o
dying
the
proto
col
ev
er
asserts
end
L,
then
there
is
a
distinct
previous
assertion
of
b
egin
L.
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Gordon
and
Jeffrey
W
o
o
and
Lam
[23
]
in
tro
duce
corresp
ondence
assertions
to
state
in
tended
prop
erties
of
authen
tication
proto
cols
based
on
cryptograph
y
.
Consider
a
proto
col
where
a
principal
a
generates
a
new
session
k
ey
k
and
transmits
it
to
b.
W
e
in
tend
that
if
a
run
of
b
ends
a
k
ey
exc
hange
b
elieving
that
it
has
receiv
ed
k
ey
k
from
a,
then
a
generated
k
as
part
of
a
k
ey
exc
hange
in
tended
for
b.
W
e
record
this
in
ten
tion
b
y
annotating
a's
generation
of
k
b
y
the
lab
el
b
egin
ha;
b;
k
i,
and
b's
reception
of
k
b
y
the
lab
el
end
ha;
b;
k
i.
A
proto
col
can
fail
a
corresp
ondence
assertion
b
ecause
of
sev
eral
kinds
of
bug.
One
kind
consists
of
those
bugs
that
cause
the
proto
col
to
go
wrong
without
an
y
external
in
terference.
Other
kinds
are
bugs
where
an
unreliable
or
malicious
net
w
ork
or
participan
t
causes
the
proto
col
to
fail.
This
P
ap
er
W
e
sho
w
in
this
pap
er
that
correctness
prop
erties
expressed
b
y
corresp
ondence
assertions
can
b
e
pro
v
ed
b
y
t
yp
e-c
hec
king.
W
e
em
b
ed
corre-
sp
ondence
assertions
in
a
concurren
t
programming
language
(the

-calculus
of
Milner,
P
arro
w,
and
W
alk
er
[17])
and
presen
t
a
new
t
yp
e
and
eect
system
that
guaran
tees
safet
y
of
w
ell-t
yp
ed
assertions.
W
e
sho
w
sev
eral
examples
of
ho
w
corresp
ondence
assertions
can
b
e
pro
v
ed
b
y
t
yp
e-c
hec
king.
W
o
o
and
Lam's
pap
er
in
tro
duces
corresp
ondence
assertions
but
pro
vides
no
tec
hniques
for
pro
ving
them.
Clark
e
and
Marrero
[4]
use
corresp
ondence
assertions
to
sp
ecify
prop
erties
of
e-commerce
proto
cols,
suc
h
as
authoriza-
tions
of
transactions.
T
o
the
b
est
of
our
kno
wledge,
the
only
previous
w
ork
on
c
hec
king
corresp
ondence
assertions
is
a
pro
ject
b
y
Marrero,
Clark
e,
and
Jha
[16
]
to
apply
mo
del-c
hec
king
tec
hniques
to
nite
state
v
ersions
of
securit
y
proto
cols.
Since
our
w
ork
is
based
on
t
yp
e-c
hec
king,
it
is
not
limited
to
nite
state
systems.
Moreo
v
er,
t
yp
e-c
hec
king
is
comp
ositional:
w
e
can
v
erify
com-
p
onen
ts
in
isolation,
and
kno
w
that
their
comp
osition
is
safe,
without
ha
ving
to
v
erify
the
en
tire
system.
Unlik
e
Marrero,
Clark
e,
and
Jha's
w
ork,
ho
w
ev
er,
the
system
of
the
presen
t
pap
er
do
es
not
deal
with
cryptographic
primitiv
es,
and
nor
do
es
it
deal
with
an
arbitrary
opp
onen
t.
Still,
in
another
pap
er
[9],
w
e
adapt
our
t
yp
e
and
eect
system
to
the
setting
of
the
spi-calculus
[1],
an
extension
of
the

-calculus
with
abstract
cryptographic
primitiv
es.
This
adaptation
can
sho
w,
moreo
v
er,
that
prop
erties
hold
in
the
presence
of
an
arbitrary
un
t
yp
ed
opp
onen
t.
Review
of
The
Un
t
yp
ed

-Calculus
Milner,
P
arro
w,
and
W
alk
er's

-
calculus
is
a
concurren
t
formalism
to
whic
h
man
y
kinds
of
concurren
t
com-
putation
ma
y
b
e
reduced.
Its
simplicit
y
mak
es
it
an
attractiv
e
v
ehicle
for
dev
eloping
the
ideas
of
this
pap
er,
while
its
generalit
y
suggests
they
ma
y
b
e
widely
applicable.
Its
basic
data
t
yp
e
is
the
name,
an
unguessable
iden
tier
for
a
comm
unications
c
hannel.
Computation
is
based
on
the
exc
hange
of
mes-
sages,
tuples
of
names,
on
named
c
hannels.
Programming
in
the

-calculus
is
based
on
the
follo
wing
constructs
(written,
un
usually
,
with
k
eyw
ords,
for
100

Gordon
and
Jeffrey
the
sak
e
of
clarit
y).
The
rest
of
the
pap
er
con
tains
man
y
examples.
An
out-
put
pro
cess
out
xhy
1
;
:
:
:
;
y
n
i
represen
ts
a
message
hy
1
;
:
:
:
;
y
n
i
sen
t
on
the
c
hannel
x.
An
input
pro
cess
inp
x(z
1
;
:
:
:
;
z
n
);
P
blo
c
ks
till
it
nds
a
mes-
sage
sen
t
on
the
c
hannel
x,
reads
the
names
in
the
message
in
to
the
v
ariables
z
1
;
:
:
:
;
z
n
,
and
then
runs
P
.
The
pro
cess
P
j
Q
is
the
parallel
comp
osition
of
the
t
w
o
pro
cesses
P
and
Q;
the
t
w
o
ma
y
run
indep
enden
tly
or
comm
unicate
on
shared
c
hannels.
The
name
generation
pro
cess
new
(x);
P
generates
a
fresh
name,
calls
it
x,
then
runs
P
.
Unless
P
rev
eals
x,
no
other
pro
cess
can
use
this
fresh
name.
The
replication
pro
cess
rep
eat
P
b
eha
v
es
lik
e
an
un
b
ounded
parallel
arra
y
of
replicas
of
P
.
The
pro
cess
stop
represen
ts
inactivit
y;
it
do
es
nothing.
Finally
,
the
conditional
if
x
=
y
then
P
else
Q
compares
the
names
x
and
y
.
If
they
are
the
same
it
runs
P
;
otherwise
it
runs
Q.
2
Corresp
ondence
Assertions,
b
y
Example
This
section
in
tro
duces
the
idea
of
dening
corresp
ondence
assertions
b
y
an-
notating
co
de
with
b
egin-
and
end-ev
en
ts.
W
e
giv
e
examples
of
b
oth
safe
co
de
and
of
unsafe
co
de,
that
is,
of
co
de
that
satises
the
corresp
ondence
assertions
induced
b
y
its
annotations,
and
of
co
de
that
do
es
not.
A
transmit-ac
kno
wledge
handshak
e
is
a
standard
comm
unications
idiom,
easily
expressed
in
the

-calculus:
along
with
the
actual
message,
the
sender
transmits
an
ac
kno
wledgemen
t
c
hannel,
up
on
whic
h
the
receiv
er
sends
an
ac
kno
wledgemen
t.
W
e
in
tend
that:
During
a
transmit-ac
kno
wledge
handshak
e,
if
the
sender
receiv
es
an
ac-
kno
wledgmen
t,
then
the
receiv
er
has
obtained
the
message.
Corresp
ondence
assertions
can
express
this
in
ten
tion
formally
.
Supp
ose
that
a
and
b
are
the
names
of
the
sender
and
receiv
er,
resp
ectiv
ely
.
W
e
annotate
the
co
de
of
the
receiv
er
b
with
a
b
egin-assertion
at
the
p
oin
t
after
it
has
receiv
ed
the
message
msg
.
W
e
annotate
the
co
de
of
the
sender
a
with
an
end-assertion
at
the
p
oin
t
after
it
has
receiv
ed
the
ac
kno
wledgemen
t.
W
e
lab
el
b
oth
assertions
with
the
names
of
the
principals
and
the
transmitted
message,
ha;
b;
msg
i.
Hence,
w
e
assert
that
if
after
sending
msg
to
b,
the
sender
a
receiv
es
an
ac
kno
wledgemen
t,
then
a
distinct
run
of
b
has
receiv
ed
msg
.
Supp
ose
that
c
is
the
name
of
the
c
hannel
on
whic
h
principal
b
receiv
es
messages
from
a.
Here
is
the

-calculus
co
de
of
the
annotated
sender
and
receiv
er:
R
cver
(a;
b;
c)

=
inp
c(msg
;
ack
);
b
egin
ha;
b;
msg
i;
out
ack
hi
Snder
(a;
b;
c)

=
new
(msg
);
new
(ack
);
out
chmsg
;
ack
i;
inp
ack
();
end
ha;
b;
msg
i
The
sender
creates
a
fresh
message
msg
and
a
fresh
ac
kno
wledgemen
t
c
hannel
101

Gordon
and
Jeffrey
ack
,
sends
the
t
w
o
on
the
c
hannel
c,
w
aits
for
an
ac
kno
wledgemen
t,
and
then
asserts
an
end-ev
en
t
lab
elled
ha;
b;
msg
i.
The
receiv
er
gets
the
message
msg
and
the
ac
kno
wledgemen
t
c
hannel
ack
o
c,
asserts
a
b
egin-ev
en
t
lab
elled
ha;
b;
msg
i,
and
sends
an
ac
kno
wledgemen
t
on
ack
.
W
e
sa
y
a
program
is
safe
if
it
satises
the
in
ten
tions
induced
b
y
the
b
egin-
and
end-assertions.
More
precisely
,
a
program
is
safe
just
if
for
ev
ery
run
of
the
program
and
for
ev
ery
lab
el
L,
there
is
a
distinct
b
egin-ev
en
t
lab
elled
L
preceding
ev
ery
end-ev
en
t
lab
elled
L.
(W
e
formalize
this
denition
in
Sec-
tion
5.)
Here
are
three
com
binations
of
our
examples:
t
w
o
safe,
one
unsafe.
new
(c);
Snder
(a;
b;
c)
j
R
cver
(a;
b;
c)
(Example
1:
safe
)
Example
1
uses
one
instance
of
the
sender
and
one
instance
of
the
receiv
er
to
represen
t
a
single
instance
of
the
proto
col.
The
restriction
new
(c);
mak
es
the
c
hannel
c
priv
ate
to
the
sender
and
the
receiv
er.
This
assem
bly
is
safe;
its
only
run
correctly
implemen
ts
the
handshak
e
proto
col.
new
(c);
Snder
(a;
b;
c)
j
Snder
(a;
b;
c)
j
rep
eat
R
cver
(a;
b;
c)
(Example
2:
safe
)
Example
2
uses
t
w
o
copies
of
the
sender|represen
ting
t
w
o
attempts
b
y
a
single
principal
a
to
send
a
message
to
b|and
a
replicated
cop
y
of
the
receiv
er|
represen
ting
the
principal
b
willing
to
accept
an
un
b
ounded
n
um
b
er
of
mes-
sages.
Again,
this
assem
bly
is
safe;
an
y
run
consists
of
an
in
terlea
ving
of
t
w
o
correct
handshak
es.
new
(c);
Snder
(a;
b;
c)
j
Snder
(a
0
;
b;
c)
j
rep
eat
R
cver
(a;
b;
c)
(Example
3:
unsafe
)
Example
3
is
a
v
arian
t
on
Example
2,
where
w
e
k
eep
the
replicated
receiv
er
b,
but
c
hange
the
iden
tit
y
of
one
of
the
senders,
so
that
the
t
w
o
senders
represen
t
t
w
o
dieren
t
principals
a
and
a
0
.
These
t
w
o
principals
share
a
single
c
hannel
c
to
the
receiv
er.
Since
the
iden
tit
y
a
of
the
sender
is
a
parameter
of
R
cver
(a;
b;
c)
rather
than
b
eing
explicitly
comm
unicated,
this
assem
bly
is
unsafe.
There
is
a
run
in
whic
h
a
0
generates
msg
and
ack
,
and
sends
them
to
b;
b
asserts
a
b
egin-ev
en
t
lab
elled
ha;
b;
msg
i
and
outputs
on
ack
;
then
a
0
asserts
an
end-ev
en
t
lab
elled
ha
0
;
b;
msg
i.
This
end-ev
en
t
has
no
corresp
onding
b
egin-
ev
en
t
so
the
assem
bly
is
unsafe,
reecting
the
p
ossibilit
y
that
the
receiv
er
can
102

Gordon
and
Jeffrey
b
e
mistak
en
ab
out
the
iden
tit
y
of
the
sender.
3
T
yping
Corresp
ondence
Assertions
3.1
T
yp
es
and
Ee
cts
Our
t
yp
e
and
eect
system
is
based
on
the
idea
of
assigning
t
yp
es
to
names
and
eects
to
pro
cesses.
A
t
yp
e
describ
es
what
op
erations
are
allo
w
ed
on
a
name,
suc
h
as
what
messages
ma
y
b
e
comm
unicated
on
a
c
hannel
name.
An
eect
describ
es
the
collection
of
lab
els
of
ev
en
ts
the
pro
cess
ma
y
end
while
not
itself
b
eginning.
W
e
compute
eects
based
on
the
in
tuition
that
end-
ev
en
ts
are
accoun
ted
for
b
y
preceding
b
egin-ev
en
ts;
a
b
egin-ev
en
t
is
a
credit
while
an
end-ev
en
t
is
a
debit.
According
to
this
metaphor,
the
eect
of
a
pro
cess
is
an
upp
er
b
ound
on
the
debt
a
pro
cess
ma
y
incur.
If
w
e
can
assign
a
pro
cess
the
empt
y
eect,
w
e
kno
w
all
of
its
end-ev
en
ts
are
accoun
ted
for
b
y
b
egin-ev
en
ts.
Therefore,
w
e
kno
w
that
the
pro
cess
is
safe,
that
is,
its
corresp
ondence
assertions
are
true.
An
essen
tial
ingredien
t
of
our
t
yping
rules
is
the
idea
of
attac
hing
a
latent
ee
ct
to
eac
h
c
hannel
t
yp
e.
W
e
allo
w
an
y
pro
cess
receiving
o
a
c
hannel
to
treat
the
laten
t
eect
as
a
credit
to
w
ards
subsequen
t
end-ev
en
ts.
This
is
sound
b
ecause
w
e
require
an
y
pro
cess
sending
on
a
c
hannel
to
treat
the
laten
t
eect
as
a
debit
that
m
ust
b
e
accoun
ted
for
b
y
previous
b
egin-ev
en
ts.
Laten
t
eects
are
at
the
heart
of
our
metho
d
for
t
yp
e-c
hec
king
ev
en
ts
b
egun
b
y
one
pro
cess
and
ended
b
y
another.
The
follo
wing
table
describ
es
the
syn
tax
of
t
yp
es
and
eects.
As
in
most
v
ersions
of
the

-calculus,
w
e
mak
e
no
lexical
distinction
b
et
w
een
names
and
v
ariables,
ranged
o
v
er
b
y
a;
b;
c;
x;
y
;
z
.
An
event
lab
el,
L,
is
simply
a
tuple
of
names.
Ev
en
t
lab
els
iden
tify
the
ev
en
ts
asserted
b
y
b
egin-
and
end-assertions.
An
ee
ct,
e,
is
a
m
ultiset,
that
is,
an
unordered
list,
of
ev
en
t
lab
els,
written
as
[L
1
;
:
:
:
;
L
n
].
A
typ
e,
T
,
tak
es
one
of
t
w
o
kinds.
The
rst
kind,
Name,
is
the
t
yp
e
of
pure
names,
that
is,
names
that
only
supp
ort
equalit
y
op
erations,
but
cannot
b
e
used
as
c
hannels.
W
e
use
Name
as
the
t
yp
e
of
names
that
iden
tify
principals,
for
instance.
The
second
kind,
Ch(x
1
:T
1
;
:
:
:
;
x
n
:T
n
)e,
is
a
t
yp
e
of
a
c
hannel
comm
unicating
n-tuples
of
names,
of
t
yp
es
T
1
,
:
:
:
,
T
n
,
with
laten
t
eect
e.
The
names
x
1
,
:
:
:
,
x
n
are
b
ound;
the
scop
e
of
eac
h
x
i
consists
of
the
t
yp
es
T
i+1
,
:
:
:
,
T
n
,
and
the
laten
t
eect
e.
W
e
iden
tify
t
yp
es
up
to
the
consisten
t
renaming
of
b
ound
names.
Names,
Ev
en
t
Lab
els,
Eects,
and
T
yp
es:
a;
b;
c;
x;
y
;
z
names,
v
ariables
L
::=
hx
1
;
:
:
:
;
x
n
i
ev
en
t
lab
el:
tuple
of
names
e
::=
[L
1
;
:
:
:
;
L
n
]
eect:
m
ultiset
of
ev
en
t
lab
els
T
::=
t
yp
e
Name
pure
name
103

Gordon
and
Jeffrey
Ch
(x
1
:T
1
;
:
:
:
;
x
n
:T
n
)e
c
hannel
with
laten
t
eect
e
F
or
example:

Ch()[
],
a
sync
hronization
c
hannel
(that
is,
a
c
hannel
used
only
for
sync
hro-
nization)
with
no
laten
t
eect.

Ch(a:
Name)[hbi],
a
c
hannel
for
comm
unicating
a
pure
name,
costing
[hbi]
to
senders
and
pa
ying
[hbi]
to
receiv
ers,
where
b
is
a
xed
name.

Ch(a:
Name)[hai],
a
c
hannel
for
comm
unicating
a
pure
name,
costing
[hai]
to
senders
and
pa
ying
[hai]
to
receiv
ers,
where
a
is
the
name
comm
unicated
on
the
c
hannel.

Ch(a:
Name;
b:
Ch()[hai])[
],
a
c
hannel
with
no
laten
t
eect
for
comm
unicating
pairs
of
the
form
a;
b,
where
a
is
a
pure
name,
and
b
is
the
name
of
a
syn-
c
hronization
c
hannel,
costing
[hai]
to
senders
and
pa
ying
[hai]
to
receiv
ers.
The
follo
wing
is
a
con
v
enien
t
shorthand
for
the
lists
of
t
yp
ed
v
ariable
decla-
rations
found
in
c
hannel
t
yp
es:
Notation
for
T
yp
ed
V
ariables:
~
x:
~
T

=
x
1
:T
1
;
:
:
:
;
x
n
:T
n
where
~
x
=
x
1
;
:
:
:
;
x
n
and
~
T
=
T
1
;
:
:
:
;
T
n


=
()
the
empt
y
list
The
follo
wing
equations
dene
the
the
sets
of
free
names
of
our
syn
tax
as
follo
ws:
v
ariable
declarations,
fn(:
)

=
?
and
fn(
~
x:
~
T
;
x:T
)

=
fn(
~
x:
~
T
)
[
(fn
(T
)
 f
~
x
g);
t
yp
es,
fn
(Name
)

=
?
and
fn(Ch(
~
x
:
~
T
)e)

=
fn
(
~
x
:
~
T
)
[
(fn(e)
 f
~
xg);
ev
en
t
lab
els,
fn(hx
1
;
:
:
:
;
x
n
i)

=
fx
1
;
:
:
:
;
x
n
g;
and
ev
en
ts,
fn([L
1
;
:
:
:
;
L
1
])

=
fn
(L
1
)
[



[
fn(L
n
).
F
or
an
y
of
these
forms
of
syn
tax,
w
e
write
 fx y
g
for
the
op
eration
of
capture-a
v
oiding
substitution
of
the
name
y
for
eac
h
free
o
ccurrence
of
the
name
x.
W
e
write
 f
~
x 
~
y
g,
where
~
x
=
x
1
;
:
:
:
;
x
n
and
~
y
=
y
1
;
:
:
:
;
y
n
for
the
iterated
substitution
 fx
1
 y
1
g



fx
n
 y
n
g.
3.2
Syntax
of
our
T
yp
e
d

-Calculus
W
e
explained
the
informal
seman
tics
of
b
egin-
and
end-assertions
in
Section
2,
and
of
the
other
constructs
in
Section
1.
Pro
cesses:
P
;
Q;
R
::=
pro
cess
out
xhy
1
;
:
:
:
;
y
n
i
p
oly
adic
async
hronous
output
inp
x(y
1
:T
1
;
:
:
:
;
y
n
:T
n
);
P
p
oly
adic
input
if
x
=
y
then
P
else
Q
conditional
new
(x:
T
);
P
name
generation
P
j
Q
comp
osition
rep
eat
P
replication
104

Gordon
and
Jeffrey
stop
inactivit
y
b
egin
L;
P
b
egin-assertion
end
L;
P
end-assertion
There
are
t
w
o
name
binding
constructs:
input
and
name
generation.
In
an
input
pro
cess
inp
x(y
1
:T
1
;
:
:
:
;
y
n
:T
n
);
P
,
eac
h
name
y
i
is
b
ound,
with
scop
e
consisting
of
T
i+1
,
:
:
:
,
T
n
,
and
P
.
In
a
name
restriction
new
(x:
T
);
P
,
the
name
x
is
b
ound;
its
scop
e
is
P
.
W
e
write
P
fx 
y
g
for
the
outcome
of
a
capture-a
v
oiding
substitution
of
the
name
y
for
eac
h
free
o
ccurrence
of
the
name
x
in
the
pro
cess
P
.
W
e
iden
tify
pro
cesses
up
to
the
consisten
t
renaming
of
b
ound
names.
W
e
let
fn(P
)
b
e
the
set
of
free
names
of
a
pro
cess
P
.
W
e
sometimes
write
an
output
as
out
xh
~
y
i
where
~
y
=
y
1
;
:
:
:
;
y
n
,
and
an
input
as
inp
x(
~
y
:
~
T
);
P
,
where
~
y
:
~
T
is
a
v
ariable
declaration
written
in
the
notation
in
tro
duced
in
the
previous
section.
W
e
write
out
xh
~
y
i;
P
as
a
shorthand
for
out
xh
~
y
i
j
P
.
3.3
Intuitions
for
the
T
yp
e
and
Ee
ct
System
As
a
prelude
to
our
formal
t
yping
rules,
w
e
presen
t
the
underlying
in
tuitions.
Recall
the
in
tuition
that
end-ev
en
ts
are
costs
to
b
e
accoun
ted
for
b
y
b
egin-
ev
en
ts.
When
w
e
sa
y
a
pro
cess
P
has
eect
e,
it
means
that
e
is
an
upp
er
b
ound
on
the
b
egin-ev
en
ts
needed
to
precede
P
to
mak
e
the
whole
pro
cess
safe.
In
other
w
ords,
if
P
has
eect
[L
1
;
:
:
:
;
L
n
]
then
b
egin
L
1
;



;
b
egin
L
n
;
P
is
safe.
T
yping
Assertions
An
assertion
b
egin
L;
P
pa
ys
for
one
end-ev
en
t
lab
elled
L
in
P
;
so
if
P
is
a
pro
cess
with
eect
e,
then
b
egin
L;
P
is
a
pro
cess
with
eect
e [L],
that
is,
the
m
ultiset
e
with
one
o
ccurrence
of
L
deleted.
So
w
e
ha
v
e
a
t
yping
rule
of
the
form:
P
:
e
)
b
egin
L;
P
:
e [L]
If
P
is
a
pro
cess
with
eect
e,
then
end
L;
P
is
a
pro
cess
with
eect
e+[L],
that
is,
the
concatenation
of
e
and
[L].
W
e
ha
v
e
a
rule:
P
:
e
)
end
L;
P
:
e+[L]
T
yping
Name
Generation
and
Concurrency
The
eect
of
a
name
gen-
eration
pro
cess
new
(x:T
);
P
,
is
simply
the
eect
of
P
.
T
o
prev
en
t
scop
e
con-
fusion,
w
e
forbid
x
from
o
ccurring
in
this
eect.
P
:
e;
x
=
2
fn(e)
)
new
(x:
T
);
P
:
e
The
eect
of
a
concurren
t
comp
osition
of
pro
cesses
is
the
m
ultiset
union
of
the
constituen
t
pro
cesses.
P
:
e
P
;
Q
:
e
Q
)
P
j
Q
:
e
P
+
e
Q
The
inactiv
e
pro
cess
asserts
no
end-ev
en
ts,
so
its
eect
is
empt
y
.
105

Gordon
and
Jeffrey
stop
:
[
]
The
replication
of
a
pro
cess
P
b
eha
v
es
lik
e
an
un
b
ounded
arra
y
of
repli-
cas
of
P
.
If
P
has
a
non-empt
y
eect,
then
its
replication
w
ould
ha
v
e
an
un
b
ounded
eect,
whic
h
could
not
b
e
accoun
ted
for
b
y
preceding
b
egin-
assertions.
Therefore,
to
t
yp
e
rep
eat
P
w
e
require
P
to
ha
v
e
an
empt
y
eect.
P
:
[
]
)
rep
eat
P
:
[
]
T
yping
Comm
unications
W
e
b
egin
b
y
presen
ting
the
rules
for
t
yping
comm
unications
on
monadic
c
hannels
with
no
laten
t
eect,
that
is,
those
with
t
yp
es
of
the
form
Ch(y
:
T
)[
].
The
comm
unicated
name
has
t
yp
e
T
.
An
output
out
xhz
i
has
empt
y
eect.
An
input
inp
x(y
:
T
);
P
has
the
same
eect
as
P
.
Since
the
input
v
ariable
in
the
pro
cess
and
in
the
t
yp
e
are
b
oth
b
ound,
w
e
ma
y
assume
they
are
the
same
v
ariable
y
.
x
:
Ch(y
:T
)[
];
z
:
T
)
out
xhz
i
:
[
]
x
:
Ch(y
:T
)[
];
P
:
e;
y
=
2
fn(e)
)
inp
x(y
:
T
);
P
:
e
Next,
w
e
consider
the
t
yp
e
Ch
(y
:
T
)e
`
of
monadic
c
hannels
with
laten
t
eect
e
`
.
The
laten
t
eect
is
a
cost
to
senders,
a
b
enet
to
receiv
ers,
and
is
the
scop
e
of
the
v
ariable
y
.
W
e
assign
an
output
out
xhz
i
the
eect
e
`
fy
 
z
g,
where
w
e
ha
v
e
instan
tiated
the
name
y
b
ound
in
the
t
yp
e
of
the
c
hannel
with
z
,
the
name
actually
sen
t
on
the
c
hannel.
W
e
assign
an
input
inp
x(y
:T
);
P
the
eect
e
 e
`
,
where
e
is
the
eect
of
P
.
T
o
a
v
oid
scop
e
confusion,
w
e
require
that
y
is
not
free
in
e
 e
`
.
x
:
Ch(y
:T
)e
`
;
z
:
T
)
out
xhz
i
:
e
`
fy
 
z
g
x
:
Ch(y
:T
)e
`
;
P
:
e;
y
=
2
fn(e
 e
`
)
)
inp
x(y
:
T
);
P
:
e
 e
`
The
formal
rules
for
input
and
output
in
the
next
section
generalize
these
rules
to
deal
with
p
oly
adic
c
hannels.
T
yping
Conditionals
When
t
yping
a
conditional
if
x
=
y
then
P
else
Q,
it
is
useful
to
exploit
the
fact
that
P
only
runs
if
the
t
w
o
names
x
and
y
are
equal.
T
o
do
so,
w
e
c
hec
k
the
eect
of
P
after
substituting
one
for
the
other.
Supp
ose
then
pro
cess
P
fx 
y
g
has
eect
e
P
fx y
g.
Supp
ose
also
that
pro
cess
Q
has
eect
e
Q
.
Let
e
P
_
e
Q
b
e
the
least
upp
er
b
ound
of
an
y
t
w
o
eects
e
P
and
e
Q
.
Then
e
P
_
e
Q
is
an
upp
er
b
ound
on
the
b
egin-ev
en
ts
needed
to
precede
the
conditional
to
mak
e
it
safe,
whether
P
or
Q
runs.
An
example
in
Section
4.2
illustrates
this
rule.
P
fx 
y
g
:
e
P
fx y
g;
Q
:
e
Q
)
if
x
=
y
then
P
else
Q
:
e
P
_
e
Q
3.4
T
yping
R
ules
Our
t
yping
rules
dep
end
on
sev
eral
op
erations
on
eect
m
ultisets,
most
of
whic
h
w
ere
in
tro
duced
informally
in
the
previous
section.
Here
are
the
formal
denitions.
106

Gordon
and
Jeffrey
Op
erations
on
eects:
e
+
e
0
,
e

e
0
,
e
 e
0
,
L
2
e,
e
_
e
0
[L
1
;
:
:
:
;
L
m
]
+
[L
m+1
;
:
:
:
;
L
m+n
]

=
[L
1
;
:
:
:
;
L
m+n
]
e

e
0
if
and
only
if
e
0
=
e
+
e
0
0
for
some
e
00
e
 e
0

=
the
smallest
e
00
suc
h
that
e

e
0
+
e
00
L
2
e
if
and
only
if
[L]

e
e
_
e
0

=
the
smallest
e
00
suc
h
that
e

e
0
0
and
e
0

e
00
The
t
yping
judgmen
ts
of
this
section
dep
end
on
an
en
vironmen
t
to
assign
a
t
yp
e
to
all
the
v
ariables
in
scop
e.
En
vironmen
ts:
E
::=
~
x:
~
T
en
vironmen
t
dom(
~
x:
~
T
)

=
f
~
xg
domain
of
an
en
vironmen
t
T
o
equate
t
w
o
names
in
an
en
vironmen
t,
needed
for
t
yping
conditionals,
w
e
dene
a
name
fusion
function.
W
e
obtain
the
fusion
E
fx x
0
g
from
E
b
y
turning
all
o
ccurrences
of
x
and
x
0
in
E
in
to
x
0
.
F
using
x
with
x
0
in
E
:
E
fx x
0
g
(x
1
:T
1
;
:
:
:
;
x
n
:T
n
)fx x
0
g

=
(x
1
fx x
0
g):
(T
1
fx x
0
g);
:
:
:
;
(x
n
fx x
0
g):(T
n
fx x
0
g)
where
E
;
x:
T

=

E
if
x
2
dom(E
)
E
;
x:T
otherwise
The
follo
wing
table
summarizes
the
v
e
judgmen
ts
of
our
t
yp
e
system,
whic
h
are
inductiv
ely
dened
b
y
rules
in
subsequen
t
tables.
Judgmen
t
E
`

means
en
vironmen
t
E
is
w
ell-formed.
Judgmen
t
E
`
T
means
t
yp
e
T
is
w
ell-formed.
Judgmen
t
E
`
x
:
T
means
name
x
is
in
scop
e
with
t
yp
e
T
.
Judgmen
t
E
`
h
~
x
i
:
h
~
y
:
~
T
i
means
tuple
h
~
xi
matc
hes
the
v
ariable
declaration
~
y
:
~
T
.
Judgmen
t
E
`
P
:
e
means
pro
cess
P
has
eect
e.
Judgmen
ts:
E
`

go
o
d
en
vironmen
t
E
`
T
go
o
d
t
yp
e
T
E
`
x
:
T
go
o
d
name
x
of
t
yp
e
T
E
`
h
~
xi
:
h
~
y
:
~
T
i
go
o
d
message
~
x
matc
hing
~
y
:
~
T
E
`
P
:
e
go
o
d
pro
cess
P
with
eect
e
The
rules
dening
the
rst
three
judgmen
ts
are
standard.
107

Gordon
and
Jeffrey
Go
o
d
en
vironmen
ts,
t
yp
es,
and
names:
(En
v
?)
?
`

(En
v
x)
E
`
T
x
=
2
dom(E
)
E
;
x:
T
`

(T
yp
e
Name)
E
`

E
`
Name
(T
yp
e
Chan)
E
;
~
x:
~
T
`

fn(e)

dom(E
)
[
f
~
xg
E
`
Ch(
~
x
:
~
T
)e
(Name
x)
E
0
;
x:T
;
E
00
`

E
0
;
x:
T
;
E
00
`
x
:
T
The
next
judgmen
t,
E
`
h
~
xi
:
h
~
y
:
~
T
i,
is
an
auxiliary
judgmen
t
used
for
t
yping
output
pro
cesses;
it
is
used
in
the
rule
(Pro
c
Output)
to
c
hec
k
that
the
message
h
~
xi
sen
t
on
a
c
hannel
of
t
yp
e
Ch(
~
y
:
~
T
)e
matc
hes
the
v
ariable
declaration
~
y
:
~
T
.
Go
o
d
message:
(Msg
hi)
E
`

E
`
hi
:
hi
(Msg
x)
(where
y
=
2
f
~
y
g
[
dom(E
))
E
`
h
~
xi
:
h
~
y
:
~
T
i
E
`
x
:
(T
f
~
y
 
~
xg)
E
`
h
~
x;
xi
:
h
~
y
:
~
T
;
y
:
T
i
Finally
,
here
are
the
rules
for
t
yping
pro
cesses.
The
eect
of
a
pro
cess
is
an
upp
er
b
ound;
the
rule
(Pro
c
Subsum)
allo
ws
us
to
increase
this
upp
er
b
ound.
In
tuitions
for
all
the
other
rules
w
ere
explained
in
the
previous
section.
Go
o
d
pro
cesses:
(Pro
c
Subsum)
(where
e

e
0
and
fn(e
0
)

dom(E
))
E
`
P
:
e
E
`
P
:
e
0
(Pro
c
Output)
E
`
x
:
Ch
(
~
y
:
~
T
)e
E
`
h
~
xi
:
h
~
y
:
~
T
i
E
`
out
xh
~
xi
:
(ef
~
y
 
~
x
g)
(Pro
c
Input)
(where
fn(e
 e
0
)

dom(E
))
E
`
x
:
Ch
(
~
y
:
~
T
)e
0
E
;
~
y
:
~
T
`
P
:
e
E
`
inp
x(
~
y
:
~
T
);
P
:
e
 e
0
(Pro
c
Cond)
E
`
x
:
T
E
`
y
:
T
E
fx y
g
`
P
fx 
y
g
:
e
P
fx y
g
E
`
Q
:
e
Q
E
`
if
x
=
y
then
P
else
Q
:
e
P
_
e
Q
(Pro
c
Res)
(where
x
=
2
fn(e))
E
;
x:T
`
P
:
e
E
`
new
(x:T
);
P
:
e
(Pro
c
P
ar)
E
`
P
:
e
P
E
`
Q
:
e
Q
E
`
P
j
Q
:
e
P
+
e
Q
108

Gordon
and
Jeffrey
(Pro
c
Rep
eat)
E
`
P
:
[
]
E
`
rep
eat
P
:
[
]
(Pro
c
Stop)
E
`

E
`
stop
:
[
]
(Pro
c
Begin)
(where
fn(L)

dom(E
))
E
`
P
:
e
E
`
b
egin
L;
P
:
e
 [L]
(Pro
c
End)
(where
fn(L)

dom(E
))
E
`
P
:
e
E
`
end
L;
P
:
e
+
[L]
Section
5
presen
ts
our
main
t
yp
e
safet
y
result,
Theorem
5.2,
that
E
`
P
:
[
]
implies
P
is
safe.
Lik
e
most
t
yp
e
systems,
ours
is
incomplete.
There
are
safe
pro
cesses
that
are
not
t
yp
eable
in
our
system.
F
or
example,
w
e
cannot
assign
the
pro
cess
if
x
=
x
then
stop
else
(end
x;
stop
)
the
empt
y
eect,
and
y
et
it
is
p
erfectly
safe.
4
Applications
In
this
section,
w
e
presen
t
some
examples
of
using
corresp
ondence
assertions
to
v
alidate
safet
y
prop
erties
of
comm
unication
proto
cols.
F
or
more
examples,
including
examples
with
cryptographic
proto
cols
whic
h
are
secure
against
ex-
ternal
attac
k
ers,
see
the
companion
pap
er
[9].
4.1
T
r
ansmit-A
cknow
le
dge
Handshake
Recall
the
un
t
yp
ed
sender
and
receiv
er
co
de
from
Section
2.
Supp
ose
w
e
mak
e
the
t
yp
e
denitions:
Msg

=
Name
A
ck
(a;
b;
msg
)

=
Ch()[ha;
b;
msg
i]
Host

=
Name
R
e
q
(a;
b)

=
Ch(msg
:Msg
;
ack
:A
ck
(a;
b;
msg
))[
]
109

Gordon
and
Jeffrey
Supp
ose
also
that
w
e
annotate
the
sender
and
receiv
er
co
de,
and
the
co
de
of
Example
1
as
follo
ws:
Snder
(a:Host
;
b:Host
;
c:R
e
q
(a;
b))

=
new
(msg
:
Msg
);
new
(ack
:A
ck
(a;
b;
msg
));
out
chmsg
;
ack
i;
inp
ack
();
end
ha;
b;
msg
i
R
cver
(a:
Host
;
b:Host
;
c:R
e
q
(a;
b))

=
inp
c(msg
:Msg
;
ack
:A
ck
(a;
b;
msg
));
b
egin
ha;
b;
msg
i;
out
ack
hi
Example1
(a:Host
;
b:Host
)

=
new
(c:R
e
q
(a;
b));
Snder
(a;
b;
c)
j
R
cver
(a;
b;
c)
W
e
can
then
c
hec
k
that
a:
Host
;
b:Host
`
Example1
(a;
b)
:
[
].
Since
the
system
has
the
empt
y
eect,
b
y
Theorem
5.2
it
is
safe.
It
is
routine
to
c
hec
k
that
Example
2
from
Section
2
also
has
the
empt
y
eect,
but
that
Example
3
cannot
b
e
t
yp
e-c
hec
k
ed
(as
to
b
e
exp
ected,
since
it
is
unsafe).
4.2
Hostname
L
o
okup
In
this
example,
w
e
presen
t
a
simple
hostname
lo
okup
system,
where
a
clien
t
b
wishing
to
ping
a
serv
er
a
can
con
tact
a
name
serv
er
query
,
to
get
a
net
w
ork
address
ping
for
a.
The
clien
t
can
then
send
a
ping
request
to
the
address
ping
,
and
get
an
ac
kno
wledgemen
t
from
the
serv
er.
W
e
shall
c
hec
k
t
w
o
prop
erties:

When
the
ping
clien
t
b
nishes,
it
b
eliev
es
that
the
ping
serv
er
a
has
b
een
pinged.

When
the
ping
serv
er
a
nishes,
it
b
eliev
es
that
it
w
as
con
tacted
b
y
the
ping
clien
t
b.
W
e
write
\a
w
as
pinged
b
y
b"
as
shorthand
for
ha;
bi,
and
\b
tried
to
ping
a"
for
hb;
a;
ai.
These
examples
are
w
ell-t
yp
ed,
with
t
yp
es
whic
h
w
e
dene
later
in
this
section.
110

Gordon
and
Jeffrey
W
e
program
the
ping
clien
t
and
serv
er
as
follo
ws.
PingClient
(a:Hostname
;
b:Hostname
;
query
:Query
)

=
new
(r
es
:
R
es
(a));
out
query
ha;
r
es
i;
inp
r
es
(ping
:
Ping
(a));
new
(ack
:
A
ck
(a;
b));
b
egin
\b
tried
to
ping
a";
out
ping
hb;
ack
i;
inp
ack
();
end
\a
w
as
pinged
b
y
b"
PingServer
(a
:
Hostname
;
ping
:
Ping
(a))

=
rep
eat
inp
ping
(b
:
Hostname
;
ack
:
A
ck
(a;
b));
b
egin
\a
w
as
pinged
b
y
b";
end
\b
tried
to
ping
a";
out
ack
hi
If
these
pro
cesses
are
safe,
then
an
y
ping
request
and
resp
onse
m
ust
come
as
matc
hing
pairs.
In
practice,
the
name
serv
er
w
ould
require
some
data
structure
suc
h
as
a
hash
table
or
database,
but
for
this
simple
example
w
e
just
use
a
large
if-statemen
t:
NameServer
(
query
:Query
;
h
1
:Hostname
;
:
:
:
;
h
n
:
Hostname
;
ping
1
:Ping
(h
1
);
:
:
:
;
ping
n
:Ping
(h
n
)
)

=
rep
eat
inp
query
(h;
r
es
);
if
h
=
h
1
then
out
r
es
hping
1
i
else



if
h
=
h
n
then
out
r
es
hping
n
i
else
stop
T
o
get
the
system
to
t
yp
e-c
hec
k,
w
e
use
the
follo
wing
t
yp
es:
Hostname

=
Name
A
ck
(a;
b)

=
Ch()[\a
w
as
pinged
b
y
b"]
Ping
(a)

=
Ch(b:Hostname
;
ack
:
A
ck
(a;
b))[\b
tried
to
ping
a"]
R
es
(a)

=
Ch(ping
:Ping
(a))[
]
Query

=
Ch(a:Hostname
;
r
es
:R
es
(a))[
]
111

Gordon
and
Jeffrey
The
most
subtle
part
of
t
yp
e-c
hec
king
the
system
is
the
conditional
in
the
name
serv
er.
A
t
ypical
branc
h
is:
h
i
:
Hostname
;
ping
i
:
Ping
(h
i
);
h
:
Hostname
;
r
es
:
R
es
(h)
`
if
h
=
h
i
then
out
r
es
hping
i
i
else



:
[
]
When
t
yp
e-c
hec
king
the
then-branc
h,
(Pro
c
Cond)
assumes
h
=
h
i
b
y
apply-
ing
a
substitution
to
the
en
vironmen
t:
(h
i
:
Hostname
;
ping
i
:
Ping
(h
i
);
h
:
Hostname
;
r
es
:
R
es
(h))fh 
h
i
g
=
(h
i
:
Hostname
;
ping
i
:
Ping
(h
i
);
r
es
:
R
es
(h
i
))
In
this
en
vironmen
t,
w
e
can
t
yp
e-c
hec
k
the
then-branc
h:
h
i
:
Hostname
;
ping
i
:
Ping
(h
i
);
r
es
:
R
es
(h
i
)
`
out
r
es
hping
i
i
:
[
]
If
(Pro
c
Cond)
did
not
apply
the
substitution
to
the
en
vironmen
t,
this
example
could
not
b
e
t
yp
e-c
hec
k
ed,
since:
h
i
:
Hostname
;
ping
i
:
Ping
(h
i
);
h
:
Hostname
;
r
es
:
R
es
(h)
0
out
r
es
hping
i
i
:
[
]
4.3
F
unctions
It
is
t
ypical
to
co
de
the
-calculus
in
to
the

-calculus,
using
a
return
c
hannel
k
as
the
destination
for
the
result.
F
or
instance,
the
hostname
lo
okup
example
of
the
previous
section
can
b
e
rewritten
in
the
st
yle
of
a
remote
pro
cedure
call.
The
clien
t
and
serv
er
are
no
w:
PingClient
(a:Hostname
;
b:Hostname
;
query
:Query
)

=
let
(ping
:
Ping
(a))
=
query
hai;
b
egin
\b
tried
to
ping
a";
let
()
=
ping
hbi;
end
\a
w
as
pinged
b
y
b"
PingServer
(a
:
Hostname
;
ping
:
Ping
(a))

=
fun
ping
(b:Hostname
)
f
b
egin
\a
w
as
pinged
b
y
b";
end
\b
tried
to
ping
a";
return
hi
g
112

Gordon
and
Jeffrey
The
name
serv
er
is
no
w:
NameServer
(
query
:Query
;
h
1
:Hostname
;
:
:
:
;
h
n
:
Hostname
;
ping
1
:Ping
(h
1
);
:
:
:
;
ping
n
:Ping
(h
n
)
)

=
fun
query
(h:Hostname
)
f
if
h
=
h
1
then
return
hping
1
i
else



if
h
=
h
n
then
return
hping
n
i
else
stop
g
In
order
to
pro
vide
t
yp
es
for
these
examples,
w
e
ha
v
e
to
pro
vide
a
function
t
yp
e
with
latent
ee
cts.
These
eects
are
pr
e
c
ondition/p
ostc
ondition
pairs,
whic
h
act
lik
e
Hoare
triples.
In
the
t
yp
e
(
~
x:
~
T
)e
!
(
~
y
:
~
U
)e
0
w
e
ha
v
e
a
precondition
e
whic
h
the
callee
m
ust
satisfy
,
and
a
p
ostcondition
e
0
whic
h
the
caller
m
ust
satisfy
.
F
or
example,
the
t
yp
es
for
the
hostname
lo
okup
example
are:
Ping
(a)

=
(b:Hostname
)[\b
tried
to
ping
a"]
!
()[\a
w
as
pinged
b
y
b"]
Query

=
(a:Hostname
)[
]
!
(ping
:Ping
(a))[
]
whic
h
sp
ecies
that
the
remote
ping
call
has
a
precondition
\b
tried
to
ping
a"
and
a
p
ostcondition
\a
w
as
pinged
b
y
b".
This
can
b
e
co
ded
in
to
the

-calculus
using
a
translation
[17]
in
con
tin
u-
ation
passing
st
yle.
fun
f
(
~
x:
~
T
)
fP
g

=
rep
eat
inp
f
(
~
x:
~
T
;
k
:Ch(
~
y
:
~
U
)e
0
);
P
let
(
~
y
:
~
U
)
=
f
h
~
xi;
P

=
new
(k
:Ch(
~
y
:
~
U
)e
0
);
out
f
h
~
x
;
k
i;
inp
k
(
~
y
:
~
U
);
P
return
h
~
z
i

=
out
k
h
~
z
i
(
~
x:
~
T
)e
!
(
~
y
:
~
U
)e
0

=
Ch(
~
x:
~
T
;
k
:Ch(
~
y
:
~
U
)e
0
)e
This
translation
is
standard,
except
for
the
t
yping.
It
is
routine
to
v
erify
its
soundness.
5
F
ormalizing
Corresp
ondence
Assertions
In
this
section,
w
e
giv
e
the
formal
denition
of
the
trace
seman
tics
for
the

-calculus
with
corresp
ondence
assertions,
whic
h
is
used
in
the
denition
of
a
safe
pro
cess.
W
e
then
state
the
main
result
of
this
pap
er,
whic
h
is
that
eect-free
pro
cesses
are
safe.
W
e
giv
e
the
trace
seman
tics
as
a
lab
elled
transition
system.
F
ollo
wing
Berry
and
Boudol
[3]
and
Milner
[17]
w
e
use
a
structural
congruence
P

Q,
and
giv
e
our
op
erational
seman
tics
up
to
.
113

Gordon
and
Jeffrey
Structural
Congruence:
P

Q
P

P
(Struct
Re)
Q

P
)
P

Q
(Struct
Symm)
P

Q;
Q

R
)
P

R
(Struct
T
rans)
P

Q
)
inp
x(
~
y
:
~
T
);
P

inp
x(
~
y
:
~
T
);
Q
(Struct
Input)
P

Q
)
new
(x:
T
);
P

new
(x:
T
);
Q
(Struct
Res)
P

Q
)
P
j
R

Q
j
R
(Struct
P
ar)
P

Q
)
rep
eat
P

rep
eat
Q
(Struct
Repl)
P
j
stop

P
(Struct
P
ar
Zero)
P
j
Q

Q
j
P
(Struct
P
ar
Comm)
(P
j
Q)
j
R

P
j
(Q
j
R
)
(Struct
P
ar
Asso
c)
rep
eat
P

P
j
rep
eat
P
(Struct
Repl
P
ar)
new
(x:T
);
(P
j
Q)

P
j
new
(x:
T
);
Q
(Struct
Res
P
ar)
(where
x
=
2
fn
(P
))
new
(x
1
:
T
1
);
new
(x
2
:T
2
);
P

new
(x
2
:T
2
);
new
(x
1
:T
1
);
P
(Struct
Res
Res)
(where
x
1
6=
x
2
;
x
1
=
2
fn(T
2
);
x
2
=
2
fn(T
1
))
There
are
four
actions
in
this
lab
elled
transition
system:

P
b
egin
L
    !
P
0
when
P
reac
hes
a
b
egin
L
assertion.

P
end
L
   !
P
0
when
P
reac
hes
an
end
L
assertion.

P
gen
hxi
   !
P
0
when
P
generates
a
new
name
x.

P

 !
P
0
when
P
can
p
erform
an
in
ternal
action.
F
or
example:
(new
(x:Name
);
b
egin
hxi;
end
hxi;
stop)
gen
hxi
   !
(b
egin
hxi;
end
hxi;
stop)
b
egin
hxi
    !
(end
hxi;
stop)
end
hxi
   !
(stop)
Next,
w
e
dene
the
syn
tax
of
actions

,
and
their
free
names
and
generated
names.
Actions:

;

::=
actions
b
egin
L
b
egin-ev
en
t
end
L
end-ev
en
t
gen
hxi
name
generation

in
ternal
114

Gordon
and
Jeffrey
F
ree
names,
fn(
),
and
generated
names,
gn
(
),
of
an
action

:
fn(
)

=
?
fn(b
egin
L)

=
fn(L)
fn(end
L)

=
fn
(L)
fn(gen
hxi)

=
fxg
gn(
)

=
?
gn(b
egin
L)

=
?
gn(end
L)

=
?
gn(gen
hxi

=
fxg
The
lab
elled
transition
system
P

 !
P
0
is
dened
here.
T
ransitions:
P

 !
P
0
out
xh
~
x
i
j
inp
x(
~
y
);
P

 !
P
f
~
y
 
~
xg
(T
rans
Comm)
if
x
=
x
then
P
else
Q

 !
P
(T
rans
Matc
h)
if
x
=
y
then
P
else
Q

 !
Q
(T
rans
Mismatc
h)
(where
x
6=
y
)
b
egin
L;
P
b
egin
L
    !
P
(T
rans
Begin)
end
L;
P
end
L
   !
P
(T
rans
End)
new
(x:T
);
P
gen
hxi
   !
P
(T
rans
Gen)
P

 !
P
0
)
P
j
Q

 !
P
0
j
Q
(T
rans
P
ar)
(where
gn(
)
\
fn(Q)
=
?)
P

 !
P
0
)
new
(x:
T
);
P

 !
new
(x:T
);
P
0
(T
rans
Res)
(where
x
=
2
fn(
))
P

P
0
;
P
0

 !
Q
0
;
Q
0

Q
)
P

 !
Q
(T
rans
)
F
rom
this
op
erational
seman
tics,
w
e
can
dene
the
traces
of
a
pro
cess,
with
reductions
P
s
 !
P
0
where
s
is
a
sequence
of
actions.
T
races:
s;
t
::=

1
;
:
:
:
;

n
trace
F
ree
names,
fn(s),
and
generated
names,
gn(s),
of
a
trace
s:
fn(
1
;
:
:
:
;

n
)

=
fn(
1
)
[



[
fn
(
n
)
gn(
1
;
:
:
:
;

n
)

=
gn(
1
)
[



[
gn
(
n
)
T
raced
transitions:
P
s
 !
P
0
P

P
0
)
P
"
 !
P
0
(T
race
)
P

 !
P
00
;
P
00
s
 !
P
0
)
P
;s
 !
P
0
(T
race
Action)
(where
fn(
)
\
gn(s)
=
?)
W
e
require
a
side-condition
on
(T
race
Action)
to
ensure
that
generated
names
are
unique,
otherwise
w
e
could
observ
e
traces
suc
h
as
(new
(x);
new
(y
);
stop
)
gen
hxi;gen
hxi
        !
(stop)
Ha
ving
formally
dened
the
trace
seman
tics
of
our

-calculus,
w
e
can
dene
when
a
trace
is
a
corresp
ondence:
this
is
when
ev
ery
end
L
has
a
distinct,
115

Gordon
and
Jeffrey
matc
hing
b
egin
L.
F
or
example:
b
egin
L;
end
L
is
a
corresp
ondence
b
egin
L;
end
L;
end
L
is
not
a
corresp
ondence
b
egin
L;
b
egin
L;
end
L;
end
L
is
a
corresp
ondence
W
e
formalize
this
b
y
coun
ting
the
n
um
b
er
of
b
egin
L
and
end
L
actions
there
are
in
a
trace.
Beginnings,
b
egins
(
),
and
endings,
ends
(
),
of
an
action

:
b
egins
(b
egin
L)

=
[L]
ends
(b
egin
L)

=
[
]
b
egins
(end
L)

=
[
]
ends
(end
L)

=
[L]
b
egins
(gen
hxi)

=
[
]
ends
(gen
hxi)

=
[
]
b
egins
(
)

=
[
]
ends
(
)

=
[
]
Beginnings,
b
egins
(s),
and
endings,
ends
(s),
of
a
trace
s:
b
egins
(
1
;
:
:
:
;

n
)

=
b
egins
(
1
)
+



+
b
egins
(
n
)
ends
(
1
;
:
:
:
;

n
)

=
ends
(
1
)
+



+
ends
(
n
)
Corresp
ondence:
A
trace
s
is
a
c
orr
esp
ondenc
e
if
and
only
if
ends
(s)

b
egins
(s).
A
pro
cess
is
safe
if
ev
ery
trace
is
a
corresp
ondence.
Safet
y:
A
pro
cess
P
is
safe
if
and
only
if
for
all
traces
s
and
pro
cesses
P
0
if
P
s
 !
P
0
then
s
is
a
corresp
ondence.
A
subtlet
y
of
this
denition
of
safet
y
is
that
although
w
e
w
an
t
eac
h
end-
ev
en
t
of
a
safe
pro
cess
to
b
e
preceded
b
y
a
distinct,
matc
hing
b
egin-ev
en
t,
a
trace
st
ma
y
b
e
a
corresp
ondence
b
y
virtue
of
a
later
b
egin-ev
en
t
in
t
matc
h-
ing
an
earlier
end-ev
en
t
in
s.
F
or
example,
a
trace
lik
e
end
L;
b
egin
L
is
a
corresp
ondence.
T
o
see
wh
y
our
denition
implies
that
a
matc
hing
b
egin-ev
en
t
m
ust
precede
eac
h
end-ev
en
t
in
eac
h
trace
of
a
safe
pro
cess,
supp
ose
a
safe
pro
cess
has
a
trace
s;
end
L;
t.
By
denition
of
traces,
the
pro
cess
also
has
the
shorter
trace
s;
end
L,
whic
h
m
ust
b
e
a
corresp
ondence,
since
it
is
a
trace
of
a
safe
pro
cess.
Therefore,
the
end-ev
en
t
end
L
is
preceded
b
y
a
matc
hing
b
egin-ev
en
t
in
s.
W
e
can
no
w
state
the
formal
result
of
the
pap
er,
Theorem
5.2,
that
ev
ery
eect-free
pro
cess
is
safe.
This
giv
es
us
a
comp
ositional
tec
hnique
for
v
erifying
the
safet
y
of
comm
unications
proto
cols.
It
follo
ws
from
a
sub
ject
reduction
result,
Theorem
5.1.
The
most
di√Ücult
parts
of
the
formal
dev
elopmen
t
to
c
hec
k
in
detail
are
the
parts
asso
ciated
with
the
(Pro
c
Cond)
rule,
b
ecause
of
116

Gordon
and
Jeffrey
its
use
of
a
substitution
applied
to
an
en
vironmen
t.
Theorem
5.1
(Sub
ject
Reduction)
Supp
ose
E
`
P
:
e.
(1)
If
P

 !
P
0
then
E
`
P
0
:
e.
(2)
If
P
b
egin
L
    !
P
0
then
E
`
P
0
:
e
+
[L].
(3)
If
P
end
L
   !
P
0
then
E
`
P
0
:
e
 [L],
and
L
2
e.
(4)
If
P
gen
hxi
   !
P
0
and
x
=
2
dom(E
)
then
E
;
x:
T
`
P
0
:
e
for
some
typ
e
T
.
Theorem
5.2
(Safet
y)
If
E
`
P
:
[
]
then
P
is
safe.
6
Related
W
ork
Corresp
ondence
assertions
are
not
new;
w
e
ha
v
e
already
discussed
prior
w
ork
on
corresp
ondence
assertions
for
cryptographic
proto
cols
[23,16
].
A
con
tribu-
tion
of
our
w
ork
is
the
idea
of
directly
expressing
corresp
ondence
assertions
b
y
adding
annotations
to
a
general
concurren
t
language,
in
our
case
the

-
calculus.
Giord
and
Lucassen
in
tro
duced
t
yp
e
and
eect
systems
[10,15
]
to
manage
side-eects
in
functional
programming.
There
is
a
substan
tial
literature;
recen
t
applications
include
memory
managemen
t
for
high-lev
el
[22
]
and
lo
w-lev
el
[5]
languages,
race-condition
a
v
oidance
[7],
and
access
con
trol
[20].
Early
t
yp
e
systems
for
the

-calculus
[17,19
]
fo
cus
on
regulating
the
data
sen
t
on
c
hannels.
Subsequen
t
t
yp
e
systems
also
regulate
pro
cess
b
eha
viour;
for
example,
session
t
yp
es
[21,11
]
regulate
pairwise
in
teractions
and
linear
t
yp
es
[14
]
help
a
v
oid
deadlo
c
ks.
A
recen
t
pap
er
[6]
explicitly
prop
oses
a
t
yp
e
and
eect
system
for
the

-calculus,
and
the
idea
of
laten
t
eects
on
c
hannel
t
yp
es.
This
idea
can
also
b
e
represen
ted
in
a
recen
t
general
framew
ork
for
concurren
t
t
yp
e
systems
[13
].
Still,
the
t
yp
es
of
our
system
are
dep
enden
t
in
the
sense
that
they
ma
y
include
the
names
of
c
hannels;
to
the
b
est
of
our
kno
wledge,
this
is
the
rst
dep
enden
t
t
yp
e
system
for
the

-calculus.
Another
system
of
dep
enden
t
t
yp
es
for
a
concurren
t
language
is
Flanagan
and
Abadi's
system
[7]
for
a
v
oiding
race
conditions
in
the
concurren
t
ob
ject
calculus
of
Gordon
and
Hankin
[8
].
The
rule
(Pro
c
Cond)
for
t
yping
name
equalit
y
if
x
=
y
then
P
else
Q
c
hec
ks
P
under
the
assumption
that
the
names
x
and
y
are
the
same;
w
e
formalize
this
b
y
substituting
y
for
x
in
the
t
yp
e
en
vironmen
t
and
the
pro
cess
P
.
Giv
en
that
names
are
the
only
kind
of
v
alue,
this
tec
hnique
is
simpler
than
the
standard
tec
hnique
from
dep
enden
t
t
yp
e
theory
[18
,2]
of
dening
t
yping
judgmen
ts
with
resp
ect
to
an
equiv
alence
relation
on
v
alues.
Honda,
V
asconcelos,
and
Y
oshida
[12]
also
use
the
tec
hnique
of
applying
substitutions
to
en
vironmen
ts
while
t
yp
e-c
hec
king.
117

Gordon
and
Jeffrey
7
Conclusions
The
long
term
ob
jectiv
e
of
this
w
ork
is
to
c
hec
k
secrecy
and
authen
ticit
y
prop-
erties
of
securit
y
proto
cols
b
y
t
yping.
This
pap
er
in
tro
duces
sev
eral
k
ey
ideas
in
the
minimal
y
et
general
setting
of
the

-calculus:
the
idea
of
expressing
corresp
ondences
b
y
b
egin-
and
end-annotations,
the
idea
of
a
dep
enden
t
t
yp
e
and
eect
system
for
pro
ving
corresp
ondences,
and
the
idea
of
using
laten
t
eects
to
t
yp
e
corresp
ondences
b
egun
b
y
one
pro
cess
and
ended
b
y
another.
Sev
eral
examples
demonstrate
the
promise
of
this
system.
Unlik
e
a
previous
approac
h
based
on
mo
del-c
hec
king,
t
yp
e-c
hec
king
corresp
ondence
assertions
is
not
limited
to
nite-state
systems.
A
companion
pap
er
[9
]
b
egins
the
w
ork
of
applying
these
ideas
to
crypto-
graphic
proto
cols
as
formalized
in
Abadi
and
Gordon's
spi-calculus
[1
],
and
has
already
pro
v
ed
useful
in
iden
tifying
kno
wn
issues
in
published
proto
cols.
Our
rst
t
yp
e
system
for
spi
is
sp
ecic
to
cryptographic
proto
cols
based
on
symmetric
k
ey
cryptograph
y
.
Instead
of
attac
hing
laten
t
eects
to
c
hannel
t
yp
es,
as
in
this
pap
er,
w
e
attac
h
them
to
a
new
t
yp
e
for
nonces,
to
formalize
a
sp
ecic
idiom
for
prev
en
ting
repla
y
attac
ks.
Another
a
v
en
ue
for
future
w
ork
is
t
yp
e
inference
algorithms.
The
t
yp
e
system
of
the
presen
t
pap
er
has
indep
enden
t
in
terest.
It
in
tro-
duces
the
ideas
in
a
more
general
setting
than
the
spi-calculus,
and
sho
ws
in
principle
that
corresp
ondence
assertions
can
b
e
t
yp
e-c
hec
k
ed
in
an
y
of
the
man
y
programming
languages
that
ma
y
b
e
reduced
to
the

-calculus.
Ac
kno
wledgemen
ts
W
e
had
useful
discussions
with
Andrew
Kennedy
and
Naoki
Koba
y
ashi.
T
on
y
Hoare
commen
ted
on
a
draft
of
this
pap
er.
Alan
Jerey
w
as
supp
orted
in
part
b
y
Microsoft
Researc
h
during
some
of
the
time
w
e
w
ork
ed
on
this
pap
er.
References
[1]
M.
Abadi
and
A.D.
Gordon.
A
calculus
for
cryptographic
proto
cols:
The
spi
calculus.
Information
and
Computation,
148:1{70,
1999.
[2]
H.
Barendregt.
Lam
b
da
calculi
with
t
yp
es.
In
S.
Abramsky
,
D.M.
Gabba
y
,
and
T.S.E.
Maibaum,
editors,
Handb
o
ok
of
L
o
gic
in
Computer
Scienc
e,
V
olume
II.
Oxford
Univ
ersit
y
Press,
1992.
[3]
G.
Berry
and
G.
Boudol.
The
c
hemical
abstract
mac
hine.
The
or
etic
al
Computer
Scienc
e,
96(1):217{248,
April
1992.
[4]
E.
Clark
e
and
W.
Marrero.
Using
formal
metho
ds
for
analyzing
securit
y
.
Av
ailable
at
http://www.cs.cmu.edu/m
arre
ro/a
bst
ract
.htm
l,
2000.
[5]
K.
Crary
,
D.
W
alk
er,
and
G.
Morrisett.
T
yp
ed
memory
managemen
t
in
a
calculus
of
capabilities.
In
26th
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
pages
262{275,
1999.
118

Gordon
and
Jeffrey
[6]
S.
Dal
Zilio
and
A.D.
Gordon.
Region
analysis
and
a

-calculus
with
groups.
In
Mathematic
al
F
oundations
of
Computer
Scienc
e
2000
(MF
CS2000),
v
olume
1893
of
L
e
ctur
es
Notes
in
Computer
Scienc
e,
pages
1{21.
Springer,
2000.
[7]
C.
Flanagan
and
M.
Abadi.
Ob
ject
t
yp
es
against
races.
In
J.C.M.
Baeten
and
S.
Mau
w,
editors,
CONCUR'99:
Concurr
ency
The
ory,
v
olume
1664
of
L
e
ctur
es
Notes
in
Computer
Scienc
e,
pages
288{303.
Springer,
1999.
[8]
A.D.
Gordon
and
P
.D.
Hankin.
A
concurren
t
ob
ject
calculus:
Reduction
and
t
yping.
In
Pr
o
c
e
e
dings
HLCL'98,
ENTCS.
Elsevier,
1998.
[9]
A.D.
Gordon
and
A.
Jerey
.
Authen
ticit
y
b
y
t
yping
for
securit
y
proto
cols.
In
14th
IEEE
Computer
Se
curity
F
oundations
Workshop.
IEEE
Computer
So
ciet
y
Press,
2001.
T
o
app
ear.
[10]
D.K.
Giord
and
J.M.
Lucassen.
In
tegrating
functional
and
imp
erativ
e
programming.
In
A
CM
Confer
enc
e
on
Lisp
and
F
unctional
Pr
o
gr
amming,
pages
28{38,
1986.
[11]
K.
Honda,
V.
V
asconcelos,
and
M.
Kub
o.
Language
primitiv
es
and
t
yp
e
discipline
for
structured
comm
unication-based
programming.
In
Eur
op
e
an
Symp
osium
on
Pr
o
gr
amming,
v
olume
1381
of
L
e
ctur
es
Notes
in
Computer
Scienc
e,
pages
122{128.
Springer,
1998.
[12]
K.
Honda,
V.
V
asconcelos,
and
N.
Y
oshida.
Secure
information
o
w
as
t
yp
ed
pro
cess
b
eha
viour.
In
Eur
op
e
an
Symp
osium
on
Pr
o
gr
amming,
Lectures
Notes
in
Computer
Science.
Springer,
2000.
[13]
A.
Igarashi
and
N.
Koba
y
ashi.
A
generic
t
yp
e
system
for
the
pi
calculus.
In
28th
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
pages
128{
141,
2001.
[14]
N.
Koba
y
ashi.
A
partially
deadlo
c
k-free
t
yp
ed
pro
cess
calculus.
A
CM
T
r
ansactions
on
Pr
o
gr
amming
L
anguages
and
Systems,
20:436{482,
1998.
[15]
J.M.
Lucassen.
T
yp
es
and
ee
cts,
towar
ds
the
inte
gr
ation
of
functional
and
imp
er
ative
pr
o
gr
amming.
PhD
thesis,
MIT,
1987.
Av
ailable
as
T
ec
hnical
Rep
ort
MIT/LCS/TR{408,
MIT
Lab
oratory
for
Computer
Science.
[16]
W.
Marrero,
E.M.
Clark
e,
and
S.
Jha.
Mo
del
c
hec
king
for
securit
y
proto
cols.
In
DIMA
CS
Workshop
on
Design
and
F
ormal
V
eric
ation
of
Se
curity
Pr
oto
c
ols,
1997.
Preliminary
v
ersion
app
ears
as
T
ec
hnical
Rep
ort
TR{CMU{CS{97{139,
Carnegie
Mellon
Univ
ersit
y
,
Ma
y
1997.
[17]
R.
Milner.
Communic
ating
and
Mobile
Systems:
the

-Calculus.
Cam
bridge
Univ
ersit
y
Press,
1999.
[18]
B.
Nordstr
om,
K.
P
etersson,
and
J.
Smith.
Pr
o
gr
amming
in
Martin-L
of
's
T
yp
e
The
ory:
A
n
Intr
o
duction.
Oxford
Univ
ersit
y
Press,
1990.
[19]
B.
Pierce
and
D.
Sangiorgi.
T
yping
and
subt
yping
for
mobile
pro
cesses.
Mathematic
al
Structur
es
in
Computer
Scienc
e,
6(5):409{454,
1996.
119

Gordon
and
Jeffrey
[20]
C.
Sk
alk
a
and
S.
Smith.
Static
enforcemen
t
of
securit
y
with
t
yp
es.
In
P
.
W
adler,
editor,
2000
A
CM
International
Confer
enc
e
on
F
unctional
Pr
o
gr
amming,
pages
34{45,
2000.
[21]
K.
T
ak
euc
hi,
K.
Honda,
and
M.
Kub
o.
An
in
teraction-based
language
and
its
t
yping
system.
In
Pr
o
c
e
e
dings
6th
Eur
op
e
an
Confer
enc
e
on
Par
al
lel
L
anguages
and
A
r
chite
ctur
e,
v
olume
817
of
L
e
ctur
es
Notes
in
Computer
Scienc
e,
pages
398{413.
Springer,
1994.
[22]
M.
T
ofte
and
J.-P
.
T
alpin.
Region-based
memory
managemen
t.
Information
and
Computation,
132(2):109{176,
1997.
[23]
T.Y.C.
W
o
o
and
S.S.
Lam.
A
seman
tic
mo
del
for
authen
tication
proto
cols.
In
IEEE
Symp
osium
on
Se
curity
and
Privacy,
pages
178{194,
1993.
120

MFPS
17
Preliminary
Version
Pseudo-comm
utativ
e
Monads
Martin
Hyland
Dept
of
Pur
e
Mathematics
and
Mathematic
al
Statistics
University
of
Cambridge
Wilb
erfor
c
e
R
o
ad,
Cambridge,
ENGLAND
and
John
P
o
w
er
1
L
ab
or
atory
for
the
F
oundations
of
Computer
Scienc
e
University
of
Edinbur
gh
King's
Buildings,
Edinbur
gh
EH9
3JZ,
SCOTLAND
Abstract
W
e
in
tro
duce
the
notion
of
pseudo-comm
utativ
e
monad
together
with
that
of
pseudo-
closed
2-category
,
the
leading
example
b
eing
giv
en
b
y
the
2-monad
on
C
at
whose
2-category
of
algebras
is
the
2-category
of
small
symmetric
monoidal
categories.
W
e
pro
v
e
that
for
an
y
pseudo-comm
utativ
e
2-monad
on
C
at,
its
2-category
of
algebras
is
pseudo-closed.
W
e
also
in
tro
duce
supplemen
tary
denitions
and
results,
and
w
e
illustrate
this
analysis
with
further
examples
suc
h
as
those
of
small
categories
with
nite
pro
ducts,
and
examples
arising
from
wiring,
in
teraction,
con
texts,
and
the
logic
of
Bunc
hed
Implication.
1
In
tro
duction
Symmetric
monoidal
categories,
often
with
a
little
extra
structure
and
sub
ject
to
some
extra
axioms,
suc
h
as
those
required
to
mak
e
symmetric
monoidal
structure
in
to
nite
pro
duct
or
nite
copro
duct
structure,
pla
y
a
fundamen
tal
foundational
role
in
m
uc
h
of
theoretical
computer
science.
F
or
instance,
they
ha
v
e
long
b
een
used
to
mo
del
con
texts,
t
ypically
but
not
only
when
in
the
form
of
nite
pro
duct
structure
(see
for
instance
[4]
and,
esp
ecially
relev
an
t
here,
[5
]).
They
ha
v
e
also
long
b
een
used
to
mo
del
a
parallel
op
erator
(see
for
instance
[9])
or
in
teraction
[1].
Occasionally
,
one
sees
t
w
o
symmetric
monoidal
1
This
w
ork
is
supp
orted
b
y
EPSR
C
gran
t
GR/M56333:
The
structure
of
programming
languages
:
syn
tax
and
seman
tics,
and
a
British
Council
gran
t
and
the
COE
budget
of
ST
A
Japan.
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Hyland
and
Po
wer
structures
in
teracting
with
eac
h
other,
for
instance
in
w
ork
on
linear
logic
or
more
recen
tly
on
Bunc
hed
Implication
[11].
Sev
eral
delicate
constructions
are
made
using
symmetric
monoidal
structure.
F
or
instance,
one
often
considers
the
free
symmetric
monoidal
category
,
p
ossibly
with
additional
structure,
on
1,
and
one
sometimes
sees
study
of
the
free
symmetric
monoidal
closed
category
on
a
symmetric
monoidal
category
.
One
also
sees
constructions
on
categories
p
ossessing
a
pair
of
symmetric
monoidal
structures
as
in
Bunc
hed
Implication.
This
all
motiv
ates
us
to
seek
a
calculus
of
symmetric
monoidal
categories,
p
ossibly
with
a
little
extra
structure
sub
ject
to
mild
axioms
as
illustrated
ab
o
v
e.
By
a
calculus,
w
e
mean
a
mathematical
accoun
t
of
what
constructions
one
can
mak
e
on
symmetric
monoidal
categories
and
still
obtain
a
symmet-
ric
monoidal
category
.
F
or
instance,
it
is
routine
to
v
erify
that
a
pro
duct
of
symmetric
monoidal
categories
is
symmetric
monoidal.
F
ormally
,
suc
h
a
cal-
culus
amoun
ts
to
study
of
the
structure
of
the
2-category
S
y
mM
on
of
small
symmetric
monoidal
categories
and
strong
symmetric
monoidal
functors.
It
has
long
b
een
kno
wn
that
this
is
an
instance
of
algebraic
structure
on
C
at
[2]
and
therefore
has
w
ell-b
eha
v
ed
limits
and
bicolimits,
in
particular
pro
ducts
and
bicopro
ducts
for
example.
But
is
the
2-category
S
y
mM
on,
or
at
least
the
v
arian
t
S
y
mM
on
s
of
small
symmetric
monoidal
categories
and
strict
symmet-
ric
monoidal
functors,
itself
a
symmetric
monoidal
category?
And
is
there
an
axiomatic
pro
of
of
suc
h
a
result
that
w
ould
apply
to
v
arian
ts
of
the
notion
of
small
symmetric
monoidal
category
suc
h
as
that
of
small
category
with
nite
pro
ducts?
P
ositiv
e
answ
ers
w
ould
substan
tially
increase
the
range
of
construc-
tions
a
v
ailable
for
use:
for
instance,
considering
the
free
structure
on
1
as
for
example
in
[5],
implicit
is
the
idea
that
structure
on
C
,
whic
h
is
isomorphic
to
C
at(1;
C
),
lifts
to
structure
on
the
category
of
structure
preserving
functors
from
F
(1)
to
C
.
There
is
go
o
d
reason
to
hop
e
that
the
answ
ers
to
these
questions
migh
t
b
e
p
ositiv
e.
A
small
symmetric
monoidal
category
is,
except
for
some
isomor-
phisms
rather
than
equalities,
a
comm
utativ
e
monoid
in
the
category
C
at,
And
the
category
of
comm
utativ
e
monoids,
C
M
on,
in
S
et,
is
a
symmetric
monoidal
closed
category
,
the
reason
b
eing
that
the
monad
T
on
S
et
for
whic
h
C
M
on
is
isomorphic
to
T
-Al
g
is
a
comm
utativ
e
monad
(the
notion
of
comm
u-
tativ
e
monad
app
earing
in
theoretical
computer
science
in
w
ork
suc
h
as
that
of
Moggi
on
computational
eects
[10]),
and
for
an
y
comm
utativ
e
monad
T
,
the
category
T
-Al
g
is
symmetric
monoidal
closed,
with
the
adjunction
b
et
w
een
T
-Al
g
and
S
et
b
eing
a
symmetric
monoidal
adjunction.
In
fact,
there
is
a
monad
T
on
C
at
for
whic
h
the
category
T
-Al
g
is
iso-
morphic
to
the
category
of
small
symmetric
monoidal
categories
and
strict
symmetric
monoidal
functors,
and
that
monad
has
a
unique
strength.
Ho
w-
ev
er,
that
strength
is
not
comm
utativ
e,
the
reason
b
eing
that
at
precisely
one
p
oin
t
where
one
requires
an
equalit
y
,
one
has
an
isomorphism.
And
con-
sequen
tly
,
S
y
mM
on
s
is
not
symmetric
monoidal
closed.
But
the
2-category
S
y
mM
on
do
es
ha
v
e
a
structure
that
is
a
mild
w
eak
ening
of
closed
structure,
122

Hyland
and
Po
wer
and
w
e
can
pro
v
e
that
result
axiomatically
,
with
axioms
that
hold
equally
of
the
2-category
of
small
categories
with
nite
pro
ducts
and
of
v
arian
ts.
So
this
pap
er
is
dev
oted
to
sp
elling
out
what
that
mild
2-categorical
generalisation
of
closed
structure
is,
what
the
corresp
onding
generalisation
of
the
notion
of
com-
m
utativ
e
monad
is,
and
giving
the
pro
of
that
for
ev
ery
pseudo-comm
utativ
e
monad
on
C
at,
the
2-category
of
algebras
and
pseudo-maps
of
algebras
is
pseudo-closed.
Inevitably
,
with
the
complexit
y
of
coherence
required
for
our
denitions,
w
e
m
ust
b
e
v
ery
sk
etc
h
y
with
detail
for
a
short
conference
pap
er.
But
m
uc
h
more
detail
app
ears
in
[6].
A
denition
pro
v
ably
(with
considerable
eort)
equiv
alen
t
to
one
w
e
ha
v
e
here
w
as
in
tro
duced
b
y
Max
Kelly
in
[7],
but,
as
he
recognised
at
the
time,
his
axioms
w
ere
to
o
complicated
to
b
e
denitiv
e.
The
pap
er
is
organised
v
ery
simply:
w
e
dene
the
notions
of
pseudo-
comm
utativit
y
and
symmetry
for
a
pseudo-comm
utativit
y
,
giv
en
a
2-monad
on
C
at,
and
presen
t
our
leading
example,
in
Section
2;
w
e
dene
the
no-
tion
of
pseudo-closedness
in
Section
3;
and
w
e
outline
a
pro
of
that
T
-Al
g
is
pseudo-closed
if
T
has
a
pseudo-comm
utativit
y
in
Section
4.
2
Pseudo-comm
utativit
y
for
a
2-monad
W
e
refer
the
reader
to
[2]
for
2-categorical
terminology:
unfortunately
,
there
is
not
space
to
include
m
uc
h
of
it
here.
Let
T
b
e
a
2-monad
on
C
at,
for
instance
the
2-monad
for
small
symmetric
strict
monoidal
categories.
Then
T
p
ossesses
a
unique
strength
t
A;B
:
A

T
B
 !
T
(A

B
)
and,
b
y
symmetry
,
a
unique
costrength
t

A;B
:
T
A

B
 !
T
(A

B
)
The
2-functorial
b
eha
viour
of
T
corresp
onds
to
t
via
comm
utativit
y
of
A
in
-
[B
;
A

B
]
[A;
B
]

T
A
t
-
T
([A;
B
]

A)
[T
B
;
A

T
B
]
in
?
[T
B
;
t]
-
[T
B
;
T
(A

B
)]
T
?
[T
A;
T
B
]

T
A
T

T
A
?
ev
-
T
B
T
ev
?
Denition
2.1
A
pseudo-c
ommutativity
for
a
2-monad
(T
;
;

)
is
an
isomor-
123

Hyland
and
Po
wer
phic
mo
dication
T
A

T
B
t

-
T
(A

T
B
)
T
(t)
-
T
2
(A

B
)
+

A;B
T
(T
A

B
)
t
?
T
t

-
T
2
(A

B
)

AB
-
T
(A

B
)

AB
?
suc
h
that
the
follo
wing
three
strength
axioms,
t
w
o

axioms
and
t
w
o

axioms
hold.
(i)

AB
;C

(t
A;B

T
C
)
=
t
A;B
C

(A


B
;C
)
(ii)

A;B
C

(T
A

t
B
;C
)
=

AB
;C

(t

A;B

T
C
)
(iii)

A;B
C

(T
A

t

B
;C
)
=
t

AB
;C

(
A;B

C
)
(iv)

A;B

(
A

T
B
)
is
an
iden
tit
y
mo
dication
(v)

A;B

(T
A


B
)
is
an
iden
tit
y
mo
dication
(vi)

A;B

(
A

T
B
)
is
equal
to
the
pasting
T
2
A

T
B
t

-
T
(T
A

T
B
)
T
t

-
T
2
(A

T
B
)
T
2
t
-
T
3
(A

B
)
+
T

A;B
T
(T
2
A

B
)
t
?
T
2
(T
A

B
)
T
t
?
T
2
t

-
T
3
(A

B
)
T

AB
-
T
2
(A

B
)
T

AB
?
+

T
A;B
T
2
(T
A

B
)
T
t

?

T
AB
-
T
(T
A

B
)

T
AB
?
T
t

-
T
2
(A

B
)

T
(AB
)
?

AB
-
T
(A

B
)

AB
?
(vii)
the
dual
of
the
ab
o
v
e

axiom
There
is
a
little
redundancy
here,
as
follo
ws.
Prop
osition
2.2
A
ny
two
of
the
str
ength
axioms
implies
the
thir
d.
If
the
mo
dication

w
ere
an
iden
tit
y
,
T
w
ould
b
e
a
comm
utativ
e
2-monad
[7
,8]
and
the
axioms
w
ould
all
b
e
redundan
t.
But
in
our
leading
example,
where
T
is
the
2-monad
on
C
at
for
symmetric
strict
monoidal
categories,

is
not
an
iden
tit
y
but
rather
is
determined
b
y
a
non-trivial
symmetry
.
W
e
shall
so
on
sp
ell
out
that
example
in
detail,
but
rst
w
e
in
tro
duce
a
further
symmetry
condition
on
a
pseudo-comm
utativit
y:
w
e
do
not
use
this
condition
for
our
main
results,
but
it
simplies
analysis
of
the
examples
and
w
e
b
eliev
e
124

Hyland
and
Po
wer
it
will
b
e
useful
in
practice,
for
example
in
relation
to
Bunc
hed
Implication
[11
],
as
w
e
shall
explain
b
elo
w.
Denition
2.3
A
pseudo-comm
utativit
y

is
symmetric
when
T
c
A;B


A;B

c
T
B
;T
A
is
the
in
v
erse
of

B
;A
.
The
simplication
that
this
denition
allo
ws
is
giv
en
b
y
the
follo
wing
prop
osition.
Prop
osition
2.4
A
n
isomorphic
mo
dic
ation

as
ab
ove
is
a
symmetric
pseudo-
c
ommutativity
if
the
symmetry
axiom,
one
str
ength
axiom,
one

axiom,
and
one

axiom
hold.
Finally
,
w
e
sp
ell
out
our
leading
example
in
detail.
Most
of
the
other
examples,
whic
h
w
e
list
afterw
ards,
w
ork
similarly
.
Example
2.5
Let
T
b
e
the
2-monad
for
symmetric
strict
monoidal
categories.

Giv
en
a
category
A,
the
category
T
A
has
as
ob
jects
sequences
a
1
:
:
:
a
n
of
ob
jects
of
A
(with
maps
generated
b
y
symmetries
and
the
maps
of
A);
the
tensor
pro
duct
is
concatenation.

Giv
en
t
w
o
categories
A
and
B
,
the
category
T
A

T
B
has
as
ob
jects
pairs
((a
1
:
:
:
a
n
);
(b
1
:
:
:
b
m
))
and
the
t
w
o
maps
T
A

T
B
 !
T
(A

B
)
tak
e
suc
h
pairs
to
the
sequences
of
all
(a
i
;
b
j
)
ordered
according
to
the
t
w
o
p
ossible
lexicographic
orderings.
In
fact
T
A

T
B
t

-
T
(T
A

B
)
T
(t)
-
T
2
(A

B
)

AB
-
T
(A

B
)
giv
es
the
ordering
(a
1
;
b
1
);
(a
1
;
b
2
);
:
:
:
in
whic
h
the
rst
co
ordinate
tak
es
precedence,
while
T
A

T
B
t
-
T
(T
A

B
)
T
(t

)
-
T
2
(A

B
)

AB
-
T
(A

B
)
giv
es
the
ordering
(a
1
;
b
1
);
(a
2
;
b
1
);
:
:
:
in
whic
h
the
second
co
ordinate
tak
es
precedence.

The
comp
onen
t

A;B
of
the
mo
dication
is
giv
en
b
y
the
unique
symmetry
mediating
b
et
w
een
the
t
w
o
lexicographic
orders.
125

Hyland
and
Po
wer
W
e
no
w
indicate
the
force
of
our
v
arious
axioms
as
they
app
ear
here.

The
strength
axioms
concern
the
v
arious
lexicographic
orderings
of
the
se-
quences
(a
i
;
b
j
;
c
k
)
where
again
there
is
just
one
a
i
(or
b
j
or
c
k
).
V
arious
orderings
are
iden
tied
and
as
a
result
there
are
in
eac
h
case
prima
facie
t
w
o
pro
cesses
for
mediating
b
et
w
een
the
orderings:
these
are
equal.
So
the
axioms
reect
the
fact
that
there
is
a
unique
w
a
y
to
mediate
b
et
w
een
a
pair
of
orderings.

The

axioms
express
the
fact
that
the
t
w
o
lexicographic
orderings
of
the
(a
i
;
b
j
)
are
equal
if
one
of
n
or
m
is
1.

The

axioms
tak
e
more
explaining.
T
ak
e
a
sequence
a
1
;
:
:
:
;
a
n
of
se-
quences
a
i
1
;
:
:
:
a
i
m(i)
.
Concatenation
giv
es
a
sequence
a
i
j
where
the
order
is
determined
b
y
the
precedence
(i;
j
):
that
is,
i
tak
es
precedence
o
v
er
j
.
T
ak
e
this
concatenated
sequence
together
with
a
sequence
b
1
;
:
:
:
;
b
p
.
Then

A;B

(
A

T
B
)
mediates
b
et
w
een
the
order
on
the
(a
i
j
;
b
k
)
with
prece-
dence
(i;
j;
k
)
and
that
with
precedence
(k
;
i;
j
).
Ho
w
ev
er
w
e
can
also
use


T

A;B

t

to
mediate
b
et
w
een
the
orders
determined
b
y
(i;
j;
k
)
and
(i;
k
;
j
),
and
use


T
t



T
A;B
to
mediate
b
et
w
een
the
orders
determined
b
y
(i;
k
;
j
)
and
(k
;
i;
j
).
Comp
osing
these
t
w
o
giv
es
the
rst.
So
again
the
axioms
reect
the
fact
that
there
is
a
unique
w
a
y
to
mediate
b
et
w
een
a
pair
of
orderings.

The
symmetry
axiom
just
sa
ys
that
if
y
ou
sw
ap
the
order
t
wice,
y
ou
return
to
where
y
ou
b
egan.
F
urther
examples
of
symmetric
pseudo-comm
utativ
e
monads,
for
whic
h
w
e
shall
not
sp
ell
out
the
details,
are
giv
en
b
y
those
for
(i)
Symmetric
monoidal
categories.
(ii)
Categories
with
strictly
asso
ciativ
e
nite
pro
ducts.
(Categories
with
strictly
asso
ciativ
e
nite
copro
ducts.)
(iii)
Categories
with
nite
pro
ducts.
(Categories
with
nite
copro
ducts.)
(iv)
Categories
with
an
action
of
a
symmetric
strictly
asso
ciativ
e
monoidal
category
.
(v)
Symmetric
strict
monoidal
categories
with
a
strict
monoidal
endofunctor.
(vi)
Symmetric
monoidal
categories
with
a
strong
monoidal
endofunctor.
These
examples
are
used
widely
for
mo
delling
con
texts,
or
parallelism,
or
in
teraction
in
computer
science
[1,4,5,9
],
and
one
can
build
com
binations
as
used
in
[11]
or
v
arian
ts.
In
more
detail,
nite
pro
ducts
are
used
extensiv
ely
for
mo
delling
con
texts,
for
instance
in
[4].
A
subtle
com
bination
of
nite
pro
ducts
and
symmetric
monoidal
structure
is
used
to
mo
del
parallelism
in
[9
].
And
symmetric
monoidal
structure
is
used
to
mo
del
in
teraction
in
[1].
And
in
curren
t
researc
h,
Plotkin
is
using
a
category
with
an
action
of
a
sym-
metric
monoidal
category
to
mo
del
call-b
y-name
and
call-b
y-v
alue,
along
the
lines
of
symmetric
premonoidal
categories
b
eing
represen
ted
as
the
action
of
126

Hyland
and
Po
wer
a
symmetric
monoidal
category
on
a
category
[12
].
F
or
a
non-example
of
the
symmetry
condition,
w
e
b
eliev
e
that
there
is
a
natural
pseudo-comm
utativit
y
on
the
2-monad
for
braided
monoidal
categories
whic
h
is
not
symmetric.
W
e
can
pro
v
e
that
our
denition
of
symmetric
pseudo-comm
utativit
y
im-
plies
that
adum
brated
b
y
Kelly
in
[7],
whic
h
tells
us
Theorem
2.6
If
T
is
a
symmetric
pseudo-c
ommutative
monad
on
C
at,
then
T
lifts
to
a
2-monad
on
the
2-c
ate
gory
S
y
mM
on
of
smal
l
symmetric
monoidal
c
ate
gories
and
str
ong
symmetric
monoidal
functors.
This
result
seems
lik
ely
to
relate
to
Bunc
hed
Implication
[11
],
where
the
underlying
rst
order
structure
in
v
olv
es
a
symmetric
monoidal
category
,
so
an
ob
ject
of
S
y
mM
on,
that
p
ossesses
nite
pro
ducts,
so
has
T
-structure
for
the
symmetric
pseudo-comm
utativ
e
monad
for
small
categories
with
nite
pro
ducts.
W
e
do
not
immediately
ha
v
e
a
more
direct
relationship
with
linear
logic,
as
the
latter
in
v
olv
es
a
comonad
!,
and
the
2-category
of
small
categories
equipp
ed
with
a
comonad
is
not
an
example
of
the
2-category
of
algebras
for
a
pseudo-comm
utativ
e
2-monad.
3
Pseudo-closed
2-categories
In
this
section,
w
e
dene
the
notion
of
a
pseudo-closed
2-category
.
Denition
3.1
A
pseudo-close
d
2-category
consists
of
a
2-category
K
,
a
2-
functor
[ ;
 ]
:
K
op

K
 !
K
and
a
2-functor
V
:
K
 !
C
at,
together
with
an
ob
ject
I
of
K
and
transfor-
mations
j
,
e,
i,
k
,
with
comp
onen
ts

j
A
:
I
 !
[A;
A]
pseudo-dinatural
in
A,

e
A
:
[I
;
A]
 !
A
natural
in
A,
and
i
A
:
A
 !
[I
;
A]
pseudo-natural
in
A,

k
A;B
;C
:
[B
;
C
]
 !
[[A;
B
];
[A;
C
]]
natural
in
B
and
C
and
dinatural
in
A,
suc
h
that
V
[ ;
 ]
=
K
( ;
 )
:
K
op

K
 !
C
at,
e
and
i
form
a
retract
equiv
alence,
and
(i)
I
j
B
-
[B
;
B
]
@
@
@
@
@
j
[A;B
]
R
[[A;
B
];
[A;
B
]]
k
A
?
127

Hyland
and
Po
wer
(ii)
[A;
C
]
k
A
-
[[A;
A];
[A;
C
]]
[A;
C
]
w
w
w
w
w
w
w
w
w

e
[A;C
]
[I
;
[A;
C
]]
[j
A
;
[A;
C
]]
?
(iii)
[C
;
D
]
k
A
-
[[A;
C
];
[A;
D
]]
k
[A;B
]
-
[[[A;
B
];
[A;
C
]];
[[A;
B
];
[A;
D
]]]
[[B
;
C
];
[B
;
D
]]
k
B
?
[[B
;
C
];
k
A
]
-
[[B
;
C
];
[[A;
B
];
[A;
D
]]]
[k
A
;
[[A;
B
];
[A;
D
]]]
?
(iv)
[A;
B
]
k
I
-
[[I
;
A];
[I
;
B
]]
@
@
@
@
@
[e
A
;
B
]
R
[[I
;
A];
B
]
[[I
;
A];
e
B
]
?
(v)
The
map
K
(A;
A)
=
V
[A;
A]
 !
V
[I
;
[A;
A]]
=
K
(I
;
[A;
A])
induced
b
y
i
[A;A]
tak
es
1
A
to
j
A
.
W
e
compare
this
denition
with
that
of
closed
category
in
[3],
where
the
theory
of
enric
hed
categories
w
as
in
tro
duced.
Its
primary
denition
w
as
that
of
a
closed
category;
it
then
dened
monoidal
closed
categories
and
pro
ceeded
from
there.
The
only
reason
more
mo
dern
accoun
ts
start
with
the
notion
of
monoidal
category
is
b
ecause
it
is
rst
order
structure:
but
the
closed
structure
is
t
ypically
more
primitiv
e.
Giv
en
our
aims,
w
e
ask
for
2-categories,
2-functors,
and
2-natural
or
2-
dinatural
transformations
where
[3
]
drops
the
prex
2:
there
is
one
signican
t
case
of
pseudo-naturalit
y
.
Moreo
v
er,
as
K
( ;
 )
is
a
2-functor
in
to
C
at,
the
co
domain
for
V
should
b
e
C
at
rather
than
S
et
as
in
[3].
Allo
wing
for
these
c
hanges,
our
v
e
en
umerated
conditions
corresp
ond
to
Eilen
b
erg
and
Kelly's
v
e
axioms.
The
fact
that
e
is
a
retract
equiv
alence
128

Hyland
and
Po
wer
rather
than
an
isomorphism
as
in
[3]
is
signican
t.
W
e
ha
v
e
no
c
hoice
if
w
e
are
to
include
our
leading
example:
one
migh
t
hop
e
that
the
2-category
of
small
symmetric
monoidal
categories
w
ould
ha
v
e
in
v
ertible
e,
but
it
do
es
not;
and
b
ecause
e
is
not
an
isomorphism,
w
e
do
not
ha
v
e
the
Eilen
b
erg
and
Kelly
v
ersions
of
conditions
2
and
4
whic
h
are
expressed
in
terms
of
i;
and
those
conditions
w
ould
fail
in
our
leading
example.
Moreo
v
er
i
is
only
pseudo-
natural
in
examples.
W
e
note
that
w
e
are
able
to
giv
e
our
restricted
denition
so
that
T
-Al
g
will
b
e
an
example
where
all
the
structure
maps
other
than
i
A
are
strict
maps
of
T
-algebras.
This
is
not
the
most
general
p
ossible
notion
of
pseudo-closedness.
Ev
en
Eilen
b
erg
and
Kelly
could
ha
v
e
ask
ed
for
an
isomorphism
b
et
w
een
V
[ ;
 ]
and
K
( ;
 ):
their
c
hoice
of
equalit
y
means
that
a
monoidal
category
sub
ject
to
the
usual
adjoin
tness
condition
need
not
b
e
closed
in
their
sense.
But
our
examples
allo
w
us
considerable
strictness,
so
w
e
tak
e
adv
an
tage
of
that
to
pro
vide
a
relativ
ely
simple
denition.
On
the
other
hand,
it
do
es
not
con
tain
all
axioms
that
hold
of
our
class
of
examples
either.
In
particular,
our
pseudo-natural
transformation
i
and
our
pseudo-dinatural
transformation
j
satisfy
strictness
conditions
along
the
lines
that,
for
some
sp
ecic
classes
of
maps,
the
isomorphism
giv
en
b
y
pseudo-
naturalit
y
is
in
fact
an
iden
tit
y
.
Ho
w
ev
er,
at
presen
t,
w
e
ha
v
e
no
theorems
that
mak
e
use
of
suc
h
facts,
and
adding
them
to
the
denition
w
ould
complicate
rather
than
simplify
it,
so
w
e
ha
v
e
not
in
tro
duced
them
as
axioms.
4
Pseudo-closed
structure
on
T
-Al
g
W
e
consider
the
2-category
T
-Al
g
of
strict
T
-algebras
and
pseudo-maps
of
T
-algebras
as
dev
elop
ed
in
[2],
for
a
2-monad
T
on
C
at.
W
e
can
readily
generalise
b
ey
ond
C
at,
but
this
con
tains
the
examples
of
primary
in
terest
to
us:
the
2-category
of
small
symmetric
monoidal
categories
and
strong
sym-
metric
monoidal
functors
is
an
example,
as
is
the
category
of
small
categories
with
nite
pro
ducts
and
nite
pro
duct
preserving
functors,
etcetera.
W
e
write
A
=
(A;
a)
for
a
t
ypical
T
-algebra.
A
pseudo-map
(f
;

f
)
:
A
 !
B
is
giv
en
b
y
data
T
A
T
f
-
T
B
+

f
A
a
?
f
-
B
b
?
where
the
isomorphic
2-cell

f
satises

and

conditions.
W
e
often
write
f
=
(f
;

f
)
:
A
 !
B
for
suc
h
a
pseudo-map,
the
2-cell
usually
b
eing
understo
o
d.
Giv
en
a
pseudo-comm
utativit
y
for
T
,
w
e
sho
w
that
for
an
y
T
-algebras
A
129

Hyland
and
Po
wer
and
B
,
the
category
T
-Al
g
(A;
B
)
has
a
T
-algebra
structure
dened
p
oin
t
wise,
i.e.,
it
inherits
a
T
-algebra
structure
from
the
cotensor,
i.e.,
from
the
functor
category
[A;
B
]
with
p
oin
t
wise
T
-structure.
In
order
to
express
the
denition,
w
e
recall
t
w
o
sorts
of
limits
in
2-categories.
Giv
en
a
pair
of
parallel
2-cells
f
;
g
:
X
 !
Y
in
a
2-category
K
,
the
iso-
inserter
of
f
and
g
consists
of
the
univ
ersal
1-cell
i
:
I
 !
X
and
isomorphic
2-cell

:
f
i
)
g
i,
univ
ersally
inserting
an
isomorphism
b
et
w
een
f
and
g
.
Giv
en
parallel
2-cells

;

:
f
)
g
:
X
 !
Y
,
the
e
quier
of

and

is
the
univ
ersal
1-cell
e
:
E
 !
X
making

e
=

e.
Prop
osition
4.1
[2]
F
or
any
2-monad
T
on
C
at,
the
2-c
ate
gory
T
-Al
g
has
and
the
for
getful
2-functor
U
:
T
-Al
g
 !
C
at
pr
eserves
iso-inserters
and
e
quiers.
It
is
routine
to
describ
e
iso-inserters
and
equiers
in
C
at
b
y
considering
their
univ
ersal
prop
erties
as
they
apply
to
functors
with
domain
1.
With
these
denitions,
w
e
can
dene
the
pseudo-closed
structure
of
T
-Al
g
for
pseudo-
comm
utativ
e
T
.
Denition
4.2
Giv
en
T
-algebras
A
=
(A;
a)
and
B
=
(B
;
b),
w
e
construct
a
new
T
-algebra
in
three
steps.
(i)
T
ak
e
the
iso-inserter
(i
:
I
n
 !
[A;
B
];

0
)
of
[A;
B
]

A;B
-
[a;
B
]
-
[T
A;
B
]
where
the
underlying
1-cell
of

A;B
is
dened
b
y
the
comp
osite
[A;
B
]
T
-
[T
A;
T
B
]
[T
A;
b]
-
[T
A;
B
]
whic
h
canonically
but
not
ob
viously
lifts
to
a
map
in
T
-Al
g
,
with
2-cell
structure
dened
b
y
use
of

,
So
w
e
get
a
univ
ersal
2-cell

0
:

A;B

i
 !
[a;
B
]

i.
(ii)
T
ak
e
the
equier
e
0
:
E
q
0
 !
I
n
of
[
A
;
B
]


0
with
the
iden
tit
y
.
(iii)
T
ak
e
the
equier
e
:
E
q
 !
E
q
0
of
[
A
;
B
]


0

e
0
with
the
follo
wing
130

Hyland
and
Po
wer
pasting:
[A;
B
]

-
[T
A;
B
]
     i

+

0
     [a;
B
]

@
@
@
@
@

R
E
q
0
e
0
-
I
n
i
-
[A;
B
]
[T
2
A;
B
]
@
@
@
@
@
i
R
+

0
@
@
@
@
@

R
     [T
a;
B
]

[A;
B
]
[a;
B
]
-
[T
A;
B
]
Here
the
nal
square
comm
utes
b
y
naturalit
y
of

,
and
the
domains
of
the
2-cells
matc
h
easily;
for
the
co
domains,
one
m
ust
w
ork
a
little.
W
e
write
the
resulting
T
-algebra
[A;
B
]
and
call
it,
equipp
ed
with
the
com-
p
osite
p
=
i

e
0

e
:
[A;
B
]
 !
[A;
B
]
and
the
isomorphic
2-cell

=

0

e
0

e
:

A;B

p
 !
[a;
B
]

p
the
exp
onen
tial
A
to
B
.
T
aking
the
canonical
constructions
of
iso-inserters
and
equiers
in
C
at,
it
transpires
that
our
nal
E
q
is
exactly
the
category
of
pseudo-maps
from
A
to
B
.
So
the
forgetful
2-functor
tak
es
[A;
B
]
to
T
-Al
g
(A;
B
).
Moreo
v
er
the
follo
wing
univ
ersal
prop
ert
y
follo
ws
directly
from
the
construction.
Prop
osition
4.3
Given
T
-algebr
as
A
=
(A;
a)
and
B
=
(B
;
b),
the
T
-algebr
a
[A;
B
]
e
quipp
e
d
with
p
:
[A;
B
]
 !
[A;
B
]
and
an
isomorphic
2-c
el
l

:

A;B

p
 !
[a;
B
]

p
satises
the
universal
pr
op
erty
that
for
e
ach
D
,
c
omp
osition
with
p
induc
es
an
isomorphism
b
etwe
en
T
-Al
g
(D
;
[A;
B
])
and
the
c
ate
gory
of
c
ones
given
by
data
f
:
D
 !
[A;
B
]
and
an
isomorphic
2-c
el
l

:

A;B

f
 !
[a;
B
]

f
satisfying
two
e
quic
ation
c
onditions:
one
for
,
the
other
for

.
T
o
complete
the
pro
of
of
our
main
theorem,
a
delicate
notion
of
m
ulti-
linear
map
of
T
-algebras
seems
of
fundamen
tal
imp
ortance
[6].
But
the
ab
o
v
e
is
the
cen
tral
p
oin
t,
and,
taking
the
unit
to
b
e
T
1,
the
free
T
-algebra
on
1,
w
e
ha
v
e
131

Hyland
and
Po
wer
Theorem
4.4
If
T
is
a
pseudo-c
ommutative
2-monad
on
C
at,
then
T
-Al
g
is
a
pseudo-close
d
2-c
ate
gory.
References
[1]
Abramsky
,
S.,
R
etr
acing
some
p
aths
in
pr
o
c
ess
algebr
a,
\Pro
c.
CONCUR
96,"
Lect.
Notes
in
Computer
Science
1119
(1996)
1{17.
[2]
Blac
kw
ell,
R.,
G.M.
Kelly
,
and
A.J.
P
o
w
er,
Two-dimensional
monad
the
ory,
J.
Pure
Appl.
Algebra
59
(1989)
1{41.
[3]
Eilen
b
erg,
S.,
and
G.M.
Kelly
,
Close
d
c
ate
gories,
\Pro
c.
Conference
on
Categorical
Algebra
(La
Jolla
1965),"
Springer-V
erlag
(1966).
[4]
Fiore,
M.,
and
G.D.
Plotkin,
A
n
axiomatisation
of
c
omputational
ly
ade
quate
domain-the
or
etic
mo
dels
of
F
P
C
,
Pro
c.
LICS
94
(1994)
92{102.
[5]
Fiore,
M.,
G.D.
Plotkin,
and
A.J.
P
o
w
er,
Cub
oidal
sets
in
axiomatic
domain
the
ory,
Pro
c.
LICS
97
(1997)
268{279.
[6]
Hyland,
M.,
and
A.J.
P
o
w
er,
Pseudo-c
ommutative
monads
and
pseudo-close
d
2-c
ate
gories,
J.
Pure
Appl.
Algebra
(to
app
ear).
[7]
Kelly
,
G.M.,
Coher
enc
e
the
or
ems
for
lax
algebr
as
and
for
distributive
laws,
Lecture
Notes
in
Mathematics
420,
Springer-V
erlag
(1974)
281{375.
[8]
Ko
c
k,
A.,
Close
d
c
ate
gories
gener
ate
d
by
c
ommutative
monads,
J.
Austral.
Math
So
c.
12
(1971)
405-424.
[9]
Milner,
R.,
Calculi
for
inter
action,
Acta
Informatica
33
(1996)
707{737.
[10]
Moggi,
E.,
Notions
of
c
omputation
and
monads,
Information
and
Computation
93
(1991)
55{92.
[11]
O'Hearn,
P
.W.,
and
D.J.
Pym,
The
lo
gic
of
bunche
d
implic
ations,
Bull.
Sym
b
olic
Logic
(to
app
ear)
[12]
P
o
w
er,
A.J.,
and
E.
P
.
Robinson,
Pr
emonoidal
c
ate
gories
and
notions
of
c
omputation,
Math.
Struct.
in
Comp.
Science
7
(1997)
453{468.
132

MFPS
17
Preliminary
Version
Stably
Compact
Spaces
and
Closed
Relations
Ac
him
Jung
Scho
ol
of
Computer
Scienc
e
The
University
of
Birmingham
Birmingham,
B15
2TT
England
Mathias
Kegelmann
F
achb
er
eich
Mathematik
T
e
chnische
Universit
at
Darmstadt
Schlogartenstr
ae
7
64289
Darmstadt
Germany
M.
Andrew
Moshier
Computer
Scienc
e
Dep
artment
Chapman
University
333
N.
Glassel
l
Str
e
et
Or
ange,
CA
92666
USA
Abstract
Stably
compact
spaces
are
a
natural
generalization
of
compact
Hausdor
spaces
in
the
T
0
setting.
They
ha
v
e
b
een
studied
in
tensiv
ely
b
y
a
n
um
b
er
of
researc
hers
and
from
a
v
ariet
y
of
standp
oin
ts.
In
this
pap
er
w
e
let
the
morphisms
b
et
w
een
stably
compact
spaces
b
e
certain
\closed
relations"
and
study
the
resulting
categorical
prop
erties.
Apart
from
ex-
tending
ordinary
con
tin
uous
maps,
these
morphisms
ha
v
e
a
n
um
b
er
of
pleasing
prop
erties,
the
most
prominen
t,
p
erhaps,
b
eing
that
they
corresp
ond
to
preframe
homomorphisms
on
the
lo
calic
side.
W
e
exploit
this
Stone-t
yp
e
dualit
y
to
establish
that
the
category
of
stably
compact
spaces
and
closed
relations
has
bilimits.
1
In
tro
duction
The
researc
h
rep
orted
in
this
pap
er
deriv
es
its
motiv
ation
from
t
w
o
sources.
F
or
some
time,
w
e
ha
v
e
tried
to
extend
Samson
Abramsky's
Domain
The
ory
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Jung,
Kegelmann
and
Moshier
in
L
o
gic
al
F
orm
to
con
tin
uous
domains,
[1,15,14
,17].
This
has
led
to
a
n
um
b
er
of
insigh
ts,
the
most
imp
ortan
t
p
erhaps
b
eing
that
in
order
to
p
erform
domain
constructions
strictly
lo
gic
al
ly,
one
can
in
v
ok
e
a
v
ersion
of
Gen
tzen's
cut
elim-
ination
theorem.
This,
ho
w
ev
er,
requires
that
w
e
consider
a
purer
logic
than
Abramsky
did.
Seman
tically
,
it
then
turns
out
that
the
notion
of
morphisms
so
captured
consists
of
certain
r
elations,
rather
than
functions,
[14,
Prop
osi-
tion
6.5].
This
is
quite
in
line
with
dev
elopmen
ts
in
denotational
seman
tics,
where
the
need
for
(or
the
adv
an
tages
of
)
relations
has
b
een
noticed
for
some
time,
[5,3].
Our
second
motiv
ation
stems
from
the
desire
to
circum
v
en
t
some
of
the
di√Üculties
connected
to
classical
domain
theory
.
As
is
w
ell
kno
wn,
in
order
to
get
a
cartesian
closed
category
of
con
tin
uous
domains,
one
has
to
restrict
to
a
sub
category
of
FS-domains,
[13
,1].
Unlik
e
general
con
tin
uous
domains,
a
straigh
tforw
ard
c
haracterisation
of
FS-domains
via
their
Stone
dual,
for
example,
is
not
kno
wn.
P
erhaps
as
a
result
of
the
relativ
e
w
eakness
of
our
to
ols
for
FS-domains,
certain
basic
questions
ab
out
them
remain
unresolv
ed.
W
e
still
do
not
kno
w
whether
they
coincide
with
retracts
of
binite
domains
or
whether
the
probabilistic
p
o
w
erdomain
can
b
e
restricted
to
this
category
,
[16
].
The
seman
tic
spaces
whic
h
w
e
put
forw
ard
in
this
pap
er,
in
con
trast
to
FS-domains,
are
v
ery
w
ell
b
eha
v
ed
and
understo
o
d.
They
are
the
so-called
stably-c
omp
act
sp
ac
es.
Man
y
equiv
alen
t
c
haracterisations
are
kno
wn
and
man
y
prop
erties
ha
v
e
b
een
disco
v
ered
for
them.
Also,
they
do
encompass
most
cate-
gories
of
con
tin
uous
domains
whic
h
ha
v
e
pla
y
ed
a
role
in
denotational
seman-
tics.
As
is
clear
from
what
w
e
ha
v
e
said
at
the
b
eginning,
w
e
are
in
terested
in
the
category
SCS

of
stably
compact
spaces
with
closed
r
elations
as
mor-
phisms.
Although
a
similar
set-up
has
b
een
considered
some
time
ago,
[26
,
Prop.
11.2.5],
the
explicit
relational
presen
tation
app
ears
to
b
e
new.
The
purp
ose
of
this
pap
er
is
to
examine
the
suitabilit
y
of
SCS

as
a
se-
man
tic
univ
erse.
T
o
this
end
w
e
lo
ok
at
nitary
closure
prop
erties
and
the
bilimit
construction.
The
latter,
to
our
great
satisfaction,
b
eha
v
es
in
a
v
ery
natural
and
in
tuitiv
e
w
a
y
.
Sp
ecically
,
w
e
sho
w
that
the
bilimit
coincides
with
a
classical
top
ological
limit
although
it
is
constructed
or
der-the
or
etic
al
ly.
2
The
category
of
of
stably
compact
spaces
and
closed
relations
2.1
The
sp
ac
es
W
e
assume
standard
domain
theoretic
notation
as
it
is
used
in
[8,1],
for
exam-
ple.
Sligh
tly
less
w
ell
kno
wn,
p
erhaps,
are
the
follo
wing
notions
and
results.
If
X
is
a
top
ological
space
and
A
an
arbitrary
subset
of
X
then
the
satur
ation
of
A
is
dened
as
the
in
tersection
of
all
neigh
b
orho
o
ds
of
A.
F
or
an
y
T
0
-
top
ological
space
X
,
the
sp
e
cialization
or
der
of
X
is
the
relation
v
X
giv
en
b
y
134

Jung,
Kegelmann
and
Moshier
x
v
X
y
if
ev
ery
neigh
b
orho
o
d
of
x
is
also
a
neigh
b
orho
o
d
of
y
.
The
saturation
of
a
subset
A
can
then
also
b
e
describ
ed
as
the
up
w
ard
closure
with
resp
ect
to
v
X
.
Op
en
set
are
alw
a
ys
upp
er,
that
is,
saturated.
An
imp
ortan
t
fact
is
that
the
saturation
of
a
compact
set
is
again
compact,
for
a
set
A
has
exactly
the
same
op
en
co
v
ers
as
its
saturation.
F
or
an
y
top
ological
space
X
the
set
of
op
en
subsets
forms
a
complete
lattice

(X
)
with
resp
ect
to
subset
inclusion.
Vice
v
ersa,
for
ev
ery
complete
lattice
L
the
set
of
completely
prime
lters,
denoted
pt(L),
carries
the
top
ology
fO
a
j
a
2
Lg
where
F
2
O
a
if
a
2
F
.
A
space
is
T
0
if
the
assignmen
t,
whic
h
asso
ciates
with
a
p
oin
t
x
2
X
the
op
en
neigh
b
orho
o
d
lter
N
(x),
is
injectiv
e.
A
space
is
called
sob
er
if
the
assignmen
t
is
bijectiv
e.
See
[1,
Section
7]
for
a
detailed
in
tro
duction
to
this
topic.
W
e
are
no
w
ready
to
dene
the
ob
jects
of
in
terest
in
this
pap
er:
Denition
2.1
A
top
ological
space
is
called
stably
c
omp
act
if
it
is
sob
er,
compact,
lo
cally
compact
and
nite
in
tersections
of
compact
saturated
subsets
are
again
compact.
Stably
compact
spaces
ha
v
e
b
een
studied
in
tensiv
ely
(and
under
man
y
dieren
t
names),
[8,10
,9,24,19,15
]
but,
unfortunately
,
apart
from
[17
]
there
is
no
single
comprehensiv
e
reference
for
their
man
y
prop
erties.
W
e
therefore
state
the
main
facts
needed
in
the
sequel.
Our
principal
tec
hnical
to
ol
is
the
Hofmann-Mislo
v
e
Theorem,
[11,18
]:
Theorem
2.2
L
et
X
b
e
a
sob
er
sp
ac
e.
Ther
e
is
an
or
der-r
eversing
bije
ction
b
etwe
en
the
set
K(X
)
of
c
omp
act
satur
ate
d
subsets
of
X
(or
der
e
d
by
r
everse
d
inclusion)
and
Sc
ott-op
en
lters
in

(X
)
(or
der
e
d
by
inclusion).
It
assigns
to
a
c
omp
act
satur
ate
d
set
the
lter
of
op
en
neighb
orho
o
ds
and
to
a
Sc
ott-op
en
lter
of
op
en
sets
their
interse
ction.
One
consequence
of
this
whic
h
w
e
will
need
later
is
that
ev
ery
Scott-op
en
lter
in

(X
)
is
equal
to
the
in
tersection
of
all
completely
prime
lters
con-
taining
it.
Another
is
the
fact
that
the
set
K(X
)
is
a
dcp
o
when
equipp
ed
with
rev
ersed
inclusion.
F
or
stably
compact
spaces
ev
en
more
is
true:
Prop
osition
2.3
L
et
X
b
e
a
stably
c
omp
act
sp
ac
e.
(i)
K(X
)
is
a
c
omplete
lattic
e
in
which
supr
ema
ar
e
c
alculate
d
as
interse
c-
tions
and
nite
inma
as
unions.
(ii)

(X
)
and
K(X
)
ar
e
stably
c
ontinuous
fr
ames.
(iii)
In

(X
)
we
have
O

O
0
if
and
only
if
ther
e
is
K
2
K(X
)
with
O

K

O
0
.
(iv)
In
K(X
)
we
have
K

K
0
if
and
only
if
ther
e
is
O
2
(X
)
with
K
0

O

K
.
As
in
[15]
w
e
use
stably
c
ontinuous
fr
ame
to
denote
con
tin
uous
distributiv
e
lattices
in
whic
h
the
w
a
y-b
elo
w
relation
is
multiplic
ative,
that
is,
in
whic
h
135

Jung,
Kegelmann
and
Moshier
x

y
;
z
implies
x

y
^
z
and
in
whic
h
1

1.
They
are
precisely
the
Stone
duals
of
stably
compact
spaces,
see
[10,
Theorem
1.5].
Note
that
the
prop
osition
tells
us
that
the
complemen
ts
of
compact
saturated
sets
form
another
top
ology
on
X
,
called
the
c
o-c
omp
act
top
olo
gy
for
X
and
denoted
b
y
X

.
Original
and
co-compact
top
ology
are
closely
related:
Prop
osition
2.4
L
et
X
b
e
a
stably
c
omp
act
sp
ac
e.
(i)
The
op
en
sets
of
X

ar
e
the
c
omplements
of
c
omp
act
satur
ate
d
sets
in
X
.
(ii)
The
op
en
sets
of
X
ar
e
the
c
omplements
of
c
omp
act
satur
ate
d
sets
in
X

.
(iii)
X

is
stably
c
omp
act
and
(X

)

is
identic
al
to
X
.
(iv)
The
sp
e
cialization
or
der
of
X
is
the
inverse
of
the
sp
e
cialization
or
der
of
X

.
F
or
a
stably
compact
space
X
,
the
p
atch
top
olo
gy
of
X
is
the
common
renemen
t
of
the
original
top
ology
and
the
co-compact
top
ology
.
It
is
denoted
b
y
X

.
It
is
the
k
ey
to
making
the
connection
to
m
uc
h
earlier
w
ork
b
y
Leop
oldo
Nac
h
bin,
[21]:
A
p
artial
ly
or
der
e
d
sp
ac
e
or
p
osp
ac
e
is
a
top
ological
space
X
with
a
partial
order
relation
v
X
suc
h
that
the
graph
of
v
X
is
a
closed
subset
of
X

X
.
Suc
h
a
space
m
ust
b
e
Hausdor
b
ecause
the
diagonal
relation,
i.e.,
the
in
tersection
of
v
X
and
the
opp
osite
partial
order
w
X
,
is
closed.
Theorem
2.5
F
or
a
stably
c
omp
act
sp
ac
e
X
the
sp
e
cialization
or
der
to
gether
with
the
p
atch
top
olo
gy
makes
X

into
a
c
omp
act
or
der
e
d
sp
ac
e.
Conversely,
for
a
c
omp
act
or
der
e
d
sp
ac
e
(X
;
v)
the
op
en
upp
er
sets
"U
=
U
2

(X
)
form
the
top
olo
gy
for
a
stably
c
omp
act
sp
ac
e
X
"
,
and
the
two
op
er
ations
ar
e
mutual
ly
inverse.
Mor
e
over,
for
a
stably
c
omp
act
sp
ac
e
X
the
upp
er
close
d
sets
of
X

ar
e
pr
e
cisely
the
c
omp
act
satur
ate
d
sets
of
X
.
Notice
that
for
a
compact
Hausdor
space
X
,
the
diagonal
relation

X
is
a
closed
(trivial)
partial
order.
By
applying
Theorem
2.5
to
the
p
ospace
(X
;

X
),
w
e
see
that
the
upp
er
op
ens
and
lo
w
er
op
ens
are
just
the
op
ens
of
the
original
top
ology
.
So
X
=
X

=
X

.
The
con
v
erse
also
holds.
Corollary
2.6
A
sp
ac
e
X
is
c
omp
act
Hausdor
if
and
only
if
it
is
a
stably
c
omp
act
sp
ac
e
for
which
X
=
X

.
Pro
of.
The
patc
h
top
ology
for
an
y
stably
compact
space
is
Hausdor.
In
the
case
of
a
stably
compact
space
for
whic
h
X
=
X

,
the
patc
h
top
ology
is
simply
the
original.
2
W
e
can
th
us
think
of
stably
compact
spaces
as
the
T
0
generalization
of
compact
Hausdor
spaces.
The
fact
that
X
6=
X

in
general
forces
us
to
tread
carefully
in
Section
2.2
as
w
e
generalize
from
closed
relations
b
et
w
een
compact
Hausdor
spaces
to
closed
relations
b
et
w
een
stably
compact
spaces.
The
imp
ortance
of
stably
compact
spaces
for
domain
theory
is
that
almost
all
categories
used
in
seman
tics
are
particular
categories
of
stably
compact
136

Jung,
Kegelmann
and
Moshier
spaces.
Prop
osition
2.7
FS
domains,
and
henc
e
in
p
articular
Sc
ott
domains
and
c
ontinuous
lattic
es,
e
quipp
e
d
with
their
Sc
ott
top
olo
gies,
ar
e
stably
c
omp
act
sp
ac
es.
2.2
The
morphisms
The
ob
vious
category
of
stably
compact
spaces
is
that
of
con
tin
uous
functions,
i.e.
the
full
sub
category
SCS
of
the
category
of
top
ological
spaces
T
op
.
The
category
that
w
e
are
really
in
terested
in,
ho
w
ev
er,
is
one
that
generalizes
KHaus

,
the
category
of
compact
Hausdor
spaces
and
closed
relations.
W
e
quote
the
basic
denitions
and
results
from
[14].
The
sp
ecialization
order
of
a
stably
compact
space
X
is
generally
not
closed
in
X

X
.
Indeed,
w
ere
it
closed,
X
w
ould
b
e
a
p
ospace,
hence
w
ould
b
e
Hausdor.
Th
us,
sp
ecialization
w
ould
b
e
trivial.
Sp
ecialization,
on
the
other
hand,
is
rev
ersed
b
y
taking
the
co-compact
top
ology
(again,
in
the
Hausdor
case
X
=
X

so
the
\rev
ersal"
is
trivial).
Th
us:
Prop
osition
2.8
The
sp
e
cialization
or
der
of
a
stably
c
omp
act
sp
ac
e
X
is
close
d
in
X

X

.
Pro
of.
Supp
ose
that
x
6v
X
y
.
Then
there
is
an
op
en
set
U
con
taining
x
and
not
y
.
By
lo
cal
compactness,
w
e
can
assume
that
U
is
con
tained
in
a
compact
saturated
neigh
b
orho
o
d
K
of
x
that
also
do
es
not
con
tain
y
.
U
is
an
upp
er
set
con
taining
x.
The
complemen
t
of
K
is
a
lo
w
er
set
con
taining
y
.
Th
us
U

(X
n
K
)
is
a
neigh
b
orho
o
d
of
hx;
y
i
in
X

X

that
do
es
not
meet
v
X
.2
F
or
stably
compact
spaces
X
and
Y
,
w
e
call
a
closed
subset
R

X

Y

a
close
d
r
elation
fr
om
X
to
Y
and
w
e
write
it
as
R
:
X
+
-
Y
.
If
w
e
sp
ell
out
this
condition
then
it
means
that
for
x
2
X
and
y
2
Y
suc
h
that
x
6R
y
w
e
nd
an
op
en
neigh
b
orho
o
d
U
of
x
and
a
compact
saturated
set
K

Y
that
do
esn't
con
tain
y
suc
h
that
U

(Y
n
K
)
\
R
=
;.
[cf.
the
pro
of
Prop
osition
2.8.]
Note
that
ev
ery
closed
relation
R
satises
the
rule
x
0
v
X
x
R
y
v
Y
y
0
=
)
x
0
R
y
0
.
The
comp
osition
of
closed
relations
is
the
usual
relation
pro
duct,
R
;
S
=

hx;
z
i
j
(9y
)
x
R
y
and
y
S
z
g.
Note
that,
follo
wing
usual
practice,
w
e
write
the
comp
osition
of
relations
from
left
to
righ
t,
whereas
for
functions
it
is
from
righ
t
to
left.
T
o
a
v
oid
am
biguit
y
w
e
use
\;"
to
indicate
left-to-righ
t
comp
osi-
tion.
Notice
that
the
sp
ecialization
order
of
an
y
stably
compact
space
X
acts
as
iden
tit
y
under
taking
the
relation
pro
duct
with
closed
relations
from
or
to
X
and
also
that
the
comp
osition
of
t
w
o
closed
relations
is
again
closed.
W
e
call
the
category
of
stably
compact
spaces
with
closed
relations
SCS

.
The
Hausdor
case
is
w
orth
considering
separately
as
it
helps
to
illuminate
the
denition
of
closed
relations.
As
w
e
ha
v
e
noted,
a
stably
compact
space
is
Hausdor
if
and
only
if
its
top
ology
agrees
with
its
co-compact
top
ology
.
Th
us
137

Jung,
Kegelmann
and
Moshier
our
closed
relations
from
X
to
Y
are
simply
closed
subsets
of
X

Y
=
X

Y

whenev
er
Y
is
Hausdor.
Th
us
SCS

correctly
generalizes
KHaus

,
in
whic
h
w
e
could
tak
e
the
morphisms
simply
as
closed
subsets
of
X

Y
.
The
fact
that
w
e
could
get
a
w
a
y
with
this
apparen
tly
simpler
notion
of
morphism
in
the
Hausdor
setting
is
due
essen
tially
to
the
fact
that
in
compact
Hausdor
spaces
the
co-compact
top
ology
is
\hidden
from
view."
In
particular,
KHaus

is
a
full
sub
category
of
SCS

(as
w
ell
as
b
eing
a
sub
category
of
Rel).
Note
that
the
ob
vious
forgetful
\functor"
from
SCS

to
Rel,
the
category
of
sets
with
relations,
preserv
es
comp
osition
but
not
iden
tities.
The
only
stably
compact
spaces
for
whic
h
iden
tit
y
is
preserv
ed
are
those
with
trivial
sp
ecialization
orders,
i.e.,
the
compact
Hausdor
spaces.
Relations
b
et
w
een
sets
can
b
e
understo
o
d
as
m
ulti-functions.
As
the
fol-
lo
wing
prop
osition
sho
ws
this
carries
o
v
er
to
our
top
ological
setting
in
an
in
teresting
w
a
y
.
Prop
osition
2.9
L
et
X
and
Y
b
e
stably
c
omp
act
sp
ac
es
and
R
:
X
+
-
Y
a
close
d
r
elation
then
f
R
(x)
:=
fy
2
Y
j
x
R
y
g
denes
a
c
ontinuous
function
fr
om
X
to
K(Y
),
wher
e
the
latter
is
e
quipp
e
d
with
the
Sc
ott
top
olo
gy.
Conversely,
if
f
:
X
!
K(Y
)
is
c
ontinuous
then

hx;
y
i
2
X

Y


y
2
f
(x)
	
is
a
close
d
r
elation
fr
om
X
to
Y
.
Mor
e
over,
these
two
tr
anslations
ar
e
mutual
ly
inverse.
T
o
extend
this
corresp
ondence
to
the
comp
osition
of
relations
and
m
ulti-
functions,
resp
ectiv
ely
,
w
e
rst
ha
v
e
to
dene
a
la
w
of
comp
osition
on
the
latter.
T
o
this
end
recall
that
K(X
)
with
its
Scott
top
ology
is
again
a
stably
compact
space
b
y
Prop
ositions
2.3
and
2.7.
Hence
w
e
can
mak
e
K
in
to
an
endofunctor
on
SCS
b
y
mapping
a
con
tin
uous
function
f
:
X
!
Y
to
the
function
K(f
)
:
K(X
)
!
K(Y
)
that
tak
es
a
compact
saturated
subset
K

X
to
"f
[K
].
This
endofunctor
is
part
of
a
monad
whose
unit
tak
es
the
saturation
of
p
oin
ts
and
whose
m
ultiplication
is
simply
union
[22].
Consequen
tly
,
the
canonical
comp
osition
of
m
ulti-functions
is
Kleisli
comp
osition
whic
h
turns
out
to
b
e
the
analogue
of
ordinary
relation
pro
duct.
Prop
osition
2.10
The
c
ate
gory
of
close
d
r
elations
SCS

is
isomorphic
to
the
Kleisli
c
ate
gory
SCS
K
.
It
is
generally
the
case
that
a
category
C
with
a
monad
T
is
em
b
edded
in
the
Kleisli
category
C
T
simply
b
y
p
ost-comp
osing
with
the
unit
of
the
monad.
Moreo
v
er,
if
the
units
of
the
monad
are
monic,
then
the
em
b
edding
is
faithful.
Hence,
SCS
is
a
sub
category
of
SCS
K
and
th
us
also
of
SCS

.
Concretely
,
138

Jung,
Kegelmann
and
Moshier
this
em
b
edding
w
orks
b
y
taking
the
hyp
er
gr
aph
of
a
function.
The
follo
wing
prop
osition
c
haracterizes
those
relations
that
are
really
em
b
edded
functions:
Prop
osition
2.11
If
f
:
X
!
Y
is
a
c
ontinuous
function
then
the
hyp
er
gr
aph

hx;
y
i
2
X

Y


f
(x)
v
y
	
is
a
close
d
r
elation
fr
om
X
to
Y
.
Conversely,
if
R
:
X
+
-
Y
is
a
close
d
r
elation
such
that
for
al
l
x
2
X
the
set
f
R
(x)
has
a
le
ast
element
r
(x)
then
r
:
X
!
Y
is
a
c
ontinuous
function,
and
this
op
er
ation
is
the
inverse
of
the
pr
evious.
Again,
the
Hausdor
case
ma
y
help
to
illuminate
this.
If
f
:
X
!
Y
is
a
con
tin
uous
function
with
Y
a
compact
Hausdor
space,
then
the
h
yp
ergraph
is
simply
the
graph
of
f
.
This
is
a
closed
relation
just
as
classical
top
ology
tells
us
it
should
b
e.
Con
v
ersely
,
supp
ose
that
a
closed
relation
from
X
to
Y
is
the
graph
of
a
function
g
.
Then
clearly
f
R
(x)
has
a
least
elemen
t
g
(x)
for
eac
h
x.
Th
us
g
is
a
con
tin
uous
function.
2.3
The
c
ate
gory
The
left
adjoin
t
from
SCS
to
the
Kleisli
category
SCS
K

=
SCS

preserv
es
copro
ducts.
Hence,
they
are
giv
en
in
SCS

simply
as
top
ological
copro
ducts,
i.e.,
as
disjoin
t
unions.
In
the
category
Rel
of
sets
and
relations
for
ev
ery
relation
R
:
X
+
-
Y
there
is
the
recipro
cal
relation
R

that
is
giv
en
b
y
y
R

x
(
)
x
R
y
.
This
is
the
main
ingredien
t
that
mak
es
Rel
in
to
an
allegory
[7].
Our
category
SCS

fails
to
b
e
an
allegory
exactly
b
ecause,
as
w
e
shall
see,
it
lac
ks
a
true
recipro
cation
op
eration.
On
the
other
hand,
if
R
:
X
+
-
Y
is
a
closed
relation
b
et
w
een
stably
compact
spaces
then
R

:
Y

+
-
X

is
a
closed
relation
b
et
w
een
the
co-compact
top
ologies,
and
()

is
an
in
v
olution
on
SCS

.
The
problem
is
that
it
do
esn't
x
ob
jects.
W
e
can
think
of
X

as
an
upside-do
wn
v
ersion
of
X
since
the
sp
ecialization
order
v
X

for
the
co-compact
top
ology
is
simply
w
X
,
i.e.
the
dual
of
the
one
for
the
original
space.
Nonetheless,
the
maps
X
7!
X

and
R
7!
R

comprise
a
con
tra
v
arian
t
functor,
sho
wing
that
SCS

is
a
self-dual
category
.
Consequen
tly
,
categorical
pro
ducts
(denoted
here
b
y
X


Y
to
a
v
oid
conict
with
top
ological
pro
ducts
X

Y
)
are
also
giv
en
b
y
disjoin
t
union:
X


Y

=
(X

+
Y

)

=
(X

:
[
Y

)

=
(X

)

:
[
(Y

)

=
X
:
[
Y
=
X
+
Y
:
If
a
self-dual
category
is
cartesian
closed
then
all
ob
jects
are
isomorphic
and
hence
the
category
is
equiv
alen
t
to
the
category
with
only
one
(iden
tit
y)
mor-
phism.
This
sho
ws
that
SCS

cannot
b
e
cartesian
closed.
Since
categorical
pro
ducts
in
SCS

are
the
same
as
co-pro
ducts,
let
us
lo
ok
at
cartesian
pro
ducts.
In
SCS
they
are
the
categorical
pro
duct
and
w
e
139

Jung,
Kegelmann
and
Moshier
can
lift
them
to
SCS

to
mak
e
SCS

in
to
a
symmetric
monoidal
category
.
The
tensor
pro
duct
tak
es
the
cartesian
pro
duct
of
the
spaces
with
the
pro
d-
uct
top
ology
and
w
e
also
em
b
ed
the
morphisms
needed
for
the
symmetric
monoidal
structure
from
SCS
as
describ
ed
in
Prop
osition
2.11.
The
deni-
tion
of
the
tensor
pro
duct
of
t
w
o
closed
relations
R
and
S
is
p
oin
t
wise,
i,e,
hx;
y
i
R

S
hx
0
;
y
0
i
:
(
)
x
R
y
and
x
0
R
y
0
.
This
denes
a
closed
rela-
tion
and
extends
to
pro
ducts
of
con
tin
uous
functions;
for
the
details
see
[17
,
Section
3.2.4].
With
resp
ect
to

,
the
category
SCS

is
closed:
Because
of
(X

Y
)

=
X


Y

w
e
see
that
closed
subsets
of
(X

Y
)

Z

are
the
same
thing
as
closed
subsets
of
X

(Y


Z
)

whic
h
pro
v
es
SCS

(X

Y
;
Z
)

=
SCS

(X
;
Y


Z
).
This
in
ternal
homset
Y


Z
,
ho
w
ev
er,
do
es
not
corresp
ond
to
the
\real"
homset
SCS

(Y
;
Z
).
The
homset
SCS

(Y
;
Z
)
consists
of
the
closed
subsets
of
Y

Z

whic
h
b
y
Theorem
2.5
are
precisely
the
compact
saturated
subsets
of
the
dual
(Y

Z

)

.
Hence,
w
e
can
write
the
r
elation
sp
ac
e
as
[Y
)
Z
]
:=
K(Y


Z
).
With
this
denition
and
Prop
osition
2.10
w
e
get
SCS

(X

Y
;
Z
)

=
SCS

(X
;
Y


Z
)

=
SCS
 X
;
K(Y


Z
)

=
SCS
 X
;
[Y
)
Z
]

:
So,
w
e
see
that
( 
Y
)
and
[Y
)
 ]
are
almost
adjoin
t.
The
problem
is
that
the
induced
morphism
X
+
-
[Y
)
Z
]
is
not
uniquely
determined.
The
canonical
ev
aluation
morphism
is
a
functional
closed
relation
and
for
the
induced
morphism
w
e
can
alw
a
ys
c
ho
ose
a
functional
one,
and
as
suc
h
it
is
unique,
i.e.
these
morphisms
come
from
SCS
rather
than
SCS

.
In
[23]
suc
h
a
situation
is
called
a
Kleisli
exp
onential.
There
is
an
alternativ
e
description
of
the
relation
space
b
y
observing
SCS

(Y
;
Z
)

=
SCS
 Y
;
K(Z
)

:
Th
us
the
normal
function
space
[Y
!
K(Z
)]
with
the
compact-op
en
top
ology
,
whic
h
is
simply
the
Scott
top
ology
,
yields
a
space
that
is
homeomorphic
to
[Y
)
Z
].
This
construction
w
as
rst
studied
in
[25],
although
it
seems
that
some
of
subtleties
concerning
the
fact
that
this
is
only
a
Kleisli
exp
onen
tial
w
ere
o
v
erlo
ok
ed.
3
Stone
Dualit
y
Next
w
e
dev
elop
the
Stone
dualit
y
of
closed
relations.
The
morphisms
b
et
w
een
op
en
set
lattices
corresp
onding
to
closed
relations
turn
out
to
b
e
preframe
homomorphisms,
[2],
preserving
nite
meets
and
directed
suprema.
They
ha
v
e
b
een
studied
in
a
similar
framew
ork
b
efore,
see
[26
,
Prop.
11.2.5],
but
the
dualit
y
with
relations
seems
to
b
e
new.
3.1
R
elational
pr
eimage
If
R
:
X
+
-
Y
is
a
relation
and
A

X
a
subset,
then
w
e
write
[A]R
:=

y
2
Y


(9x
2
A)
x
R
y
	
140

Jung,
Kegelmann
and
Moshier
for
the
usual
forw
ard
image.
The
denition
of
the
preimage
of
a
subset
B

Y
under
the
relation
R
is
a
bit
more
tric
ky
as
there
are
sev
eral
candidates.
Here,
w
e
are
only
in
terested
in
the
universal
pr
eimage
giv
en
b
y
(8R
)[B
]
:=

x
2
X


(8y
2
Y
)
x
R
y
=
)
y
2
B
	
:
This
denition
is
useful
b
ecause
8R
turns
out
to
b
e
the
righ
t
adjoin
t
to
[]R
:
Lemma
3.1
If
R

X

Y
is
a
r
elation
and
A
and
B
ar
e
subsets
of
X
and
Y
,
r
esp
e
ctively,
then
we
have
[A]R

B
(
)
A

(8R
)[B
]:
In
the
usual
functional
setting
the
situation
is
analogous;
preimage
is
righ
t
adjoin
t
to
direct
image.
The
connection
b
et
w
een
relational
and
functional
preimage
is
the
follo
wing.
Lemma
3.2
If
f
:
X
!
Y
is
a
c
ontinuous
function
b
etwe
en
stably
c
omp
act
sp
ac
es
and
F
:
X
+
-
Y
the
c
orr
esp
onding
close
d
r
elation
given
by
the
hyp
er-
gr
aph,
then
for
al
l
upp
er
sets
A
=
"A

Y
we
have
f
 1
[A]
=
(8F
)[A]:
W
e
no
w
describ
e
the
translation
from
top
ological
spaces
to
frames
in
the
relational
setting.
Prop
osition
3.3
If
R
:
X
+
-
Y
is
a
close
d
r
elation
then
8R
is
a
c
ontinuous
semilattic
e
homomorphism
fr
om

(Y
)
to

(X
),
i.e.
it
pr
eserves
nite
inma
and
dir
e
cte
d
supr
ema.
Pro
of.
First,
w
e
ha
v
e
to
c
hec
k
that
for
an
y
op
en
V

Y
the
preimage
(8R
)[V
]
is
op
en.
So
let
x
2
(8R
)[V
],
or
equiv
alen
tly
f
R
(x)
=
[x]R

V
.
W
e
kno
w
from
Prop
osition
2.9
that
f
R
is
con
tin
uous
and
th
us
Prop
osition
2.3
giv
es
us
an
op
en
neigh
b
orho
o
d
U
of
x
suc
h
that
f
R
(x
0
)

V
for
all
x
0
2
U
.
W
e
conclude
x
2
U

(8R
)[V
],
th
us
sho
wing
that
for
a
closed
relation
the
univ
ersal
preimage
of
an
op
en
set
is
op
en.
As
w
e
ha
v
e
seen
in
Lemma
3.1,
8R
as
a
function
b
et
w
een
the
full
p
o
w
ersets
is
a
righ
t
adjoin
t.
As
suc
h
it
preserv
es
all
in
tersections
and
th
us
the
nite
meets
in

(Y
).
Th
us,
it
is
a
monotone
map
and,
consequen
tly
,
to
sho
w
that
it
also
pre-
serv
es
directed
suprema
w
e
only
ha
v
e
to
v
erify
(8R
)

S
"
V
i


S
"
(8R
)[V
i
].
So,
w
e
consider
an
x
2
(8R
)

S
"
V
i

whic
h
means
f
R
(x)

S
"
V
i
.
But
as
f
R
(x)
is
compact
w
e
can
nd
an
index
i
suc
h
that
f
R
(x)

V
i
and,
equiv
alen
tly
,
suc
h
that
x
2
(8R
)[V
i
].
2
W
e
call


R
the
restriction
and
co-restriction
of
8R
to
the
op
en
subsets
of
X
and
Y
to
simplify
notation.
Going
from
a
relation
to
the
forw
ard
im-
age
function
is
w
ell-kno
wn
to
b
e
functorial,
and
so
is
taking
adjoin
ts.
By
141

Jung,
Kegelmann
and
Moshier
Lemma
3.1
this
implies
that
univ
ersal
preimage
is
also
functorial.
Clearly
,


v
X
is
the
iden
tit
y
on


(X
)
=

(X
)
as
all
op
en
sets
are
upp
er
sets.
Th
us


is
a
con
tra
v
arian
t
functor
from
SCS

to
the
category
of
stably
con
tin
uous
frames
and
Scott
con
tin
uous
semilattice
homomorphisms
whic
h
w
e
denote
b
y
SCF

.
Just
lik
e

w
e
also
ha
v
e
to
adjust
the
functor
pt
to
the
relational
setting.
Consider
a
homomorphism

:
L
!
M
.
W
e
dene
the
relation
pt

()
:
pt

(M
)
+
-
pt

(L)
b
y
Q
pt

()
P
:
(
)

 1
[Q]

P
where
pt

on
ob
jects
b
eha
v
es
just
lik
e
the
usual
pt,
i.e.,
P
and
Q
are
com-
pletely
prime
lters
in
L
and
M
,
resp
ectiv
ely
.
Alternativ
ely
,
w
e
can
iden
tify
completely
prime
lters
with
their
c
haracteristic
functions
whic
h
are
frame
morphisms
to
2,
the
t
w
o-elemen
t
lattice.
F
or
t
w
o
suc
h
p
oints
p
:
L
!
2
and
q
:
M
!
2
the
ab
o
v
e
denition
b
ecomes
q
pt

()
p
:
(
)
q
√Ü

v
p:
Prop
osition
3.4
If

:
L
!
M
is
a
c
ontinuous
semilattic
e
homomorphism,
then
pt

()
:
pt

(M
)
+
-
pt

(L)
is
a
close
d
r
elation.
Pro
of.
Supp
ose
Q

M
and
P

L
are
completely
prime
lters
suc
h
that

 1
[Q]
*
P
.
As

is
Scott
con
tin
uous
and
Q
completely
prime
and
th
us,
in
particular,
Scott
op
en,
the
set

 1
[Q]
is
also
Scott
op
en.
Because
it
is
also
not
con
tained
in
P
and
L
is
a
con
tin
uous
lattice
w
e
can
nd
an
x
2

 1
[Q]
n
P
suc
h
that


x
*
P
.
On
the
other
hand
Q,
as
an
upp
er
set,
is
the
union
of
principal
lters
"y
for
y
2
Q
and
hence
w
e
get

 1
[Q]
=

 1

S
f"y
j
y
2
Qg

=
S


 1
["y
]


y
2
Q
	
3
x.
This
means
that
w
e
can
nd
a
y
2
Q
suc
h
that
x
2

 1
["y
].
As
L
is
stably
con
tin
uous,
the
set


x
is
a
Scott
op
en
lter
whic
h
corresp
onds
to
the
compact
saturated
subset

P
2
pt

(L)




x

P
	
of
pt

(L)
b
y
the
Hofmann-Mislo
v
e
theorem.
No
w,
w
e
consider
the
op
en
subset
of
pt

(M
)

pt

(L)

whic
h
is
giv
en
as
the
pro
duct
of
the
op
en
set
corresp
onding
to
y
and
to
the
complemen
t
of
the
compact
saturated
set
corresp
onding
to


x,
and
w
e
claim
that
this
is
a
neigh
b
orho
o
d
of
hQ;
P
i
that
do
esn't
meet
R

.
Clearly
,
hQ;
P
i
is
in
this
set,
and
if
Q
0
2
pt

(M
)
and
P
0
2
pt

(L)
are
suc
h
that
y
2
Q
0
and


x
*
P
0
w
e
get

 1
[Q
0
]


 1

"y

3
x
and
th
us

 1
[Q
0
]



x
whic
h
implies

 1
[Q
0
]
*
P
0
.
2
No
w
w
e
ha
v
e
all
the
ingredien
ts
for
a
dualit
y
b
et
w
een
SCS

and
SCF

.
It
remains
to
c
hec
k
that
the
categorical
conditions
are
indeed
met.
Theorem
3.5
The
c
ontr
avariant
functors


and
pt

ar
e
p
art
of
a
dual
e
quiv-
alenc
e
b
etwe
en
the
c
ate
gories
SCF

and
SCS

.
Pro
of.
W
e
b
egin
b
y
sho
wing
that
pt

is
indeed
a
functor.
Clearly
,
pt

(id
L
)
=
v
pt

(L)
,
the
iden
tit
y
closed
relation
on
pt

(L).
The
in
teresting
direction
for
142

Jung,
Kegelmann
and
Moshier
functorialit
y
is
to
sho
w
that
pt

( 
√Ü
)

pt

( 
);
pt

(),
where

:
L
!
M
and
 
:
M
!
N
are
con
tin
uous
semilattice
morphisms.
Let
P
2
pt

(N
)
and
P
0
2
pt

(L)
b
e
suc
h
that
P
(pt

( 
√Ü
))
P
0
,
or
equiv
alen
tly
that

 1

 
 1
[P
]


P
0
.
W
e
need
to
nd
a
completely
prime
lter
Q

M
that
satises
 
 1
[P
]

Q
and

 1
[Q]

P
0
.
Unfortunately
,
 
 1
[P
]
in
general
is
only
a
Scott
op
en
lter,
not
a
p
oin
t
in
M
.
Ho
w
ev
er,
b
y
the
Hofmann-Mislo
v
e
Theorem,
2.2,
w
e
ha
v
e
 
 1
[P
]
=
T
fQ
2
pt

(M
)
j
 
 1
[P
]

Qg.
So
for
the
sak
e
of
con
tradiction,
assume
there
exists
x
Q
2

 1
[Q]
n
P
0
for
all
Q

 
 1
[P
].
Then
the
suprem
um
W
x
Q
of
all
these
elemen
ts
do
es
not
b
elong
to
P
0
b
ecause
P
0
is
completely
prime;
on
the
other
hand,
(
W
x
Q
)
b
elongs
to
all
Q

 
 1
[P
]
b
y
monotonicit
y
of
,
hence
to
 
 1
[P
].
This
con
tradicts
the
assumption

 1
[ 
 1
[P
]]

P
0
.
T
o
sho
w
that


and
pt

giv
e
rise
to
a
dualit
y
b
et
w
een
SCF

and
SCS

w
e
ha
v
e
to
c
hec
k
that
their
actions
on
morphisms
are
m
utually
in
v
erse.
So,
supp
ose
R
:
X
+
-
Y
is
a
closed
relation
and
N
(x)
and
N
(y
)
are
the
op
en
neigh
b
orho
o
d
lters
of
t
w
o
p
oin
ts
x
2
X
and
y
2
Y
.
W
e
get
N
(x)
(pt

(8R
))
N
(y
)
(
)
(8R
)
 1

N
(x)


N
(y
)
(
)
 8V
2


(Y
)

V
2
(8R
)
 1

N
(x)

=
)
V
2
N
(y
)
(
)
 8V
2


(Y
)

x
2
(8R
)[V
]
=
)
y
2
V
(
)
 8V
2


(Y
)

[x]R

V
=
)
y
2
V
Clearly
,
x
R
y
implies
this
last
condition
and
the
con
v
erse
follo
ws
from
the
fact
that
[x]R
is
saturated.
Finally
,
w
e
tak
e
a
con
tin
uous
semilattice
morphism

:
L
!
M
and
sho
w
that
 

(pt

())

 fP
2
pt

(L)
j
x
2
P
g

=

Q
2
pt

(M
)


(x)
2
Q
	
for
an
y
x
2
L:
 8
pt

()



P
2
pt

(L)
j
x
2
P
	

=
n
Q
2
pt

(M
)


 8P
2
pt

(L)

Q
(pt

())
P
=
)
x
2
P
o
=
n
Q
2
pt

(M
)


 8P
2
pt

(L)


 1
[Q]

P
=
)
x
2
P
o
As
b
efore
w
e
use
the
fact
that

 1
[Q]
is
a
Scott-op
en
lter
and
hence
b
y
the
Hofmann-Mislo
v
e
Theorem
equal
to
the
in
tersection
of
all
completely
prime
lters
con
taining
it.
The
expression
then
re-writes
to
fQ
2
pt

(M
)
j
x
2

 1
[Q]g
whic
h
is
equal
to
fQ
2
pt

(M
)
j
(x)
2
Qg
as
desired.
2
It
is
in
teresting
to
consider
the
Stone
dual
of
the
in
v
olution
on
SCS

that
w
e
discussed
in
Section
2.3.
The
co-compact
top
ology
on
a
stably
compact
space
has
precisely
the
compact
saturated
subsets
of
the
original
space
as
closed
sets
whic
h
implies


(X

)
=

(X

)

=
K(X
).
F
rom
the
Hofmann-Mislo
v
e
Theorem
w
e
kno
w
that
K(X
)
is
in
one-to-one
corresp
ondence
to
the
Scott
op
en
lters
in

(X
).
The
latter
can
also
b
e
understo
o
d
via
their
c
haracteristic
functions
whic
h
are
precisely
the
con
tin
uous
semilattice
homomorphisms
to
2,
the
t
w
o-elemen
t
lattice.
Putting
it
all
together
w
e
get

(X

)

=
K(X
)

=
143

Jung,
Kegelmann
and
Moshier
SCF

 
(X
);
2

and
w
e
see
that
this
self-dualit
y
in
lo
calic
terms
is
exactly
the
La
wson
dualit
y
of
stably
con
tin
uous
semilattices
[20].
3.2
F
unctions
r
evisite
d
W
e
kno
w
from
Prop
osition
2.11
that
SCS
em
b
eds
faithfully
in
SCS

and
also
ho
w
to
recognize
the
morphisms
that
arise
from
this
em
b
edding
as
h
yp
ergraphs
of
functions.
W
e
refer
to
a
closed
relation
as
functional
if
it
is
the
h
yp
ergraph
of
a
con
tin
uous
function.
Similarly
the
category
SCF

con
tains
a
sub
category
of
functional
arro
ws.
Prop
osition
3.6
If
R
:
X
+
-
Y
is
a
functional
close
d
r
elation
then


(R
)
pr
eserves
nite
(and
c
onse
quently
al
l)
supr
ema.
Conversely,
if

:
L
!
M
is
a
fr
ame
homomorphism
then
pt

(L)
is
functional.
Pro
of.
If

is
a
frame
homomorphism
then
for
an
y
completely
prime
lter
Q

M
the
preimage

 1
[Q]
is
completely
prime.
Hence,
this
is
the
least
completely
prime
lter
P

L
suc
h
that

 1
[Q]

P
.
F
or
the
con
v
erse
observ
e
that
the
forw
ard
image
[x]R
of
an
y
p
oin
t
x
has
a
least
elemen
t
and
hence
will
b
e
con
tained
in
either
U
or
V
i
it
is
con
tained
in
U
[
V
.
This
sho
ws
that
8R
preserv
es
nite
suprema.
2
This
result,
of
course,
is
v
ery
similar
to
the
classical
Stone
dualit
y
b
e-
t
w
een
SCS
,
the
category
of
stably
compact
spaces
with
con
tin
uous
functions,
and
SCF

_
,
stably
con
tin
uous
lattices
with
frame
homomorphisms.
There
the
functors

and
pt
act
on
morphisms
as
follo
ws:

(f
)
is
simply
the
preim-
age
function
f
 1
[]
and
similarly
pt()
tak
es
a
completely
prime
lter
P
to
the
completely
prime
lter

 1
[P
].
As
a
corollary
of
the
previous
prop
osi-
tion
w
e
get
that
pt

and


comm
ute
with
the
em
b
eddings
of
the
functional
sub
categories.
Corollary
3.7
The
diagr
am
of
functors
SCS

-

pt
F
rm
SCS

i
?
\


-

pt

SCF

j
?
\
c
ommutes
in
the
sense
that
j
√Ü

=


√Ü
i
and
i
√Ü
pt

=
pt
√Ü
j
.
Pro
of.
The
rst
equalit
y
w
as
pro
v
ed
in
Lemma
3.2.
F
or
the
second,
tak
e
a
frame
morphism

:
L
!
M
.
It
is
mapp
ed
b
y
i
√Ü
pt
to
the
h
yp
ergraph
of
the
preimage
function,
i.e.
the
closed
relation
that
relates
Q
2
pt
(M
)
=
pt

(M
)
to
P
2
pt(L)
=
pt

(L)
if
and
only
if

 1
[Q]

P
whic
h
is
precisely
pt

(j
()).2
144

Jung,
Kegelmann
and
Moshier
As
a
consequence
of
this
corollary
the
op
eration
whic
h
extracts
from
a
functional
relation
the
underlying
con
tin
uous
function
(whic
h
exists
b
y
Prop
o-
sition
2.11)
is
just
the
comp
osition
pt
√Ü


.
It
follo
ws
that
this
is
functorial.
W
e
denote
it
b
y
U
.
There
is
a
more
categorical
w
a
y
to
iden
tify
the
functional
morphisms
in
the
t
w
o
dual
categories.
As
w
e
ha
v
e
seen
in
Section
2.3,
the
pro
ducts
on
the
func-
tional
sub
category
giv
e
rise
to
a
symmetric
monoidal
structure
on
the
larger
relational
category
.
In
addition,
the
diagonals

A
:
A
!
A

A
and
mor-
phisms
!
A
to
the
terminal
ob
ject
induce
a
diagonal
structur
e.
The
functional
morphisms
are
then
c
haracterized
as
the
total
and
deterministic
morphisms,
i.e.
the
ones
for
whic
h
!
and
,
resp
ectiv
ely
,
are
natural
transformations.
F
or
more
details
see
[17
,
Section
3.3].
4
Subspaces
There
are
a
n
um
b
er
of
dieren
t
concepts
of
\go
o
d
subspace"
in
T
op
ology
as
often
simply
carrying
the
induced
top
ology
is
to
o
w
eak.
One
v
ery
useful
one
that
is
w
ell-kno
wn
in
domain
theory
is
that
of
an
emb
e
dding-pr
oje
ction
p
air.
It
com
bines
the
categorical
notion
of
section
retraction
pair
with
the
order
theoretic
notion
of
adjunction.
It
is
then
an
immediate
corollary
that
the
space
that
is
the
co
domain
of
the
section
carries
the
subspace
top
ology
.
In
the
follo
wing
w
e
will
generalize
this
to
the
relational
setting.
4.1
Perfe
ct
r
elations
W
e
start
b
y
dening
a
sp
ecial
class
of
relations
that
will
b
e
imp
ortan
t
when
w
e
c
haracterize
relations
that
ha
v
e
adjoin
ts.
Denition
4.1
W
e
sa
y
that
a
closed
relation
R
:
X
+
-
Y
is
p
erfe
ct
if
for
all
compact
saturated
sets
K

Y
the
preimage
(8R
)[K
]
is
compact.
P
erfect
relations
can
alternativ
ely
b
e
c
haracterized
in
terms
of
their
Stone
duals.
Prop
osition
4.2
A
close
d
r
elation
R
:
X
+
-
Y
is
p
erfe
ct
if
and
only
if


(R
)
pr
eserves
the
way-b
elow
r
elation.
Pro
of.
Let
us
assume
that
R
is
p
erfect
and
U

V
are
op
en
subsets
of
Y
.
Then
there
is
a
compact
saturated
set
K

Y
suc
h
that
U

K

V
and
w
e
get


(R
)(U
)
=
(8R
)[U
]

(8R
)[K
]

(8R
)[V
]
=


(R
)(V
).
By
assumption
(8R
)[K
]
is
compact
and
hence
w
e
conclude


(R
)(U
)



(R
)(V
).
Con
v
ersely
,
supp
ose


(R
)
preserv
es
w
a
y-b
elo
w
and
K

Y
is
compact
saturated.
As
a
saturated
set,
K
it
is
the
in
tersection
of
all
the
op
en
sets
that
con
tain
it
and
w
e
compute
(8R
)[K
]
=
(8R
)

\
#
fU
2


(Y
)
j
K

U
g

=
\
#

(8R
)[U
]


K

U
	
145

Jung,
Kegelmann
and
Moshier
where
the
last
equalit
y
follo
ws
b
ecause,
b
y
Lemma
3.1,
8R
is
a
righ
t
adjoin
t
and
hence
preserv
es
arbitrary
in
tersections
in
P(Y
).
No
w
w
e
claim
that
this
last
in
tersection
is
tak
en
o
v
er
a
lterbase
for
a
Scott
op
en
lter
in


(X
)
=

(X
).
The
set

(8R
)[U
]


K

U
	
is
clearly
ltered.
T
o
see
that
it
is
generates
a
Scott
op
en
lter
tak
e
U
2

(Y
)
that
con
tains
K
.
Since
Y
is
lo
cally
compact,
the
neigh
b
orho
o
d
lter
of
the
compact
set
K
has
a
basis
of
compact
saturated
sets.
This
means
that
there
is
an
op
en
set
V
and
a
compact
set
K
0
suc
h
that
K

V

K
0

U
.
This
implies
V

U
and
hence
b
y
assumption
(8R
)[V
]

(8R
)[U
].
By
the
Hofmann-Mislo
v
e
Theorem
the
in
tersection
o
v
er
a
Scott
op
en
l-
ter
of
op
en
sets,
and
hence
also
of
a
lterbase
for
suc
h
a
lter,
is
compact
saturated.
This
sho
ws
that
(8R
)[K
]
is
compact
and
nishes
the
pro
of.
2
This
extends
the
classical
situation
of
functions
b
et
w
een
stably
compact
spaces
(or,
more
generally
,
lo
cally
compact
sob
er
spaces),
[10
,
Remark
1.3].
Since
the
Stone
dual
of
a
function
has
an
upp
er
adjoin
t,
p
erfectness
in
that
situation
can
b
e
further
c
haracterized
b
y
the
adjoin
t
b
eing
Scott-con
tin
uous
(lo
c.
cit.).
Because
of
Corollary
3.7
w
e
ha
v
e
that
a
con
tin
uous
function
b
e-
t
w
een
stably
compact
spaces
is
p
erfect
in
the
classical
sense
if
and
only
if
the
corresp
onding
relation
giv
en
b
y
the
h
yp
ergraph
is
p
erfect
in
our
sense.
It
ma
y
b
e
w
orth
while
to
add
a
few
w
ords
ab
out
terminology
here.
As
w
e
quoted,
p
erfect
maps
ha
v
e
(at
least)
three
dieren
t
c
haracterizations
and
fur-
thermore
man
y
useful
prop
erties.
Dep
ending
on
what
is
considered
essen
tial
in
a
giv
en
situation,
additional
assumptions
are
made
in
order
to
preserv
e
certain
k
ey
prop
erties
in
the
absence
of
lo
cal
compactness,
sobriet
y
or
b
oth.
This
has
led
to
an
abundance
of
dieren
t
concepts
for
whic
h
it
no
w
app
ears
imp
ossible
to
establish
a
coheren
t
terminology
.
Either
of
\prop
er"
[4,10
]
or
\p
erfect"
[12
,9,6]
is
usually
used
but
it
is
not
clear
where
the
b
oundary
b
e-
t
w
een
the
t
w
o
ough
t
to
b
e
dra
wn.
Our
c
hoice
of
\p
erfect"
follo
ws
the
more
recen
t
custom
of
reserving
\prop
er"
for
sligh
tly
stronger
requiremen
ts
ev
en
in
the
case
of
lo
cally
compact
sob
er
spaces.
W
e
also
note
that
p
erfect
functions
b
et
w
een
stably
compact
spaces
are
ex-
actly
those
whic
h
are
con
tin
uous
with
resp
ect
to
b
oth
original
and
co-compact
top
ology
.
This
implies
that
they
are
exactly
those
maps
whic
h
are
monotone
and
patc
h
con
tin
uous.
T
o
summarize:
Prop
osition
4.3
L
et
f
:
X
!
Y
b
e
a
function
b
etwe
en
stably
c
omp
act
sp
ac
es
and
R
:
X
+
-
Y
the
c
orr
esp
onding
hyp
er
gr
aph.
Then
the
fol
lowing
ar
e
e
quiv-
alent:
(i)
R
is
p
erfe
ct;
(ii)
f
is
p
erfe
ct
with
r
esp
e
ct
to
the
original
top
olo
gies;
(iii)
f
is
p
erfe
ct
with
r
esp
e
ct
to
the
c
o-c
omp
act
top
olo
gies;
(iv)
f
is
monotone
and
p
atch
c
ontinuous.
There
is
y
et
another
approac
h
to
p
erfectness
via
uniform
con
tin
uit
y:
F
or
146

Jung,
Kegelmann
and
Moshier
ev
ery
stably
compact
space
there
is
a
unique
quasi-uniformit
y
U
suc
h
that
U
induces
the
top
ology
and
U
 1
induces
the
co-compact
top
ology
.
A
con
tin
uous
function
f
:
X
!
Y
b
et
w
een
stably
compact
spaces
is
p
erfect
if
and
only
if
it
is
uniformly
con
tin
uous
with
resp
ect
to
these
unique
quasi-uniformities
on
X
and
Y
.
F
or
details
see
[25,
Theorem
3].
In
a
w
a
y
,
p
erfect
con
tin
uous
functions
seem
to
b
e
a
b
etter
notion
of
mor-
phisms
for
the
category
SCS
than
just
con
tin
uous
ones,
as
op
en
and
compact
saturated
sets
pla
y
similarly
imp
ortan
t
roles.
Moreo
v
er,
with
these
morphisms
w
e
can
explain
in
whic
h
w
a
y
the
patc
h
top
ology
is
a
\natural"
construction:
Ev
ery
con
tin
uous
function
b
et
w
een
compact
Hausdor
spaces
is
p
erfect,
and
hence
this
category
em
b
eds
fully
and
faithfully
in
to
SCS
with
p
erfect
maps.
No
w,
taking
the
patc
h
top
ology
is
simply
the
righ
t
adjoin
t,
i.e.
the
co-reector,
for
this
inclusion
functor,
[6].
Returning
to
closed
relations
again,
p
erfectness
is
link
ed
to
op
enness.
W
e
sa
y
that
a
closed
relation
R
:
X
+
-
Y
is
op
en
if
for
all
op
en
sets
U

X
the
forw
ard
image
[U
]R
is
op
en.
F
or
the
next
prop
osition
w
e
need
the
follo
wing
observ
ation
whic
h
relates
forw
ard
image,
univ
ersal
preimage,
complemen
tation
and
recipro
cation:
Lemma
4.4
If
R
:
X
+
-
Y
is
a
r
elation
in
Rel
and
M

X
is
an
arbitr
ary
subset
then
[X
n
M
]R
=
Y
n
(8R

)[M
].
Pro
of.
F
or
y
2
Y
w
e
ha
v
e
y
2
[X
n
M
]R
(
)
(9x
2
X
n
M
)
x
R
y
(
)
y
=
2
(8R

)[M
]
(
)
y
2
Y
n
(8R

)[M
]:
2
Prop
osition
4.5
A
close
d
r
elation
R
:
X
+
-
Y
is
op
en
if
and
only
if
the
r
e
cipr
o
c
al
r
elation
R

:
Y

+
-
X

is
p
erfe
ct.
Pro
of.
Let
us
assume
that
R
is
op
en.
W
e
tak
e
a
compact
saturated
set
K
2
K(X

)
and
ha
v
e
to
sho
w
that
(8R

)[K
]
is
compact
in
Y

.
By
Theorem
2.5
the
condition
K
2
K(X

)
is
equiv
alen
t
to
X
n
K
2

(X
)
and
the
op
enness
of
R
means
that
[X
n
K
]R
is
op
en.
By
the
previous
lemma
w
e
ha
v
e
[X
n
K
]R
=
Y
n
(8R

)[K
]
2

(Y

)
whic
h,
again
b
y
Theorem
2.5,
implies
that
(8R

)[K
]
is
a
compact
saturated
subset
of
Y

.
Con
v
ersely
,
if
R

is
p
erfect
and
U
2

(X
)
then
X
n
U
is
compact
saturated
in
X

.
F
rom
the
previous
lemma
w
e
get
(8R

)[X
n
U
]
=
Y
n
Y
n
(8R

)[X
n
U
]
=
Y
n
[X
n
(X
n
U
)]R
=
Y
n
[U
]R
whic
h
is
a
compact
saturated
subset
of
Y

b
e-
cause
of
the
p
erfectness
of
R

.
Consequen
tly
,
its
complemen
t
[U
]R
is
an
op
en
subset
of
Y
.
2
147

Jung,
Kegelmann
and
Moshier
4.2
A
djunctions
As
usual
in
an
order-enric
hed
category
,
w
e
sa
y
that
for
t
w
o
closed
relations
R
:
X
+
-
Y
is
the
left
or
lower
adjoint
of
S
:
Y
+
-
X
if
S
;
R
:
X
+
-
X
is
b
elo
w
the
iden
tit
y
and
if
R
;
S
:
Y
+
-
Y
is
ab
o
v
e
the
iden
tit
y
on
Y
.
Lik
ewise,
S
is
called
the
right
or
upp
er
adjoint
of
R
.
The
question
is
what
is
the
righ
t
order
on
the
homsets
SCS

(X
;
Y
).
One
c
hoice
is
subset
inclusion
but
it
turns
out
to
b
e
b
etter
to
use
the
one
induced
from
the
corresp
onding
homsets
SCS
 X
;
K(Y
)

,
in
k
eeping
with
Prop
osition
2.10.
Since
K(Y
)
is
ordered
b
y
rev
erse
inclusion
this
means
that
the
relations
in
the
homsets
for
SCS

are
also
ordered
b
y
rev
erse
inclusion
of
their
graphs.
Note
that
adjoin
ts
determine
eac
h
other
uniquely
as
is
the
case
in
an
y
order-enric
hed
category
.
Lemma
4.6
The
functors


and
pt

pr
eserve
the
or
der
on
the
homsets,
thus
making
SCS

and
SCF

dual
ly
e
quivalent
as
or
der-enriche
d
c
ate
gories.
Conse-
quently,
we
have
R
a
S
for
close
d
r
elations
if
and
only
if


(S
)
a


(R
).
Pro
of.
The
rst
claim
can
easily
b
e
v
eried
from
the
denition
of
the
t
w
o
functors.
Then
the
second
is
an
immediate
consequence.
Note,
ho
w
ev
er,
that
b
ecause
of
con
tra
v
ariance
the
role
of
lo
w
er
and
upp
er
adjoin
t
are
rev
ersed.
2
Upp
er
adjoin
ts
ha
v
e
a
v
ery
concise
c
haracterization:
Theorem
4.7
A
close
d
r
elation
R
:
X
+
-
Y
has
a
lower
adjoint
if
and
only
if
it
is
p
erfe
ct
and
functional.
Pro
of.
F
rom
the
previous
lemma
w
e
kno
w
that
R
has
a
lo
w
er
adjoin
t
if
and
only
if


(R
)
has
an
upp
er
adjoin
t.
As
w
e
kno
w,


(R
)
is
a
con
tin
uous
semilattice
homomorphism
and
as
a
monotone
function
b
et
w
een
the
complete
lattices


(Y
)
=

(Y
)
and


(X
)
=

(X
)
it
is
a
lo
w
er
adjoin
t
if
and
only
if
it
preserv
es
all
suprema.
By
Prop
osition
3.6
this
is
the
case
precisely
when
R
is
functional.
In
this
case
w
e
ha
v
e
an
upp
er
adjoin
t
u
:


(X
)
!


(Y
),
but
it
need
not
b
e
a
con
tin
uous
semilattice
homomorphism.
As
an
upp
er
adjoin
t
it
preserv
es
all
inma,
but
it
is
Scott
con
tin
uous
if
and
only
if
its
adjoin
t


(R
)
preserv
es
the
w
a
y-b
elo
w
relation
(see
[1,
Prop
osition
3.1.14]).
F
rom
Prop
osition
4.2
w
e
kno
w
that
this
is
equiv
alen
t
to
R
b
eing
p
erfect.
2
Using
Prop
osition
4.3
ab
o
v
e
w
e
can
rephrase
this
as
follo
ws.
Corollary
4.8
A
close
d
r
elation
has
a
lower
adjoint
if
and
only
if
it
is
func-
tional
and
the
c
orr
esp
onding
function
is
p
atch
c
ontinuous,
i.e.
c
ontinuous
with
r
esp
e
ct
to
the
p
atch
top
olo
gies.
In
the
case
of
Hausdor
spaces
the
last
condition
is
trivially
true
since
the
patc
h
top
ology
is
simply
the
original
top
ology
.
Hence,
w
e
get
the
follo
wing
result.
Corollary
4.9
A
close
d
r
elation
b
etwe
en
c
omp
act
Hausdor
sp
ac
es
is
a
c
on-
tinuous
function
if
and
only
if
it
has
a
lower
adjoint
in
SCS

.
148

Jung,
Kegelmann
and
Moshier
-
L
e
e
e
e
e

J
J
J
J



1
0
b
?
S
B
U
a
Fig.
1.
A
non-functional
em
b
edding
retraction
pair.
Consider
the
t
w
o
p
osets
giv
en
in
Figure
1.
W
e
dene
t
w
o
closed
relations
L
:=
f0g

B
[
f1g

fa;
bg
and
U
:=
f?g

S
[
fa;
bg

f1g
whic
h
is
the
h
yp
ergraph
of
the
function
that
maps
?
to
0
and
iden
ties
a
and
b
b
y
mapping
them
to
1.
W
e
ha
v
e
L
;
U
=
id
S
and
also
U
;
L
v
id
B
whic
h
sho
ws
that
they
form
a
em
b
edding-pro
jection
pair
in
the
sense
that
L
is
a
lo
w
er
adjoin
t
section
and
U
the
corresp
onding
upp
er
adjoin
t
retraction.
This
example
sho
ws
that
em
b
eddings
need
not
b
e
functional.
W
e
can,
ho
w
ev
er,
sa
y
explicitly
what
this
lo
w
er
adjoin
t
do
es.
Essen
tially
it
is
just
taking
preimages
under
the
function
corresp
onding
to
its
adjoin
t:
Prop
osition
4.10
L
et
u
:
X
!
Y
b
e
a
p
erfe
ct
c
ontinuous
function
b
etwe
en
stably
c
omp
act
sp
ac
es,
U
:
X
+
-
Y
its
hyp
er
gr
aph
and
L
the
lower
adjoint.
Then
we
have
y
L
x
(
)
x
2
(8U
)["
y
]
(
)
y

u(x)
and
the
c
orr
esp
onding
multi-function
f
L
:
Y
!
K(X
)
satises
f
L
(y
)
=
u
 1
["y
]:
Pro
of.
Note
that
w
e
ha
v
e
x
2
(8U
)["y
]
(
)
x
2
u
 1
["y
]
b
y
Lemma
3.2,
and
hence
the
descriptions
of
the
adjoin
t
giv
en
in
the
prop
osition
agree.
W
e
b
egin
b
y
sho
wing
that
L
is
a
closed
relation.
The
easiest
pro
of
is
to
sho
w
that
f
L
is
con
tin
uous:
It
factorizes
as
Y
"
-
K(Y
)
u
 1
[]
-
K(X
)
where
the
rst
function
is
already
kno
wn
to
b
e
con
tin
uous.
The
spaces
K(Y
)
and
K(X
)
carry
the
Scott
top
ology
and
directed
suprema
are
giv
en
b
y
ltered
in
tersections
whic
h
are
preserv
ed
b
y
the
preimage
function
u
 1
[].
So,
f
L
is
a
comp
osition
of
con
tin
uous
functions.
T
o
sho
w
L
a
U
w
e
ha
v
e
to
c
hec
k
v
X
=
id
X

U
;
L
and
L;
U

id
Y
=
v
Y
since
the
order
on
the
homsets
is
rev
ersed
inclusion.
So,
for
x
v
x
0
w
e
ha
v
e
x
U
u(x)
L
x
0
since
u(x)
v
u(x
0
).
F
or
the
second
inclusion,
y
L
x
U
y
0
implies
y
v
u(x)
v
y
0
.
2
149

Jung,
Kegelmann
and
Moshier
5
Bilimits
As
our
nal
topic
w
e
consider
bilimits
in
SCS

.
In
domain
theory
suc
h
bilimits
are
usually
tak
en
o
v
er
directed
diagrams
of
em
b
edding-pro
jection
pairs.
As
p
oin
ted
out
in
[1
]
the
construction
do
esn't
dep
end
on
the
fact
that
the
mor-
phisms
are
sections
and
retractions
but
exclusiv
ely
on
the
prop
erties
of
the
adjunctions.
Hence,
w
e
discuss
the
construction
of
bilimits
using
this
setup.
Both
SCS

and
SCF

are
order
enric
hed
categories
and
supp
ort
the
notion
of
an
adjoin
t
pair.
W
e
denote
the
sub
categories
of
lo
w
er
adjoin
ts
b
y
SCS

l
and
SCF

l
,
resp
ectiv
ely
.
The
dual
categories
of
upp
er
adjoin
ts
are
denoted
b
y
SCS

u
and
SCF

u
.
In
the
follo
wing
w
e
discuss
bilimits
of
directed
diagrams
of
adjoin
t
closed
relations
b
et
w
een
stably
compact
spaces,
or
to
b
e
more
precise,
colimits
for
functors
from
a
directed
p
oset
I
to
the
sub
category
of
lo
w
er
adjoin
t
closed
relations
SCS

l
.
Theorem
5.1
Every
dir
e
cte
d
diagr
am
in
SCS

l
has
a
bilimit.
This
me
ans
that
it
has
a
c
olimit
which
is
also
a
c
olimit
for
the
whole
c
ate
gory
SCS

.
Mor
e
over,
the
c
orr
esp
onding
upp
er
adjoints
for
the
c
olimiting
c
o
c
one
make
it
into
limit
for
the
upp
er
adjoints
of
the
diagr
am
and
this
is
also
a
limit
in
the
ambient
c
ate
gory
SCS

.
Pro
of.
W
e
pro
v
e
this
via
the
Stone
dual.
So
let
I
b
e
a
directed
set
and
D
:
I
!
SCS

l
a
directed
diagram.
W
e
consider
the
comp
osition


√Ü
D
!
SCF

u
where
w
e
denote
the
ob
jects
as
L
i
:=


(D
(i))
and
the
morphisms
as

j
i
and
their
upp
er
adjoin
ts
as
 
ij
.
Suc
h
a
diagram
can
b
e
considered
to
consist
of
dcp
o's
and
Scott-con
tin
uous
maps.
Hence
the
general
domain
theoretic
mac
hinery
can
b
e
brough
t
to
b
ear,
cf.
[1,
Section
3.3]
and
[8,
Section
IV-3].
F
rom
this
w
e
kno
w
that
the
(domain-theoretic)
bilimit
is
giv
en
b
y

(x
i
)
i2I
2
Y
i2I
L
i


(8i
<
j
)
 
ij
(x
j
)
=
x
i
	
and
that
the
(Scott-con
tin
uous)
maps
 
j
:
L
!
L
j
,
 
j
((x
i
)
i2I
)
=
x
j
form
a
lim-
iting
cone
o
v
er
the
diagram
((L
i
)
i2I
;
( 
ij
)
ij
)
in
the
category
DCPO.
F
urther-
more,
the
(Scott-con
tin
uous)
maps

i
:
L
i
!
L,

i
(x)
=
 F
"
k
i;j
 
j
k
(
k
i
(x))

j
2I
form
a
colimiting
co
cone
of
the
diagram
((L
i
)
i2I
;
(
j
i
)
ij
)
in
DCPO.
The
fol-
lo
wing
relationships
hold:
(i)
F
or
all
i
2
I
,

i
is
a
lo
w
er
adjoin
t
of
 
i
.
(ii)
id
L
=
F
"
i2I

i
√Ü
 
i
.
(iii)
(8i;
j
2
I
)
 
j
√Ü

i
=
F
"
k
i;j
 
j
k
√Ü

k
i
.
(iv)
F
or
an
y
cone
(M
;
(
i
)
i2I
)
(of
Scott-con
tin
uous
maps)
o
v
er
the
diagram
((L
i
)
i2I
;
( 
ij
)
ij
)
the
mediating
morphism

:
M
!
L
is
giv
en
b
y

=
F
"
i2I

i
√Ü

i
.
150

Jung,
Kegelmann
and
Moshier
(v)
F
or
an
y
co
cone
(M
;
(
i
)
i2I
)
(of
Scott-con
tin
uous
maps)
o
v
er
the
diagram
((L
i
)
i2I
;
(
j
i
)
ij
)
the
mediating
morphism

:
L
!
M
is
giv
en
b
y

=
F
"
i2I

i
√Ü
 
i
.
The
ob
jects
and
morphisms
of
the
category
SCF

ha
v
e
additional
structure,
so
w
e
need
to
sho
w
the
follo
wing:
(a)
L
is
a
complete
lattice.
(b)
L
is
con
tin
uous.
(c)
L
is
distributiv
e.
(d)
The
w
a
y-b
elo
w
relation
on
L
is
m
ultiplicativ
e
and
1

1.
(e)
F
or
all
i
2
I
,

i
and
 
i
preserv
e
nite
inma.
(f
)
Assuming
that
the
cone
(resp.
co
cone)
maps
preserv
e
nite
inma,
so
do
the
mediating
morphisms.
F
or
the
sak
e
of
brevit
y
,
w
e
will
from
no
w
on
write
x
for
a
sequence
(x
i
)
i2I
wherev
er
p
ossible.
(a)
The
 
ij
,
as
upp
er
adjoin
ts,
preserv
e
all
inma.
Hence
these
are
calcu-
lated
p
oin
t
wise
in
L.
(b)
Con
tin
uit
y
follo
ws
for
dcp
o's
already
,
see
Theorem
3.3.11
in
[1].
Ho
w-
ev
er,
it
will
b
e
necessary
for
the
remaining
claims
to
ha
v
e
a
c
haracterization
of
the
w
a
y-b
elo
w
relation
on
L
at
hand.
F
or
this
observ
e
that
the

i
preserv
e
w
a
y-b
elo
w,
[1,
Prop
osition
3.1.14(2)];
w
e
can
therefore
emplo
y
prop
ert
y
2
ab
o
v
e
to
get
x

y
i
there
exists
an
index
j
2
I
and
elemen
ts
x

y
in
L
i
suc
h
that
x


j
(x)


j
(y
)

y
.
W
e
need
to
do
(e)
next:
The
 
i
preserv
e
inma
b
ecause
they
are
upp
er
adjoin
ts.
F
or
the
lo
w
er
adjoin
ts
w
e
exploit
the
fact
that
nite
meets
comm
ute
with
directed
join
ts
in
con
tin
uous
lattices,
[8,
Corollary
I-2.2].
The
claim
then
follo
ws
directly
from
the
form
ula
for
the

i
.
(c)
W
e
need
to
in
v
ok
e
the
con
tin
uit
y
of
L
for
this:
Assume
a

x
^
(y
_
z
).
Using
the
con
tin
uit
y
of
suprem
um
and
inm
um
w
e
kno
w
that
there
are
additional
sequences
a
0
,
b
and
c
suc
h
that
a

a
0
^
(b
_
c
)
and
a
0

x,
b

y
and
c

z
.
By
our
c
haracterization
of
w
a
y-b
elo
w
on
L
it
follo
ws
that
w
e
can
nd
elemen
ts
x;
y
;
z
in
some
appro
ximating
lattice
L
j
suc
h
that
a
0


j
(x)

x
,
etc.
No
w
w
e
can
calculate
a

a
0
^
(b
_
c)


j
(x)
^
(
j
(y
)
_

j
(z
))
=

j
(x
^
(y
_
z
))
=

j
((x
^
y
)
_
(x
^
z
))
=
(
j
(x)
^

j
(y
))
_
(
j
(x)
^

j
(z
))

(x
^
y
)
_
(x
^
z
).
(d)
This
is
similar
to
the
previous
item:
F
or
x

y
;
z
nd
x

y
,
x
0

z
in
some
L
j
suc
h
that
x


j
(x)


j
(y
)

y
and
x


j
(x
0
)


j
(z
)

z
.
The
claim
then
follo
ws
from
m
ultiplicativit
y
of

in
L
j
:
x


j
(x)
^

j
(x
0
)
=

j
(x
^
x
0
)


j
(y
^
z
)
=

j
(y
)
^

j
(z
)

y
^
z
.
F
or
1

1
just
observ
e
that
1

1
holds
in
eac
h
L
i
and
the
lo
w
er
adjoin
ts
are
SCF

maps,
that
is,
they
preserv
e
the
empt
y
meet.
(f
)
Lik
e
(e),
this
follo
ws
from
the
dening
form
ulas
for
mediating
mor-
phisms
and
the
fact
that
nite
meets
comm
ute
with
directed
suprema.
2
151

Jung,
Kegelmann
and
Moshier
The
limit-colim
i
t
coincidence
for
SCF

whic
h
w
e
established
in
the
pre-
ceding
pro
of
sa
ys
(among
other
things)
that
directed
colimits
in
SCF

l
are
also
colimits
in
the
original
category
of
semilattice
homomorphisms.
Both
the
diagram
maps

j
i
and
the
co
cone
maps

i
are
in
fact
lo
w
er
adjoin
ts
and
conse-
quen
tly
sup-preserving,
whic
h
means
that
they
are
frame
maps.
F
rame
maps
b
et
w
een
con
tin
uous
semilattices,
ho
w
ev
er,
are
not
necessarily
lo
w
er
adjoin
ts.
Nonetheless,
directed
colimits
in
SCF

l
are
also
colimits
of
frames,
as
our
next
lemma
sho
ws.
Lemma
5.2
The
emb
e
dding
of
SCF

l
into
the
c
ate
gory
F
rm
of
fr
ames
and
fr
ame
homomorphisms
pr
eserves
dir
e
cte
d
c
olimits.
Pro
of.
The
colimit
L
of
a
directed
diagram
((L
i
)
i2I
;
(
j
i
)
ij
)
in
SCF

l
as
con-
structed
in
the
pro
of
of
the
previous
theorem
yields
a
distributiv
e
con
tin
uous
lattice,
hence
a
(spatial)
frame,
[8,
Theorem
5.5].
The
colimiting
maps

i
are
lo
w
er
adjoin
ts
in
addition
to
b
eing
SCF

morphisms,
so
they
are
frame
homo-
morphisms.
What
needs
to
b
e
sho
wn
is
that
the
mediating
morphism

for
a
co
cone
(
i
)
i2I
of
frame
homomorphisms
is
again
a
frame
homomorphism.
Since
w
e
already
kno
w
that

will
b
e
a
con
tin
uous
semilattice
homomorphisms
all
that
remains
to
b
e
sho
wn
is
preserv
ation
of
(nite)
suprema.
The
pro
of
of
this
prop
ert
y
is
a
b
eautiful
in
terpla
y
b
et
w
een
form
ulas
2
and
3
from
the
preceding
theorem.
Let
X
b
e
a
set
of
elemen
ts
of
the
colimit
L.
W
e
calculate
for
the
non-trivial
inequalit
y:
(
G
X
)
=
G
"
j
2I

j
√Ü
 
j
(
G
X
)
denition
of

=
G
"
j
2I

j
√Ü
 
j
(
G
x2X
G
"
i2I

i
√Ü
 
i
(x))
form
ula
2
=
G
"
j
2I
G
"
i2I

j
√Ü
 
j
(
G
x2X

i
√Ü
 
i
(x))
asso
ciativit
y
=
G
"
j
2I
G
"
i2I

j
√Ü
 
j
√Ü

i
(
G
x2X
 
i
(x))

i
's
are
lo
w
er
adjoin
ts
=
G
"
j
2I
G
"
i2I

j
 G
"
k
i;j
 
j
k
√Ü

k
i
(
G
x2X
 
i
(x))

form
ula
3
=
G
"
j
2I
G
"
i2I
G
"
k
i;j

j
√Ü
 
j
k
(
G
x
2X

k
i
√Ü
 
i
(x
))

j
's
are
con
tin
uous
&

k
i
's
are
lo
w
er
adjoin
ts
=
G
"
j
2I
G
"
i2I
G
"
k
i;j

k
√Ü

k
j
√Ü
 
j
k
(
G
x
2X

k
i
√Ü
 
ik
√Ü
 
k
(x))
(co)cone
condition

G
"
j
2I
G
"
i2I
G
"
k
i;j

k
(
G
x2X
 
k
(x))
adjoin
tness
of

and
 
=
G
"
k
2I

k
(
G
x2X
 
k
(x))
redundan
t
indices
152

Jung,
Kegelmann
and
Moshier
=
G
"
k
2I
G
x
2X

k
√Ü
 
k
(x)

k
's
are
frame
maps
=
G
x2X
G
"
k
2I

k
√Ü
 
k
(x
)
asso
ciativit
y
=
G
x2X
(x)
denition
of

2
Theorem
5.3
The
functor
U
fr
om
SCS

u
to
SCS
pr
eserves
inverse
limits.
Pro
of.
The
dual
equiv
alence
b
et
w
een
SCS

u
and
SCF

l
transforms
in
v
erse
lim-
its
in
to
direct
colimits.
The
latter
are
preserv
ed
b
y
the
inclusion
of
SCF

l
in
to
F
rm
according
to
the
preceding
lemma.
Stone
dualit
y
translates
them
in
to
in
v
erse
limits
in
T
op
.
2
The
reader
ma
y
still
feel
a
bit
n
um
b
from
all
these
calculations
and
not
immediately
recognize
the
force
of
this
theorem.
Let
us
therefore
elab
orate
on
its
con
ten
t
a
little
bit.
T
op
is
a
complete
category
and
limits
are
calculated
in
the
usual
w
a
y:
If
D
:
I
!
T
op
is
a
functor
(for
an
y
diagram
D
)
then
the
p
oin
ts
of
lim
D
are
giv
en
b
y
thr
e
ads
:
lim
D
=

(x
i
)
i2ob
j(I)
2
Y
i2ob
j(I)
D
(i)


(8(f
:
i
!
j
)
2
mor(I))
D(f
)(x
i
)
=
x
j
	
The
top
ology
is
inherited
from
the
pro
duct
space
Q
i2ob
j(I)
D
(i).
Upp
er
adjoin
t
relations
b
et
w
een
stably
compact
spaces
are
functional
and
the
functor
U
asso-
ciates
with
ev
ery
suc
h
relation
the
generating
(p
erfect)
function.
Theorem
5.3
then
states
that
a
bilimit
in
N

is
calculated
top
ologically
as
the
limit
of
the
corresp
onding
in
v
erse
diagram
of
p
erfect
maps.
One
can
turn
this
around
and
sa
y
that
the
con
ten
t
of
the
theorem
is
to
recognize
in
v
erse
limits
of
p
erfect
maps
as
bilimits
in
an
order-enric
hed
setting,
yielding
a
limit-colimi
t
coin-
cidence
with
resp
ect
to
closed
relations.
This
app
ears
to
b
e
an
imp
ortan
t
rst
step
in
making
stably
compact
spaces
a
suitable
univ
erse
for
seman
tic
in
terpretations.
Ac
kno
wledgemen
ts
The
authors
are
grateful
for
the
man
y
commen
ts
they
receiv
ed
when
parts
of
this
researc
h
w
ere
presen
ted
at
earlier
o
ccasions.
Sp
ecial
thanks
go
to
Mart

n
Escard
o
for
his
careful
reading
of
a
draft
v
ersion
of
this
pap
er.
References
[1]
S.
Abramsky
and
A.
Jung.
Domain
theory
.
In
S.
Abramsky
,
D.
M.
Gabba
y
,
and
T.
S.
E.
Maibaum,
editors,
Handb
o
ok
of
L
o
gic
in
Computer
Scienc
e,
v
olume
3,
153

Jung,
Kegelmann
and
Moshier
pages
1{168.
Clarendon
Press,
1994.
[2]
B.
Banasc
hewski.
Another
lo
ok
at
the
Lo
calic
T
yc
hono
Theorem.
Commentationes
Mathematic
ae
Universitatis
Car
olinae,
29:647{656,
1988.
[3]
R.
Bird
and
O.
de
Mo
or.
A
lgebr
a
of
Pr
o
gr
amming,
v
olume
100
of
International
Series
in
Computer
Scienc
e.
Pren
tice
Hall,
1997.
[4]
N.
Bourbaki.
Gener
al
T
op
olo
gy.
Elemen
ts
of
Mathematics.
Springer
V
erlag,
1989.
[5]
C.
Brink,
W.
Kahl,
and
G.
Sc
hmidt,
editors.
R
elational
Metho
ds
in
Computer
Scienc
e.
Adv
ances
in
Computing
Science.
Springer
V
erlag,
1996.
[6]
M.
H.
Escard
o.
The
regular-lo
cally-compact
coreection
of
stably
lo
cally
compact
lo
cale.
Journal
of
Pur
e
and
Applie
d
A
lgebr
a,
157(1):41{55,
2001.
[7]
P
.
J.
F
reyd
and
A.
Scedro
v.
Cate
gories,
A
l
le
gories.
North-Holland,
1990.
[8]
G.
Gierz,
K.
H.
Hofmann,
K.
Keimel,
J.
D.
La
wson,
M.
Mislo
v
e,
and
D.
S.
Scott.
A
Comp
endium
of
Continuous
L
attic
es.
Springer
V
erlag,
1980.
[9]
R.-E.
Homann.
The
Fell
compactication
revisited.
In
R.-E.
Homann
and
K.
H.
Hofmann,
editors,
Continuous
L
attic
es
and
their
Applic
ations,
Pr
o
c
e
e
dings
of
the
thir
d
c
onfer
enc
e
on
c
ate
goric
al
and
top
olo
gic
al
asp
e
cts
of
c
ontinuous
lattic
es
(Br
emen
1982),
v
olume
101
of
L
e
ctur
e
Notes
in
Pur
e
and
Applie
d
Mathematics,
pages
57{116.
Marcel-Dekk
er,
1985.
[10]
K.
H.
Hofmann.
Stably
con
tin
uous
frames
and
their
top
ological
manifestations.
In
H.
L.
Ben
tley
,
H.
Herrlic
h,
M.
Ra
jagopalan,
and
H.
W
ol,
editors,
Cate
goric
al
T
op
olo
gy,
Pr
o
c
e
e
dings
of
1983
Confer
enc
e
in
T
ole
do,
v
olume
5
of
Sigma
Series
in
Pur
e
and
Applie
d
Mathematics,
pages
282{307,
Berlin,
1984.
Heldermann.
[11]
K.
H.
Hofmann
and
M.
Mislo
v
e.
Lo
cal
compactness
and
con
tin
uous
lattices.
In
B.
Banasc
hewski
and
R.-E.
Homann,
editors,
Continuous
L
attic
es,
Pr
o
c
e
e
dings
Br
emen
1979,
v
olume
871
of
L
e
ctur
e
Notes
in
Mathematics,
pages
209{248.
Springer
V
erlag,
1981.
[12]
P
.
T.
Johnstone.
F
actorization
and
pullbac
k
theorems
for
lo
calic
geometric
morphisms.
T
ec
hnical
Rep
ort
79,
Univ
ersit

e
catholique
de
Louv
ain,
1979.
[13]
A.
Jung.
The
classication
of
con
tin
uous
domains.
In
Pr
o
c
e
e
dings,
Fifth
A
nnual
IEEE
Symp
osium
on
L
o
gic
in
Computer
Scienc
e,
pages
35{40.
IEEE
Computer
So
ciet
y
Press,
1990.
[14]
A.
Jung,
M.
Kegelmann,
and
M.
A.
Moshier.
Multi
lingual
sequen
t
calculus
and
coheren
t
spaces.
F
undamenta
Informatic
ae,
37:369{412,
1999.
[15]
A.
Jung
and
Ph.
S

underhauf.
On
the
dualit
y
of
compact
vs.
op
en.
In
S.
Andima,
R.
C.
Flagg,
G.
Itzk
o
witz,
P
.
Misra,
Y.
Kong,
and
R.
Kopp
erman,
editors,
Pap
ers
on
Gener
al
T
op
olo
gy
and
Applic
ations:
Eleventh
Summer
Confer
enc
e
at
the
University
of
Southern
Maine,
v
olume
806
of
A
nnals
of
the
New
Y
ork
A
c
ademy
of
Scienc
es,
pages
214{230,
1996.
154

Jung,
Kegelmann
and
Moshier
[16]
A.
Jung
and
R.
Tix.
The
troublesome
probabilistic
p
o
w
erdomain.
In
A.
Edalat,
A.
Jung,
K.
Keimel,
and
M.
Kwiatk
o
wsk
a,
editors,
Pr
o
c
e
e
dings
of
the
Thir
d
Workshop
on
Computation
and
Appr
oximation,
v
olume
13
of
Ele
ctr
onic
Notes
in
The
or
etic
al
Computer
Scienc
e.
Elsevier
Science
Publishers
B.V.,
1998.
23
pages,
URL:
http://www.elsevier.nl/l
oca
te/e
ntcs
/vo
lume
13.h
tml
.
[17]
M.
Kegelmann.
Continuous
domains
in
lo
gic
al
form.
PhD
thesis,
Sc
ho
ol
of
Computer
Science,
The
Univ
ersit
y
of
Birmingham,
1999.
[18]
K.
Keimel
and
J.
P
asek
a.
A
direct
pro
of
of
the
Hofmann-Mislo
v
e
theorem.
Pr
o
c
e
e
dings
of
the
AMS,
120:301{303,
1994.
[19]
H.
P
.
A.
K

unzi
and
G.
C.
L.
Br

ummer.
Sobrication
and
bicompletion
of
totally
b
ounded
quasi-uniform
spaces.
Mathematic
al
Pr
o
c
e
e
dings
of
the
Cambridge
Philosophic
al
So
ciety,
101:237{246,
1987.
[20]
J.
D.
La
wson.
The
dualit
y
of
con
tin
uous
p
osets.
Houston
Journal
of
Mathematics,
5:357{394,
1979.
[21]
L.
Nac
h
bin.
T
op
olo
gy
and
Or
der.
V
on
Nostrand,
Princeton,
N.J.,
1965.
T
ranslated
from
the
1950
monograph
\T
op
ologia
e
Ordem"
(in
P
ortugese).
Reprin
ted
b
y
Rob
ert
E.
Kreiger
Publishing
Co.,
Hun
tington,
NY,
1967.
[22]
A.
Sc
halk.
A
lgebr
as
for
Gener
alize
d
Power
Constructions.
Do
ctoral
thesis,
T
ec
hnisc
he
Ho
c
hsc
h
ule
Darmstadt,
1993.
174
pp.
[23]
A.
K.
Simpson.
Recursiv
e
t
yp
es
in
Kleisli
categories.
Man
uscript
(a
v
ailable
from
http://www.dcs.ed.ac.uk),
1992.
[24]
M.
B.
Sm
yth.
Stable
compactication
I.
Journal
of
the
L
ondon
Mathematic
al
So
ciety,
45:321{340,
1992.
[25]
Ph.
S

underhauf.
Constructing
a
quasi-uniform
function
space.
T
op
olo
gy
and
its
Applic
ations,
67:1{27,
1995.
[26]
S.
J.
Vic
k
ers.
T
op
olo
gy
Via
L
o
gic,
v
olume
5
of
Cambridge
T
r
acts
in
The
or
etic
al
Computer
Scienc
e.
Cam
bridge
Univ
ersit
y
Press,
1989.
155

156

MFPS
17
Preliminary
Version
A
Game
Seman
tics
of
Idealized
CSP
J.
Laird
COGS,
University
of
Sussex
Brighton
BN1
9QH,
UK
E-mail:
jiml@cogs.susx.ac.uk
Abstract
A
seman
tics
is
describ
ed
for
a
t
yp
ed
functional
language
whic
h
includes
primitiv
es
for
parallel
comp
osition
and
for
sync
hronous
comm
unication
along
priv
ate
c
hannels.
The
category
of
games
on
whic
h
this
seman
tics
is
based
is
an
extension
of
that
in
tro
duced
b
y
Hyland
and
Ong,
with
m
ultiple
threads
of
con
trol
represen
ted
using
a
new
notion
of
\concurrency
p
oin
ter"
together
with
relaxation
of
the
condition
whic
h
requires
alternation
of
Pla
y
er
and
Opp
onen
t
mo
v
es.
The
seman
tics
is
pro
v
ed
to
b
e
fully
abstract
for
\c
hannel-free"
t
yp
es
with
resp
ect
to
a
may-and-must
notion
of
op
erational
equiv
alence,
using
factorization
results
to
reduce
denabilit
y
to
the
sequen
tial
case.
1
In
tro
duction
Game
seman
tics
has
b
een
successfully
used
to
giv
e
mo
dels
of
v
arious
sequen-
tial
programming
languages,
with
the
distinctiv
e
feature
that
man
y
of
the
underlying
notions
are
in
tensional,
com
bining
ideas
from
concurrency
theory
with
those
from
traditional
domain
theory
.
A
hierarc
h
y
of
fully
abstract
mo
d-
els
has
emerged,
based
on
the
Hyland-Ong
(HO)
mo
del
of
PCF
[11]
extended
with
non-functional
(but
still
sequen
tial)
features
suc
h
as
m
utable
state
and
store
[1,4]
and
con
trol
[12],
to
the
p
oin
t
where
there
is
no
w
a
thorough
anal-
ysis
of
se
quential
functional
computation
whic
h
is
to
a
large
exten
t
b
ase
d
on
c
oncurr
ency
(not
to
men
tion
\concurren
t
games"
[3]
|
w
e
shall
b
e
using
the
traditional
tok
en-based
approac
h
to
game
seman
tics
here).
Extending
existing
games
mo
dels
to
giv
e
an
in
terpretation
of
concurrency
features
is
therefore
a
natural
dev
elopmen
t.
This
pap
er
describ
es
suc
h
an
extension
of
HO
games
to
mo
del
(a
syn-
c
hronous
v
ersion
of
)
Bro
ok
es'
Idealized
CSP
[6];
a
t
yp
ed
call-b
y-name
-
calculus
with
arithmetic,
a
parallel
comp
osition
op
erator,
lo
cal
declaration
of
c
hannel
names
and
op
erations
send
and
recv
for
(ground-t
yp
e)
message
pass-
ing.
A
functor-category
seman
tics
of
the
sync
hronous
language
is
describ
ed
in
[6].
The
seman
tic
analysis
pro
vided
b
y
the
games
mo
del
is
complemen
tary;
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Laird
its
distinguishing
feature
is
that
it
captures
observ
ational
equiv
alence
(with
resp
ect
to
ma
y-and-m
ust
testing),
as
w
e
pro
v
e
with
a
full
abstraction
result.
(Although
this
is
restricted
to
t
yp
es
whic
h
do
not
include
o
ccurrences
of
the
base
t
yp
e
of
c
hannels
it
could
b
e
extended
to
all
t
yp
es
b
y
adding
a
\bad
c
han-
nel"
constructor
to
the
language,
analogous
to
the
\bad
v
ariable"
constructor
mkvar
whic
h
has
b
een
added
to
Idealized
Algol
for
the
same
purp
ose
[1
].)
The
basic
framew
ork
of
Hyland-Ong
games
giv
es
us
an
in
terpretation
of
the
-calculus.
The
extension
to
mo
del
concurrency
has
three
k
ey
features;
multi-thr
e
ading,
synchr
onous
message-p
assing
and
non-determinism.
The
in
terpretation
of
m
ultiple
threads
of
con
trol
requires
the
most
radical
extension
to
previous
w
ork
in
game
seman
tics.
It
is
based
up
on
adding
a
new
set
of
\concurrency
p
oin
ters"
(in
addition
to
the
existing
\justication
p
oin
ters")
to
the
sequences
whic
h
represen
t
in
teraction
of
strategies.
The
new
p
oin
ters
allo
w
a
\con
trol
thread"
to
b
e
extracted
for
eac
h
mo
v
e.
This
allo
ws
all
of
the
conditions
whic
h
constrain
sequences
in
HO
games
|
wel
l-br
acketing,
visibility
and
(in
a
new
departure)
alternation
|
to
b
e
relaxed
with
the
result
b
eing
total
c
haos;
eac
h
con
trol
thread
m
ust
satisfy
all
of
these
conditions,
ev
en
though
the
sequence
as
a
whole
ma
y
not.
There
is
a
natural
op
eration
of
parallel
comp
osition
of
strategies
in
the
m
ulti-threaded
setting,
based
on
in
terlea
ving
of
con
trol
threads.
Moreo
v
er,
w
e
sho
w
(b
y
factorization)
that
all
branc
hing
of
con
trol
threads
in
nitary
strategies
can
b
e
obtained
from
parallel
comp
osition.
Message
passing
along
priv
ate
c
hannels
is
in
terpreted
in
\ob
ject-orien
ted"
st
yle,
as
in
the
functor-category
mo
del
[6],
and
the
games
mo
dels
of
lo
cally
b
ound
references
[1,4]
and
exceptions
[13].
In
fact
the
in
terpretation
of
the
chan
t
yp
e
as
the
pro
ducts
of
its
\metho
ds",
send
and
recv
,
is
precisely
the
same
as
the
in
terpretation
of
the
var
and
its
metho
ds
(assignmen
t
and
de-
referencing)
in
the
games
mo
del
of
Idealized
Algol
[1].
Th
us
the
only
dierence
b
et
w
een
the
seman
tics
of
the
t
w
o
features
is
in
the
in
terpretations
of
the
new-
v
ariable
and
new-c
hannel
declarations.
Both
are
giv
en
in
terms
of
comp
osition
with
a
strategy
whic
h
violates
some
of
the
constrain
ts
ob
ey
ed
b
y
elemen
ts
corresp
onding
to
purely
functional
terms,
and
captures
the
causal
relationships
b
et
w
een
writing
and
reading
or
sending
and
receiving.
The
k
ey
prop
ert
y
of
the
\new-c
hannel"
strategy
is
that
it
con
tains
a
sync
hronous
comm
unication
b
et
w
een
con
trol
threads,
and
as
w
e
sho
w
b
y
a
factorization
result,
it
can
b
e
used
to
generate
all
suc
h
b
eha
viour
in
nitary
strategies
in
the
mo
del.
Non-determinism
arises
quite
naturally
in
the
seman
tics,
b
eing
implicit
in
the
in
terpretation
of
message
passing.
A
game
seman
tics
of
Idealized
Al-
gol
with
explicit
non-determinism
has
b
een
giv
en
b
y
Harmer
and
McCusk
er
[7
],
fully
abstract
for
a
\ma
y
and
m
ust
equiv
alence".
The
approac
h
to
non-
determinism
tak
en
here
has
man
y
features
in
common
with
that
w
ork;
it
leads
to
a
similar
ma
y-and-m
ust
full
abstraction
result,
for
instance.
Ho
w
ev
er,
man
y
of
the
details
are
dieren
t,
as
the
represen
tations
of
div
ergence
used
in
[7]
ap-
ply
only
in
a
sequen
tial
setting.
158

Laird
The
remainder
of
the
pap
er
is
organized
as
follo
ws.
In
section
2,
a
syn
tax,
op
erational
seman
tics
and
notion
f
observ
ational
equiv
alence
are
giv
en
for
ICSP
.
Section
3
denes
the
category
of
\m
ulti-threaded
games"
whic
h
is
the
basis
for
the
mo
del.
Section
4
giv
es
the
denotational
seman
tics
of
ICSP
in
this
category
,
and
sho
ws
that
it
is
sound.
Section
5
uses
t
w
o
factorization
results
to
sho
w
that
ev
ery
nitary
strategy
in
the
mo
del
is
denable
as
a
term
of
ICSP
,
from
whic
h
full
abstraction
follo
ws.
2
Syn
tax
and
op
erational
seman
tics
of
Idealized
CSP
Idealized
CSP
[6
],
or
ICSP
,
is
based
on
the
call-b
y-name
-calculus,
with
t
yp
es
generated
from
a
basis
consisting
of
comm
(commands),
nat
(natural
n
um
b
ers)
and
chan
(c
hannels
for
sending
and
receiving
natural
n
um
b
ers).
T
::=
comm
j
nat
j
chan
j
T
)
T
T
erms
are
formed
according
to
the
follo
wing
grammar:
M
::=
x
j
skip
j
0
j
succ
M
j
pred
M
j
IF0
M
M
M
j
x:M
j
M
M
nil
j
M
;
M
j
M
kM
j
newchan
M
j
send
M
M
j
recv
M
The
language
com
bines
the
-calculus
with
concurrency
primitiv
es
(based
on
CSP
[9])
m
uc
h
as
Idealized
Algol
[18
]
do
es
with
imp
erativ
e
features
(an
in-
tellectual
debt
ac
kno
wledged
in
its
name);
declaring
a
new
c
hannel
name
and
sending
and
receiving
on
it
are
analogous
to
declaring,
allo
cating
and
deal-
lo
cating
a
v
ariable.
T
yping
judgemen
ts
for
the
concurrency
features
are
as
follo
ws:
 `M
:B
 `N
:B
 `M
kN
:B
B
=
nat
j
comm
 `M
:chan
)B
 `newchan
M
:B
 `M
:chan
 `N
:nat
 `send
M
N
:comm
 `M
:chan
 `recv
M
:nat
Par
al
lel
c
omp
osition
of
terms
M
kN
is
ev
aluated
b
y
splitting
the
con
trol
thread
in
t
w
o
and
(concurren
tly)
ev
aluating
M
in
one
thread
N
in
the
other.
The
op-
eration
newchan
allo
ws
lo
cal
or
priv
ate
c
hannels
to
b
e
declared
|
newchan
M
supplies
a
new
c
hannel
name
as
an
argumen
t
to
M
:
chan
)
B
and
adds
it
to
the
en
vironmen
t.
Ev
aluation
of
send
is
b
y
reducing
its
second
argumen
t
to
a
v
alue
(n
umeral)
and
then
its
rst
argumen
t
to
a
c
hannel
name,
recv
ev
aluates
its
argumen
t
to
a
c
hannel
name,
and
send
a
v
and
recv
a
reduce
in
parallel
to
skip
and
v
resp
ectiv
ely
.
The
k
ey
dierence
from
the
language
describ
ed
in
[6]
is
that
message
passing
is
sync
hronous.
W
e
ha
v
e
also
omitted
lo
cal,
assignable,
ground
t
yp
e
references

a
la
Idealized
Algol
(adding
these
to
our
mo
del
b
y
follo
wing
[1
]
is
straigh
tforw
ard)
and,
more
signican
tly
,
an
y
form
of
recursion.
The
op
erational
seman
tics
is
giv
en
in
terms
of
a
\small-step"
reduction
159

Laird
relation
on
congurations
of
ICSP
.A
conguration
C
=
N
1
;
:
:
:
;
N
k
is
a
m
ul-
tiset
of
thr
e
ads
|
ICSP
programs
of
the
same
(base)
t
yp
e
|
con
taining
the
free
c
hannel
names
Ch
(C
).
The
reduction
rules
use
the
notion
of
evaluation
c
ontext
to
pic
k
out
a
unique
next
redex
for
eac
h
thread
whic
h
is
not
a
v
alue.
Denition
2.1
Ev
aluation
con
texts
are
giv
en
b
y
the
follo
wing
grammar:
E
[]
::=[]
j
E
[]
M
j
pred
E
[]
j
succ
E
[]
j
IF0
E
[]
M
N
E
[];
M
j
send
M
E
[]
j
send
E
[]
n
j
recv
E
[]
The
(non-arithmetic)
small-step
reduction
rules
are
as
follo
ws:
E
[x:M
N
];
C
 !
E
[M
[N
=x]];
C
E
[skip
;
M
];
C
 !
E
[M
];
C
E
[M
kN
];
C
 !
E
[M
];
E
[N
];
C
E
[newchan
M
];
C
 !
E
[M
c];
C
:
c
62
C
h(E
[newchan
M
];
C
)
E
[send
a
n];
E
0
[recv
a];
C
 !
E
[skip
];
E
[n];
C
:
The
fact
that
ev
aluation
of
a
conguration
alw
a
ys
terminates
can
b
e
estab-
lished
using
a
standard
\computabilit
y
predicate"
based
pro
of.
Prop
osition
2.2
Ther
e
is
no
innite
series
of
c
ongur
ations
C
1
;
C
2
;
:
:
:
C
n
;
:
:
:
such
that
C
1
 !
C
2
 !
:
:
:
 !
C
n
 !
:
:
:
.
2
V
arious
programming
constructs
suc
h
as
Algol-st
yle
store
and
non-deterministic
c
hoice
can
b
e
expressed
in
ICSP
.
A
useful
example;
for
an
y
n
>
0
dene
the
program
oracle
n
whic
h
erratically
pro
duces
one
of
the
n
um
b
ers
less
than
n.
oracle
n
=
newchan
c:((send
c
0ksend
c
1k
:
:
:
ksend
c
(n
 1));
nilkrecv
c)
F
or
examples
of
solutions
to
more
subtle
programming
problems
in
v
olving
concurrency
see
e.g.
[6
].
2.1
Conver
genc
e
testing
and
op
er
ational
e
quivalenc
e
Observ
ational
equiv
alence
is
dened
with
resp
ect
to
a
simple
test
|
ha
ving
at
least
one
con
v
ergen
t
thread.
Denition
2.3
Dene
the
predicate
+
may
(ma
y
con
v
ergence)
on
congura-
tions
of
t
yp
e
comm
as
follo
ws:
C
;
skip
+
may
9C
0
:C
!
C
0
^
C
0
+
may
C
+
may
T
erms
M
;
N
:
T
are
may-e
quivalent
if
for
all
program
con
texts
C
[]
:
comm
,
C
[M
]
+
may
if
and
only
if
C
[N
]
+
may
.
Ma
y-equiv
alence
of
an
inheren
tly
non-deterministic
language
suc
h
as
ICSP
is
rather
w
eak
|
it
leads
to
a
failure
to
distinguish
programs
whic
h
alw
a
ys
160

Laird
con
v
erge
from
those
whic
h
ma
y
con
v
erge
or
div
erge
[8,7].
Our
mo
del
will
reect
may-and-must
equiv
alence
in
a
similar
w
a
y
to
[7].
Denition
2.4
Dene
the
predicate
+
must
(
m
ust
con
v
ergence)
on
congura-
tions:
C
;
skip
+
must
8C
0
:(C
!
C
0
)
=
)
C
0
+
must
C
+
must
T
erms
M
;
N
:
T
are
must-e
quivalent
if
for
all
closing
con
texts
C
[]
:
comm
,
C
[M
]
+
must
if
and
only
if
C
[N
]
+
must
.
W
e
shall
write
M
'
M
&M
T
N
if
M
and
N
are
ma
y-equiv
alen
t
and
m
ust-equiv
alen
t.
3
Multi-threaded
games
The
games
constructions
whic
h
will
b
e
used
to
mo
del
ICSP
are
based
on
those
giv
en
b
y
Hyland
and
Ong
[11]
and
Nic
k
au
[15]
(and
dev
elop
ed
in
[14,1,4
,10]),
in
whic
h
states
of
the
game
are
represen
ted
as
justie
d
se
quenc
es
of
mo
v
es.
Ho
w
ev
er,
in
order
to
mo
del
concurrency
it
is
necessary
to
enric
h
this
structure
b
y
adding
a
new
notion
of
`concurrency
p
oin
ter'
to
justied
sequences,
whic
h
allo
ws
m
ultiple
threads
of
con
trol
to
b
e
represen
ted
in
a
single
sequence.
The
structure
of
a
game
(the
mo
v
es,
their
lab
els,
ho
w
they
are
related)
is
sp
ecied
b
y
its
ar
ena,
dened
essen
tially
as
in
[11
].
An
ar
ena
is
a
triple
A
=
hM
A
;
`
A

(M
A
)


M
A
;

A
:
M
A
!
fQ;
Agi,
where:
M
A
is
a
set
of
tok
ens
called
mo
v
es,
`
A

(M
A
)


M
A
is
a
relation
called
enabling,
from
whic
h
a
unique
p
olarit
y
for
all
of
the
mo
v
es
in
M
A
can
b
e
inferred
using
the
rule:
v
m
is
an
O
-mo
v
e
if
it
is
initial
(i.e.

`
m),
or
enabled
b
y
a
P
-mo
v
e,
m
is
a
P
-mo
v
e
if
it
is
enabled
b
y
an
O
-mo
v
e,

A
:
M
A
!
fQ;
Ag
is
a
function
whic
h
lab
els
mo
v
es
as
answers
(A)
or
questions
(Q),
suc
h
that
ev
ery
answ
er
has
a
unique
enabling
mo
v
e
whic
h
is
a
question.
In
a
sequence
of
mo
v
es
sa,
a
justication
p
oin
ter
for
s
is
a
p
oin
ter
from
a
to
some
mo
v
e
in
s
whic
h
enables
a.
A
justie
d
se
quenc
e
o
v
er
an
arena
A
is
a
sequence
of
elemen
ts
of
M
A
in
whic
h
eac
h
non-initial
mo
v
e
a
has
a
justication
p
oin
ter.
W
e
shall
write
J
A
for
the
set
of
justied
sequences
o
v
er
A.
The
transitiv
e
closure
of
justication
is
referred
to
as
her
e
ditary
justic
ation.
V
arious
rules
|
alternation,
visibilit
y
and
w
ell-brac
k
eting
|
constrain-
ing
justied
sequences
ha
v
e
b
een
in
tro
duced
[11
]
for
dening
the
set
of
le
gal
se
quenc
es
(i.e.
v
alid
Pla
y
er-Opp
onen
t
in
teractions)
o
v
er
an
arena.
Denition
3.1
A
justied
sequence
t
satises
the
alternation
condition
if
Opp
onen
t
mo
v
es
are
alw
a
ys
follo
w
ed
b
y
Pla
y
er
mo
v
es,
and
vice-v
ersa.
T
o
dene
the
visibility
condition
requires
the
notion
of
Pla
y
er
(and
Opp
o-
nen
t)
view.
These
represen
t
a
certain
kind
of
\relev
an
t
history
of
the
sequence"
from
Pla
y
er's
(Opp
onen
t's)
p
ersp
ectiv
e.
161

Laird
Denition
3.2
The
Pla
y
er
view
psq
of
a
justied
sequence
s
is
a
sequence
with
justication
p
oin
ters,
dened
inductiv
ely
on
the
length
of
s,
as
follo
ws:
p"q
=
",
psaq
=
psqa;
if
a
is
a
Pla
y
er
mo
v
e,
psaq
=
a;
if
a
is
an
initial
Opp
onen
t
mo
v
e,
psa

tbq
=
psqab;
if
b
is
an
Opp
onen
t
mo
v
e
justied
b
y
a.
There
is
a
dual
notion
of
Opp
onen
t
view,
xsy,
dened:
x"y
=
",
xsay
=
xsya;
if
a
is
an
Opp
onen
t
mo
v
e,
xsa

tby
=
xsyab;
if
b
is
a
Pla
y
er
mo
v
e
justied
b
y
a.
Denition
3.3
A
justied
sequence
s
ob
eys
the
visibility
condition
if
the
Pla
y
er
and
Opp
onen
t
views
of
ev
ery
prex
of
s
are
w
ell-formed
justied
se-
quences.
The
br
acketing
c
ondition
requires
that
eac
h
answ
er
m
ust
b
e
justied
b
y
the
most
recen
t
op
en
question.
Denition
3.4
Dene
the
p
ending
questions
(a
set
con
taining
at
most
one
mo
v
e)
of
a
justied
sequence
as
follo
ws:
p
ending
(")
=
fg,
p
ending
(sb)
=
fbg,
if
(b)
=
Q,
p
ending
(sbtc)
=
p
ending
(s)
if
(c)
=
A
and
c
is
justied
b
y
b.
A
single-threaded
sequence
s
is
wel
l-br
ackete
d
if
for
ev
ery
prex
r
atb
v
s,
if
(b)
=
A
and
b
is
justied
b
y
a,
then
p
ending
(sat)
=
fag.
The
set
L
A
of
le
gal
se
quenc
es
o
v
er
an
arena
A
consists
of
the
set
of
justied
sequences
(o
v
er
A)
whic
h
ob
ey
the
alternation,
visibilit
y
and
w
ell-brac
k
eting
conditions.
3.1
Multi-thr
e
ade
d
Se
quenc
es
W
e
shall
no
w
dene
the
multi-thr
e
ade
d
se
quenc
es
on
whic
h
our
mo
del
is
based.
They
are
formed
b
y
adding
new
\concurrency
p
oin
ters"
to
justied
sequences.
Denition
3.5
Let
sa
b
e
a
sequence
of
mo
v
es
with
justication
p
oin
ters.
A
concurrency
p
oin
ter
for
a
is
a
p
oin
ter
from
a
to
some
single
(o
ccurrence
of
a)
mo
v
e
in
s,
whic
h
distinct
from
its
justication
p
oin
ter
(if
an
y).
A
mo
v
e
is
thr
e
ad-initial
if
it
do
es
not
ha
v
e
a
concurrency
p
oin
ter.
A
justied
sequence
without
concurrency
p
oin
ters
(that
is,
the
standard
notion
of
justied
sequence
used
in
[11])
is
said
to
b
e
\single-threaded".
162

Laird
By
tracing
bac
k
concurrency
p
oin
ters,
w
e
can
extract
a
series
of
single-
threaded
subsequences,
or
\con
trol
threads"
from
eac
h
m
ulti-threaded
se-
quence.
Denition
3.6
The
c
ontr
ol
thr
e
ad
of
the
last
mo
v
e
in
a
sequence
s
is
dened
b
y
induction
on
length
as
follo
ws:
CT(a)
=
a,
if
a
is
thread-initial,
CT(sa

tb)
=
CT(sa)b
if
b
has
a
concurrency
p
oin
ter
to
a.
A
multi-thr
e
ade
d
justie
d
se
quenc
e
is
a
sequence
with
b
oth
concurrency
and
justication
p
oin
ters,
suc
h
that
eac
h
thread
is
a
justied
sequence
|
i.e.
ev
ery
non-initial
mo
v
e
has
a
justication
p
oin
ter
to
a
mo
v
e
in
its
con
trol
thread.
Denition
3.7
F
or
an
arena
A,
let
M
T
A
b
e
the
set
of
m
ulti-threaded
se-
quences
o
v
er
A,
and
dene
the
set
of
m
ulti-threaded
justied
sequences
as
follo
ws:
J
M
A
=
fs
2
M
T
A
j
8t
v
s:CT(t)
2
J
A
g.
T
o
dene
a
notion
of
m
ulti-threaded
le
gal
sequence,
w
e
use
the
conditions
of
alternation,
visibilit
y
and
w
ell-brac
k
eting,
applying
them
not
to
the
sequence
itself,
but
to
its
threads.
Th
us,
in
a
new
departure
for
games
mo
dels,
the
condition
of
alternation
has
b
een
relaxed.
Denition
3.8
Let
LM
A
=
fs
2
J
M
A
j
8t
v
s:CT
(t)
2
L
A
g.
Note
that
in
a
m
ulti-threaded
legal
sequence,
the
concurrency
p
oin
ters
m
ust
ob
ey
the
conditions
whic
h
apply
to
justication
p
oin
ters
|
i.e.
Opp
o-
nen
t
mo
v
es
p
oin
t
to
Pla
y
er
mo
v
es
and
vice-v
ersa,
and
only
(initial)
Opp
onen
t
mo
v
es
ma
y
b
e
thread-initial
(but
initial
mo
v
es
need
not,
in
general,
b
e
thread-
initial).
Idealized
CSP
con
tains
limited
facilities
for
sync
hronizing
ev
en
ts
o
ccurring
in
dieren
t
threads;
corresp
ondingly
,
in
the
mo
del,
Pla
y
er
will
ha
v
e
only
lim-
ited
p
o
w
er
to
observ
e
and
con
trol
the
actual
ordering
of
mo
v
es
in
dieren
t
threads.
Pla
y
er
can
w
ait
un
til
a
giv
en
O
-mo
v
e
has
o
ccurred
b
efore
giving
a
resp
onse
(in
the
language
it
is
p
ossible
to
susp
end
ev
aluation
of
a
thread
un
til
an
ev
en
t
o
ccurs
in
another
thread).
Ho
w
ev
er,
Pla
y
er
cannot
force
a
P
-mo
v
e
to
o
ccur
b
efore
another
(Pla
y
er
or
Opp
onen
t)
mo
v
e,
and
cannot
observ
e
the
order
in
whic
h
t
w
o
con
tiguous
O
-mo
v
es
o
ccur.
T
o
reect
these
constrain
ts,
w
e
dene
a
relation
,
suc
h
that
s

t
if
s
can
b
e
obtained
from
t
b
y
migrating
P
mo
v
es
forw
ard,
and
migrating
O
-mo
v
es
bac
k.
Denition
3.9
Let

b
e
the
least
preorder
on
m
ulti-threaded
legal
sequences
suc
h
that
for
all
sab

t;
sba

t
2
LM
A
suc
h
that

O
P
(a)
=
O
or

O
P
(b)
=
P
,
sab

t

sba

t.
The
original
represen
tation
of
sequen
tial,
deterministic
strategies
in
[11],
is
as
sets
of
ev
en-length
sequences
in
whic
h
the
nal
mo
v
e
represen
ts
the
resp
onse
of
Pla
y
er
to
the
preceding
sequence.
Harmer
and
McCusk
er
[7]
observ
e
that
163

Laird
this
form
of
represen
tation
is
not
su√Ücien
t
to
mo
del
a
simple
non-deterministic
functional
language
up
to
ma
y
and
must
equiv
alence;
for
example,
it
iden
ties
a
strategy
whic
h
alw
a
ys
con
v
erges
with
one
whic
h
ma
y
con
v
erge
or
div
erge.
The
solution
adopted
in
[7
]
is
to
represen
t
eac
h
strategy
using
t
w
o
sets
of
traces;
a
set
of
ev
en-length
sequences
represen
ting
Pla
y
er
resp
onses
in
the
usual
w
a
y
,
and
a
set
of
o
dd-length
sequences
represen
ting
the
diver
genc
es
of
the
strategy
|
p
ositions
in
whic
h
it
ma
y
fail
to
resp
ond.
Without
the
alterna-
tion
condition,
it
is
no
longer
the
case
that
the
space
of
p
ositions
is
partitioned
b
et
w
een
those
in
whic
h
it
is
Opp
onen
t's
turn
to
mo
v
e,
and
those
in
whic
h
it
is
Pla
y
er's
turn
to
mo
v
e.
Th
us
it
is
not
clear
what
should
coun
t
as
a
div
ergence
|
Pla
y
er
migh
t
require
sev
eral
O
-mo
v
es
to
prompt
a
resp
onse.
Similarly
,
Pla
y
er
ma
y
a
string
of
mo
v
es
without
w
aiting
for
Opp
onen
t's
resp
onse.
So
w
e
represen
t
a
m
ulti-threaded
strategy

on
an
arena
A
as
a
set
of
legal
sequences
of
A
whic
h

may
p
erform
in
conjunction
wit
an
Opp
onen
t,
and
ha
ving
done
so
may
w
ait
for
further
O
-mo
v
es
b
efore
doing
an
ything
else.
W
e
shall
write
T

for
the
set
fs
2
LM
A
j
9t
2

:s
v
tg
of
reac
hable
tr
ac
es
of

.
Denition
3.10
A
(m
ulti-threaded)
strategy

:
A
is
a
subset
of
LM
A
sub-
ject
to
the
follo
wing
conditions:

"
2

,


is
closed
with
resp
ect
to

|
s

t
and
t
2
T

implies
s
2

.

the
extension
of
a
reac
hable
p
osition
with
an
O
-mo
v
e
is
reac
hable
|
if
s
2
T

,
and
a
is
an
O
-mo
v
e
suc
h
that
sa
2
LM
A
then
sa
2
T

,

in
an
y
reac
hable
p
osition,

m
ust
either
pla
y
a
P
-mo
v
e
or
w
ait
for
another
O
-mo
v
e
|if
s
2
T

then
either
s
2

or
there
is
some
P
-mo
v
e
a
suc
h
that
sa
2
T

.
A
single-threaded
strategy
on
A
is
a
subset
of
L
A
satisfying
these
conditions
(closure
under

is
clearly
trivial).
A
category
based
on
m
ulti-threaded
games
can
no
w
b
e
dened.
Because
no
new
structure
at
the
lev
el
of
arenas
is
required,
the
standard
constructions
|
pro
ducts
and
function-spaces
|
are
unaected.
Pro
duct
F
or
an
y
set-indexed
family
of
arenas
fA
i
j
i
2
I
g,
form
the
pro
duct
A
=

i2I
A
i
as
follo
ws:

M

i2I
A
i
=
`
i2I
M
A
i
,

hm;
ii
`

i2I
A
i
hn;
j
i
if
i
=
j
and
m
`
A
i
n,
and

`

i2I
A
i
hn;
j
i
if

`
A
j
n,


QA

i2I
A
i
(hm;
ii)
=

A
i
(m).
W
e
shall
write
A
k
for

k
i=1
A,
and
1
for
the
empt
y
game
(0-ary
pro
duct).
F
unction
Space
F
or
arenas
A
1
;
A
2
,
form
A
1
)
A
2
as
follo
ws:

M
A
1
)A
2
=
M
A
1
+
M
A
2
,

hm;
ii
`
A
1
)A
2
hn;
j
i
if
i
=
j
and
m
`
n
or
m
2
M
A
2
,
n
2
M
A
1
and

`
A
2
m
and

`
A
1
n,

`
hm;
ii
if
m
2
M
A
2
and

`
A
2
m,
164

Laird


QA
A
1
)A
2
(hm;
ii)
=

A
i
(m).
W
e
can
no
w
dene,
in
a
standard
fashion
[5,11],
a
category
G
M
of
m
ulti-
threaded
games,
in
whic
h
the
ob
jects
are
arenas,
and
the
morphisms
from
A
to
B
are
the
m
ulti-threaded
strategies
on
A
)
B
.
W
e
shall
write

:
A
for
a
morphism

:
1
!
A.
Comp
osition
in
the
category
is
dened
using
a
notion
of
restriction
on
m
ulti-threaded
sequences,
whic
h
\mends"
b
oth
justication
and
concurrency
p
oin
ters.
Denition
3.11
Giv
en
s
2
L
(A
1
)A
2
))A
3
,
s

(A
i
;
A
j
)
(i
<
j
)
is
a
m
ulti-
threaded
sequence
on
A
i
)
A
j
dened
as
follo
ws:
"

(A
i
;
A
j
)
=
"
sa

(A
i
;
A
j
)
=
s

(A
i
;
A
j
)
if
a
62
M
A
i
;
M
A
j
sa

(A
i
;
A
j
)
=
(s

(A
i
;
A
j
))a
if
a
2
M
A
i
;
M
A
j
.
The
justier
of
a
in
sa

(A
i
;
A
j
)
is
the
most
recen
tly
pla
y
ed
mo
v
e
from
A
i
or
A
j
whic
h
her
e
ditarily
justies
a.
(If
there
is
no
suc
h
mo
v
e,
then
a
is
initial.)
The
concurrency
p
oin
ter
from
a
p
oin
ts
to
the
most
recen
tly
pla
y
ed
mo
v
e
(if
an
y)
from
A
i
or
A
j
whic
h
is
in
CT(sa).
Lemma
3.12
If
s
2
LM
(A
1
)A
2
))A
3
then
CT
(s

(A
i
;
A
j
))
=
CT(s)

(A
i
;
A
j
).
2
As
in
other
mo
dels,
canonical
morphisms
are
c
opyc
at
strategies
whic
h
sim-
ply
cop
y
Opp
onen
t
mo
v
es
b
et
w
een
dieren
t
parts
of
a
game.
(Ho
w
ev
er,
there
is
a
dierence
in
the
treatmen
t
of
concurrency
and
justication
p
oin
ters;
the
cop
y
of
an
O
-mo
v
e
a
has
a
concurrency
p
oin
ter
to
a
itself,
and
a
justica-
tion
p
oin
ter
to
the
mo
v
e
of
whic
h
the
justier
of
a
w
as
a
cop
y
.)
The
iden
tit
y
strategy
is
the
prime
example.
Denition
3.13
Sa
y
that
s
2
LM
A)A
is
a
c
opyc
at
sequence
if
for
all
t
v
ev
en
s,
t

A
 =
t

A
+
,
and
ev
ery
P
-mo
v
e
in
s
has
a
concurrency
p
oin
ter
to
the
preceding
O
-mo
v
e.
Then
id
A
=
fs
2
LM
A)A
j
9t:s

t
^
t
is
a
cop
ycat
g.
Comp
osition
of
strategies
is
obtained
as
the
standard
`parallel
comp
osition
with
hiding'
[5].
Denition
3.14
[Comp
osition
of
m
ulti-threaded
strategies]
Giv
en

:
A
1
!
A
2
and

:
A
2
!
A
3
,
let

;

=
ft
2
LM
A
1
)A
3
j
9s
2
LM
(A
1
)A
2
))A
3
:t
=
(s

A
1
;
A
3
)
^
(s

A
1
;
A
2
)
2

^
(s

A
2
;
A
3
)
2

g
Lemma
3.15
If

:
A
)
B
and

:
B
)
C
,
then

;

:
A
)
C
.
Pro
of.
The
k
ey
p
oin
ts
are
that
if
s
2
LM
(A
1
)A
2
))A
3
,
then
s

A
i
;
A
j
is
a
legal
sequence,
and
closure
under
.
The
former
follo
ws
from
the
single-
threaded
case
[11
],
using
Lemma
3.12.
The
latter
is
pro
v
ed
b
y
sho
wing
that,
giv
en
s
2
LM
(A
1
)A
2
))A
3
and
t
2
LM
A
1
)A
3
,
suc
h
that
s

A
1
;
A
3

t,
w
e
can
nd
r
2
LM
(A
1
)A
2
))A
3
suc
h
that
r
A
1
;
A
3
=
t,
s

A
1
;
A
2

r
A
1
;
A
2
and
165

Laird
s

A
2
;
A
3

r

A
2
;
A
3
.
W
e
deriv
e
r
from
s
b
y
migrating
P
-mo
v
es
in
A
3
forw
ard,
and
O
-mo
v
es
in
A
1
bac
k,
and
sw
apping
con
tiguous
O
-mo
v
es
and
con
tiguous
P
-mo
v
es.
2
The
pro
of
that
comp
osition
is
asso
ciativ
e
follo
ws
the
standard
argumen
t
from
[11],
whic
h
is
little
altered
b
y
the
presence
of
concurrency
p
oin
ters
and
absence
of
the
alternation
condition.
Prop
osition
3.16
F
or
al
l

:
A
)
B
;

:
B
)
C
;

:
C
)
D

;
(
;
)
=
(
;

);
.
2
Moreo
v
er,
the
SMCC
structure
on
single-threaded
games
[14]
transfers
smo
othly
to
G
M
.
Prop
osition
3.17
G
M
;
1;
;
)
is
a
symmetric
monoidal
close
d
c
ate
gory.
2
T
o
construct
a
CCC
w
e
consider
a
sub
category
of
G
M
in
whic
h
morphisms
are
wel
l-op
ene
d
strategies
(as
in
the
original
HO
mo
del).
Denition
3.18
F
or
a
(m
ulti-threaded
legal)
sequence
s
con
taining
an
initial
mo
v
e
a,
dene
s

a
to
b
e
the
the
(m
ulti-threaded
legal)
subsequence
of
s
hereditarily
justied
b
y
a:
sa

a
=
a,
sba
=
(sa)b
if
a
hereditarily
justies
b
(b
has
a
concurrency
p
oin
ter
to
a
mo
v
e
in
s

b
b
y
visibilit
y),
sb

a
=
s

a
otherwise.
Denition
3.19
A
m
ulti-threaded
legal
sequence
is
wel
l-op
ene
d
if
it
con
tains
at
most
one
initial
mo
v
e.
A
w
ell-op
ened
strategy

is
a
set
of
w
ell-op
ened
sequences
satisfying
the
conditions
laid
do
wn
in
Denition
3.10
with
resp
ect
to
w
ell-op
ened
sequences
rather
than
legal
sequences.
The
w
ell-op
ened
strategies
form
a
category
with
nite
pro
ducts
giv
en
b
y
the
pro
duct
of
arenas
(for
example,
the
w
ell-op
ened
iden
tit
y
strategy
on
A,
Id
A
,
is
the
restriction
of
id
A
to
w
ell-op
ened
sequences).
Denition
3.20
F
or
a
w
ell-op
ened
strategy

:
A,
dene
the
strategy

y
:
A:
s
2

y
if
and
only
if
for
all
initial
mo
v
es
a
in
s,
s

a
2

.
F
or
the
denabilit
y
and
full
abstraction
results
w
e
will
require
a
further
re-
striction
on
strategies;
Pla
y
er
cannot
(directly)
observ
e
the
concurrency
p
oin
t-
ers
from
O
-mo
v
es.
This
corresp
onds
to
the
fact
that
in
ICSP
it
is
not
directly
observ
able
in
whic
h
lo
c
ation
(i.e.
whic
h
thread)
computation
is
o
ccurring.
The
simplest
example
of
this
is
that
newchan
c:x:((send
c
n;
nil
)krecv
c)
is
observ
ationally
equiv
alen
t
to
x:x.
Denition
3.21
Let

O
to
b
e
the
least
equiv
alence
relation
on
m
ulti-threaded
le
gal
sequences
closed
under
the
condition:
166

Laird
sa
1
t
1
a
2
t
2
br

O
sa
1
t
1
a
2
t
2
br
,
if
b
is
an
O
-mo
v
e
with
a
concurrency
p
oin
ter
to
a
1
in
the
rst
sequence,
and
to
a
2
in
the
second
sequence,
and
the
sequences
are
otherwise
iden
tical.
A
strategy

is
(concurrency)
p
oin
ter-blind
if
it
is
closed
with
resp
ect
to

O
|
s
2

and
s

O
t
implies
t
2

.
Lemma
3.22
If

:
A
!
B
;

:
B
!
C
ar
e
p
ointer-blind
then

;

is
p
ointer-
blind.
2
Dene
the
category
G
M
y
of
m
ulti-threaded
games
with
ar
enas
as
ob
jects,
and
wel
l-op
ene
d,
p
ointer-blind
str
ate
gies
on
A
)
B
as
morphisms
from
A
to
B
,
and
comp
osition
dened



=

y
;

.
Prop
osition
3.23
G
M
y
;
;
1;
)
is
a
c
artesian
close
d
c
ate
gory.
Pro
of.
W
e
use
the
follo
wing
facts.
F
or
an
y
A,
Id
y
A
=
id
A
,
and
for
an
y
w
ell-op
ened

,

y
;
Id
B
=

.
F
or
w
ell-op
ened
strategies

:
A
)
B
;

:
B
)
C
,

y
;

y
=
(
y
;

)
y
.
2
Hence
w
e
ha
v
e
the
basis
for
a
mo
del
of
the
functional
part
of
ICSP
(the
in
terpretation
of
the
ground
t
yp
es
comm
and
nat
as
\at
arenas"
with
a
sin-
gle
initial
question
enabling
one
and
coun
tably
man
y
answ
ers
resp
ectiv
ely
is
standard).
W
e
can
also
dene
prop
erties
of
strategies
(se
quentiality
and
in-
no
c
enc
e
)
whic
h
pic
k
out
the
elemen
ts
in
the
m
ulti-threaded
mo
del
whic
h
are
the
denotations
of
the
purely
functional
terms.
A
sequen
tial
strategy
is
one
whic
h
nev
er
spa
wns
new
threads
of
con
trol.
Denition
3.24
A
m
ulti-threaded
sequence
s
is
Player
se
quential
if
ev
ery
O
-
mo
v
e
in
s
is
the
target
of
at
most
one
concurrency
p
oin
ter:
i.e.
if
tar
c;
tar
0
c
0
v
s
where
c;
c
0
are
P
-mo
v
es
with
concurrency
p
oin
ters
to
a,
then
r
c
=
r
0
c
0
.
A
strategy

is
se
quential
if
ev
ery
s
2
T

is
Pla
y
er
sequen
tial.
The
notion
of
inno
c
enc
e
used
in
[11]
etc.
generalises
readily
to
the
m
ulti-
threaded
framew
ork;
a
(sequen
tial)
strategy
is
inno
c
ent
if
its
resp
onse
in
eac
h
con
trol-thread
dep
ends
only
on
the
P-view
of
that
thread
(Denition
3.2).
Denition
3.25
F
or
a
m
ulti-threaded
strategy

dene
p
q
=
fpCT
(s)q
j
s
2

g.
(If

is
single-threaded,
p
q
=
fpsq
j
s
2

g.)
A
sequen
tial
strategy

is
inno
c
ent
(and
deterministic)
if
psq
is
ev
enly
branc
hing:
i.e.
if
s;
t
2
p
q
then
if
s
u
t
is
o
dd-length
then
s
=
t.
Note
that
all
inno
cen
t
strategies
are
p
oin
ter-blind;
if
an
O
-mo
v
e
is
in
the
P
 view,
then
the
preceding
mo
v
e
is
its
justier,
whic
h
m
ust
b
e
no
later
than
the
target
of
its
justication
p
oin
ter.
Denition
3.26
F
rom
a
m
ulti-threaded
and
inno
cen
t
strategy

,
dene
the
single-threaded
inno
cen
t
strategy
threads
(
)
=
fCT(s)
j
s
2

g.
The
follo
wing
lemma
follo
ws
from
Lemma
3.12.
167

Laird
Lemma
3.27
F
or
single-thr
e
ade
d

:
A
!
B
;

:
B
!
C
,
threads
(
);
threads
(
)
=
threads
(
;

).
2
Lemma
3.28
Given
a
single-thr
e
ade
d
and
inno
c
ent
str
ate
gy

:
A,
dene
the
multi-thr
e
ade
d
str
ate
gy
threads
 1
(
)
=
fs
2
LM
A
j
8r
v
s:CT(r
)
2
T

^
8t:((t

s
_
s

t)
=
)
CT(t)
2

)g.
Then
threads
(threads
 1
(
))
=

,
and
for
any
multi-thr
e
ade
d,
se
quential
and
inno
c
ent
str
ate
gy

,
threads
 1
(threads(
))
=

.
2
Hence
threads
is
an
isomorphism
b
et
w
een
the
m
ulti-threaded,
inno
cen
t
and
sequen
tial
strategies,
and
the
inno
cen
t
single-threaded
strategies.
Prop
osition
3.29
The
se
quential
and
inno
c
ent
str
ate
gies
form
a
sub
c
ate
gory
of
G
M
y
which
is
isomorphic
to
the
c
ate
gory
of
single-thr
e
ade
d
games
and
in-
no
c
ent
str
ate
gies.
2
4
Seman
tics
of
ICSP
P
arallel
comp
osition
is
in
terpreted
using
a
corresp
onding
op
eration
on
strate-
gies
whic
h
interle
aves
their
resp
onses
to
the
initial
mo
v
e.
Denition
4.1
Sa
y
that
an
ar
ena
is
w
ell-op
ened
if
it
has
an
unique
initial
mo
v
e.
Let
s
=
a
0
a
1
:
:
:
a
n
and
t
=
b
0
b
1
:
:
:
b
n
b
e
w
ell-op
ened
sequences
in
LM
A
,
where
A
is
a
w
ell-op
ened
arena.
A
tail-interle
aving
of
s
and
t
is
a
sequence
ar
2
LM
A
suc
h
that
r
is
an
in
terlea
ving
of
a
1
:
:
:
a
n
with
b
1
:
:
:
b
n
whic
h
preserv
es
justication
and
concurrency
p
oin
ters
|
i.e.
if
a
j
p
oin
ts
to
a
0
in
s
then
a
j
p
oin
ts
to
a
in
ar
,
otherwise
if
a
j
p
oin
ts
to
a
i+1
in
s,
then
a
i+1
in
a
r
.
W
e
shall
write
sjt
for
the
set
of
tail-in
terlea
vings
of
s
and
t.
Prop
osition
4.2
F
or
any
wel
l-op
ene
d
ar
ena
A
and
(p
ointer-blind)
str
ate
gies

;

:
A
the
p
ar
al
lel
c
omp
osition
of

and

|

j
=
S
fsjt
j
s
2

^
t
2

g
|
is
a
wel
l-dene
d
(p
ointer-blind)
str
ate
gy.
2
So,
for
instance,
w
e
ha
v
e
a
general
p
ar
al
lel
c
omp
osition
morphism
for
are-
nas
with
unique
initial
mo
v
es,
pa
ra
A
:
A

A
!
A
=

l
A
j
r
A
.
A
t
ypical
pla
y
(with
concurrency
p
oin
ters)
of
pa
ra
[
[comm
]
]
is
as
follo
ws
(mo
v
es
aligned
horizon-
tally
can
o
ccur
in
either
order):
[
[
[
[comm
]
]

[
[comm
]
]
)
[
[comm
]
]
q
q
+
l
i
e
b
_
\
Y
q
)
z r
e
Z U
a
4
a
4
aa
a
k
e
Z
M
F
h
e
b
_
\
Y
V
S
]
]
Prop
osition
4.3
If
A;
B
ar
e
wel
l-op
ene
d
ar
enas
and

:
A
!
B
is
a
strict
str
ate
gy
then
for
any

;

:
C
!
A,
(
j);

=
(
;

)j(;

).
2
By
dening
[
[ `
M
kN
:
B
]
]
=
[
[ `
M
]
]j[
[ `
N
]
]
w
e
ha
v
e
an
in
terpretation
of
the
-calculus
with
parallel
comp
osition
in
G
M
y
.
So
it
remains
to
giv
e
the
168

Laird
seman
tics
of
lo
cally
b
ound
c
hannels.
This
is
based
on
viewing
elemen
ts
of
t
yp
e
chan
as
`ob
jects'
dened
b
y
their
`metho
ds'
|
in
this
case
send
and
recv
.
This
w
as
suggested
as
an
in
terpretation
for
reference
t
yp
es
b
y
Reynolds
[17
]
and
used
to
giv
e
a
a
functor-category
seman
tics
for
idealized
CSP
b
y
Bro
ok
es
[6].
The
in
terpretation
describ
ed
here
is
particularly
close
to
the
game
seman
tics
of
store
in
Idealized
Algol
[1].

W
e
dene
[
[chan
]
]
=
[
[comm
]
]
!

[
[nat
]
]
(whic
h
is
the
same
as
the
in
terpretation
of
the
t
yp
e
var
giv
en
in
[1
]).

F
or
sending
messages
(and
assigning
to
v
ariables)
there
is
a
sequen
tial
and
inno
cen
t
strategy
write
:
[
[nat
]
]

[
[comm
]
]
!
!
[
[comm
]
]
describ
ed
in
[1]
whic
h
resp
onds
to
the
initial
mo
v
e
b
y
asking
the
question
in
[
[nat
]
],
giv
en
the
answ
er
n
it
asks
the
initial
question
in
the
nth
part
of
the
pro
duct
[
[comm
]
]
!
.
When
this
is
answ
ered,
it
answ
ers
the
initial
question.
W
e
dene
[
[ `
send
M
N
]
]
=
h[
[ `
M
]
];

l
;
[
[ `
N
]
]i;
write
,
whic
h
is
pre-
cisely
the
same
as
the
in
terpretation
of
assignmen
t
in
[1
].

W
e
dene
[
[ `
recv
M
]
]
=
[
[ `
M
]
];

r
,
(the
in
terpretation
of
deallo
cation
in
[1]).
These
op
erations
preserv
e
inno
cence
(and
determinacy)
and
sequen
tialit
y
,
and
hence
all
denotations
of
terms
in
ICSP
-
fk;
newchan
g
satisfy
these
conditions.
Th
us
w
e
ha
v
e
the
follo
wing
denabilit
y
result
for
inno
cen
t
sequen
tial
strate-
gies,
whic
h
is
a
minor
adaptation
of
the
denabilit
y
theorem
for
PCF
[11],
and
precisely
analogous
to
denabilit
y
in
Idealized
Algol
without
bad
v
ariables.
Prop
osition
4.4
If
 is
a
chan
-fr
e
e
c
ontext
and
T
is
a
chan
-fr
e
e
typ
e,
and

:
[
[ ;
chan
k
]
]
!
[
[T
]
]
is
a
se
quential
and
inno
c
ent
str
ate
gy
such
that
p
q
is
nite,
then
ther
e
is
a
term
 ;
chan
k
`
M

:
T
of
ICSP
-
fk;
newchan
g
such
that

=
[
[M

]
].
2
Th
us
the
only
part
of
the
seman
tics
of
c
hannels
whic
h
is
non-functional
|
and
moreo
v
er
the
only
part
whic
h
diers
from
the
game
seman
tics
of
store
in
Idealized
Algol
|
is
the
new-c
hannel
generator.
This
can
b
e
dened
b
y
a
(p
oin
ter-blind)
strategy
ccell
:
[
[nat
]
]

[
[comm
]
]
!
whic
h
is
similar
to
the
cell
strategy
used
to
in
terpret
new
in
the
mo
del
of
Idealized
Algol
[1]
in
the
w
a
y
that
it
causes
in
teraction
b
et
w
een
the
t
w
o
read/write
or
send/receiv
e
com-
p
onen
ts
of
[
[chan
]
]
(and
violates
inno
cence
in
the
pro
cess)
but
the
signican
t
dierence
is
that
comm
unication
b
et
w
een
sending
and
receiving
is
concurren
t
and
sync
hronous
rather
than
sequen
tial.
A
t
ypical
pla
y
of
ccell
(with
con-
currency
p
oin
ters)
is
giv
en
b
elo
w
(the
questions
in
the
ith
\send
comp
onen
t"
[
[comm
]
]
!
ha
v
e
b
een
lab
elled
send
(i),
and
their
answ
ers
as
sent
(i),
the
question
in
the
\receiv
e"
comp
onen
t
[
[nat
]
]
has
b
een
lab
elled
recv
,
and
its
ith
answ
er
rcvd(i)).
169

Laird
[
[
[
[comm
]
]
!

[
[nat
]
]
send
(i)
send
(j
)
send(k
)
recv
recv
sent
(i)
R
sent
(k
)
R
rcvd(k
)
b 
rcvd(i)
b 
recv
recv
sent
(j
)
Z


0
rcvd(j
)
b
V
]
]
Informally
,
the
b
eha
viour
of
ccell
can
b
e
describ
ed
in
the
follo
wing
terms.
It
m
ust
resp
ond
to
an
y
pla
y
in
whic
h
there
is
b
oth
an
unansw
ered
send
(i)
question
and
an
unansw
ered
recv
question.
In
resp
onse
to
suc
h
a
pla
y
ccell
matc
hes
up
an
y
suc
h
pairs
of
questions
b
y
giving
the
answ
er
rcvd(i)
to
the
recv
question,
and
the
answ
er
sent
to
send(i).
So
ccell
is
implicitly
non-deterministic,
as
answ
ers
can
b
e
exc
hanged
b
e-
t
w
een
an
y
pair
of
op
en
send
and
recv
mo
v
es.
And
in
order
to
satisfy
the
visibilit
y
and
alternation
conditions,
the
send
and
recv
mo
v
es
m
ust
alw
a
ys
b
e
in
dieren
t
threads
|
as
one
w
ould
exp
ect,
as
sync
hronous
message
passing
requires
the
sender
and
recipien
t
to
b
e
in
dieren
t
threads.
Denition
4.5
F
ormally
,
ccell
can
b
e
dened
as
follo
ws.
Let
the
b
alanc
e
d
sequences
of
ccell
,
B
ccell

ccell
,
b
e
the
least
set
of
sequences
con
taining
"
and
closed
under
the
follo
wing
rule:
if
s
2
B
ccell
,
then
s

send
(i)

recv

sent

rcvd
(i)
2
ccell
(where
sent
has
concurrency
and
justication
p
oin
ters
to
send
(i),
and
rcvd(i)
to
recv
).
Let
the
\w
aiting
to
send"
sequences
of
ccell
,
S
ccell
,
b
e
the
least
sup
erset
of
B
ccell
suc
h
that
if
s
2
S
ccell
,
then
s

recv
2
ccell
.
Similarly
,
the
set
of
\w
aiting
to
send"
sequences,
R
ccell
,
is
the
least
sup
erset
of
B
ccell
suc
h
that
if
s
2
R
ccell
,
then
s

send(i)
2
ccell
.
No
w
let
ccell
=
fs
2
LM
[
[chan
]
]
j
9t:s

t
^
(t
2
S
ccell
_
t
2
R
ccell
)g
W
e
dene
[
[ `
newchan
M
:
B
]
]
=
([
[ `
M
:
chan
)
B
]
]

ccell
);
App.
4.1
Soundness
of
the
semantics
A
program
denotation
is
may
c
onver
gent
if
it
can
answ
er
the
initial
question
at
least
once.
A
denotation
is
must
c
onver
gent
if
it
alw
a
ys
giv
es
some
resp
onse
(i.e.
do
es
not
w
ait)
in
resp
onse
to
Opp
onen
t's
initial
mo
v
e.
Denition
4.6
Let
q
b
e
the
initial
Opp
onen
t
question
in
the
arena
[
[comm
]
],
and
a
its
answ
er.
F
or
a
program
M
:
comm
,
dene
M
#
may
if
q
a
2
T
[
[M
]
]
and
[
[M
]
]
#
must
if
q
62
[
[M
]
].
Soundness
of
the
in
terpretation
|
i.e.
corresp
ondence
b
et
w
een
the
notions
of
ma
y
and
m
ust
con
v
ergence
in
the
op
erational
and
denotational
seman
tics
|
can
no
w
b
e
established.
First,
comm
utativit
y
and
asso
ciativit
y
of
parallel
comp
osition,
and
comm
utativit
y
of
new-c
hannel
declaration
means
that
the
denition
of
the
denotation
of
a
conguration
can
b
e
giv
en
without
am
biguit
y
.
170

Laird
Denition
4.7
F
or
a
conguration
C
=
M
1
:
comm
;
:
:
:
;
M
n
:
comm
suc
h
that
C
h(C
)
=
c
1
;
:
:
:
;
c
k
,
dene
[
[C
]
]
=
[
[newchan
c
1
:
:
:
:
newchan
c
k
:M
1
k
:
:
:
kM
n
]
].
Sa
y
that
a
conguration
is
con
v
erged
if
it
has
the
form
C
;
skip,
and
dead-
lo
c
k
ed
if
it
is
not
con
v
erged
and
cannot
b
e
further
reduced.
Lemma
4.8
If
C
is
c
onver
ge
d,
then
[
[C
]
]
#
may
and
[
[C
]
]
#
must
and
if
C
is
de
ad
lo
cke
d
then
[
[C
]
]
6#
may
and
[
[C
]
]
6#
must
.
2
Prop
osition
4.9
F
or
any
non-c
onver
ge
d
and
non-de
ad
lo
cke
d
c
ongur
ation
C
,
[
[C
]
]
#
may
if
and
only
if
ther
e
is
some
C
0
such
that
[
[C
0
]
]
#
may
and
C
 !
C
0
,
and
[
[C
]
]
#
must
if
and
only
if
[
[C
0
]
]
#
must
for
al
l
C
0
such
that
C
 !
C
0
.
Pro
of.
The
pro
of
is
based
on
the
standard
prop
erties
of
a
cartesian
closed
category
,
together
with
Prop
osition
4.3
and
the
follo
wing
lemmas.
Lemma
4.10
[
[(newchan
c:M
)kN
]
]
=
[
[newchan
c:(M
kN
)]
]
(c
=
2
F
V
(N
)
[
[(newchan
c:M
);
N
]
]
=
[
[newchan
c:(M
;
N
)]
],
(c
=
2
F
V
(N
))
[
[newchan
c:E
[send
c
v
]kE
0
[recv
c]kM
]
]

[
[newchan
c:E
[skip
]kE
0
[v
]kM
]
].
2
T
o
pro
v
e
m
ust-soundness
w
e
also
need
the
follo
wing
lemma,
whic
h
is
based
on
analysis
of
the
strategy
ccell
.
Lemma
4.11
F
or
terms
M
1
;
M
2
;
:
:
:
M
n
,
dene
k
in
M
i
=
M
1
kM
2
k
:
:
:
kM
n
.
Supp
ose
we
have
terms
M
i
j
=
E
i
j
[send
a
i
v
i
j
]
:
j

m
i
and
N
i
k
=
D
i
k
[recv
a
i
]
:
k

l
i
for
i

n.
Then
k
in
((k
j
m
i
M
i
j
)k(k
k
l
i
N
i
k
))
=
[
I
nJ
m
I
K
l
J
k
in
((k
j
m
i
M
(I
;
J
))
i
j
)k(k
k
l
i
N
(I
;
J
;
K
)
i
k
));
wher
e
M
(I
;
J
)
i
j
=

E
i
j
[skip
];
if
i
=
I
and
j
=
J
M
(I
;
J
)
i
j
=
M
i
j
otherwise,
N
(I
;
J
;
K
)
i
k
=
E
i
k
[v
I
J
]
if
i
=
I
and
k
=
K
,
and
N
(I
;
J
;
K
)
i
k
=
N
i
k
.
2
W
e
can
no
w
pro
v
e
Prop
osition
4.9.
Supp
ose
C
is
non-con
v
erged.
Then
b
y
Lemma
4.10,
if
C
 !
C
0
then
[
[C
0
]
]

[
[C
]
],
and
hence
if
[
[C
]
]
#
must
then
[
[C
0
]
]
#
must
,
and
if
[
[C
0
]
]
#
may
then
[
[C
]
]
#
may
.
T
o
pro
v
e
that
if
[
[C
0
]
]
#
must
for
all
C
0
suc
h
that
C
 !
C
0
then
[
[C
]
]
#
must
,
supp
ose
that
there
is
some
reduction
C
 !
C
0
whic
h
is
not
an
instance
of
the
comm
unication
rule.
Then
b
y
Lemma
4.10,
[
[C
]
]
=
[
[C
0
]
]
and
[
[C
]
]
#
must
as
required.
On
the
other
hand,
if
there
is
no
reduction
whic
h
is
not
an
instance
of
comm
unication,
then
all
threads
ha
v
e
the
form
E
[send
c
n]
or
E
[send
c
n]
and
hence
b
y
Lemma
4.11,
q
62
[
[C
]
]
=
S
C
0
:C
 !C
0
[
[C
0
]
]
as
required.
2
Corollary
4.12
If
M
:
comm
is
a
pr
o
gr
am
of
ICSP
then
M
+
may
if
and
only
if
[
[M
]
]
#
may
and
M
+
must
if
and
only
if
[
[M
]
]
#
must
.
171

Laird
Pro
of.
M
+
may
implies
[
[M
]
]
#
may
and
M
+
must
implies
[
[M
]
]
#
must
b
y
induc-
tion
on
reduction.
The
con
v
erse
follo
ws
from
the
fact
that
ev
aluation
alw
a
ys
terminates
(Prop
osition
2.2).
2
5
Denabilit
y
and
full
abstraction
T
o
pro
v
e
a
full
abstraction
result
for
chan
-free
t
yp
es
it
remains
to
sho
w
that
ev
ery
nitary
strategy
at
these
t
yp
es
is
denable
as
a
term.
All
strategies
on
arenas
denoting
t
yp
es
of
rank
1
or
ab
o
v
e
con
tain
innitely
man
y
sequences,
so
niteness
is
dened
in
terms
of
the
smallest
set
required
to
generate
these
sequences.
Denition
5.1
A
gener
ator
for
a
strategy

is
a
set
of
sequences
S


suc
h
that
for
all
t
2

there
exists
sr

t
suc
h
that
s
2
S
and
r
con
tains
only
O
-mo
v
es.
W
e
sa
y
that

is
nitary
if
it
has
a
nite
generator
S
,
and
that
it
is
b
ounded
b
y
k
if
the
length
of
all
sequences
in
S
is
less
than
k
.
Denabilit
y
is
reduced
in
t
w
o
steps
to
the
case
of
sequen
tial
and
inno-
cen
t
(deterministic)
strategies,
whic
h
are
denable
in
ICSP
 fnewchan
;
kg,
b
y
the
no
w-standard
tec
hnique
of
factorization
[1
,12,4,7].
The
rst
stage
is
factorization
of
eac
h
nitary
m
ulti-threaded
strategy
in
to
the
comp
osition
of
a
sequen
tial
strategy
with
parallel
comp
osition.
Denition
5.2
Supp
ose
satb
2
LM
A
,
where
the
concurrency
p
oin
ter
from
b
go
es
to
a.
Dene
b
ranches
(satb)
to
b
e
the
n
um
b
er
of
mo
v
es
in
satb
whic
h
p
oin
t
to
b.
F
or
nitary

,
let
b
ranches
(
)
=
max(fb
ranches
(sa)
j
sa
2
T

^

O
P
(a)
=
P
g).
Th
us

is
sequen
tial
if
and
only
if
b
ranches
(
)

1.
Prop
osition
5.3
L
et

:
A
b
e
a
nitary
str
ate
gy,
such
that
b
ranches
(
)
=
n.
Then
ther
e
is
a
nitary
se
quential
str
ate
gy
seq
(
)
:
[
[comm
]
]
!
A
such
that
[
[k
in
skip
]
];
seq
(
)
=

.
Pro
of.
The
idea
b
ehind
the
factorization
is
simple.
In
resp
onse
to
eac
h
O
-
mo
v
e
a
in
A,
seq
(
)
mak
es
a
mo
v
e
with
a
concurrency
p
oin
ter
to
a
in
comm
,
prompting
Opp
onen
t
(pla
ying
as
[
[k
in
skip
]
])
to
giv
e
n
answ
ers.
Then
seq(
)
pla
ys
as

,
except
that
where

pla
ys
a
mo
v
e
with
a
p
oin
ter
a,
seq
(
)
pla
ys
the
same
mo
v
e
with
a
p
oin
ter
to
a
fresh
instance
of
one
of
these
answ
ers.
Supp
ose
that
8s
v
t:b
ranches
(s)

n.
Dene
a
Pla
y
er-sequen
tial
sequence
seq(t),
b
y
the
follo
wing
induction:
seq
(")
=
",
seq
(sa)
=
seq
(s)aq
b
a
1
b
a
2
:
:
:
b
a
n
(where
a
is
an
O
-mo
v
e,
q
is
the
initial
question
in
[
[comm
]
]
(p
oin
ting
to
a),
and
b
a
1
;
b
a
2
;
:
:
:
b
a
n
are
n
answ
ers
with
p
oin
ters
to
q
).
172

Laird
If
c
is
a
P
-mo
v
e
p
oin
ting
to
b,
and
b
ranches
(sbtc)
=
i
then
seq
(sbtc)
=
seq
(sbt)
b
c
(where
b
c
p
oin
ts
to
b
b
i
).
Th
us
seq
(
)
is
a
map
from
LM
A
to
LM
[
[comm
]
]!A
with
the
follo
wing
prop
er-
ties:
seq
(s)
is
pla
y
er-sequen
tial,
seq
(s)

A
=
s
and
seq
(s)

[
[comm
]
]
2
[
[k
in
skip
]
].
Let
seq
(
)
=
ft
2
LM
[
[comm
]
])A
j
9s
2

:t

seq
(s)g.
2
The
factorization
of
sequen
tial
strategies
in
to
inno
cen
t
strategies
via
the
chan
t
yp
e
and
ccell
strategy
is
more
complex.
It
resem
bles
the
factorization
of
inno
cence
via
the
cell
strategy
[1]
in
that
it
uses
ccell
to
enco
de
information
ab
out
the
en
tire
history
of
the
pla
y
,
but
it
also
uses
sync
hronization
in
a
fundamen
tal
w
a
y
and
incorp
orates
the
factorization
of
non-determinism
via
an
\oracle"
giv
en
in
[7].
The
factorized
strategy
runs
t
w
o
threads
in
parallel,
a
\master
strategy"
whic
h
op
erates
b
y
sending
and
receiving
messages
in
a
con
text
of
c
hannels;
it
observ
es
Opp
onen
t
mo
v
es
and
dictates
Pla
y
er
mo
v
es
in
A
via
comm
unication
with
a
(generalized)
\sla
v
e
strategy"
whic
h
mo
v
es
bac
k
and
forth
b
et
w
een
the
con
text
and
A,
rep
orting
on
the
progress
of
pla
y
in
A
to
the
master
strategy
and
executing
its
commands.
F
or
a
nitary
strategy

let
resp
onses
(
)
b
e
the
greatest
n
um
b
er
of
dieren
t
P
-mo
v
es
whic
h

can
giv
e
in
resp
onse
to
one
p
osition
|
i.e.
resp
onses
(
)
=
max
fjfsa
:
sa
2
T

^

O
P
(a)
=
P
gj
:
s
2
T

g.
Prop
osition
5.4
F
or
e
ach
ar
ena
A
and
k
2
!
ther
e
exists
a
nitary,
se
quen-
tial
and
inno
c
ent
(deterministic)
str
ate
gy
slave
k
:
nat

nat

chan
k
+2
!
A
such
that
if

:
A
is
a
nitary
str
ate
gy
b
ounde
d
by
k
and
resp
onses
(
)
=
n,
then
ther
e
is
an
inno
c
ent
str
ate
gy
mas(
)
:
(nat

nat
)

chan
k
+2

nat
!
A
and
such
that
oracle
n

[
[0k1]
]

ccell
k
+2
;
(mas(
)jslave
k
)
=

.
Pro
of.
F
actorized
pla
ys
pro
ceed
as
follo
ws.
The
sla
v
e
resp
onds
to
eac
h
Op-
p
onen
t
mo
v
e
a
in
A
b
y
trying
to
send
an
enco
ding
of
it
(and
its
view)
on
c
hannel
1.
The
master
main
tains
a
single
op
en
receiv
e
question
on
c
hannel
1,
allo
wing
it
to
learn
the
en
tire
history
of
pla
y
in
A
(up
to

and

O
).
Once
the
master
and
sla
v
e
ha
v
e
concluded
a
successful
comm
unication
on
c
hannel
1,
the
master
sends
the
sla
v
e
a
n
um
b
er
2
<
i

k
+
2
on
c
hannel
2.
This
n
um
b
er
is
the
name
of
a
priv
ate
c
hannel,
in
whic
h
the
sla
v
e
immediately
pla
ys
a
receiv
e
mo
v
e,
w
aiting
for
comm
unication
from
the
master.
When
the
mas-
ter
has
observ
ed
that
pla
y
in
A
has
tak
en
place
to
whic
h

w
ould
resp
ond
with
one
of
the
P
-mo
v
es
b
0
;
b
2
;
:
:
:
b
m
,
he
splits
the
thread
of
con
trol
using
the
parallel
comp
osition
[
[0k1]
],
in
a
sp
ecial
case
of
the
sequen
tialization
factoriza-
tion
of
Prop
osition
5.3.
In
one
of
the
threads
th
us
created,
he
main
tains
the
surv
eillance
of
c
hannel
1
b
y
rep
eating
the
receiv
e
question.
In
the
other,
he
uses
the
oracle
to
generate
j

m
non-deterministically
.
If
the
mo
v
e
b
j
has
a
p
oin
ter
to
a
i
the
master
then
sends
an
enco
ding
of
b
j
on
c
hannel
i
whic
h
is
receiv
ed
b
y
the
w
aiting
sla
v
e,
who
pla
ys
the
mo
v
e
b
j
with
a
p
oin
ter
to
a
i
as
173

Laird
required.
2
The
factorization
theorems
together
with
Prop
osition
4.4
yield
the
follo
w-
ing
denabilit
y
result.
Corollary
5.5
Every
nitary
(p
ointer-blind)
str
ate
gy

over
a
channel-fr
e
e
typ
e-obje
ct
[
[T
]
]
is
denable
as
an
ICSP
term
M

:
T
.
2
The
denabilit
y
result
means
that
the
\in
trinsic
equiv
alence"
on
strategies
corresp
onds
to
observ
ational
equiv
alence.
Th
us
w
e
can
no
w
dene
a
fully
abstract
mo
del
of
ICSP
b
y
c
haracterizing
this
in
trinsic
equiv
alence
directly
,
via
a
\dual"
to
the
\equiv
alence
up
to
redirection
of
p
oin
ters",
used
to
dene
the
p
oin
ter-blindness
condition
(Denition
3.21).
Denition
5.6
Let

P
b
e
the
least
equiv
alence
relation
on
m
ulti-threaded
sequences
suc
h
that
sa
1
t
1
a
2
t
2
br

P
sa
1
t
1
a
2
t
2
br
if
b
is
a
Pla
y
er
mo
v
e
with
a
concurrency
p
oin
ter
to
a
1
in
the
rst
sequence
and
to
a
2
in
the
second,
and
the
sequences
are
otherwise
iden
tical.
Let



if
8s
2

:9t
2

:s

t
and
8t
2

:9s
2

:s


.
Theorem
5.7
F
or
al
l
close
d
terms
M
;
N
:
T
ICSP,
M
'
M
&M
N
if
and
only
if
[
[M
]
]

[
[N
]
].
Pro
of.
It
is
straigh
tforw
ard
that
if
[
[M
]
]

[
[N
]
]
then
no
p
oin
ter-blind
strat-
egy
can
distinguish
them
T
o
establish
the
con
v
erse,
supp
ose
[
[M
]
]
con
tains
a
sequence
s
suc
h
that
for
all
t
2
[
[N
]
],
t
6
P
s.
Assume
that
s
is
maximal
(with
this
prop
ert
y)
with
resp
ect
to
.
There
are
t
w
o
cases
to
consider,
dep
ending
on
whether
s
is
r
e
achable
(up
to

P
)
in
t,
or
not
Supp
ose
s
is
not
reac
hable
|
i.e.
for
all
t
2
T
[
[N
]
]
,
t
6
P
s.
Then
let

:
[
[T
]
]
!
[
[comm
]
]
b
e
the
strategy
generated
b
y
q
sa
2
[
[T
]
]
)
[
[comm
]
]
(where
q
is
the
initial
question
in
[
[comm
]
]
and
a
is
its
answ
er)
|
i.e.

is
generated
b
y
ft
2
LM
[
[T
)comm
]
]
j
9r
v
q
sa:t

r
g.
By
denabilit
y
,
there
exists
a
term
L

:
T
)
comm
suc
h
that

=
[
[L

]
].
Then
q
a
2
[
[M
]
];
,
so
b
y
soundness,
L

M
+
may
.
And
q
a
62
[
[N
]
];
,
since
if
q
s
0
a

q
sa,
then
s

s
0
and
hence
s
0
62
[
[N
]
]
b
y
maximalit
y
of
s
with
resp
ect
to
.
Hence
b
y
soundness
L

N
6+
may
.
Supp
ose
s
is
reac
hable
in
[
[N
]
]
|
i.e.
there
is
a
sequence
sr
2
[
[N
]
].
Then
let

b
e
the
strategy
whic
h
con
v
erges
when
it
encoun
ters
an
y
trace
from
[
[M
]
]
whic
h
is
distinct
from
s,
and
div
erges
otherwise
|
i.e.

is
generated
b
y
the
set
of
sequences
ft
2
LM
[
[T
)comm
]
]
j
9r
b
2
[
[M
]
]:r
v
s
^
t

q
r
ag
(whic
h
is
nite
b
ecause
[
[M
]
]
is
nite
branc
hing).
Then
q
62
[
[M
]
],
but
q
2
[
[N
]
],
so
b
y
the
argumen
t
from
denabilit
y
,
L

M
+
must
but
L

N
6+
must
.
2
6
Conclusions
The
seman
tics
of
ICSP
describ
ed
here
can
b
e
considered
a
rst
step
in
an
attempt
to
describ
e
concurrency
in
functional
languages
more
generally
using
174

Laird
game
seman
tics.
The
most
ob
vious
next
step
is
a
c
haracterisation
of
recursion
in
suc
h
a
setting.
T
o
do
so
is
straigh
tforw
ard
for
a
seman
tics
of
may
-testing;
but
whilst
there
is
a
natural
mo
del
of
m
ust-testing,
the
di√Ücult
y
is
to
dene
an
op
erational
seman
tics
with
resp
ect
to
whic
h
it
is
adequate,
as
it
is
necessary
that
ev
aluation
is
fair.
Another
desirable
dev
elopmen
t
w
ould
b
e
an
extension
of
the
full
abstraction
result
to
t
yp
es
including
c
hannels.
Recen
t
w
ork
b
y
McCusk
er
on
the
game
seman
tics
of
Idealized
Algol
without
bad
v
ariables
suggests
that
this
is
p
ossible
using
an
ordering
on
legal
pla
ys,
although
in
the
concurren
t
case
it
seems
rather
more
complicated.
V
ariations
on
the
language
itself
can
b
e
considered.
F
or
instance,
asyn-
c
hronous
message
passing
(without
queuing)
has
a
natural
in
terpretation,
the
in
teresting
problem
is
to
giv
e
a
denabilit
y
result
for
this
mo
del.
Or
w
e
could
consider
a
call-b
y-v
alue
language
with
thread-iden
tiers
and
passing
of
func-
tions
as
messages
(a
kind
of
\core
CML"
[16
]).
It
is
straigh
tforw
ard
to
giv
e
a
call-b
y-v
alue
seman
tics
in
the
st
yle
describ
ed
here
(either
directly
,
or
b
y
using
the
F
am
(C
)
construction
[2]).
Message-passing
can
b
e
extended
from
ground
t
yp
es
to
higher
t
yp
es
m
uc
h
as
the
games
in
terpretation
of
Idealized
Algol
extends
to
general
references
[4].
Comparison
with
the
v
arious
syn
tactic
enco
dings
of
these
features
ma
y
b
e
of
in
terest.
As
w
e
ha
v
e
describ
ed
a
framew
ork
for
mo
delling
concurrency
using
HO-
games,
as
w
ell
as
the
sp
ecic
in
terpretation
of
ICSP
,
there
is
plen
t
y
of
scop
e
for
more
general
dev
elopmen
ts
|
the
language
and
seman
tics
can
b
e
extended
with
features
suc
h
as
con
trol
(as
in
[12,13
])
or
higher-order
references
(as
in
[4
]),
as
has
b
een
done
in
the
sequen
tial
case.
Here
again
there
are
some
ex-
pressiv
eness
issues
whic
h
are
w
ell
kno
wn
suc
h
as
enco
dings
of
references
using
c
hannels,
but
in
general
a
formal
and
fully
abstract
seman
tics
could
pro
vide
a
p
o
w
erful
to
ol
for
reasoning
precisely
ab
out
the
in
teraction
of
sequen
tial
and
concurren
t
eects.
References
[1]
S.
Abramsky
and
G.
McCusk
er.
Linearit
y
Sharing
and
state:
a
fully
abstract
game
seman
tics
for
Idealized
Algol
with
activ
e
expressions.
In
P
.W.
O'Hearn
and
R.
T
ennen
t,
editors,
A
lgol-like
languages.
Birkhauser,
1997.
[2]
S.
Abramsky
and
G.
McCusk
er.
Call-b
y-v
alue
games.
In
M.
Neilsen
and
W.
Thomas,
editors,
Computer
Scienc
e
L
o
gic:
11
th
A
nnual
workshop
pr
o
c
e
e
dings,
LNCS,
pages
1{17.
Springer-Verlag,
1998.
[3]
S.
Abramsky
and
P
.-A.
Mellies.
Concurren
t
games
and
full
completeness.
In
Pr
o
c
e
e
dings
of
the
14th
annual
Symp
osium
on
L
o
gic
In
Computer
Scienc
e,
LICS
'99,
1999.
[4]
S.
Abramsky,
K.
Honda,
G.
McCusk
er.
A
fully
abstract
games
seman
tics
for
general
references.
In
Pr
o
c
e
e
dings
of
the
13th
A
nnual
Symp
osium
on
L
o
gic
In
Computer
Scienc
e,
LICS
'98,
1998.
175

Laird
[5]
S.
Abramsky,
R.
Jagadeesan.
Games
and
full
completeness
for
m
ultiplicativ
e
linear
logic.
Journal
of
Symb
olic
L
o
gic,
59:543{574,
1994.
[6]
S.
Bro
ok
es.
Idealized
CSP:
Com
bining
pro
cedures
with
comm
unicating
pro
cesses.
In
Pr
o
c
e
e
dings
of
MFPS
'97,
Electronic
notes
in
Theoretical
Computer
Science.
Elsevier-North
Holland,
1997.
[7]
R.
Harmer
and
G.
McCusk
er.
A
fully
abstract
games
seman
tics
for
nite
non-
determinism.
In
Pr
o
c
e
e
dings
of
the
F
ourte
enth
A
nnual
Symp
osium
on
L
o
gic
in
Computer
Scienc
e,
LICS
`99.
IEEE
press,
1998.
[8]
M.
Hennessy
,
and
E.
Ashcroft.
A
mathematical
seman
tics
for
a
non-
deterministic
t
yp
ed
-calculus.
The
or
etic
al
Computer
Scienc
e,
11:227{245,
1980.
[9]
C.
A.
R.
Hoare.
Comm
unicating
sequen
tial
pro
cesses.
Communic
ations
of
the
A
CM,
21(8):666{677,
1978.
[10]
K.
Honda
and
N.
Y
oshida.
Game
theoretic
analysis
of
call-b
y-v
alue
computation.
In
Pr
o
c
e
e
dings
of
24th
International
Col
lo
quium
on
A
utomata,
L
anguages
and
Pr
o
gr
amming,
v
olume
1256
of
L
e
ctur
e
Notes
in
Computer
Scienc
e.
Springer-Verlag,
1997.
[11]
J.
M.
E.
Hyland
and
C.-H.
L.
Ong.
On
full
abstraction
for
PCF:
I,
I
I
and
I
I
I,
1995.
T
o
app
ear
in
Theoretical
Computer
Science.
[12]
J.
Laird.
F
ull
abstraction
for
functional
languages
with
con
trol.
In
Pr
o
c
e
e
dings
of
the
Twelfth
International
Symp
osium
on
L
o
gic
In
Computer
Scienc
e,
LICS
`97,
1997.
[13]
J.
Laird.
A
fully
abstract
game
seman
tics
of
lo
cal
exceptions.
In
Pr
o
c
e
e
dings
of
the
Sixte
enth
International
Symp
osium
on
L
o
gic
In
Computer
Scienc
e,
LICS
`01,
2001.
T
o
app
ear.
[14]
G.
McCusk
er.
Games
and
ful
l
abstr
action
for
a
functional
metalanguage
with
r
e
cursive
typ
es.
PhD
thesis,
Imp
erial
College
London,
1996.
[15]
H.
Nic
k
au.
Hereditarily
sequen
tial
functionals.
In
Pr
o
c
e
e
dings
of
the
Symp
osium
on
L
o
gic
al
F
oundations
of
Computer
Scienc
e:L
o
gic
at
St.
Petersbur
g,
LNCS.
Springer-Verlag,
1994.
[16]
J.
Repp
y
.
Higher
Or
der
Concurr
ency.
PhD
thesis,
Cornell
Univ
ersit
y
,
1992.
[17]
J.
Reynolds.
Syn
tactic
con
trol
of
in
terference.
In
Conf.
R
e
c
or
d
5
th
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
pages
39{46,
1978.
[18]
J.
Reynolds.
The
essence
of
Algol.
In
A
lgorithmic
L
anguages,
pages
345{372.
North
Holland,
1981.
176

MFPS
17
Preliminary
Version
Unique
Fixed
P
oin
ts
in
Domain
Theory
Key
e
Martin
Oxfor
d
University
Computing
L
ab
or
atory
Wolfson
Building,
Parks
R
o
ad,
Oxfor
d
O
X1
3QD
http://web.comlab.ox.ac.
uk/o
ucl
/wor
k/ke
ye.
mart
in
Abstract
W
e
un
v
eil
new
results
based
on
measuremen
t
that
guaran
tee
the
existence
of
unique
xed
p
oin
ts
whic
h
ne
e
d
not
b
e
maximal.
In
addition,
w
e
establish
that
least
xed
p
oin
ts
are
always
attractors
in
the

top
ology
,
and
then
explore
the
consequences
of
these
ndings
in
analysis.
In
particular,
an
extension
of
the
Banac
h
xed
p
oin
t
theorem
on
compact
metric
spaces
is
obtained.
1
In
tro
duction
The
standard
xed
p
oin
t
theorem
in
domain
theory
states
that
a
Scott
con-
tin
uous
map
f
:
D
!
D
on
a
dcp
o
D
with
least
elemen
t
?
has
a
least
xed
p
oin
t
giv
en
b
y
x(f
)
:=
G
n0
f
n
(?):
This
is
p
erhaps
the
single
most
imp
ortan
t
result
in
domain
theory
,
giv
en
its
eectiv
eness
in
handling
the
seman
tics
of
recursion,
and
the
fact
that
its
reasoning
extends
naturally
to
the
categorical
lev
el
to
explain
wh
y
it
is
that
equations
lik
e
D
'
[D
!
D
]
ma
y
b
e
solv
ed.
It
could
b
e
argued
that
one
of
its
faults
is
that
it
only
applies
to
c
ontinuous
mappings,
since
there
are
no
w
more
general
xed
p
oin
t
theorems
a
v
ailable
[4].
Ho
w
ev
er,
within
the
con
text
of
con
tin
uous
mappings,
the
only
criticism
that
seems
plausible
is
that
its
canonical
xed
p
oin
ts
are
not
as
canonical
as
they
could
b
e.
There
is,
after
all,
one
thing
more
satisfying
than
a
least
xed
p
oin
t:
A
unique
xed
p
oin
t.
Using
ideas
all
originally
in
tro
duced
in
[5],
w
e
establish
that
there
are
natural
xed
p
oin
t
theorems
in
domain
theory
whic
h
guaran
tee
the
existence
of
unique,
attractiv
e
xed
p
oin
ts.
In
the
next
three
sections,
w
e
discuss
domains,
con
ten
t
and
in
v
ariance.
These
are
preliminary
ideas
needed
later
on.
W
e
then
in
tro
duce
con
tractions
on
domains
and
pro
v
e
a
xed
p
oin
t
theorem
ab
out
them
v
ery
reminiscen
t
of
the
Banac
h
theorem
in
analysis.
In
fact,
this
new
result
has
the
Banac
h
theorem
as
one
of
its
consequences.
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Mar
tin
Finally
,
in
the
case
of
a
domain
with
a
least
elemen
t,
w
e
learn
that
least
xed
p
oin
ts
are
always
attractiv
e
in
the

top
ology
and
that
the
results
on
con
tractions
also
hold
for
a
larger
and
more
natural
class
of
nonexp
ansive
mappings.
Because
of
the
latter,
an
impro
v
emen
t
of
the
Banac
h
xed
p
oin
t
theorem
on
compact
metric
spaces
can
b
e
obtained.
2
Bac
kground
A
p
oset
is
a
partially
ordered
set
[1].
Denition
2.1
Let
(P
;
v)
b
e
a
partially
ordered
set.
The
le
ast
element
?
of
P
satises
?
v
x
for
all
x,
when
it
exists.
A
nonempt
y
subset
S

P
is
dir
e
cte
d
if
(8x;
y
2
S
)(9z
2
S
)
x;
y
v
z
.
The
supr
emum
of
a
subset
S

P
is
the
least
of
all
its
upp
er
b
ounds
pro
vided
it
exists.
This
is
written
F
S
.
A
dcp
o
is
a
p
oset
in
whic
h
ev
ery
directed
subset
has
a
suprem
um.
Denition
2.2
F
or
a
subset
X
of
a
dcp
o
D
,
set
"
X
:=
fy
2
D
:
(9x
2
X
)
x
v
y
g
&
#
X
:=
fy
2
D
:
(9x
2
X
)
y
v
xg:
W
e
write
"
x
=
"
fxg
and
#
x
=
#
fxg
for
elemen
ts
x
2
X
.
The
set
of
maximal
elements
in
a
dcp
o
D
is
max
D
=
fx
2
D
:
"
x
=
fxgg:
By
Hausdor
maximalit
y
,
ev
ery
dcp
o
has
at
least
one
maximal
elemen
t.
Denition
2.3
A
subset
U
of
a
dcp
o
D
is
Sc
ott
op
en
if
(i)
U
is
an
upp
er
set:
x
2
U
&
x
v
y
)
y
2
U
,
and
(ii)
U
is
inaccessible
b
y
directed
suprema:
F
or
ev
ery
directed
S

D
,
G
S
2
U
)
S
\
U
6=
;:
The
collection

D
of
all
Scott
op
en
sets
on
D
is
called
the
Scott
top
ology
.
Prop
osition
2.4
A
map
f
:
D
!
E
b
etwe
en
dcp
o's
is
Sc
ott
c
ontinuous
i
(i)
f
is
monotone:
x
v
y
)
f
(x)
v
f
(y
):
(ii)
f
pr
eserves
dir
e
cte
d
supr
ema:
F
or
every
dir
e
cte
d
S

D
,
f
(
G
S
)
=
G
f
(S
):
Denition
2.5
In
a
dcp
o
(D
;
v),
a

x
i
for
all
directed
subsets
S

D
,
x
v
F
S
)
(9s
2
S
)
a
v
s:
W
e
set
#
#x
=
fa
2
D
:
a

xg.
A
dcp
o
D
is
c
ontinuous
if
#
#
x
is
directed
with
suprem
um
x
for
all
x
2
D
.
The
sets
"
"
x
=
fy
2
D
:
x

y
g
for
x
2
D
form
a
basis
for
the
Scott
top
ology
on
a
con
tin
uous
dcp
o
D
.
Finally
,
w
e
adopt
the
follo
wing
denition
of
`domain'
in
this
pap
er.
Denition
2.6
A
domain
is
a
con
tin
uous
dcp
o
D
suc
h
that
for
all
x;
y
2
D
,
there
is
z
2
D
with
z
v
x;
y
:
178

Mar
tin
F
or
example,
a
con
tin
uous
dcp
o
with
le
ast
element
?
is
a
domain
in
the
presen
t
sense.
3
Con
ten
t
The
ideas
in
this
and
the
next
section
are
co
v
ered
in
em
barassing
detail
in
[5].
Let
[0;
1)

b
e
the
domain
of
nonnegativ
e
reals
ordered
as
x
v
y
,
y

x:
Denition
3.1
A
Scott
con
tin
uous
map

:
D
!
[0;
1)

on
a
con
tin
uous
dcp
o
D
induc
es
the
Sc
ott
top
olo
gy
ne
ar
X

D
if
for
all
x
2
X
and
all
sequences
x
n

x,
lim
n!1
x
n
=
x
)
G
x
n
=
x;
and
this
suprem
um
is
directed.
W
e
write
this
as

!

X
:
That
is,
if
w
e
observe
that
a
sequence
(x
n
)
of
appro
ximations
calculates
x,
it
actual
ly
do
es
calculate
x.
The
map

measures
the
information
con
ten
t
of
the
ob
jects
in
X
.
F
or
this
reason,
w
e
sometimes
sa
y
that

me
asur
es
X
:
Denition
3.2
A
me
asur
ement
is
a
Scott
con
tin
uous
map

:
D
!
[0;
1)

that
measures
the
set
k
er

=
fx
2
D
:
x
=
0g:
The
nature
of
the
idea
is
that
information
imparted
to
us
b
y
a
measuremen
t
ab
out
the
en
vironmen
t
ma
y
b
e
tak
en
as
true.
Here
is
an
illustration
of
this
principle.
Prop
osition
3.3
L
et

:
D
!
[0;
1)
b
e
a
me
asur
ement
with

!

D
:
Then
(i)
F
or
al
l
x
2
D
;
x
=
0
)
x
2
max
D
:
(ii)
F
or
al
l
x;
y
2
D
;
x
v
y
&
x
=
y
)
x
=
y
:
(iii)
A
monotone
map
f
:
D
!
D
is
Sc
ott
c
ontinuous
i

f
:
D
!
[0;
1)

is
Sc
ott
c
ontinuous.
One
of
the
rst
motiv
ations
for
measuremen
t
w
as
the
desire
to
pro
v
e
useful
xed
p
oin
t
theorems.
Generally
sp
eaking,
`useful'
means
theorems
whic
h
are
easy
to
apply
to
nonmonotonic
mappings,
or
results
whic
h
sa
y
more
ab
out
monotonic
maps
than
the
Scott
xed
p
oin
t
theorem.
Here
is
the
rst
example
ev
er
found
of
the
latter
t
yp
e
[5].
Theorem
3.4
L
et
f
:
D
!
D
b
e
a
monotone
map
on
a
domain
D
with
a
me
asur
ement

for
which
ther
e
is
a
c
onstant
c
<
1
such
that
(8x)
f
(x)

c

x:
If
ther
e
is
a
p
oint
x
2
D
with
x
v
f
(x),
then
x
?
=
G
n0
f
n
(x)
2
max
D
179

Mar
tin
is
the
unique
xe
d
p
oint
of
f
on
D
.
F
urthermor
e,
x
?
is
an
attr
actor
in
two
dier
ent
senses:
(i)
F
or
al
l
x
2
k
er
,
f
n
(x)
!
x
?
in
the
Sc
ott
top
olo
gy
on
k
er
,
and
(ii)
F
or
al
l
x
v
x
?
,
F
n0
f
n
(x)
=
x
?
,
and
this
supr
emum
is
a
limit
in
the
Sc
ott
top
olo
gy
on
D.
The
only
problem
with
this
theorem
is
that
it
requires
xed
p
oin
ts
maxi-
mal.
V
ery
shortly
w
e
will
unco
v
er
some
new
results
that
o
v
ercome
this
di√Ü-
cult
y
in
what
app
ears
to
b
e
a
more
elegan
t
approac
h.
4
In
v
ariance
All
w
a
ys
of
measuring
a
domain
app
eal
to
a
common
ob
jectiv
e.
Denition
4.1
The

top
olo
gy
on
a
con
tin
uous
dcp
o
D
has
as
a
basis
all
sets
of
the
form
"
"x
\
#
y
,
for
x;
y
2
D
:
It
is
denoted

D
:
One
unsatisfying
asp
ect
of
the
Scott
top
ology
is
its
w
eak
notion
of
limit.
Ideally
,
one
w
ould
hop
e
that
an
y
sequence
with
a
limit
in
the
Scott
top
ology
had
a
suprem
um.
But
this
is
far
from
true.
F
or
instance,
on
a
con
tin
uous
dcp
o
with
least
elemen
t
?,
all
sequences
con
v
erge
to
?:
Lemma
4.2
(Martin
[5])
L
et
D
b
e
a
c
ontinuous
dcp
o.
Then
(i)
A
se
quenc
e
(x
n
)
c
onver
ges
to
a
p
oint
x
in
the

top
olo
gy
i
it
c
onver
ges
to
x
in
the
Sc
ott
top
olo
gy
and
(9n)
x
k
v
x;
for
al
l
k

n:
(ii)
If
x
n
!
x
in
the

top
olo
gy,
then
ther
e
is
a
le
ast
inte
ger
n
such
that
G
k
n
x
k
=
x:
(iii)
If
(x
n
)
is
a
se
quenc
e
with
x
n
v
x,
then
x
n
!
x
in
the

top
olo
gy
i
x
n
!
x
in
the
Sc
ott
top
olo
gy.
In
a
phrase,

limits
are
the
Scott
limits
with
computational
signicance.
Prop
osition
4.3
A
monotone
map
f
:
D
!
E
b
etwe
en
c
ontinuous
dcp
o's
is

c
ontinuous
i
it
is
Sc
ott
c
ontinuous.
So
what
do
es
all
this
ha
v
e
to
do
with
information
con
ten
t?
Giv
en
a
mea-
suremen
t

!

D
,
consider
the
elemen
ts
"-close
to
x
2
D
,
for
"
>
0,
giv
en
b
y

"
(x)
:=
fy
2
D
:
y
v
x
&
jx
 y
j
<
"g:
Regardless
of
the
measuremen
t
w
e
use,
these
sets
are
always
a
basis
for
the

top
ology
.
In
fact,
it
is
this
prop
ert
y
whic
h
denes
con
ten
t
on
a
domain.
Theorem
4.4
(Martin
[5])
F
or
a
Sc
ott
c
ontinuous
map

:
D
!
[0;
1)

,

!

D
i
f
"
(x)
:
x
2
D
&
"
>
0g
is
a
b
asis
for
the

top
olo
gy
on
D
.
180

Mar
tin
This
realization
not
only
impro
v
es
our
understanding
of
the

top
ology
,
it
also
allo
ws
us
to
mak
e
more
eectiv
e
use
of
measuremen
t.
Lemma
4.5
L
et
(D
;
)
b
e
a
c
ontinuous
dcp
o
with
a
me
asur
ement

!

D
:
(i)
If
(x
n
)
is
a
se
quenc
e
with
x
n
v
x,
then
x
n
!
x
in
the

top
olo
gy
i
lim
n!1
x
n
=
x:
(ii)
A
monotone
map
f
:
D
!
D
is
Sc
ott
c
ontinuous
i

f
:
D
!
[0;
1)

is

c
ontinuous.
Notice
that
the
Scott
top
ology
can
alw
a
ys
b
e
reco
v
ered
from
the

top
ology
as

D
=
f"
U
:
U
2

D
g.
5
Fixed
p
oin
ts
of
con
tractions
In
this
section,
(D
;
)
is
a
domain
with
a
measuremen
t

!

D
:
Denition
5.1
Let
f
b
e
a
monotone
selfmap
on
(D
;
).
If
there
exists
a
constan
t
c
suc
h
that
x
v
y
)
f
(x)
 f
(y
)

c

(x
 y
);
for
all
x;
y
2
D
,
then
f
is
a
c
ontr
action
if
c
<
1
and
nonexp
ansive
if
c

1:
Prop
osition
5.2
A
c
ontr
action
is
Sc
ott
c
ontinuous.
Pro
of.
First,
f
is

con
tin
uous.
By
Theorem
4.4,
the

top
ology
on
D
is
rst
coun
table,
and
so
w
e
can
w
ork
with
sequences
in
v
erifying
this
assertion.
Let
x
n
!
x
in
the

top
ology
on
D
.
Then
w
e
can
assume
x
n
v
x.
Hence
0

f
(x
n
)
 f
(x)

c

(x
n
 x)
whic
h
means
lim
n!1
f
(x
n
)
=
f
(x)
since
x
n
!
x:
Then
f
is

con
tin
uous.
By
Lemma
4.5(ii),
f
is
Scott
con
tin
uous.
2
The
last
prop
osition
do
es
not
require
a
con
traction:
The
same
pro
of
w
orks
for
an
y
v
alue
of
c

0.
It
is
our
next
result
that
requires
c
<
1:
Theorem
5.3
L
et
f
b
e
a
c
ontr
action
on
(D
;
).
If
ther
e
is
a
p
oint
x
v
f
(x),
then
x
(f
)
:=
G
n0
f
n
(x)
is
the
unique
xe
d
p
oint
of
f
on
D
.
Pro
of.
By
Prop.
5.2,
f
is
Scott
con
tin
uous,
so
it
is
clear
that
x(f
)
is
a
xed
p
oin
t
of
f
.
181

Mar
tin
Let
x
=
f
(x)
and
y
=
f
(y
)
b
e
t
w
o
xed
p
oin
ts
of
f
.
By
our
assumption
on
D
,
there
is
an
elemen
t
z
2
D
with
z
v
x;
y
:
Then
f
n
(z
)
v
x
=
f
n
(x);
for
all
n

1:
By
induction,
w
e
ha
v
e
f
n
(z
)
 f
n
(x)
=
f
n
(z
)
 x

c
n

(z
 x);
for
all
n

1.
Then
f
n
(z
)
!
x
and
so
G
n0
f
n
(z
)
=
x
since

!

D
:
But
the
same
argumen
t
applies
to
y
.
2
In
fact,
careful
insp
ection
of
the
pro
of
of
the
last
theorem
sho
ws
that
the
unique
xed
p
oin
t
is
an
attractor
in
the

top
ology
.
Denition
5.4
A
xed
p
oin
t
p
=
f
(p)
of
a
con
tin
uous
map
f
:
X
!
X
on
a
space
X
is
called
an
attr
actor
if
there
is
an
op
en
set
U
around
p
suc
h
that
f
n
(x)
!
p
for
all
x
2
U:
W
e
also
refer
to
p
as
attr
active.
Examples
of
attractiv
e
xed
p
oin
ts
are
easy
to
nd:
In
the
analysis
of
h
yp
erb
olic
iterated
function
systems,
where
they
are
sometimes
called
frac-
tals,
or
in
the
study
of
iterativ
e
metho
ds
in
n
umerical
analysis
lik
e
Newton's
metho
d,
where
they
arise
as
the
solutions
to
nonlinear
equations.
Corollary
5.5
L
et
f
b
e
a
c
ontr
action
on
(D
;
).
If
a
v
x
(f
),
then
G
n0
f
n
(a)
=
x
(f
);
and
this
supr
emum
is
a
limit
in
the

top
olo
gy.
That
is,
x
(f
)
is
an
attr
actor
in
the

top
olo
gy.
Pro
of.
The
claim
is
implicitly
established
in
the
previous
theorem.
F
or
the
attractor
bit,
let
U
=
#
x(f
).
This
is
a
lo
w
er
set
and
hence

op
en.
2
Th
us,
b
eginning
with
any
appro
ximation
a
of
x
(f
),
the
iterates
f
n
(a)
con
v
erge
to
x
(f
),
ev
en
if
a
6v
f
(a):
In
addition,
w
e
can
obtain
a
go
o
d
estimate
of
ho
w
man
y
iterations
are
required
to
ac
hiev
e
an
"-appro
ximation
of
x
(f
):
Prop
osition
5.6
L
et
f
b
e
a
c
ontr
action
on
(D
;
)
with
unique
xe
d
p
oint
x(f
):
Then
for
any
x
v
x(f
)
and
"
>
0,
n
>
log(x
 
x(f
))
 log
"
log(1=c)
)
jf
n
(x)
 
x(f
)j
<
";
for
any
inte
ger
n

0;
pr
ovide
d
x
6=
x
(f
):
Pro
of.
If
c
=
0;
then
f
is
constan
t,
and
the
statemen
t
holds
trivially
,
adopting
the
con
v
en
tion
that
log(1=0)
=
log
1
=
1.
Let
0
<
c
<
1:
182

Mar
tin
F
or
an
in
teger
n

0,
w
e
ha
v
e
jf
n
(x)
 
x(f
)j
=
f
n
(x)
 
x(f
)

c
n

(x
 
x(f
)):
Th
us,
n
>
log(x
 
x(f
))
 log
"
log(1=c)
)
c
n

(x
 
x(f
))
<
";
whic
h
pro
v
es
the
claim.
2
Of
course,
for
the
estimate
to
b
e
useful
w
e
m
ust
kno
w
the
measure
of
x
(f
):
One
case
when
this
is
easy
to
calculate
is
if
f
(x)

c

x.
Then

x(f
)
=
0:
Surprisingly
,
this
condition
amoun
ts
to
sa
ying
that
f
is
the
extension
to
D
of
a
con
tin
uous
map
on
k
er
.
Prop
osition
5.7
F
or
a
c
ontr
action
f
on
(D
;
)
with
k
er

=
max
D
,
the
fol
lowing
ar
e
e
quivalent:
(i)
The
map
f
pr
eserves
maximal
elements.
(ii)
F
or
al
l
x
2
D
,
f
(x)

c

x.
In
either
c
ase,
x(f
)
2
max
D
:
Pro
of.
Let
f
ha
v
e
con
traction
constan
t
c.
(i)
)
(ii):
Let
x
2
D
:
By
the
directed
completeness
of
D
,
there
is
an
elemen
t
y
2
"
x
\
max
D
.
Then
f
(x)
 f
(y
)
=
f
(x)

c

(x
 y
)
=
c

x
whic
h
holds
since
f
(y
)
=
0
b
y
(i).
(ii)
)
(i):
Let
x
2
max
D
:
Then
x
=
0
so
0

f
(x)

c

x
=
0.
Th
us,
f
(x)
2
k
er

=
max
D
:
2
In
fact,
ev
ery
con
traction
on
a
complete
metric
space
can
b
e
represen
ted
as
a
con
traction
on
a
domain
of
the
t
yp
e
ab
o
v
e.
Example
5.8
Let
f
:
X
!
X
b
e
a
con
traction
on
a
complete
metric
space
X
with
Lipsc
hitz
constan
t
c
<
1:
The
mapping
f
:
X
!
X
extends
to
a
monotone
map

f
:
BX
!
BX
on
the
formal
ball
mo
del
BX
[2]
giv
en
b
y

f
(x;
r
)
=
(f
x;
c

r
);
whic
h
satises


f
(x;
r
)
 

f
(y
;
s)
=
c


(x;
r
)
 c


(y
;
s)
=
c

(
(x;
r
)
 
(y
;
s));
where

:
BX
!
[0;
1)

,

(x;
r
)
=
r
;
is
the
standard
measuremen
t
on
BX
.
No
w
c
ho
ose
r
so
that
(x;
r
)
v

f
(x;
r
).
By
Theorem
5.3,

f
has
a
unique
xed
p
oin
t
whic
h
implies
that
f
do
es
to
o.
Th
us,
Theorem
5.3
has
the
Banac
h
xed
p
oin
t
theorem
as
a
consequence.
A
constan
t
mapping
taking
an
y
v
alue
o
the
top
is
a
con
traction
with
a
unique
xed
p
oin
t
that
is
not
maximal,
and
hence
not
of
the
sort
men
tioned
in
Prop.
5.7.
W
e
will
see
a
more
substan
tial
example
later
on.
183

Mar
tin
6
Fixed
p
oin
ts
of
nonexpansiv
e
maps
W
e
b
egin
with
a
fundamen
tal
result
on
a
w
ell-kno
wn
theme.
Theorem
6.1
L
et
f
:
D
!
D
b
e
a
Sc
ott
c
ontinuous
map
on
a
c
ontinuous
dcp
o
D
with
le
ast
element
?.
Then
its
le
ast
xe
d
p
oint
is
an
attr
actor
in
the

top
olo
gy:
F
or
al
l
x
v
x
(f
),
G
n0
f
n
(x)
=
x
(f
);
and
this
supr
emum
is
a
limit
in
the

top
olo
gy.
Pro
of.
By
monotonicit
y
,
w
e
ha
v
e
f
n
(?)
v
f
n
(x)
v
x
(f
);
for
all
n

0:
Then
since
f
n
(?)
!
x
(f
)
in
the

top
ology
,
f
n
(x)
!
x(f
)
in
the

top
ology
.
2
Prop
osition
6.2
L
et
f
b
e
a
monotone
map
on
(D
;
)
with
le
ast
element
?
and
me
asur
ement

!

D
such
that
x
v
y
)
f
(x)
 f
(y
)
<
x
 y
;
for
al
l
distinct
p
airs
x;
y
2
D
.
Then
x
(f
)
:=
G
n0
f
n
(?)
is
the
unique
xe
d
p
oint
of
f
on
D
.
Pro
of.
The
map
f
is
nonexpansiv
e
and
hence
Scott
con
tin
uous
b
y
the
remark
follo
wing
Prop.
5.2.
Th
us,
x(f
)
is
its
least
xed
p
oin
t.
If
x
is
an
y
xed
p
oin
t
of
f
,
then
x
(f
)
v
x:
If
these
t
w
o
are
dieren
t,
then

x(f
)
 x
=
f
(x(f
))
 f
(x)
<

x(f
)
 x.
Then
they
are
the
same.
This
pro
v
es
that
x
(f
)
is
the
only
xed
p
oin
t
of
f
.
2
If
the
map
in
the
last
result
preserv
ed
max
D
=
k
er
,
it
w
ould
satisfy
f
(x)
<
x,
for
x
>
0:
Happily
,
for
maps
lik
e
these,
w
e
can
pro
v
e
the
last
result
assuming
only
a
measuremen
t.
Theorem
6.3
L
et
(D
;
)
b
e
a
c
ontinuous
dcp
o
with
me
asur
ement

and
le
ast
element
?.
If
f
:
D
!
D
is
a
Sc
ott
c
ontinuous
map
with
f
(x)
<
x
for
x
>
0,
then
x(f
)
:=
G
n0
f
n
(?)
2
max
D
is
the
unique
xe
d
p
oint
of
f
on
D
.
In
addition,
if
f
(k
er
)

k
er
,
then
(8x
2
k
er
)
f
n
(x)
!
x
(f
);
in
the
r
elative
Sc
ott
top
olo
gy
on
k
er
:
Pro
of.
If

x(f
)
>
0,
then

x(f
)
=
f
(x(f
))
<

x(f
):
Hence

x(f
)
=
0
whic
h
means
x(f
)
2
k
er


max
D
:
But
if
a
least
xed
p
oin
t
is
maximal,
it
m
ust
b
e
unique.
184

Mar
tin
T
o
see
that
x
(f
)
is
an
attractor
in
the
relativ
e
Scott
top
ology
on
k
er
;
let
U

D
b
e
a
Scott
op
en
set
around
x(f
):
Then
there
is
K
suc
h
that
n

K
)
f
n
(?)
2
U
whic
h
means
n

K
)
f
n
(x)
2
U
\
k
er

since
f
n
(?)
v
f
n
(x)
and
f
(k
er
)

k
er
.
Hence,
f
n
(x)
!
x(f
)
in
the
relativ
e
Scott
top
ology
on
k
er
,
for
an
y
initial
guess
x
2
k
er
:
2
This
is
the
same
result
as
Theorem
3.4
extended
to
a
larger
class
of
map-
pings
on
domains
with
least
elemen
ts.
In
addition,
in
eac
h
of
the
last
t
w
o
results,
Theorem
6.1
implies
x(f
)
is
an
attractor
in
the

top
ology
on
D
.
No
w
for
wh
y
all
this
matters.
7
Applications
Time
to
b
e
sixteen
again.
Let
f
:
[0;

=2]
!
[0;

=2]
b
e
f
(x)
=
sin
x:
As
is
w
ell-kno
wn,
b
eginning
with
an
y
p
oin
t
x
2
[0;

=2]
and
successiv
ely
applying
f
yields
a
sequence
of
iterates
(f
n
(x))
that
magically
tends
to
zero.
Wh
y?
A
t
rst
glance,
one
thinks
of
the
Banac
h
theorem,
whic
h
explains
that
con
tractions
b
eha
v
e
this
w
a
y
.
Up
on
closer
insp
ection,
ho
w
ev
er,
w
e
see
that
things
are
more
in
teresting
in
the
case
of
the
sine
w
a
v
e.
Because
f
0
(0)
=
1,
f
(x)
=
sin
x
is
not
a
con
traction
on
[0;

=2],
and
so
the
Banac
h
theorem
is
not
applicable.
But
domain
theory
is.
Example
7.1
Let
D
=
[0;

=2]

b
e
the
domain
with
x
v
y
,
y

x
and
natural
measuremen
t
x
=
x:
The
function
f
(x)
=
sin
x
is
a
monotone
selfmap
on
D
.
By
the
mean
v
alue
theorem,
if
x
v
y
and
x
6=
y
,
there
is
c
2
(y
;
x)
suc
h
that
f
(x)
 f
(y
)
=
f
(x)
 f
(y
)
=
f
0
(c)(x
 y
)
=
(cos
c)(x
 y
):
Hence,
f
(x)
 f
(y
)
<
x
 y
;
since
0
<
cos
c
<
1.
Then
Theorem
6.2
implies
that
f
has
a
unique
xed
p
oin
t,
giv
en
b
y
x
(f
)
=
G
n0
f
n
(
=2):
Ho
w
ev
er,
f
(0)
=
0,
so
w
e
m
ust
ha
v
e
x(f
)
=
0,
b
y
uniqueness.
No
w
the
in
teresting
part.
By
Theorem
6.1,
x
(f
)
is
an
attractor
in
the

top
ology
.
Th
us,
for
any
x
v
x
(f
),
f
n
(x)
!
x(f
)
in
the

top
ology
.
But
con
v
ergence
in
the

top
ology
on
D
implies
con
v
ergence
in
the
euclidean
top
ology
.
Th
us,
for
all
x
2
[0;

=2],
f
n
(x)
!
0:
In
fact,
the
reasoning
in
the
last
example
extends
to
any
compact
metric
space,
since
they
can
all
b
e
mo
deled
[3]
as
the
k
ernel
of
a
measuremen
t.
185

Mar
tin
Prop
osition
7.2
L
et
f
:
X
!
X
b
e
a
function
on
a
c
omp
act
metric
sp
ac
e
(X
;
d)
such
that
d(f
x;
f
y
)
<
d(x;
y
)
for
al
l
x;
y
2
X
with
x
6=
y
:
Then
f
has
a
unique
xe
d
p
oint
x

such
that
for
al
l
x
2
X
,
f
n
(x)
!
x

:
Pro
of.
Let
UX
b
e
the
domain
of
nonempt
y
compact
subsets
of
X
ordered
under
rev
erse
inclusion.
The
map
f
has
a
Scott
con
tin
uous
extension
to
UX
giv
en
b
y

f
:
UX
!
UX
::
K
7!
f
(K
).
The
domain
UX
has
a
natural
measuremen
t,
x
=
diam
x,
the
diameter
mapping
deriv
ed
from
the
metric
d.
In
addition,
the
space
X
can
b
e
reco
v
ered
as
k
er

=
ffxg
:
x
2
X
g
=
max
UX
'
X
in
the
relativ
e
Scott
top
ology
.
F
or
x
>
0,
either


f
(x)
=
0
<
x,
or
the
compactness
of
x
yields
distinct
p
oin
ts
a;
b
2
x
suc
h
that


f
(x)
=
d(f
a;
f
b)
<
d(a;
b)

x:
The
result
no
w
follo
ws
from
Theorem
6.3.
2
That
is,
the
Banac
h
xed
p
oin
t
theorem
holds
on
compact
metric
spaces
under
w
eak
er
assumptions.
The
impressiv
e
asp
ect
of
the
last
result
is
not
the
uniqueness
of
x

:
It
is
that
x

is
a
global
attractor.
Corollary
7.3
L
et
f
:
[a;
b]
!
[a;
b]
b
e
a
c
ontinuous
map
on
a
nonempty
c
omp
act
interval.
If
jf
0
(x)j
<
1
for
al
l
x
2
(a;
b),
then
f
has
a
unique
xe
d
p
oint
x

2
[a;
b]
such
that
f
n
(x)
!
x

,
for
al
l
x
2
[a;
b]:
Pro
of.
By
the
mean
v
alue
theorem,
jf
(b)
 f
(a)j
=
jf
0
(c)jjb
 aj
<
jb
 aj
for
some
c
2
(a;
b):
No
w
Prop.
7.2
applies.
2
The
map
f
(x)
=
sin
x
satisifes
0
<
f
0
(x)
<
1
on
(0;

=2),
but
as
w
e
ha
v
e
already
seen,
it
is
not
a
con
traction.
Th
us,
Theorem
6.3
yields
another
insigh
t
in
to
wh
y
the
sine
w
a
v
e
b
eha
v
es
the
w
a
y
it
do
es.
But
the
reader
should
not
b
e
misled
in
to
thinking
that
these
ideas
are
only
applicable
to
domain
theoretic
fragmen
ts
of
classical
mathematics.
Example
7.4
Let
D
=
[N
!
N
?
]
b
e
the
domain
of
partial
functions
on
the
naturals.
The
elemen
ts
of
D
are
measured
as
f
=
X
f
(n)=?
1
2
n+1
:
Then
k
er

=
ff
2
D
:
dom
(f
)
=
N
g
is
the
set
of
total
functions.
No
w
consider
the
op
erator

:
D
!
D
giv
en
b
y
(f
)(n)
=
8
<
:
n
if
n
=
0
or
n
=
1;
n
+
f
(n
 2)=
cos(n
=2)
otherwise
:
186

Mar
tin
Because
(f
)(n)
=
?
)
f
(n
 2)
=
?
or
(n
>
1
and
o
dd),
w
e
are
able
to
write
for
elemen
ts
f
v
g
that
(f
)
 (g
)
=
X
f
(n 2)=?
1
2
n+1
 X
g
(n 2)=?
1
2
n+1
=
X
f
(n)=?
1
2
n+3
 X
g
(n)=?
1
2
n+3
=
1
4
(f
 g
):
By
Theorem
5.3,

has
a
unique
xed
p
oin
t.
Clearly
this
xed
p
oin
t
is
not
maximal:
It
is
undened
on
the
set
f2k
+
1
:
k
>
1g.
Then
con
tractions
with
xed
p
oin
ts
o
the
top
are
w
orth
studying
to
o.
8
Ideas
It
w
ould
b
e
nice
to
see
a
metric
based
approac
h
to
seman
tics
replaced
with
one
based
on
results
lik
e
Theorem
5.3.
Esp
ecially
on
a
mo
del
of
CSP
.
T
rying
to
obtain
estimates
in
the
spirit
of
Prop.
5.6
for
nonexp
ansive
maps
also
seems
lik
e
a
fun
question.
It
w
ould
b
e
neat
to
nd
out
if
the
informatic
deriv
ativ
e
[5]
(deriv
ativ
e
of
a
map
on
a
domain
with
resp
ect
to
a
measuremen
t)
can
b
e
useful
in
this
regard.
References
[1]
S.
Abramsky
and
A.
Jung.
Domain
The
ory.
In
S.
Abramsky
,
D.
M.
Gabba
y
,
T.
S.
E.
Maibaum,
editors,
Handb
o
ok
of
Logic
in
Computer
Science,
v
ol.
I
I
I.
Oxford
Univ
ersit
y
Press,
1994.
[2]
A.
Edalat
and
R.
Hec
kmann.
A
Computational
Mo
del
for
Metric
Sp
ac
es.
Theoretical
Computer
Science
193
(1998)
53{73.
[3]
K.
Martin.
Nonclassic
al
te
chniques
for
mo
dels
of
c
omputation.
T
op
ology
Pro
ceedings,
v
ol.
24,
1999.
[4]
K.
Martin.
The
me
asur
ement
pr
o
c
ess
in
domain
the
ory.
Pro
ceedings
of
the
27
th
In
ternational
Collo
quium
on
Automata,
Languages
and
Programming
(ICALP),
Lecture
Notes
in
Computer
Science,
v
ol.
1853,
Springer-V
erlag,
2000.
[5]
K.
Martin.
A
foundation
for
c
omputation.
Ph.D.
Thesis,
T
ulane
Univ
ersit
y
,
Departmen
t
of
Mathematics,
2000.
187

188

MFPS
17
Preliminary
Version
A
Generalisation
of
Stationary
Distributions,
and
Probabilistic
Program
Algebra
A.K.
McIv
er
1;2
Dep
artment
of
Computing
Mac
quarie
University
NSW,
A
ustr
alia
Abstract
W
e
generalise
the
classical
notion
of
stationary
distributions
of
Mark
o
v
pro
cesses
to
a
mo
del
of
probabilistic
programs
whic
h
includes
demonic
nondeterminism.
As
w
ell
as
remo
ving
some
of
the
conditions
normally
required
for
stationarit
y
,
our
gen-
eralisation
allo
ws
the
dev
elopmen
t
of
a
complete
theory
linking
stationary
b
eha
viour
to
long-term
a
v
erage
b
eha
viour
|
the
latter
b
eing
an
imp
ortan
t
prop
ert
y
that
lies
outside
the
expressiv
e
range
of
standard
logics
for
probabilistic
programs.
Keyw
ords:
Probabilistic
program
seman
tics,
probabilit
y
,
demonic
nondetermin-
ism,
Mark
o
v
pro
cess,
stationary
distribution,
Mark
o
v
decision
pro
cesses.
1
In
tro
duction
Programs
or
pro
cesses
whic
h
can
mak
e
probabilistic
c
hoices
during
their
exe-
cution
exhibit
a
range
of
(probabilistic)
b
eha
viours
outside
those
describable
b
y
purely
qualitative
formalisms;
moreo
v
er
ev
en
w
ell-kno
wn
quantitative
adap-
tations
of
familiar
program
logics
|
the
foremost
b
eing
probabilistic
temp
oral
logic
[18,2
]
|
are
still
not
expressiv
e
enough
in
some
cases.
One
suc
h
is
the
so-
called
\a
v
erage
long-term"
b
eha
viour
[3,4],
whic
h
w
e
illustrate
in
the
con
text
of
the
program
presen
ted
in
Fig.
1.
The
program
FP
represen
ts
a
sp
ecica-
tion
of
a
simple
failure-repair
mec
hanism.
The
system
it
describ
es
is
in
tended
to
execute
rep
eatedly
,
and
the
state
ev
olv
es
according
to
the
sp
ecied
prob-
abilistic
statemen
ts.
The
a
v
erage
long-term
b
eha
viour
of
FP
determines
(for
example)
the
prop
ortion
of
time
that
the
state
is
ok,
and
is
alw
a
ys
w
ell-dened
[4
].
Other
related
terms
are
\a
v
ailabilit
y"
[17]
and
\the
stationary
probabilit
y
of
ok"
[8].
In
this
particular
case
an
elemen
tary
analysis
rev
eals
that
ok
holds
1
This
w
ork
w
as
done
at
Oxford
Univ
ersit
y
,
UK,
and
w
as
funded
b
y
the
EPSR
C.
2
Email:
anabel@ics.mq.ed
u.
au
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

McIver
FP
:
=
if
ok
then
(ok
2=3

:ok)
[]
ok
else
(ok
1=2

:ok)
[]
ok

ok
and
:ok
toggle
the
states
corresp
onding
to
w
orking
and
brok
en
b
eha
viour.
The
op
erator
2=3

records
a
probabilistic
up
date,
whereas
[]
records
a
nondeterministic
up
date.
Used
together
lik
e
this,
w
e
are
able
to
sp
ecify
tolerances
on
failure
rates
|
at
ev
ery
execution,
there
is
at
le
ast
a
probabilit
y
1=2
of
reestablishing
ok
(since
the
only
other
alternativ
e
to
the
probabilistic
branc
h
establishes
ok
with
certain
t
y).
Fig.
1.
An
abstract
failure-repair
mec
hanism
on
a
v
erage
at
least
3=5
of
the
time
|
y
et
probabilistic
temp
oral
logic
cannot
describ
e
that
b
eha
viour.
(de
Alfaro
giv
es
a
nice
discussion
of
the
issues
[3].)
In
elemen
tary
probabilit
y
theory
,
long
term
a
v
erage
b
eha
viour
is,
in
some
sp
ecial
cases,
determined
b
y
\stationary
distributions"
|
a
prop
ert
y
of
(some)
Mark
o
v
pro
cesses.
Though
some
authors
[10,16
]
ha
v
e
used
Mark
o
v
pro
cesses
as
a
mo
del
for
probabilistic
programs,
more
recen
tly
a
generalised
form
[13
,9,2]
has
b
een
found
to
b
e
more
suitable,
since
it
supp
orts
the
notions
of
(demonic)
nondeterminism
(or
abstraction)
and
the
induced
partial
order
kno
wn
as
re-
nemen
t.
That
is
the
mo
del
w
e
shall
w
ork
with
here,
and
w
e
giv
e
details
in
Sec.
5.
Th
us
our
main
con
tribution
(in
Sec.
3)
is
to
giv
e
an
axiomatic
accoun
t
of
stationary
b
eha
viour
and
con
v
ergence
to
it,
one
whic
h
extends
and
sim-
plies
the
classical
notion.
Not
only
is
our
notion
of
generalised
con
v
ergence
applicable
to
all
Mark
o
v
pro
cesses
(rather
than
only
to
some
sp
ecial
cases)
but
it
completes
the
theory
linking
stationary
b
eha
viour
to
a
v
erage
long-term
b
eha
viour.
The
details
are
set
out
in
Sec.
5.
W
e
dev
elop
our
theory
follo
wing
the
algebraic
st
yle
already
a
v
ailable
in
theories
of
concurrency
,
where
it
has
pro
v
ed
a
p
o
w
erful
to
ol
for
analysing
nondeterministic
programs
that
execute
rep
eatedly
.
W
e
use
\:"
for
function
application;
,
+
and
u
denote
resp
ectiv
ely
\is
no
more
than",
addition
and
minim
um
applied
p
oin
t
wise
to
real-v
alued
functions.
Throughout
S
is
a
nite
state
space
and
S
is
fF
j
S
!
[0;
1]

P
s:S
F
:s
=
1g,
the
set
of
(discrete)
probabilit
y
distributions
o
v
er
S
.
F
or
real
k
,
w
e
write
k
for
the
constan
t
real-v
alued
function
with
range
fk
g.
If

is
a
real-v
alued
function
o
v
er
S
then
(t
)
and
(u
)
denote
resp
ectiv
ely
the
maxim
um
and
minim
um
v
alue
tak
en
b
y

as
the
state
v
aries
o
v
er
S
;
and
(k

)
or
k
(
)
represen
ts
the
the
function

p
oin
t
wise
m
ultiplied
b
y
the
real
k
.
W
e
in
tro
duce
other
notation
as
w
e
need
it.
190

McIver
2
Probabilistic
sequen
tial
programs
W
e
summarise
t
w
o
equiv
alen
t
mo
dels
for
probabilistic
programs;
more
details
are
giv
en
elsewhere
[13
,9].
The
seman
tics
for
probabilistic
sequen
tial
programs
supp
orts
the
in
terpretation
of
traditional
programming
con
trol
structures
to-
gether
with
a
binary
probabilistic
c
hoice
op
erator
p
,
where
the
op
erational
meaning
of
the
expression
A
p

B
is
that
either
A
or
B
is
executed,
with
probabilit
y
resp
ectiv
ely
p
or
1 p.
Since
there
is
no
determined
output,
that
b
eha
viour
is
sometimes
called
\probabilistic
nondeterminism".
Probabilistic
nondeterminism
is
ho
w
ev
er
v
ery
dieren
t
from
\demonic
nondeterminism",
denoted
b
y
\[]",
already
presen
t
in
standard
guarded
commands
[5],
and
whic
h
can
mo
del
undersp
ecication
or
demonic
sc
heduling
in
distributed
systems.
And
the
t
w
o
op
erators
are
mo
delled
v
ery
dieren
tly
|
as
usual
prob-
abilistic
information
is
describ
ed
b
y
(output)
probabilit
y
distributions
o
v
er
nal
states,
whereas
demonic
b
eha
viour
is
describ
ed
b
y
subsets
of
p
ossible
outputs.
Putting
those
t
w
o
ideas
together
leads
to
a
mo
del
in
whic
h
programs
corresp
ond
to
functions
from
initial
state
to
sets
of
distributions
o
v
er
nal
states,
where
the
m
ultiplicit
y
of
the
result
set
represen
ts
a
degree
of
nondeter-
minism
and
the
distribution
records
the
probabilistic
information
after
that
nondeterminism
has
b
een
resolv
ed.
W
e
ha
v
e
the
follo
wing
denition
for
the
probabilistic
program
space
H
S
[9,13
]
for
programs
op
erating
o
v
er
the
ab-
stract
state
space
S
,
3
and
its
treatmen
t
of
nondeterminism
is
similar
to
that
of
other
mo
dels
[2,15
,4]:
H
S
:
=
S
!
PS
:
More
generally
,
lik
e
Mark
o
v
pro
cesses,
ev
ery
program
in
H
S
can
b
e
considered
to
b
e
a
function
from
probabilit
y
distributions
o
v
er
initial
states,
but
in
this
case
to
sets
of
probabilit
y
distributions
o
v
er
nal
states
[9].
W
e
order
programs
using
program
renemen
t,
whic
h
compares
the
exten
t
of
nondeterminism
|
programs
higher
up
the
renemen
t
order
exhibit
less
nondeterminism
than
those
lo
w
er
do
wn:
Q
v
P
i
(8s:
S

P
:s

Q:s)
:
Classical
Mark
o
v
pro
cesses
can
b
e
iden
tied
with
the
sub
class
of
\determin-
istic",
or
purely
probabilistic
programs
in
H
S
,
and
as
suc
h
are
maximal
with
resp
ect
to
v.
F
or
instance
the
(demonically
deterministic)
program
ok
1=2

:ok
has
no
prop
er
renemen
ts
at
all.
One
consequence
of
v
ab
o
v
e
is
that
(w
orst
case)
quan
titativ
e
prop
erties
impro
v
e
as
programs
b
ecome
more
rened.
If
Q
guaran
tees
to
establish
a
predicate

with
probabilit
y
at
least
p
(irresp
ectiv
e
of
the
nondeterminism),
then
P
m
ust
also
establish

with
probabilit
y
at
least
that
same
p.
That
observ
ational
view
of
probabilistic
systems
(in
whic
h
the
frequency
of
outputs
is
recorded)
is
captured
more
generally
with
the
idea
of
\exp
ected
v
al-
ues".
Kozen
w
as
the
rst
to
exploit
this
fact
in
his
probabilistic
program
logic
3
This
basic
mo
del
can
also
b
e
enhanced
to
include
non
termination
[13]
and
miracles
[14
].
191

McIver
(but
for
deterministic
programs).
His
insigh
t
w
as
to
regard
programs
as
op
er-
ators
whic
h
transform
real-v
alued
functions
in
a
goal-directed
fashion,
in
the
same
w
a
y
that
standard
programs
can
b
e
mo
delled
as
predicate
transformers
[5
].
The
use
of
real-v
alued
functions
instead
of
predicates
allo
ws
expressions
to
incorp
orate
quan
titativ
e
(as
w
ell
as
qualitativ
e)
information.
The
idea
has
b
een
extended
b
y
others
[13]
to
include
demonic
nondeterminism
as
w
ell
as
probabilit
y
.
W
e
write
E
S
for
the
space
of
real-v
alued
functions
(exp
ectations)
o
v
er
S
,
and
T
S
for
the
asso
ciated
space
of
\exp
ectation
transformers",
dened
next.
Denition
2.1
Let
r
:
S
!
P(S
)
b
e
a
program
taking
initial
states
in
S
to
sets
of
nal
distributions
o
v
er
S
.
Then
the
gr
e
atest
guar
ante
e
d
pre-exp
ectation
at
state
s
of
program
r
,
with
resp
ect
to
p
ost-exp
ectation

in
E
S
,
is
dened
wp:r
:
:s
:
=
(uF
:
r
:s

Z
F

)
;
where
R
F

denotes
the
exp
ected
v
alue
of

with
resp
ect
to
distribution
F
.
4
W
e
sa
y
that
wp
:r
is
an
exp
e
ctation
tr
ansformer
corresp
onding
to
r
,
and
w
e
dene
T
S
to
b
e
wp:H
S
.
Programs
are
ordered
b
y
comparing
the
results
of
qualitativ
e
observ
ations:
th
us
t
v
t
0
i
(8
:
E
+
S

t:

t
0
:
)
;
where
E
+
S
denote
the
non-negativ
e
exp
ectations.
There
is
no
conict
in
using
\v"
to
denote
the
order
in
b
oth
H
S
and
T
S
,
since
the
denitions
corresp
ond
[13
].
In
the
sp
ecial
case
that
the
p
ost-exp
ectation
tak
es
v
alues
in
f0;
1g
and
th
us
represen
ts
a
predicate,
the
pre-exp
ectation
represen
ts
the
greatest
guaran
teed
probabilit
y
of
the
program
establishing
that
predicate.
Nondeterminism,
as
for
predicate
transformers,
is
in
terpreted
demonically
.
Although
the
t
w
o
views
are
equiv
alen
t
[13
],
w
e
usually
use
T
S
b
ecause
its
arithmetic
prop
erties
mak
e
it
more
con
v
enien
t
for
pro
of
than
H
S
.
T
ransform-
ers
in
T
S
are
con
tin
uous
(in
the
sense
of
real-v
alued
functions)
and
subaddi-
tiv
e,
that
is
t:(k

+
k
0

 k
00
)

k
(t:
)
+
k
0
(t:
)
 k
00
;
whic
h
can
b
e
strengthened
to
additivit
y
in
the
case
of
deterministic
programs
(classical
Mark
o
v
pro
cesses).
W
e
in
terpret
basic
program
constructs
as
op-
erations
on
transformers:
th
us
(t;
t
0
):
:
=
t:(t
0
:
);
(t
[]
t
0
):
:
=
t:
[]
t
0
:
and
(t
p

t
0
):
:
=
p(t:
)
+
(1 p)(t
0
:
),
from
whic
h
w
e
see
that
determinism
is
preserv
ed
b
y
p

and
;
,
but
not
b
y
[]
.
The
next
lemma
can
b
e
pro
v
ed
v
ery
simply
using
the
notions
of
T
S
.
Dene
the
norm
jj:jj
on
exp
ectations
as
jj
jj:
=
(t
)
 (u
).
Our
denitions
imply
4
In
fact
R
F

is
just
P
s:S
:sF
:s
b
ecause
S
is
nite
and
F
is
discrete
[6].
W
e
use
the
R
-notation
b
ecause
it
is
less
cluttered,
and
to
b
e
consisten
t
with
the
more
general
case.
192

McIver
that
if
jj
jj
=
0
then

is
constan
t
on
S
.
Lemma
2.2
L
et
t;
t
0
b
e
an
exp
e
ctation
tr
ansformers
in
T
S
.
If
t
is
determin-
istic,
and
t
0
;
t
=
t
0
;
and
furthermor
e
if
ther
e
is
some
0

c
<
1
such
that
for
any

we
have
jjt:
jj

cjj
jj,
then
t
0
is
deterministic.
Pro
of:
The
ab
ove
discussion
suggests
that
we
just
ne
e
d
to
show
that
t
0
is
additive,
which
fol
lows
by
c
ontinuity
of
tr
ansformers
in
T
S
.
Ev
en
though
Lem.
2.2
is
more
generally
true
for
an
y
programs
in
T
S
satisfying
the
conditions,
it
actually
c
haracterises
the
prop
ert
y
whic
h
underlies
whether
a
Mark
o
v
pro
cess
con
v
erges
to
its
so-called
stationary
distribution
or
not,
namely
that
it
acts
lik
e
a
con
traction
with
resp
ect
to
jj:jj.
The
term
\con
traction"
ho
w
ev
er
is
more
general
and
can
b
e
applied
to
the
whole
of
T
S
,
not
just
to
its
deterministic
p
ortion:
FP
in
Fig.
1
is
a
con
traction
for
instance,
though
it
is
not
a
Mark
o
v
pro
cess.
Con
v
ersely
,
if
t
n
is
not
a
con
traction
for
an
y
p
o
w
er
of
t
then
it
can
b
e
sho
wn
that
there
is
some
prop
er
subset
of
states
that
is
left
in
v
arian
t
b
y
t
n
,
for
some
n.
Suc
h
programs
are
also
called
\p
erio
dic",
and
w
e
shall
return
to
them
later.
3
A
program-algebraic
treatmen
t
of
`stationary
b
eha
v-
iour'
In
this
section
w
e
study
some
algebraic
prop
erties
of
programs
or
systems
that
execute
rep
eatedly
.
Algebraic
approac
hes
ha
v
e
pro
v
ed
to
b
e
v
ery
p
o
w
erful
in
the
dev
elopmen
t
of
concurrency
theory
[1];
w
e
nd
them
to
b
e
extremely
eectiv
e
in
this
con
text
as
w
ell.
Our
basic
language
(in
Fig.
2)
consists
of
t
w
o
binary
op
erators
(\;",
se-
quen
tial
comp
osition
and
\[]",
demonic
nondeterministic
c
hoice),
one
constan
t
(1,
\do
nothing")
and
a
unary
op
erator
(\

",
the
\Kleene
star").
Both
;
and
[]
are
asso
ciativ
e
and
[]
is
comm
utativ
e;
1
is
the
iden
tit
y
of
;.
Observ
e
that
for
probabilistic
mo
dels
[]
fails
to
distribute
to
the
left.
(Other
nonprobabilistic
in
terpretations
w
ould
allo
w
full
distributivit
y
[1].)
W
e
in
terpret
x

in
T
S
as
the
transformer
x

:
:
=
(
Y


u
x;
Y
),
5
whic
h
corresp
onds
to
the
program
that
from
initial
state
s
outputs
the
strongest
set
of
in
v
arian
t
states
con
taining
s.
W
e
shall
also
use
the
sp
ecial
program
c
haos
whic
h
denotes
a
nondetermin-
istic
selection
o
v
er
all
the
states
in
S
.
A
program
t
whic
h
can
reac
h
all
states
from
all
initial
states
(with
probabilit
y
1)
has
no
prop
er
in
v
arian
ts,
and
th
us
satises
t

=
c
haos.
Next
w
e
in
tro
duce
our
rst
generalisation
|
a
probabilistic
op
erator
p
;
its
prop
erties
[9]
also
app
ear
in
Fig.
2.
Observ
e
that
the
sub-distribution
of
p

corresp
onds
to
subadditivit
y
of
T
S
.
5

forms
the
greatest
xed
p
oin
t
with
resp
ect
to

on
E
S
.
193

McIver
x
v
y
,
x
[]
y
=
x
x

=
1
[]
x
[]
x

;
x

x;
(y
[]
1)
w
x
)
x;
y

=
x
x;
(y
[]
z
)
v
x;
y
[]
x;
z
x;
y
w
y
)
x

;
y
=
y
(y
[]
z
);
x
=
y
;
x
[]
z
;
x
x
p

y
=
y
1 p

x
x
[]
y
v
x
p

y
x;
y
p

x;
z
v
x;
(y
p

z
)
(y
p

z
);
x
=
y
;
x
p

z
;
x
x
p

(y
q

z
)
=
(x
p
(p+q
 pq
)

y
)
(p+q
 pq
)

z
x;
y
;
z
are
in
terpreted
as
programs
in
T
S
,
and
0
<
p
<
1.
The
axioms
without
p

are
similar
to
Kozen's
axiomatisation
of
Kleene's
language
for
regular
expressions
[11
].
Fig.
2.
Basic
axioms
W
e
sa
y
that
a
probabilit
y
distribution
F
in
S
is
stationary
with
resp
ect
to
a
Mark
o
v
pro
cess
t
if
whenev
er
the
input
states
are
distributed
as
F
,
the
output
states
are
also
distributed
exactly
according
to
F
.
In
this
section
w
e
generalise
this
idea
to
all
programs
in
T
S
.
Observ
e
rst
that
an
y
F
in
S
can
b
e
mo
delled
as
the
program
that
outputs
F
|
w
e
call
suc
h
programs
deterministic
assignmen
ts.
W
riting
^
F
for
the
deterministic
assignmen
t
that
outputs
F
for
an
y
initial
state,
w
e
can
see
that
the
denition
of
stationarit
y
ab
o
v
e
is
the
same
as
sa
ying
that
^
F
;
t
=
^
F
holds
as
an
equalit
y
in
T
S
.
Our
crucial
generalising
step
is
no
w
to
consider
any
program
t
0
satisfying
t
0
;
t
=
t
0
to
represen
t
stationary
b
eha
viour
(rather
than
only
those
programs
^
F
generated
from
distributions
F
as
ab
o
v
e);
that
tak
es
us
b
ey
ond
the
classical
treatmen
t.
T
o
ll
in
the
details,
w
e
b
egin
with
the
idea
of
w
eak
est
stationary
program,
as
follo
ws.
W
e
mak
e
use
of
x

to
enco
de
\all
in
v
arian
ts
of
x",
noted
ab
o
v
e.
Denition
3.1
Dene
x
1
to
b
e
the
the
least
program
that
is
stationary
with
resp
ect
to
x
(that
is,
whic
h
satises
x
1
;
x
=
x
1
)
and
whic
h
preserv
es
all
in
v
arian
ts
of
x
(that
is
x

v
x
1
;
x

).
W
e
ha
v
e
x
1
:
=
([]y
:
H
S

y
;
x
v
y
^
x

v
y
;
x

)
:
Note
that
an
imp
ortan
t
in
tuitiv
e
prop
ert
y
of
x
1
is
that
it
preserv
es
all
in
v
arian
ts
of
x
|
an
alternativ
e
denition
that
only
considers
stationarit
y
(the
rst
conjunct
in
Def.
3.1)
giv
es
the
incorrect
([]y
:
H
S

y
;
1
v
y
)
=
c
haos
6=
1
1
=
1
for
the
case
x
=
1.
194

McIver
x

;
x
1
=
x
1
x
11
=
x
1
x
1
v
x
n1
x

v
x
n
x

v
x
1
x
1
=
x

x;
(y
;
x)
1
v
(x;
y
)
1
;
x
x;
x
1
=
x
1
=
x
1
;
x
(p
>
0)
)
(x
p

1)
1
v
x
1
x

;
x
=
x

)
x

=
x
1
x;
y
v
z
;
x
)
x;
y
1
v
z
1
;
y
x
n
=
x

)
x
1
=
x
n1
T
o
a
v
oid
clutter,
w
e
write
x
n1
etc.
instead
of
(x
n
)
1
.
Fig.
3.
A
selection
of
basic
theorems
Program
t
1
can
b
e
though
t
of
as
deliv
ering
from
initial
state
s
the
strongest
in
v
arian
t
reac
hable
from
s,
whilst
preserving
the
probabilistic
stationary
b
e-
ha
viour.
In
fact
t
1
in
T
S
is
the
the
limit
of
the
increasing
c
hain
of
programs
t

v
t

;
t
v
t

;
t
2
v
:
:
:
v
t

;
t
n
v
:
:
:
That
limit
is
w
ell-dened
since
T
S
is
directed-complete,
and
hence
w
e
ha
v
e
the
additional
fact
(8n
>
0

x

;
x
n
v
y
)
)
x
1
v
y
:
(1)
In
Fig.
3
w
e
set
out
some
general
theorems
ab
out
1
and

,
all
implied
b
y
the
axioms
of
Fig.
2
and
the
prop
erties
of
1
set
out
in
Def.
3.1
and
(1).
T
o
see
the
dierence
b
et
w
een

and
1
w
e
reconsider
FP
from
Fig.
1.
The
only
non
trivial
in
v
arian
t
set
of
states
is
fok
;
:okg,
hence
FP

=
ok
[]
:ok;
but
this
program
is
not
stationary
with
resp
ect
to
FP,
and
so
FP
1
6=
FP

.
In
fact
FP
1
=
(ok
3=5

:ok)
[]
ok,
the
generalised
distribution
in
whic
h
the
probabilit
y
of
ok
is
at
least
3=5.
4
Extended
Mark
o
v
theory
F
rom
(1)
it
is
easy
to
see
that
in
the
general
setting,
an
y
program
t
(if
ex-
ecuted
for
long
enough)
ac
hiev
es
some
notion
of
stationary
b
eha
viour
en-
capsulated
b
y
the
program
t
1
.
But
that
is
not
the
view
tak
en
b
y
classical
Mark
o
v
pro
cess
theory
.
T
o
see
where
the
general
and
the
classical
theo-
ries
div
erge,
consider
the
program
b
:=
1 b,
where
the
v
ariable
b
can
only
tak
e
v
alues
in
f0;
1g.
The
classical
theory
sa
ys
that
this
program
do
es
not
con
v
erge
(b
ecause
it
oscillates
b
et
w
een
b's
t
w
o
v
alues).
On
the
other
hand
(b
:=
1 b)
1
=
(b
:=
1 b)

=
(b
:=
0
[]
b
:=
1),
whic
h
sa
ys
that
the
long
term
stationary
b
eha
viour
is
a
program
that
assigns
to
b
nondeterministically
from
its
t
yp
e.
That
b
eha
viour
is
disqualied
b
y
the
classical
theory
b
ecause
it
is
not
deterministic
and
so
do
es
not
represen
t
a
distribution.
W
e
discuss
the
\observ
ational"
in
tuition
b
ehind
this
solution
in
the
next
section.
F
or
no
w
w
e
end
this
section
b
y
demonstrating
that
our
generalised
notion
195

McIver
of
con
v
ergence
really
sup
ersedes
the
classical
theory
.
W
e
presen
t
a
new
pro
of
of
the
imp
ortan
t
result
ab
out
con
v
ergence
to
a
stationary
distribution
of
\ap
e-
rio
dic"
Mark
o
v
pro
cesses;
the
pro
of
relies
crucially
on
the
abilit
y
to
p
ostulate
the
existence
of
t
1
for
all
Mark
o
v
pro
cesses,
and
not
just
those
p
ermitted
b
y
the
classical
theory
.
Recall
that
a
distribution
is
mo
delled
as
a
deterministic
assignmen
t
whic
h
is
indep
enden
t
of
the
initial
state.
A
transformer
t
whic
h
corresp
onds
to
suc
h
an
assignmen
t
is
additiv
e
and,
for
an
y

,
the
exp
ectation
t:
is
a
constan
t
function.
F
or
example
wp:(ok
2=3

:ok):
returns
the
exp
ected
(nal)
v
alue
of

,
whic
h
is
constan
t
at
2(
:ok
)=3
+

:(:ok
)=3,
whatev
er
the
initial
v
alue.
Hence
in
our
terms
all
w
e
need
do
is
sho
w
that
1
maps
the
ap
erio
dic
deterministic
programs
to
transformers
that
corresp
ond
to
deterministic
as-
signmen
ts.
Ap
erio
dicit
y
is
a
prop
ert
y
of
t
pro
vided
that
all
states
are
ev
en
tually
reac
h-
able
from
all
other
states,
and
the
probabilit
y
of
returning
to
the
original
state
with
a
denite
p
erio
d
is
strictly
less
than
1
[8].
The
rst
prop
ert
y
is
the
same
as
sa
ying
that
t

=
c
haos
,
and
the
second
is
the
same
as
sa
ying
that
t
n
=
t

for
all
n
>
1
|
in
the
case
that
the
equalit
y
fails
for
some
n,
w
e
are
sa
ying
that
t
exhibits
a
p
erio
d
of
n.
The
general
theorem
ab
out
con
v
ergence
of
Mark
o
v
pro
cesses
is
then
as
follo
ws.
Theorem
4.1
If
t
in
T
S
is
deterministic
and
ap
erio
dic
then
t
1
is
a
deter-
ministic
assignment.
Pro
of:
The
c
omment
after
L
em.
2.2
implies
that
t
n
must
b
e
a
c
ontr
action
for
some
n
>
0,
and
henc
e
t
n1
must
b
e
a
deterministic
assignment
(also
by
L
em.
2.2).
The
r
esult
fol
lows
fr
om
Fig.
3
sinc
e
t
n
=
t

.
5
Applications
to
long-term
a
v
erage
b
eha
viour
The
prop
erties
of
systems
that
execute
indenitely
are
usually
in
v
estigated
using
an
adaptation
of
temp
oral
logic
|
in
our
case
pr
ob
abilistic
temp
oral
logic.
F
orm
ulae
are
in
terpreted
o
v
er
trees
of
execution
paths
|
in
our
case
pr
ob
abilistic
distributions
o
v
er
execution
paths
[15
,2].
The
in
terpretation
of
a
t
ypical
form
ula

o
v
er
a
path-distribution
yields
the
prop
ortion
of
paths
satisfying
.
As
de
Alfaro
p
oin
ts
out
[3]
ho
w
ev
er,
this
kind
of
\probabilistic
satisfaction"
refers
to
the
aggregate
path-distribution;
put
another
w
a
y
it
measures
the
c
hance
of
a
single
ev
en
t
o
ccurring
among
paths,
and
ignores
the
frequency
with
whic
h
ev
en
ts
o
ccur
along
paths.
But
this
is
precisely
what
is
called
for
in
availability
or
long-term
a
v
erage
analyses
of
failing
systems.
In
this
section
w
e
sho
w
that
b
oth
are
determined
b
y
t
1
|
ev
en
for
systems
that
include
nondeterminism,
suc
h
as
FP
in
Fig.
1.
W
e
dene
long-term
a
v
erage
b
eha
viour
as
de
Alfaro
[3]
do
es.
Giv
en
a
sequence
seq
of
exp
ectations,
let
seq
i
b
e
the
i'th
elemen
t,
and
dene
the
partial
sum
P
k
seq
=
seq
1
+
seq
2
+
:
:
:
+
seq
k
.
196

McIver
Denition
5.1
Let
t
in
T
S
execute
indenitely
,
and
let

b
e
a
predicate.
The
long-term
a
v
erage
n
um
b
er
of
o
ccurrences
of

observ
ed
to
hold
as
t
executes
is
giv
en
b
y
V
t
:
in
V
t
:
:
=
lim
inf
k
!1
P
k
seq
k
;
where
in
this
case
seq
k
:
=
t

;
t
k
:
.
Def.
5.1
corresp
onds
to
the
a
v
erage
result
after
sampling
the
state
of
the
system
at
arbitrary
in
terv
als
of
time
as
t
executes
rep
eatedly
.
Here
w
e
assume
that
at
the
k
'th
sample
p
oin
t,
the
system
has
executed
at
le
ast
k
times
|
and
in
that
case
the
c
hance
that

holds
at
the
time
of
the
test
is
t

;
t
k
:
.
When
t
corresp
onds
to
a
Mark
o
v
pro
cess
that
con
v
erges
classically
,
that
a
v
erage
is
determined
b
y
the
stationary
distribution.
W
e
ha
v
e
a
corresp
onding
result
here,
but
it
is
v
alid
for
al
l
programs.
Lemma
5.2
L
et
t
b
e
a
pr
o
gr
am
in
H
S
and

an
exp
e
ctation
in
E
S
.
Then
we
have
t
1
:
=
V
P
:
.
T
o
illustrate
the
ab
o
v
e,
recall
the
program
b
:=
1 b,
and
let
[b
=
0]
represen
t
the
exp
ectation
that
ev
aluates
to
1
at
states
where
b
is
0
and
to
0
elsewhere.
T
o
calculate
V
b:=
1 b
:[b
=
0]
w
e
consider
wp:(b
:=
1 b)

;
(b
:=
1 b)
n
:[b
=
0]
=
0
;
hence
V
b:=
1 b
:[b
=
0]
=
0
as
w
ell.
Alternativ
ely
,
(b
:=
1 b)
1
=
(b
:=
0
[]
b
:=
1),
hence
wp
:(b
:=
1 b)
1
:[b
=
0]
=
0
also.
These
results
can
b
e
understo
o
d
op
erationally
in
the
con
text
of
a
tester
who
is
allo
w
ed
to
c
ho
ose
when
to
sample
the
state
of
the
program.
Clearly
if
the
tester
only
observ
es
the
state
after
an
ev
en
n
um
b
er
of
executions
of
b
:=
1 b
then
he
will
deduce
that
b
is
nev
er
0
on
a
v
erage
(or
ev
en
at
all).
The
p
oin
t
ab
out
ap
erio
dic
programs
in
the
classical
theory
is
that
the
a
v
erage
measuremen
t
is
to
an
exten
t
robust
against
suc
h
acciden
tal
testing
bias.
And
the
same
applies
here:
whatev
er
the
prop
osed
testing
regime,
the
prop
ortion
of
time
that
FP
is
ok
will
b
e
found
to
b
e
at
least
3=5,
since
FP
1
=
(ok
3=5

:ok)
[]
ok.
6
Conclusion
Our
main
con
tribution
is
to
extend
the
notion
of
stationary
b
eha
viour
of
Mark
o
v
pro
cesses
to
a
mo
del
that
includes
demonic
nondeterminism,
setting
it
on
a
par
with
other
programming
concepts.
The
main
insigh
t
w
as
to
mo
del
stationary
b
eha
viour
explicitly
as
a
distribution-generating
program
in
T
S
;
that
allo
ws
access
to
the
tec
hniques
of
program
algebra
and
probabilistic
mo
d-
els
[1,13
].
The
generalisation
prop
osed
here
allo
ws
the
completion
of
the
theory
linking
long-term
a
v
erage
b
eha
viour
and
stationary
b
eha
viour
|
b
oth
are
no
w
197

McIver
alw
a
ys
dened,
and
they
determine
eac
h
other.
Moreo
v
er
our
generalisation
pro
vides
a
striking
simplication
to
classical
theory
of
con
v
ergence.
The
op
erator
t

presen
ted
here
is
unable
to
express
man
y
of
the
esp
erimen
ts
oered
b
y
the
m
uc
h
more
elab
orate
framew
ork
due
to
de
Alfaro
[3].
The
main
dierence
is
that
results
are
assigned
to
states
rather
than
transitions.
Nev
ertheless
man
y
useful
p
erformance
measures
are
co
v
ered
b
y
this
simpler
framew
ork.
Examples
include
a
v
erage
w
aiting
times
and
a
v
ailabilit
y
measures.
F
urther
w
ork
is
needed
to
incorp
orate
other
programming
notions
suc
h
as
co
ercions
[12],
whic
h
signican
tly
increase
the
p
o
w
er
of
algebraic
reasoning.
An
imp
ortan
t
consequence
is
that
stationary
b
eha
viour
is
no
w
susceptible
to
other
programming
tec
hniques
suc
h
as
renemen
t
and
data
abstraction
[7].
References
[1]
Ernie
Cohen.
Separation
and
reduction.
In
Mathematics
of
Pr
o
gr
am
Construction,
5th
International
Confer
enc
e,
Portugal,
July
2000,
n
um
b
er
1837
in
LNCS,
pages
45{59.
Springer
V
erlag,
2000.
[2]
L.
de
Alfaro.
T
emp
oral
logics
for
the
sp
ecication
of
p
erformance
and
reliabilit
y
.
Pr
o
c
e
e
dings
of
ST
A
CS
'97,
LNCS
v
olume
1200,
1997.
[3]
L.
de
Alfaro.
Ho
w
to
sp
ecify
and
v
erify
the
long-run
a
v
erage
b
eha
vior
of
parobabilistic
systems.
In
Pr
o
c
e
e
dings
of
'LICS
'98,
23-24
June,
Indianap
olis,
1998.
[4]
C.
Derman.
Finite
State
Markov
De
cision
Pr
o
c
esses.
Academic
Press,
1970.
[5]
E.W.
Dijkstra.
A
Discipline
of
Pr
o
gr
amming.
Pren
tice
Hall
In
ternational,
Englew
o
o
d
Clis,
N.J.,
1976.
[6]
W.
F
eller.
A
n
Intr
o
duction
to
Pr
ob
ability
The
ory
and
its
Applic
ations,
v
olume
1.
Wiley
,
second
edition,
1971.
[7]
P
.
H.
B.
Gardiner
and
C.
C.
Morgan.
Data
renemen
t
of
predicate
transformers.
The
or
etic
al
Computer
Scienc
e,
87:143{162,
1991.
[8]
G.
Grimmett
and
D.
W
elsh.
Pr
ob
ability:
an
Intr
o
duction.
Oxford
Science
Publications,
1986.
[9]
Jifeng
He,
K.
Seidel,
and
A.
K.
McIv
er.
Probabilistic
mo
dels
for
the
guarded
command
language.
Scienc
e
of
Computer
Pr
o
gr
amming,
28(2,3):171{192,
Jan
uary
1997.
[10]
D.
Kozen.
Seman
tics
of
probabilistic
programs.
Journal
of
Computer
and
System
Scienc
es,
22:328{350,
1981.
[11]
D.
Kozen.
A
completeness
theorem
for
Kleene
algebras
and
the
algebra
of
regular
ev
en
ts.
Information
and
Computation,
110:336{390,
1994.
198

McIver
[12]
C.
C.
Morgan.
Pr
o
gr
amming
fr
om
Sp
e
cic
ations.
Pren
tice-Hall,
second
edition,
1994.
[13]
C.
C.
Morgan,
A.
K.
McIv
er,
and
K.
Seidel.
Probabilistic
predicate
transformers.
A
CM
T
r
ansactions
on
Pr
o
gr
amming
L
anguages
and
Systems,
18(3):325{353,
Ma
y
1996.
[14]
C.C.
Morgan.
Priv
ate
comm
unication.
1995.
[15]
R.
Segala.
Mo
deling
and
v
erication
of
randomized
distributed
real-time
systems.
PhD
Thesis,
1995.
[16]
M.
Sharir,
A.
Pn
ueli,
and
S.
Hart.
V
erication
of
probabilistic
programs.
SIAM
Journal
on
Computing,
13(2):292{314,
Ma
y
1984.
[17]
N.
Storey
.
Safety-critic
al
c
omputer
systems.
Addison-W
esley
,
1996.
[18]
M.
V
ardi.
Automatic
v
erication
of
probabilistic
concurren
t
nite-state
systems.
Pr
o
c
e
e
dings
of
26th
IEEE
Symp
osium
on
F
ound.
of
Comp.
Sci.,
pages
327{338,
1985.
199

200

MFPS
17
Preliminary
Version
A
Selectiv
e
CPS
T
ransformation
Lasse
R.
Nielsen
BRICS
1
Dep
artment
of
Computer
Scienc
e,
University
of
A
arhus
Building
540,
Ny
Munke
gade,
DK-8000
A
arhus
C,
Denmark.
E-mail:
lrn@brics.dk
Abstract
The
CPS
transformation
mak
es
all
functions
con
tin
uation-passing,
uniformly
.
Not
all
functions,
ho
w
ev
er,
need
con
tin
uations:
they
only
do
if
their
ev
aluation
includes
computational
eects.
In
this
pap
er
w
e
fo
cus
on
con
trol
op
erations,
in
particular
\call
with
curren
t
con
tin
uation"
and
\thro
w".
W
e
c
haracterize
this
in
v
olv
emen
t
as
a
con
trol
eect
and
w
e
presen
t
a
selectiv
e
CPS
transformation
that
mak
es
functions
con
tin
uation-passing
if
they
ha
v
e
a
con
trol
eect,
and
that
lea
v
es
the
others
in
direct
st
yle.
W
e
formalize
this
selectiv
e
CPS
transformation
with
an
op
erational
seman
tics
and
a
sim
ulation
theorem

a
la
Plotkin.
1
In
tro
duction
This
pap
er
denes,
and
pro
v
es
correct,
a
selectiv
e
Con
tin
uation-P
assing
St
yle
(CPS)
transformation,
i.e.,
one
that
preserv
es
part
of
the
program
in
direct
st
yle.
It
uses
information
ab
out
a
program's
eect-b
eha
vior
to
guide
the
transformation.
The
particular
computational
eect
w
e
use
is
the
con
trol-
transfer
eect
exemplied
b
y
\call
with
curren
t
con
tin
uation"
[3].
1.1
R
elate
d
work
Selectiv
ely
CPS
transforming
a
program
is
not
a
new
idea.
Dan
vy
and
Hatcli
dened
a
selectiv
e
CPS
transformation
based
on
strict-
ness
analysis
[6].
When
dealing
with
the
eect
of
non-termination,
a
strict
function
is
indieren
t
to
the
ev
aluation
order
of
its
argumen
t,
and
as
suc
h
argumen
ts
of
strict
functions
could
b
e
transformed
b
y
a
call-b
y-v
alue
trans-
formation
while
the
rest
of
the
program
w
as
transformed
b
y
a
call-b
y-name
transformation.
The
same
authors
also
in
v
estigated
CPS
transformation
based
1
Basic
Researc
h
in
Computer
Science
(www.brics.dk),
funded
b
y
the
Danish
National
Researc
h
F
oundation.
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Nielsen
on
totalit
y
information,
dening
a
selectiv
e
transformation
[7
].
There
is
no
immediate
generalization
of
strictness
to
other
eects
than
non-termination,
though,
whereas
trivialit
y
(the
absence
of
eects)
generalizes
immediately
to
all
other
computational
eects,
as
w
e
ha
v
e
exemplied
with
con
trol
eects.
Kim,
Yi,
and
Dan
vy
implemen
ted
a
selectiv
e
CPS
transformation
for
the
core
language
of
SML
of
New
Jersey
to
reduce
the
o
v
erhead
of
their
CPS-
transformation
whic
h
-enco
ded
the
exception
eects
of
SML
[15
].
The
im-
plemen
tation
is
v
ery
similar
to
the
presen
t
w
ork,
though
they
treat
exceptions
instead
of
con
trol
op
erations
and
base
the
annotation
on
a
sp
ecic
exception
analysis.
Recen
t
w
ork
has
fo
cused
on
selectiv
e
transformations
for
dieren
t
reasons.
Repp
y
in
tro
duced
a
lo
cal
CPS
transformation
in
an
otherwise
direct-st
yle
compiler
to
impro
v
e
the
e√Üciency
of
nested
lo
ops
[18
].
Kim
and
Yi
dened
co
ercions
b
et
w
een
direct
st
yle
and
CPS
terms
with
no
other
eects
than
non-
termination,
allo
wing
arbitrary
sub
expressions
to
b
e
transformed,
and
facili-
tating
in
terfacing
to
external
co
de
in
b
oth
direct
st
yle
and
CPS.
The
selectiv
e
transformation
w
as
pro
v
en
correct
[14
].
The
presen
t
pap
er
denes
a
selectiv
e
CPS
transformation
for
the
simply
t
yp
ed
-calculus
extended
with
recursiv
e
functions
and
computational
eects,
namely
callcc
and
thr
o
w,
in
to
-calculus
with
only
recursiv
e
functions,
i.e.,
with
only
non-termination
as
an
eect.
The
transformation
is
based
on
an
eect
analysis,
and
it
is
pro
v
en
correct
with
resp
ect
to
the
dynamic
b
eha
vior
of
the
program.
W
e
conjecture
that
the
metho
dology
extends
to
other
t
yp
es
of
eects,
only
diering
in
the
details
of
the
enco
ding
of
eectful
primitiv
es
in
to
-expressions.
1.2
Overview
Section
2
giv
es
the
syn
tax
and
seman
tics
of
a
small,
t
yp
ed
functional
language
with
con
trol
eects,
and
sho
ws
the
traditional
(non-selectiv
e)
CPS
transfor-
mation.
Section
3
extends
the
language
with
eect
annotations
whic
h
are
v
eried
b
y
an
eect
system,
and
denes
the
selectiv
e
CPS
transformation
guided
b
y
these
annotations.
Section
4
pro
v
es
the
correctness
of
the
selectiv
e
CPS
transformation
using
Plotkin-inspired
colon
translations,
and
Section
5
concludes.
2
Denitions
W
e
dene
the
source
and
target
language
of
our
selectiv
e
CPS
transformation,
giving
the
syn
tax
and
t
yp
e
predicates
as
w
ell
as
an
op
erational
seman
tics.
2.1
Syntax
The
source
language
is
a
call-b
y-v
alue
t
yp
ed
functional
language
with
recursiv
e
functions
and
the
canonical
con
trol
op
erators:
callcc
and
thr
o
w.
The
202

Nielsen
syn
tax
is
giv
en
in
Figure
1,
where
x
and
f
range
o
v
er
a
set
of
iden
tiers
and
c
ranges
o
v
er
a
set
of
constan
ts.
e
::=
c
j
x
j
fun
f
x:e
j
e
@
e
j
callcc
x:e
j
thr
o
w
e
e
Fig.
1.
Abstract
syn
tax
of
the
source
language
W
e
iden
tify
expressions
up
to
renaming
of
b
ound
v
ariables,
i.e.,
fun
f
x:x
=
fun
g
y
:y
.
W
e
use
the
shorthand

x:e
for
a
function-abstraction
fun
f
x:e
where
f
do
es
not
o
ccur
in
e
.
W
e
require
expressions
to
b
e
w
ell
t
yp
ed
with
regard
to
the
t
yping
rules
in
Figure
2,
similar
to
those
giv
en
b
y
Harp
er,
Duba,
and
MacQueen
[12].
The
syn
tax
of
t
yp
es
is
giv
en
b
y
the
grammar:

::=
b
j

!

j
h
i
where
b
ranges
o
v
er
a
set
of
base
t
yp
es,
and
h
i
is
the
t
yp
e
of
con
tin
uations
exp
ecting
a
v
alue
of
t
yp
e

.
In
the
rules
ConstType
is
a
mapping
from
constan
ts
to
base
t
yp
es,
giving
the
t
yp
e
of
a
constan
t,
and
 is
a
mapping
from
iden
tiers
to
t
yp
es.
 (x)
=

 `
x
:

ConstType(c
)
=
b
 `
c
:
b
 [x
:

1
][f
:

1
!

2
]
`
e
:

2
 `
fun
f
x:e
:

1
!
2
 `
e
1
:

1
!

2
 `
e
2
:

1
 `
e
1
@
e
2
:

2
 [x
:
h
i]
`
e
:

 `
callcc
x:e
:

 `
e
1
:
h

i
 `
e
2
:

 `
thr
o
w
e
1
e
2
:

2
Fig.
2.
The
t
yping
rules
of
the
source
language.
W
e
dene
a
program
to
b
e
a
closed
expression
of
t
yp
e
b
0
,
an
arbitrary
base
t
yp
e,
and
w
e
only
pro
v
e
the
correctness
of
the
transformation
on
en
tire
programs.
203

Nielsen
2.2
Semantics
The
source
language
has
a
left-to-righ
t
call-b
y-v
alue(CBV)
op
erational
se-
man
tics
giv
en
using
ev
aluation
con
texts.
W
e
in
tro
duce
an
in
termediate
v
alue
to
the
syn
tax
to
represen
t
captured
con
tin
uations,
and
dene
the
v
alues
and
con
texts
recursiv
ely
,
and
giv
e
the
con
text-based
reduction
rules
(Figure
3).
Extended
expressions,
v
alues,
and
ev
aluation
con
texts:
e
::=
:
:
:
j
hE
i
v
::=
c
j
fun
f
x:e
j
hE
i
E
::=
[
]
j
E
@
e
j
v
@
E
j
thr
o
w
E
e
j
thr
o
w
v
E
Reduction
rules:
E
[(fun
f
x:e
)
@
v
]
!
E
[e
[fun
f
x:e
=f
]
[
v
=x]]
E
[
callcc
x:e
]
!
E
[e
[hE
i=x]]
E
[thr
o
w
hE
1
i
v
]
!
E
1
[v
]
Fig.
3.
Seman
tics
of
the
source
language
Notice
that
con
tin
uations
are
represen
ted
as
con
texts,
so
thro
wing
a
con-
tin
uation
amoun
ts
to
reinstating
a
con
text.
This
seman
tics
uses
ev
aluation
con
texts
in
a
w
a
y
similar
to
F
elleisen
[9],
capturing
the
fact
that
for
an
y
expression,
there
is
at
most
one
enabled
re-
duction
at
a
time.
Sub
ject
reduction
(e
:

and
e
!
e
0
implies
e
0
:

)
can
b
e
pro
v
en
b
y
a
completely
standard
pro
of,
whic
h
has
b
een
omitted.
2.3
The
CPS
tr
ansformation
The
CPS
transformation
can
b
e
used
to
transform
a
program
in
the
source
language
in
to
a
program
in
a
similar
language
without
callcc
and
thr
o
w,
while
preserving
the
computational
b
eha
vior
of
the
source
program.
That
is,
the
translated
program,
when
applied
to
an
initial
con
tin
uation,
terminates
if
the
source
program
did,
and
the
result
of
the
transformed
program,
whic
h
is
of
a
base
t
yp
e,
is
the
same
as
that
of
the
original
program.
The
CPS-transformation
has
other
in
teresting
prop
erties:
204

Nielsen

It
generates
programs
that
can
b
e
ev
aluated
under
b
oth
a
call-b
y-name
(CBN)
and
a
CBV
seman
tics
and
yield
the
same
result,
whic
h
corresp
onds
to
the
result
of
the
source
program.
A
n
um
b
er
of
CPS
transformations
exist,
eac
h
corresp
onding
to
an
ev
aluation-order
for
the
source
language
[13].

It
generates
programs
where
all
applications
are
tail-calls,
i.e.,
no
applica-
tion
is
in
an
argumen
t
p
osition.
CPS
transformations
are
used
in
man
y
places,
but
primarily
in
compilers
to
giv
e
an
in
termediate
represen
tation
[1
,21]
and
as
a
w
a
y
to
simplify
the
language
of
a
program
b
efore
applying
other
transformations
or
analyses
to
it
[4].
It
is
the
last
application
that
is
the
motiv
ation
for
the
presen
t
w
ork.
The
standard
CBV
CPS
transformation
is
dened
in
Figure
4.
C
[
[c
]
]
=

k:k
@
C
v
[
[c
]
])
C
[
[x]
]
=

k:k
@
C
v
[
[x]
])
C
[
[fun
f
x:e
]
]
=

k:k
@
C
v
[
[fun
f
x:e
]
])
C
[
[e
1
@
e
2
]
]
=

k:C
[
[e
1
]
]
@

v
:C
[
[e
2
]
]
@

v
0
:v
@
v
0
@
k
C
[
[callcc
x:e
]
]
=

k:
x:C
[
[e
]
]
@
k
@
k
C
[
[thr
o
w
e
1
e
2
]
]
=

k:C
[
[e
1
]
]
@

v
:C
[
[e
2
]
]
@
v
C
v
[
[x]
])
=
x
C
v
[
[c
]
])
=
c
C
v
[
[fun
f
x:e
]
])
=
fun
f
x:C
[
[e
]
]
Fig.
4.
The
CPS
transformation
The
C
v
[
[]
])
function
is
used
to
co
erce
v
alues
and
iden
tiers
in
to
CPS
form,
whic
h
consists
of
transforming
the
b
o
dies
of
function
abstractions.
V
alues
and
iden
tiers
share
the
prop
ert
y
that
Reynolds
called
\b
eing
trivial"
[19
]
and
Moggi
called
\b
eing
a
v
alue"
(as
opp
osed
to
a
computation)
[16],
in
the
sense
that
they
ha
v
e
no
computational
eects,
including
non
termination.
The
C
[
[]
]
function
is
used
on
expressions
with
p
oten
tial
eects,
the
\serious"
expressions.
205

Nielsen
3
The
selectiv
e
CPS
transformation
As
stated
in
the
previous
section,
w
e
treat
trivial
and
serious
expressions
dif-
feren
tly
.
T
rivial
expressions
are
those
that
ha
v
e
no
computational
eects
and
serious
expressions
are
those
that
migh
t
ha
v
e
eects.
The
safe
appro
ximation
used
b
y
the
standard
CPS
transformation
assumes
that
an
y
application
migh
t
ha
v
e
eects,
whic
h
is
not
unreasonable
when
one
considers
non
termination
as
an
eect.
In
the
source
language
w
e
ha
v
e
added
con
trol
eects,
and
it
mak
es
sense
only
to
fo
cus
on
those,
and
let
the
termination
b
eha
vior
b
e
preserv
ed
b
y
only
ev
aluating
the
result
in
a
CBV
seman
tics.
If
w
e
do
that,
w
e
can
use
an
eect
analysis
to
nd
the
parts
of
the
program
that
are
guaran
teed
to
b
e
free
of
the
con
trol
eects
generated
b
y
callcc
and
thr
o
w.
In
the
follo
wing
w
e
will
use
the
w
ords
\trivial"
and
\non-trivial"
ab
out
the
absence
or
p
ossible
presence
of
c
ontr
ol
eects
only
,
while
ignoring
the
partialit
y
eect
of
non-
termination.
That
is,
an
expression
that
has
an
innite
reduction
sequence
can
still
b
e
said
to
b
e
\trivial"
with
regards
to
con
trol
eects.
W
e
are
not
aiming
for
ev
aluation-order
indep
endence,
rather
the
source
and
target
lan-
guages
are
assumed
to
ha
v
e
the
same
ev
aluation-order
(call-b
y-v
alue),
so
the
translation
need
not
tak
e
an
y
measures
to
preserv
e
or
prev
en
t
non-termination
in
otherwise
eect-free
expressions.
This
section
denes
eect-annotated
expressions,
an
eect
t
yp
e
system
to
c
hec
k
the
consistency
of
the
annotation,
and
a
selectiv
e
CPS
transformation
that
k
eeps
trivial
applications
in
direct
st
yle.
3.1
A
nnotate
d
sour
c
e
language
W
e
annotate
a
program
with
annotations
tak
en
from
the
set
fT
;
N
g,
whic
h
is
a
partial
order
with
the
ordering
relation
N
<
T
.
W
e
mark
some
applications
as
trivial,
with
a
T
,
and
some
as
(p
oten
tially)
non-trivial,
with
an
N
.
The
trivial
ones
are
k
ept
in
direct
st
yle,
and
as
suc
h
do
not
exp
ect
to
receiv
e
a
con
tin
uation.
F
or
an
expression,
an
eect
analysis
can
tell
us
one
of
three
things:

Some
ev
aluation
of
the
expression
will
certainly
giv
e
rise
to
eects
(meaning,
in
this
case,
the
reduction
sequence
of
the
expression
con
tains
ev
aluations
of
callcc
or
thr
o
w
expressions),

no
ev
aluation
of
the
expression
will
giv
e
rise
to
eects,
or

w
e
just
don't
kno
w
either
w
a
y
,
whic
h
can
happ
en
since
the
problem
is
generally
undecidable.
The
presen
t
transformation
aims
to
k
eep
the
expressions
in
the
second
case
in
direct
st
yle.
Since
an
y
eectful
expression
must
b
e
put
in
to
CPS,
w
e
m
ust
treat
the
rst
and
third
cases
equally
,
and
they
are
b
oth
mark
ed
N
.
Unifying
these
t
w
o
cases
giv
es
rise
to
the
stated
ordering
where
greater
means
more
206

Nielsen
information
is
kno
wn:
certain
t
y
of
the
absence
of
eects
as
opp
osed
to
only
p
ossible
presence.
A
::=
T
j
N
e
::=
c
j
x
j
fun
A
f
x:e
j
(e
@
A
e
)
A
j
callcc
x:e
j
thr
o
w
e
e
These
are
the
minimal
annotations
needed
for
our
purp
ose.
W
e
treat
v
alues
and
iden
tiers
(the
traditional
trivial
expressions)
as
if
they
w
ere
annotated
as
suc
h,
i.e.,
(e
)
T
is
a
matc
h
for
an
y
trivial
expression,
just
as
(e
)
N
matc
hes
the
t
w
o
con
trol
op
erators.
W
e
require
that
an
expression
annotated
as
trivial
actually
is
so,
i.e.,
when-
ev
er
it
is
ev
aluated,
the
reduction
sequence
con
tains
no
steps
corresp
onding
to
reductions
of
callcc
or
thr
o
w
expressions.
Since
w
e
use
this
annotation
as
a
basis
for
the
selectiv
e
CPS
transformation,
w
e
will
w
an
t
to
CPS
transform
all
expressions
that
are
not
mark
ed
trivial.
W
e
ha
v
e
to
treat
functions
and
applications
with
sp
ecial
care.
When
a
lam
b
da
abstraction
is
applied
at
an
application
p
oin
t,
the
b
o
dy
of
the
abstrac-
tion
is
also
ev
aluated
at
that
p
oin
t.
If
the
b
o
dy
is
not
trivial,
then
neither
is
the
application,
and
after
selectiv
e
CPS
transformation,
the
transformed
application
m
ust
pass
a
con
tin
uation
to
the
transformed
b
o
dy
,
and
the
b
o
dy
should
exp
ect
a
con
tin
uation.
In
a
higher-order
program,
more
than
one
abstraction
can
b
e
applied
at
the
same
application
p
oin
t,
and
after
transformation,
all
of
these
abstractions
m
ust
either
exp
ect
a
con
tin
uation
or
not.
That
means
that
all
functions
that
can
end
up
in
a
giv
en
application
m
ust
b
e
transformed
in
the
same
w
a
y
.
That
divides
the
abstractions
in
to
t
w
o
groups,
those
transformed
in
to
CPS,
i.e.,
exp
ecting
a
con
tin
uation,
and
those
k
ept
in
direct
st
yle,
i.e.,
not
exp
ecting
a
con
tin
uation.
Some
abstractions
with
a
trivial
b
o
dy
migh
t
b
e
transformed
to
exp
ect
a
con
tin
uation
in
order
to
matc
h
the
other
abstractions
that
reac
h
the
same
application
p
oin
ts.
W
e
will
sa
y
that
the
annotation
is
\consisten
t"
(with
regards
to
the
b
e-
ha
vior
of
the
program)
if:

All
expressions
mark
ed
trivial
are
trivial,

all
abstractions
mark
ed
trivial,
or
non-trivial,
are
only
applied
at
application
p
oin
ts
mark
ed
trivial,
or
non-trivial
resp
ectiv
ely
,
and

all
abstractions
whose
b
o
dy
are
mark
ed
non-trivial,
are
themselv
es
mark
ed
as
non-trivial.
T
o
c
hec
k
all
this,
w
e
use
an
extension
of
the
t
yp
e
system
to
an
eect
t
yp
e
system
that
guaran
tees
that
the
annotation
is
consisten
t.
The
t
yp
es
are
also
207

Nielsen
annotated,
so
the
grammar
of
t
yp
es
is:

::=
b
j

A
!

j
h
i
The
eect
system
is
sho
wn
in
Figure
5.
 (x)
=

 `
x
:

;
T
ConstType(c
)
=
b
 `
c
:
b
;
T
 [x
:

1
][f
:
(
1
A
1
!
2
)]
`
e
:

2
;
A
A
1

A
 `
fun
f
x:e
:

1
A
1
!
2
;
T
 `
e
1
:

1
A
3
!
2
;
A
1
 `
e
2
:

1
;
A
2
A

min
(A
1
;
A
2
;
A
3
)
 `
e
1
@
e
2
:

2
;
A
 [x
:
h
i]
`
e
:

;
A
 `
callcc
x:e
:

;
N
 `
e
1
:
h
i
;
A
1
 `
e
2
:

;
A
2
 `
thr
o
w
e
1
e
2
:

2
;
N
Fig.
5.
Eect
t
yp
e
system
If
an
expression
is
t
yp
eable
in
the
original
t
yp
e
system,
then
there
exists
at
least
one
annotation
that
is
t
yp
eable
in
the
eect
system,
namely
the
one
where
all
functions
and
applications
are
mark
ed
non-trivial.
The

in
the
rule
for
function
abstractions
is
exactly
due
to
the
restriction
on
whic
h
functions
that
can
o
w
where.
F
unctions
with
trivial
b
o
dies
can
b
e
annotated
with
an
N
,
allo
wing
them
to
o
w
in
to
an
application
exp
ecting
to
pass
a
con
tin
uation,
but
this
is
reected
in
the
t
yp
e,
whic
h
is
the
only
thing
that
is
kno
wn
at
the
application
p
oin
t.
There
are
t
w
o
dieren
t
annotated
function
t
yp
es,
one
for
eac
h
annotation,
and
only
one
of
these
is
allo
w
ed
at
eac
h
application
p
oin
t.
The

on
the
rule
for
applications
is
discussed
in
the
next
section,
W
e
only
consider
w
ell-annotated
expressions
from
here
on,
i.e.,
expressions
that
are
allo
w
ed
b
y
the
eect
t
yping
rules.
3.2
The
Sele
ctive
CPS
T
r
ansformation
W
e
dene
a
CPS
transformation
that
transforms
w
ell-annotated
expressions
and
lea
v
es
trivial
applications
in
direct
st
yle
(Figure
6).
208

Nielsen
S
[
[e
T
]
]
=
k
@
S
v
[
[e
T
]
]
S
[
[(e
1
@
N
e
2
)
N
]
]
=

k:S
[
[e
1
]
]
@
(
v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k))
S
[
[callcc
x:e
]
]
=

k:(
x:S
[
[e
]
]
@
k)
@
k
S
[
[thr
o
w
e
1
e
2
]
]
=

k:S
[
[e
1
]
]
@
(
v
:S
[
[e
2
]
]
@
v)
S
v
[
[x]
]
=
x
S
v
[
[c
]
]
=
c
S
v
[
[fun
N
f
x:e
]
]
=
fun
f
x:S
[
[e
]
]
S
v
[
[fun
T
f
x:e
]
]
=
fun
f
x:S
v
[
[e
]
]
S
v
[
[e
1
@
T
e
2
]
]
=
S
v
[
[e
1
]
]
@
S
v
[
[e
2
]
]
Fig.
6.
The
selectiv
e
CPS
transformation
3.3
Semantics
of
annotate
d
syntax
W
e
do
not
c
hange
the
seman
tics
of
the
language,
since
the
annotation
is
just
a
mark
on
the
expressions,
and
it
is
only
used
b
y
the
CPS
transformation.
Still,
in
order
to
pro
v
e
the
correctness
of
the
transformation,
w
e
dene
a
reduction
relation
on
annotated
expressions
that
up
dates
the
annotation.
E

((fun
A
1
f
x:(e
)
A
3
)
@
A
2
v
)
A

!
E

(e
)
A
3

fun
A
1
f
x:(e
)
A
3
=f

[v
=x]

E

callcc
x:(e
)
A

!
E

(e
)
A
[hE
i=x]

E
[thr
o
w
hE
0
i
v
]
!
E
0
[v
]
The
p
oin
t
of
this
reduction
relation
is
that
v
alues
and
iden
tiers
are
alw
a
ys
mark
ed
trivial,
and
no
expression
mark
ed
trivial
can
ev
er
reduce
to
one
mark
ed
as
non-trivial.
With
these
reduction
rules,
an
expression
mark
ed
non-trivial
can
reduce
to
one
mark
ed
trivial,
t
ypically
b
y
reducing
it
to
a
v
alue.
If
that
happ
ens
to
one
of
the
sub
expressions
of
an
application,
w
e
can
suddenly
b
e
in
the
situation
where
b
oth
of
the
sub
expressions
are
trivial
as
w
ell
as
the
b
o
dies
of
the
functions
exp
ected
to
b
e
applied
there,
and
the
en
tire
application
could
no
w
b
e
consisten
tly
annotated
as
trivial.
The
w
eak
ening
in
the
eect-t
yping
rule
for
applications
is
there
to
a
v
oid
that
suc
h
a
c
hange
w
ould
mandate
c
hanges
to
annotations
not
lo
cal
to
the
reduction
taking
place.
209

Nielsen
All
these
prop
erties
mak
e
a
pro
of
of
Sub
ject
Reduction
a
trivial
extension
of
the
pro
of
for
the
unannotated
syn
tax.
One
reason
for
ha
ving
b
oth
annotations
and
an
eect
system,
and
not,
e.g.,
only
the
eect
system,
is
for
ease
of
represen
tation.
Ev
en
if
a
reduced
program
allo
ws
a
more
precise
eect-analysis
than
the
original
program,
the
transformation
is
based
on
the
original
program,
and
the
annotation
k
eeps
the
original
annotation
throughout
the
reduction
sequence.
4
Pro
of
of
correctness
T
o
pro
v
e
the
correctness
of
the
transformation,
w
e
m
ust
rst
sp
ecify
a
notion
of
correctness.
In
this
case
w
e
require
that
the
transformed
program
reduces
to
the
same
result
as
the
original
program.
Theorem
4.1
(Correctness
of
the
Selectiv
e
CPS
T
ransformation)
If
e
is
a
close
d
and
wel
l-annotate
d
expr
ession
of
typ
e
b
0
then
e
!

v
,
S
[
[e
]
]
@
(
x:x)
!

v
In
Plotkin's
original
pro
of,
the
result
of
the
transformed
program
w
ould
b
e
S
v
[
[v
]
],
but
since
the
program
has
a
t
yp
e
where
the
only
v
alues
are
constan
ts,
and
all
constan
ts
satisfy
S
v
[
[c
]
]
=
c
,
w
e
can
state
the
theorem
as
ab
o
v
e.
4.1
The
sele
ctive
c
olon-tr
anslations
The
pro
of
uses
a
metho
d
similar
to
Plotkin's
in
his
original
pro
of
of
the
correct-
ness
of
the
CPS
transformation
[17].
It
uses
a
so-called
\colon-translation"
to
b
ypass
the
initial
administrativ
e
reductions
and
fo
cus
on
the
ev
aluation
p
oin
t.
The
in
tuition
that
driv
es
the
normal
CPS
transformation
is
that
if
e
re-
duces
to
v
then
(C
[
[e
]
]
@
k
)
should
ev
aluate
to
(k
@
C
v
[
[v
]
])).
Plotkin
captured
this
in
his
colon
translation
where
if
e
!
e
0
then
e
:
k
!

e
0
:
k,
and
at
the
end
of
the
deriv
ation,
v
alues
satised
v
:
k
=
k
@
	(v
),
where
	()
is
what
w
e
write
S
v
[
[
]
].
The
idea
of
the
colon
translation
is
that
in
e
:
k
,
the
k
represen
ts
the
c
ontext
of
e
,
whic
h
in
the
transformed
program
has
b
een
collected
in
a
con
tin-
uation:
a
function
exp
ecting
the
result
of
ev
aluating
e
.
The
colon
separates
the
source
program
to
the
left
and
the
transformed
program
to
the
righ
t
of
it.
In
the
selectiv
e
CPS
transform,
some
con
texts
are
not
turned
in
to
con
tin
ua-
tions,
namely
the
con
texts
of
expressions
mark
ed
trivial,
since
suc
h
expressions
are
not
transformed
to
CPS
expressions,
and
as
suc
h
do
es
not
exp
ect
a
con-
tin
uation.
Therefore
w
e
ha
v
e
t
w
o
colon
translations,
one
for
non-trivial
expressions,
with
a
con
tin
uation
function
after
the
colon,
and
one
for
trivial
expressions
with
an
ev
aluation
con
text
after
the
colon.
The
denition
is
sho
wn
in
Figure
7.
In
b
oth
cases,
what
is
to
the
left
of
the
colon
is
a
piece
of
source
syn
tax,
and
210

Nielsen
what
is
to
the
righ
t
is
a
represen
tation
of
the
con
text
of
that
expression
in
the
source
program
translated
to
the
target
language.
If
the
expression
is
trivial,
the
source
con
text
is
represen
ted
b
y
a
con
text
in
the
target
language,
and
the
translation
of
the
expression
is
put
in
to
this
con
text.
If
the
expression
is
not
trivial,
then
the
source
con
text
is
represen
ted
b
y
a
con
tin
uation
function
whic
h
is
passed
to
the
translation
of
the
expression.
e
T
:
k
=
e
T
:
[k
@
[
]
]
(e
1
@
N
e
2
)
N
:
k
=
e
1
:

v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
)
if
e
1
is
not
a
v
alue
(v
1
@
N
e
2
)
N
:
k
=
e
2
:

v
0
:S
v
[
[v
1
]
]
@
v
0
@
k
if
e
2
is
not
a
v
alue
(v
1
@
N
v
2
)
N
:
k
=
S
v
[
[v
1
]
]
@
S
v
[
[v
2
]
]
@
k
(e
1
@
T
e
2
)
N
:
k
=
e
1
:

v
:S
[
[e
2
]
]
@
(
v
0
:k
@
(v
@
v
0
))
if
e
1
is
not
a
v
alue
(v
1
@
T
e
2
)
N
:
k
=
e
2
:

v
0
:k
@
(S
v
[
[v
1
]
]
@
v
0
)
if
e
2
is
not
a
v
alue
(v
1
@
T
v
2
)
N
:
k
=
k
@
(S
v
[
[v
1
]
]
@
S
v
[
[v
2
]
])
callcc
x:e
:
k
=
(
x:S
[
[e
]
]
@
k
)
@
k
thr
o
w
e
1
e
2
:
k
=
e
1
:

v
:S
[
[e
2
]
]
@
v
if
e
1
is
not
a
v
alue
thr
o
w
v
1
e
2
:
k
=
e
2
:
S
v
[
[v
1
]
]
if
e
2
is
not
a
v
alue
thr
o
w
v
1
v
2
:
k
=
S
v
[
[v
1
]
]
@
S
v
[
[v
2
]
]
x
:
E
=
E
[x]
c
:
E
=
E
[c
]
fun
N
f
x:e
:
E
=
E
[fun
f
x:S
[
[e
]
]]
fun
T
f
x:e
:
E
=
E
[fun
f
x:S
v
[
[e
]
]]
(e
1
@
T
e
2
)
T
:
E
=
e
1
:
E

([
]
@
T
S
v
[
[e
2
]
])
T

if
e
1
is
not
a
v
alue
(v
1
@
T
e
2
)
T
:
E
=
e
2
:
E

(S
v
[
[v
1
]
]
@
T
[
])
T

if
e
2
is
not
a
v
alue
(v
1
@
T
v
2
)
T
:
E
=
E

(S
v
[
[v
1
]
]
@
T
S
v
[
[v
2
]
])
T

Fig.
7.
The
selectiv
e
colon
translation
on
expressions
In
Plotkin's
colon
translation,
v
:
k
=
k
@
(v
).
This
also
holds
for
this
colon
translation
pair,
since
v
:
k
=
v
:
[k
@
[
]],
since
v
is
trivial,
and
v
:
[k
@
[
]]
=
k
@
v
b
y
the
denition
of
the
e
:
E
-translation.
211

Nielsen
The
e
:
E
-translation
is
not
as
signican
t
as
the
e
:
k
-translation,
since
all
it
do
es
is
apply
the
	-function
to
the
argumen
t,
i.e.,
if
e
is
a
trivial
expression
then
e
:
E
=
E
[S
v
[
[e
]
]].
There
are
no
administrativ
e
reductions
to
b
ypass
in
direct
st
yle.
W
e
plan
to
use
the
colon
translations
on
the
result
of
reducing
on
the
annotated
expressions,
so
w
e
extend
it
to
w
ork
on
con
tin
uation
v
alues,
hE
i,
whic
h
are
v
alues
and
as
suc
h
trivial.
hE
0
i
:
E
=
E
[E
0
:
id
]
where
id
=

x:x
and
E
:
k
denes
either
a
con
tin
uation
function
or
a
con
text
as
displa
y
ed
in
Figure
8,
where
E
T
represen
ts
an
y
non-empt
y
con
text
with
a
top-most
annotation
as
trivial.
[
]
:
k
=
k
E
T
:
k
=
E
T
:
[k
@
[
]]
(E
@
N
e
2
)
N
:
k
=
E
:

v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
)
(E
@
T
e
2
)
N
:
k
=
E
:

v
:S
[
[e
2
]
]
@
(
v
0
:k
@
(v
@
v
0
))
(v
1
@
N
E
)
N
:
k
=
E
:
(
v
0
:S
v
[
[v
1
]
]
@
v
0
@
k
)
(v
1
@
T
E
)
N
:
k
=
E
:
(
v
0
:k
@
(S
v
[
[v
1
]
]
@
v
0
))
thr
o
w
E
e
2
:
k
=
E
:

v
:S
[
[e
2
]
]
@
v
thr
o
w
v
1
E
:
k
=
E
:
S
v
[
[v
1
]
]
[
]
:
E
=
E
(E
@
T
e
2
)
T
:
E
0
=
E
:
E
0
[[
]
@
S
v
[
[e
2
]
]]
(v
1
@
T
E
)
T
:
E
0
=
E
:
E
0
[S
v
[
[v
1
]
]
@
[
]]
Fig.
8.
The
selectiv
e
colon
translation
on
con
texts.
The
E
:
k
-translation
yields
either
con
tin
uation
functions
or
con
texts,
de-
p
ending
on
the
annotation
of
the
innermost
lev
els
of
the
con
text
argumen
t,
and
the
E
:
E
-translation
alw
a
ys
giv
es
a
con
text,
but
requires
that
the
rst
argumen
t's
outermost
annotation
is
trivial.
These
colon-translations
satisfy
a
n
um
b
er
of
corresp
ondences.
Prop
osition
4.2
F
or
al
l
c
ontexts
E
1
,
E
2
,
and
E
3
,
and
c
ontinuation
functions
212

Nielsen
(close
d
functional
values)
the
fol
lowing
e
qualities
hold.
E
1
[E
2
[
]]
:
k
=
E
2
:
(E
1
:
k
)
E
1
[E
2
[
]]
:
E
3
=
E
2
:
(E
1
:
E
3
)
Pro
of.
The
pro
of
is
b
y
simple
induction
on
the
con
text
E
1
.

If
E
1
=
[
]
then
(E
1
[E
2
[
]]
:
k
)
=
(E
2
:
k
)
=
(E
2
:
(E
1
:
k
))
and
(E
1
[E
2
[
]]
:
E
3
)
=
(E
2
:
E
3
)
=
(E
2
:
(E
1
:
E
3
)).

If
E
1
=

(E
@
N
e
2
)
N

then
E
1
[E
2
[
]]
:
k
=
(E
[E
2
]
@
N
e
2
)
N
:
k
=
E
[E
2
]
:

v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
)
(def.
of
E
:
k
)
=
E
2
:
(E
:

v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
))
(I.H.)
=
E
2
:
(

(E
@
N
e
2
)
N

:
k
)
(def.
E
:
k
)

The
remaining
cases
are
similar.
2
One
w
ould
exp
ect
that
similar
equalities
hold
for
the
colon
translations
on
expressions,
i.e.,
E
[e
]
:
k
=
e
:
(E
:
k
)
and
E
[e
]
:
E
0
=
e
:
(E
:
E
0
),
and
indeed
these
equalities
hold
in
most
cases.
The
exception
is
when
E
is
non-
empt
y
and
the
\innermost"
expression
of
the
con
text
is
not
annotated
as
trivial,
e.g.,
E
1

([
]
@
e
1
)
N

for
some
con
text
E
1
and
expression
e
1
,
and
e
is
a
v
alue.
Normally
the
e
:
k
translation
descends
the
left-hand
side
and
rebuilds
the
con
text
on
the
righ
t
hand
side,
either
as
a
con
tin
uation
function
or
as
a
con
text,
dep
ending
on
the
annotation.
The
exception
men
tioned,
E
[
e
]
:
k
,
the
fo
cus
of
the
colon
translation,
the
expression
on
the
left
hand
side
of
the
colon,
w
ould
nev
er
descend
all
the
w
a
y
do
wn
to
a
v
alue.
W
e
ha
v
e
made
sp
ecial
cases
for
v
@
e
to
b
ypass
administrativ
e
reductions,
so
E
[v
]
:
k
w
ould
not
equal
v
:
(E
:
k
),
b
ecause
the
latter
in
tro
duces
an
administrativ
e
reduction.
Reducing
that
administrativ
e
reduction,
applying
k
to
S
v
[
[v
]
],
do
es
lead
to
v
:
(E
:
k
)
again
in
one
or
more
reduction
steps.
That
is,
if
e
is
a
v
alue
and
E
is
not
a
trivial
con
text
then
e
:
(E
:
k
)
=
(E
:
k
)
@
S
v
[
[e
]
]
!

E
[e
]
:
k
,
and
lik
ewise
for
the
e
:
E
-relation.
Prop
osition
4.3
F
or
al
l
c
ontexts
E
and
E
0
,
expr
essions
e
,
and
c
ontinuation
functions
k
e
:
(E
:
k
)
!

E
[e
]
:
k
e
:
(E
:
E
0
)
!

E
[e
]
:
E
0
(if
e
trivial
)
and
!

is
!
0
,
i.e.,
e
quality,
if
e
is
not
a
value.
213

Nielsen
Pro
of.
Omitted.
2
4.2
Colon-tr
anslation
lemmas
Plotkin
used
four
lemmas
to
pro
v
e
his
sim
ulation
and
indierence
theorems.
W
e
only
pro
v
e
sim
ulation,
whic
h
corresp
onds
to
Plotkin's
sim
ulation,
since
w
e
already
kno
w
that
indierence
do
es
not
hold
for
a
selectiv
e
CPS
transforma-
tion
(at
least
unless
the
selectivit
y
is
based
on
the
eect
of
non
termination
as
w
ell).
Lemma
4.4
(Substitution)
If
 [x
:

1
]
`
e
:

2
;
A
and
`
v
:

1
;
T
is
a
close
d
value
then
S
[
[e
]
]
[S
v
[
[v
]
]=x]
=
S
[
[e
[v
=x]]
]
S
v
[
[e
]
]
[S
v
[
[v
]
]=x]
=
S
v
[
[e
[
v
=x]]
]
(if
e
is
trivial)
Pro
of.
The
pro
of
is
b
y
induction
on
the
structure
of
e
,
using
the
distributiv
e
prop
erties
of
substitution
and
taking
the
trivial
cases
b
efore
the
non-trivial
ones
(b
ecause
the
S
[
[]
]
translation
defers
trivial
sub
expressions
to
the
	
trans-
formation).
The
details
ha
v
e
b
een
omitted.
2
Lemma
4.5
(Initial
reduction)
If
 `
e
:

;
A
and
k
is
a
c
ontinuation
function
of
appr
opriate
typ
e
then
S
[
[e
]
]
@
k
!

e
:
k
E
[S
v
[
[e
]
]]
=
e
:
E
(if
e
is
trivial)
Pro
of.
Again,
the
pro
of
is
b
y
induction
on
the
structure
of
e
with
the
S
[
[]
]
case
tak
en
after
the
	
case
for
trivial
expressions.
The
E
[S
v
[
[
]
]]
=

:
E
case:
There
are
four
cases
co
v
ering
all
trivial
expressions:

If
e
is
a
v
alue
or
an
iden
tier
then
e
:
E
=
E
[S
v
[
[e
]
]]
b
y
denition
of
e
:
E
.

If
e
=
(e
1
@
T
e
2
)
T
(e
1
not
a
v
alue)
then
(e
1
@
T
e
2
)
T
:
E
=
e
1
:
E
[[
]
@
S
v
[
[e
2
]
]]
(def.
e
:
E
)
=
E
[
S
v
[
[e
1
]
]
@
S
v
[
[e
2
]
]]
(I.H.)
=
E

S
v
[
[(e
1
@
T
e
2
)
T
]
]

(def.
	)

If
e
=
(v
1
@
T
e
2
)
T
(e
2
not
a
v
alue)
then
(v
1
@
T
e
2
)
T
:
E
=
e
2
:
E
[S
v
[
[v
1
]
]
@
[
]
]
(def.
e
:
E
)
=
E
[
S
v
[
[v
1
]
]
@
S
v
[
[e
2
]
]]
(I.H.)
=
E

S
v
[
[(v
1
@
T
e
2
)
T
]
]

(def.
	)
214

Nielsen

If
e
=
(v
1
@
T
v
2
)
T
then
(v
1
@
T
v
2
)
T
:
E
=
E
[S
v
[
[v
1
]
]
@
S
v
[
[v
2
]
]]
(I.H.)
=
E

S
v
[
[(v
1
@
T
v
2
)
T
]
]

(def.
	)
This
accoun
ts
for
all
trivial
expressions.
The
S
[
[
]
]
@
k
!


:
k
case:
There
is
one
sub-case
for
eac
h
non-trivial
expres-
sion,
and
one
case
for
all
trivial
expressions:

If
e
is
trivial
then
S
[
[e
]
]
@
k
=
k
@
S
v
[
[e
]
]
=
e
:
[k
@
[
]]
=
e
:
k
from
the
ab
o
v
e
cases
and
the
denition
of
e
:
k
.

If
e
=
(e
1
@
N
e
2
)
N
(e
1
not
a
v
alue)
then
S
[
[(e
1
@
N
e
2
)
N
]
]
@
k
!
S
[
[e
1
]
]
@
(
v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
))
(def.
S
[
[]
])
!

e
1
:
(
v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
))
(I.H.)
=
(e
1
@
N
e
2
)
N
:
k
(def.
e
:
k
)

If
e
=
(v
1
@
N
e
2
)
N
(e
2
not
a
v
alue)
then
S
[
[(v
1
@
N
e
2
)
N
]
]
@
k
!
S
[
[v
1
]
]
@
(
v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
))
(def.
S
[
[
]
])
!
(
v
:S
[
[e
2
]
]
@
(
v
0
:v
@
v
0
@
k
))
@
S
v
[
[v
1
]
]
(def.
S
[
[v
]
])
!
S
[
[e
2
]
]
@
(
v
0
:S
v
[
[v
1
]
]
@
v
0
@
k
)
!

e
2
:

v
0
:S
v
[
[v
1
]
]
@
v
0
@
k
(I.H.)
=
(v
1
@
N
e
2
)
N
:
k
(def.
e
:
k
)

If
e
=
(v
1
@
N
v
2
)
N
then
the
pro
of
is
similar
to
the
previous
case
except
t
w
o
v
alues
need
to
b
e
applied
to
con
tin
uations
instead
of
just
one.

If
e
=
(e
1
@
T
e
2
)
N
then
the
pro
ofs
are
similar
to
the
ones
for
e
=
(e
1
@
T
e
2
)
N
except
that
the
innermost
application
is
k
@
(v
@
v
0
)
in-
stead
of
(v
@
v
0
)
@
k
.

If
e
=
callcc
x:e
1
then
S
[
[callcc
x:e
1
]
]
@
k
!
(
x:S
[
[e
1
]
]
@
k
)
@
k
=
callcc
x:e
1
:
k
.

If
e
=
thr
o
w
e
1
e
2
the
pro
ofs
are
similar
to
the
ones
for
application.
2
Lemma
4.6
(Sim
ulation)
If
E
[e
]
!
E
0
[e
0
]
is
one
of
the
r
e
duction
rules
for
the
annotate
d
language,
then
E
[
e
]
:
id
!

E
0
[e
0
]
:
id
215

Nielsen
and
if
the
r
e
duction
is
not
of
a
thr
o
w
expr
ession,
then
the
!

is
actual
ly
one
or
mor
e
steps.
Pro
of.
Coun
ting
annotations,
there
are
v
e
cases:

If
e
=
(fun
N
f
x:e
1
@
N
v
)
N
then
E

(fun
N
f
x:e
1
@
N
v
)
N

:
id
=
(fun
N
f
x:e
1
@
N
v
)
N
:
(E
:
id
)
(Prop.
4.3)
=
S
v
[
[fun
N
f
x:e
1
]
]
@
S
v
[
[v
]
]
@
(E
:
id
)
(def.
e
:
k
)
=
fun
f
x:S
[
[e
1
]
]
@
S
v
[
[v
]
]
@
(E
:
id
)
(def.
	)
!
S
[
[e
1
]
]

S
v
[
[fun
N
f
x:e
1
]
]=f

[S
v
[
[v
]
]=x]
@
(E
:
id
)
=
S
[
[e
1

fun
N
f
x:e
1
=f

[v
=x]
]
]
@
(E
:
id
)
(Lemma
4.4
)
!

e
1

fun
N
f
x:e
1
=f

[v
=x]
:
(E
:
id)
(Lemma
4.5
)
!

E

e
1

fun
N
f
x:e
1
=f

[v
=x]

:
id
(Prop.
4.3)

If
e
=
(fun
T
f
x:e
1
@
T
v
)
N
then
w
e
kno
w
that
e
1
is
trivial,
since
otherwise
the
function
w
ould
b
e
annotated
N
,
and
E
:
k
is
a
con
tin
uation
since
E
has
no
trivial
inner
sub-con
texts.
E

(fun
T
f
x:e
1
@
T
v
)
N

:
id
=
(fun
T
f
x:e
1
@
T
v
)
N
:
(E
:
id
)
(Prop.
4.3
)
=
(E
:
id
)
@
(S
v
[
[fun
T
f
x:e
1
]
]
@
S
v
[
[v
]
])
(def.
e
:
k
)
=
(E
:
id
)
@
(fun
f
x:S
v
[
[e
1
]
]
@
S
v
[
[v
]
])
(def.
	)
!
(E
:
id
)
@
S
v
[
[e
1
]
]

S
v
[
[fun
T
f
x:e
1
]
]=f

[S
v
[
[v
]
]
=x]
=
(E
:
id
)
@
S
v
[
[e
1

fun
T
f
x:e
1
=f

[v
=x]]
]
(Lemma
4.4)
!

e
1

fun
T
f
x:e
1
=f

[v
=x]
:
[(E
:
id
)
@
[
]]
(Lemma
4.5,
e
1
trivial
)
=
e
1

fun
T
f
x:e
1
=f

[v
=x]
:
(E
:
id
)
(def.
e
:
k
)
!

E

e
1

fun
N
f
x:e
1
=f

[v
=x]

:
id
(Prop.
4.3
)

If
e
=
(e
1
@
T
e
2
)
T
then
either
E
:
k
is
a
con
text
or
a
con
tin
uation.
If
it
is
a
con
tin
uation
the
pro
of
pro
ceeds
just
as
the
previous
case.
If
it
is
a
con
text
216

Nielsen
then
E

(fun
T
f
x:e
1
@
T
v
)
T

:
id
=
(fun
T
f
x:e
1
@
T
v
)
T
:
(E
:
id)
(Prop.
4.3)
=
(E
:
id
)

S
v
[
[fun
T
f
x:e
1
]
]
@
S
v
[
[v
]
]

(def.
e
:
k
)
=
(E
:
id
)
[fun
f
x:S
v
[
[e
1
]
]
@
S
v
[
[v
]
]]
(def.
	)
!
(E
:
id
)

S
v
[
[e
1
]
]

S
v
[
[fun
T
f
x:e
1
]
]=f

[S
v
[
[v
]
]=x]

=
(E
:
id
)

S
v
[
[e
1

fun
T
f
x:e
1
=f

[v
=x]]
]

(Lemma
4.4
)
!

e
1

fun
T
f
x:e
1
=f

[v
=x]
:
(E
:
id
)
(Lemma
4.5,
e
1
trivial
)
!

E

e
1

fun
N
f
x:e
1
=f

[v
=x]

:
id
(Prop.
4.3)

If
e
=
callcc
x:e
1
then
E
[callcc
x:e
1
]
:
id
=
callcc
x:e
1
:
(E
:
id
)
(Prop.
4.3)
=
(
x:S
[
[e
1
]
]
@
(E
:
id
))
@
(E
:
id
)
(def.
e
:
k
)
!
S
[
[e
1
]
]
@
(E
:
id
)
[(E
:
id
)=x]
=
S
[
[e
1
]
]
[
(E
:
id)=x]
@
(E
:
id
)
(E
:
k
is
closed)
=
S
[
[e
1
]
]
[
S
v
[
[h
E
i]
]=x]
@
(E
:
id
)
(def.
S
v
[
[hE
i
]
])
=
S
[
[e
1
[hE
i
=x]
]
]
@
(E
:
id
)
(Lemma
4.4
)
!

e
1
[h
E
i=x]
:
(E
:
id)
(Lemma
4.5
)
!

E
[e
1
[h
E
i=x]]
:
id
(Prop.
4.3)

If
e
=
thr
o
w
hE
0
i
v
then
E
[thr
o
w
hE
0
i
v
]
:
id
=
S
v
[
[hE
0
i]
]
@
S
v
[
[v
]
]
(def.
e
:
k
)
=
(E
0
:
id
)
@
S
v
[
[v
]
]
(def.
S
v
[
[hE
i]
])
=
v
:
[(
@
E
0
:
id
)[
]]
(def.
v
:
E
)
=
v
:
(E
0
:
id)
(def.
(e
)
T
:
k
)
!

E
0
[v
]
:
id
(Prop.
4.3
)
In
all
cases
except
thr
o
w,
there
is
at
least
one
reduction
step.
2
217

Nielsen
4.3
Pr
o
of
of
c
orr
e
ctness
T
o
pro
v
e
the
correctness
of
the
selectiv
e
CPS
transformation,
w
e
use
the
sim-
ulation
lemma
in
t
w
o
w
a
ys.
Pro
of.
The
pro
of
of
e
!

c
=
)
S
[
[e
]
]
@
id
!

c
follo
ws
directly
from
the
lemma
4.5
and
rep
eated
use
of
lemma
4.6.
Assume
e
!

c
.
S
[
[e
]
]
@
id
!

e
:
id
(Lemma
4.5)
!

c
:
id
(Lemma
4.6,
rep
eated
)
=
c
:
[id
@
[
]]
(def.
(e
)
T
:
k
)
=
id
@
c
(def.
c
:
E
)
!
c
.
The
other
direction
of
correctness,
S
[
[e
]
]
@
id
!

c
=
)
e
!

c
,
is
sho
wn
b
y
con
trap
osition.
Assuming
that
for
no
c
do
es
e
!

c
,
that
is,
e
div
erges,
allo
ws
us
to
sho
w
that
the
same
holds
for
S
[
[e
]
].
The
pro
of
that
transformation
preserv
es
div
ergence
also
follo
w
from
Lem-
mas
4.5
and
4.6.
Since
S
[
[e
]
]
@
id
!

e
:
id
it
su√Üces
to
sho
w
that
e
:
id
has
an
arbitrary
long
reduction
sequence.
Assume
that
e
div
erges.
W
e
sho
w
that
for
an
y
n
there
exists
an
m
suc
h
that
if
e
!
m
e
1
then
(e
:
id)
!

(e
1
:
id
)
in
n
or
more
reduction
steps.
This
is
pro
v
en
b
y
induction
on
n.
The
base
case
(n
=
0)
is
trivial.
F
or
the
induction
case
(n
+
1)
lo
ok
at
the
n
case.
There
exists
m
suc
h
that
e
!
m
e
1
and
e
:
id
!

e
1
:
id
.
Lo
ok
at
the
reduction
sequence
from
e
1
.

If
the
rst
reduction
step
(e
1
!
e
2
)
is
not
the
reduction
of
a
thr
o
w
ex-
pression,
then
e
1
:
id
!
+
e
2
:
id,
and
m
+
1
giv
es
us
our
n
+
1
or
longer
reduction
sequence
of
e
:
id.

If
the
rst
reduction
step
(e
1
!
e
2
)
is
of
a
thr
o
w
expression,
then
e
1
:
id
!

e
2
:
id
.
In
that
case
w
e
lo
ok
at
the
next
step
in
the
same
w
a
y
.
Either
w
e
nd
a
reduction
that
is
not
a
thr
o
w,
and
w
e
get
the
m
needed
for
the
pro
of,
or
there
is
nothing
but
reductions
of
thr
o
w
expressions
in
the
innite
reduction
sequence
of
e
1
.
There
can
not
b
e
an
innite
sequence
of
reductions
of
thr
o
w
expressions,
since
reducing
a
thr
o
w
expression
necessarily
reduces
the
size
of
the
en
tire
program.
A
substitution
in
to
a
con
text
corresp
onds
to
the
application
of
a
linear
function,
and
it
reduces
the
size
of
the
expression
if
one
coun
ts
it
as,
e.g.,
n
um
b
er
of
distinct
sub
expressions
or
n
um
b
er
of
thr
o
w
-expressions.
That
means
that
e
:
id
has
an
innite
reduction
sequence.
2
218

Nielsen
5
Conclusion
W
e
ha
v
e
pro
v
en
the
correctness
of
a
selectiv
e
CPS
transformation
based
on
an
eect
analysis.
Similar
pro
ofs
can
b
e
made
for
other
-enco
dings
and
compu-
tational
eects
(e.g.,
with
monads),
where
the
immediate
c
hoice
w
ould
b
e
the
eect
of
non-termination.
That
is
the
eect
that
is
enco
ded
b
y
the
traditional
CPS
transformation
of
languages
with
no
other
eects,
and
if
one
has
an
an-
notation
of
suc
h
a
program,
marking
terminating
(eect-free)
expressions
to
k
eep
in
direct
st
yle,
then
the
metho
d
w
orks
just
as
w
ell.
5.1
Persp
e
ctives
Dan
vy
and
Hatcli
's
CPS
transformation
after
strictness
analysis
[6]
general-
izes
the
call-b
y-name
and
the
call-b
y-v
alue
CPS
transformations.
The
same
authors'
CPS
transformation
after
totalit
y
analysis
[7
]
generalizes
the
call-
b
y-name
CPS
transformation
and
the
iden
tit
y
transformation.
In
the
same
manner,
the
presen
t
w
ork
generalizes
the
call-b
y-v
alue
CPS
transformation
and
the
iden
tit
y
transformation,
and
pro
v
es
this
generalization
correct.
Dan
vy
and
Filinski
in
tro
duced
the
one-pass
CPS-transformation
[5]
that
remo
v
es
the
administrativ
e
reductions
from
the
result
b
y
p
erforming
them
at
transformation
time.
This
optimization
can
b
e
applied
to
the
selectiv
e
CPS-transformation
presen
ted
here
as
w
ell.
A
pro
of
of
the
correctness
of
the
one-pass
CPS-transformation
also
using
Plotkin's
colon
translation
exists
[8].
W
e
exp
ect
that
the
metho
ds
used
for
pro
ving
correctness
of
the
selectiv
e-
and
the
one-pass
CPS
transformations
are
orthogonal,
and
can
easily
b
e
com
bined.
The
selectiv
e
CPS
transformation
presen
ted
here
is
based
on
an
eect
analysis
and
should
generalize
to
other
computational
eects
than
con
trol,
e.g.,
state
or
I/O.
The
pro
of
will
not
carry
o
v
er
to
other
eects,
since
it
relies
on
the
c
hoice
of
-enco
ding
of
the
eect
primitiv
es,
but
w
e
exp
ect
that
the
structure
of
the
pro
of
can
b
e
preserv
ed.
The
approac
h
tak
en
is
\Curry-st
yle"
in
the
sense
that
w
e
ha
v
e
giv
en
a
lan-
guage
and
its
op
erational
meaning,
and
only
after
the
fact
w
e
ha
v
e
asso
ciated
t
yp
es
and
eect
annotation
to
the
un
t
yp
ed
terms.
A
\Ch
urc
h-st
yle"
approac
h,
suc
h
as
Filinski's
[10
,11],
w
ould
ha
v
e
dened
the
language
with
explicit
t
yp
es
and
eect
annotation,
so
that
only
w
ell-t
yp
ed,
consisten
tly
annotated
pro-
grams
are
giv
en
a
seman
tics.
5.2
F
utur
e
work
It
is
p
ossible
to
pro
v
e
results
similar
to
the
presen
t
ones
for
other
c
hoices
of
eects
and
com
binations
of
eects.
A
sensible
c
hoice
w
ould
b
e
a
monadic
eect
of
state
and
con
trol,
since
it
is
su√Ücien
t
to
implemen
t
all
other
c
hoices
of
la
y
ered
monads
[11].
A
pro
of
similar
to
the
presen
t
one
for
b
oth
state
and
con
trol
eects
w
ould
b
e
a
logical
next
step.
219

Nielsen
Ac
kno
wledgmen
ts:
The
metho
d
of
extending
the
colon
translation
to
selectiv
e
CPS
transformation
w
as
originally
dev
elop
ed
in
co
op
eration
with
Junk-taek
Kim
and
Kw
angk
eun
Yi
from
KAIST
in
Korea,
and
with
Olivier
Dan
vy
from
BRICS
in
Denmark.
The
presen
t
w
ork
w
ould
not
ha
v
e
b
een
p
ossible
without
their
inspiration.
Thanks
are
also
due
to
Andrzej
Filinski
and
to
the
anon
ymous
referees
for
their
commen
ts.
References
[1]
Andrew
W.
App
el.
Compiling
with
Continuations.
Cam
bridge
Univ
ersit
y
Press,
New
Y
ork,
1992.
[2]
Hans-J.
Bo
ehm,
editor.
Pr
o
c
e
e
dings
of
the
Twenty-First
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
P
ortland,
Oregon,
Jan
uary
1994.
A
CM
Press.
[3]
William
Clinger,
Daniel
P
.
F
riedman,
and
Mitc
hell
W
and.
A
sc
heme
for
a
higher-lev
el
seman
tic
algebra.
In
John
Reynolds
and
Maurice
Niv
at,
editors,
A
lgebr
aic
Metho
ds
in
Semantics,
pages
237{250.
Cam
bridge
Univ
ersit
y
Press,
1985.
[4]
Daniel
Damian
and
Olivier
Dan
vy
.
Syn
tactic
acciden
ts
in
program
analysis.
In
Philip
W
adler,
editor,
Pr
o
c
e
e
dings
of
the
2000
A
CM
SIGPLAN
International
Confer
enc
e
on
F
unctional
Pr
o
gr
amming,
pages
209{220,
Mon
tr

eal,
Canada,
Septem
b
er
2000.
A
CM
Press.
[5]
Olivier
Dan
vy
and
Andrzej
Filinski.
Represen
ting
con
trol,
a
study
of
the
CPS
transformation.
Mathematic
al
Structur
es
in
Computer
Scienc
e,
2(4):361{391,
Decem
b
er
1992.
[6]
Olivier
Dan
vy
and
John
Hatcli.
CPS
transformation
after
strictness
analysis.
A
CM
L
etters
on
Pr
o
gr
amming
L
anguages
and
Systems,
1(3):195{212,
1993.
[7]
Olivier
Dan
vy
and
John
Hatcli.
On
the
transformation
b
et
w
een
direct
and
con
tin
uation
seman
tics.
In
Stephen
Bro
ok
es,
Mic
hael
Main,
Austin
Melton,
Mic
hael
Mislo
v
e,
and
Da
vid
Sc
hmidt,
editors,
Pr
o
c
e
e
dings
of
the
9th
Confer
enc
e
on
Mathematic
al
F
oundations
of
Pr
o
gr
amming
Semantics,
n
um
b
er
802
in
Lecture
Notes
in
Computer
Science,
pages
627{648,
New
Orleans,
Louisiana,
April
1993.
Springer-V
erlag.
[8]
Olivier
Dan
vy
and
Lasse
R.
Nielsen.
A
higher-order
colon
translation.
In
Herb
ert
Kuc
hen
and
Kazunori
Ueda,
editors,
Fifth
International
Symp
osium
on
F
unctional
and
L
o
gic
Pr
o
gr
amming,
n
um
b
er
2024
in
Lecture
Notes
in
Computer
Science,
pages
78{91,
T
oky
o,
Japan,
Marc
h
2001.
Springer-V
erlag.
Extended
v
ersion
a
v
ailable
as
the
tec
hnical
rep
ort
BRICS
RS-00-33.
[9]
Matthias
F
elleisen.
The
Calculi
of
-v-CS
Conversion:
A
Syntactic
The
ory
of
Contr
ol
and
State
in
Imp
er
ative
Higher-Or
der
Pr
o
gr
amming
L
anguages.
PhD
220

Nielsen
thesis,
Departmen
t
of
Computer
Science,
Indiana
Univ
ersit
y
,
Blo
omington,
Indiana,
August
1987.
[10]
Andrzej
Filinski.
Represen
ting
monads.
In
Bo
ehm
[2
],
pages
446{457.
[11]
Andrzej
Filinski.
Represen
ting
la
y
ered
monads.
In
Alex
Aik
en,
editor,
Pr
o
c
e
e
dings
of
the
Twenty-Sixth
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
pages
175{188,
San
An
tonio,
T
exas,
Jan
uary
1999.
A
CM
Press.
[12]
Rob
ert
Harp
er,
Bruce
F.
Duba,
and
Da
vid
MacQueen.
T
yping
rst-class
con
tin
uations
in
ML.
Journal
of
F
unctional
Pr
o
gr
amming,
3(4):465{484,
Octob
er
1993.
[13]
John
Hatcli
and
Olivier
Dan
vy
.
A
generic
accoun
t
of
con
tin
uation-passing
st
yles.
In
Bo
ehm
[2],
pages
458{471.
[14]
Jung-taek
Kim
and
Kw
angk
eun
Yi.
In
terconnecting
Bet
w
een
CPS
Terms
and
Non-CPS
Terms.
In
Sabry
[20
].
[15]
Jung-taek
Kim,
Kw
angk
eun
Yi,
and
Olivier
Dan
vy
.
Assessing
the
o
v
erhead
of
ML
exceptions
b
y
selectiv
e
CPS
transformation.
In
Greg
Morrisett,
editor,
R
e
c
or
d
of
the
1998
A
CM
SIGPLAN
Workshop
on
ML
and
its
Applic
ations,
Baltimore,
Maryland,
Septem
b
er
1998.
Also
app
ears
as
BRICS
tec
hnical
rep
ort
RS-98-15.
[16]
Eugenio
Moggi.
Computational
lam
b
da-calculus
and
monads.
In
Pr
o
c
e
e
dings
of
the
F
ourth
A
nnual
IEEE
Symp
osium
on
L
o
gic
in
Computer
Scienc
e,
pages
14{23,
P
acic
Gro
v
e,
California,
June
1989.
IEEE
Computer
So
ciet
y
Press.
[17]
Gordon
D.
Plotkin.
Call-b
y-name,
call-b
y-v
alue
and
the
-calculus.
The
or
etic
al
Computer
Scienc
e,
1:125{159,
1975.
[18]
John
Repp
y
.
Lo
cal
CPS
con
v
ersion
in
a
direct-st
yle
compiler.
In
Sabry
[20
].
[19]
John
C.
Reynolds.
Denitional
in
terpreters
for
higher-order
programming
languages.
Higher-Or
der
and
Symb
olic
Computation,
11(4):363{397,
1998.
Reprin
ted
from
the
pro
ceedings
of
the
25th
A
CM
National
Conference
(1972).
[20]
Amr
Sabry
,
editor.
Pr
o
c
e
e
dings
of
the
Thir
d
A
CM
SIGPLAN
Workshop
on
Continuations
CW'01,
n
um
b
er
545
in
T
ec
hnical
Rep
ort,
Computer
Science
Departmen
t,
Indiana
Univ
ersit
y
,
Blo
omington,
Indiana,
Decem
b
er
2000.
[21]
Guy
L.
Steele
Jr.
Rabbit:
A
compiler
for
Sc
heme.
T
ec
hnical
Rep
ort
AI-TR-
474,
Articial
In
telligence
Lab
oratory
,
Massac
h
usetts
Institute
of
T
ec
hnology
,
Cam
bridge,
Massac
h
usetts,
Ma
y
1978.
221

Nielsen
222

MFPS
17
Preliminary
Version
Seman
tics
for
Algebraic
Op
erations
Gordon
Plotkin
and
John
P
o
w
er
1
L
ab
or
atory
for
the
F
oundations
of
Computer
Scienc
e
University
of
Edinbur
gh
King's
Buildings
Edinbur
gh
EH9
3JZ
SCOTLAND
Abstract
Giv
en
a
category
C
with
nite
pro
ducts
and
a
strong
monad
T
on
C
,
w
e
in-
v
estigate
axioms
under
whic
h
an
O
bC
-indexed
family
of
op
erations
of
the
form

x
:
(T
x)
n
 !
T
x
pro
vides
a
denitiv
e
seman
tics
for
algebraic
op
erations
added
to
the
computational
-calculus.
W
e
recall
a
denition
for
whic
h
w
e
ha
v
e
elsewhere
giv
en
adequacy
results
for
b
oth
big
and
small
step
op
erational
seman
tics,
and
w
e
sho
w
that
it
is
equiv
alen
t
to
a
range
of
other
p
ossible
natural
denitions
of
algebraic
op
eration.
W
e
outline
examples
and
non-examples
and
w
e
sho
w
that
our
denition
is
equiv
alen
t
to
one
for
call-b
y-name
languages
with
eects
to
o.
1
In
tro
duction
Eugenio
Moggi,
in
[6,8],
in
tro
duced
the
idea
of
giving
a
unied
category
theo-
retic
seman
tics
for
computational
eects
suc
h
as
nondeterminism,
probabilis-
tic
nondeterminism,
side-eects,
and
exceptions,
b
y
mo
delling
eac
h
of
them
uniformly
in
the
Kleisli
category
for
an
appropriate
strong
monad
on
a
base
category
C
with
nite
pro
ducts.
He
supp
orted
that
construction
b
y
dev
elop-
ing
the
computational
-calculus
or

c
-calculus,
for
whic
h
it
pro
vides
a
sound
and
complete
class
of
mo
dels.
The
computational
-calculus
is
essen
tially
the
same
as
the
simply
t
yp
ed
-calculus
except
for
the
essen
tial
fact
of
making
a
careful
systematic
distinction
b
et
w
een
computations
and
v
alues.
Ho
w
ev
er,
it
do
es
not
con
tain
op
erations,
and
op
erations
are
essen
tial
to
an
y
program-
ming
language.
So
here,
in
b
eginning
to
address
that
issue,
w
e
pro
vide
a
unied
seman
tics
for
algebraic
op
erations,
supp
orted
b
y
equiv
alence
theorems
to
indicate
denitiv
eness
of
the
axioms.
1
This
w
ork
is
supp
orted
b
y
EPSR
C
gran
t
GR/L89532:
Notions
of
computabilit
y
for
gen-
eral
datat
yp
es.
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

Plotkin
and
Po
wer
W
e
distinguish
here
b
et
w
een
algebraic
op
erations
and
arbitrary
op
erations.
The
former
are,
in
a
sense
w
e
shall
mak
e
precise,
a
natural
generalisation,
from
S
et
to
an
arbitrary
category
C
with
nite
pro
ducts,
of
the
usual
op
erations
of
univ
ersal
algebra.
The
k
ey
p
oin
t
is
that
the
op
erations

x
:
(T
x)
n
 !
T
x
are
parametrically
natural
in
the
Kleisli
category
for
a
strong
monad
T
on
C
,
as
made
precise
in
Denition
2.1:
in
that
case,
w
e
sa
y
that
the
monad
T
supp
orts
the
op
erations;
the
leading
class
of
examples
has
T
b
eing
gener-
ated
b
y
the
op
erations
sub
ject
to
equations
accompan
ying
them.
Examples
of
suc
h
op
erations
are
those
for
nondeterminism
and
probabilistic
nondeter-
minism,
and
for
raising
exceptions.
A
non-example
is
giv
en
b
y
an
op
eration
for
handling
exceptions.
In
a
companion
pap
er
[11],
w
e
ha
v
e
giv
en
the
ab
o
v
e
denition,
giv
en
a
syn-
tactic
coun
terpart
in
terms
of
the
computational
-calculus,
and
pro
v
ed
ade-
quacy
results
for
small
and
big-step
op
erational
seman
tics.
But
suc
h
results
alone
lea
v
e
some
scop
e
for
a
precise
c
hoice
of
appropriate
seman
tic
axioms.
So
in
this
pap
er,
w
e
pro
v
e
a
range
of
equiv
alence
results,
whic
h
w
e
b
eliev
e
pro
vide
strong
evidence
for
a
sp
ecic
c
hoice
of
axioms,
namely
those
for
parametric
naturalit
y
in
the
Kleisli
category
as
men
tioned
ab
o
v
e.
Our
most
profound
result
is
essen
tially
ab
out
a
generalisation
of
the
corresp
ondence
b
et
w
een
ni-
tary
monads
and
La
wv
ere
theories
from
S
et
to
a
category
with
nite
pro
ducts
C
and
a
strong
monad
T
on
C
:
this
result
c
haracterises
algebraic
op
erations
as
generic
eects.
The
generalit
y
of
our
analysis
is
somewhat
greater
than
in
the
study
of
enric
hed
La
wv
ere
theories
in
[12]:
the
latter
require
C
to
b
e
lo
cally
nitely
presen
table
as
a
closed
category
,
whic
h
is
not
true
of
all
our
leading
examples.
Moggi
ga
v
e
a
seman
tic
form
ulation
of
a
notion
of
op
eration
in
[7],
with
an
analysis
based
on
his
computational
metalanguage,
but
he
only
required
nat-
uralit
y
of
the
op
erations
in
C
,
and
w
e
kno
w
of
no
w
a
y
to
pro
vide
op
erational
seman
tics
in
suc
h
generalit
y
.
Our
v
arious
c
haracterisation
results
do
not
seem
to
extend
to
suc
h
generalit
y
either.
Eviden
t
further
w
ork
is
to
consider
ho
w
other
op
erations
suc
h
as
those
for
handling
exceptions
should
b
e
mo
delled.
That
migh
t
in
v
olv
e
going
b
ey
ond
monads,
as
Moggi
has
suggested
to
us;
one
p
ossibilit
y
is
in
the
direction
of
dy
ads
[13].
W
e
form
ulate
our
pap
er
in
terms
of
a
strong
monad
T
on
a
category
with
nite
pro
ducts
C
.
W
e
could
equally
form
ulate
it
in
terms
of
closed
F
r
ey
d-
categories
in
the
spirit
of
[1],
whic
h
pro
vides
a
leading
example
for
us
in
its
analysis
of
nite
nondeterminism.
The
pap
er
is
organised
as
follo
ws.
In
Section
2,
w
e
recall
the
denition
of
algebraic
op
eration
giv
en
in
[11]
and
w
e
exhibit
some
simple
reform
ulations
of
it.
In
Section
3,
w
e
giv
e
direct
equiv
alen
t
v
ersions
of
these
statemen
ts
in
terms
of
enric
hmen
t
under
the
assumption
that
C
is
closed.
In
Section
4,
w
e
giv
e
a
more
substan
tial
reform
ulation
of
the
notion
in
terms
of
op
erations
on
224

Plotkin
and
Po
wer
homs,
b
oth
when
C
is
closed
and
more
generally
when
C
is
not
closed.
In
Section
5,
w
e
giv
e
what
w
e
regard
as
the
most
profound
result
of
the
pap
er,
whic
h
is
a
form
ulation
in
terms
of
generic
eects,
generalising
a
study
of
La
wv
ere
theories.
Finally
,
in
Section
6,
w
e
c
haracterise
algebraic
op
erations
in
terms
of
op
erations
on
the
category
T
-Al
g
,
as
this
giv
es
an
indication
of
ho
w
to
incorp
orate
call-b
y-name
languages
with
computational
eects
in
to
the
picture.
And
w
e
giv
e
conclusions
and
an
outline
of
p
ossible
future
directions
in
Section
7.
2
Algebraic
op
erations
and
simple
equiv
alen
ts
In
this
section,
w
e
giv
e
the
denition
of
algebraic
op
eration
as
w
e
made
it
in
[11].
In
that
pap
er,
w
e
ga
v
e
the
denition
and
a
syn
tactic
coun
terpart
in
terms
of
the
computational
-calculus,
and
w
e
pro
v
ed
adequacy
results
for
small
and
big-step
op
erational
seman
tics
for
the
latter
in
terms
of
the
former.
Those
results
did
not
isolate
denitiv
e
axioms
for
the
notion
of
algebraic
op-
eration.
So
in
this
section,
w
e
start
with
a
few
straigh
tforw
ard
equiv
alence
results
on
whic
h
w
e
shall
build
later.
W
e
assume
w
e
ha
v
e
a
category
C
with
nite
pro
ducts
together
with
a
strong
monad
<
T
;

;
;
st
>
on
C
with
Kleisli
exp
onen
tials,
i.e.,
suc
h
that
for
all
ob
jects
x
and
z
of
C
,
the
functor
C
T
( x;
z
)
:
C
op
 !
S
et
is
represen
table.
W
e
do
not
tak
e
C
to
b
e
closed
in
general:
w
e
shall
need
to
assume
it
for
some
later
results,
but
w
e
sp
ecically
do
not
w
an
t
to
assume
it
in
general,
and
w
e
do
not
require
it
for
an
y
of
the
results
of
this
section.
Giv
en
a
map
f
:
y

x
 !
T
z
in
C
,
w
e
denote
the
parametrised
lifting
of
f
,
i.e.,
the
comp
osite
y

T
x
st
-
T
(y

x)
T
f
-
T
2
z

z
-
T
z
b
y
f
y
:
y

T
x
 !
T
z
.
Denition
2.1
An
algebr
aic
op
er
ation
is
an
O
bC
-indexed
family
of
maps

x
:
(T
x)
n
 !
T
x
suc
h
that
for
ev
ery
map
f
:
y

x
 !
T
z
in
C
,
the
diagram
y

(T
x)
n
hf
y

(y


i
)i
n
i=1
-
(T
z
)
n
y

T
x
y


x
?
f
y
-
T
z

z
?
comm
utes.
225

Plotkin
and
Po
wer
F
or
some
examples
of
algebraic
op
erations,
for
C
=
S
et,
let
T
b
e
the
nonempt
y
nite
p
o
w
er-set
monad
with
binary
c
hoice
op
erations
[9,1];
alterna-
tiv
ely
,
let
T
b
e
the
monad
for
probabilistic
nondeterminism
with
probabilistic
c
hoice
op
erations
[2,3
];
or
tak
e
T
to
b
e
the
monad
for
prin
ting
with
prin
ting
op
erations
[10].
Observ
e
the
non-comm
utativit
y
in
the
latter
example.
One
can,
of
course,
generalise
from
S
et
to
categories
suc
h
as
that
of
!
-cp
o's,
for
instance
considering
the
v
arious
p
o
w
er-domains
together
with
binary
c
hoice
op
erators.
One
can
also
consider
com
binations
of
these,
for
instance
to
mo
del
in
ternal
and
external
c
hoice
op
erations.
Sev
eral
of
these
examples
are
treated
in
detail
in
[11].
There
are
sev
eral
equiv
alen
t
form
ulations
of
the
coherence
condition
of
the
denition.
Decomp
osing
it
in
a
maximal
w
a
y
,
w
e
ha
v
e
Prop
osition
2.2
A
n
O
bC
-indexe
d
family
of
maps

x
:
(T
x)
n
 !
T
x
is
an
algebr
aic
op
er
ation
if
and
only
if
(i)

is
natur
al
in
C
(ii)

r
esp
e
cts
st
in
the
sense
that
y

(T
x)
n
hst

(y


i
)i
n
i=1
-
(T
(y

x))
n
y

T
x
y


x
?
st
-
T
(y

x)

y
x
?
c
ommutes
(iii)

r
esp
e
cts

in
the
sense
that
(T
2
x)
n

n
x
-
(T
x)
n
T
2
x

T
x
?

x
-
T
x

x
?
c
ommutes.
Pro
of.
It
is
immediately
clear
from
our
form
ulation
of
the
denition
and
the
prop
osition
that
the
conditions
of
the
prop
osition
imply
the
coherence
requiremen
t
of
the
denition.
F
or
the
con
v
erse,
to
pro
v
e
naturalit
y
in
C
,
put
y
=
1
and,
giv
en
a
map
g
:
x
 !
z
in
C
,
comp
ose
it
with

z
and
apply
the
coherence
condition
of
the
denition.
F
or
coherence
with
resp
ect
to
st,
tak
e
226

Plotkin
and
Po
wer
f
:
y

x
 !
T
z
to
b
e

y
x
.
And
for
coherence
with
resp
ect
to
,
put
y
=
1
and
tak
e
f
to
b
e
id
T
x
.
2
There
are
other
in
teresting
decomp
ositions
of
the
coherence
condition
of
the
denition
to
o.
In
the
ab
o
v
e,
w
e
ha
v
e
tak
en
T
to
b
e
an
endo-functor
on
C
.
But
one
often
also
writes
T
for
the
righ
t
adjoin
t
to
the
canonical
functor
J
:
C
 !
C
T
as
the
b
eha
viour
of
the
righ
t
adjoin
t
on
ob
jects
is
giv
en
precisely
b
y
the
b
eha
viour
of
T
on
ob
jects.
So
with
this
o
v
erloading
of
notation,
w
e
ha
v
e
functors
(T
 )
n
:
C
T
 !
C
and
T
:
C
T
 !
C
,
w
e
can
sp
eak
of
natural
transformations
b
et
w
een
them,
and
w
e
ha
v
e
the
follo
wing
prop
osition.
Prop
osition
2.3
A
n
O
bC
-indexe
d
family
of
maps

x
:
(T
x)
n
 !
T
x
is
an
algebr
aic
op
er
ation
if
and
only
if

is
natur
al
in
C
T
and

r
esp
e
cts
st.
In
another
direction,
as
w
e
shall
in
v
estigate
further
b
elo
w,
it
is
sometimes
con
v
enien
t
to
separate
the

part
of
the
coherence
condition
from
the
rest
of
it.
W
e
can
do
that
with
the
follo
wing
somewhat
tec
hnical
result.
Prop
osition
2.4
A
n
O
bC
-indexe
d
family

x
:
(T
x)
n
 !
T
x
forms
an
algebr
aic
op
er
ation
if
and
only
if

r
esp
e
cts

and,
for
every
map
f
:
y

x
 !
z
in
C
,
the
diagr
am
y

(T
x)
n
hst

(y


i
)i
n
i=1
-
(T
(y

x))
n
(T
f
)
n
-
(T
z
)
n
y

T
x
y


x
?
st
-
T
(y

x)
T
f
-
T
z

z
?
c
ommutes.
3
Equiv
alen
t
form
ulations
if
C
is
closed
F
or
our
more
profound
results,
it
seems
b
est
rst
to
assume
that
C
is
closed,
explain
the
results
in
those
terms,
and
later
to
drop
the
closedness
condition
and
explain
ho
w
to
reform
ulate
the
results
without
essen
tial
c
hange.
So
for
the
results
in
this
section,
w
e
shall
assume
C
is
closed.
Let
the
closed
structure
of
C
b
e
denoted
b
y
[ ;
 ].
Giv
en
a
monad
<
T
;

;

>
on
C
,
to
giv
e
a
strength
for
T
is
equiv
alen
t
to
giving
an
enric
hmen
t
of
T
in
C
:
giv
en
a
strength,
one
has
an
enric
hmen
t
T
x;y
:
[x;
y
]
 !
[T
x;
T
y
]
227

Plotkin
and
Po
wer
giv
en
b
y
the
transp
ose
of
[x;
y
]

T
x
st
-
T
([x;
y
]

x)
T
ev
-
T
y
and
giv
en
an
enric
hmen
t
of
T
,
one
has
a
strength
giv
en
b
y
the
transp
ose
of
x
-
[y
;
x

y
]
T
y
;xy
-
[T
y
;
T
(x

y
)]
It
is
routine
to
v
erify
that
the
axioms
for
a
strength
are
equiv
alen
t
to
the
axioms
for
an
enric
hmen
t.
So,
giv
en
a
strong
monad
<
T
;

;
;
st
>
on
C
,
the
monad
T
is
enric
hed
in
C
,
and
so
is
the
functor
( )
n
:
C
 !
C
.
The
category
C
T
also
canonically
acquires
an
enric
hmen
t
in
C
,
i.e,
the
homset
C
T
(x;
y
)
of
C
T
lifts
to
a
homob
ject
of
C
:
the
ob
ject
[x;
T
y
]
of
C
acts
as
a
homob
ject,
applying
the
functor
C
(1;
 )
:
C
 !
S
et
to
it
giving
the
homset
C
T
(x;
y
);
comp
osition
C
T
(y
;
z
)

C
T
(x;
y
)
 !
C
T
(x;
z
)
lifts
to
a
map
in
C
[y
;
T
z
]

[x;
T
y
]
 !
[x;
T
z
]
determined
b
y
taking
a
transp
ose
and
applying
ev
aluation
maps
t
wice
and
eac
h
of
the
strength
and
the
m
ultiplication
once;
and
iden
tities
and
the
axioms
for
a
category
lift
to
o.
The
canonical
functor
J
:
C
 !
C
T
b
ecomes
a
C
-enric
hed
functor
with
a
C
-enric
hed
righ
t
adjoin
t.
The
main
adv
an
tage
of
the
closedness
condition
for
us
is
that
it
allo
ws
us
to
disp
ense
with
the
parametrisation
of
the
naturalit
y
,
or
equiv
alen
tly
with
the
coherence
with
resp
ect
to
the
strength,
as
follo
ws.
Prop
osition
3.1
If
C
is
close
d,
an
O
bC
-indexe
d
family

x
:
(T
x)
n
 !
T
x
forms
an
algebr
aic
op
er
ation
if
and
only
if
[x;
T
z
]
( )
n

[T
x;

z
]

T
x;T
z
-
[(T
x)
n
;
(T
z
)
n
]
[T
x;
T
z
]
[T
x;

z
]

T
x;T
z
?
[
x
;
T
z
]
-
[(T
x)
n
;
T
z
]
[(T
x)
n
;

z
]
?
c
ommutes.
The
left-hand
v
ertical
map
in
the
diagram
here
is
exactly
the
b
eha
viour
of
the
C
-enric
hed
righ
t
adjoin
t
T
:
C
T
 !
C
to
the
canonical
C
-enric
hed
functor
J
:
C
 !
C
T
on
homs,
and
the
top
horizon
tal
map
is
exactly
the
b
eha
viour
of
the
C
-enric
hed
functor
(T
 )
n
:
C
T
 !
C
on
homs.
So
the
228

Plotkin
and
Po
wer
coherence
condition
in
the
prop
osition
is
precisely
the
statemen
t
that

forms
a
C
-enric
hed
natural
transformation
from
the
C
-enric
hed
functor
(T
 )
n
:
C
T
 !
C
to
the
C
-enric
hed
functor
T
:
C
T
 !
C
.
Pro
of.
Giv
en
a
map
f
:
y

x
 !
T
z
in
C
,
the
transp
ose
of
the
map
giv
es
a
map
from
y
to
[x;
T
z
].
Precomp
osing
the
coherence
condition
here
with
that
map,
then
transp
osing
b
oth
sides,
one
obtains
the
coherence
condition
of
the
denition.
F
or
the
con
v
erse,
giv
en
a
map
g
:
y
 !
[x;
T
z
],
taking
its
transp
ose,
using
the
coherence
condition
of
the
denition,
and
transp
osing
bac
k
again,
sho
ws
that
the
ab
o
v
e
square
precomp
osed
with
g
comm
utes.
So
b
y
the
Y
oneda
lemma,
w
e
are
done.
2
The
same
argumen
t
can
b
e
used
to
giv
e
a
further
c
haracterisation
of
the
notion
of
algebraic
op
eration
if
C
is
closed
b
y
mo
difying
Prop
osition
2.4.
This
yields
Prop
osition
3.2
If
C
is
close
d,
an
O
bC
-indexe
d
family

x
:
(T
x)
n
 !
T
x
forms
an
algebr
aic
op
er
ation
if
and
only
if

r
esp
e
cts

and
[x;
z
]
( )
n

T
x;z
-
[(T
x)
n
;
(T
z
)
n
]
[T
x;
T
z
]
T
x;z
?
[
x
;
T
z
]
-
[(T
x)
n
;
T
z
]
[(T
x)
n
;

z
]
?
c
ommutes.
This
prop
osition
sa
ys
that
if
C
is
closed,
an
algebraic
op
eration
is
exactly
a
C
-enric
hed
natural
transformation
from
the
C
-enric
hed
functor
(T
 )
n
:
C
 !
C
to
the
C
-enric
hed
functor
T
:
C
 !
C
that
is
coheren
t
with
resp
ect
to
.
4
Algebraic
op
erations
as
op
erations
on
homs
In
our
v
arious
form
ulations
of
the
notion
of
algebraic
op
eration
so
far,
w
e
ha
v
e
alw
a
ys
had
an
O
bC
-indexed
family

x
:
(T
x)
n
 !
T
x
and
considered
equiv
alen
t
conditions
on
it
under
whic
h
it
migh
t
b
e
called
an
algebraic
op
eration.
In
computing,
this
amoun
ts
to
considering
an
op
erator
on
expressions.
But
there
is
another
approac
h
in
whic
h
arro
ws
of
the
category
C
T
ma
y
b
e
seen
as
primitiv
e,
regarding
them
as
programs.
This
w
as
the
under-
lying
idea
of
the
reform
ulation
[1]
of
the
seman
tics
for
nite
nondeterminism
of
[9].
So
w
e
should
lik
e
to
reform
ulate
the
notion
of
algebraic
op
eration
in
229

Plotkin
and
Po
wer
these
terms.
Prop
osition
3.1
allo
ws
us
to
do
that.
In
order
to
explain
the
reason
for
the
coherence
conditions,
w
e
shall
start
b
y
expressing
the
result
assuming
C
is
closed;
after
whic
h
w
e
shall
drop
the
closedness
assumption
and
see
ho
w
the
result
can
b
e
re-expressed
using
parametrised
naturalit
y
.
W
e
rst
need
to
explain
an
enric
hed
v
ersion
of
the
Y
oneda
lemma
as
in
[4].
If
D
is
a
small
C
-enric
hed
category
,
then
D
op
ma
y
also
b
e
seen
as
a
C
-enric
hed
category
.
W
e
do
not
assume
C
is
complete
here,
but
if
w
e
did,
then
w
e
w
ould
ha
v
e
a
C
-enric
hed
functor
category
[D
op
;
C
]
and
a
C
-enric
hed
Y
oneda
em
b
edding
Y
D
:
D
 !
[D
op
;
C
]
The
C
-enric
hed
Y
oneda
em
b
edding
Y
D
is
a
C
-enric
hed
functor
and
it
is
fully
faithful
in
the
strong
sense
that
the
map
D
(x;
y
)
 !
[D
op
;
C
](D
( ;
x);
D
( ;
y
))
is
an
isomorphism
in
the
category
C
:
see
[4]
for
all
the
details.
It
follo
ws
b
y
applying
the
functor
C
(1;
 )
:
C
 !
S
et
that
this
induces
a
bijection
from
the
set
of
maps
from
x
to
y
in
D
to
the
set
of
C
-enric
hed
natural
transformations
from
the
C
-enric
hed
functor
D
( ;
x)
:
D
op
 !
C
to
the
C
-enric
hed
functor
D
( ;
y
)
:
D
op
 !
C
.
This
is
the
result
w
e
need,
except
that
w
e
do
not
w
an
t
to
assume
that
C
is
complete,
and
the
C
-enric
hed
categories
of
in
terest
to
us
are
of
the
form
C
T
,
so
in
general
are
not
small.
These
are
not
ma
jor
problems
although
they
go
a
little
b
ey
ond
the
scop
e
of
the
standard
form
ulation
of
enric
hed
category
theory
in
[4]:
one
can
em
b
ed
C
in
to
a
larger
univ
erse
C
0
just
as
one
can
em
b
ed
S
et
in
to
a
larger
univ
erse
S
et
0
when
necessary
,
and
the
required
mathematics
for
the
enric
hed
analysis
app
ears
in
[4].
W
e
still
ha
v
e
what
can
reasonably
b
e
called
a
Y
oneda
em
b
edding
of
D
in
to
[D
op
;
C
],
with
b
oth
categories
regarded
as
C
0
-enric
hed
rather
than
C
-enric
hed,
and
it
is
still
fully
faithful
as
a
C
0
-
enric
hed
functor.
Ho
w
ev
er,
w
e
can
form
ulate
the
result
w
e
need
more
directly
without
reference
to
C
0
simply
b
y
stating
a
restricted
form
of
the
enric
hed
Y
oneda
lemma:
letting
F
un
C
(D
op
;
C
)
denote
the
(p
ossibly
large)
category
of
C
-enric
hed
functors
from
D
op
to
C
,
the
underlying
ordinary
functor
D
 !
F
un
C
(D
op
;
C
)
of
the
Y
oneda
em
b
edding
is
fully
faithful.
W
e
use
this
latter
statemen
t
b
oth
here
and
in
the
follo
wing
section.
No
w
for
our
main
result
of
this
section
under
the
assumption
that
C
is
closed.
Theorem
4.1
If
C
is
close
d,
to
give
an
algebr
aic
op
er
ation
is
e
quivalent
to
giving
an
O
bC
op

O
bC
family
of
maps
a
y
;x
:
[y
;
T
x]
n
 !
[y
;
T
x]
that
is
C
-natur
al
in
y
as
an
obje
ct
of
C
op
and
C
-natur
al
in
x
as
an
obje
ct
of
230

Plotkin
and
Po
wer
C
T
,
i.e.,
such
that
[y
;
T
x]
n

[y
0
;
y
]
hcomp

(
i

[y
0
;
y
])i
n
i=1
-
[y
0
;
T
x]
n
[y
;
T
x]

[y
0
;
y
]
a
y
;x

[y
0
;
y
]
?
comp
-
[y
0
;
T
x]
a
y
0
;x
?
and
[x;
T
z
]

[y
;
T
x]
n
hcomp
K

([x;
T
z
]


i
)i
n
i=1
-
[y
;
T
z
]
n
[x;
T
z
]

[y
;
T
x]
[x;
T
z
]

a
y
;x
?
comp
K
-
[y
;
T
z
]
a
y
;z
?
c
ommute,
wher
e
comp
is
the
C
-enriche
d
c
omp
osition
of
C
and
comp
K
is
C
-
enriche
d
Kleisli
c
omp
osition.
Pro
of.
First
observ
e
that
[y
;
T
x]
n
is
isomorphic
to
[y
;
(T
x)
n
].
No
w,
it
fol-
lo
ws
from
our
C
-enric
hed
v
ersion
of
the
Y
oneda
lemma
that
to
giv
e
the
data
together
with
the
rst
axiom
of
the
prop
osition
is
equiv
alen
t
to
giving
an
O
bC
-indexed
family

:
(T
x)
n
 !
T
x
By
a
further
application
of
our
C
-enric
hed
v
ersion
of
the
Y
oneda
lemma,
it
follo
ws
that
the
second
condition
of
the
prop
osition
is
equiv
alen
t
to
the
coherence
condition
of
Prop
osition
3.1.
2
As
men
tioned
earlier,
w
e
can
still
state
essen
tially
this
result
ev
en
without
the
condition
that
C
b
e
closed.
There
are
t
w
o
reasons
for
this.
First,
for
the
pap
er,
w
e
ha
v
e
assumed
the
existence
of
Kleisli
exp
onen
tials,
as
are
essen
tial
in
order
to
mo
del
-terms.
But
most
of
the
examples
of
the
closed
structure
of
C
w
e
ha
v
e
used
ab
o
v
e
are
of
the
form
[y
;
T
x],
whic
h
could
equally
b
e
expressed
as
the
Kleisli
exp
onen
tial
y
)
x.
The
Kleisli
exp
onen
tial
routinely
extends
to
a
functor
 )
 :
C
op
T

C
T
 !
C
Second,
in
the
ab
o
v
e,
w
e
made
one
use
of
a
construct
of
the
form
[y
0
;
y
]
with
no
T
protecting
the
second
ob
ject.
But
w
e
can
replace
that
b
y
using
the
ordinary
Y
oneda
lemma
to
express
the
rst
condition
of
the
theorem
in
terms
of
maps
f
:
w

y
0
 !
y
.
Summarising,
w
e
ha
v
e
231

Plotkin
and
Po
wer
Corollary
4.2
T
o
give
an
algebr
aic
op
er
ation
is
e
quivalent
to
giving
an
O
bC
op

O
bC
family
of
maps
a
y
;x
:
(y
)
x)
n
 !
(y
)
x)
in
C
,
such
that
for
every
map
f
:
w

y
0
 !
y
in
C
,
the
diagr
am
(y
)
x)
n

w

y
0
(f
)
x)
n

w

y
0
-
((w

y
0
)
)
x)
n

w

y
0
(y
)
x)

y
a
y
;x

f
?
ev
-
x
ev

(a
w
y
0
;x

w

y
0
)
?
c
ommutes,
and
the
diagr
am
(x
)
z
)

(y
)
x)
n
hcomp
K

((x
)
z
)


i
)i
n
i=1
-
(y
)
z
)
n
(x
)
z
)

(y
)
x)
(x
)
z
)

a
y
;x
?
comp
K
-
(y
)
z
)
a
y
;z
?
c
ommutes,
wher
e
comp
K
is
the
c
anonic
al
internalisation
of
Kleisli
c
omp
osi-
tion.
5
Algebraic
op
erations
as
generic
eects
In
this
section,
w
e
apply
our
form
ulation
of
the
C
-enric
hed
Y
oneda
lemma
to
c
haracterise
algebraic
op
erations
in
en
tirely
dieren
t
terms
again
as
maps
in
C
T
,
i.e.,
in
terms
of
generic
eects.
Observ
e
that
if
C
has
an
n-fold
copro
duct
n
of
1,
the
functor
(T
 )
n
:
C
T
 !
C
is
isomorphic
to
the
functor
n
)
 :
C
T
 !
C
.
If
C
is
closed,
the
functor
n
)
 enric
hes
canonically
to
a
C
-
enric
hed
functor,
and
that
C
-enric
hed
functor
is
precisely
the
represen
table
C
-
functor
C
T
(n;
 )
:
C
T
 !
C
,
where
C
T
is
regarded
as
a
C
-enric
hed
category
.
So
b
y
Prop
osition
3.1
together
with
our
C
-enric
hed
v
ersion
of
the
Y
oneda
lemma,
w
e
immediately
ha
v
e
Theorem
5.1
If
C
is
close
d,
the
C
-enriche
d
Y
one
da
emb
e
dding
induc
es
a
bije
ction
b
etwe
en
maps
1
 !
n
in
C
T
and
algebr
aic
op
er
ations

x
:
(T
x)
n
 !
T
x
This
result
is
essen
tially
just
an
instance
of
an
enric
hed
v
ersion
of
the
iden
tication
of
maps
in
a
La
wv
ere
theory
with
op
erations
of
the
La
wv
ere
theory
.
Observ
e
that
it
follo
ws
that
there
is
no
mathematical
reason
to
restrict
232

Plotkin
and
Po
wer
atten
tion
to
algebraic
op
erations
of
arit
y
n
for
a
natural
n
um
b
er
n.
W
e
could
just
as
w
ell
sp
eak,
in
this
setting,
of
algebraic
op
erations
of
the
form

x
:
(a
)
 )
 !
(b
)
 )
for
an
y
ob
jects
a
and
b
of
C
.
So
for
instance,
w
e
could
include
an
accoun
t
of
innitary
op
erations
as
one
migh
t
use
to
mo
del
op
erations
in
v
olv
ed
with
state.
F
or
sp
ecic
c
hoices
of
C
suc
h
as
C
=
P
oset,
one
could
consider
more
exotic
arities
suc
h
as
that
giv
en
b
y
Sierpinski
space.
Once
again,
b
y
use
of
parametrisation,
w
e
can
a
v
oid
the
closedness
as-
sumption
on
C
here,
yielding
the
stronger
statemen
t
Theorem
5.2
F
unctoriality
of
 )
 :
C
op
T

C
T
 !
C
in
its
rst
variable
induc
es
a
bije
ction
fr
om
the
set
of
maps
1
 !
n
in
C
T
to
the
set
of
algebr
aic
op
er
ations

x
:
(T
x)
n
 !
T
x
W
e
regard
this
as
the
most
profound
result
of
the
pap
er.
This
result
sho
ws
that
to
giv
e
an
algebraic
op
eration
is
equiv
alen
t
to
giving
a
generic
eect,
i.e.,
a
constan
t
of
t
yp
e
the
arit
y
of
the
op
eration.
F
or
example,
to
giv
e
a
binary
nondeterministic
op
erator
for
a
strong
monad
T
is
equiv
alen
t
to
giving
a
constan
t
of
t
yp
e
2,
and
to
giv
e
equations
to
accompan
y
the
op
erator
is
equiv
alen
t
to
giving
equations
to
b
e
satised
b
y
the
constan
t.
The
leading
example
here
has
T
b
eing
the
non-empt
y
nite
p
o
w
erset
monad
or
a
p
o
w
er-
domain.
Giv
en
a
nondeterministic
op
erator
_,
the
constan
t
is
giv
en
b
y
tr
ue
_
f
al
se,
and
giv
en
a
constan
t
c,
the
op
erator
is
giv
en
b
y
M
_
N
=
if
c
then
M
else
N
.
There
are
precisely
three
non-empt
y
nite
subsets
of
the
t
w
o
elemen
t
set,
and
accordingly
,
there
are
precisely
three
algebraic
op
erations
on
the
non-
empt
y
nite
p
o
w
erset
monad,
and
they
are
giv
en
b
y
the
t
w
o
pro
jections
and
c
hoice.
The
connection
of
this
result
with
enric
hed
La
wv
ere
theories
[12]
is
as
fol-
lo
ws.
If
C
is
lo
cally
nitely
presen
table
as
a
closed
category
,
one
can
dene
a
notion
of
nitary
C
-enric
hed
monad
on
C
and
a
notion
of
C
-enric
hed
La
wv
ere
theory
,
and
pro
v
e
that
the
t
w
o
are
equiv
alen
t,
generalising
the
usual
equiv-
alence
in
the
case
that
C
=
S
et.
Giv
en
a
nitary
C
-enric
hed
monad
T
,
the
corresp
onding
C
-enric
hed
La
wv
ere
theory
is
giv
en
b
y
the
full
sub-C
-category
of
C
T
determined
b
y
the
nitely
presen
table
ob
jects.
These
include
all
nite
copro
ducts
of
1.
So
our
results
here
exactly
relate
maps
in
the
La
wv
ere
theory
with
algebraic
op
erations,
generalising
La
wv
ere's
original
idea.
Of
course,
in
this
pap
er,
w
e
do
not
assume
the
niteness
assumptions
on
either
the
category
C
or
the
monad
T
,
but
our
result
here
is
essen
tially
the
same.
Theorem
5.2
extends
with
little
fuss
to
the
situation
of
nitely
presen
table
ob
jects
a
and
b;
one
just
requires
a
suitable
renemen
t
of
the
construct
(T
 )
n
to
accoun
t
for
a
and
b
b
eing
ob
jects
of
C
rather
than
nite
n
um
b
ers.
This
follo
ws
readily
b
y
insp
ection
of
the
w
ork
of
[12
],
and,
in
a
sp
ecial
case,
it
seems
to
pro
vide
an
accoun
t
of
some
of
the
op
erations
asso
ciated
with
state,
233

Plotkin
and
Po
wer
as
suggested
to
us
b
y
Moggi.
6
Algebraic
op
erations
and
the
category
of
algebras
Finally
,
in
this
section,
w
e
c
haracterise
the
notion
of
algebraic
op
eration
in
terms
of
the
category
of
algebras
T
-Al
g
.
The
co-Kleisli
category
of
the
comonad
on
T
-Al
g
induced
b
y
the
monad
T
is
used
to
mo
del
call-b
y-name
languages
with
eects,
so
this
form
ulation
giv
es
us
an
indication
of
ho
w
to
generalise
our
analysis
to
call-b
y-name
computation
or
p
erhaps
to
some
com-
bination
of
call-b
y-v
alue
and
call-b
y-name,
cf
[5].
If
C
is
closed
and
has
equalisers,
generalising
La
wv
ere,
the
results
of
the
previous
section
can
equally
b
e
form
ulated
as
equiv
alences
b
et
w
een
algebraic
op
erations
and
op
erations

(A;a)
:
U
(A;
a)
n
 !
U
(A;
a)
natural
in
(A;
a),
where
U
:
T
-Al
g
 !
C
is
the
C
-enric
hed
forgetful
functor:
equalisers
are
needed
in
C
in
order
to
giv
e
an
enric
hmen
t
of
T
-Al
g
in
C
.
W
e
pro
v
e
the
result
b
y
use
of
our
C
-enric
hed
v
ersion
of
the
Y
oneda
lemma
again,
together
with
the
observ
ation
that
the
canonical
C
-enric
hed
functor
I
:
C
T
 !
T
-Al
g
is
fully
faithful.
F
ormally
,
the
result
is
Theorem
6.1
If
C
is
close
d
and
has
e
qualisers,
the
C
-enriche
d
Y
one
da
em-
b
e
dding
induc
es
a
bije
ction
b
etwe
en
maps
1
 !
n
in
C
T
and
C
-enriche
d
nat-
ur
al
tr
ansformations

:
(U
 )
n
 !
U
 :
Com
bining
this
with
Theorem
5.1,
w
e
ha
v
e
Corollary
6.2
If
C
is
close
d
and
has
e
qualisers,
to
give
an
algebr
aic
op
er
ation

x
:
(T
x)
n
 !
T
x
is
e
quivalent
to
giving
a
C
-enriche
d
natur
al
tr
ansformation

:
(U
 )
n
 !
U:
One
can
also
giv
e
a
parametrised
v
ersion
of
this
result
if
C
is
neither
closed
nor
complete
along
the
lines
for
C
T
as
in
the
previous
section.
It
yields
Theorem
6.3
T
o
give
an
algeb
er
aic
op
er
ation

x
:
(T
x)
n
 !
T
x
is
e
quivalent
to
giving
an
O
b(T
-Al
g
)-indexe
d
family
of
maps

(A;a)
:
U
(A;
a)
n
 !
U
(A;
a)
such
that,
for
e
ach
map
f
:
x

U
(A;
a)
 !
U
(B
;
b)
234

Plotkin
and
Po
wer
c
ommutativity
of
x

T
A
x

T
f
-
x

T
B
x

A
x

a
?
x

f
-
x

B
x

b
?
implies
c
ommutativity
of
x

U
(A;
a)
n
hf

(x


i
)i
n
i=1
-
U
(B
;
b)
n
x

U
(A;
a)
x


(A;a)
?
f
-
U
(B
;
b)

(B
;b)
?
7
Conclusions
and
F
urther
W
ork
F
or
some
nal
commen
ts,
w
e
note
that
little
atten
tion
has
b
een
paid
in
the
literature
to
the
parametrised
naturalit
y
condition
on
the
notion
of
algebraic
op
eration
that
w
e
ha
v
e
used
hea
vily
here.
And
none
of
the
main
results
of
[11
]
used
it,
although
they
did
require
naturalit
y
in
C
T
.
So
it
is
natural
to
ask
wh
y
that
is
the
case.
F
or
the
latter
p
oin
t,
in
[11
],
w
e
addressed
ourselv
es
almost
exclusiv
ely
to
closed
terms,
and
that
mean
t
that
parametrised
naturalit
y
of
algebraic
op
erations
did
not
arise
as
w
e
did
not
ha
v
e
an
y
parameter.
Regarding
wh
y
parametrised
naturalit
y
do
es
not
seem
to
ha
v
e
b
een
ad-
dressed
m
uc
h
in
the
past,
observ
e
that
for
C
=
S
et,
ev
ery
monad
has
a
unique
strength,
so
parametrised
naturalit
y
of

is
equiv
alen
t
to
ordinary
nat-
uralit
y
of

.
More
generally
,
if
the
functor
C
(1;
 )
:
C
 !
S
et
is
faithful,
i.e.,
if
1
is
a
generator
in
C
,
then
parametrised
naturalit
y
is
again
equiv
alen
t
to
ordinary
naturalit
y
of

.
That
is
true
for
categories
suc
h
as
P
oset
and
that
of
!
-cp
o's,
whic
h
ha
v
e
b
een
the
leading
examples
of
categories
studied
in
this
regard.
The
reason
w
e
ha
v
e
a
distinction
is
b
ecause
w
e
ha
v
e
not
assumed
that
1
is
a
generator,
allo
wing
us
to
include
examples
suc
h
as
top
oses
or
C
at
for
example.
Of
course,
in
future,
w
e
hop
e
to
address
other
op
erations
that
are
not
algebraic,
suc
h
as
one
for
handling
exceptions.
It
seems
unlik
ely
that
the
ap-
proac
h
of
this
pap
er
extends
directly
.
Eugenio
Moggi
has
recommended
w
e
lo
ok
b
ey
ond
monads.
W
e
should
also
lik
e
to
extend
and
in
tegrate
this
w
ork
with
w
ork
addressing
other
asp
ects
of
giving
a
unied
accoun
t
of
computa-
235

Plotkin
and
Po
wer
tional
eects.
W
e
note
here
esp
ecially
P
aul
Levy's
w
ork
[5]
whic
h
can
b
e
used
to
giv
e
accoun
ts
of
b
oth
call-b
y-v
alue
and
call-b
y-name
in
the
same
setting,
and
w
ork
on
mo
dularit
y
[13
],
whic
h
migh
t
also
help
with
other
computational
eects.
References
[1]
Anderson,
S.O.,
and
A.
J.
P
o
w
er,
A
R
epr
esentable
Appr
o
ach
to
Finite
Nondeterminism,
Theoret.
Comput.
Sci.
177
(1997)
3{25.
[2]
Jones,
C.,
\Probabilistic
Non-Determinism,"
Ph.D.
Thesis,
Univ
ersit
y
of
Edin
burgh,
Rep
ort
ECS-LF
CS-90-105,
1990.
[3]
Jones,
C.,
and
G.
D.
Plotkin,
A
Pr
ob
abilistic
Power
domain
of
Evaluations,
Pro
c.
LICS
4
(1989)
186{195.
[4]
Kelly
,
G.M.,
\Basic
Concepts
of
Enric
hed
Category
Theory
,"
Cam
bridge:
Cam
bridge
Univ
ersit
y
Press,
1982.
[5]
Levy
,
P
.B.,
Cal
l-by-Push-V
alue:
A
Subsuming
Par
adigm,
\Pro
c.
TLCA
99"
Lecture
Notes
in
Computer
Science
1581
228{242.
[6]
Moggi,
E.,
Computational
lamb
da-c
alculus
and
monads,
Pro
c.
LICS
89
(1989)
14{23.
[7]
Moggi,
E.,
A
n
abstr
act
view
of
pr
o
gr
amming
languages,
Univ
ersit
y
of
Edin
burgh,
Rep
ort
ECS-LF
CS-90-113,
1989.
[8]
Moggi,
E.,
Notions
of
c
omputation
and
monads,
Inf.
and
Comp.
93
(1991)
55{92.
[9]
Plotkin,
G.D.,
A
Power
domain
Construction,
SIAM
J.
Comput.
5
(1976)
452{
487.
[10]
Plotkin,
G.D.,
\Domains,"
(h
ttp://www.dcs.ed.ac.uk/home/gdp/),
1983.
[11]
Plotkin,
G.D.,
and
A.
J.
P
o
w
er,
A
de
quacy
for
A
lgebr
aic
Ee
cts,
Pro
c.
F
OSSA
CS
2001
(to
app
ear).
[12]
P
o
w
er,
A.J.,
Enriche
d
L
awver
e
The
ories,
Theory
and
Applications
of
Categories
(2000)
83{93.
[13]
P
o
w
er,
A.J.,
and
E.
P
.
Robinson,
Mo
dularity
and
Dyads,
\Pro
c.
MFPS
15"
Electronic
Notes
in
Tho
eret.
Comp.
Sci.
20,
1999.
236

MFPS 17 Preliminary Version
An Algebraic Foundation for Graph-based
Diagrams in Computing
John Power 1,3 and Konstantinos Tourlas 2,4
Division of Informatics
The University of Edinburgh
Edinburgh EH9 3JZ
United Kingdom
Abstract
We develop an algebraic foundation for some of the graph-based structures underly-
ing a variety of popular diagrammatic notations for the speciÔ¨Åcation, modelling and
programming of computing systems. Using hypergraphs and higraphs as leading ex-
amples, a locally ordered category Graph(C) of graphs in a locally ordered category
C is deÔ¨Åned and endowed with symmetric monoidal closed structure. Two other op-
erations on higraphs and variants, selected for relevance to computing applications,
are generalised in this setting.
1
Introduction
Recent years have witnessed a rapid, ongoing popularisation of diagrammatic
notations in the speciÔ¨Åcation, modelling and programming of computing sys-
tems. Most notable among them are Statecharts [4], a notation for modelling
reactive systems, and the UniÔ¨Åed Modelling Language (UML) [10], a family
of diagrammatic notations for object-based modelling. Invariably, underlying
such complex diagrams is some notion of graph, upon which labels and other
linguistic or visual annotations are added according to application-speciÔ¨Åc
needs (see e.g. [10,9,3] for a variety of examples).
Beyond ordinary graphs, the two leading examples studied here are hy-
pergraphs and higraphs [5]. The latter underlie a number of sophisticated
diagrammatic formalisms including, most prominently, Statecharts, the state
1 This work has been done with the support of EPSRC grant GR/M56333 and a British
Council grant, and the COE budget of STA Japan.
2 Support EPSRC grant GR/N12480 and of the COE budget of STA Japan is gratefully
acknowledged.
3 Email: ajp@dcs.ed.ac.uk
4 Email: kxt@dcs.ed.ac.uk
This is a preliminary version. The Ô¨Ånal version will be published in
Electronic Notes in Theoretical Computer Science
URL: www.elsevier.nl/locate/entcs

Power and Tourlas
diagrams of UML, and the domain-speciÔ¨Åc language Argos [8] for program-
ming reactive systems. Higraphs allow for vitally concise, economical repre-
sentations of complex state-transition systems, such as those underlying re-
alistic reactive systems, by drastically reducing the number of edges required
to specify the transition relation. This is achieved by replacing a number of
transitions having, say, a common target state with a single transition having
the same target but with source a new ‚Äúsuper-state‚Äù containing all the source
states of the original transitions. The resulting reduction in complexity is of
the order of n2, where n is the number of states.
We begin our analysis by observing that graphs, hypergraphs and higraphs
are all instances of the same structure, that of a graph in a category C, with C
being respectively Set, Rel and Poset. Other variants are also considered. The
case of higraphs is motivated and studied extensively and concretely in the
draft paper [13]. The latter assumes only elementary knowledge of category
theory on the part of the reader, so as to be accessible to a wide audience
of computer scientists who have immediate scientiÔ¨Åc and practical interest
in higraphs and their applications in UML and Statecharts. In the present
paper, Section 2 introduces our leading examples, followed by a deÔ¨Ånition in
Section 2.4 of a category Graph(C) of graphs in a locally ordered category C.
Underlying Statecharts is a binary operation which given Statecharts S
and S‚Ä≤ yields a third corresponding to the semantics of S and S‚Ä≤ operating
concurrently. We show how the same applies to higraphs and hypergraphs.
Here we formulate this precisely and uniformly in algebraic terms by deÔ¨Åning a
symmetric monoidal closed structure on Graph(C). We do so in Section 3. It
is further shown that symmetric monoidal closed adjunction linking Graph(C)
to Cat(C) exists when the latter category bears a generalisation of the ‚Äúother‚Äù
symmetric monoidal closed structure on Cat.
Hierarchies of edges in higraphs are exploited in practical applications to
produce concise speciÔ¨Åcations of complex reactive systems. To understand
the meaning of higher-level edges we introduce in Section 4 a completion
operation on higraphs. This is shown to be an instance of the right adjoint to
the inclusion of Graph(C) into Graphopl(C), the latter having oplax natural
transformations as arrows. A theorem stating conditions for the existence of
such right adjoints is proved.
To support users in working with large, hierarchically structured dia-
grams representing complex systems, one requires eÔ¨Äective mechanisms for
re-organising, abstracting and Ô¨Åltering the information present in diagrams
[9]. The leading example studied here is of a Ô¨Åltering operation on higraphs,
introduced and motivated by Harel in [5] under the name of zooming out. We
show in Section 5 how it generalises to graphs in non-trivially locally ordered
categories.
238

Power and Tourlas
Fig. 1. A simple hypergraph.
F
A
B
C
D
E
Fig. 2. A simple higraph.
2
Leading examples and main deÔ¨Ånition
We begin by recalling the standard deÔ¨Ånition of a (directed, multi-)graph as
consisting of a set V of vertices, a set E of edges and two functions s, t : E ‚àí‚Üí
V giving the source and target of each edge. That is, a graph is a pair of
parallel arrows s, t : E ‚àí‚ÜíV in the category Set.
2.1
Hypergraphs
Hypergraphs are a generalisation of graphs in which each edge may have sets
of vertices as its source and target. The typical pictorial representation of this
kind of directed hypergraph is illustrated in Figure 1.
Thus, a hypergraph consists of a set V of vertices, a set E of edges and
two functions s, t : E ‚àí‚Üí2V giving sources and targets. Equivalently, s and
t may be seen as relations from E to V , thus arriving at the following
DeÔ¨Ånition 2.1 A hypergraph is a pair of parallel maps in the category Rel of
(small) sets and relations.
2.2
Higraphs
Higraph is a term coined-up by Harel[5] as short for hierarchical graph, but
is often used to include several variants. The deÔ¨Ånitive feature of higraphs,
common to all variants, is referred to as depth, meaning that nodes may be
contained inside other nodes. Figure 2 illustrates the standard pictorial rep-
resentation of a higraph consisting of six nodes and four edges, with the nodes
labelled B, C and D being spatially contained within the node labelled A. It
is therefore common, and we shall hereafter adhere to convention, to call the
nodes of a higraph blobs, as an indication of their pictorial representation by
239

Power and Tourlas
convex contours on the plane. For further details the reader is referred to [13].
The containment relation on blobs is captured by requiring poset struc-
ture on the set of blobs. The notion of higraph developed here extends this
requirement to the set of edges:
DeÔ¨Ånition 2.2 A higraph is a pair of parallel arrows s, t : E ‚àí‚ÜíB in the
category Poset.
In practice, a higraph typically arises as a graph (B, E, s, t) together with
a partial order ‚â§B on B. In that case, the poset structure on E may be taken
to be the discrete one. However, other choices of orders on E are often useful,
e.g. for encoding the conÔ¨Çict resolution schemes [6] adopted in Statecharts.
In most applications of higraphs, especially Statecharts, the intuitive un-
derstanding of en edge e is as implying the presence of ‚Äúlower-level‚Äù, implicit
edges from all blobs contained in s(e) to all blobs contained in t(e). The point
in general is that a multitude of edges is made implicit in a single, explicitly
shown higher-level edge. In Statecharts, this device is employed for repre-
senting interrupt transitions, thus drastically reducing the number of edges
required to specify the transition relation among the states of the represented
transition system.
2.3
Combinations and variants
To deal with realistic diagrams, one may additionally wish to combine features
found in diÔ¨Äerent notions of graph, e.g. to allow edges in higraphs to have
multiple sources and targets, as is indeed allowed in some Statecharts. The
resulting notion of graph, a combination of simple higraphs (as deÔ¨Åned above)
and hypergraphs, could be approached by considering the category of posets
and relations between their underlying sets. The category BSup of posets with
all binary sups (and sup-preserving monotone maps) gives a better model of
depth in Statecharts. One may also consider graphs in the category œâ-Cpo of
œâ-complete partial orders.
2.4
Graphs in locally ordered categories
Each of our leading examples of ‚Äúnotions of graph‚Äù has been cast in terms of a
pair of parallel maps in a suitable category C. Another, less obvious common-
ality among our examples is that C has been a locally ordered category, i.e.
a category enriched in the cartesian closed category Poset of posets, a fact of
which substantial use will be made later. (The category Set is locally ordered
in a trivial sense: each hom-object is a discrete poset.) Generalising from our
situation one has:
DeÔ¨Ånition 2.3 Let C be a locally ordered category. Let Graph(C) denote the
locally ordered category of graphs in C, that is the functor category [¬∑ ‚Üí
‚Üí¬∑, C]
where the category ¬∑ ‚Üí
‚Üí¬∑ consists of two objects and two non-identity maps as
shown.
2
240

Power and Tourlas
h
B
C
D
E
F
G
j
f
e
k
g
A
Fig. 3. A simple Statechart
f
B
C
j
‚äó
h
F
G
e
k
g
E
=
B,E
B,F
C,G
C,E
B,G
C,F
k
h
f
j
k
f
j
j
f
e
g
h
g
e
Fig. 4. Operation underlying the Statechart of Fig. 3
So, an object of Graph(C) consists of a pair of objects E and V of C,
together with a pair of maps s, t : E ‚àí‚ÜíV in C. An arrow of Graph(C)
from (E, V, s, t : E ‚àí‚ÜíV ) to (E‚Ä≤, V ‚Ä≤, s‚Ä≤, t‚Ä≤ : E‚Ä≤ ‚àí‚ÜíV ‚Ä≤) consists of maps
fE : E ‚àí‚ÜíE‚Ä≤ and fV : V ‚àí‚ÜíV ‚Ä≤ such that fV s = s‚Ä≤fE and fV t = t‚Ä≤fE. The
local order of Graph(C) is generated by that of C, i.e., (fE, fV ) ‚â§(gE, gV ) if
fE ‚â§gE and fV ‚â§gV .
3
A symmetric monoidal closed structure on Graph(C)
We now proceed to study some extra structure on Graph(C), for well-behaved
C.
Our motivation arises from the application of higraphs in Statecharts.
SpeciÔ¨Åcations of complex reactive systems directly in terms of transition sys-
tems become impractical to visualise owing to the large number of states
involved.
Statecharts deal with this problem by allowing the modelling of
reactive systems directly in terms of their identiÔ¨Åable concurrent subsystems:
Example 3.1 Consider the Statechart in Figure 3 representing two subsys-
tems A and D operating concurrently.
Assuming an interleaving model of
concurrency, as is the case with Statecharts, the meaning of this picture is
captured precisely by the operation where the resulting transition system is
exactly the intended behaviour of the complete system.
2
A consequence of our results in this section is that the above operation,
which in [5] is referred to as ‚Äúa sort of product of automata‚Äù, generalises
241

Power and Tourlas
smoothly to higraphs.
This is an essential step in pinpointing the precise
mathematical structures underpinning the semantics of Statecharts. For, more
generally, the speciÔ¨Åcations of the subsystems A and D in Figure 3 typically
bear higraph structure.
So for our next main result, we observe that, generalising the situation for
C = Set in Example 3.1, here not requiring local order structure on C, we
have
Theorem 3.2 For any cartesian closed category C with Ô¨Ånite coproducts, the
category Graph(C) has a symmetric monoidal structure given as follows: given
G = (E, V, s, t) and G‚Ä≤ = (E‚Ä≤, V ‚Ä≤, s‚Ä≤, t‚Ä≤), the graph G ‚äóG‚Ä≤ has vertex object
V √ó V ‚Ä≤ and edge object (E √ó V ‚Ä≤) + (V √ó E‚Ä≤), with source and target maps
evident. The unit of this symmetric monoidal structure is given by V = 1 and
E = 0.
Proof. That ‚äóis a bifunctor follows directly from the properties of the binary
products and coproducts in C. The required isomorphisms are easily deduced
from those associated with the symmetric monoidal structure induced on C
by its cartesian structure, and the veriÔ¨Åcation of the required coherence con-
ditions is routine.
2
Example 3.3 On higraphs ‚äóyields a straightforward generalisation of the
operation in Figure 4. SpeciÔ¨Åcally œá‚äóœá‚Ä≤ contains an edge ‚ü®b1, b‚Ä≤‚ü©‚Üí‚ü®b2, b‚Ä≤‚ü©for
every edge b1 ‚Üíb2 in œá and blob b‚Ä≤ in œá‚Ä≤, and an edge ‚ü®b, b‚Ä≤
1‚ü©‚Üí‚ü®b, b‚Ä≤
2‚ü©for every
edge b‚Ä≤
1 ‚Üíb‚Ä≤
2 in œá‚Ä≤ and blob b in œá. Containment is given by ‚ü®b1, b‚Ä≤
1‚ü©‚â§‚ü®b2, b‚Ä≤
2‚ü©
iÔ¨Äb1 ‚â§b2 and b‚Ä≤
1 ‚â§b‚Ä≤
2. In the case of hypergraphs, H ‚äóH‚Ä≤ contains an edge
{‚ü®x1, x‚Ä≤‚ü©, . . . , ‚ü®xn, x‚Ä≤‚ü©} ‚Üí{‚ü®y1, x‚Ä≤‚ü©, . . . , ‚ü®ym, x‚Ä≤‚ü©} for each edge {x1, . . . , xn} ‚Üí
{y1, . . . , ym} in H and vertex x‚Ä≤ in œá‚Ä≤, and similarly for the edges in H‚Ä≤.
Theorem 3.4 For any cartesian closed category C with Ô¨Ånite coproducts and
Ô¨Ånite limits, the symmetric monoidal structure on Graph(C) given in Theo-
rem 3.2 is closed.
Proof. The exponential object [G‚Ä≤, G‚Ä≤‚Ä≤] has object of vertices the domain of
the equaliser of the two maps from [V ‚Ä≤, V ‚Ä≤‚Ä≤]√ó[E‚Ä≤, E‚Ä≤‚Ä≤] to [E‚Ä≤, V ‚Ä≤] √ó [E‚Ä≤, V ‚Ä≤] given
by ‚ü®[s‚Ä≤, V ‚Ä≤], [t‚Ä≤, V ‚Ä≤]‚ü©‚ó¶œÄ0 and ‚ü®[E‚Ä≤, s‚Ä≤], [E‚Ä≤, t‚Ä≤]‚ü©‚ó¶œÄ1 where œÄ0, œÄ1 are the projections
from [V ‚Ä≤, V ‚Ä≤‚Ä≤] √ó [E‚Ä≤, E‚Ä≤‚Ä≤]. The object of edges of [G‚Ä≤, G‚Ä≤‚Ä≤] is the domain of the
equaliser of the maps ‚ü®œÄ0 ‚ó¶q ‚ó¶œÄ‚Ä≤
0, œÄ0 ‚ó¶q ‚ó¶œÄ‚Ä≤
2‚ü©and ‚ü®[V ‚Ä≤, s‚Ä≤‚Ä≤] ‚ó¶œÄ‚Ä≤
1, [V ‚Ä≤, t‚Ä≤‚Ä≤] ‚ó¶œÄ‚Ä≤
1‚ü©,
both having domain V √ó [V ‚Ä≤, E‚Ä≤‚Ä≤] √ó V and codomain [V ‚Ä≤, V ‚Ä≤‚Ä≤] √ó [V ‚Ä≤, V ‚Ä≤‚Ä≤], where
œÄ‚Ä≤
i are the three projections out of V √ó [V ‚Ä≤, E‚Ä≤‚Ä≤] √ó V .
2
Notice, in particular, that the exponential in the category Graph(C) with the
tensor product deÔ¨Åned in the theorem is particularly natural. The object of
vertices represents all graph homomorphisms from G to G‚Ä≤, and the object of
edges represents all transformations between graph homomorphisms.
242

Power and Tourlas
3.1
A symmetric monoidal closed adjunction
It is well known that one may deÔ¨Åne categories in any category C with Ô¨Ånite
limits, the usual category Cat being isomorphic to the category of models
Cat(Set) in Set of an appropriate Ô¨Ånite limit sketch [1]. We shall write Cat(C)
for the category of categories in C, implicitly asserting C to have Ô¨Ånite limits
as required.
While it is well known that Cat is a cartesian closed category, it is far
less well known that there is precisely one other symmetric monoidal closed
structure on Cat [2,12]. We refer to the other one as the other symmetric
monoidal closed structure on Cat, which may be outlined as follows:
‚Ä¢ The exponential A ‚àí‚ÜíB is given by the set of functors from A to B, with
a morphism from g to h being the assignment of an arrow Œ±x : gx ‚àí‚Üíhx
to each object x of A. The composition is obvious. We shall call an arrow
of A ‚àí‚ÜíB a transformation.
‚Ä¢ The tensor product may be described in terms of a universal property: it
is the universal D for which one has, for each object x of A, a functor
hx : B ‚àí‚ÜíD and for each object y of B, a functor ky : A ‚àí‚ÜíD such
that hxy = kyx for each (x, y). The unit of the tensor product is the unit
category.
Explicitly, the tensor product A ‚äóB of A and B has as object set ObA √ó
ObB, and an arrow from (x, y) to (x‚Ä≤, y‚Ä≤) consists of a Ô¨Ånite sequence of non-
identity arrows, with alternate arrows forming a directed path in A, and the
others forming a directed path in B. Composition is given by concatenation,
then cancellation accorded by the composition of A and B. The symmetry is
obvious.
It is routine to verify that if, in addition to having Ô¨Ånite limits, C is co-
complete and cartesian closed, the other symmetric monoidal closed structure
extends to Cat(C).
We are now in position to state our theorem relating
Cat(C) to Graph(C):
Theorem 3.5 For a cocomplete cartesian closed category C with Ô¨Ånite lim-
its, the forgetful functor U : Cat(C) ‚àí‚ÜíGraph(C) is part of a symmetric
monoidal closed adjunction with respect to the other tensor product on Cat(C)
and the above symmetric monoidal closed structure on Graph(C).
Proof. For a proof, consider the case that C is Set and simply internalise the
argument there.
2
Note that a corresponding result does not hold for the cartesian closed
structures of Cat(C) and Graph(C) even in the case of C = Set, so we regard
this result as strong evidence of the naturalness of this structure. Finally, in
this vein, we observe
Theorem 3.6 For cartesian closed C with Ô¨Ånite coproducts, the forgetful
functor from Graph(C) to C is part of a symmetric monoidal closed adjunc-
243

Power and Tourlas
Fig. 5. Completion of a simple higraph, where the added edges are shown dashed.
tion with respect to the above symmetric monoidal structure on Graph(C).
Proof. For a proof, consider the proof in the case of C = Set and routinely
internalise it to C.
2
Again, even in the case of C = Set, a corresponding result does not hold in
respect of the cartesian closed structure of Graph(C) as the left adjoint does
not preserve the unit, i.e., it does not send 1 to the terminal object of Graph
as the latter has an edge.
4
A completion operation
A construction useful in understanding the semantics of higraphs and variants
(for instance that involving the categories BSup or œâ-Cpo) is to explicate all
edges which are understood as being implicitly present in a higraph (recall
the discussion near the end of Section 2.2). This ‚Äúcompletion‚Äù operation is
illustrated in Figure 5.
DeÔ¨Ånition 4.1 Let œá = s, t : E ‚àí‚ÜíB be a higraph. The higraph T(œá), called
the completion of œá, has blobs B and edges the subset of E√ó(B√óB) consisting
of those pairs ‚ü®e, ‚ü®b, b‚Ä≤‚ü©‚ü©such that b ‚â§B s(e) and b‚Ä≤ ‚â§B t(e), partially ordered
pointwise, with source and target given by projections.
2
DeÔ¨Ånition 4.2 Given a locally ordered category C, we denote by Graphopl(C)
the locally ordered category whose objects are graphs in C and whose arrows
are oplax transformations, i.e. pairs (fE : E ‚àí‚ÜíE‚Ä≤, fV : V ‚àí‚ÜíV ‚Ä≤) such that
fV s ‚â§s‚Ä≤fE and fV t ‚â§t‚Ä≤fE, with local order structure induced by that of C. 2
To state our theorem, it is convenient to use a little of the theory of 2-
categories, speciÔ¨Åcally some Ô¨Ånite limits. A convenient account of such limits
is [7]. In particular, we need to use the notion of an oplax limit of a map. So
we recall it here.
DeÔ¨Ånition 4.3 Given an arrow f : X ‚àí‚ÜíY in a locally ordered category C,
244

Power and Tourlas
an oplax limit of f is given by a diagram of the form
L
œÄo
- X
‚â§
L
id
?
œÄ1
- Y
f
?
satisfying two properties:
‚Ä¢ for any other diagram of the form
K
h0
- X
‚â§
K
id
?
h1
- Y
f
?
there is a unique arrow u : K ‚àí‚ÜíL such that œÄ0u = h0 and œÄ1u = h1, and
‚Ä¢ (the two-dimensional property) for any two diagrams of the form
K
h0
- X
K
h
‚Ä≤
0
- X
‚â§
‚â§
K
id
?
h1
- Y
f
?
K
id
?
h
‚Ä≤
1
- Y
f
?
with h0 ‚â§h
‚Ä≤
0 and h1 ‚â§h
‚Ä≤
1, it follows that u ‚â§u‚Ä≤.
2
Theorem 4.4 If the locally ordered category C has Ô¨Ånite limits, then the in-
clusion of Graph(C) into Graphopl(C) has a right adjoint.
Proof. Given a graph G = (E, V, s, t), the right adjoint has vertex object
given by V and object of edges given by the oplax limit of the map ‚ü®s, t‚ü©:
E ‚àí‚ÜíV √ó V .
It is a routine exercise in 2-categories to prove that this
construction yields a right adjoint.
2
The 2-category theory expert will observe that we have only used pie-limits
in C, which may become important in due course [11]. Perhaps a more familiar
expression for the oplax limit used in the proof is in terms of a comma object
in C from the identity map on V √ó V to the map ‚ü®s, t‚ü©: E ‚àí‚ÜíV √ó V . If
245

Power and Tourlas
F
A
B
C
D
E
F
A
E
Fig. 6. Zooming out of a blob in a higraph
C were the locally ordered category Poset, then the right adjoint could be
described explicitly by placing an edge from v to v‚Ä≤ if there is an edge from a
vertex greater than or equal to v to a vertex greater than or equal to v‚Ä≤ in G.
This matches exactly our explicit description of T in DeÔ¨Ånition 4.1.
Dually, if C has Ô¨Ånite colimits, the inclusion of Graph(C) into Graphopl(C)
has a left adjoint.
5
Zooming out
We begin by recalling Harel‚Äôs simple instance of a zooming operation on hi-
graphs: the selection of a single blob and the subsequent removal from view
of all blobs contained in it. An example is illustrated in the transition from
the left to the right half of Figure 6.
To capture the notion of selecting a blob in a higraph we need the following:
DeÔ¨Ånition 5.1 A pointed higraph œà consists of an ordinary higraph œá =
s, t : E ‚àí‚ÜíB together with a distinguished blob, given as a map 1 ‚àí‚ÜíB
in Poset and called the point of œà. The category H‚ãÜhas pointed higraphs
as its objects and maps those ones which preserve points. Let H‚ãÜ,min be the
full subcategory of H‚ãÜconsisting of all objects (pointed higraphs) in which the
point is minimal wrt. the partial order on blobs; in other words, the point is
an atomic blob. Let I be the full functor including H‚ãÜ,min into H‚ãÜ.
2
Consider a pointed higraph œà with œá = (s, t : E ‚àí‚ÜíB) and point, say,
p ‚ààB. The pointed higraph Z(œà), obtained by zooming out of the point in
œà, is determined by the following data:
‚Ä¢ blobs: B‚Ä≤ = B \ {b | b < p} (ordered by the restriction to B‚Ä≤ of the partial
order on B);
‚Ä¢ edges: E, with the source and target functions being q ‚ó¶s and q ‚ó¶t respec-
tively, where q : B ‚àí‚ÜíB‚Ä≤ is the (obviously monotone) function mapping
each b Ã∏< p in B to b ‚ààB‚Ä≤ and each b < p to p ‚ààB‚Ä≤;
‚Ä¢ point: p
One now has the following [13]:
Proposition 5.2 The function Z extends to a functor from H‚ãÜto H‚ãÜ,min
which is left adjoint to the inclusion functor I.
2
This proposition will be shown an instance of Theorem 5.5 below. Gener-
246

Power and Tourlas
alising the essential structure underlying our leading example one has:
DeÔ¨Ånition 5.3 Given a locally ordered category C, denote by Graph(C)‚àóthe
locally ordered category for which an object consists of a graph (E, V, s, t) in
C together with a map v : 1 ‚àí‚ÜíV in C. The maps are pairs of maps that
strictly preserve the structure.
2
DeÔ¨Ånition 5.4 Given a locally ordered category C, denote by Graph(C)‚àómin
the locally ordered full subcategory of Graph(C)‚àósuch that the point v : 1 ‚àí‚Üí
V is a minimal element in the poset C(1, V ).
2
Theorem 5.5 If C is a cocomplete locally ordered category, then the inclusion
of Graph(C)‚àómin in Graph(C)‚àóhas a left adjoint.
Proof. Given (E, V, s, t) and v : 1 ‚àí‚ÜíV , take the joint coequaliser of v with
all of the elements of the poset C(1, V ) that are less than or equal to it. It is
routine to verify that this gives the left adjoint.
2
Example 5.6 For graphs in BSup the theorem gives the expected generali-
sation of the zoom-out operation on graphs in Poset in the presence of the
extra structure given by binary sups. However, zoom-outs do not generalise to
graphs in Rel, or the category of posets and relations between their underlying
sets, as the terminal object is the empty set (poset).
6
Further work
Our aim is to develop, in an incremental and principled way, structures which
bear suÔ¨Écient detail to model realistic diagrammatic notations. Currently we
are working towards providing such a model for a large class of Statecharts,
which include features found in higraphs and hypergraphs. The work herein
presented lays the abstract foundations for our approach, in which notions of
graph and combinations thereof may be studied.
Another strand of our work is to study extensions to such notions of graph,
as required to support users in performing speciÔ¨Åcation and reasoning tasks
with diagrams. For instance, a mild extension to higraphs was brieÔ¨Çy intro-
duced by Harel in [5], permitting edges to be ‚Äúloosely‚Äù attached to nodes, the
four possibilities being illustrated in
A
B
E
F
.
The rationale was to indicate transitions or relations between some as yet
unspeciÔ¨Åed, or purposefully omitted (e.g. as the result of zooming out) parts
of the represented system. For motivation and details the reader is referred
to [13]. We conclude by noting that such graphs with ‚Äúloose edges‚Äù can be
added easily to our framework, provided that the locally ordered category C
247

Power and Tourlas
has Ô¨Ånite (pie) colimits, thereby allowing one to deÔ¨Åne tensors with the arrow
poset.
References
[1] M. Barr and C. Wells. Category Theory for Computing Science. Prentice-Hall,
1990.
[2] F. Foltz, C.M. Kelly, and C. Lair.
Algebraic categories with few monoidal
biclosed structures or none. Journal of Pure and Applied Algebra, 17:171‚Äì177,
1980.
[3] Corin Gurr and Konstantinos Tourlas.
Towards the principled design of
software engineering diagrams.
In Proceedings of the 22nd International
Conference on Software Engineering, pages 509‚Äì520. ACM, IEEE Computer
Society, ACM Press, 2000.
[4] David Harel. Statecharts: A visual approach to complex systems. Science of
Computer Programming, 8(3):231‚Äì275, 1987.
[5] David Harel. On visual formalisms. Communications of the ACM, 31(5):514‚Äì
530, 1988.
[6] David Harel and Amnon Naamad. The STATEMATE semantics of Statecharts.
ACM Transactions on Software Engineering Methodology, 5(4), October 1996.
[7] G.M. Kelly.
Elementary observations on 2-categorical limits.
Bull. Austral.
Math. Soc., pages 301‚Äì317, 1989.
[8] F. Maraninchi. The Argos language: Graphical representation of automata and
description of reactive systems. In Proceedings of the IEEE Workshop on Visual
Languages, 1991.
[9] Bonnie M. Nardi. A Small Matter of Programming: Perspectives on End-User
Computing. MIT Press, 1993.
[10] Rob Pooley and Perdita Stevens. Using UML. Addison Wesley, 1999.
[11] A.J. Power and E.P. Robinson. A characterization of pie-limits. Math. Proc.
Cambridge Philos. Soc., 110:33‚Äì47, 1991.
[12] John Power and Edmund Robinson.
Premonoidal categories and notions of
computation. Mathematical Structures in Comp. Science, 11, 1993.
[13] John Power and Konstantinos Tourlas. An algebraic foundation for higraphs.
Submitted for publication, March 2001.
248

MFPS 17 Preliminary Version
Comparing Control Constructs by
Double-barrelled CPS Transforms
Hayo Thielecke
H.Thielecke@cs.bham.ac.uk
School of Computer Science
University of Birmingham
Birmingham
United Kingdom
Abstract
We investigate continuation-passing style transforms that pass two continuations.
Altering a single variable in the translation of Œª-abstraction gives rise to diÔ¨Äerent
control operators: Ô¨Årst-class continuations; dynamic control; and (depending on
a further choice of a variable) either the return statement of C; or Landin‚Äôs J-
operator. In each case there is an associated simple typing. For those constructs
that allow upward continuations, the typing is classical, for the others it remains
intuitionistic, giving a clean distinction independent of syntactic details.
1
Introduction
Control operators come in bewildering variety.
Sometimes the same term
is used for distinct constructs, as with catch in early Scheme or throw in
Standard ML of New Jersey, which are very unlike the catch and throw
in Lisp whose names they borrow. On the other hand, this Lisp catch is
fundamentally similar to exceptions despite their dissimilar and much more
ornate appearance.
Fortunately it is sometimes possible to glean some high-level ‚Äúlogical‚Äù view
of a programming language construct by looking only at its type. SpeciÔ¨Åcally
for control operations, GriÔ¨Én‚Äôs discovery [3] that call/cc and related op-
erators can be ascribed classical types gives us the fundamental distinction
between languages that have such classical types and those that do not, even
though they may still enjoy some form of control. This approach complements
comparisons based on contextual equivalences [10,14].
Such a comparison would be diÔ¨Écult unless we blot out complication.
In particular, exceptions are typically tied in with other, fairly complicated
features of the language which are not relevant to control as such: in ml
with the datatype mechanism, in Java with object-orientation. In order to
This is a preliminary version. The Ô¨Ånal version will be published in
Electronic Notes in Theoretical Computer Science
URL: www.elsevier.nl/locate/entcs

Thielecke
simplify, we Ô¨Årst strip down control operators to the bare essentials of labelling
and jumping, so that there are no longer any distracting syntactic diÔ¨Äerences
between them. The grammar of our toy language is uniformly this:
M ::= x | Œªx.M | MM | here M | go M.
The intended meaning of here is that it labels a ‚Äúprogram point‚Äù or expression
without actually naming any particular label‚Äîjust uttering the demonstrative
‚Äúhere‚Äù, as it were. Correspondingly, go jumps to a place speciÔ¨Åed by a here,
without naming the ‚Äúto‚Äù of a goto.
Despite the simplicity of the language, there is still scope for variation:
not by adding bells and whistles to here and go, but by varying the meaning
of Œª-abstraction. Its impact can be seen quite clearly in the distinction be-
tween exceptions and Ô¨Årst-class continuations. The diÔ¨Äerence between them
is as much due to the meaning of Œª-abstraction as due to the control operators
themselves, since Œª-abstraction determines what is statically put into a closure
and what is passed dynamically. Readers familiar with, say, Scheme imple-
mentations will perhaps not be surprised about the impact of what becomes
part of a closure. But the point of this paper is twofold:
‚Ä¢ small variations in the meaning of Œª completely change the meaning of our
control operators;
‚Ä¢ we can see these diÔ¨Äerences at an abstract, logical level, without delving
into the innards of interpreters.
We give meaning to the Œª-calculus enriched with here and go by means
of continuations in Section 2, examining in Sections 3‚Äì5 how variations on Œª-
abstraction determine what kind of control operations here and go represent.
For each of these variations we present a simple typing, which agrees with the
transform (Section 6). We conclude by explaining the signiÔ¨Åcance of these
typings in terms of classical and intuitionistic logic (Section 7).
2
Double-barrelled CPS
Our starting point is a continuation-passing style (cps) transform. This trans-
form is double-barrelled in the sense that it always passes two continuations.
Hence the clauses start with Œªkq. . . . instead of Œªk. . . .. Other than that, this
cps transform is in fact a very mild variation on the usual call-by-value one [8].
As indicated by the ? , we leave one variable, the extra continuation passed
to the body of a Œª-abstraction, unspeciÔ¨Åed.
[[x]] = Œªkq.kx
[[Œª?x.M]] = Œªks.k(Œªxrd.[[M]]r ? )
[[MN]] = Œªkq.[[M]](Œªm.[[N]](Œªn.mnkq)q)q
[[here M]] = Œªkq.[[M]]kk
[[go M]] = Œªkq.[[M]]qq
The extra continuation may be seen as a jump continuation, in that its
250

Thielecke
manipulation accounts for the labelling and jumping. This is done symmet-
rically: here makes the jump continuation the same as the current one k,
whereas go sets the current continuation of its argument to the jump contin-
uation q. The clauses for variables and applications do not interact with the
additional jump continuation: the former ignores it, while the latter merely
distributes it into the operator, the operand and the function call.
Only in the clause for Œª-abstraction do we face a design decision. Depend-
ing on which continuation (static s, dynamic d, or the return continuation
r) we Ô¨Åll in for ‚Äú?‚Äù in the clause for Œª, there are three diÔ¨Äerent Ô¨Çavours of
Œª-abstraction.
[[Œªsx.M]] = Œªks.k(Œªxrd.[[M]]r s )
[[Œªdx.M]] = Œªks.k(Œªxrd.[[M]]r d )
[[Œªrx.M]] = Œªks.k(Œªxrd.[[M]]r r )
The lambdas are subscripted to distinguish them, and the box around the last
variable is meant to highlight that this is the crucial diÔ¨Äerence between the
transforms. Formally there is also a fourth possibility, the outer continuation
k, but this seems less meaningful and would not Ô¨Åt into simple typing.
For all choices of Œª, the operation go is always a jump to a place speciÔ¨Åed
by a here. For example, for any M, the term here ((Œªx.M)(go N)) should be
equivalent to N, as the go jumps past the M. But in more involved examples
than this, there may be diÔ¨Äerent choices where go can go to among several
occurrences of here. In particular, if s is passed as the second continuation
argument to M in the transform of Œªx.M, then a go in M will refer to the
here that was in scope at the point of deÔ¨Ånition (unless there is an intervening
here, just as one binding of a variable x can shadow another). By contrast,
if d is passed to M in Œªx.M, then the here that is in scope at the point of
deÔ¨Ånition is forgotten; instead go in M will refer to the here that is in scope
at the point of call when Œªx.M is applied to an argument. In fact, depending
upon the choice of variable in the clause for Œª as above, here and go give rise
to diÔ¨Äerent control operations:
‚Ä¢ Ô¨Årst-class continuations like those given by call/cc in Scheme [4];
‚Ä¢ dynamic control in the sense of Lisp, and typeable in a way reminiscent of
checked exceptions;
‚Ä¢ a return-operation, which can be reÔ¨Åned into the J-operator invented by
Landin in 1965 and ancestral to call/cc [4,6,7,13].
We examine these constructs in turn, giving a simple type system in each
case. An unusual feature of these type judgements is that, because we have
two continuations, there are two types in the succedent on the right of the
turnstile, as in
Œì ‚ä¢M : A, B.
The Ô¨Årst type on the right accounts for the case that the term returns a value;
it corresponds to the current continuation. The second type accounts for the
251

Thielecke
Fig. 1. Typing for static here and go
Œì, x : A, Œì‚Ä≤ ‚ä¢s x : A, C
Œì ‚ä¢s M : B, B
Œì ‚ä¢s here M : B, C
Œì ‚ä¢s M : B, B
Œì ‚ä¢s go M : C, B
Œì, x : A ‚ä¢s M : B, C
Œì ‚ä¢s Œªsx.M : A ‚ÜíB, C
Œì ‚ä¢s M : A ‚ÜíB, C
Œì ‚ä¢s N : A, C
Œì ‚ä¢s MN : B, C
jump continuation. In logical terms, the comma on the right may be read as
a disjunction. It makes a big diÔ¨Äerence whether this disjunction is classical
or intuitionistic. That is our main criterion of comparing and contrasting the
control constructs.
3
First-class continuations
The Ô¨Årst choice of which continuation to pass to the body of a function is
arguably the cleanest.
Passing the static continuation s gives control the
same static binding as ordinary Œª-calculus variables. In the static case, the
transform is this:
[[x]] = Œªkq.kx
[[Œªsx.M]] = Œªks.k(Œªxrd.[[M]]r s )
[[MN]] = Œªkq.[[M]](Œªm.[[N]](Œªn.mnkq)q)q
[[here M]] = Œªkq.[[M]]kk
[[go M]] = Œªkq.[[M]]qq
We type our source language with here and go as in Figure 1.
In logical terms, both here and go are a combined right weakening and
contraction.
By themselves, weakening and contraction do not amount to
much; but it is the combination with the rule for ‚Üí-introduction that makes
the calculus ‚Äúclassical‚Äù, in the sense that there are terms whose types are
propositions of classical, but not of intuitionistic, minimal logic.
To see how ‚Üí-introduction gives classical types, consider Œª-abstracting
over go.
x : A ‚ä¢s go x : B, A
‚ä¢s Œªsx.go x : A ‚ÜíB, A
If we read the comma as ‚Äúor‚Äù, and A‚ÜíB for arbitrary B as ‚Äúnot A‚Äù, then
this judgement asserts the classical excluded middle, ‚Äúnot A or A‚Äù. We build
on the classical type of Œªsx.go x for another canonical example: Scheme‚Äôs
252

Thielecke
call-with-current-continuation (call/cc for short) operator [4].
It is
syntactic sugar in terms of static here and go:
call/cc = Œªsf.(here (f (Œªsx.go x))).
As one would expect [3], the type of call/cc is Peirce‚Äôs law ‚Äúif not A implies
A, then A‚Äù. We derive the judgement
‚ä¢s Œªsf.(here (f (Œªsx.go x))) : ((A ‚ÜíB) ‚ÜíA) ‚ÜíA, C
as follows. Let Œì be the context f : (A ‚ÜíB) ‚ÜíA. Then we derive:
Œì ‚ä¢s f : (A ‚ÜíB) ‚ÜíA, A
Œì, x : A ‚ä¢s x : A, A
Œì, x : A ‚ä¢s go x : B, A
Œì ‚ä¢s Œªsx.go x : A ‚ÜíB, A
Œì ‚ä¢s (f (Œªsx.go x)) : A, A
Œì ‚ä¢s here (f (Œªsx.go x)) : A, C
‚ä¢s Œªsf.(here (f (Œªsx.go x))) : ((A ‚ÜíB) ‚ÜíA) ‚ÜíA, C
As another example, let Œì be any context, and assume we have Œì ‚ä¢s M : A, B.
Right exchange is admissible in that we can also derive Œì ‚ä¢s M ‚Ä≤ : B, A for
some M ‚Ä≤.
In the typing of call/cc, a go is (at least potentially, depending on f)
exported from its enclosing here. Conversely, in the derivation of right ex-
change, a go is imported into a here from without. What makes everything
work is static binding.
4
Dynamic control
Next we consider the dynamic version of here and go. The word ‚Äúdynamic‚Äù
is used here in the sense of dynamic binding and dynamic control in Lisp.
Another way of phrasing it is that with a dynamic semantics, the here that
is in scope at the point where a function is called will be used, as opposed to
the here that was in scope at the point where the function was deÔ¨Åned‚Äîthe
latter being used for the static semantics.
In the dynamic case, the transform is this:
[[x]] = Œªkq.kx
[[Œªdx.M]] = Œªks.k(Œªxrd.[[M]]r d )
[[MN]] = Œªkq.[[M]](Œªm.[[N]](Œªn.mnkq)q)q
[[here M]] = Œªkq.[[M]]kk
[[go M]] = Œªkq.[[M]]qq
In this transform, the jump continuation acts as a handler continuation; since
it is passed as an extra argument on each call, the dynamically enclosing
handler is chosen. Hence under the dynamic semantics, here and go become
a stripped-down version of Lisp‚Äôs catch and throw with only a single catch
253

Thielecke
Fig. 2. Typing for dynamic here and go
Œì, x : A, Œì‚Ä≤ ‚ä¢d x : A, C
Œì ‚ä¢d M : B, B
Œì ‚ä¢d here M : B, C
Œì ‚ä¢d M : B, B
Œì ‚ä¢d go M : C, B
Œì, x : A ‚ä¢d M : B, C
Œì ‚ä¢d Œªdx.M : A ‚ÜíB ‚à®C, D
Œì ‚ä¢d M : A ‚ÜíB ‚à®C, C
Œì ‚ä¢d N : A, C
Œì ‚ä¢d MN : B, C
tag. These catch and throw operation are themselves a no-frills version of
exceptions with only identity handlers. We can think of here and go as a
special case of these more elaborate constructs:
here M ‚â°(catch ‚Äôe M)
go M ‚â°(throw ‚Äôe M)
Because the additional continuation is administered dynamically, we can-
not Ô¨Åt it into our simple typing without annotating the function type. So for
dynamic control, we write the function type as A ‚ÜíB ‚à®C. Syntactically, this
should be read as a single operator with the three arguments in mixÔ¨Åx. We
regard the type system as a variant of intuitionistic logic in which ‚Üíand ‚à®
always have to be introduced or eliminated together.
This annotated arrow can be seen as an idealization of the Java throws
clause in method deÔ¨Ånitions, in that A ‚ÜíB ‚à®C could be written as
B(A) throws C
in a more Java-like syntax. A function of type A ‚ÜíB ‚à®C may throw things
of type C, so it may only be called inside a here with the same type. Our
typing for the language with dynamic here and go is presented in Figure 2.
We do not attempt to idealize the ML way of typing exceptions because
ML uses a universal type exn for exceptions, in eÔ¨Äect allowing a carefully
delimited area of untypedness into the language. The typing of ML exceptions
is therefore much less informative than that of checked exceptions.
Note that here and go are still the same weakening and contraction hybrid
as in the static setting. But here their signiÔ¨Åcance is a completely diÔ¨Äerent one
because the ‚Üí-introduction is coupled with a sort of ‚à®-introduction. To see
the diÔ¨Äerence, recall that in the static setting Œª-abstracting over a go reiÔ¨Åes
the jump continuation and thereby, at the type level, gives rise to classical
disjunction.
This is not possible with the version of Œª that gives go the
dynamic semantics. Consider the following inference:
x : A ‚ä¢d go x : B, A
‚ä¢d Œªdx.go x : A ‚ÜíB ‚à®A, C
254

Thielecke
The C-accepting continuation at the point of deÔ¨Ånition is not accessible to the
go inside the Œªd. Instead, the go refers only to the A-accepting continuation
that will be available at the point of call. Far from the excluded middle, the
type of Œªdx.go x is thus ‚ÄúA implies A or B; or anything‚Äù.
In the same vein, as a further illustration how fundamentally diÔ¨Äerent the
dynamic here and go are from the static variety, we revisit the term that, in
the static setting, gave rise to call/cc with its classical type:
Œªf.here (f (Œªx.go x)).
Now in the dynamic case, we can only derive the intuitionistic formula
((A ‚ÜíB ‚à®A) ‚ÜíA ‚à®A) ‚ÜíA ‚à®C
as the type of this term.
Let Œì be the context f : (A ‚ÜíB ‚à®A) ‚ÜíA ‚à®A. Then we have:
Œì ‚ä¢d f : (A ‚ÜíB ‚à®A) ‚ÜíA ‚à®A, A
Œì, x : A ‚ä¢d x : A, A
Œì, x : A ‚ä¢d go x : B, A
Œì ‚ä¢d Œªdx.go x : A ‚ÜíB ‚à®A, A
Œì ‚ä¢d (f (Œªdx.go x)) : A, A
Œì ‚ä¢d here (f (Œªdx.go x)) : A, C
‚ä¢d Œªdf.here (f (Œªdx.go x)) : ((A ‚ÜíB ‚à®A) ‚ÜíA ‚à®A) ‚ÜíA ‚à®C, D
5
Return continuation
Our last choice is passing the return continuation as the extra continuation to
the body of a Œª-abstraction. So the cps transform is this:
[[x]] = Œªkq.qx
[[Œªrx.M]] = Œªks.k(Œªxrd.[[M]]r r )
[[MN]] = Œªkq.[[M]](Œªm.[[N]](Œªn.mnkq)q)q
[[here M]] = Œªkq.[[M]]kk
[[go M]] = Œªkq.[[M]]qq
This transform grants Œªr the additional role of a continuation binder. The
original operator for this purpose, here, is rendered redundant, since here M
is now equivalent to (Œªrx.M)(Œªry.y) where x is not free in M. At Ô¨Årst sight,
binding continuations seems an unusual job for a Œª; but it becomes less so if
we think of go as the return statement of C or Java.
5.1
Non-Ô¨Årst class return
Because the enclosing Œª determines which continuation go jumps to with its
argument, the go-operator has the same eÔ¨Äect as a return statement. The
255

Thielecke
Fig. 3. Typing for go as a return-operation
Œì, x : A, Œì‚Ä≤ ‚ä¢r x : A, C
Œì ‚ä¢r M : B, B
Œì ‚ä¢r go M : C, B
Œì, x : A ‚ä¢r M : B, B
Œì ‚ä¢r Œªrx.M : A ‚ÜíB, C
Œì ‚ä¢r M : A ‚ÜíB, C
Œì ‚ä¢r N : A, C
Œì ‚ä¢r MN : B, C
type of extra continuation assumed by go needs to agree with the return type
of the nearest enclosing Œª:
Œì, x : A ‚ä¢r M : B, B
Œì ‚ä¢r Œªrx.M : A ‚ÜíB, C
The whole type system for the calculus with Œªr is in Figure 3.
The agreement between go and the enclosing Œªr is comparable with the
typing in C, where the expression featuring in a return statement must have
the return type declared by the enclosing function. For instance, M needs to
have type int in the deÔ¨Ånition:
int f(){ . . . return M; . . . }
With Œªr, the special form go cannot be made into a Ô¨Årst-class function. If
we try to Œª-abstract over go x by writing Œªrx.go x then go will refer to that
Œªr.
The failure of Œªr to give Ô¨Årst-class returning can be seen logically as follows.
In order for Œªr to be introduced, both types on the right have to be the same:
x : A ‚ä¢r go x : A, A
‚ä¢r Œªrx.go x : A ‚ÜíA, C
Rather than the classical ‚Äúnot A or A‚Äù this asserts merely the intuitionistic
‚ÄúA implies A; or anything‚Äù.
One has a similar situation in Gnu C, which has both the return statement
and nested functions, without the ability to refer to the return address of
another function. If we admit go as a Ô¨Årst-class function, it becomes a much
more powerful form of control, Landin‚Äôs JI-operator.
5.2
The JI-operator
Keeping the meaning of Œªr as a continuation binder, we now consider a control
operator JI that always refers to the statically enclosing Œªr, but which, unlike
the special form go, is a Ô¨Årst-class expression, so that we can pass the return
continuation to some other function f by writing f(JI).
The cps of this
operator is this:
[[JI]] = Œªks.k(Œªxrd. s x)
That is almost, but not quite, the same as if we tried to deÔ¨Åne JI as Œªrx.go x:
256

Thielecke
Fig. 4. Typing for JI
Œì, x : A, Œì‚Ä≤ ‚ä¢j x : A, C
Œì ‚ä¢j JI : B ‚ÜíC, B
Œì, x : A ‚ä¢j M : B, B
Œì ‚ä¢j Œªrx.M : A ‚ÜíB, C
Œì ‚ä¢j M : A ‚ÜíB, C
Œì ‚ä¢j N : A, C
Œì ‚ä¢j MN : B, C
[[JI]] = [[Œªrx.go x]]
= Œªks.k(Œªxrd. r x)
We can, however, deÔ¨Åne JI in terms of go if we use the static Œªs, that is
JI = Œªsx.go x, as this does not inadvertently shadow the continuation s that
we want JI to refer to.
The whole transform for the calculus with JI is this:
[[x]] = Œªkq.qx
[[Œªrx.M]] = Œªks.k(Œªxrd.[[M]]r r )
[[MN]] = Œªkq.[[M]](Œªm.[[N]](Œªn.mnkq)q)q
[[JI]] = Œªks.k(Œªxrd. s x)
Recall that the role of here has been usurped by Œªr, and we replaced go by
its Ô¨Årst-class cousin JI.
In the transform for JI, the jump continuation is the current ‚Äúdump‚Äù in
the sense of the secd-machine. The dump in the secd-machine is a sort of
call stack, which holds the return continuation for the procedure whose body
is currently being evaluated. Making the dump into a Ô¨Årst-class object was
precisely how Landin invented Ô¨Årst-class control, embodied by the J-operator.
The typing for the language with JI is given in Figure 4. In particular,
the type of JI is the classical disjunction
Œì ‚ä¢j JI : B ‚ÜíC, B
As an example of the type system for the calculus with the JI-operator,
we see that Reynolds‚Äôs [9] deÔ¨Ånition of call/cc in terms of JI typechecks.
(Strictly speaking, Reynolds used escape, the binding-form cousin of call/cc,
but call/cc and escape are syntactic sugar for each other.) We infer the type
of call/cc ‚â°Œªrf.((Œªrk.f k)(JI)) to be:
((A ‚ÜíB) ‚ÜíA) ‚ÜíA)
To write the derivation, we abbreviate some contexts as follows:
Œìfk ‚â°f : (A ‚ÜíB) ‚ÜíA, k : (A ‚ÜíB)
Œìf ‚â°f : (A ‚ÜíB) ‚ÜíA
257

Thielecke
Then we can derive:
Œìfk ‚ä¢j f : (A ‚ÜíB) ‚ÜíA, A
Œìfk ‚ä¢j k : (A ‚ÜíB), A
Œìfk ‚ä¢j f k : A, A
Œìf ‚ä¢j Œªrk.fk : (A ‚ÜíB) ‚ÜíA, A
Œìf ‚ä¢j JI : A ‚ÜíB, A
Œìf ‚ä¢j (Œªrk.f k)(JI) : A, A
‚ä¢j Œªrf.((Œªrk.f k)(JI)) : ((A ‚ÜíB) ‚ÜíA) ‚ÜíA), C
Because JI has such evident logical meaning as classical disjunction, we
have considered it as basic. Landin [6] took another operator, called J, as
primitive, while JI was derived as the special case of J applied to the identity
combinator:
J I = J (Œªx.x)
This explains the name ‚ÄúJI‚Äù, as ‚ÄúJ‚Äù stands for ‚Äújump‚Äù and I for ‚Äúidentity‚Äù.
We were able to start with JI, since (as noted by Landin) the J-operator is
syntactic sugar for JI by virtue of:
J = (Œªrr.Œªrf.Œªrx.r(fx)) (JI).
To accommodate J in our typing, we use this deÔ¨Ånition in terms of JI to
derive the following type for J:
‚ä¢j J : (A ‚ÜíB) ‚Üí(A ‚ÜíC), B
Let Œì be the context x : A, r : B ‚ÜíC, f : A ‚ÜíB. We derive:
Œì ‚ä¢j r : B ‚ÜíC, C
Œì ‚ä¢j f : A ‚ÜíB, C
Œì ‚ä¢j x : A, C
Œì ‚ä¢j fx : B, C
Œì ‚ä¢j r(fx) : C, C
r : B ‚ÜíC, f : A ‚ÜíB ‚ä¢j Œªrx.r(fx) : A ‚ÜíC, A ‚ÜíC
r : B ‚ÜíC ‚ä¢j Œªrf.Œªrx.r(fx) : (A ‚ÜíB) ‚Üí(A ‚ÜíC), (A ‚ÜíB) ‚Üí(A ‚ÜíC)
‚ä¢j Œªrr.Œªrf.Œªrx.r(fx) : (B ‚ÜíC) ‚Üí(A ‚ÜíB) ‚Üí(A ‚ÜíC), B
‚ä¢j (Œªrr.Œªrf.Œªrx.r(fx)) (JI) : (A ‚ÜíB) ‚Üí(A ‚ÜíC), B
This type reÔ¨Çects the behaviour of the J-operator in the secd machine.
When J is evaluated, it captures the B-accepting current dump continuation;
it can then be applied to a function of type A‚ÜíB. This function is composed
with the captured dump, yielding a non-returning function of type A‚ÜíC, for
arbitrary C. By analogy with call-with-current-continuation, we may
read the J-operator as ‚Äúcompose-with-current-dump‚Äù [13].
The logical signiÔ¨Åcance, if any, of the extra function types in the general
J seems unclear. There is a curious, though vague, resemblance to exception
handlers in dynamic control, since they too are functions only to be applied
on jumping. This feature of J may be historical, as it arose in a context where
258

Thielecke
greater emphasis was given to attaching dumps to functions than to dumps
as Ô¨Årst-class continuations in their own right.
6
Type preservation
The typings agree with the transforms in that they are preserved in the usual
way for cps transforms: we have a ‚Äúdouble-negation‚Äù transform for types,
contexts and judgements.
The only (slight) complication is in typing the
dynamic continuation in those transforms that ignore it.
The function type of the form A ‚ÜíB ‚à®C for the dynamic semantics is
translated as follows:
[[A ‚ÜíB ‚à®C]] = [[A]] ‚Üí([[B]] ‚ÜíAns) ‚Üí([[C]] ‚ÜíAns) ‚ÜíAns
Each call expects not only the B-accepting return continuation, but also the
C-accepting continuation determined by the here that encloses the call.
Because we have not varied the transform of application, functions deÔ¨Åned
with Œªs and Œªr are also passed this dynamic continuation, even though they
ignore it:
[[Œªsx.M]] = Œªks.k(Œªxrd.[[M]]r s )
[[Œªrx.M]] = Œªks.k(Œªxrd.[[M]]r r )
In both of these cases, the dynamic jump continuation d is fed to each function
call, but never needed. Each function deÔ¨Ånition must expect this argument
to be of certain type. Because diÔ¨Äerent calls of the same function may have
dynamically enclosing here operators with diÔ¨Äerent types, the type ascribed
to d should be polymorphic.
So the function type of the form A‚ÜíB is transformed so as to accept this
unwanted argument polymorphically:
[[A ‚ÜíB]] = ‚àÄŒ≤.[[A]] ‚Üí([[B]] ‚ÜíAns) ‚ÜíŒ≤ ‚ÜíAns
That is, a function of type A ‚ÜíB accepts an argument of type A, a B-
accepting return continuation, and the continuation determined by the here
dynamically enclosing the call.
For all the transforms we have preservation of the respective typing: if
Œì ‚ä¢? M : A, B, then
[[Œì]] ‚ä¢[[M]] : ([[A]] ‚ÜíAns) ‚Üí([[B]] ‚ÜíAns) ‚ÜíAns.
The proof is a straightforward induction over the derivation.
As a typical example, consider how the classical axiom of excluded middle
‚ä¢j JI : A ‚ÜíB, A
is translated to the Œª-term [[JI]] = Œªks.k(Œªxrd.rx) with the type
((‚àÄŒ≤.[[A]] ‚Üí([[B]] ‚ÜíAns) ‚ÜíŒ≤ ‚ÜíAns) ‚ÜíAns) ‚Üí([[A]] ‚ÜíAns) ‚ÜíAns.
259

Thielecke
Fig. 5. Comparison of the type systems as logics
Static here and go, implies call/cc
Œì ‚ä¢s B, B
Œì ‚ä¢s B, C
Œì ‚ä¢s B, B
Œì ‚ä¢s C, B
Œì, A, Œì‚Ä≤ ‚ä¢s A, C
Œì, A ‚ä¢s B, C
Œì ‚ä¢s A ‚ÜíB, C
Œì ‚ä¢s A ‚ÜíB, C
Œì ‚ä¢s A, C
Œì ‚ä¢s B, C
Dynamic here and go, like checked exceptions
Œì ‚ä¢d B, B
Œì ‚ä¢d B, C
Œì ‚ä¢d B, B
Œì ‚ä¢d C, B
Œì, A, Œì‚Ä≤ ‚ä¢d A, C
Œì, A ‚ä¢d B, C
Œì ‚ä¢d A ‚ÜíB ‚à®C, D
Œì ‚ä¢d A ‚ÜíB ‚à®C, C
Œì ‚ä¢d A, C
Œì ‚ä¢d B, C
Non-Ô¨Årst class return-operation
Œì ‚ä¢r B, B
Œì ‚ä¢r C, B
Œì, A, Œì‚Ä≤ ‚ä¢r A, C
Œì, A ‚ä¢r B, B
Œì ‚ä¢r A ‚ÜíB, C
Œì ‚ä¢r A ‚ÜíB, C
Œì ‚ä¢r A, C
Œì ‚ä¢r B, C
Landin‚Äôs JI-operator
Œì ‚ä¢j B ‚ÜíC, B
Œì, A, Œì‚Ä≤ ‚ä¢j A, C
Œì, A ‚ä¢j B, B
Œì ‚ä¢j A ‚ÜíB, C
Œì ‚ä¢j A ‚ÜíB, C
Œì ‚ä¢j A, C
Œì ‚ä¢j B, C
7
Conclusions
As a summary of the four control constructs we have considered, we present
their typings in Figure 5, omitting the terms for conciseness. As logical sys-
tems, these toy logics may seem a little eccentric, with two succedents that can
only be manipulated in a slightly roundabout way. But they are suÔ¨Écient for
our purposes here, which is to illustrate the correspondence of Ô¨Årst-class con-
tinuations with classical logic and weaker control operation with intuitionistic
logic, and the central role of the arrow type in this dichotomy.
Recall the following fact from proof theory (see for example [15]). Suppose
260

Thielecke
one starts from a presentation of intuitionistic logic with sequents of the form
Œì ‚ä¢‚àÜ. If a rule like the following is added that allows ‚Üí-introduction even if
there are multiple succedents, the logic becomes classical.
Œì, A ‚ä¢B, ‚àÜ
Œì ‚ä¢A ‚ÜíB, ‚àÜ
In continuation terms, the signiÔ¨Åcance of this rule is that the function clo-
sure of type A ‚ÜíB may contain any of the continuations that appear in ‚àÜ;
to use the jargon, these continuations become ‚ÄúreiÔ¨Åed‚Äù. The fact that the
logic becomes classical means that once we can have continuations in func-
tion closures, we gain Ô¨Årst-class continuations and thereby the same power as
call/cc. We have this form of rule for static here and go; though not for JI,
since JI as the excluded middle is already blatantly classical by itself.
But the logic remains intuitionistic if the ‚Üí-introduction is restricted. The
rule for this case typically admits only a single formula on the right:
Œì, A ‚ä¢B
Œì ‚ä¢A ‚ÜíB, ‚àÜ
Considered as a restriction on control operators, this rule prohibits Œª-abstraction
for terms that contain free continuation variables. There are clearly other pos-
sibilities how we can prevent assumptions from ‚àÜto become hidden (in that
they can be used in the derivation of A ‚ÜíB without showing up in this type
itself). We could require these assumptions to remain explicit in the arrow
type, by making ‚àÜa singleton that either coincides with the B on the right
of the arrow, or is added to it:
Œì, A ‚ä¢r B, B
Œì ‚ä¢r A ‚ÜíB, C
Œì, A ‚ä¢d B, C
Œì ‚ä¢d A ‚ÜíB ‚à®C, D
These are the rules for ‚Üí-introduction in connection with the return-operation,
and dynamic here and go, respectively. Neither of which gives rise to Ô¨Årst-
class continuations, corresponding to the fact that with these restrictions on
‚Üí-introduction the logics remain intuitionistic.
The distinction between static and dynamic control in logical terms ap-
pears to be new, as is the logical explanation of Landin‚Äôs JI-operator.
7.1
Related work
Following GriÔ¨Én [3], there has been a great deal of work on classical types
for control operators, mainly on call/cc or minor variants thereof. A similar
cps transforms for dynamic control (exceptions) has appeared in [5], albeit
for a very diÔ¨Äerent purpose. Felleisen describes the J-operator by way of cps,
but since his transform is not double-barrelled, J means something diÔ¨Äerent
in each Œª [2]. Variants of the here and go operators are even older than the
notion of continuation itself: the operations valof and resultis from cpl
later appeared in Strachey and Wadsworth‚Äôs report on continuations [11,12].
261

Thielecke
These operators led to the modern return in C. As we have shown here, they
lead to much else besides if combined with diÔ¨Äerent Ô¨Çavours of Œª.
7.2
Further work
In this paper, control constructs were compared by cps transforms and typing
of the source. A diÔ¨Äerent, but related approach compares them by typing in
the target of the cps [1]. On the source, we have the dichotomy between
intuitionistic and classical typing, whereas on the target, the distinction is
between linear and intuitionistic. We hope to relate these in further work.
References
[1] Berdine, J., P. W. O‚ÄôHearn, U. Reddy and H. Thielecke, Linearly used
continuations, in: A. Sabry, editor, Proceedings of the 3rd ACM SIGPLAN
Workshop on Continuations, 2001.
[2] Felleisen, M., ReÔ¨Çections on Landin‚Äôs J operator: a partly historical note.,
Computer Languages 12 (1987), pp. 197‚Äì207.
[3] GriÔ¨Én, T. G., A formulae-as-types notion of control, in: Proc. 17th ACM
Symposium on Principles of Programming Languages, San Francisco, CA USA,
1990, pp. 47‚Äì58.
[4] Kelsey, R., W. Clinger and J. Rees, editors, Revised5 report on the algorithmic
language Scheme, Higher-Order and Symbolic Computation 11 (1998), pp. 7‚Äì
105.
[5] Kim, J., K. Yi and O. Danvy, Assessing the overhead of ML exceptions by
selective CPS transformation, in: Proceedings of the 1998 ACM SIGPLAN
Workshop on ML, 1998.
[6] Landin, P. J., A generalization of jumps and labels, Report, UNIVAC Systems
Programming Research (1965).
[7] Landin, P. J., A generalization of jumps and labels, Higher-Order and Symbolic
Computation 11 (1998), reprint of [6].
[8] Plotkin, G., Call-by-name, call-by-value, and the Œª-calculus, Theoretical
Computer Science 1 (1975), pp. 125‚Äì159.
[9] Reynolds,
J.
C.,
DeÔ¨Ånitional interpreters for higher-order programming
languages, in: Proceedings of the 25th ACM National Conference (1972), pp.
717‚Äì740.
[10] Riecke, J. G. and H. Thielecke, Typed exceptions and continuations cannot
macro-express each other, in: J. Wiedermann, P. van Emde Boas and M. Nielsen,
editors, Proceedings 26th International Colloquium on Automata, Languages
and Programming (ICALP), LNCS 1644 (1999), pp. 635‚Äì644.
262

Thielecke
[11] Strachey, C. and C. P. Wadsworth, Continuations: A mathematical semantics
for handling full jumps, Monograph PRG-11, Oxford University Computing
Laboratory, Programming Research Group, Oxford, UK (1974).
[12] Strachey, C. and C. P. Wadsworth, Continuations: A mathematical semantics
for handling full jumps, Higher-Order and Symbolic Computation 13 (2000),
pp. 135‚Äì152, reprint of [11].
[13] Thielecke, H., An introduction to Landin‚Äôs ‚ÄúA generalization of jumps and
labels‚Äù, Higher-Order and Symbolic Computation 11 (1998), pp. 117‚Äì124.
[14] Thielecke, H., On exceptions versus continuations in the presence of state,
in: G. Smolka, editor, Programming Languages and Systems, 9th European
Symposium on Programming, ESOP 2000,, number 1782 in LNCS (2000), pp.
397‚Äì411.
[15] Troelstra, A. S. and H. Schwichtenberg, ‚ÄúBasic Proof Theory,‚Äù Cambridge
University Press, 1996.
263

264

MFPS
17
Preliminary
Version
Distance
and
Measuremen
t
in
Domain
Theory
P
a
w
e 
l
W
aszkiewicz
Scho
ol
of
Computer
Scienc
e
The
University
of
Birmingham
Birmingham,
Unite
d
Kingdom
Abstract
W
e
in
v
estigate
the
notion
of
distance
on
domains.
In
particular,
w
e
sho
w
that
measuremen
t
is
a
fundamen
tal
concept
underlying
partial
metrics
b
y
pro
ving
that
a
domain
in
its
Scott
top
ology
is
partially
metrizable
only
if
it
admits
a
measuremen
t.
Con
v
ersely
,
the
natural
notion
of
a
distance
asso
ciated
with
a
measuremen
t
not
only
yields
meaningful
partial
metrics
on
domains
of
essen
tial
imp
ortance
in
computa-
tion,
suc
h
as
I
R
,

1
and
P
!
,
it
also
serv
es
as
a
useful
theoretical
device
b
y
allo
wing
one
to
establish
the
existence
of
partial
metrics
on
arbitrary
!
-con
tin
uous
dcp
o's.
1
In
tro
duction
The
theory
b
y
Key
e
Martin,
in
tro
duced
in
[5],
in
v
estigates
domains
equipp
ed
not
only
with
order
but
also
with
a
quan
titativ
e
notion
of
measuremen
t.
The
theory
is
easy
to
understand,
b
eing
based
on
the
\informatic"
in
tuition
b
e-
hind
domain
theory
.
It
is
widely
applicable.
Most
of
the
domains
arising
in
applications
of
domain
theory
ha
v
e
measuremen
ts,
including
the
class
of
all
coun
tably
based
domains.
Tw
o
cen
tral
notions
of
the
theory
are
a
me
a-
sur
ement
and
the
-top
olo
gy
called
here
the
Martin
top
olo
gy.
The
last
one
is
Hausdor
on
a
domain
and
ner
than
b
oth
Scott
and
La
wson
top
ologies.
It
is
w
ell-suited
for
computation:
b
oth
con
tin
uit
y
and
completeness
of
a
domain
can
b
e
describ
ed
in
terms
of
the
Martin
top
ology
.
The
main
theme
of
this
pap
er
is
the
study
of
the
notion
of
distance
on
domains.
Our
w
ork
in
this
direction
is
v
ery
m
uc
h
inspired
b
y
questions
p
osed
b
y
Reinhold
Hec
kmann
in
[4]
and
Key
e
Martin
in
[5].
One
ob
vious
candidate
for
a
distance
on
domains
is
a
partial
metric
suc
h
that
the
partial
metric
top
ology
agrees
with
the
Scott
top
ology
of
the
induced
order
(see
Section
2.2
for
denitions).
Another
one
is
a
symmetric
map
d

built
from
a
measuremen
t

b
y
a
standard
construction.
1
Email:
P.Waszkiewicz@cs
.b
ham
.a
c.u
k
This
is
a
preliminary
v
ersion.
The
nal
v
ersion
will
b
e
published
in
Electronic
Notes
in
Theoretical
Computer
Science
URL:
www.elsevier.nl/loca
te/
ent
cs

W
aszkiewicz
The
rst
problem
of
Hec
kmann's
is
to
c
haracterize
partial
metric
spaces
whic
h
are
con
tin
uous
dcp
o's
with
resp
ect
to
the
induced
order
and
suc
h
that
the
Scott
top
ology
and
the
partial
metric
top
ology
agree.
The
other
c
hallenge
is
to
sho
w
whic
h
con
tin
uous
dcp
o's
are
partially
metrizable.
W
e
sho
w
that
answ
ers
to
b
oth
questions
can
b
e
ac
hiev
ed
b
y
in
tro
ducing
metho
ds
of
measuremen
t
theory
in
to
the
study
of
partial
metric
spaces.
In
Section
3
w
e
sho
w
that
a
con
tin
uous
p
oset,
whic
h
is
partially
metrizable
in
its
Scott
top
ology
m
ust
admit
a
measuremen
t.
Under
some
additional,
mild
restrictions,
the
con
v
erse
also
holds:
if
the
self-distance
mapping
for
the
partial
metric
is
a
measuremen
t,
then
as
a
consequence,
the
partial
metric
top
ology
agrees
with
the
Scott
top
ology
.
Our
thesis
is
that
d

,
called
here
the
distance
function
asso
ciated
with
a
measuremen
t
,
deserv
es
its
name.
W
e
study
its
basic
prop
erties
in
Section
4.
It
is
w
ell-kno
wn
[5
]
that
d

induces
the
Scott
top
ology
.
W
e
pro
v
e
that
it
also
enco
des
the
underlying
order,
in
the
same
fashion
as
partial
metrics
do.
Therefore,
it
is
natural
to
ask
if
d

is
a
partial
metric.
W
e
demonstrate
(see
Section
5)
that
for
arbitr
ary
measuremen
ts
the
answ
er
is
p
ositiv
e
for
a
restricted
class
of
domains,
whic
h
is,
ho
w
ev
er,
large
enough
to
adv
ance
O'Neill's
construction
from
[7].
Our
nal
argumen
t
in
fa
v
our
of
d

b
eing
a
distance
b
et
w
een
elemen
ts
of
a
domain
is
presen
ted
in
the
last
section.
W
e
sho
w
that
ev
ery
!
-con
tin
uous
dcp
o
is
partially
metrizable
and
the
partial
metric
is
the
distance
function
d

asso
ciated
with
some
measuremen
t

on
the
domain.
This
result
solv
es
the
second
problem
of
Hec
kmann's
for
the
class
of
all
coun
tably
based
domains.
1.1
Convention
In
the
pap
er
w
e
adopt
the
follo
wing
con
v
en
tion:
original
results
are
the
n
um-
b
ered
ones
unless
they
are
ac
kno
wledged
explicitly
.
F
or
instance,
all
the
ex-
amples
of
measuremen
ts
on
domains
from
Section
2.5
are
tak
en
from
[5].
2
Bac
kground
2.1
Domain
the
ory
W
e
review
some
basic
notions
from
domain
theory
,
mainly
to
x
the
language
and
notation.
See
[1]
for
more
information.
Let
P
b
e
a
p
oset.
A
pair
of
elemen
ts
x;
y
2
P
is
c
onsistent
(b
ounde
d)
if
there
exists
an
elemen
t
z
2
P
suc
h
that
z
w
x;
y
.
W
e
sa
y
that
a
p
oset
is
b
ounde
d-c
omplete
if
eac
h
b
ounded
pair
of
elemen
ts
has
a
suprem
um.
A
subset
A

P
of
P
is
dir
e
cte
d
if
it
is
nonempt
y
and
an
y
pair
of
elemen
ts
of
A
has
an
upp
er
b
ound
in
A.
If
a
directed
set
A
has
a
suprem
um,
it
is
denoted
F
"
A.
A
p
oset
P
in
whic
h
ev
ery
directed
set
has
a
suprem
um
is
called
a
dcp
o.
Let
x
and
y
b
e
elemen
ts
of
a
p
oset
P
.
W
e
sa
y
that
x
appr
oximates
(is
way-b
elow)
y
if
for
all
directed
subsets
A
of
P
,
y
v
F
"
A
implies
x
v
a
for
266

W
aszkiewicz
some
a
2
A.
W
e
denote
it
as
x

y
.
No
w,
#
#
x
is
the
set
of
all
appro
ximan
ts
of
x
b
elo
w
it.
"
"
x
is
dened
dually
.
W
e
sa
y
that
a
subset
B
of
a
dcp
o
P
is
a
(domain-the
or
etic)
basis
for
P
if
for
ev
ery
elemen
t
x
of
P
,
the
set
#
#
x
\
B
is
directed
with
suprem
um
x.
A
p
oset
is
called
c
ontinuous
if
it
has
a
basis.
It
can
b
e
sho
wn
that
a
p
oset
P
is
con
tin
uous
i
#
#
x
is
directed
with
suprem
um
x,
for
all
x
2
P
.
A
p
oset
is
called
a
domain
if
it
is
a
con
tin
uous
dcp
o.
A
subset
U

P
of
a
p
oset
P
is
upp
er
if
x
w
y
2
U
)
x
2
U
.
Upp
er
sets
inaccessible
b
y
directed
suprema
form
a
top
ology
called
the
Sc
ott
top
olo
gy;
it
is
denoted

P
.
A
domain
admits
a
coun
table
domain-theoretic
basis
i
the
Scott
top
ology
is
second
coun
table.
In
this
case
the
domain
is
called
an
!
-
c
ontinuous
domain.
The
Scott
top
ology
enco
des
the
underlying
order:
x
v
y
in
P
i
8U
2

:
(x
2
U
)
y
2
U
).
This
is
the
general
denition
of
the
so-
called
sp
e
cialisation
or
der
for
a
top
ology
.
The
collection
f"
"
x
j
x
2
D
g
forms
a
basis
for
the
Scott
top
ology
on
a
con
tin
uous
p
oset
D
.
The
Scott
top
ology
satises
only
w
eak
separation
axioms:
it
is
alw
a
ys
T
0
on
a
p
oset
but
T
1
only
if
the
order
is
trivial.
The
top
ology
is
sob
er
on
a
domain
(a
top
ological
space
is
sob
er
i
it
is
T
0
and
ev
ery
nonempt
y
closed
subset
whic
h
is
not
the
union
of
t
w
o
closed
prop
er
subsets
is
the
closure
of
a
p
oin
t).
Sobriet
y
of
a
space
implies
that
the
underlying
sp
ecialisation
order
is
a
dcp
o.
F
or
con
tin
uous
p
osets,
b
eing
a
dcp
o
and
sobriet
y
of
the
Scott
top
ology
are
equiv
alen
t
conditions.
The
p
oset
[0;
1)
op
gures
prominen
tly
in
Martin's
w
ork
and
also
in
this
note.
It
is
a
domain
without
least
elemen
t.
W
e
use
v
to
refer
to
its
order
whic
h
is
dual
to
the
natural
one,
,
and
try
to
a
v
oid
the
latter
en
tirely
.
(
is
used
in
this
pap
er
whenev
er
w
e
w
ork
with
[0;
1).)
2.2
Partial
metrics
W
e
will
briey
review
basic
denitions
and
facts
ab
out
partial
metric
spaces
from
Hec
kmann's
[4]
and
Matthew's
articles
[6].
A
partial
metric
on
a
set
X
is
a
map
p
:
X

X
!
[0;
1)
whic
h
satises
for
all
x;
y
;
z
2
X
,
1.
p(x;
y
)
=
p(y
;
x)
(symmetry),
2.
p(x;
y
)
=
p(x;
x)
=
p(y
;
y
)
implies
x
=
y
(T
0
separation
axiom),
3.
p(x;
y
)

p(x;
z
)
+
p(z
;
y
)
 p(z
;
z
)
(
]
),
4.
p(x;
x)

p(x;
y
)
(SSD
-
\small
self-distances").
If
w
e
abandon
Axiom
4,
p
is
called
a
we
ak
p
artial
metric.
F
rom
the
top
ological
p
oin
t
of
view,
w
eak
partial
metrics
and
partial
metrics
are
equiv
alen
t
since
for
ev
ery
w
eak
partial
metric
p
there
is
a
corresp
onding
one
whic
h
satises
SSD
[4
],
giv
en
b
y
p
0
(x;
y
)
:=
maxfp(x;
y
);
p(x;
x);
p(y
;
y
)g.
The
top
ology

p
induced
b
y
the
partial
metric
p
is
the
top
ology
whic
h
has
267

W
aszkiewicz
a
basis
consisting
of
op
en
balls
of
the
form
B
"
(x)
:=
fy
2
X
j
p(x;
y
)
<
p(x;
x)
+
"g
for
an
x
2
X
and
a
radius
"
>
0.
The
denition
is
w
ell-formed
since
the
collection
of
op
en
balls
indeed
forms
a
basis
for
a
top
ology
on
X
.
The
name
\T
0
separation
axiom"
is
justied
b
y
the
fact
that
it
is
a
nec-
essary
and
su√Ücien
t
condition
for
X
to
b
e
a
T
0
space
w.r.t.

p
.
It
is
not
Hausdor
in
general,
as
the
example
of
the
formal
ball
mo
del
sho
ws.
There-
fore,
the
sp
ecialisation
order
v

P
of

p
will
b
e
non-trivial
in
general.
All
of
the

p
-op
en
sets,
the
op
en
balls
among
them,
are
upp
er
sets
with
resp
ect
to
the
order.
W
e
ha
v
e
that
the
follo
wing
are
equiv
alen
t
for
all
x;
y
2
X
:
1.
x
v

P
y
,
2.
p(x;
y
)
=
p(x;
x),
3.
8"
>
0
y
2
B
"
(x).
W
e
will
sa
y
x
v
p
y
if
one
of
the
ab
o
v
e
conditions
holds.
A
weighte
d
quasi-metric
on
a
set
X
is
a
pair
of
maps
(q
;
w
)
consisting
of
a
quasi-metric
q
:
X
2
!
[0;
1)
(satises
all
metric
axioms
but
symmetry)
and
a
weight
function
w
:
X
!
[0;
1)
where
for
all
x;
y
2
X
,
q
(x;
y
)
+
w
(x)
=
q
(y
;
x)
+
w
(y
).
q
induces
order
and
top
ology
in
the
usual
manner:
for
all
x;
y
2
X
,
x
v
q
y
i
q
(x;
y
)
=
0
and
B
q
"
(x)
=
fy
2
X
j
q
(x;
y
)
<
"g
is
a
basis
for
the
induced
top
ology

q
.
Matthews
[6]
pro
v
es
that
there
is
an
algebraic
equiv
alence
b
et
w
een
a
partial
metric
p
on
X
and
a
w
eigh
ted
quasi-metric
(q
;
w
)
giv
en
b
y
p(x;
y
)
:=
q
(x;
y
)
+
w
(x)
and
con
v
ersely
q
(x;
y
)
:=
p(x;
y
)
 w
(x)
and,
moreo
v
er,
p
and
q
induce
the
same
order
and
top
ology
.
W
e
will
exploit
this
in
the
last
theorem
of
the
pap
er.
Finally
,
for
ev
ery
partial
metric
space
(X
;
p),
if
X
is
equipp
ed
with
the
top
ology

p
induced
b
y
p
and
[0;
1)
op
with
the
Scott
top
ology
,
then
the
map-
ping
p
:
X

X
!
[0;
1)
op
is
con
tin
uous.
Since
ev
ery
con
tin
uous
map
is
monotone
with
resp
ect
to
the
sp
ecialisation
orders
of
its
domain
and
co
domain,
p
:
X

X
!
[0;
1)
op
and
the
corresp
onding
w
eigh
t
function
w
:
X
!
[0;
1)
op
are
monotone.
This
is
one
of
the
reasons
wh
y
one
can
hop
e
for
the
w
eigh
t
(self-distance)
function
to
b
e
a
measuremen
t.
2.3
Martin
's
the
ory
W
e
giv
e
a
summary
of
the
main
elemen
ts
of
Key
e
Martin's
theory
of
measure-
men
ts
on
domains.
Our
main
reference
is
[5].
Let
P
b
e
a
p
oset
and
E
a
domain.
F
or
a
monotone
mapping
:
P
!
E
and
an
y
x
2
P
,
"
2
E
w
e
dene

"
(x)
:=
fy
2
P
j
y
v
x
^
"

y
g
=

 1
("
"
")
\
#
x:
268

W
aszkiewicz
W
e
sa
y
that

"
(x)
is
the
set
of
elemen
ts
of
P
whic
h
are
"-close
to
x
2
P
.
Since
in
most
cases
w
e
assume
E
=
[0;
1)
op
,
w
e
read
"

(y
)
as
(y
)
<
"
in
the
natural
order,
whic
h
matc
hes
the
in
tuition
b
ehind
the
name
of

"
(x).
The
map

can
b
e
though
t
of
as
a
quan
titativ
e
measure
of
a
relativ
e
\distance"
b
et
w
een
elemen
ts
in
P
.
Immediately
w
e
ha
v
e
that

"
(x)
6=
;
i
x
2

"
(x)
and
for
an
y
y
2
P
,
if
y
2

"
(x),
then
y
2

"
(y
)


"
(x).
W
e
sa
y
that
a
monotone
mapping
:
P
!
E
induc
es
the
Sc
ott
top
olo
gy
on
a
subset
X
of
a
p
oset
P
if
8U
2

P
8x
2
X
:
x
2
U
)
(9"
2
E
)
x
2

"
(x)

U
.
W
e
denote
it
as

 !
X

P
.
If
X
=
P
,
w
e
write

 !

P
,
whic
h
reads:

induc
es
the
Sc
ott
top
olo
gy
everywher
e
(on
P
).
In
the
pap
er,
the
follo
wing
observ
ation
will
often
b
e
referred
to
as
the
me
asur
ement
pr
op
erty:
for
a
map
:
P
!
[0;
1)
op
on
a
con
tin
uous
p
oset
P
and
for
an
y
X

P
,
the
follo
wing
are
equiv
alen
t:
(i)

is
Scott-con
tin
uous
and
induces
the
Scott
top
ology
ev
erywhere
on
X
,
(ii)
for
all
x
2
X
and
all
subsets
S

#
#
x,
S
is
directed
with
suprem
um
x
i
F
fs
j
s
2
S
g
=
x.
It
is
not
hard
to
sho
w
that
the
iden
tit
y
mapping
on
a
domain
P
induces
the
Scott
top
ology
ev
erywhere
on
P
.
Moreo
v
er,
the
prop
ert
y
is
preserv
ed
b
y
the
comp
osition
of
maps.
A
me
asur
ement
on
a
con
tin
uous
p
oset
D
is
a
Scott-
con
tin
uous
mapping
:
D
!
[0;
1)
op
whic
h
induces
the
Scott
top
ology
on
its
k
ernel
k
er

:=
fx
2
D
j
(x)
=
0g.
Martin's
theory
has
a
ric
h
top
ological
dimension.
The
Martin
top
olo
gy
(also
called
the

top
olo
gy)
arises
naturally
in
the
consideration
of
measure-
men
ts.
F
or
an
y
monotone
mapping
:
D
!
E
b
et
w
een
domains,
the
collection
f
"
(x)
j
x
2
D
;
"
2
E
g
forms
a
basis
for
a
top
ology
on
D
.
In
particular,
if

is
tak
en
to
b
e
the
iden
tit
y
map
on
D
,
w
e
obtain
a
top
ology
with
a
basis
f"
"
x
\
#y
j
x;
y
2
D
g.
W
e
call
this
top
ology
the
Martin
top
olo
gy
on
D
.
The
fol-
lo
wing
imp
ortan
t
Invarianc
e
The
or
em
holds:
if
:
D
!
E
is
Scott-con
tin
uous,
then

induces
the
Scott
top
ology
on
D
i
f
"
(x)
j
x
2
D
;
"
2
E
g
is
a
basis
for
the
Martin
top
ology
on
D
.
That
is,
no
matter
ho
w
w
e
measure
a
domain,
all
measuremen
ts
giv
e
rise
to
the
same

top
ology
on
the
domain.
The
Martin
top
ology
is
alw
a
ys
Hausdor
on
a
domain.
The
study
of
its
prop
erties
is
the
sub
ject
of
a
c
hapter
in
Martin's
thesis
[5].
In
our
pap
er
w
e
w
ork
on
p
osets
equipp
ed
with
a
particularly
pleasan
t
class
of
measuremen
ts
whic
h
induce
the
Scott
top
ology
ev
erywhere
on
their
domains.
W
e
are
able
to
c
haracterize
b
oth
the
order
(see
Sections
4)
and
completeness
of
a
domain
strictly
in
terms
of
the
measuremen
t.
2.4
Completeness
F
or
an
y
top
ology

,
the
collection
of
in
tersections
C
\
O
of
a
closed
set
C
and
an
op
en
set
O
of

forms
a
basis
of
a
top
ology
,
the
so-called
b-top
ology
for

.
S

underhauf
[8]
sho
ws
that

is
sob
er
i
ev
ery
observative
net
con
v
erges
in
the
b-top
ology
for

.
(A
net
(x
i
)
i2I
is
observ
ativ
e
if
for
all
i
2
I
and
for
all
269

W
aszkiewicz
U
2

,
x
i
2
U
implies
that
the
net
is
ev
en
tually
in
U
.)
In
the
case
of
p
osets
with
measuremen
ts,
w
e
can
conne
our
atten
tion
to
observ
ativ
e
sequences:
Lemma
2.1
L
et
P
b
e
a
c
ontinuous
p
oset
with
a
me
asur
ement
:
P
!
[0;
1)
op
such
that

 !

P
.
The
Sc
ott
top
olo
gy
on
P
is
rst-c
ountable.
Pro
of.
P
is
rst
coun
table
since
f"
x+
1
n
(x)
j
n
2
N
g
is
a
coun
table
neigh-
b
ourho
o
d
base
at
x
2
P
.
2
It
comes
as
no
surprise
that:
Prop
osition
2.2
The
Martin
top
olo
gy
is
the
b-top
olo
gy
for
the
Sc
ott
top
olo
gy
on
a
c
ontinuous
p
oset
P
.
Pro
of.
The
collection
f"
"
x
\
#y
j
x;
y
2
P
g
is
a
basis
for
the
Martin
top
ology
on
P
.
Th
us,
the
Martin
top
ology
is
alw
a
ys
coarser
than
the
b-top
ology
.
T
o
pro
v
e
the
con
v
erse,
denote
the
b-top
ology
for
the
Scott
top
ology
b
y

and
let
x
2
U
2

.
W
e
can
assume
U
is
a
basic-op
en
set
in

and
hence
U
=
O
\
C
,
where
O
is
a
Scott-op
en
set
and
C
is
Scott-closed.
Let
us
c
ho
ose
an
elemen
t
y
2
U
w
a
y-b
elo
w
x
suc
h
that
y
2
O
.
Also,
y
2
C
,
since
C
is
do
wn
w
ard
closed.
Consequen
tly
,
y
2
U
.
W
e
claim
that
the
set
A
:=
"
"
y
\
#
x
is
a
subset
of
U
.
Indeed,
if
z
2
A,
then
z
2
"
"
y

O
.
Also,
z
2
#x

C
.
Therefore,
z
2
U
.
Since
A
is
basic-Martin
op
en,
w
e
are
done.
2
Therefore,
Martin's
In
v
ariance
Theorem
states
that
the
b-top
ology
for
the
Scott
top
ology
on
P
can
b
e
constructed
from
a
measuremen
t
with

 !

P
(the
pro
of
of
the
Theorem
holds
verb
atim,
ev
en
if
P
is
not
a
dcp
o).
No
w,
S

underhauf
's
result
giv
es
that
a
con
tin
uous
p
oset
is
sob
er
(equiv
alen
tly:
is
a
dcp
o)
i
ev
ery
observ
ativ
e
sequence
in
P
Martin-con
v
erges
in
P
.
Ho
w
ev
er,
it
happ
ens
that
with
m
uc
h
simpler
reasoning
w
e
can
pro
v
e
a
stronger
result.
W
e
need
to
kno
w
a
few
simple
facts
ab
out
con
v
ergence
in
the
Martin
top
ology
,
all
pro
v
ed
in
[5
].
Firstly
,
giv
en
a
measuremen
t
:
P
!
[0;
1)
op
on
a
con
tin
uous
p
oset
P
,
a
sequence
(x
n
)
con
v
erges
to
an
x
2
P
in
the
Martin
top
ology
on
P
i
lim
x
n
=
x
and
(x
n
)
is
ev
en
tually
in
#x.
Secondly
,
a
sequence
(x
n
)
Martin-con
v
erges
to
an
x
i
it
Scott-con
v
erges
and
(x
n
)
is
ev
en
tually
in
#x.
Lemma
2.3
A
c
ontinuous
p
oset
P
with
a
me
asur
ement
:
P
!
[0;
1)
op
with

 !

P
is
a
dcp
o
i
every
incr
e
asing
se
quenc
e
(x
n
)
Martin-c
onver
ges
in
P
.
Pro
of.
Let
(x
n
)
b
e
a
sequence
with
x
=
F
"
x
n
.
Since

is
Scott-con
tin
uous,
x
=
(
G
"
x
n
)
=
G
fx
n
j
n
2
N
g
=
lim
n!1
x
n
:
Since
x
n
v
x
for
ev
ery
n
2
N
,
(x
n
)
Martin-con
v
erges.
The
pro
of
of
the
con
v
erse
is
essen
tially
the
con
ten
t
of
Corollary
3.1.3
of
[5]
and
w
e
giv
e
it
only
for
the
sak
e
of
completeness:
Martin-con
v
ergence
of
(x
n
)
to
x
implies
that
the
sequence
is
ev
en
tually
b
elo
w
x.
Since
the
sequence
is
increasing,
all
x
n
are
270

W
aszkiewicz
b
elo
w
x.
Let
u
b
e
another
upp
er
b
ound
for
the
sequence.
F
or
ev
ery
Scott-
op
en
set
U
around
x,
there
exists
k
suc
h
that
x
k
2
U
,
b
y
Scott-con
v
ergence.
No
w,
since
U
is
upp
er,
x
k
v
u
2
U
.
This
pro
v
es
x
v
u.
2
W
e
conclude
this
section
with
a
summary
of
results:
Theorem
2.4
L
et
P
b
e
a
c
ontinuous
p
oset
with
a
me
asur
ement
:
P
!
[0;
1)
op
with

 !

P
.
The
fol
lowing
ar
e
e
quivalent:
(i)
the
Sc
ott
top
olo
gy
on
P
is
sob
er,
(ii)
P
is
a
dcp
o,
(iii)
al
l
incr
e
asing
se
quenc
es
c
onver
ge
in
the
Sc
ott
top
olo
gy
on
P
,
(iv)
al
l
incr
e
asing
se
quenc
es
c
onver
ge
in
the
Martin
top
olo
gy
on
P
,
(v)
al
l
observative
se
quenc
es
c
onver
ge
in
the
Martin
top
olo
gy
on
P
.
2
2.5
Examples
of
domains
with
me
asur
ements
Can
tor
set
mo
del

1
.
Let

1
denote
the
set
of
all
nite
and
innite
w
ords
o
v
er
a
nite
alphab
et
,
with
the
prex
ordering.
This
is
an
!
-algebraic
domain.
F
or
all
x;
y
2

1
,
x

y
holds
i
x
v
y
and
x
is
nite.
The
mapping
1
2
jj
:

1
!
[0;
1)
op
where
j

j
:

1
!
N
[
f1g
tak
es
a
string
to
its
length
is
a
measuremen
t
on

1
.
Moreo
v
er,
it
induces
the
Scott
top
ology
ev
erywhere
on

1
.
The
in
terv
al
domain
IR
.
The
collection
IR
of
compact
in
terv
als
of
the
real
line
ordered
under
rev
erse
inclusion
is
an
!
-con
tin
uous
domain.
The
suprem
um
of
a
directed
set
S

IR
is
T
S
and
for
all
in
terv
als
x;
y
2
IR
w
e
ha
v
e
x

y
i
x
is
con
tained
in
the
in
terior
of
y
.
The
length
function
j

j
:
IR
!
[0;
1)
op
giv
en
b
y
jxj
=
x
 x,
where
x
=
[x;
x
]
2
IR
,
is
a
measure-
men
t
on
IR
.
It
induces
the
Scott
top
ology
ev
erywhere
on
IR
.
The
p
o
w
erset
of
naturals
P
!
.
The
collection
of
all
subsets
of
N
ordered
b
y
inclusion
is
an
!
-algebraic
domain.
The
suprem
um
of
a
directed
set
S

P
!
is
S
S
and
for
all
elemen
ts
x;
y
of
P
!
the
appro
ximation
relation
is
giv
en
b
y
x

y
i
x

y
and
x
nite.
The
mapping
j

j
:
P
!
!
[0;
1)
op
giv
en
b
y
jxj
=
1
 X
n2x
1
2
n+1
is
a
measuremen
t
on
P
!
.
It
induces
the
Scott
top
ology
ev
erywhere
on
P
!
.
The
formal
ball
mo
del
BX
,
in
tro
duced
in
[2].
The
mapping

:
BX
!
[0;
1)
op
giv
en
b
y
(x;
r
)
=
r
is
a
measuremen
t
on
BX
.
It
induces
the
Scott
top
ology
ev
erywhere
on
BX
.
271

W
aszkiewicz
The
domain
of
nite
lists
[S
]
o
v
er
a
set
S
.
A
list
x
o
v
er
a
set
S
is
a
map
x:
f1;
2;
:::;
ng
!
S
for
n

0.
Informally
,
for
x;
y
2
[S
],
y
is
a
sublist
of
x
if
y
matc
hes
some
con
v
ex
subset
of
x,
e.g.
[a;
b]
is
a
sublist
of
[c;
a;
b;
d],
while
[a;
d]
is
not.
W
e
dene
a
partial
order
on
[S
]
b
y
x
v
y
i
y
is
a
sublist
of
x.
With
this
order,
[S
]
is
an
algebraic
dcp
o,
where
ev
ery
elemen
t
is
compact.
[S
]
is
!
-con
tin
uous
i
S
is
coun
table.
The
length
of
the
list,
l
en:
[S
]
!
N
,
giv
en
b
y
l
en(x)
:=
jdom(x)j
(cardinalit
y
of
the
domain
of
x)
is
a
measuremen
t
on
[S
],
whic
h
induces
the
Scott
top
ology
ev
erywhere
on
[S
].
In
all
the
examples
ab
o
v
e,
the
k
ernel
of
the
measuremen
t
is
precisely
the
set
of
maximal
elemen
ts.
Ho
w
ev
er,
w
e
do
not
kno
w
if
for
arbitrary
!
-con
tin
uous
dcp
o,
the
set
of
maximals
is
the
k
ernel
of
some
measuremen
t
on
the
domain.
This
is
already
a
3-y
ear
old
problem.
Belo
w,
w
e
sho
w
that
it
is
the
condition
on
the
k
ernel
whic
h
causes
the
di√Ücult
y
,
since
it
is
easy
to
nd
a
measuremen
t
on
a
domain
with
coun
table
basis
(with
p
ossibly
empt
y
k
ernel).
Example
2.5
[5]
F
or
an
y
con
tin
uous
dcp
o
D
with
a
coun
table
basis
fU
n
j
n
2
N
g
for
the
Scott
top
ology
,
a
mapping
:
D
!
[0;
1)
op
giv
en
b
y
(x)
:=
1
 X
fn2N:x2U
n
g
1
2
n+1
is
a
measuremen
t
whic
h
induces
the
Scott
top
ology
ev
erywhere
on
D
.
3
The
necessit
y
of
measuremen
t
on
partially
metrizable
domains
In
this
pap
er,
w
e
are
mainly
concerned
with
the
case
when
a
partial
metric
top
ology
is
the
Scott
top
ology
of
the
induced
order,

p
=

in
sym
b
ols.
W
e
demonstrate
that
suc
h
a
class
of
partial
metrics
is
in
timately
connected
to
measuremen
ts.
W
e
giv
e
a
construction
of
a
measuremen
t
from
a
giv
en
partial
metric
with

p
=

X
on
an
arbitrary
set
X
.
Precisely
,
for
a
partial
metric
p
on
a
set
X
,
the
self-distance
mapping
:
X
!
[0;
1)
op
giv
en
b
y
(x)
:=
p(x;
x)
for
all
x
2
X
is
Scott-con
tin
uous
and
induces
the
Scott-top
ology
ev
erywhere
on
X
.
Moreo
v
er,
it
happ
ens
that
under
some
mild,
computationally
meaningful
restrictions
on
an
underlying
p
oset
X
,
the
con
v
erse
also
holds:
if
the
self-
distance
map

is
a
measuremen
t
whic
h
induces
the
Scott
top
ology
ev
ery-
where,
then

p
=

.
W
e
use

X


p
to
denote
the
fact
that
the
partial
metric
top
ology
is
larger
than
the
Scott
top
ology
of
the
induced
order
v
p
.
The
meaning
of

p


X
is
analogous.
Also,
in
this
section,

 !

means
that
the
mapping

induces
the
Scott
top
ology
ev
erywhere
on
X
.
Theorem
3.1
L
et
(X
;
p)
b
e
a
p
artial
metric
sp
ac
e
such
that
the
Sc
ott
top
olo
gy
of
the
or
der
v
p
agr
e
es
with
the
p
artial
metric
top
olo
gy

p
.
Then
the
self-
272

W
aszkiewicz
distanc
e
map
:
X
!
[0;
1)
op
is
Sc
ott-c
ontinuous
and
has
pr
op
erty

 !

.
Pro
of.
First,
w
e
will
sho
w
that
if

X


p
,
then

 !

.
Indeed,
let
x
2
U
2

X
.
Since

X


p
,
there
exists
an
"
>
0
suc
h
that
x
2
B
"
(x)

U
.
Dene
√Ü
:=
(x)
+
".
Since
(x)
<
√Ü
,
x
2

√Ü
(x).
No
w,
let
y
2

√Ü
(x).
Since
p(x;
y
)

(y
)
as
y
v
p
x
and
(y
)
<
√Ü
=
(x)
+
",
w
e
ha
v
e
p(x;
y
)
<
(x)
+
".
This
means
y
2
B
"
(x).
Therefore

√Ü
(x)

B
"
(x).
No
w,
it
remains
to
sho
w
that
if

p


X
,
then
the
self-distance
map
:
X
!
[0;
1)
op
is
Scott-con
tin
uous.
F
or,
since
p
:
X

X
!
[0;
1)
op
is

p
-con
tin
uous,
also

is

p
-con
tin
uous.
The
Scott-con
tin
uit
y
of

follo
ws
immediately
from
the
assumption.
2
Therefore,
w
e
obtained
a
necessary
condition
for
partial
metrizabilit
y
of
the
Scott
top
ology
on
con
tin
uous
p
osets.
Corollary
3.2
Every
p
artial
ly
metrizable
c
ontinuous
p
oset
admits
a
me
asur
e-
ment
which
induc
es
the
Sc
ott
top
olo
gy
everywher
e.
It
happ
ens
that
there
is
a
class
of
partial
metric
spaces
where
inducing
the
Scott
top
ology
b
y
the
self-distance
map
is
equiv
alen
t
to
the
agreemen
t
of
the
Scott
and
partial
metric
top
ologies.
Denition
3.3
W
e
call
a
partial
metric
space
stable
if
8x;
y
2
X
:
p(x;
y
)
=
G
fz
j
z
v
p
x;
y
g:
Notice
that
the
last
condition
is
equiv
alen
t
to
8x;
y
2
X
8"
>
0
9z
v
p
x;
y
:
(z
)
<
p(x;
y
)
+
":
Moreo
v
er,
if
X
is
a
con
tin
uous
p
oset
with
resp
ect
to
the
induced
order,
then
stabilit
y
can
b
e
written
as
8x;
y
2
X
:
p(x;
y
)
=
F
fz
j
z

p
x;
y
g,
where

p
is
the
w
a
y-b
elo
w
relation
obtained
from
the
order
v
p
.
Theorem
3.4
L
et
(X
;
p)
b
e
a
p
artial
metric
sp
ac
e
such
that:
1.
X
is
stable,
and
2.
the
induc
e
d
or
der
v
p
makes
X
a
c
ontinuous
p
oset.
Then
the
Sc
ott
top
olo
gy
of
the
or
der
v
p
agr
e
es
with
the
p
artial
metric
top
olo
gy

p
i
the
self-distanc
e
map
:
X
!
[0;
1)
op
is
a
me
asur
ement
with
pr
op
erty

 !

.
Pro
of.
The
pro
of
consists
of
t
w
o
observ
ations.
The
rst
one
states
that,
if
(X
;
p)
is
a
stable
space,
then

X


p
holds
i

 !

.
())
has
already
b
een
sho
wn
in
the
pro
of
of
the
preceding
theorem.
F
or
the
con
v
erse,
let
x
2
U
2

X
.
By

 !

,
w
e
can
assume
x
2

√Ü
(x)

U
,
where
√Ü
:=
(x)
+
"
for
some
"
>
0.
Set
"
0
:=
1
2
".
W
e
w
an
t
to
sho
w
B
"
0
(x)

"(
√Ü
(x)).
Let
y
2
B
"
0
(x).
Then
b
y
273

W
aszkiewicz
denition,
p(x;
y
)
<
(x)
+
"
0
.
By
assumption,
there
exist
z
v
p
x;
y
suc
h
that
w
e
ha
v
e
(z
)
<
p(x;
y
)
+
"
0
<
(x)
+
2"
0
=
(x)
+
"
=
√Ü
:
Hence
w
e
ha
v
e
sho
wn
that
z
2

√Ü
(x).
Moreo
v
er,
since
z
v
p
y
,
y
2
"
√Ü
(x).
Therefore
the
claim
that
B
"
0
(x)

"(
√Ü
(x))
is
no
w
pro
v
ed.
Consequen
tly
,
w
e
ha
v
e
x
2
B
"
0
(x)

"
√Ü
(x)

"
U
=
U;
whic
h
giv
es

X


p
.
The
pro
of
of
the
rst
observ
ation
is
completed.
The
second
one
states
that
if
(X
;
p)
is
a
partial
metric
space
suc
h
that
the
induced
order
v
p
mak
es
X
a
con
tin
uous
p
oset,
then

p


X
i
the
self-
distance
map
:
X
!
[0;
1)
op
is
Scott-con
tin
uous.
F
or
((),
let
x
2
V
2

p
.
T
ak
e
an
y
op
en
ball
around
x
in
V
,
that
is,
c
ho
ose
"
>
0
suc
h
that
x
2
B
"
(x)

V
.
It
is
easy
to
sho
w
that
x
2

√Ü
(x)

B
"
(x)

V
,
where
√Ü
:=
(x)
+
".
Since
B
"
(x)
is
an
upp
er
set,
x
2
"
√Ü
(x)

B
"
(x)

V
.
Finally
,
b
y
con
tin
uit
y
of
X
and
,
the
set
"
√Ü
(x)
is
Scott-op
en
(see
also
the
next
section
for
more
detailed
explanation).
Therefore

p


X
.
The
con
v
erse
has
already
b
een
sho
wn
in
the
pro
of
of
the
preceding
theo-
rem.
2
4
The
distance
map
asso
ciated
with
a
measuremen
t
In
the
last
section
w
e
sa
w
that
whenev
er
a
partial
metric
induces
the
Scott
top
ology
on
the
underlying
domain,
the
domain
admits
a
measuremen
t
whic
h
induces
the
Scott
top
ology
ev
erywhere.
This
result
tells
us
w
e
should
lo
ok
to
measuremen
t
in
dening
a
notion
of
distance
on
domains.
W
e
start
with
a
standard
construction
from
[5].
Giv
en
a
con
tin
uous
p
oset
P
equipp
ed
with
a
measuremen
t
:
P
!
E
with

 !

P
one
can
dene
a
mapping
d

:
P
2
!
E
giv
en
b
y
d

(x;
y
)
:=
F
f(z
)
j
z

x;
y
g,
pro
viding
that
an
y
t
w
o
elemen
ts
x;
y
of
P
are
b
ounded
from
b
elo
w
and
E
is
a
dcp
o.
Martin
pro
v
es
that
d

is
Scott-con
tin
uous
on
P
2
.
Our
thesis
is
that
d

ma
y
serv
e
as
a
distance
function
b
et
w
een
elemen
ts
of
a
domain.
In
this
section
w
e
examine
basic
prop
erties
of
d

.
Denition
4.1
Let
P
b
e
a
con
tin
uous
p
oset
with
a
measuremen
t
:
P
!
[0;
1)
op
.
The
map
d

:
P
2
!
[0;
1)
op
dened
b
y
d

(x;
y
)
:=
G
f(z
)
j
z

x;
y
g
is
the
distance
function
asso
ciated
with
.
Notice
that
for
a
con
tin
uous
p
oset
P
with
a
measuremen
t,
w
e
can
alw
a
ys
assume
that
d

is
dened:
w
e
simply
scale
the
measuremen
t
to
[0;
1)
op
b
y


x
:=
x
1+x
,
add
b
ottom
to
P
with


?
:=
1
and
study
d


.
d

induces
a
top
ology
on
P
.
The
collection
of
op
en
balls
fB
"
(x)
j
x
2
P
;
"
>
0g
is
a
basis
for
the
top
ology
,
where
B
"
(x)
:=
fy
2
P
j
d

(x;
y
)
<
"g.
274

W
aszkiewicz
If
:
P
!
E
is
a
Scott-con
tin
uous
mapping
on
a
con
tin
uous
p
oset
P
with

 !

P
,
then
f"
"
(x)
j
x
2
P
;
"
2
E
g
is
a
basis
for
the
Scott
top
ology
on
P
.
No
w,
Martin
pro
v
ed
that
for
all
x
2
P
and
"
>
0,
B
"
(x)
=
"
"
(x),
that
is,
the
top
ology
induced
b
y
d

is
alw
a
ys
the
Scott
top
ology
.
Thanks
to
this
crucial
fact,
from
no
w
on
it
is
clear
that
d

is
a
computationally
imp
ortan
t
ob
ject
to
study
.
First
of
all,
w
e
are
going
to
sho
w
that
whenev
er
a
con
tin
uous
p
oset
is
equipp
ed
with
a
measuremen
t,
the
induced
distance
d

captures
order
b
et
w
een
elemen
ts.
Let
us
start
with
a
w
ell-kno
wn
fact:
Lemma
4.2
([5])
L
et
P
b
e
a
c
ontinuous
p
oset
with
a
monotone
map
:
P
!
[0;
1)
op
.
The
fol
lowing
ar
e
e
quivalent:
(i)

is
Sc
ott-c
ontinuous,
(ii)
x
=
d

(x;
x)
for
any
x
2
P
,
(iii)
x
v
y
)
d

(x;
y
)
=
x
for
any
x;
y
2
P
.
Theorem
4.3
L
et
P
b
e
a
c
ontinuous
p
oset
with
a
me
asur
ement
:
P
!
[0;
1)
op
with

 !

P
.
Then
for
al
l
x;
y
2
P
,
x
v
y
(
)
d

(x;
y
)
=
x:
Pro
of.
())
b
y
Lemma
4.2.
F
or
(()
assume
d

(x;
y
)
=
x.
Let
(x
n
)
b
e
a
sequence
with
x
n

x;
y
and
lim
x
n
=
d

(x;
y
).
Then
lim
x
n
=
x
and
b
y
the
measuremen
t
prop
ert
y
,
(x
n
)
is
directed
with
suprem
um
x.
Therefore,
x
=
F
"
x
n
v
y
.
2
Observ
e
an
immediate
corollary
of
the
result
and
Example
2.5.
W
e
are
able
to
c
haracterize
the
order
relation
on
arbitrary
!
-con
tin
uous
dcp
o.
Corollary
4.4
F
or
any
c
ontinuous
dcp
o
D
with
a
c
ountable
b
asis
fU
n
j
n
2
N
g
for
the
Sc
ott
top
olo
gy,
x
v
y
(
)
d

(x;
y
)
=
x,
wher
e
:
D
!
[0;
1)
op
is
given
in
Example
2.5.
2
No
w
w
e
ha
v
e
an
elemen
tary
pro
of
of
some
prop
erties
of
d

.
The
rst
one,
b
elo
w,
can
b
e
treated
as
the
T
0
axiom
in
the
case
when
d

is
a
partial
metric
on
D
.
The
second
prop
ert
y
states
the
an
tisymmetry
of
the
order.
Corollary
4.5
With
assumptions
of
The
or
em
4.3,
d

has
the
fol
lowing
pr
op-
erties:
1.
d

(x;
y
)
=
x
=
y
(
)
x
=
y
,
2.
d

(x;
y
)
=
0
(
)
x
=
y
2
k
er
.
2
The
c
haracterization
of
the
order
giv
en
in
Theorem
4.3
reminds
us
of
the
denition
of
the
order
induced
b
y
a
partial
metric.
Therefore
one
can
ask
when
d

is
a
partial
metric.
275

W
aszkiewicz
5
When
distance
is
a
partial
metric
W
e
no
w
try
to
justify
the
in
tuition
that
d

pro
vides
a
measure
of
distance
b
e-
t
w
een
elemen
ts
of
a
domain.
In
particular,
w
e
start
with
a
su√Ücien
t
condition
for
d

to
b
e
a
partial
metric.
Prop
osition
5.1
L
et
P
b
e
a
c
ontinuous
p
oset
with
a
me
asur
ement
:
P
!
[0;
1)
op
with

 !

P
.
If
for
al
l
c
onsistent
p
airs
a;
b
2
P
and
for
al
l
upp
er
b
ounds
r
of
a
and
b,
ther
e
exists
an
s
v
a;
b
such
that
r
+
s

a
+
b;
then
d

:
P
!
[0;
1)
is
a
p
artial
metric
on
P
such
that
its
induc
e
d
or
der
agr
e
es
with
the
or
der
on
P
and
the
p
artial
metric
top
olo
gy

p
is
the
Sc
ott
top
olo
gy
on
P
.
Pro
of.
Pro
ofs
of
this
and
next
prop
osition
are
extensions
of
Martin's
argu-
men
t
in
Corollary
5.4.1
of
[5].
It
is
enough
to
pro
v
e
that
d

satises

]
.
T
ak
e
an
y
x;
y
;
z
2
P
.
By
denition
of
d

,
there
exists
an
a
v
x;
z
and
b
v
y
;
z
suc
h
that
d

(x;
z
)
+
"
2

a
^
d

(y
;
z
)
+
"
2

b;
for
an
y
"
>
0.
Since
a;
b
are
consisten
t,
there
is
s
v
a;
b
suc
h
that
d

(x;
y
)

d

(a;
b)

s

a
+
b
 z
:
Hence,
d

(x;
y
)
+
z

d

(x;
y
)
+
d

(y
;
z
)
+
";
for
all
"
>
0.
This
pro
v
es
that
d

satises

]
.
Agreemen
t
of
orders
and
top
ologies
claimed
in
the
h
yp
othesis
follo
ws
from
general
prop
erties
of
d

.
2
Notice
that
if
P
is
b
ounded-complete
and

is
mo
dular,
that
is,
for
all
consisten
t
pairs
x;
y
2
P
w
e
ha
v
e
(x
t
y
)
+
(x
u
y
)
=
x
+
y
,
then
the
conditions
of
the
prop
osition
hold
and
d

=
(x
u
y
)
is
a
partial
metric
on
P
.
Hence
w
e
adv
anced
the
result
b
y
O'Neill
[7]
who
ga
v
e
a
construction
of
a
partial
metric
from
a
v
aluation
on
a
so
called
valuation
sp
ac
e,
i.e.
on
a
b
ounded-complete
inf-semilattice.
Ho
w
ev
er,
as
our
last
result
sho
ws,
the
existence
of
suprema
and
inma
is
not
necessary
.
Prop
osition
5.1
guaran
tees
the
existence
of
a
partial
metric
whic
h
induces
the
Scott
top
ology
on
IR
;

1
;
P
!
since
their
natural
measuremen
ts
are
mo
d-
ular.
The
mapping
p
IR
:
IR

IR
!
[0;
1)
giv
en
b
y
p
IR
([x;
x
];
[y
;
y
])
:=
max
fx
;
y
g
 min
fx;
y
g
where
[x
;
x];
[y
;
y
]
2
IR
,
is
a
partial
metric
on
IR
.
276

W
aszkiewicz
The
mapping
p

1
:

1


1
!
[0;
1)
giv
en
b
y
p

1
(x;
y
)
:=
2
 jr
j
;
where
r
is
the
largest
common
prex
of
x
and
y
,
is
a
partial
metric
on

1
.
The
mapping
p
P
!
:
P
!

P
!
!
[0;
1)
giv
en
b
y
p
P
!
(x;
y
)
:=
1
 X
n2x\y
2
 (n+1)
is
a
partial
metric
on
P
!
.
In
more
general
cases,
d

is
usually
no
longer
a
partial
metric.
Sometimes,
ho
w
ev
er,
d

still
satises
the
classical
triangle
inequalit
y
for
metrics.
Prop
osition
5.2
L
et
P
b
e
a
c
ontinuous
p
oset
with
a
me
asur
ement
:
P
!
[0;
1)
op
with

 !

P
such
that
9z
v
x;
y
:
z

x
+
y
:
Then
d

:
P
!
[0;
1)
satises
the
triangle
ine
quality
and
induc
es
the
Sc
ott
top
olo
gy
on
P
.
Pro
of.
The
reasoning
is
essen
tially
the
same
as
in
the
pro
of
of
the
preceding
Prop
osition.
2
In
terestingly
,
in
the
case
ab
o
v
e,
the
restriction
of
d

to
k
er

is
a
metric
whic
h
yields
the
relativ
e
Scott
top
ology
on
k
er
.
This
fact
is
in
v
estigated
in
detail
in
Martin's
thesis.
F
urther
generalization
is
still
p
ossible,
but
this
in
v
olv
es
applying
a
v
aluable
construction
due
to
F
rink
[3]
to
the
map
d

,
and
is
b
ey
ond
our
presen
t
concern.
6
The
existence
of
partial
metrics
on
coun
tably
based
domains
The
results
in
the
last
section
mak
e
us
think
that
d

ma
y
serv
e
as
a
distance
map
on
domains
only
in
restricted
cases
and
hence
is
not
a
useful
theoretical
device
in
establishing
the
existence
of
partial
metrics.
Ho
w
ev
er,
the
follo
wing
result
sho
ws
that
this
is
not
true.
It
also
pro
vides
a
practical
illustration
of
the
tec
hniques
dev
elop
ed
in
sections
3
and
4.
Theorem
6.1
L
et
D
b
e
an
!
-c
ontinuous
dcp
o.
Then
ther
e
is
a
Sc
ott-c
ontinuous
p
artial
metric
p
:
D
2
!
[0;
1)
such
that
(i)
v
p
=v
D
,
(ii)
the
Sc
ott
top
olo
gy
on
D
is
the
p
artial
metric
top
olo
gy

p
.
In
short,
al
l
c
ountably
b
ase
d
domains
ar
e
p
artial
ly
metrizable.
277

W
aszkiewicz
Note
the
nice
analogy
b
et
w
een
this
result
and
Urysohn's
lemma:
All
reg-
ular,
second-coun
table
spaces
are
metrizable.
Pro
of.
Let
fU
n
j
n
2
N
g
b
e
a
coun
table
base
for
the
Scott
top
ology
on
D
,
consisting
of
Scott-op
en
lters
[1
].
The
map
p(x;
y
)
:=
1
 X
fn2N:x;y
2U
n
g
1
2
n+1
;
is
a
Scott-con
tin
uous
partial
metric
on
D
.
Indeed,
p(x;
y
)
=
1
 X
fn:x;y
2U
n
g
1
2
n+1
=
G
f1
 X
fn:z
2U
n
g
1
2
n+1
j
z

x;
y
g
=
G
fz
j
z

x;
y
g
=
d

(x;
y
);
where

is
a
measuremen
t
with

 !

D
giv
en
b
y
Example
2.5
and
d

is
the
asso
ciated
distance
map.
Note
that
b
ecause
ev
ery
U
n
for
n
2
N
is
a
lter,
the
condition
x;
y
2
U
n
)
9z
2
U
n
:
z

x;
y
holds
and
the
second
equalit
y
ab
o
v
e
is
indeed
correct.
No
w,
w
e
will
c
hec
k
the
partial
metric
axioms
for
p.
The
condition
p(x;
y
)

0
for
all
x;
y
2
D
and
symmetry
follo
w
straigh
t
from
the
denition.
T
0
axiom
for
p
holds
b
y
Corollary
4.5.
F
or

]
:
tak
e
an
y
x;
y
;
z
2
P
.
Notice
that
the
inequalit
y
is
equiv
alen
t
to:
X
fn:x;z
2U
n
g
1
2
n+1
+
X
fn:y
;z
2U
n
g
1
2
n+1

X
fn:x;y
2U
n
g
1
2
n+1
+
X
fn:z
2U
n
g
1
2
n+1
:
W
e
need
to
distinguish
three
cases
where
an
op
en
set
U
k
;
k
2
N
is
coun
ted
in
b
oth
sums
and
in
one
of
the
sums
on
the
left-hand
side.
But
in
ev
ery
case
ev
ery
index
k
,
whic
h
con
tributes
to
the
sums
on
the
left-hand
side
also
con
tributes
to
the
sums
on
the
righ
t-hand
side.
Hence,
the
inequalit
y
is
pro
v
ed.
Agreemen
t
of
orders,
v
p
=v
D
,
is
established
b
y
Theorem
4.3.
The
partial
metric
is
stable
b
y
the
remark
follo
wing
Denition
3.3.
The-
orem
3.4
giv
es
that
the
partial
metric
top
ology
is
the
Scott
top
ology
of
the
induced
order
v
p
and
so
the
order
on
D
.
2
Finally
,
it
is
easy
to
c
hec
k
that
the
asso
ciated
quasi-metric
whic
h
induces
the
same
order
and
top
ology
is
giv
en
b
y
q
(x;
y
)
=
1
 X
fn:x2U
n
)y
2U
n
g
1
2
n+1
and
is
w
eigh
ted
b
y
.
278

W
aszkiewicz
Ac
kno
wledgemen
t
The
author
wishes
to
thank
Ac
him
Jung
and
Key
e
Martin
for
their
v
aluable
criticisms
and
Dagmara
Boguc
k
a
for
her
supp
ort
and
friendship.
References
[1]
S.
Abramsky
and
A.
Jung.
Domain
theory
.
In
S.
Abramsky
,
D.
M.
Gabba
y
,
and
T.
S.
E.
Maibaum,
editors,
Handb
o
ok
of
L
o
gic
in
Computer
Scienc
e,
v
olume
3,
pages
1{168.
Clarendon
Press,
1994.
[2]
A.
Edalat
and
R.
Hec
kmann.
A
computational
mo
del
for
metric
spaces.
The
or
etic
al
Computer
Scienc
e,
193:53{73,
1998.
[3]
A.H.
F
rink.
Distance
functions
and
the
metrization
problem.
Bul
letin
of
the
A
meric
an
Mathematic
al
So
ciety,
43:133{142,
1937.
[4]
Reinhold
Hec
kmann.
Appro
ximation
of
metric
spaces
b
y
partial
metric
spaces.
Applie
d
Cate
goric
al
Structur
es,
7:71{83,
1999.
[5]
Key
e
Martin.
A
F
oundation
for
Computation.
PhD
thesis,
Departmen
t
of
Mathematics,
T
ulane
Univ
ersit
y
,
New
Orleans,
LA
70118,
2000.
[6]
Stev
e
G.
Matthews.
P
artial
metric
top
ology
.
In
Pr
o
c
e
e
dings
of
the
8th
Summer
Confer
enc
e
on
T
op
olo
gy
and
Its
Applic
ation,
v
olume
728,
pages
176{185,
1992.
[7]
Simon
J.
O'Neill.
P
artial
metrics,
v
aluations
and
domain
theory
.
Researc
h
Rep
ort
CS-RR-293,
Departmen
t
of
Computer
Science,
Univ
ersit
y
of
W
arwic
k,
Co
v
en
try
,
UK,
Octob
er
1995.
[8]
Philipp
S

underhauf.
Sobriet
y
in
terms
of
nets.
Applie
d
Cate
goric
al
Structur
es,
8:649{653,
2000.
279

Recent BRICS Notes Series Publications
NS-01-2
Stephen Brookes and Michael Mislove, editors. Preliminary
Proceedings of the 17th Annual Conference on Mathematical
Foundations of Programming Semantics, MFPS ‚Äô01, (Aarhus,
Denmark, May 24‚Äì27, 2001), May 2001. viii+279 pp.
NS-01-1
Nils Klarlund and Anders M√∏ller. MONA Version 1.4 ‚Äî User
Manual. January 2001. 83 pp.
NS-00-8
Anders M√∏ller and Michael I. Schwartzbach. The XML Revo-
lution. December 2000. 149 pp.
NS-00-7
Nils Klarlund, Anders M√∏ller, and Michael I. Schwartzbach.
Document Structure Description 1.0. December 2000. 40 pp.
NS-00-6
Peter D. Mosses and Hermano Perrelli de Moura, editors. Pro-
ceedings of the Third International Workshop on Action Seman-
tics, AS 2000, (Recife, Brazil, May 15‚Äì16, 2000), August 2000.
viii+148 pp.
NS-00-5
Claus Brabrand. <bigwig> Version 1.3 ‚Äî Tutorial. Septem-
ber 2000. ii+92 pp.
NS-00-4
Claus Brabrand. <bigwig> Version 1.3 ‚Äî Reference Manual.
September 2000. ii+56 pp.
NS-00-3
Patrick Cousot, Eric Goubault, Jeremy Gunawardena, Mau-
rice Herlihy, Martin Raussen, and Vladimiro Sassone, edi-
tors.
Preliminary Proceedings of the Workshop on Geometry
and Topology in Concurrency Theory, GETCO ‚Äô00, (State Col-
lege, USA, August 21, 2000), August 2000. vi+116 pp.
NS-00-2
Luca Aceto and Bj¬®orn Victor, editors. Preliminary Proceedings
of the 7th International Workshop on Expressiveness in Concur-
rency, EXPRESS ‚Äô00, (State College, Pennsylvania, USA, Au-
gust 21, 2000), August 2000. vi+130 pp.
NS-00-1
Bernd G¬®artner. Randomization and Abstraction ‚Äî Useful Tools
for Optimization. February 2000. 106 pp.
NS-99-3
Peter D. Mosses and David A. Watt, editors. Proceedings of the
Second International Workshop on Action Semantics, AS ‚Äô99,
(Amsterdam, The Netherlands, March 21, 1999), May 1999.
iv+172 pp.

