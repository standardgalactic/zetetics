LATTE: Accelerating LiDAR Point Cloud Annotation via Sensor
Fusion, One-Click Annotation, and Tracking
Bernie Wang1, Virginia Wu2, Bichen Wu1, and Kurt Keutzer1
Abstract‚Äî LiDAR (Light Detection And Ranging) is an
essential and widely adopted sensor for autonomous vehicles,
particularly for those vehicles operating at higher levels (L4-
L5) of autonomy. Recent work has demonstrated the promise of
deep-learning approaches for LiDAR-based detection. However,
deep-learning algorithms are extremely data hungry, requiring
large amounts of labeled point-cloud data for training and eval-
uation. Annotating LiDAR point cloud data is challenging due
to the following issues: 1) A LiDAR point cloud is usually sparse
and has low resolution, making it difÔ¨Åcult for human annotators
to recognize objects. 2) Compared to annotation on 2D images,
the operation of drawing 3D bounding boxes or even point-
wise labels on LiDAR point clouds is more complex and time-
consuming. 3) LiDAR data are usually collected in sequences,
so consecutive frames are highly correlated, leading to repeated
annotations. To tackle these challenges, we propose LATTE, an
open-sourced annotation tool for LiDAR point clouds. LATTE
features the following innovations: 1) Sensor fusion: We utilize
image-based detection algorithms to automatically pre-label a
calibrated image, and transfer the labels to the point cloud. 2)
One-click annotation: Instead of drawing 3D bounding boxes or
point-wise labels, we simplify the annotation to just one click on
the target object, and automatically generate the bounding box
for the target. 3) Tracking: we integrate tracking into sequence
annotation such that we can transfer labels from one frame
to subsequent ones and therefore signiÔ¨Åcantly reduce repeated
labeling. Experiments show the proposed features accelerate the
annotation speed by 6.2x and signiÔ¨Åcantly improve label quality
with 23.6% and 2.2% higher instance-level precision and recall,
and 2.0% higher bounding box IoU. LATTE is open-sourced
at https://github.com/bernwang/latte.
I. INTRODUCTION
LiDAR (Light detection and ranging) is an essential and
widely adopted sensor for autonomous vehicles. This is
particularly true for applications such as Robo-Taxis which
require higher levels (L4-L5) of autonomy. Compared with
cameras, LiDAR is more robust to ambient light condition
changes. It can also provide very accurate distance measure-
ments (error < 2cm 1) to nearby obstacles, which is essential
for the planning and control of autonomous vehicles.
To understand the environment through LiDAR, au-
tonomous vehicles need to extract semantic meaning from
the point cloud and accurately identify and locate objects
such as cars, pedestrians, cyclists, and so on. Such problems
are called LiDAR-based detection, and they have long been
studied by the research community. An increasing number
1Bernie Wang, Bichen Wu, and Kurt Keutzer are with Berkeley
AI Research, University of California, Berkeley, CA, U.S.A. Email:
{berniewang, bichen, keutzer}@berkeley.edu
2Virginia Wu is with the Department of Software Engineering, Huaqiao
University, Fujian Province, China. She worked on this project while
interning at UC Berkeley. Email: wbc0310@gmail.com
Fig. 1.
A screenshot of LATTE. Best viewed in color.
of works [1], [2], [3], [4] have demonstrated the promise of
using Deep Learning to solve this problem. Compared with
previous approaches, deep learning solutions obtain superior
accuracy and faster speed, but they are also extremely data
hungry, requiring large amounts of data for training.
Compared to annotating camera images, annotating Li-
DAR point clouds is much more difÔ¨Åcult. The challenges
can be summarized in the following three aspects and are
illustrated in Fig. 2: 1) Low resolution: Cameras can easily
capture high-resolution images, with widespread support for
4K resolution. In comparison, LiDAR sensors have much
more limited resolution. For example, typical vertical res-
olutions for Velodyne LiDARs are 32 or 64 lines. For the
64-line LiDAR1 with a vertical angular resolution of 0.41‚ó¶,
the spatial resolution at 50 meters is merely 0.36 meters.
As a result, LiDAR point clouds are very sparse, making it
difÔ¨Åcult for human annotators to identify objects, as shown in
Fig. 2(a). 2) Complex annotating operations: LiDAR-based
detection problems have different formulations, and the most
popular two are 3D bounding box detection and point-wise
segmentation. The former requires predicting a 3D bounding
box that tightly covers a target object, and the latter requires
Ô¨Ånding all the points that belong to a target object. In
both scenarios, annotating 3D point cloud is signiÔ¨Åcantly
more complex than annotating a 2D image. In bounding box
detection, for example, a 2D bounding box can be determined
by drawing two corners. For 3D bounding boxes, however,
annotators have to determine not only the center position,
the length, width, and height of the target, but also 3D
rotations. As a result, correctly annotating a 3D bounding
1https://velodynelidar.com/hdl-64e.html
arXiv:1904.09085v1  [cs.CV]  19 Apr 2019



(
 ,$1 

!.4-#(-&
!.7
	
!.4-#(-&
!.7
1 ,$3
1 ,$3



:
;
<
 .61$2.+43(.-
!.,/+$7 --.3 3(-&./$1 3(.-2
"$04$-3( +".11$+ 3(.-
.+$
8"+(23
Fig. 2.
Challenges of annotating LiDAR point clouds. (a) LiDAR point clouds have low resolution and therefore objects are difÔ¨Åcult for humans to
recognize. The upper two Ô¨Ågures are point clouds of a trafÔ¨Åc pole and a cyclist, but both are difÔ¨Åcult to recognize. The lower two are the corresponding
images. (b) Annotating 2D bounding boxes on an image vs. 3D bounding boxes on a point cloud. Annotating 3D bounding boxes is more complicated
due to more degrees of freedom of 3D scaling and rotation. (c) Point clouds of two consecutive frames are shown here. Even though the two frames are
highly similar, target objects are moving and have different speeds. As a result, new bounding boxes are needed on new frames.
box is much more complex for human annotators, as shown
in Fig. 2(b). 3) Sequential correlation: Many LiDAR point
cloud data are collected in sequences, so consecutive frames
are different but highly correlated. If we were to annotate
LiDAR point cloud frame by frame naively, most of the
annotations would be repeated, as shown in Fig. 2(c).
Without addressing these challenges, it is difÔ¨Åcult to
annotate LiDAR data efÔ¨Åciently over a large dataset. This
limits the progress of research for LiDAR-based detection.
Furthermore, although several efforts are trying to create
more open-sourced datasets ([5], [6]) for LiDAR-based de-
tection, the annotation tools behind these datasets are not
publicly accessible. Moreover, there are obvious advantages
to enabling groups to efÔ¨Åciently annotate LiDAR datasets for
their own LiDAR sensors, conÔ¨Ågurations, and so on.
To address these problems, we propose LATTE, an open-
sourced LiDAR annotation tool, as shown in Fig. 1. We
address the challenges above with the following solutions:
1) Sensor fusion: Cameras have much higher resolution
than LiDAR sensors, and image-based detection algorithms
are much more mature than LiDAR-based. LiDAR sensors
are usually paired with cameras, and the two sensors are
calibrated such that each point from the cloud can be
projected to a corresponding pixel in the image. Therefore,
we can apply camera-based image detection algorithms and
transfer labels from an image to a 3D point cloud. The
algorithm-generated labels are not perfect and are limited
by the algorithm accuracy, projection and synchronization
errors, but we can use them as pre-labels to help human
annotators recognize objects and ‚ÄúÔ¨Åne-tune‚Äù the labels. 2)
One-click annotation: We simplify the operational complex-
ity for LiDAR annotation from drawing point-wise labels to
drawing 3D bounding boxes, then to top-view 2D bounding
boxes, and eventually to one-click annotations. For a target
object, a human annotator need only click on one point on
it, and we utilize clustering algorithms to expand the point-
annotation to the entire object, and automatically estimate
a top-view 2D bounding box around the object. From the
top-view of a 2D bounding box, we can infer point-wise
labels for segmentation problems, simply by treating each
point inside the bounding box as part of the target object.
3) Tracking: To reduce repeated annotations on consecutive
frames in a sequence, we utilize tracking algorithms to
transfer annotations from one frame to subsequent ones. By
integrating all these solutions, our annotation tool enables a
6.2x reduction in annotation time while delivering better la-
bel quality, as measured by 23.6% and 2.2% higher instance-
level precision and recall, and 2.0% higher bounding box
IoU. Furthermore, we open-source our annotation tool and
build it in a modular way such that each component can be
replaced and improved easily if more advanced algorithms
for each part become available.
II. RELATED WORK
LiDAR-based detection and datasets: LiDAR-based de-
tection aims to identify and locate objects of interest from
a LiDAR point cloud. Two main problem formulations for
these point clouds are bounding box object detection [4]
of which the goal is to draw a tight bounding box that
covers the target object; and semantic segmentation [1],
of which the goal is to predict labels for each point in
the cloud and therefore Ô¨Ånd the cluster corresponding to
target objects. Earlier works mainly rely on handcrafted
geometrical features for segmentation and classiÔ¨Åcation [7],
[8], [9]. More recent works adopt deep learning to solve this
problem [1], [2], [10], [11], [3], [4] and achieve signiÔ¨Åcant
improvements in accuracy and efÔ¨Åciency.
Deep learning methods require much more data for train-
ing, therefore many efforts have focused on creating public
datasets for LiDAR-based detection. The KITTI dataset [5]
contains about 15,000 frames of 3D bounding box anno-
tations for road-objects. The Apolloscape dataset [6] con-
tains 140,000 frames of point-wise background annotation.
Public datasets serve as benchmarks to facilitate research,
but they are not enough to support product adoption since
different conÔ¨Ågurations of LiDAR sensors, locations, and so

on requires creating different datasets. Therefore, it is equally
important to provide annotation tools to enable more groups
to create their own datasets.
Annotation tools: Many efforts focus on improving anno-
tation tools to generate more data for deep learning training,
but most of the annotation tools are focusing on images.
VIA [12] provides a simple yet powerful webpage-based tool
for drawing bounding boxes and polygons on images. Later
works such as PolygonRNN [13], [14] seek to utilize more
advanced algorithms to facilitate and accelerate human anno-
tations. For video annotation, VATIC [15] integrates tracking
(mainly linear interpolation) to reduce annotating repeated
entities in consecutive frames. For autonomous driving ap-
plications, Yu et al. propose Scalabel [16], a package of tools
that support annotating bounding boxes and semantic masks
on images. Few works have focused on building LiDAR
annotation tools. The Apolloscape [6] dataset‚Äôs annotation
pipeline uses sensor fusion and image-based detection to
generate labels through images. But their 3D annotations are
for static backgrounds instead of moving objects. [17] adopts
a sensor-fusion strategy to generate LiDAR point cloud labels
using image-based detectors, and directly use them to train
LiDAR-based detectors. However, the correctness of such
labels is limited by the accuracy of the image detector,
projection and synchronization error. Moreover, neither [6]
nor [17] have open-sourced their annotation tools.
Data collection through simulation: To sidestep the
difÔ¨Åculty of data collection and annotation, many research
efforts aim at using simulation to generate LiDAR point
cloud data to train neural networks. Yue et al. [18] built
a LiDAR simulator on top of the video game GTA-V. The
simulated data are then used to train, evaluate, and verify
deep learning models [1], [2], [18]. Carla [19] is an open-
source simulator for autonomous driving, and it supports
image and LiDAR data generation. However, due to the
distribution shift between the simulated data and the real
world data, deep learning models trained on simulated data
perform poorly on the real world data. Many works aim
to close the gap between simulation and the real world by
domain adaptation [2]. Despite some promising progress,
domain adaptation remains a challenging problem and the
gap has been reduced but not closed. Therefore, collecting
and annotating real-world data is still critical.
III. METHOD
In this section, we discuss in detail three features of
LATTE that aim to accelerate LiDAR point cloud annotation:
sensor fusion, one-click annotation, and tracking.
A. Sensor Fusion
As shown in Fig.2(a), LiDAR point cloud are low reso-
lution and are difÔ¨Åcult for human annotators to recognize.
In comparison, cameras have higher resolution, and image-
based detection algorithms are more mature than LiDAR-
based. Therefore, we use image-based detection to help us
annotate LiDAR point cloud. Our pipeline is illustrated in
Fig. 3.
 2*/1$+ !$+$#(, &$
1.)$"3(-&/.(-3"+.4#3.3'$(, &$
-+ !$+$#(/.(-3"+.4#
43./1$+ !$+$#(/.(-3"+.4#
1.)$"3(.-
4$18
 !$+1 -2%$1
Fig. 3.
The sensor-fusion pipeline of LATTE. A LiDAR point cloud
is projected onto its corresponding image. Next, we use Mask-RCNN to
predict semantic labels on the image. The labels are then transferred back
to the LiDAR point cloud.
LiDAR sensors are paired with cameras, and the two
sensors are calibrated such that for each point pi with a 3D
coordinate (xi, yi, zi) in the point cloud, we can project it to
a pixel qi with a 2D coordinate (ui, vi) in the corresponding
image. The projection can be mathematically described as
qi = Ppi + t,
where P ‚ààR2√ó3 is the projection matrix and t ‚ààR2 is the
translation vector.
We then apply semantic segmentation on the image. In
our annotator, we use Mask R-CNN [20] to get semantic
labels for each pixel in the image. The semantic labels
can be regarded as a mask M such that for each pixel
qi with coordinates (ui, vi), we can Ô¨Ånd its label li as
li = M(ui, vi). Finally, this label can be transferred to
its corresponding point in the 3D space. This way, we can
automatically generate pre-labels for the point cloud.
We highlight the pre-labeled points in the original point
cloud such that human annotators can quickly identify ob-
jects of interest. After an annotator draws a bounding box
over the target object, we again project all the points in the
cluster back to the image, Ô¨Ånd the patch of the image that
contains the target object, crop the patch and show it to
human annotators for conÔ¨Årmation, as illustrated in Fig. 4.



	







Fig. 4.
We use sensor fusion to help annotators conÔ¨Årm the category of
a selected object. Once a 3D bounding box is chosen, we project all the
points within the bounding box to the image and show the corresponding
crop of the image to human annotators for visual conÔ¨Årmation.

B. One-click Annotation
In this section, we discuss how we simplify the annotation
operation from drawing point-wise labels to drawing 3D
bounding box, then to top-view 2D bounding boxes, and
eventually to simply one-click annotation. A comparison of
3D bounding box, top-view 2D bounding box, and one-click
annotation is illustrated in Fig.5.
LiDAR-based perception can be formulated as a bounding
box detection problem or a semantic segmentation problem.
The former requires annotating 3D bounding boxes as shown
in Fig.2(b), while the latter requires annotating point-wise
labels. Naively annotating each point to obtain point-wise
categorical labels is not feasible. Fortunately for 3D point
cloud, point-wise labels can be obtained from 3D bounding
boxes, as explained in [1]. For most of the road-objects
we care about, their bounding boxes do not overlap in 3D
space. As a result, point-wise labels can be converted from
3D bounding boxes, simply by treating each point inside a
bounding box as part of the target object and therefore with
the same the same categorical label.
However, drawing 3D bounding boxes is still operationally
complex. As illustrated in Fig. 5, ideally, drawing a 3D
bounding box requires 1 operation to locate the object, 3
operations to scale the sides of the bounding box, and 3
rotations to adjust the orientation. For autonomous driving
applications, what is more important is to locate the ob-
ject from the top-view. Therefore, we can simplify a 3D
bounding box to a top-view 2D bounding box, which can
be determined by its 2D center position, 2D sizes of width
and length, and its yaw angle. The operations needed to draw
such a bounding box include 1 locating operation, 2 scaling
operations, and 1 rotation, as illustrated in Fig. 5.
To further reduce the annotation complexity, we built one-
click annotation ‚Äì human annotators only need to click
on one point on the target object, as illustrated in Fig.
5. After the locating operations by human annotators, we
automatically apply clustering algorithms to Ô¨Ånd all the
points for the target object, from which we estimate a top-
view 2D bounding box for the target object. Then, human
annotators only need to adjust the automatically generated
bounding box if it does not Ô¨Åt the object perfectly. Our one-
click annotation is summarized in Fig. 6. It mainly contains
three steps: ground removal, clustering, and bounding box
estimation.
Ground removal: We model the ground as a segment of
planes where each plane is characterized by a linear model:
nT p = d,
where n = [a, b, c]T is the normal vector, p = [x, y, z]T is
a point at the plane, and d is the distance to the ground.
To determine the ground, we need to estimate the normal
vector n from the noisy LiDAR data. We initially estimate
the normal vector by sampling a set of lowest points in the
vertical ditection (z-direction). We denote the set as G0 and

		

		




." 3(-& ./2



" +(-&./2
	


.3 3(-&./2
	


.3 +



" +(-&./
.3 3(-&./
." 3(-&./
Fig. 5.
A comparison of drawing a 3D bounding box, a top-view 2D
bounding box, and one-click annotation.
1(&(- +
/.(-3"+.4#
1.4-#
1$,.5 +
+423$1(-&
.4-#(-&!.7
$23(, 3(.-
+("*$#/.(-3
7/ -#$#"+423$1
Fig. 6.
The one-click annotation pipeline of LATTE. For a given LiDAR
point cloud, we Ô¨Årst remove the ground. After an annotator clicks on one
point on a target object, we use clustering algorithms to expand from
the clicked point to the entire object. Finally, we estimate a top-view 2D
bounding box for the object.
compute the covariance matrix C0 ‚ààR3√ó3:
¬Øp =
1
|G0|
|G0|
X
i=1
pi,
C0 =
|G0|
X
i=1
(pi ‚àí¬Øp)(pi ‚àí¬Øp)T .
where ¬Øp is the mean of the points in G0 and the co-
variance matrix C0 represents how spread out the points
in G0 are. We analyze the direction of the dispersion by
computing its singular value decomposition (SVD). The
Ô¨Årst two singular vectors corresponding to the two largest
singular values represent the span of the plane. The singular
vector corresponding to the smallest singular value is a good
approximation for the normal because the variance in the
direction of the normal is smallest among all directions.
After computing the normal vector, we now have an
updated estimate of the ground plane. With our estimated
plane we resample the ground points by their distance and
iteratively update the normal vector:
Gk = {p : |nT
k‚àí1 ¬∑ p| < thresh}
where |nT
k‚àí1 ¬∑ p| is the distance between point p and the
plane whose normal vector at iteration k ‚àí1 is nk‚àí1.
The normal vector approximation and ground sampling are
repeated until the segmentation converges or for a Ô¨Åxed
number of iterations.
Clustering: After removing the ground we Ô¨Ånd the nearest
cluster to the point on which the human annotator clicks.
The clustering algorithm is based on density-based spatial

clustering of applications with noise (DBSCAN) [21] and is
described in Algorithm 1, where FindNeighbor(p, X, œµ) Ô¨Ånds
the neigbors in X that are œµ-close to p.
Algorithm 1: Clustering Algorithm
Input: seed s ‚ààR3, point cloud P ‚ààRn√ó3, distance
threshold œµ
Output: cluster C ‚ààRm√ó3
seen = ‚àÖ, initialize Q;
Q.push(seed);
while Q not empty do
neighbors = FindNeighbors(Q.pop(), P, œµ);
for neighbor in neighbors do
if neighbor not in seen then
seen.add(neighbor);
Q.push(neighbor);
end
end
end
return seen;
Since LiDAR point clouds can contain a large number of
points (approximately 100,000 points per frame for Velodyne
LiDAR), we perform pruning and downsampling in order to
make one-click annotation efÔ¨Åcient. Fig. 8 shows that the
distribution of bounding box sizes is concentrated around
6m2 which is the size of a typical car. Therefore we can
assume an upper bound on the dimensions of an object and
appropriately prune the point cloud.
Bounding box estimation: After we Ô¨Ånd the cluster, we
use a search-based rectangle Ô¨Åtting [22] to estimate bounding
boxes. Other methods, such as PCA based ones, can also be
plugged into LATTE. To have the optimal rectangle Ô¨Åtting
for a cluster, we need to know the appropriate heading of
the rectangle. Ideally, the rectangle can be found by solving
the following optimization problem:
argmin
Œ∏,U,V,c1,c2
X
i‚àà|U|
(xi cos Œ∏ + yi sin Œ∏ ‚àíc1)2+
X
j‚àà|V |
(‚àíxj sin Œ∏ + yj cos Œ∏ ‚àíc2)2,
subject to
U ‚à™V = G, U ‚à©V = ‚àÖ,
which aims to partition observed points in G into two
mutually exclusive groups U and V depending on which
edges they are closer to. Points in U are closer to the
edge x cos Œ∏ + y sin Œ∏ ‚àíc1, and points in V are closer to
‚àíx sin Œ∏ + y cos Œ∏ ‚àíc2.
Due to the combinatorial nature of the problem, it is
infeasible to solve it exactly. To solve this problem approxi-
mately and efÔ¨Åciently, we use search-based rectangle Ô¨Åtting
algorithm [22] that searches headings and projects the points
in the cluster to two perpendicular edges. It searches the
optimal heading to minimize a loss function as:
Œ∏‚àó= argmin
Œ∏‚àà[0,œÄ]
L(GeŒ∏,1, GeŒ∏,2),
where G ‚ààRn√ó2 denotes a matrix where each row contains
the (x, y)-coordinate of a point. eŒ∏,1 = [cos Œ∏, sin Œ∏]T , eŒ∏,2 =
[‚àísin Œ∏, cos Œ∏]T are orthogonal unit vectors representing
the directions of two perpendicular edges. The loss func-
tion L(¬∑, ¬∑) is deÔ¨Åned as the following. We denote c1 =
GeŒ∏,1, c2 = GeŒ∏,2, which represent projection of points to
eŒ∏,1, eŒ∏,2. Then the distances from points in G to the closer
edge is computed as
d1 =
argmin
v‚àà{c1‚àímin{c1},c1‚àímax{c1}}
‚à•v‚à•2,
d2 =
argmin
v‚àà{c2‚àímin{c2},c2‚àímax{c2}}
‚à•v‚à•2.
We can then divide all the points to two groups according
to above distances and compute the loss function as
L(GeŒ∏,1, GeŒ∏,2) = ‚àíVar({d1,i : d1,i < d2,i})
‚àíVar({d2,i : d2,i < d1,i})
where d1,i is the i-th element of d1, and similar for d2,i.
Var(¬∑) computes the variance of a set of values. After solving
for the optimal heading Œ∏‚àó, the following equations are used
to compute the four edges of the rectangle:
Edge 1:x cos Œ∏‚àó+ y sin Œ∏‚àó‚àímin{c‚àó
1} = 0
Edge 2:x cos Œ∏‚àó+ y sin Œ∏‚àó‚àímax{c‚àó
1} = 0
Edge 3: ‚àíx sin Œ∏‚àó+ y cos Œ∏‚àó‚àímin{c‚àó
2} = 0
Edge 4: ‚àíx sin Œ∏‚àó+ y cos Œ∏‚àó‚àímax{c‚àó
2} = 0
where c‚àó
1 = GeŒ∏‚àó,1, c‚àó
2 = GeŒ∏‚àó,2.
C. Tracking
To accelerate annotation on sequences, we integrate track-
ing to LATTE such that annotations from one frame can be
transferred to subsequent ones, as illustrated in Fig. 7.
 +, -(+3$1
!2$15 3(.-3
1$#("3(.-3
 +, -(+3$1
1$#("3(.-3
!2$15 3(.-3
9
1 ,$3
1 ,$3
1 ,$3
Fig. 7.
Tracking pipeline of LATTE. Annotators label a bounding box in
the initial frame. Next, we use Kalman Ô¨Åltering to predict the center position
of the bounding box at the next frame. Human annotators then adjust the
bounding box, and we use the new center position as a new observation to
update the Kalman Ô¨Ålter.
LATTE is constructed in a modular way such that it can
support different tracking algorithms, but we adopt Kalman
Ô¨Åltering [23] in our implementation. We use Kalman Ô¨Åltering

to track the bounding box center of a target object. Human
annotators need to label the Ô¨Årst frame of a sequence. Next,
our algorithm predicts the centers of bounding boxes for the
next frame. For non-rigid objects (such as pedestrians), their
bounding boxes do not have Ô¨Åxed shapes. Therefore, we re-
estimate the bounding boxes using a similar algorithm as
the one-click annotation, as described in section III-B. For
rigid objects such as cars, their bounding boxes should not
change over time, so we only estimate the yaw angle. The
predicted bounding box is displayed at the next frame, and
the human annotator can simply make adjustments to the
bounding boxes. The adjusted bounding boxes then serve as
observations in the Kalman update step.
Formally, we deÔ¨Åne the state vector of a bounding box
at frame k as xk = [px, py, vx, vy, ax, ay]T , where px and
py are the coordinates for the center of the bounding box
at frame k. vx, vy and ax, ay represent the velocity and
acceleration of the center, respectively. A human annotates
the Ô¨Årst frame in the sequence, and we can obtain the
initial values for the center position. The initial velocity and
acceleration values are left to be zero. Next, we predict the
center coordinates at the next frame as
ÀÜxk|k‚àí1 = F ÀÜxk‚àí1|k‚àí1,
Pk|k‚àí1 = FPk‚àí1|k‚àí1F T + Q,
where F ‚ààR6√ó6 represents the state transition model. We
assume a constant acceleration model and deÔ¨Åne F as
F =
Ô£Æ
Ô£ØÔ£ØÔ£ØÔ£ØÔ£ØÔ£ØÔ£∞
1
0
‚àÜt
0
1
2‚àÜt2
0
0
1
0
‚àÜt
0
1
2‚àÜt2
0
0
1
0
‚àÜt
0
0
0
0
1
0
‚àÜt
0
0
0
0
1
0
0
0
0
0
0
1
Ô£π
Ô£∫Ô£∫Ô£∫Ô£∫Ô£∫Ô£∫Ô£ª
,
where ‚àÜt is the sampling interval of the sensor. Q ‚àà
R6√ó6 represents the process noise covariance matrix and is
modeled as Q = diag(nx, ny, nvx, nvy, nax, nay), where the
coefÔ¨Åcients are tuned by trial-and-error. The values are based
their on the units of the state vector (m, m/s, m/s2) and
their uncertainty level. Since we can directly observe center
coordinates, we have higher certainty for nx and ny than
others. ÀÜxk‚àí1|k‚àí1 represents the a posteriori state estimate at
time k ‚àí1 given observations up to and including at time k.
Pk‚àí1|k‚àí1 ‚ààR6√ó6 represents the a posteriori error covariance
matrix, and the initial value P0|0 is estimated empirically by
computing the error covariance matrix on a sample of 100
tracking objects.
Based on the center position prediction, we then estimate
the bounding box at frame k and ask the human annotator
to adjust it. The adjusted bounding box provides us an
observation of the new center coordinates zk = [px,k, py,k]T ,
which we use to update the Kalman Ô¨Ålter as
Àúyk = zk ‚àíHÀÜxk|k‚àí1,
Kk = Pk|k‚àí1HT (R + HPk|k‚àí1HT )‚àí1,
ÀÜxk|k = ÀÜxk|k‚àí1 + KkÀúyk,
Pk|k = (I ‚àíKkH)Pk|k‚àí1(I ‚àíKkH)T + KkRKT
k ,
where H ‚ààR2√ó6 is the observation model. Since we only
observe the center position through, we deÔ¨Åne
H =

1
0
0
0
0
0
0
1
0
0
0
0

.
R ‚ààR2√ó2 is the covariance of the observation noise and
is deÔ¨Åned as R = diag(‚àÜx, ‚àÜy) where ‚àÜx and ‚àÜy are the
resolution of the LiDAR scanner in the x and y direction.
We iteratively apply Kalman Ô¨Åltering from the Ô¨Årst frame to
the end, as shown in Fig. 7.
IV. EXPERIMENTS
A. Experiment Setup
Providing precise quantitative measurements of produc-
tivity improvements using human subjects is quite time
consuming and complicated [24]. Nevertheless, while we feel
that the productivity advantages of features such as ‚Äùone-
click annotation‚Äù are obvious, we wanted to provide some
estimate of the productivity improvements that LATTE pro-
vided. So, to estimate productivity we simply measured the
time and operation count used by volunteers using LATTE
to annotate LiDAR point cloud data from the KITTI dataset
[5]. The KITTI dataset involves eight object categories
and includes 3D Velodyne point cloud data, accompanying
color images, GPS/IMU data, 3D object tracklet labels, and
camera-to-Velodyne calibration data. We randomly selected
30 sequences of LiDAR data, where each sequence contains
Ô¨Åve frames. This test benchmark contains a total amount of
1,116 instances. More detailed analysis of object statistics
can be found in Fig. 8.
We asked nine volunteers to annotate these frames using
LATTE with all three features (sensor fusion, one-click
annotation, and tracking). We divide the data and volunteers
such that each feature is evaluated on the entire dataset. In
other words each frame is annotated using each feature so
that every feature is evaluated on the same frames. This is
to ensure that we are testing each feature on the same data.
The annotators were asked to draw bounding boxes for
instances for which they feel conÔ¨Ådent, for example instances
of vehicles where at least two complete edges are visible.
Instances that are far away tend to be sparse or occluded
and are therefore not annotated. We only evaluate objects
whose bounding box intersects with a ground truth bounding
box. To form a baseline for comparison, we asked volunteers
to draw top-view 2D bounding boxes on the test LiDAR
point cloud without using LATTE‚Äôs advanced features. To
further evaluate the efÔ¨Åcacy of each component, we also
asked volunteers to use only one of the three features for
annotation. Each volunteer annotates a sequence of 5 frames
with one feature a time. We also asked the volunteers to
annotate with a fully-featured version of the tool. In order to
eliminate the case where annotation efÔ¨Åciency is improved
solely due to the fact that the annotator has seen the frame
before, each frame is seen only once by each volunteer.
Therefore we do not falsely attribute an improvement in
efÔ¨Åciency to the feature we are testing.

car
pedestrian cyclist
truck
van
0
200
400
600
800
1,000
Class Label
Distribution of Class Labels
0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30
0
50
100
150
200
250
Bounding Box Area (m2)
Distribution of Bounding Box Sizes xtick style
0
45
90
135
180
225
270
315
0
200
400
600
Bounding Box Orientation (Degrees)
Distribution of Bounding Box Orientations
Fig. 8.
Distribution of bounding boxes by class, box area, and orientation in our test benchmark.
B. Metrics
To evaluate the accuracy of annotations, we used our
own ground truth instead of using the bounding boxes from
KITTI dataset. This is because bounding boxes provided by
KITTI do not include all instances in a scene, particularly
the ones that are behind the drive. Therefore, we asked an
expert human annotator to provide high-quality annotations
as ground truth. We measure the intersection-over-union
(IoU) between an annotated bounding box and the ground
truth as the accuracy metric per instance, and we report
the IoU averaged over all the instances annotated by all of
the volunteers. Note that comparing our ground truth with
KITTI‚Äôs bounding boxes, we see 86.0% average IoU.
To better understand the typical agreement between two
human annotators, we ask different volunteers to use LATTE
to label the same frames and instances, and compute the
pair-wise IoU agreement per instance. Among 452 pairs of
annotations on 132 instances, the average IoU is 84.5% with
a standard deviation of 8.74%. This serves as a reference for
considering other IoU results. In addition, we select a few
samples of bounding box annotations and compare them with
our ground truth and KITTI‚Äôs annotation in Fig. 9. As we
can see, the IoU between each pairs ranges from 78.1% to
93.8%, but the bounding boxes are very similar to each other.

306/%5365)
 0-6/5&&3
)&
	







)&# ("'%




	
)&# ("'%



	


Fig. 9.
Visualization of bounding box annotations from our volunteers,
our ground truth, and KITTI. The IoU between each pair listed.
Another factor of accuracy is the correct identiÔ¨Åcation of
objects of interest. To evaluate this, we measure the instance-
level precision and recall. An annotation has to have more
than 50% of the IoU with a ground truth box in order to
be considered a true positive. This is different from the IoU
above since IoU is counted on objects that are both annotated
by a volunteer and the ground truth. We report the IoU result
in Table I and the precision and recall in Table II.
To evaluate efÔ¨Åciency, we record the time spent on anno-
tation per instance. In addition, we also measure the number
of annotation operations, which is deÔ¨Åned as bounding
box adjustments (resizing, rotation, translation) and assigning
classes. The efÔ¨Åciency result is reported in Table I.
C. Results
TABLE I
ACCURACY AND EFFICIENCY OF LATTE.
Method
IoU (%)
IoU(%)
w/ KITTI
Time (s)
#ops
Ground Truth
100.0
86.0
-
-
Baseline
85.5
82.3
9.51
3.76
Sensor fusion
86.3
82.5
3.88
2.88
One-click annotation
86.2
82.9
2.55
1.29
Tracking
86.4
83.5
2.41
1.53
Full features
87.5
84.7
1.53
1.02
The accuracy and efÔ¨Åciency of LATTE is listed. The ‚ÄúIoU‚Äù column
shows the average IoU of annotation vs. our ground truth. The ‚ÄúIoU w/
KITTI‚Äù column shows the average IoU of annotations vs. the KITTI
ground truth. The ‚ÄúTime‚Äù column shows the average time spent on
annotating one instance. The ‚Äú#ops‚Äù column shows the average number
of operations spent on annotating one instance. As a reference for the
IoU result, the average pair-wise IoU from different annotators is 84.5%
with a standard deviation of 8.74%.
TABLE II
INSTANCE-LEVEL PRECISION & RECALL OF LATTE
Method
Precision (%)
Recall (%)
Baseline
69.9
82.9
Sensor fusion
83.9
85.0
One-click annotation
78.8
84.8
Tracking
91.8
85.2
Full features
93.5
85.1
Baseline: Since there are no other open-source tools with
similar functionality, we compare LATTE to a stripped down
version with all of the new features removed. The volunteers
are asked to manually annotate all instances by drawing top-
view bounding boxes, as illustrated in Fig. 5. From Table
I, we can see that it takes an average of 9.51s, and 3.76
operations to annotate one instance. Despite the longer time,
the label quality is the poorest among all variations. The IoU

with the ground truth is just 85.5%, the precision is 69.9%,
and the recall is 82.9%.
Full features: To test LATTE with all of the features, we
ask the volunteers to use the following workÔ¨Çow. For the
Ô¨Årst frame of a sequence, we use sensor fusion to highlight
objects of interest and ask human annotators to use one-click
annotation to draw annotations and make necessary adjust-
ments. After volunteers are conÔ¨Ådent with Ô¨Årst frame, they
can move on to the next frame, where tracking will generate
bounding box proposals for volunteers to verify and adjust.
The full features show a 6.2 times speed-up in annotation
time and 3.7 times reduction in number of operations while
achieving higher IoU at 87.5% over the baseline‚Äôs 85.5%,
higher recall (85.1% vs. 82.9%) and signiÔ¨Åcantly higher
precision (93.5% vs. 69.9%). We visualize some samples
of annotations and compare them with the ground truth and
KITTI dataset‚Äôs annotations in Fig. 9.
Ablation study: To study the effectiveness of each of the
proposed features, we ask volunteers to use a variation of
LATTE with only one feature enabled. When volunteers are
only allowed to use the sensor fusion feature, we are able
to achieve a 2.4 times speed-up in annotation time compared
to the baseline while achieving higher IoU (+0.8%), recall
(+2.1%), and signiÔ¨Åcantly higher precision (+14.0%). In
addition, the number of operations per instance on average
reduces by 0.9, nearly an entire operation. This supports
our claim that sensor fusion helps human annotators to
better recognize objects from point clouds. With only one-
click annotation, our method shows a 3.8 times speed-
up in annotation time and 2.9 reduction in the number of
annotation operations while achieving higher IoU, precision
and recall. With only tracking, we show a speed-up of
4.74x while achieving better annotation agreement than the
baseline. This is largely due to the fact that tracking saved
redundant annotations on sequential frames.
V. CONCLUSIONS
EfÔ¨Åciently annotating LiDAR point clouds at scale is cru-
cial for the development of LiDAR-based detection and au-
tonomous driving. However, annotating LiDAR point clouds
is difÔ¨Åcult due to the challenges of low resolution, complex
annotating operations, and sequential correlation. To solve
these problems, we propose LATTE, an open-sourced Li-
DAR annotation tool that features sensor-fusion, one-click
annotation, and tracking. Based on our own experiments we
estimate that LATTE achieves a 6.2x speedup compared with
baseline annotation tools and delivers better label quality
with 23.6% and 2.2% higher instance-level precision and
recall, and 2.0% higher bounding box IoU.
REFERENCES
[1] B. Wu, A. Wan, X. Yue, and K. Keutzer, ‚ÄúSqueezeseg: Convolutional
neural nets with recurrent crf for real-time road-object segmentation
from 3d lidar point cloud,‚Äù in 2018 IEEE International Conference on
Robotics and Automation (ICRA).
IEEE, 2018, pp. 1887‚Äì1893.
[2] B. Wu, X. Zhou, S. Zhao, X. Yue, and K. Keutzer, ‚ÄúSqueezesegv2:
Improved model structure and unsupervised domain adaptation for
road-object segmentation from a lidar point cloud,‚Äù arXiv preprint
arXiv:1809.08495, 2018.
[3] C. R. Qi, W. Liu, C. Wu, H. Su, and L. J. Guibas, ‚ÄúFrustum
pointnets for 3d object detection from rgb-d data,‚Äù arXiv preprint
arXiv:1711.08488, 2017.
[4] B. Li, T. Zhang, and T. Xia, ‚ÄúVehicle detection from 3d lidar using
fully convolutional network,‚Äù arXiv preprint arXiv:1608.07916, 2016.
[5] A. Geiger, P. Lenz, and R. Urtasun, ‚ÄúAre we ready for autonomous
driving? the kitti vision benchmark suite,‚Äù in Computer Vision and
Pattern Recognition (CVPR), 2012 IEEE Conference on. IEEE, 2012,
pp. 3354‚Äì3361.
[6] X. Huang, X. Cheng, Q. Geng, B. Cao, D. Zhou, P. Wang, Y. Lin,
and R. Yang, ‚ÄúThe apolloscape dataset for autonomous driving,‚Äù in
Proceedings of the IEEE Conference on Computer Vision and Pattern
Recognition Workshops, 2018, pp. 954‚Äì960.
[7] B. Douillard, J. Underwood, N. Kuntz, V. Vlaskine, A. Quadros,
P. Morton, and A. Frenkel, ‚ÄúOn the segmentation of 3d lidar point
clouds,‚Äù in Robotics and Automation (ICRA), 2011 IEEE International
Conference on.
IEEE, 2011, pp. 2798‚Äì2805.
[8] M. Himmelsbach, A. Mueller, T. L¬®uttel, and H.-J. W¬®unsche, ‚ÄúLidar-
based 3d object perception,‚Äù in Proceedings of 1st international
workshop on cognition for technical systems, vol. 1, 2008.
[9] D. Z. Wang, I. Posner, and P. Newman, ‚ÄúWhat could move? Ô¨Ånding
cars, pedestrians and bicyclists in 3d laser data,‚Äù in Robotics and
Automation (ICRA), 2012 IEEE International Conference on.
IEEE,
2012, pp. 4038‚Äì4044.
[10] C. R. Qi, H. Su, K. Mo, and L. J. Guibas, ‚ÄúPointnet: Deep learning
on point sets for 3d classiÔ¨Åcation and segmentation,‚Äù in CVPR, 2017,
pp. 77‚Äì85.
[11] C. R. Qi, L. Yi, H. Su, and L. J. Guibas, ‚ÄúPointnet++: Deep
hierarchical feature learning on point sets in a metric space,‚Äù in NIPS,
2017, pp. 5099‚Äì5108.
[12] A. Dutta, A. Gupta, and A. Zissermann, ‚ÄúVGG image annotator
(VIA),‚Äù http://www.robots.ox.ac.uk/‚àºvgg/software/via/, 2016.
[13] L. Castrejon, K. Kundu, R. Urtasun, and S. Fidler, ‚ÄúAnnotating object
instances with a polygon-rnn,‚Äù in Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition, 2017, pp. 5230‚Äì5238.
[14] D. Acuna, H. Ling, A. Kar, and S. Fidler, ‚ÄúEfÔ¨Åcient interactive
annotation of segmentation datasets with polygon-rnn++,‚Äù 2018.
[15] C. Vondrick, D. Patterson, and D. Ramanan, ‚ÄúEfÔ¨Åciently scaling up
crowdsourced video annotation,‚Äù International Journal of Computer
Vision, pp. 1‚Äì21, 10.1007/s11263-012-0564-1. [Online]. Available:
http://dx.doi.org/10.1007/s11263-012-0564-1
[16] F. Yu, W. Xian, Y. Chen, F. Liu, M. Liao, V. Madhavan, and T. Darrell,
‚ÄúBdd100k: A diverse driving video database with scalable annotation
tooling,‚Äù arXiv preprint arXiv:1805.04687, 2018.
[17] F. Piewak, P. Pinggera, M. Schafer, D. Peter, B. Schwarz, N. Schneider,
M. Enzweiler, D. Pfeiffer, and M. Zollner, ‚ÄúBoosting lidar-based
semantic labeling by cross-modal training data generation,‚Äù in Pro-
ceedings of the European Conference on Computer Vision (ECCV),
2018, pp. 0‚Äì0.
[18] X. Yue, B. Wu, S. A. Seshia, K. Keutzer, and A. L. Sangiovanni-
Vincentelli, ‚ÄúA lidar point cloud generator: from a virtual world to
autonomous driving,‚Äù in Proceedings of the 2018 ACM on Interna-
tional Conference on Multimedia Retrieval.
ACM, 2018, pp. 458‚Äì
464.
[19] A. Dosovitskiy, G. Ros, F. Codevilla, A. Lopez, and V. Koltun,
‚ÄúCARLA: An open urban driving simulator,‚Äù in Proceedings of the
1st Annual Conference on Robot Learning, 2017, pp. 1‚Äì16.
[20] K. He, G. Gkioxari, P. Doll¬¥ar, and R. Girshick, ‚ÄúMask r-cnn,‚Äù in
Proceedings of the IEEE international conference on computer vision,
2017, pp. 2961‚Äì2969.
[21] M. Ester, H.-P. Kriegel, J. Sander, and X. Xu, ‚ÄúA density-based
algorithm for discovering clusters a density-based algorithm for
discovering clusters in large spatial databases with noise,‚Äù in
Proceedings of the Second International Conference on Knowledge
Discovery and Data Mining, ser. KDD‚Äô96.
AAAI Press, 1996,
pp. 226‚Äì231. [Online]. Available: http://dl.acm.org/citation.cfm?id=
3001460.3001507
[22] X. Zhang, W. Xu, C. Dong, and J. M. Dolan, ‚ÄúEfÔ¨Åcient l-shape Ô¨Åtting
for vehicle detection using laser scanners,‚Äù in 2017 IEEE Intelligent
Vehicles Symposium, June 2017.
[23] G. Welch and G. Bishop, ‚ÄúAn introduction to the kalman Ô¨Ålter,‚Äù Chapel
Hill, NC, USA, Tech. Rep., 1995.
[24] J. Lazar, J. H. Feng, and H. Hochheiser, Research methods in human-
computer interaction.
Morgan Kaufmann, 2017.

