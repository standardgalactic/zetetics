Lectures on the
Curry-Howard Isomorphism
Morten Heine B. Sørensen
University of Copenhagen
PaweÃl Urzyczyn
University of Warsaw


Preface
The Curry-Howard isomorphism states an amazing correspondence between
systems of formal logic as encountered in proof theory and computational
calculi as found in type theory. For instance, minimal propositional logic
corresponds to simply typed λ-calculus, ﬁrst-order logic corresponds to de-
pendent types, second-order logic corresponds to polymorphic types, etc.
The isomorphism has many aspects, even at the syntactic level: formulas
correspond to types, proofs correspond to terms, provability corresponds to
inhabitation, proof normalization corresponds to term reduction, etc.
But there is much more to the isomorphism than this. For instance,
it is an old idea—due to Brouwer, Kolmogorov, and Heyting, and later
formalized by Kleene’s realizability interpretation—that a constructive proof
of an implication is a procedure that transforms proofs of the antecedent
into proofs of the succedent; the Curry-Howard isomorphism gives syntactic
representations of such procedures.
These notes give an introduction to parts of proof theory and related
aspects of type theory relevant for the Curry-Howard isomorphism.
Outline
Since most calculi found in type theory build on λ-calculus, the notes be-
gin, in Chapter 1, with an introduction to type-free λ-calculus. The intro-
duction derives the most rudimentary properties of β-reduction including
the Church-Rosser theorem. It also presents Kleene’s theorem stating that
all recursive functions are λ-deﬁnable and Church’s theorem stating that
β-equality is undecidable.
As explained above, an important part of the Curry-Howard isomor-
phism is the idea that a constructive proof of an implication is a certain
procedure. This calls for some elaboration of what is meant by constructive
proofs, and Chapter 2 therefore presents intuitionistic propositional logic.
The chapter presents a natural deduction formulation of minimal and intu-
itionistic propositional logic. The usual semantics in terms of Heyting alge-
bras and in terms of Kripke models are introduced—the former explained
i

ii
Preface
on the basis of Boolean algebras—and the soundness and completeness re-
sults are then proved.
An informal proof semantics, the so-called BHK-
interpretation, is also presented.
Chapter 3 presents the simply typed λ-calculus and its most fundamen-
tal properties up to the subject reduction property and the Church-Rosser
property. The distinction between simply typed λ-calculus `a la Church and
`a la Curry is introduced, and the uniqueness of types property—which fails
for the Curry system—is proved for the Church system. The equivalence
between the two systems, in a certain sense, is also established. The chapter
also proves the weak normalization property by the Turing-Prawitz method,
and ends with Schwichtenberg’s theorem stating that the numeric functions
representable in simply typed λ-calculus are exactly the extended polyno-
mials.
This provides enough background material for our ﬁrst presentation of
the Curry-Howard isomorphism in Chapter 4, as it appears in the con-
text of natural deduction for minimal propositional logic and simpy typed
λ-calculus. The chapter presents another formulation of natural deduction,
which is often used in the proof theory literature, and which facilitates a ﬁner
distinction between similar proofs. The exact correspondence between nat-
ural deduction for minimal propositional logic and simply typed λ-calculus
is then presented. The extension to product and sum types is also discussed.
After a brief part on proof-theoretical applications of the weak normaliza-
tion property, the chapter ends with a proof of strong normalization using
the Tait-Girard method, here phrased in terms of saturated sets.
Chapter 5 presents the variation of the Curry-Howard isomorphism in
which one replaces natural deduction by Hilbert style proofs and simply
typed λ-calculus by simply typed combinatory logic. After type-free com-
binators and weak reduction—and the Church-Rosser property—the usual
translations from λ-calculus to combinators, and vice versa, are introduced
and shown to preserve some of the desired properties pertaining to weak
reduction and β-reduction. Then combinators with types are introduced,
and the translations studied in this setting.
Finally Hilbert-style proofs
are introduced, and the connection to combinators with types proved. The
chapter ends with a part on subsystems of combinators in which relevance
and linearity play a role.
Having seen two logics or, equivalently, two calculi with types, Chapter 6
then studies decision problems in these calculi, mainly the type checking,
the type reconstruction, and the type inhabitation problem. The type re-
construction problem is shown to be P-complete by reduction to and from
uniﬁcation (only the reduction to uniﬁcation is given in detail). The type
inhabitation problem is shown to be PSPACE-complete by a reduction from
the satisﬁability problem for classical second-order propositional formulas.
The chapter ends with Statman’s theorem stating that equality on typed
terms is non-elementary.

Outline
iii
After introducing natural deduction systems and Hilbert-style systems,
the notes introduce in Chapter 7 Gentzen’s sequent calculus systems for
propositional logic. Both classical and intuitionistic variants are introduced.
In both cases a somewhat rare presentation—taken from Prawitz—with as-
sumptions as sets, not sequences, is adopted. For the intuitionistic system
the cut-elimination theorem is mentioned, and from this the subformula
property and decidability of the logic are inferred. Two aproaches to term
assignment for sequent calculus proofs are studied. In the ﬁrst approach,
the terms are those of the simply typed λ-calculus. For this approach, the
connection between normal forms and cut-free proofs is studied in some de-
tail. In the second approach, the terms are intended to mimic exactly the
rules of the calculus, and this assignment is used to prove the cut-elimination
theorem in a compact way.
The remaining chapters study variations of the Curry-Howard isomor-
phism for more expressive type systems and logics.
In Chapter 8 we consider the most elementary connections between nat-
ural deduction for classical propositional logic and simply typed λ-calculus
with control operators, in particular, the correspondence between classical
proof normalization and reduction of control operators. Kolmogorov’s em-
bedding of classical logic into intuitionistic logic is shown to induce a con-
tinuation passing style translation which eliminates control operators.
Chapter 9 is about ﬁrst-order logic. After a presentation of the syntax
for quantiﬁers, the proof systems and interpretations seen in earlier chapters
are generalized to the ﬁrst-order case.
Chapter 10 presents dependent types, as manifest in the calculus λP.
The strong normalization property is proved by a translation to simply typed
λ-calculus. A variant of λP `a la Curry is introduced. By another translation
it is shown that a term is typable in λP `a la Curry iﬀit is typable in simply
typed λ-calculus. While this shows that type reconstruction is no harder
than in simply typed λ-calculus, the type checking problem in λP `a la Curry
turns out to be undecidable. The last result of the chapter shows that ﬁrst-
order logic can be encoded in λP.
In Chapter 11 we study arithmetic. The chapter introduces Peano Arith-
metic (PA) and brieﬂy recalls G¨odel’s theorems and the usual result stating
that exactly the recursive functions can be represented in Peano Arithmetic.
The notion of a provably total recursive function is also introduced. Heyt-
ing arithmetic (HA) is then introduced and Kreisel’s theorem stating that
provable totality in HA and PA coincide is presented. Then Kleene’s real-
izability interpretation is introduced—as a way of formalizing the BHK-
interpretation—and used to prove consistency of HA. G¨odel’s system T
is then introduced and proved to be strongly normalizing. The failure of
arithmetization of proofs of this property is mentioned. The result stating
that the functions deﬁnable in T are the functions provably total in Peano
Arithmetic is also presented. Finally, G¨odel’s Dialectica interpretation is

iv
Preface
presented and used to prove consistency of HA and to prove that all func-
tions provably total in Peano Arithmetic are deﬁnable in T.
Chapter 12 is about second-order logic and polymorphism. For the sake
of simplicity, only second-order propositional systems are considered. Natu-
ral deduction, Heyting algebras, and Kripke models are extended to the new
setting. The polymorphic λ-calculus is then presented, and the correspon-
dence with second-order logic developed. After a part about deﬁnability
of data types, a Curry version of the polymorphic λ-calculus is introduced,
and Wells’ theorem stating that type reconstruction and type checking are
undecidable is mentioned. The strong normalization property is also proved.
The last chapter, Chapter 13, presents the λ-cube and pure type systems.
First Barendregt’s cube is presented, and its systems shown equivalent to
previous formulations by means of a classiﬁcation result. Then the cube is
geneneralized to pure type systems which are then developed in some detail.
About the notes
Each chapter is provided with a number of exercises. We recommend that
the reader try as many of these as possible. At the end of the notes, answers
and hints are provided to some of the exercises.1
The notes cover material from the following sources:
• Girard, Lafont, Taylor: Proofs and Types, Cambridge Tracts in Theo-
retical Computer Science 7, 1989.
• Troelstra, Schwichtenberg: Basic Proof Theory, Cambridge Tracts in
Theoretical Computer Science 43, 1996.
• Hindley: Basic Simple Type Theory, Cambridge Tracts in Theoretical
Computer Science 42, 1997.
• Barendregt: Lambda Calculi with Types, pages 117–309 of Abram-
sky, S. and D.M. Gabbay and T.S.E. Maibaum, editors, Handbook of
Logic in Computer Science, Volume II, Oxford University Press, 1992.
Either of these sources make excellent supplementary reading.
The notes are largely self-contained, although a greater appreciation of
some parts can probably be obtained by readers familiar with mathemat-
ical logic, recursion theory and complexity. We recommend the following
textbooks as basic references for these areas:
• Mendelson: Introduction to Mathematical Logic, fourth edition, Chap-
man & Hall, London, 1997.
1This part is quite incomplete due to the “work-in-progress” character of the notes.

About the notes
v
• Jones: Computability and Complexity From a Programming Perspec-
tive, MIT Press, 1997.
The notes have been used for a one-semester graduate/Ph.D. course
at the Department of Computer Science at the University of Copenhagen
(DIKU). Roughly one chapter was presented at each lecture, sometimes
leaving material out.
The notes are still in progress and should not be conceived as having
been proof read carefully to the last detail. Nevertheless, we are grateful
to the students attending the course for pointing out numerous typos, for
spotting actual mistakes, and for suggesting improvements to the exposition.
This joint work was made possible thanks to the visiting position funded
by the University of Copenhagen, and held by the second author at DIKU
in the winter and summer semesters of the academic year 1997-8.
M.H.B.S. & P.U., May 1998

vi

Contents
Preface
i
Outline
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
i
About the notes
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
iv
1
Type-free λ-calculus
1
1.1
λ-terms
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Reduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.3
Informal interpretation . . . . . . . . . . . . . . . . . . . . . .
7
1.4
The Church-Rosser Theorem
. . . . . . . . . . . . . . . . . .
8
1.5
Expressibility and undecidability . . . . . . . . . . . . . . . .
11
1.6
Historical remarks
. . . . . . . . . . . . . . . . . . . . . . . .
19
1.7
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2
Intuitionistic logic
23
2.1
Intuitive semantics . . . . . . . . . . . . . . . . . . . . . . . .
24
2.2
Natural deduction
. . . . . . . . . . . . . . . . . . . . . . . .
25
2.3
Algebraic semantics of classical logic . . . . . . . . . . . . . .
28
2.4
Heyting algebras . . . . . . . . . . . . . . . . . . . . . . . . .
30
2.5
Kripke semantics . . . . . . . . . . . . . . . . . . . . . . . . .
34
2.6
The implicational fragment
. . . . . . . . . . . . . . . . . . .
36
2.7
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
3
Simply typed λ-calculus
41
3.1
Simply typed λ-calculus `a la Curry . . . . . . . . . . . . . . .
41
3.2
Simply typed λ-calculus `a la Church . . . . . . . . . . . . . .
45
3.3
Church versus Curry typing . . . . . . . . . . . . . . . . . . .
49
3.4
Normalization . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
3.5
Expressibility . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
3.6
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
vii

viii
Contents
4
The Curry-Howard isomorphism
57
4.1
Natural deduction without contexts
. . . . . . . . . . . . . .
57
4.2
The Curry-Howard isomorphism
. . . . . . . . . . . . . . . .
63
4.3
Consistency from normalization . . . . . . . . . . . . . . . . .
68
4.4
Strong normalization . . . . . . . . . . . . . . . . . . . . . . .
68
4.5
Historical remarks
. . . . . . . . . . . . . . . . . . . . . . . .
71
4.6
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
5
Proofs as combinators
75
5.1
Combinatory logic
. . . . . . . . . . . . . . . . . . . . . . . .
75
5.2
Typed combinators . . . . . . . . . . . . . . . . . . . . . . . .
79
5.3
Hilbert-style proofs . . . . . . . . . . . . . . . . . . . . . . . .
81
5.4
Relevance and linearity
. . . . . . . . . . . . . . . . . . . . .
83
5.5
Historical remarks
. . . . . . . . . . . . . . . . . . . . . . . .
87
5.6
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
6
Type-checking and related problems
89
6.1
Hard and complete . . . . . . . . . . . . . . . . . . . . . . . .
90
6.2
The 12 variants . . . . . . . . . . . . . . . . . . . . . . . . . .
91
6.3
(First-order) uniﬁcation . . . . . . . . . . . . . . . . . . . . .
92
6.4
Type reconstruction algorithm
. . . . . . . . . . . . . . . . .
95
6.5
Eta-reductions
. . . . . . . . . . . . . . . . . . . . . . . . . .
97
6.6
Type inhabitation
. . . . . . . . . . . . . . . . . . . . . . . .
99
6.7
Equality of typed terms . . . . . . . . . . . . . . . . . . . . . 101
6.8
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7
Sequent calculus
105
7.1
Classical sequent calculus
. . . . . . . . . . . . . . . . . . . . 106
7.2
Intuitionistic sequent calculus . . . . . . . . . . . . . . . . . . 109
7.3
Cut elimination . . . . . . . . . . . . . . . . . . . . . . . . . . 113
7.4
Term assignment for sequent calculus . . . . . . . . . . . . . . 115
7.5
The general case
. . . . . . . . . . . . . . . . . . . . . . . . . 118
7.6
Alternative term assignment . . . . . . . . . . . . . . . . . . . 121
7.7
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
8
Classical logic and control operators
127
8.1
Classical propositional logic, implicational fragment
. . . . . 127
8.2
The full system . . . . . . . . . . . . . . . . . . . . . . . . . . 131
8.3
Terms for classical proofs
. . . . . . . . . . . . . . . . . . . . 132
8.4
Classical proof normalization
. . . . . . . . . . . . . . . . . . 133
8.5
Deﬁnability of pairs and sums . . . . . . . . . . . . . . . . . . 135
8.6
Embedding into intuitionistic propositional logic
. . . . . . . 136
8.7
Control operators and CPS translations . . . . . . . . . . . . 138
8.8
Historical remarks
. . . . . . . . . . . . . . . . . . . . . . . . 140

Contents
ix
8.9
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
9
First-order logic
143
9.1
Syntax of ﬁrst-order logic
. . . . . . . . . . . . . . . . . . . . 143
9.2
Intuitive semantics . . . . . . . . . . . . . . . . . . . . . . . . 145
9.3
Proof systems . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
9.4
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
9.5
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
10 Dependent types
155
10.1 System λP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
10.2 Rules of λP . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
10.3 Properties of λP
. . . . . . . . . . . . . . . . . . . . . . . . . 159
10.4 Dependent types `a la Curry . . . . . . . . . . . . . . . . . . . 161
10.5 Existential quantiﬁcation
. . . . . . . . . . . . . . . . . . . . 162
10.6 Correspondence with ﬁrst-order logic . . . . . . . . . . . . . . 163
10.7 Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
11 First-order arithmetic and G¨odel’s T
169
11.1 The language of arithmetic
. . . . . . . . . . . . . . . . . . . 169
11.2 Peano Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . 170
11.3 Representable and provably recursive functions . . . . . . . . 172
11.4 Heyting Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . 174
11.5 Kleene’s realizability interpretation . . . . . . . . . . . . . . . 176
11.6 G¨odel’s System T . . . . . . . . . . . . . . . . . . . . . . . . . 179
11.7 G¨odel’s Dialectica interpretation
. . . . . . . . . . . . . . . . 183
11.8 Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
12 Second-order logic and polymorphism
191
12.1 Propositional second-order formulas
. . . . . . . . . . . . . . 191
12.2 Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
12.3 Polymorphic lambda-calculus (System F)
. . . . . . . . . . . 196
12.4 Expressive power . . . . . . . . . . . . . . . . . . . . . . . . . 199
12.5 Curry-style polymorphism . . . . . . . . . . . . . . . . . . . . 203
12.6 Strong normalization of second-order typed λ-calculus . . . . 205
12.7 Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
13 The λ-cube and pure type systems
209
13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.2 Barendregt’s λ-cube
. . . . . . . . . . . . . . . . . . . . . . . 211
13.3 Example derivations . . . . . . . . . . . . . . . . . . . . . . . 214
13.4 Classiﬁcation and equivalence with previous formulations
. . 217
13.5 Pure type systems
. . . . . . . . . . . . . . . . . . . . . . . . 219
13.6 Examples of pure type systems . . . . . . . . . . . . . . . . . 221

x
Contents
13.7 Properties of pure type systems . . . . . . . . . . . . . . . . . 222
13.8 The Barendregt-Geuvers-Klop conjecture
. . . . . . . . . . . 225
14 Solutions and hints to selected exercises
227
Index
261

CHAPTER 1
Type-free λ-calculus
The λ-calculus is a collection of formal theories of interest in, e.g., computer
science and logic. The λ-calculus and the related systems of combinatory
logic were originally proposed as a foundation of mathematics around 1930
by Church and Curry, but the proposed systems were subsequently shown
to be inconsistent by Church’s students Kleene and Rosser in 1935.
However, a certain subsystem consisting of the λ-terms equipped with
so-called β-reduction turned out to be useful for formalizing the intuitive
notion of eﬀective computability and led to Church’s thesis stating that
λ-deﬁnability is an appropriate formalization of the intuitive notion of eﬀec-
tive computability. The study of this subsystem—which was proved to be
consistent by Church and Rosser in 1936—was a main inspiration for the
development of recursion theory.
With the invention of physical computers came also programming lan-
guages, and λ-calculus has proved to be a useful tool in the design, imple-
mentation, and theory of programming languages. For instance, λ-calculus
may be considered an idealized sublanguage of some programming languages
like LISP. Also, λ-calculus is useful for expressing semantics of program-
ming languages as done in denotational semantics. According to Hindley
and Seldin [55, p.43], “λ-calculus and combinatory logic are regarded as
‘test-beds’ in the study of higher-order programming languages: techniques
are tried out on these two simple languages, developed, and then applied to
other more ‘practical’ languages.”
The λ-calculus is sometimes called type-free or untyped to distinguish it
from variants in which types play a role; these variants will be introduced
in the next chapter.
1.1. λ-terms
The objects of study in λ-calculus are λ-terms. In order to introduce these,
it is convenient to introduce the notion of a pre-term.
1

2
Chapter 1. Type-free λ-calculus
1.1.1. Definition. Let
V = {v0, v1, . . . }
denote an inﬁnite alphabet. The set Λ−of pre-terms is the set of strings
deﬁned by the grammar:
Λ−::= V | (Λ−Λ−) | (λV Λ−)
1.1.2. Example. The following are pre-terms.
(i) ((v0 v1) v2) ∈Λ−;
(ii) (λv0 (v0 v1)) ∈Λ−;
(iii) ((λv0 v0) v1) ∈Λ−;
(iv) ((λv0 (v0 v0)) (λv1 (v1 v1))) ∈Λ−.
1.1.3. Notation. We use uppercase letters, e.g., K, L, M, N, P, Q, R with or
without subscripts to denote arbitrary elements of Λ−and lowercase letters,
e.g., x, y, z with or without subscripts to denote arbitrary elements of V .
1.1.4. Terminology.
(i) A pre-term of form x (i.e., an element of V ) is called a variable;
(ii) A pre-term of form (λx M) is called an abstraction (over x);
(iii) A pre-term of form (M N) is called an application (of M to N).
The heavy use of parentheses is rather cumbersome. We therefore intro-
duce the following, standard conventions for omitting parentheses without
introducing ambiguity.
We shall make use of these conventions under a
no-compulsion/no-prohibition agreement—see Remark 1.1.10.
1.1.5. Notation. We use the shorthands
(i) (K L M) for ((K L) M);
(ii) (λx λy M) for (λx (λy M));
(iii) (λx M N) for (λx (M N));
(iv) (M λx N) for (M (λx N)).
We also omit outermost parentheses.
1.1.6. Remark. The two ﬁrst shorthands concern nested applications and
abstractions, respectively. The two next ones concern applications nested
inside abstractions and vice versa, respectively.
To remember the shorthands, think of application as associating to the
left, and think of abstractions as extending as far to the right as possible.

1.1. λ-terms
3
When abstracting over a number of variables, each variable must be
accompanied by an abstraction. It is therefore convenient to introduce the
following shorthand.
1.1.7. Notation. We write λx1 . . . xn.M for λx1 . . . λxn M. As a special
case, we write λx.M for λx M.
1.1.8. Remark. Whereas abstractions are written with a λ, there is no cor-
responding symbol for applications; these are written simply by juxtaposi-
tion. Hence, there is no corresponding shorthand for applications.
1.1.9. Example. The pre-terms in Example 1.1.2 can be written as follows,
respectively:
(i) v0 v1 v2;
(ii) λv0.v0 v1;
(iii) (λv0.v0) v1;
(iv) (λv0.v0 v0) λv1.v1 v1.
1.1.10. Remark. The conventions mentioned above are used in the remain-
der of these notes. However, we refrain from using them—wholly or partly—
when we ﬁnd this more convenient. For instance, we might prefer to write
(λv0.v0 v0) (λv1.v1 v1) for the last term in the above example.
1.1.11. Definition. For M ∈Λ−deﬁne the set FV(M) ⊆V of free variables
of M as follows.
FV(x)
=
{x};
FV(λx.P)
=
FV(P)\{x};
FV(P Q)
=
FV(P) ∪FV(Q).
If FV(M) = {} then M is called closed.
1.1.12. Example. Let x, y, z denote distinct variables. Then
(i) FV(x y z) = {x, y, z};
(ii) FV(λx.x y) = {y};
(iii) FV((λx.x x) λy.y y) = {}.
1.1.13. Definition. For M, N ∈Λ−and x ∈V , the substitution of N for x
in M, written M[x := N] ∈Λ−, is deﬁned as follows, where x ̸= y:
x[x := N]
= N;
y[x := N]
= y;
(P Q)[x := N] = P[x := N] Q[x := N];
(λx.P)[x := N] = λx.P;
(λy.P)[x := N] = λy.P[x := N],
if y ̸∈FV(N) or x ̸∈FV(P);
(λy.P)[x := N] = λz.P[y := z][x := N],
if y ∈FV(N) and x ∈FV(P).

4
Chapter 1. Type-free λ-calculus
where z is chosen as the vi ∈V with minimal i such that vi ̸∈FV(P)∪FV(N)
in the last clause.
1.1.14. Example. If x, y, z are distinct variables, then for a certain vari-
able u:
((λx.x yz) (λy.x y z) (λz.x y z))[x := y] = (λx.x yz) (λu.y u z) (λz.y y z)
1.1.15. Definition. Let α-equivalence, written =α, be the smallest relation
on Λ−, such that
P =α P
for all P;
λx.P =α λy.P[x := y]
if y ̸∈FV(P),
and closed under the rules:
P =α P ′
⇒
∀x ∈V :
λx.P =α λx.P ′;
P =α P ′
⇒
∀Z ∈Λ−:
P Z =α P ′ Z;
P =α P ′
⇒
∀Z ∈Λ−:
Z P =α Z P ′;
P =α P ′
⇒
P ′ =α P;
P =α P ′ & P ′ =α P ′′
⇒
P =α P ′′.
1.1.16. Example. Let x, y, z denote diﬀerent variables. Then
(i) λx.x =α λy.y;
(ii) λx.x z =α λy.y z;
(iii) λx.λy.x y =α λy.λx.y x;
(iv) λx.x y ̸=α λx.x z.
1.1.17. Definition. Deﬁne for any M ∈Λ−, the equivalence class [M]α by:
[M]α = {N ∈Λ−| M =α N}
Then deﬁne the set Λ of λ-terms by:
Λ
=
Λ−/=α =
{[M]α | M ∈Λ−}
1.1.18. Warning. The notion of a pre-term and the associated explicit dis-
tinction between pre-terms and λ-terms introduced above are not standard
in the literature. Rather, it is customary to call our pre-terms λ-terms, and
then informally remark that α-equivalent λ-terms are “identiﬁed.”
In the remainder of these notes we shall be almost exclusively concerned
with λ-terms, not pre-terms. Therefore, it is convenient to introduce the
following.

1.1. λ-terms
5
1.1.19. Notation. We write M instead of [M]α in the remainder.
This
leads to ambiguity: is M a pre-term or a λ-term? In the remainder of these
notes, M should always be construed as [M]α ∈Λ, except when explicitly
stated otherwise.
We end this section with two deﬁnitions introducing the notions of free
variables and substitution on λ-terms (recall that, so far, these notions have
been introduced only for pre-terms). These two deﬁnitions provide the ﬁrst
example of how to rigorously understand deﬁnitions involving λ-terms.
1.1.20. Definition. For M ∈Λ deﬁne the set FV(M) ⊆V of free variables
of M as follows.
FV(x)
=
{x};
FV(λx.P)
=
FV(P)\{x};
FV(P Q)
=
FV(P) ∪FV(Q).
If FV(M) = {} then M is called closed.
1.1.21. Remark. According to Notation 1.1.19, what we really mean by this
is that we deﬁne FV as the map from Λ to subsets of V satisfying the rules:
FV([x]α)
=
{x};
FV([λx.P]α)
=
FV([P]α)\{x};
FV([P Q]α)
=
FV([P]α) ∪FV([Q]α).
Strictly speaking we then have to demonstrate there there is at most one such
function (uniqueness) and that there is at least one such function (existence).
Uniqueness can be established by showing for any two functions FV1 and
FV2 satisfying the above equations, and any λ-term, that the results of FV1
and FV2 on the λ-term are the same. The proof proceeds by induction on
the number of symbols in any member of the equivalence class.
To demonstrate existence, consider the map that, given an equivalence
class, picks a member, and takes the free variables of that. Since any choice
of member yields the same set of variables, this latter map is well-deﬁned,
and can easily be seen to satisfy the above rules.
In the rest of these notes such considerations will be left implicit.
1.1.22. Definition. For M, N ∈Λ and x ∈V , the substitution of N for x
in M, written M{x := N}, is deﬁned as follows:
x[x := N]
=
N;
y[x := N]
=
y,
if x̸=y;
(P Q)[x := N]
=
P[x := N] Q[x := N];
(λy.P)[x := N]
=
λy.P[x := N],
if x̸=y, where y ̸∈FV(N).
1.1.23. Example.
(i) (λx.x y)[x := λz.z] = λx.x y;
(ii) (λx.x y)[y := λz.z] = λx.x λz.z.

6
Chapter 1. Type-free λ-calculus
1.2. Reduction
Next we introduce reduction on λ-terms.
1.2.1. Definition. Let →β be the smallest relation on Λ such that
(λx.P) Q →β P[x := Q],
and closed under the rules:
P →β P ′
⇒
∀x ∈V :
λx.P →β λx.P ′
P →β P ′
⇒
∀Z ∈Λ :
P Z →β P ′ Z
P →β P ′
⇒
∀Z ∈Λ :
Z P →β Z P ′
A term of form (λx.P) Q is called a β-redex, and P[x := Q] is called its
β-contractum. A term M is a β-normal form if there is no term N with
M →β N.
There are other notions of reduction than β-reduction, but these will not
be considered in the present chapter. Therefore, we sometimes omit “β-”
from the notions β-redex, β-reduction, etc.
1.2.2. Definition.
(i) The relation →
→β (multi-step β-reduction) is the transitive-reﬂexive clo-
sure of →β; that is, →
→β is the smallest relation closed under the rules:
P →β P ′
⇒
P →
→β P ′;
P →
→β P ′ & P ′ →
→β P ′′
⇒
P →
→β P ′′;
P →
→β P.
(ii) The relation =β (β-equality) is the transitive-reﬂexive-symmetric clo-
sure of →β; that is, =β is the smallest relation closed under the rules:
P →β P ′
⇒
P =β P ′;
P =β P ′ & P ′ =β P ′′
⇒
P =β P ′′;
P =β P;
P =β P ′
⇒
P ′ =β P.
1.2.3. Warning. In these notes, the symbol = without any qualiﬁcation is
used to express the fact that two objects, e.g., pre-terms or λ-terms are
identical. This symbol is very often used in the literature for β-equality.
1.2.4. Example.
(i) (λx.x x) λz.z →β (x x)[x := λz.z] = (λz.z) λy.y;
(ii) (λz.z) λy.y →β z[z := λy.y] = λy.y;
(iii) (λx.x x) λz.z →
→β λy.y;
(iv) (λx.x) y z =β y ((λx.x) z).

1.3. Informal interpretation
7
1.3. Informal interpretation
Informally, λ-terms express functions and applications of functions in a pure
form. For instance, the λ-term
I = λx.x
intuitively denotes the function that maps any argument to itself, i.e., the
identity function. This is similar to the notation n 7→n employed in math-
ematics. However, λx.x is a string over an alphabet with symbols λ, x, etc.
(or rather an equivalence class of such objects), whereas n 7→n is a function,
i.e., a certain set of pairs. The diﬀerence is the same as that between a pro-
gram written in some language and the mathematical function it computes,
e.g., addition.
As in the notation n 7→n, the name of the abstracted variable x in λx.x
is not signiﬁcant, and this is why we identify λx.x with, e.g., λy.y.
Another λ-term is
K∗= λy.λx.x
which, intuitively, denotes the function that maps any argument to a func-
tion, namely the one that maps any argument to itself, i.e., the identity
function. This is similar to programming languages where a function may
return a function as a result. A related λ-term is
K = λy.λx.y
which, intuitively, denotes the function that maps any argument to the
function that, for any argument, returns the former argument.
Since λ-terms intuitively denote functions, there is a way to invoke one
λ-term on another; this is expressed by application. Thus, the λ-term
I K
expresses application of I to K. Since K intuitively denotes a function too,
I denotes a function which may have another function as argument. This is
similar to programming languages where a procedure may receive another
procedure as argument.
In mathematics we usually write application of a function, say f(n) = n2,
to an argument, say 4, with the argument in parentheses: f(4).
In the
λ-calculus we would rather write this as (f 4), or just f 4, keeping Nota-
tion 1.1.5 in mind. Not all parentheses can be omitted, though; for instance,
(λx.x) I
λx.x I
are not the same λ-term; the ﬁrst is I applied to I, whereas the second
expects an argument x which is applied to I.

8
Chapter 1. Type-free λ-calculus
Intuitively, if λx.M denotes a function, and N denotes an argument,
then the the value of the function on the argument is denoted by the λ-term
that arises by substituting N for x in M. This latter λ-term is exactly the
term
M[x := N]
This is similar to common practice in mathematics; if f is as above, then
f(4) = 42, and we get from the application f(4) to the value 42 by substi-
tuting 4 for n in the body of the deﬁnition of f.
The process of calculating values is formalized by β-reduction. Indeed,
M →β N if N arises from M by replacing a β-redex, i.e., a part of form
(λx.P) Q
by its β-contractum.
P[x := Q]
For instance,
I K = (λx.x) K →β x[x := K] = K
Then the relation →
→β formalizes the process of computing the overall result.
Also, =β identiﬁes λ-terms that, intuitively, denote the same function.
Note that λ-calculus is a type-free formalism. Unlike common mathe-
matical practice, we do not insist that λ-terms denote functions from cer-
tain domains, e.g., the natural numbers, and that arguments be drawn from
these domains. In particular, we may have self-application as in the λ-term
ω = λx.x x
and we may apply this λ-term to itself as in the λ-term
Ω= ω ω
The type-free nature of λ-calculus leads to some interesting phenomena;
for instance, a λ-term may reduce to itself as in
Ω= (λx.x x) ω →β ω ω = Ω
Therefore, there are also λ-terms with inﬁnite reduction sequences, like
Ω→β Ω→β . . .
1.4. The Church-Rosser Theorem
Since a λ-term M may contain several β-redexes, i.e., several parts of form
(λx.P) Q, there may be several N such that M →β N. For instance,
K (I I) →β λx.(I I)

1.4. The Church-Rosser Theorem
9
and also
K (I I) →β K I
However, the Church-Rosser theorem, proved below, states that if
M →
→β M1
and
M →
→β M2
then a single λ-term M3 can be found with
M1 →
→β M3
and
M2 →
→β M3
In particular, if M1 and M2 are β-normal forms, i.e., λ-terms that admit
no further β-reductions, then they must be the same λ-term, since the β-
reductions from M1 and M2 to M3 must be in zero steps. This is similar to
the fact that when we calculate the value of an arithmetical expression, e.g.,
(4 + 2) · (3 + 7) · 11
the end result is independent of the order in which we do the calculations.
1.4.1. Definition. A relation > on Λ satisﬁes the diamond property if, for
all M1, M2, M3 ∈Λ, if M1 > M2 and M1 > M3, then there exists an M4 ∈Λ
such that M2 > M4 and M3 > M4.
1.4.2. Lemma. Let > be a relation on Λ and suppose that its transitive clo-
sure1 is →
→β. If > satisﬁes the diamond property, then so does →
→β.
Proof. First show by induction on n that M1 > N1 and M1 > . . . > Mn
implies that there are N2, . . . , Nn such that N1 > N2 > . . . > Nn and
Mn > Nn.
Using this property, show by induction on m that if N1 > . . . > Nm and
N1 >∗M1 then there are M2, . . . , Mm such that M1 > M2 > . . . > Mm and
Nm >∗Mm.
1Let R be a relation on Λ. The transitive closure of R is the least relation R∗satisfying:
PRP ′
⇒
PR∗P ′
PR∗P ′ & P ′R∗P ′′
⇒
PR∗P ′′
The reﬂexive closure of R is the least relation R= satisfying:
PRP ′
⇒
PR=P ′
PR=P

10
Chapter 1. Type-free λ-calculus
Now assume M1 →
→β M2 and M1 →
→β M3. Since →
→β is the transitive
closure of > we have M1 > . . . > M2 and M1 > . . . > M3. By what was
shown above, we can ﬁnd M4 such that M2 > . . . > M4 and M3 > . . . > M4.
Since →
→β is the transitive closure of >, also M2 →
→β M4 and M3 →
→β M4.
⊓⊔
1.4.3. Definition. Let →
→l be the relation on Λ deﬁned by:
P →
→l P
P →
→l P ′
⇒
λx.P →
→l λx.P ′
P →
→l P ′ & Q →
→l Q′
⇒
P Q →
→l P ′ Q′
P →
→l P ′ & Q →
→l Q′
⇒
(λx.P) Q →
→l P ′[x := Q′]
1.4.4. Lemma. M →
→l M′ & N →
→l N′ ⇒M[x := N] →
→l M′[x := N ′].
Proof. By induction on the deﬁnition of M →
→l M′. In case M′ is M,
proceed by induction on M.
⊓⊔
1.4.5. Lemma. →
→l satisﬁes the diamond property, i.e., for all M1, M2, M3 ∈Λ,
if M1 →
→l M2 and M1 →
→l M3, then there exists an M4 ∈Λ such that
M2 →
→l M4 and M3 →
→l M4.
Proof. By induction on the deﬁnition of M1 →
→l M2, using the above
lemma.
⊓⊔
1.4.6. Lemma. →
→β is the transitive closure of →
→l.
Proof. Clearly2
(→β)= ⊆→
→l ⊆→
→β
Then
→
→β = ((→β)=)∗⊆→
→∗
l ⊆(→
→β)∗= →
→β
In particular, →
→∗
l = →
→β.
⊓⊔
1.4.7. Theorem (Church and Rosser, 1936). For every M1, M2, M3 ∈Λ, if
M1 →
→β M2 and M1 →
→β M3, then there exists an M4 ∈Λ such that M2 →
→β
M4 and M3 →
→β M4.
Proof (Tait & Martin-L¨of). By the above three lemmas.
⊓⊔
1.4.8. Corollary. For all M, N ∈Λ, if M =β N, then there exists an
L ∈Λ such that M →
→β L and N →
→β L.
1.4.9. Corollary. For all M, N1, N2 ∈Λ, if M →
→β N1 and M →
→β N2 and
both N1 and N2 are in β-normal form, then N1 = N2.
2Recall the relations R∗and R= deﬁned earlier.

1.5. Expressibility and undecidability
11
1.4.10. Corollary. For all M, N ∈Λ, if there are β-normal forms L1 and
L2 such that M →
→β L1, N →
→β L2, and L1 ̸= L2, then M ̸=β N.
1.4.11. Example. λx.x ̸=β λx.λy.x.
1.4.12. Remark. One can consider the lambda calculus as an equational
theory, i.e., a formal theory with formulas of the form M =β N.
The
preceding example establishes consistency of this theory, in the following
sense: there exists a formula P which cannot be proved.
This may seem to be a very weak property, compared to “one cannot
prove a contradiction” (where a suitable notion of “contradiction” in ordi-
nary logic is e.g., P ∧¬P). But note that in most formal theories, where a
notion of contradiction can be expressed, its provability implies provability
of all formulas. Thus, consistency can be equally well deﬁned as “one cannot
prove everything”.
1.5. Expressibility and undecidability
Although we have given an informal explanation of the meaning of λ-terms
it remains to explain in what sense β-reduction more precisely can express
computation. In this section we show that λ-calculus can be seen as an
alternative formulation of recursion theory.
The following gives a way of representing numbers as λ-terms.
1.5.1. Definition.
(i) For any n ∈N and F, A ∈Λ deﬁne F n(A) (n-times iterated application
of F to A) by:
F 0(A)
=
A
F n+1(A)
=
F(F n(A))
(ii) For any n ∈N, the Church numeral cn is the λ-term
cn = λs.λz.sn(z)
1.5.2. Example.
(i) c0 = λs.λz.z;
(ii) c1 = λs.λz.s z;
(iii) c2 = λs.λz.s (s z);
(iv) c3 = λs.λz.s (s (s z)).
1.5.3. Remark. cn is the number n represented inside the λ-calculus.
The following shows how to do arithmetic on Church numerals.

12
Chapter 1. Type-free λ-calculus
1.5.4. Proposition (Rosser). Let
A+
=
λx.λy.λs.λz.x s (y s z);
A∗
=
λx.λy.λs.x (y s);
Ae
=
λx.λy.y x.
Then
A+ cn cm
=
cn+m;
A∗cn cm
=
cn·m;
Ae cn cm
=
cnm if m > 0.
Proof. For any n ∈N,
cn s z
=
(λf.λx.fn(x)) s z
=β
(λx.sn(x)) z
=β
sn(z)
Thus
A+ cn cm
=
(λx.λy.λs.λz.x s (y s z)) cn cm
=β
λs.λz.cn s (cm s z)
=β
λs.λz.cn s (sm(z))
=β
λs.λz.sn(sm(z))
=
λs.λz.sn+m(z)
=
cn+m
The similar properties for multiplication and exponentiation are left as ex-
ercises.
⊓⊔
1.5.5. Remark. Recall that M =β N when, intuitively, M and N denote
the same object. For instance I I =β I since both terms, intuitively, denote
the identity function.
Now consider the two terms
As
=
λx.λs.λz.s (x s z)
A′
s
=
λx.λs.λz.x s (s z)
It is easy to calculate that
As cn
=β
cn+1
A′
s cn
=β
cn+1
So both terms denote, informally, the successor function on Church numer-
als, but the two terms are not β-equal (why not?)
The following shows how to deﬁne booleans and conditionals inside λ-
calculus.

1.5. Expressibility and undecidability
13
1.5.6. Proposition. Deﬁne
true
=
λx.λy.x;
false
=
λx.λy.y;
if B then P else Q = B P Q.
Then
if true then P else Q
=β
P;
if false then P else Q
=β
Q.
Proof. We have:
if true then P else Q
=
(λx.λy.x) P Q
=β
(λy.P) Q
=β
P.
The proof that if false then P else Q =β Q is similar.
⊓⊔
We can also deﬁne pairs in λ-calculus.
1.5.7. Proposition. Deﬁne
[P, Q]
=
λx.x P Q;
π1
=
λx.λy.x;
π2
=
λx.λy.y.
Then
[P, Q] π1
=β
P;
[P, Q] π2
=β
Q.
Proof. We have:
[P, Q] π1
=
(λx.x P Q) λx.λy.x
=β
(λx.λy.x) P Q
=β
(λy.P) Q
=β
P.
The proof that [P, Q] π2 =β Q is similar.
⊓⊔
1.5.8. Remark. Note that we do not have [M π1, M π2] =β M for all
M ∈Λ; that is, our pairing operator is not surjective.
1.5.9. Remark. The construction is easily generalized to tuples [M1, . . . , Mn]
with projections πi where i ∈{1, . . . , n}.
The following gives one way of expressing recursion in λ-calculus.

14
Chapter 1. Type-free λ-calculus
1.5.10. Theorem (Fixed point theorem). For all F there is an X such that
F X =β X
In fact, there is a λ-term Y such that, for all F:
F (Y F) =β Y F
Proof. Put
Y = λf.(λx.f (x x)) λx.f (x x)
Then
Y F
=
(λf.(λx.f (x x)) λx.f (x x)) F
=β
(λx.F (x x)) λx.F (x x)
=β
F ((λx.F (x x)) λx.F (x x))
=β
F ((λf.(λx.f (x x)) λx.f (x x)) F)
=
F (Y F)
as required.
⊓⊔
1.5.11. Corollary. Given M ∈Λ there is F ∈Λ such that:
F =β M[f := F]
Proof. Put
F = Y λf.M
Then
F
=
Y λf.M
=β
(λf.M) (Y λf.M)
=
(λf.M) F
=β
M[f := F]
as required.
⊓⊔
Corollary 1.5.11 allows us to write recursive deﬁnitions of λ-terms; that
is, we may deﬁne F as a λ-term satisfying a ﬁxed point equation F =β λx.M
where the term F occurs somewhere inside M.
However, there may be
several terms F satisfying this equation (will these be β-equal?).
1.5.12. Example. Let C be some λ-term which expresses a condition, i.e.,
let C cn =β true or C cn =β false, for all n ∈N. Let S deﬁne the successor
function (see Remark 1.5.5). Suppose we want to compute in λ-calculus, for
any number, the smallest number greater than the given one that satisﬁes
the condition. This is expressed by the λ-term F:
H
=
λf.λx.if (C x) then x else f (S x)
F
=
Y H

1.5. Expressibility and undecidability
15
Indeed, for example
F c4
=
(Y H) c4
=β
H (Y H) c4
=
(λf.λx.if (C x) then x else f (S x)) (Y H) c4
=β
if (C c4) then c4 else (Y H) (S c4)
=
if (C c4) then c4 else F (S c4)
So far we have been informal as to how λ-terms “express” certain func-
tions. This notion is made precise as follows.
1.5.13. Definition.
(i) A numeric function is a map
f : Nm →N.
(ii) A numeric function f : Nm →N is λ-deﬁnable if there is an F ∈Λ such
that
F cn1 . . . cnm =β cf(n1,... ,nm)
for all n1, . . . , nm ∈N.
1.5.14. Remark. By the Church-Rosser property, (ii) implies that, in fact,
F cn1 . . . cnm →
→β cf(n1,... ,nm)
There are similar notions for partial functions—see [7].
We shall show that all recursive functions are λ-deﬁnable.
1.5.15. Definition. The class of recursive functions is the smallest class of
numeric functions containing the initial functions
(i) projections: Um
i (n1, . . . , nm) = ni for all 1 ≤i ≤m;
(ii) successor: S+(n) = n + 1;
(iii) zero: Z(n) = 0.
and closed under composition, primitive recursion, and minimization:
(i) composition: if g : Nk →N and h1, . . . , hk : Nm →N are recursive,
then so is f : Nm →N deﬁned by
f(n1, . . . , nm) = g(h1(n1, . . . , nm), . . . , hk(n1, . . . , nm)).
(ii) primitive recursion: if g : Nm →N and h : Nm+2 →N are recursive,
then so is f : Nm+1 →N deﬁned by
f(0, n1, . . . , nm)
=
g(n1, . . . , nm);
f(n + 1, n1, . . . , nm)
=
h(f(n, n1, . . . , nm), n, n1, . . . , nm).

16
Chapter 1. Type-free λ-calculus
(iii) minimization: if g : Nm+1 →N is recursive and for all n1, . . . , nm there
is an n such that g(n, n1, . . . , nm) = 0, then f : Nm →N deﬁned as
follows is also recursive3
f(n1, . . . , nm) = µn.g(n, n1, . . . , nm) = 0
1.5.16. Lemma. The initial functions are λ-deﬁnable.
Proof. With
Um
i
=
λx1. . . . λxm.xi
S+
=
λx.λs.λz.s (x s z)
Z
=
λx.c0
the necessary properties hold.
⊓⊔
1.5.17. Lemma. The λ-deﬁnable functions are closed under composition.
Proof. If g : Nk →N is λ-deﬁnable by G ∈Λ and h1, . . . , hk : Nm →N
are λ-deﬁnable by some H1, . . . , Hk ∈Λ, then f : Nm →N deﬁned by
f(n1, . . . , nm) = g(h1(n1, . . . , nm), . . . , hk(n1, . . . , nm))
is λ-deﬁnable by
F = λx1. . . . λxm.G (H1 x1 . . . xm) . . . (Hk x1 . . . xm),
as is easy to verify.
⊓⊔
1.5.18. Lemma. The λ-deﬁnable functions are closed under primitive recur-
sion.
Proof. If g : Nm →N is λ-deﬁnable by some G ∈Λ and h : Nm+2 →N is
λ-deﬁnable by some H ∈Λ, then f : Nm+1 →N deﬁned by
f(0, n1, . . . , nm)
=
g(n1, . . . , nm);
f(n + 1, n1, . . . , nm)
=
h(f(n, n1, . . . , nm), n, n1, . . . , nm),
is λ-deﬁnable by F ∈Λ where
F
=
λx.λx1. . . . λxm.x T [c0, G x1 . . . xn] π2;
T
=
λp.[S+ (p π1), H (p π2) (p π1) x1 . . . xm].
Indeed, we have
F cn cn1 . . . cnm
=β
cn T [c0, G cn1 . . . cnm] π2
=β
T n([c0, G cn1 . . . cnm]) π2
3µn.g(n, n1, . . . , nm) = 0 denotes the smallest number n satisfying the equation
g(n, n1, . . . , nm) = 0.

1.5. Expressibility and undecidability
17
Also,
T [cn, cf(n,n1,... ,nm)]
=β
[S+(cn), H cf(n,n1,... ,nm) cn cn1 . . . cnm]
=β
[cn+1, ch(f(n,n1,... ,nm),n,n1,... ,nm)]
=β
[cn+1, cf(n+1,n1,... ,nm)]
So
T n([c0, G cn1 . . . cnm])
=β
[cn, cf(n,n1,... ,nm)]
From this the required property follows.
⊓⊔
1.5.19. Lemma. The λ-deﬁnable functions are closed under minimization.
Proof. If g : Nm+1 →N is λ-deﬁnable by G ∈Λ and for all n1, . . . , nm
there is an n, such that g(n, n1, . . . , nm) = 0, then f : Nm →N deﬁned by
f(n1, . . . , nm) = µm.g(n, n1, . . . , nm) = 0
is λ-deﬁnable by F ∈Λ, where
F = λx1. . . . λxm.H c0
and where H ∈Λ is such that
H =β λy.if (zero? (G x1 . . . xm y)) then y else H (S+ y).
Here,
zero? = λx.x (λy.false) true
We leave it as an exercise to verify that the required properties hold.
⊓⊔
The following can be seen as a form of completeness of the λ-calculus.
1.5.20. Theorem (Kleene). All recursive functions are λ-deﬁnable.
Proof. By the above lemmas.
⊓⊔
The converse also holds, as one can show by a routine argument. Similar
results hold for partial functions as well—see [7].
1.5.21. Definition. Let ⟨•, •⟩: N2 →N be a bijective, recursive function.
The map # : Λ−→N is deﬁned by:
#(vi)
=
⟨0, i⟩
#(λx.M)
=
⟨2, ⟨#(x), #(M)⟩⟩
#(M N)
=
⟨3, ⟨#(M), #(N)⟩⟩
For M ∈Λ, we take #(M) to be the least possible number #(M′) where M′
is an alpha-representative of M. Also, for M ∈Λ, we deﬁne ⌈M⌉= c#(M).

18
Chapter 1. Type-free λ-calculus
1.5.22. Definition. Let A ⊆Λ.
(i) A is closed under =β if
M ∈A & M =β N ⇒N ∈A
(ii) A is non-trival if
A ̸= ∅& A ̸= Λ
(iii) A is recursive if
#A = {#(M) | M ∈A}
is recursive.
1.5.23. Theorem (Curry, Scott). Let A be non-trivial and closed under =β.
Then A is not recursive.
Proof (J. Terlouw). Suppose A is recursive. Deﬁne
B = {M | M ⌈M⌉∈A}
There exists an F ∈Λ with
M ∈B
⇔
F ⌈M⌉=β c0;
M ̸∈B
⇔
F ⌈M⌉=β c1.
Let M0 ∈A, M1 ∈Λ\A, and let
G = λx.if (zero? (F x)) then M1 else M0
Then
M ∈B
⇔
G ⌈M⌉=β M1
M ̸∈B
⇔
G ⌈M⌉=β M0
so
G ∈B
⇔
G ⌈G⌉=β M1
⇒
G ⌈G⌉̸∈A
⇒
G ̸∈B
G ̸∈B
⇔
G ⌈G⌉=β M0
⇒
G ⌈G⌉∈A
⇒
G ∈B
a contradiction.
⊓⊔
1.5.24. Remark. The above theorem is analogous to Rice’s theorem known
in recursion theory.
The following is a variant of the halting problem. Informally it states that
the formal theory of β-equality mentioned in Remark 1.4.12 is undecidable.
1.5.25. Corollary (Church). {M ∈Λ | M =β true} is not recursive.
1.5.26. Corollary. The following set is not recursive:
{M ∈Λ | ∃N ∈Λ : M →
→β N & N is a β-normal form }.
One can also infer from these results the well-known theorem due to
Church stating that ﬁrst-order predicate calculus is undecidable.

1.6. Historical remarks
19
1.6. Historical remarks
For more on the history of λ-calculus, see e.g., [55] or [7]. First hand in-
formation may be obtained from Rosser and Kleene’s eye witness state-
ments [94, 62], and from Curry and Feys’ book [24] which contains a wealth
of historical information. Curry and Church’s original aims have recently
become the subject of renewed attention—see, e.g., [9, 10] and [50].
1.7. Exercises
1.7.1. Exercise. Show, step by step, how application of the conventions in
Notation 1.1.5 allows us to express the pre-terms in Example 1.1.2 as done
in Example 1.1.9.
1.7.2. Exercise. Which of the following abbreviations are correct?
1. λx.x y = (λx.x) y;
2. λx.x y = λx.(x y);
3. λx.λy.λz.x y z = (λx.λy.λz.x) (y z);
4. λx.λy.λz.x y z = ((λx.λy.λz.x) y) z;
5. λx.λy.λz.x y z = λx.λy.λz.((x y) z).
1.7.3. Exercise. Which of the following identiﬁcations are correct?
1. λx.λy.x = λy.λx.y;
2. (λx.x) z = (λz.z) x.
1.7.4. Exercise. Do the following terms have normal forms?
1. I, where λx.x;
2. Ω, i.e., ω ω, where ω = λx.x x;
3. K I Ωwhere K = λx.λy.x;
4. (λx.K I (x x)) λy.K I (y y);
5. (λx.z (x x)) λy.z (y y).
1.7.5. Exercise. A reduction path from a λ-term M is a ﬁnite or inﬁnite
sequence
M →β M1 →β M2 →β . . .

20
Chapter 1. Type-free λ-calculus
A term that has a normal form is also called weakly normalizing (or just
normalizing), since at least one of its reduction paths terminate in a nor-
mal form. A term is strongly normalizing if all its reduction paths even-
tually terminate in normal forms, i.e., if the term has no inﬁnite reduction
paths. Which of the ﬁve terms in the preceding exercise are weakly/strongly
normalizing? In which cases do diﬀerent reduction paths lead to diﬀerent
normal forms?
1.7.6. Exercise. Which of the following are true?
1. (λx.λy.λz.(x z) (y z)) λu.u =β (λv.v λy.λz.λu.u) λx.x;
2. (λx.λy.x λz.z) λa.a =β (λy.y) λb.λz.z;
3. λx.Ω=β Ω.
1.7.7. Exercise. Prove (without using the Church-Rosser Theorem) that
for all M1, M2, M3 ∈Λ, if M1 →β M2 and M1 →β M3, then there exists an
M4 ∈Λ such that M2 →
→β M4 and M3 →
→β M4.
Can you extend your proof technique to yield a proof of the Church-
Rosser theorem?
1.7.8. Exercise. Fill in the details of the proof Lemma 1.4.4.
1.7.9. Exercise. Fill in the details of the proof Lemma 1.4.5.
1.7.10. Exercise. Which of the following are true?
1. (I I) (I I) →
→l I I;
2. (I I) (I I) →
→l I;
3. I I I I →
→l I I I;
4. I I I I →
→l I;
1.7.11. Exercise. Show that the fourth clause in Deﬁnition 1.4.3 cannot be
replaced by
(λx.P) Q →
→l P[x := Q].
That is, show that, if this is done, then →
→l does not satisfy the diamond
property.
1.7.12. Exercise. Prove Corollary 1.4.8–1.4.10.
1.7.13. Exercise. Write λ-terms (without using the notation sn(z)) whose
β-normal forms are the Church numerals c5 and c100.

1.7. Exercises
21
1.7.14. Exercise. Prove that A∗and Ae satisfy the equations stated in
Proposition 1.5.4.
1.7.15. Exercise. For each n ∈N, write a λ-term Bn such that
Bn ci Q1 . . . Qn =β Qi,
for all Q1, . . . Qn ∈Λ.
1.7.16. Exercise. For each n ∈N, write λ-terms Pn, π1, . . . , πn, such that
for all Q1, . . . , Qn ∈Λ:
(Pn Q1 . . . Qn) πi =β Qi.
1.7.17. Exercise (Klop, taken from [7]). Let λx1x2 . . . xn.M be an abbre-
viation for λx1.λx2. . . . λxn.M. Let
?
=
λabcdefghijklmnopqstuvwxyzr.r (thisisafixedpointcombinator);
$
=
??????????????????????????.
Show that $ is a ﬁxed point combinator, i.e., that $ F =β F ($ F), holds for
all F ∈Λ.
1.7.18. Exercise. Deﬁne a λ-term neg such that
neg true
=β
false;
neg false
=β
true.
1.7.19. Exercise. Deﬁne λ-terms O and E such that, for all n ∈N:
Ocm =β
½ true
if m is odd;
false
otherwise,
and
Ecm =β
½ true
if m is even;
false
otherwise.
1.7.20. Exercise. Deﬁne a λ-term P such that
P cn+1 =β cn
Hint: use the same trick as in the proof that the λ-deﬁnable functions are
closed under primitive recursion. (Kleene got this idea during a visit at his
dentist.)

22
Chapter 1. Type-free λ-calculus
1.7.21. Exercise. Deﬁne a λ-term eq? such that, for all n, m ∈N:
eq? cn cm =β
½ true
if m = n;
false
otherwise.
Hint: use the ﬁxed point theorem to construct a λ-term H such that
H cn cm
=β
if (zero? cn)
then (if (zero? cm) then true else false)
else (if (zero? cm) then false else (H (P cn) (P cm)))
where P is as in the preceding exercise.
Can you prove the result using instead the construction in Lemma 1.5.18?
1.7.22. Exercise. Deﬁne a λ-term H such that for all n ∈N:
H c2n =β cn
1.7.23. Exercise. Deﬁne a λ-term F such that for all n ∈N:
H cn2 =β cn
1.7.24. Exercise. Prove Corollary 1.5.25.

CHAPTER 2
Intuitionistic logic
The classical understanding of logic is based on the notion of truth. The
truth of a statement is “absolute” and independent of any reasoning, un-
derstanding, or action. Statements are either true or false with no regard
to any “observer”. Here “false” means the same as “not true”, and this is
expressed by the tertium non datur principle that “p ∨¬p” must hold no
matter what the meaning of p is.
Needless to say, the information contained in the claim p ∨¬p is quite
limited. Take the following sentence as an example:
There is seven 7’s in a row somewhere in the decimal represen-
tation of the number π.
Note that it may very well happen that nobody ever will be able to determine
the truth of the above sentence. Yet we are forced to accept that one of the
cases must necessarily hold. Another well-known example is as follows:
There are two irrational numbers x and y, such that xy is ratio-
nal.
The proof of this fact is very simple: if
√
2
√
2 is a rational number then we
can take x = y =
√
2; otherwise take x =
√
2
√
2 and y =
√
2.
The problem with this proof is that we do not know which of the two
possibilities is the right one. Again, there is very little information in this
proof, because it is not constructive.
These examples demonstrate some of the drawbacks of classical logic,
and give hints on why intuitionistic (or constructive) logic is of interest.
Although the roots of constructivism in mathematics reach deeply into the
XIXth Century, the principles of intuitionistic logic are usually attributed
to the works of the Dutch mathematician and philosopher Luitzen Egber-
tus Jan Brouwer from the beginning of XXth Century. Brouwer is also the
inventor of the term “intuitionism”, which was originally meant to denote a
23

24
Chapter 2. Intuitionistic logic
philosophical approach to the foundations of mathematics, being in opposi-
tion to Hilbert’s “formalism”.
Intuitionistic logic as a branch of formal logic was developed later around
the year 1930. The names to be quoted here are Heyting, Glivenko, Kol-
mogorov and Gentzen. To learn more about the history and motivations
see [26] and Chapter 1 of [107].
2.1. Intuitive semantics
In order to understand intuitionism, one should forget the classical, Platonic
notion of “truth”. Now our judgements about statements are no longer based
on any predeﬁned value of that statement, but on the existence of a proof
or “construction” of that statement.
The following rules explain the informal constructive semantics of propo-
sitional connectives. These rules are sometimes called the BHK-interpretation
for Brouwer, Heyting and Kolmogorov. The algorithmic ﬂavor of this deﬁ-
nition will later lead us to the Curry-Howard isomorphism.
• A construction of ϕ1 ∧ϕ2 consists of a construction of ϕ1 and a con-
struction of ϕ2;
• A construction of ϕ1 ∨ϕ2 consists of a number i ∈{1, 2} and a con-
struction of of ϕi;
• A construction of ϕ1 →ϕ2 is a method (function) transforming every
construction of ϕ1 into a construction of ϕ2;
• There is no possible construction of ⊥(where ⊥denotes falsity).
Negation ¬ϕ is best understood as an abbreviation of an implication ϕ →⊥.
That is, we assert ¬ϕ when the assumption of ϕ leads to an absurd. It follows
that
• A construction of ¬ϕ is a method that turns every construction of ϕ
into a non-existent object.
Note that the equivalence between ¬ϕ and ϕ →⊥holds also in classical
logic. But note also that the intuitionistic statement ¬ϕ is much stronger
than just “there is no construction for ϕ”.
2.1.1. Example. Consider the following formulas:
1. ⊥→p;
2. ((p →q) →p) →p;
3. p →¬¬p;

2.2. Natural deduction
25
4. ¬¬p →p;
5. ¬¬¬p →¬p;
6. (¬q →¬p) →(p →q);
7. (p →q) →(¬q →¬p);
8. ¬(p ∧q) →(¬p ∨¬q);
9. (¬p ∨¬q) →¬(p ∧q);
10. ((p ↔q) ↔r) ↔(p ↔(q ↔r));
11. ((p ∧q) →r) ↔(p →(q →r));
12. (p →q) ↔(¬p ∨q);
13. ¬¬(p ∨¬p).
These formulas are all classical tautologies.
Some of them can be easily
given a BHK-interpretation, but some of them cannot. For instance, a con-
struction for formula 3, which should be written as “p →((p →⊥) →⊥)”,
is as follows:
Given a proof of p, here is a proof of (p →⊥) →⊥: Take a proof
of p →⊥. It is a method to translate proofs of p into proofs
of ⊥. Since we have a proof of p, we can use this method to
obtain a proof of ⊥.
On the other hand, formula 4 does not seem to have such a construction.
(The classical symmetry between formula 3 and 4 disappears!)
2.2. Natural deduction
The language of intuitionistic propositional logic is the same as the language
of classical propositional logic. We assume an inﬁnite set PV of propositional
variables and we deﬁne the set Φ of formulas by induction, represented by
the following grammar:
Φ ::= ⊥| PV | (Φ →Φ) | (Φ ∨Φ) | (Φ ∧Φ).
That is, our basic connectives are: implication →, disjunction ∨, conjunc-
tion ∧, and the constant ⊥(false).
2.2.1. Convention. The connectives ¬ and ↔are abbreviations. That is,
• ¬ϕ abbreviates ϕ →⊥;

26
Chapter 2. Intuitionistic logic
• ϕ ↔ψ abbreviates (ϕ →ψ) ∧(ψ →ϕ).
2.2.2. Convention.
1. We sometimes use the convention that implication is right associative,
i.e., we write e.g. ϕ →ψ →ϑ instead of ϕ →(ψ →ϑ).
2. We assume that negation has the highest, and implication the lowest
priority, with no preference between ∨and ∧. That is, ¬p ∧q →r
means ((¬p) ∧q) →r.
3. And of course we forget about outermost parentheses.
In order to formalize the intuitionistic propositional calculus, we deﬁne a
proof system, called natural deduction, which is motivated by the informal
semantics of 2.1.
2.2.3. Warning. What follows is a quite simpliﬁed presentation of natural
deduction, which is often convenient for technical reasons, but which is not
always adequate.
To describe the relationship between various proofs in
ﬁner detail, we shall consider a variant of the system in Chapter 4.
2.2.4. Definition.
(i) A context is a ﬁnite subset of Φ.
We use Γ, ∆, etc. to range over
contexts.
(ii) The relation Γ ⊢ϕ is deﬁned by the rules in Figure 2.1. We also write
⊢N for ⊢.
(iii) We write Γ, ∆instead of Γ ∪∆, and Γ, ϕ instead of Γ, {ϕ}. We also
write ⊢ϕ instead of {} ⊢ϕ.
(iv) A formal proof of Γ ⊢ϕ is a ﬁnite tree, whose nodes are labelled by
pairs of form (Γ′, ϕ′), which will also be written Γ′ ⊢ϕ′, satisfying the
following conditions:
• The root label is Γ ⊢ϕ;
• All the leaves are labelled by axioms;
• The label of each father node is obtained from the labels of the
sons using one of the rules.
(v) For inﬁnite Γ we deﬁne Γ ⊢ϕ to mean that Γ0 ⊢ϕ, for some ﬁnite
subset Γ0 of Γ.
(vi) If ⊢ϕ then we say that ϕ is a theorem of the intuitionistic propositional
calculus.

2.2. Natural deduction
27
Γ, ϕ ⊢ϕ (Ax)
Γ ⊢ϕ
Γ ⊢ψ
Γ ⊢ϕ ∧ψ
(∧I)
Γ ⊢ϕ ∧ψ
Γ ⊢ϕ
(∧E)Γ ⊢ϕ ∧ψ
Γ ⊢ψ
Γ ⊢ϕ
Γ ⊢ϕ ∨ψ
(∨I)
Γ ⊢ψ
Γ ⊢ϕ ∨ψ
Γ, ϕ ⊢ρ
Γ, ψ ⊢ρ
Γ ⊢ϕ ∨ψ
Γ ⊢ρ
(∨E)
Γ, ϕ ⊢ψ
Γ ⊢ϕ →ψ
(→I)
Γ ⊢ϕ →ψ
Γ ⊢ϕ
Γ ⊢ψ
(→E)
Γ ⊢⊥
Γ ⊢ϕ
(⊥E)
Figure 2.1: Intuitionistic propositional calculus
The proof system consists of an axiom scheme, and rules. For each logical
connective (except ⊥) we have one or two introduction rules and one or two
elimination rules. An introduction rule for a connective • tells us how a
conclusion of the form ϕ • ψ can be derived. An elimination rule describes
the way in which ϕ • ψ can be used to derive other formulas. The intuitive
meaning of Γ ⊢ϕ is that ϕ is a consequence of the assumptions in Γ.
We give example proofs of our three favourite formulas:
2.2.5. Example. Let Γ abbreviate {ϕ →(ψ →ϑ), ϕ →ψ, ϕ}.
(i)
ϕ ⊢ϕ
⊢ϕ →ϕ
(→I)
(ii)
ϕ, ψ ⊢ϕ
ϕ ⊢ψ →ϕ
(→I)
⊢ϕ →(ψ →ϕ)
(→I)
(iii)
(→E)Γ ⊢ϕ →(ψ →ϑ)
Γ ⊢ϕ
Γ ⊢ψ →ϑ
Γ ⊢ϕ →ψ
Γ ⊢ϕ
Γ ⊢ψ
(→E)
Γ ⊢ϑ
ϕ →(ψ →ϑ), ϕ →ψ ⊢ϕ →ϑ
(→I)
ϕ →(ψ →ϑ) ⊢(ϕ →ψ) →(ϕ →ϑ)
(→I)
⊢(ϕ →(ψ →ϑ)) →(ϕ →ψ) →(ϕ →ϑ)
(→I)
(→E)

28
Chapter 2. Intuitionistic logic
2.2.6. Remark. Note the distinction between the relation ⊢, and a formal
proof of Γ ⊢ϕ.
The following properties will be useful.
2.2.7. Lemma. Intuitionistic propositional logic is closed under weakening
and substitution, that is, Γ ⊢ϕ implies Γ, ψ ⊢ϕ and Γ[p := ψ] ⊢ϕ[p := ψ],
where [p := ψ] denotes a substitution of ψ for all occurrences of a proposi-
tional variable p.
Proof. Easy induction with respect to the size of proofs.
⊓⊔
2.3. Algebraic semantics of classical logic
To understand better the algebraic semantics for intuitionistic logic let us
begin with classical logic. Usually, semantics of classical propositional for-
mulas is deﬁned in terms of the two truth values, 0 and 1 as follows.
2.3.1. Definition. Let B = {0, 1}.
(i) A valuation in B is a map v : PV →B; such a map will also be called
a 0-1 valuation.
(ii) Given a 0-1 valuation v, deﬁne the map [[•]]v : Φ →B by:
[[p]]v
=
v(p),
for p ∈PV ;
[[⊥]]v
=
0;
[[ϕ ∨ψ]]v
=
max{[[ϕ]]v, [[ψ]]v};
[[ϕ ∧ψ]]v
=
min{[[ϕ]]v, [[ψ]]v};
[[ϕ →ψ]]v
=
max{1 −[[ϕ]]v, [[ψ]]v}.
We also write v(ϕ) for [[ϕ]]v.
(iii) A formula ϕ ∈Φ is a tautology if v(ϕ) = 1 for all valuations in B.
Let us consider an alternative semantics, based on the analogy between
classical connectives and set-theoretic operations.
2.3.2. Definition. A ﬁeld of sets (over X) is a nonempty family R of sub-
sets of X, closed under unions, intersections and complement (to X).
It follows immediately that {}, X ∈R, for each ﬁeld of sets R over X.
Examples of ﬁelds of sets are:
(i) P(X);
(ii) {{}, X};
(iii) {A ⊆X : A ﬁnite or −A ﬁnite} (−A is the complement of A).

2.3. Algebraic semantics of classical logic
29
2.3.3. Definition. Let R be a ﬁeld of sets over X.
(i) A valuation in R is a map v : PV →R.
(ii) Given a valuation v in R, deﬁne the map [[•]]v : Φ →X by:
[[p]]v
=
v(p)
for p ∈PV
[[⊥]]v
=
{}
[[ϕ ∨ψ]]v
=
[[ϕ]]v ∪[[ψ]]v
[[ϕ ∧ψ]]v
=
[[ϕ]]v ∩[[ψ]]v
[[ϕ →ψ]]v
=
(X −[[ϕ]]v) ∪[[ψ]]v
We also write v(ϕ) for [[ϕ]]v.
2.3.4. Proposition. The above two approaches to semantics are equivalent,
i.e., the following conditions are equivalent for each ﬁeld of subsets R over
a nonempty set X:
1. ϕ is a tautology;
2. v(ϕ) = X, for all valuations v in R.
Proof. (1) ⇒(2): Suppose that v(ϕ) ̸= X. There is an element a ∈X
such that a ̸∈v(ϕ). Deﬁne a 0-1 valuation w so that w(p) = 1 iﬀa ∈v(p).
Prove by induction that for all formulas ψ
w(ψ) = 1
iﬀ
a ∈v(ψ).
Then w(ϕ) ̸= 1.
(2) ⇒(1): A 0-1 valuation can be seen as a valuation in R that assigns only
X and {} to propositional variables.
⊓⊔
2.3.5. Definition. A Boolean algebra is an algebraic system of the form
B = ⟨B, ∪, ∩, −, 0, 1⟩, where:
• ∪, ∩are associative and commutative;
• (a ∪b) ∩c = (a ∩c) ∪(b ∩c)
and
(a ∩b) ∪c = (a ∪c) ∩(b ∪c);
• a ∪0 = a
and
a ∩1 = a;
• −a ∪a = 1
and
−a ∩a = 0.
The relation ≤deﬁned by a ≤b iﬀa ∪b = b is a partial order1 in every
Boolean algebra, and the operations ∩, ∪are the glb and lub operations
w.r.t. this order.
1A transitive, reﬂexive and anti-symmetric relation.

30
Chapter 2. Intuitionistic logic
The notion of a Boolean algebra is a straightforward generalization of
the notion of a ﬁeld of sets. Another example of a Boolean algebra is the
algebra of truth values ⟨B, max, min, −, 0, 1⟩, where −x is 1 −x.
We can generalize the above set semantics to arbitrary Boolean algebras
by replacing valuations in a ﬁeld of sets by valuations in a Boolean algebra
in the obvious way. But in fact, every Boolean algebra is isomorphic to a
ﬁeld of sets, so this generalization does not change our semantics.
2.4. Heyting algebras
We will now develop a semantics for intuitionistic propositional logic.
Let Φ be the set of all propositional formulas, let Γ ⊆Φ (in particular Γ
may be empty) and let ∼be the following equivalence relation:
ϕ ∼ψ
iﬀ
Γ ⊢ϕ →ψ and Γ ⊢ψ →ϕ.
Let LΓ = Φ/∼= {[ϕ]∼: ϕ ∈Φ}, and deﬁne a partial order ≤over LΓ by:
[ϕ]∼≤[ψ]∼
iﬀ
Γ ⊢ϕ →ψ.
That ∼is an equivalence relation and that ≤is a well-deﬁned partial order
is a consequence of the following formulas being provable:
• ϕ →ϕ;
• (ϕ →ψ) →((ψ →ϑ) →(ϕ →ϑ));
In addition, we can deﬁne the following operations over LΓ:
[α]∼∪[β]∼
=
[α ∨β]∼;
[α]∼∩[β]∼
=
[α ∧β]∼;
−[α]∼
=
[¬α]∼.
These operations are well-deﬁned, because the following formulas are prov-
able:
• (ϕ →ϕ′) →(¬ϕ′ →¬ϕ);
• (ϕ →ϕ′) →((ψ →ψ′) →((ϕ ∨ψ) →(ϕ′ ∨ψ′)));
• (ϕ →ϕ′) →((ψ →ψ′) →((ϕ ∧ψ) →(ϕ′ ∧ψ′))).
We can go on and show that operations ∩and ∪are the glb and lub opera-
tions w.r.t. the relation ≤, and that the distributivity laws
(a ∪b) ∩c = (a ∩c) ∪(b ∩c)
and
(a ∩b) ∪c = (a ∪c) ∩(b ∪c)

2.4. Heyting algebras
31
are satisﬁed.2 The class [⊥]∼is the least element 0 of LΓ, because ⊥→ϕ
is provable, and [⊤]∼, where ⊤= ⊥→⊥, is the top element 1. We have
[⊤]∼= {ϕ : Γ ⊢ϕ}. However, there are (not unexpected) diﬃculties with
the complement operation: We have −a ∩a = [⊥]∼but not necessarily
−a ∪a = [⊤]∼.
The best we can assert about −a is that it is the greatest element such
that −a ∩a = 0, and we can call it a pseudo-complement. Since negation
is a special kind of implication, the above calls for a generalization. An
element c is called a relative pseudo-complement of a with respect to b, iﬀc
is the greatest element such that a∩c ≤b. The relative pseudo-complement,
if it exists, is denoted a ⇒b.
It is not diﬃcult to ﬁnd out that in our algebra LΓ, often called a Lin-
denbaum algebra, we have [ϕ]∼⇒[ψ]∼= [ϕ →ψ]∼.
We have just discovered a new type of algebra, called Heyting algebra or
pseudo-Boolean algebra.
2.4.1. Definition.
A Heyting algebra is an algebraic system of the form
H = ⟨H, ∪, ∩, ⇒, −, 0, 1⟩, that satisﬁes the following conditions:
• ∪, ∩are associative and commutative;
• (a ∪b) ∩c = (a ∩c) ∪(b ∩c)
and
(a ∩b) ∪c = (a ∪c) ∩(b ∪c);
• a ∪0 = a
and
a ∩1 = a;
• a ∪a = a;
• a ∩c ≤b is equivalent to c ≤a ⇒b (where a ≤b stands for a ∪b = b);
• −a = a ⇒0.
The above conditions amount to as much as saying that H is a distributive
lattice with zero and relative pseudo-complement deﬁned for each pair of
elements.
In particular, each Boolean algebra is a Heyting algebra with
a ⇒b deﬁned as −a ∪b. The most prominent example of a Heyting algebra
which is not a Boolean algebra is the algebra of open sets of a topological
space, for instance the algebra of open subsets of the Euclidean plane R2.
2.4.2. Definition.
• The symbol ϱ(a, b) denotes the distance between points a, b ∈R2;
• A subset A of R2 is open iﬀfor every a ∈A there is an r > 0 with
{b ∈R2 : ϱ(a, b) < r} ⊆A;
• If A is a subset of R2 then Int(A) denotes the interior of A, i.e., the
union of all open subsets of A.
2That is, LΓ is a distributive lattice.

32
Chapter 2. Intuitionistic logic
2.4.3. Proposition. Let H = ⟨O(R2), ∪, ∩, ⇒, ∼, 0, 1⟩, where
• O(R2) is the family of all open subsets of R2;
• the operations ∩, ∪are set-theoretic;
• A ⇒B := Int(−A ∪B), for arbitrary open sets A and B;
• 0 = {} and 1 = R2.
• ∼A = Int(−A), where −is the set-theoretic complement.
Then H is a Heyting algebra.
Proof. Exercise 2.7.6.
⊓⊔
In fact, every Heyting algebra is isomorphic to a subalgebra of the algebra
of open sets of a topological space. A comprehensive study of the algebraic
semantics for intuitionistic (and classical) logic is the book of Rasiowa and
Sikorski [88]. See also Chapter 13 of [108].
The semantics of intuitionistic propositional formulas is now deﬁned as
follows.
2.4.4. Definition. Let H = ⟨H, ∪, ∩, ⇒, −, 0, 1⟩be a Heyting algebra.
(i) A valuation v in a H is a map v : PV →H.
(ii) Given a valuation v in H, deﬁne the map [[•]]v : Φ →H by:
[[p]]v
=
v(p)
for p ∈PV
[[⊥]]v
=
0
[[ϕ ∨ψ]]v
=
[[ϕ]]v ∪[[ψ]]v
[[ϕ ∧ψ]]v
=
[[ϕ]]v ∩[[ψ]]v
[[ϕ →ψ]]v
=
[[ϕ]]v ⇒[[ψ]]v
As usual, we write v(ϕ) for [[ϕ]]v.
2.4.5. Notation. Let H = ⟨H, ∪, ∩, ⇒, −, 0, 1⟩be a Heyting algebra. We
write:
• H, v |= ϕ, whenever v(ϕ) = 1;
• H |= ϕ, whenever H, v |= ϕ, for all v;
• H, v |= Γ, whenever H, v |= ϕ, for all ϕ ∈Γ;
• H |= Γ, whenever H, v |= Γ, for all v;
• |= ϕ, whenever H, v |= ϕ, for all H, v;
• Γ |= ϕ, whenever H, v |= Γ implies H, v |= ϕ, for all H and v.

2.4. Heyting algebras
33
We say that a formula ϕ such that |= ϕ is intuitionistically valid or is an
intuitionistic tautology. It follows from the following completeness theorem
that the notions of a theorem and a tautology coincide for intuitionistic
propositional calculus.
2.4.6. Theorem (Soundness and Completeness). The following conditions
are equivalent
1. Γ ⊢ϕ;
2. Γ |= ϕ.
Proof. (1) ⇒(2): Verify that all provable formulas are valid in all Heyting
algebras (induction w.r.t. proofs).
(2) ⇒(1): This follows from our construction of the Lindenbaum algebra.
Indeed, suppose that Γ |= ϕ, but Γ ̸⊢ϕ. Then ϕ ̸∼⊤, i.e., [ϕ]≁= 1 in LΓ.
Deﬁne a valuation v by v(p) = [p]∼in LΓ and prove by induction that
v(ψ) = [ψ]∼, for all formulas ψ. It follows that v(ϕ) ̸= 1, a contradiction.
⊓⊔
2.4.7. Example. To see that Peirce’s law ((p →q) →p) →p is not intu-
itionistically valid, consider the algebra of open subsets of R2. Take v(p) to
be the whole space without one point, and v(q) = {}. (Note that a ⇒b = 1
in a Heyting algebra iﬀa ≤b.)
Intuitionistic logic is not ﬁnite-valued: There is no single ﬁnite Heyting
algebra H such that ⊢ϕ is equivalent to H |= ϕ.
Indeed, consider the
formula W{pi ↔pj : i, j = 0, . . . , n and i ̸= j}.
(Here the symbol W
abbreviates the disjunction of all members of the set.) This formula is not
valid in general (Exercise 2.7.10), although it is valid in all Heyting algebras
of cardinality at most n.
But ﬁnite Heyting algebras are suﬃcient for the semantics, as well as
one suﬃciently “rich” inﬁnite algebra.
2.4.8. Theorem.
1. A formula ϕ of length n is valid iﬀit is valid in all Heyting algebras
of cardinality at most 22n;
2. Let H be the algebra of all open subsets of a dense-in-itself 3 metric
space V (for instance the algebra of all open subsets of R2).
Then
H |= ϕ iﬀϕ is valid.
3Every point x is a limit of a sequence {xn}n, where xn ̸= x, for all n.

34
Chapter 2. Intuitionistic logic
We give only a sketch of the main ideas of the proof, for the most curious
reader. See [88] for details.
For (1), suppose H, v ̸|= ϕ, and let ϕ1, . . . ϕm be all subformulas of ϕ.
We construct a small model H′ as a distributive sublattice of H, with 0
and 1, generated by the elements v(ϕ1), . . . , v(ϕm). This lattice is a Heyting
algebra (warning: this is not a Heyting subalgebra of H), and H′, v′ ̸|= ϕ,
for a suitable v′.
As for (2), every ﬁnite algebra can be embedded into the algebra of open
subsets of some open subset of V , and this algebra is a homomorphic image
of H.
Thus, every valuation in a ﬁnite algebra can be translated into a
valuation in H.
From part (1) of the above theorem, it follows that intuitionistic propo-
sitional logic is decidable. But the upper bound obtained this way (double
exponential space) can be improved down to polynomial space, with help of
other methods, see [103].
2.5. Kripke semantics
We now introduce another semantics of intuitionistic propositional logic.
2.5.1. Definition. A Kripke model is deﬁned as a tuple of the form C =
⟨C, ≤, ⊩⟩, where C is a non-empty set, ≤is a partial order in C and ⊩is a
binary relation between elements of C (called states or possible worlds) and
propositional variables, that satisﬁes the following monotonicity condition:
If c ≤c′ and c ⊩p then c′ ⊩p.
The intuition is that elements of the model represent states of knowledge.
The relation ≤represents extending states by gaining more knowledge, and
the relation ⊩tells which atomic formulas are known to be true in a given
state. We extend this relation to provide meaning for propositional formulas
as follows.
2.5.2. Definition. If C = ⟨C, ≤, ⊩⟩is a Kripke model, then
• c ⊩ϕ ∨ψ
iﬀ
c ⊩ϕ or c ⊩ψ;
• c ⊩ϕ ∧ψ
iﬀ
c ⊩ϕ and c ⊩ψ;
• c ⊩ϕ →ψ
iﬀ
c′ ⊩ψ, for all c′ such that c ≤c′ and c′ ⊩ϕ;
• c ⊩⊥never happens.
We use C ⊩ϕ to mean that c ⊩ϕ, for all c ∈C.
Note that the above deﬁnition implies the following rule for negation:

2.5. Kripke semantics
35
• c ⊩¬ϕ
iﬀ
c′ ⊮ϕ, for all c′ ≥c.
and the following generalized monotonicity (proof by easy induction):
If c ≤c′ and c ⊩ϕ then c′ ⊩ϕ.
We now want to show completeness of Kripke semantics. For this, we trans-
form every Heyting algebra into a Kripke model.
2.5.3. Definition. A ﬁlter in a Heyting algebra H = ⟨H, ∪, ∩, ⇒, −, 0, 1⟩is
a nonempty subset F of H, such that
• a, b ∈F implies a ∩b ∈F;
• a ∈F and a ≤b implies b ∈F.
A ﬁlter F is proper iﬀF ̸= H. A proper ﬁlter F is prime iﬀa ∪b ∈F
implies that either a or b belongs to F.
2.5.4. Lemma. Let F be a proper ﬁlter in H and let a ̸∈F. There exists a
prime ﬁlter G such that F ⊆G and a ̸∈G.
We only give a hint for the proof that can be found e.g., in [88]. Consider
the family of all ﬁlters G containing F and such that a ̸∈G, ordered by
inclusion. Apply Kuratowski-Zorn Lemma to show that this family has a
maximal element. This is a prime ﬁlter (Exercise 2.7.12) although it is not
necessarily a maximal proper ﬁlter.
2.5.5. Lemma. Let v be a valuation in a Heyting algebra H.
There is a
Kripke model C = ⟨C, ≤, ⊩⟩, such that H, v |= ϕ iﬀC ⊩ϕ, for all formu-
las ϕ.
Proof. We take C to be the set of all prime ﬁlters in H. The relation ≤
is inclusion, and we deﬁne F ⊩p iﬀv(p) ∈F. By induction, we prove that,
for all formulas ψ,
F ⊩ψ
iﬀ
v(ψ) ∈F.
(2.1)
The only nontrivial case of this induction is when ψ = ψ′ →ψ′′. Assume
F ⊩ψ′ →ψ′′, and suppose that v(ψ′ →ψ′′) = v(ψ′) ⇒v(ψ′′) ̸∈F. Take
the least ﬁlter G′ containing F ∪{v(ψ′)}. Then
G′ = {b : b ≥f ∩v(ψ′) for some f ∈F},
and we have v(ψ′′) ̸∈G′, in particular G′ is proper.
Indeed, otherwise
v(ψ′′) ≥f ∩v(ψ′), for some f ∈F, and thus f ≤v(ψ′) ⇒v(ψ′′) ∈F —
a contradiction.

36
Chapter 2. Intuitionistic logic
We extend G′ to a prime ﬁlter G, not containing v(ψ′′). By the induction
hypothesis, G ⊩ψ′. Since F ⊩ψ′ →ψ′′, it follows that G ⊩ψ′′. That is,
v(ψ′′) ∈G — a contradiction.
For the converse, assume that v(ψ′ →ψ′′) ∈F ⊆G ⊩ψ′. From the
induction hypothesis we have v(ψ′) ∈G and since F ⊆G we obtain v(ψ′) ⇒
v(ψ′′) ∈G.
Thus v(ψ′′) ≥v(ψ′) ∩(v(ψ′) ⇒v(ψ′′)) ∈G, and from the
induction hypothesis we conclude G ⊩ψ′′ as desired.
The other cases are easy. Note that primality is essential for disjunction.
Having shown (2.1), assume that C ⊩ϕ and H, v ̸|= ϕ. Then v(ϕ) ̸= 1
and there exist a proper ﬁlter not containing v(ϕ). This ﬁlter extends to a
prime ﬁlter G such that v(ϕ) ̸∈G and thus G ⊮ϕ. On the other hand, if
H, v |= ϕ, then v(ϕ) = 1 and 1 belongs to all ﬁlters in H.
⊓⊔
2.5.6. Theorem. The sequent Γ ⊢ϕ is provable iﬀfor all Kripke models C,
the condition C ⊩Γ implies C ⊩ϕ.
Proof. The left-to-right part is shown by induction (Exercise 2.7.13). For
the other direction assume Γ ̸⊢ϕ. Then H, v |= Γ but H, v ̸|= ϕ, for some
H, v. From the previous lemma we have a Kripke model C with C ⊩Γ and
C ⊮ϕ.
⊓⊔
Here is a nice application of Kripke semantics.
2.5.7. Proposition. If ⊢ϕ ∨ψ then either ⊢ϕ or ⊢ψ.
Proof. Assume ̸⊢ϕ and ̸⊢ψ. There are Kripke models C1 = ⟨C1, ≤1, ⊩1⟩
and C2 = ⟨C2, ≤2, ⊩2⟩and states c1 ∈C1 and c2 ∈C2, such that c1 ⊮ϕ
and c2 ⊮
ψ.
Without loss of generality we can assume that c1 and c2
are least elements of C1 and C2, respectively, and that C1 ∩C2 = {}. Let
C = ⟨C1 ∪C2 ∪{c0}, ≤, ⊩⟩, where c0 ̸∈C1 ∪C2, the order is the union of
≤1 and ≤2 extended by c0 taken as the least element, and ⊩is the union
of ⊩1 and ⊩2. That is,
c0 ⊮p,
for all variables p. It is easy to see that this is a Kripke model. In addition
we have C, c1 ⊩ϑ iﬀC1, c1 ⊩ϑ, for all formulas ϑ, and a similar property
holds for c2.
Now suppose that ⊢ϕ ∨ψ. By soundness, we have c0 ⊩ϕ ∨ψ, and thus
either c0 ⊩ϕ or c0 ⊩ψ, by deﬁnition of ⊩. Then either c1 ⊩ϕ or c2 ⊩ψ,
because of monotonicity.
⊓⊔
2.6. The implicational fragment
The most important logical conjective is the implication. Thus, it is mean-
ingful to study the fragment of propositional calculus with only one connec-
tive: the implication. This is the true minimal logic. The natural deduction

2.7. Exercises
37
system for the implicational fragment consists of the rules (→E), (→I) and
the axiom scheme.
2.6.1. Theorem. The implicational fragment of intuitionistic propositional
calculus is complete with respect to Kripke models, i.e., Γ ⊢ϕ is provable iﬀ
for all Kripke models C, the condition C ⊩Γ implies C ⊩ϕ.
Proof. The implication from left to right follows from soundness of the full
natural deduction system, of which our minimal logic is a fragment. For the
proof in the other direction, let us assume that Γ ̸⊢ϕ. We deﬁne a Kripke
model C = ⟨C, ≤, ⊩⟩, where
C = {∆: Γ ⊆∆, and ∆is closed under ⊢}.
That is, ∆∈C means that ∆⊢ψ implies ψ ∈∆.
The relation ≤is inclusion and ⊩is ∈, that is, ∆⊩p holds iﬀp ∈∆,
for all propositional variables p. By induction we show the following claim:
∆⊩ψ
iﬀ
ψ ∈∆,
for all implicational formulas ψ and all states ∆. The case of a variable is
immediate from the deﬁnition. Let ψ be ψ1 →ψ2 and let ∆⊩ψ. Take ∆′ =
{ϑ : ∆, ψ1 ⊢ϑ}. Then ψ1 ∈∆′ and, by the induction hypothesis, ∆′ ⊩ψ1.
Thus ∆′ ⊩ψ2 and we get ψ2 ∈∆′, again by the induction hypothesis. Thus,
∆, ψ1 ⊢ψ2, and by (→I) we get what we want.
Now assume ψ ∈∆(that is ∆⊢ψ) and take ∆′ ≥∆with ∆′ ⊩ψ1.
Then ψ1 ∈∆′, i.e., ∆′ ⊢ψ1. But also ∆′ ⊢ψ1 →ψ2, because ∆⊆∆′. By
(→E) we can derive ∆′ ⊢ψ2, which means, by the induction hypothesis,
that ∆′ ⊩ψ2.
⊓⊔
The completeness theorem has a very important consequence: the con-
servativity of the full intuitionistic propositional calculus over its implica-
tional fragment.
2.6.2. Theorem. Let ϕ be an implicational formula, and let Γ be a set of
implicational formulas. If Γ ⊢ϕ can be derived in the intuitionistic proposi-
tional calculus then it can be derived in the implicational fragment.
Proof. Easy. But note that we use only one half from the two completeness
theorems 2.5.6 and 2.6.1: we need only soundness of the full logic and only
the other direction for the fragment.
⊓⊔
2.7. Exercises
2.7.1. Exercise. Find constructions for formulas (1), (3), (5), (7), (9), (11)
and (13) of Example 2.1.1, and do not ﬁnd constructions for the other for-
mulas.

38
Chapter 2. Intuitionistic logic
2.7.2. Exercise. Prove Lemma 2.2.7.
2.7.3. Exercise. Give natural deduction proofs for the formulas of Exer-
cise 2.7.1.
2.7.4. Exercise. Show that the relation ≤deﬁned in a Boolean algebra by
the condition a ≤b iﬀa ∪b = b is a partial order and that
• a ∩b ≤a;
• the condition a ≤b is equivalent to a ∩b = a;
• the operations ∪and ∩are respectively the upper and lower bound
wrt. ≤;
• the constants 0 and 1 are respectively the bottom and top element.
2.7.5. Exercise. Show that the relation ≤deﬁned in a Heyting algebra by
the condition a ≤b iﬀa ∪b = b is a partial order and that
• −a ∩a = 0;
• (a ∪b) ∩a = a and a ∩b ≤a;
• the condition a ≤b is equivalent to a ∩b = a, and to a ⇒b = 1;
• the operations ∪and ∩are respectively the upper and lower bound
wrt. ≤;
• the constants 0 and 1 are respectively the bottom and top element.
2.7.6. Exercise. Prove Proposition 2.4.3.
2.7.7. Exercise. Fill in the details of the proof that the Lindenbaum alge-
bra LΓ of 2.4 is indeed a Heyting algebra.
2.7.8. Exercise. Complete the proof of the completeness theorem 2.4.6.
2.7.9. Exercise. Show that the formulas (2), (4), (6), (8) and (10) are not
intuitionistically valid. (Use open subsets of R2 or construct Kripke models.)
2.7.10. Exercise. Show that the formula W{pi ↔pj : i, j = 0, . . . , n and
i ̸= j} is not intuitionistically valid.
2.7.11. Exercise. A ﬁlter is maximal iﬀit is a maximal proper ﬁlter. Show
that each maximal ﬁlter is prime. Show also that in a Boolean algebra every
prime ﬁlter is maximal.
2.7.12. Exercise. Complete the proof of Lemma 2.5.4.

2.7. Exercises
39
2.7.13. Exercise. Complete the proof of Theorem 2.5.6, part ⇒. (Hint:
choose a proper induction hypothesis.)
2.7.14. Exercise. Can the proof of Theorem 2.6.1 be generalized to the full
propositional calculus?
2.7.15. Exercise. A state c in a Kripke model C determines p iﬀeither
c ⊩p or c ⊩¬p. Deﬁne a 0-1 valuation vc by vc(p) = 1 iﬀc ⊩p. Show that
if c determines all propositional variables in ϕ then vc(ϕ) = 1 implies c ⊩ϕ.
2.7.16. Exercise. Let ϕ be a classical tautology such that all propositional
variables in ϕ are among p1, . . . , pn. Show that the formula (p1 ∨¬p1) →
· · · →(pn ∨¬pn) →ϕ is intuitionistically valid.
2.7.17. Exercise. Prove the Glivenko theorem: A formula ϕ is a classical
tautology iﬀ¬¬ϕ is an intuitionistic tautology.
2.7.18. Warning. The Glivenko theorem does not extend to ﬁrst-order logic.

40
Chapter 2. Intuitionistic logic

CHAPTER 3
Simply typed λ-calculus
Recall from the ﬁrst chapter that a λ-term, unlike the functions usually
considered in mathematics, does not have a ﬁxed domain and range. Thus,
whereas we would consider the function n 7→n2 as a function from natural
numbers to natural numbers (or from integers to natural numbers, etc.)
there is no corresponding requirement in λ-calculus. Or, to be more precise,
there is no corresponding requirement in type-free λ-calculus.
Curry [23] and Church [18] also introduced versions of their systems with
types. These systems form the topic of the present chapter.
3.1. Simply typed λ-calculus `a la Curry
We begin with the simply typed λ-calculus `a la Curry.
3.1.1. Definition.
(i) Let U denote a denumerably inﬁnite alphabet whose members will be
called type variables. The set Π of simple types is the set of strings
deﬁned by the grammar:
Π ::= U | (Π →Π)
We use α, β, . . . to denote arbitrary type variables, and σ, τ, . . . to de-
note arbitrary types. We omit outermost parentheses, and omit other
parentheses with the convention that →associates to the right.
(ii) The set C of contexts is the set of all sets of pairs of the form
{x1 : τ1, . . . , xn : τn}
with τ1, . . . , τn ∈Π, x1, . . . , xn ∈V (variables of Λ) and xi ̸= xj for i̸=j.
41

42
Chapter 3. Simply typed λ-calculus
(iii) The domain of a context Γ = {x1 : τ1, . . . , xn : τn} is deﬁned by:
dom(Γ) = {x1, . . . , xn}
We write x : τ for {x : τ} and Γ, Γ′ for Γ∪Γ′ if dom(Γ)∩dom(Γ′) = {}.
(iv) The range of a context Γ = {x1 : τ1, . . . , xn : τn} is deﬁned by:
|Γ| = {τ ∈Π | (x : τ) ∈Γ, for some x}.
(v) The typability relation ⊢on C × Λ × Π is deﬁned by:
Γ, x : τ ⊢x : τ
Γ, x : σ ⊢M : τ
Γ ⊢λx.M : σ →τ
Γ ⊢M : σ →τ
Γ ⊢N : σ
Γ ⊢M N : τ
where we require that x ̸∈dom(Γ) in the ﬁrst and second rule.
(vi) The simply typed λ-calculus λ→is the triple (Λ, Π, ⊢). To distinguish
between this system and variants, the present one will also be called
simply typed λ-calculus `a la Curry or just λ→`a la Curry.
3.1.2. Example. Let σ, τ, ρ be arbitrary types. Then:
(i) ⊢λx.x : σ →σ;
(ii) ⊢λx.λy.x : σ →τ →σ;
(iii) ⊢λx.λy.λz.x z (y z) : (σ →τ →ρ) →(σ →τ) →σ →ρ.
3.1.3. Definition. If Γ ⊢M : σ then we say that M has type σ in Γ. We
say that M ∈Λ is typable if there are Γ and σ such that Γ ⊢M : σ.
The set of typable terms is a subset—in fact, a proper subset—of the set
of all λ-terms. In this subset, restrictions are made regarding which λ-terms
may be applied to other λ-terms.
Very informally, the type variables denote some unspeciﬁed sets, and
σ →τ denotes the set of functions from σ to τ. Saying that M has type
σ →τ in Γ then intuitively means that this set of functions contains the
particular function that M informally denotes. For instance, ⊢λx.x : σ →σ
informally states that the identity function is a function from a certain set
to itself.
A context is an assumption that some elements x1, . . . , xn have certain
types σ1, . . . , σn, respectively. Moreover, if x has type σ and M has type τ
then λx.M has type σ →τ. This reﬂects the intuition that if M denotes
an element of τ for each x in σ, then λx.M denotes a function from σ to τ.
In a similar vein, if M has type σ →τ and N has type σ, then M N has
type τ.

3.1. Simply typed λ-calculus `a la Curry
43
3.1.4. Warning. The idea that types denote sets should not be taken too
literally. For instance, if A and B are sets then the set of functions from
A to A is disjoint from the set of functions from B to B. In contrast, if σ
and τ are diﬀerent simple types, then a single term may have both types,
at least in the version of simply typed λ-calculus presented above.
Just like λ-calculus provides a foundation of higher-order functional pro-
gramming languages like LISP and Scheme, various typed λ-calculi provide
a foundation of programming languages with types like Pascal, ML, and
Haskell. Typed λ-calculi are also of independent interest in proof theory as
we shall have frequent occasion to see in these notes.
We conclude this section with a brief review of some of the most funda-
mental properties of λ→. The survey follows [8].
The following shows that only types of free variables of a term matter
in the choice contexts.
3.1.5. Lemma (Free variables lemma). Assume that Γ ⊢M : σ. Then:
(i) Γ ⊆Γ′ implies Γ′ ⊢M : σ;
(ii) FV(M) ⊆dom(Γ);
(iii) Γ′ ⊢M : σ where dom(Γ′) = FV(M) and Γ′ ⊆Γ.
Proof. (i) by induction on the derivation of Γ ⊢M : σ. As in [8] we
present the proof in some detail and omit such details in the remainder.
1. The derivation is
∆, x : σ ⊢x : σ
where Γ = ∆, x : σ, x ̸∈dom(∆) and M = x. Since Γ ⊆Γ′ and Γ′
is a context, Γ′ = ∆′, x : σ for some ∆′ with x ̸∈dom(∆′). Hence
∆′, x : σ ⊢x : σ, as required.
2. The derivation ends in
Γ, x : τ1 ⊢P : τ2
Γ ⊢λx.P : τ1 →τ2
where x ̸∈dom(Γ), σ = τ1 →τ2, and M = λx.P. Without loss of
generality we can assume that x ̸∈dom(Γ′). Then Γ, x : τ1 ⊆Γ′, x : τ1
so by the induction hypothesis Γ′, x : τ1 ⊢P : τ2. Then we also have
Γ ⊢λx.P : τ1 →τ2, as required.
3. The derivation ends in
Γ ⊢P : τ →σ
Γ ⊢Q : τ
Γ ⊢P Q : σ
where M = P Q. By the induction hypothesis (twice) Γ′ ⊢P : τ →σ
and Γ′ ⊢Q : τ, and then Γ′ ⊢P Q : σ, as required.

44
Chapter 3. Simply typed λ-calculus
(ii)-(iii) by induction on the derivation of Γ ⊢M : σ.
⊓⊔
The following shows how the type of some term must have been obtained
depending on the form of the term.
3.1.6. Lemma (Generation lemma).
(i) Γ ⊢x : σ implies x : σ ∈Γ;
(ii) Γ ⊢M N : σ implies that there is a τ such that Γ ⊢M : τ →σ and
Γ ⊢N : τ.
(iii) Γ ⊢λx.M : σ implies that there are τ and ρ such that Γ, x : τ ⊢M : ρ
and σ = τ →ρ.
Proof. By induction on the length of the derivation.
⊓⊔
3.1.7. Definition. The substitution of type τ for type variable α in type σ,
written σ[α := τ], is deﬁned by:
α[α := τ]
=
τ
β[α := τ]
=
β
if α ̸= β
(σ1 →σ2)[α := τ]
=
σ1[α := τ] →σ2[α := τ]
The notation Γ[α := τ] stands for the context {(x : σ[α := τ]) | (x : σ) ∈Γ}.
The following shows that the type variables range over all types; this is a
limited form of polymorphism [90]; we will hear much more about polymor-
phism later. The proposition also shows, similarly, that free term variables
range over arbitrary terms.
3.1.8. Proposition (Substitution lemma).
(i) If Γ ⊢M : σ, then Γ[α := τ] ⊢M : σ[α := τ].
(ii) If Γ, x : τ ⊢M : σ and Γ ⊢N : τ then Γ ⊢M[x := N] : σ.
Proof. By induction on the derivation of Γ ⊢M : σ and generation of
Γ, x : τ ⊢M : σ, respectively.
⊓⊔
The following shows that reduction preserves typing.
3.1.9. Proposition (Subject reduction). If Γ ⊢M : σ and M →β N, then
Γ ⊢N : σ.
Proof. By induction on the derivation of M →β N using the substitution
lemma and the generation lemma.
⊓⊔

3.2. Simply typed λ-calculus `a la Church
45
3.1.10. Remark. The similar property
Γ ⊢N : σ & M →
→β N ⇒Γ ⊢M : σ
is called subject expansion and does not hold in λ→, see Exercise 3.6.2.
3.1.11. Corollary. If Γ ⊢M : σ and M →
→β N, then Γ ⊢N : σ.
3.1.12. Theorem (Church-Rosser property for typable terms). Suppose that
Γ ⊢M : σ. If M →
→β N and M →
→β N′, then there exists an L such that
N →
→β L and N′ →
→β L and Γ ⊢L : σ.
Proof. By the Church-Rosser property for λ-terms and the subject reduc-
tion property.
⊓⊔
3.2. Simply typed λ-calculus `a la Church
As mentioned earlier, simply typed λ-calculus was introduced by Curry [23]
and Church [18]. More precisely, Curry considered types for combinatory
logic, but his formulation was later adapted to λ-calculus [24].
There were several other important diﬀerences between the systems in-
troduced by Church and Curry.
In Curry’s system the terms are those of type-free λ-calculus and the
typing relation selects among these the typable terms. For instance, λx.x is
typable, whereas λx.x x is not.
In Church’s original system, the typing rules were built into the term
formation rules, as follows. Let Vσ denote a denumerable set of variables for
each σ ∈Π. Then deﬁne the set Λσ of simply typed terms of type σ by the
clauses:
x ∈Vσ
⇒
x ∈Λσ
M ∈Λσ→τ & N ∈Λσ
⇒
M N ∈Λτ
M ∈Λτ & x ∈Λσ
⇒
λxσ.M ∈Λσ→τ
The set of all simply typed terms is then taken as the union over all simple
types σ of the simply typed terms of type σ.
Instead of assuming that the set of variables is partitioned into disjoint
sets indexed by the set of simple types, we can use contexts to decide the
types of variables as in the system `a la Curry. Also, as in the system `a
la Curry, we can select the typable terms among a larger set. This yields
the following, more common, formulation of simply typed λ-calculus `a la
Church.

46
Chapter 3. Simply typed λ-calculus
3.2.1. Definition.
(i) The set ΛΠ of pseudo-terms is deﬁned by the following grammar:
ΛΠ ::= V | (λx: Π ΛΠ) | (ΛΠ ΛΠ)
where V is the set of (λ-term) variables and Π is the set of simple
types.1 We adopt the same terminology, notation, and conventions for
pseudo-terms as for λ-terms, see 1.3–1.10, mutatis mutandis.
(ii) The typability relation ⊩on C × ΛΠ × Π is deﬁned by:2
Γ, x : τ ⊢∗x : τ
Γ, x : σ ⊢∗M : τ
Γ ⊢∗λx:σ.M : σ →τ
Γ ⊢∗M : σ →τ
Γ ⊢∗N : σ
Γ ⊢∗M N : τ
where we require that x ̸∈dom(Γ) in the ﬁrst and second rule.
(iii) The simply typed λ-calculus `a la Church (λ→`a la Church, for short)
is the triple (ΛΠ, Π, ⊩).
(iv) If Γ ⊢∗M : σ then we say that M has type σ in Γ. We say that M ∈ΛΠ
is typable if there are Γ and σ such that Γ ⊢∗M : σ.
3.2.2. Example. Let σ, τ, ρ be arbitrary simple types. Then:
(i) ⊢∗λx:σ.x : σ →σ;
(ii) ⊢∗λx:σ.λy:τ.x : σ →τ →σ;
(iii) ⊢∗λx:σ→τ→ρ.λy:σ→τ.λz:σ.(x z) y z : (σ→τ→ρ)→(σ→τ)→σ→ρ.
Even with the formulation of λ →`a la Church in Deﬁnition 3.2.1 an
important diﬀerence with λ→`a la Curry remains: in Church’s system ab-
stractions have domains, i.e. are of the form λx: σ.M, whereas in Curry’s
system abstractions have no domain, i.e. are of the form λx.M. Thus, in
Church’s system one writes
λx:σ.x : σ →σ,
whereas in Curry’s system one writes
λx.x : σ →σ.
1Strictly speaking, we should proceed as in the case of λ-terms and deﬁne a notion of
pre-pseudo-terms, then deﬁne substitution and α-equivalence on these, and ﬁnally adopt
the convention that by M ∈ΛΠ we always mean the α-equivalence class, see 1.13–1.19.
We omit the details.
2In this chapter it is useful to distinguish syntactically between typing in the system `a
la Church and the system `a la Curry, and therefore we use ⊢∗here. In later chapters we
shall also use ⊢for ⊢∗.

3.2. Simply typed λ-calculus `a la Church
47
The two diﬀerent systems—Curry’s and Church’s—represent two diﬀer-
ent paradigms in programming languages. In Church’s system the program-
mer has to explicitly write the types for all variables used in the program
as in, e.g., Pascal, whereas in Curry’s approach the programmer merely
writes functions, and it is then the job of the compiler or the programming
environment to infer the types of variables, as e.g., in ML and Haskell.
Having introduced a new set of terms (pseudo-terms instead of λ-terms)
we are obliged to introduce the notions of substitution, reduction, etc., for
the new notion. This is carried out brieﬂy below. We reuse much notation
and terminology.
3.2.3. Definition. For M ∈ΛΠ deﬁne the set FV(M) of free variables of M
as follows.
FV(x)
=
{x}
FV(λx:σ.P)
=
FV(P)\{x}
FV(P Q)
=
FV(P) ∪FV(Q)
If FV(M) = {} then M is called closed.
3.2.4. Definition. For M, N ∈ΛΠ and x ∈V , the substitution of N for x
in M, written M[x := N], is deﬁned as follows:
x[x := N]
=
N
y[x := N]
=
y
if x̸=y
(P Q)[x := N]
=
P[x := N] Q[x := N]
(λy:σ.P)[x := N]
=
λy:σ.P[x := N]
where x̸=y and y ̸∈FV(N)
3.2.5. Definition. Let →β be the smallest relation on ΛΠ closed under the
rules:
(λx:σ . P) Q →β P[x := Q]
P →β P ′
⇒
∀x ∈V, σ ∈Π : λx:σ.P →β λx:σ.P ′
P →β P ′
⇒
∀Z ∈Λ :
P Z →β P ′ Z
P →β P ′
⇒
∀Z ∈Λ :
Z P →β Z P ′
A term of form (λx : σ . P) Q is called a β-redex, and P[x := Q] is called
its β-contractum. A term M is a β-normal form if there is no term N with
M →β N.
3.2.6. Definition.
(i) The relation →
→β (multi-step β-reduction) is the transitive-reﬂexive clo-
sure of →β;
(ii) The relation =β (β-equality) is the transitive-reﬂexive-symmetric clo-
sure of →β.

48
Chapter 3. Simply typed λ-calculus
We end the section by brieﬂy repeating the development in the preceding
subsection for simply typed λ-calculus `a la Church.
3.2.7. Lemma (Free variables lemma). Let Γ ⊢∗M : σ. Then:
(i) Γ ⊆Γ′ implies Γ′ ⊢∗M : σ;
(ii) FV(M) ⊆dom(Γ);
(iii) Γ′ ⊢∗M : σ where dom(Γ′) = FV(M) and Γ′ ⊆Γ.
Proof. See the Exercises.
⊓⊔
3.2.8. Lemma (Generation lemma).
(i) Γ ⊢∗x : σ implies x : σ ∈Γ;
(ii) Γ ⊢∗M N : σ implies that there is a τ such that Γ ⊢∗M : τ →σ and
Γ ⊢∗N : τ.
(iii) Γ ⊢∗λx: τ.M : σ implies that there is a ρ such that Γ, x : τ ⊢∗M : ρ
and σ = τ →ρ.
Proof. See the Exercises.
⊓⊔
3.2.9. Proposition (Substitution lemma).
(i) If Γ ⊢∗M : σ, then Γ[α := τ] ⊢∗M : σ[α := τ].
(ii) If Γ, x : τ ⊢∗M : σ and Γ ⊢∗N : τ then Γ ⊢∗M[x := N] : σ.
Proof. See the Exercises.
⊓⊔
3.2.10. Proposition (Subject reduction). If Γ ⊢∗M : σ and M →β N,
then Γ ⊢∗N : σ.
Proof. See the Exercises.
⊓⊔
3.2.11. Theorem (Church-Rosser property). Suppose that Γ ⊢∗M : σ. If
M →
→β N and M →
→β N′, then there exists an L such that N →
→β L and
N′ →
→β L and Γ ⊢∗L : σ.
Proof. One way to obtain this result is to repeat for ΛΠ an argument
similar to that we used for untyped terms, and then use the subject reduction
property. Another method, based on so called logical relations can be found
in [74].
⊓⊔
The following two properties of simply typed λ-calculus `a la Church do
not hold for the Curry system. Note that (ii) implies the subject expansion
property—see Remark 3.1.10.

3.3. Church versus Curry typing
49
3.2.12. Proposition (Uniqueness of types).
(i) If Γ ⊢∗M : σ and Γ ⊢∗M : τ then σ = τ.
(ii) If Γ ⊢∗M : σ and Γ ⊢∗N : τ and M =β N, then σ = τ.
Proof.
(i) By induction on M.
(ii) If M =β N then by the Church-Rosser property, M →
→β L and N →
→β L,
for some L. By subject reduction, Γ ⊢∗L : σ and Γ ⊢∗L : τ. Now
use (i).
⊓⊔
It is easy to see that these properties fail in λ→`a la Curry. For instance,
⊢λx.x : α →α and ⊢λx.x : (α →α) →(α →α) by the derivations:
x : α ⊢x : α
⊢λx.x : α →α
and
x : α→α ⊢x : α→α
⊢λx.x : (α→α) →(α→α)
Although these two derivations have the same structure, their conclusions
are diﬀerent due to diﬀerent type assumptions for x.
In contrast, if the
Church term M has type σ in Γ, then there is exactly one derivation of this
fact, which is uniquely encoded by M.
This diﬀerence leads to some interesting problems for the Curry system.
Given a term M which types can be assigned to M, if any? Is there a single
best type in some sense? Such problems are studied in type inference, which
we return to later.
Because of the above diﬀerence, λ→`a la Curry and other similar systems
are often called type assignment systems, in contrast to λ→`a la Church and
similar systems which are called, e.g., typed systems.
3.3. Church versus Curry typing
Although the simply typed λ-calculus `a la Curry and Church are diﬀerent,
one has the feeling that essentially the same thing is going on. To some
extent this intuition is correct, as we now show.
Every pseudo-term induces a type-free λ-term by erasing the domains of
abstractions.
3.3.1. Definition. The erasure map | • | : ΛΠ →Λ is deﬁned as follows:
|x|
=
x;
|M N|
=
|M| |N|;
|λx:σ.M|
=
λx.|M|.

50
Chapter 3. Simply typed λ-calculus
Erasure preserves reduction and typing:
3.3.2. Proposition (Erasing). Let M, N ∈ΛΠ.
(i) If M →β N then |M| →β |N|;
(ii) If Γ ⊢∗M : σ then Γ ⊢|M| : σ.
Proof. (i) prove by induction on M that
|M[x := N]| = |M|[x := |N|]
(∗)
Then proceed by induction on the derivation of M →β N using (∗).
(ii) by induction on the derivation of Γ ⊢∗M : σ.
⊓⊔
Conversely, one can “lift” every Curry derivation to a Church one.
3.3.3. Proposition (Lifting). For all M, N ∈Λ:
(i) If M →β N then for each M′ ∈ΛΠ with |M′| = M there is N ′ ∈ΛΠ
such that |N ′| = N, and M′ →β N′;
(ii) If Γ ⊢M : σ then there is an M′ ∈ΛΠ with |M′| = M and Γ ⊢∗M′ : σ.
Proof. By induction on the derivation of M →β N and Γ
⊢
M : σ,
respectively.
⊓⊔
3.3.4. Warning. The above two propositions allow one to derive certain
properties of Curry-style typable lambda-terms from analogous properties
of Church-style typed lambda-terms, or conversely.
For instance, strong
normalization for one variant of (λ →) easily implies strong normalization
for the other (Exercise 3.6.4).
However, one has to be very cautious with such proof methods, some-
times they do not work.
A common mistake (cf.
Exercise 3.6.5) is the
following attempt to derive the Church-Rosser property for Church-style
(λ →) from the Church-Rosser property for untyped lambda-terms:
Assume that M0 →
→β M1 and M0 →
→β M2. Then, by Propo-
sition 3.3.2, we have |M0| →
→β |M1| and |M0| →
→β |M2|.
By
Church-Rosser property for untyped lambda-terms, we have a
term P with |M1| →
→β P and |M2| →
→β P. In addition, by the
subject reduction property, P is typable into the desired type. It
remains to apply Proposition 3.3.3, to obtain a Church-style term
M3 with |M3| = P, and such that M2 →
→β M3 and M1 →
→β M3.
For an explanation why the gap in this argument cannot be easily ﬁxed, and
how it can be ﬁxed, see [74, pp. 269, 559].
In the remainder, when stating properties of simply typed λ-calculus it
must always be understood that the result applies to both λ→`a la Curry
and `a la Church, except when explicitly stated otherwise.

3.4. Normalization
51
3.4. Normalization
In this section we are concerned with λ→`a la Church.
A simple type can be regarded as a ﬁnite binary tree—this is where
the alternative name “ﬁnite type” comes from—where all internal nodes are
labeled by arrows and all leaves are labeled by type variables.
We shall
often refer to properties of types expressing them as properties of this tree
representation.
For instance, the function h(τ) deﬁned below is just the
height of the corresponding tree.
3.4.1. Definition. Deﬁne the function h : Π →N by:
h(α)
=
0
h(τ →σ)
=
1 + max(h(τ), h(σ))
It is often convenient to write Church style terms (typable pseudo-terms)
in such a way that types of some or all subterms are displayed by super-
scripts, as in e.g., (λx:τ.P ρ)τ→ρRτ. Recall that a Church style term can be
typed in only one way, provided the context of free variables is known. Thus
our labelling is always determined by the term and the context. But the
labelling itself is not a part of syntax, just a meta-notation.
The following property is the ﬁrst non-trivial property of λ→.
3.4.2. Theorem (Weak normalization). Suppose Γ ⊢∗M : σ. Then there
is a ﬁnite reduction M1 →β M2 →β . . . →β Mn ∈NFβ.
Proof. We use a proof idea due independently to Turing and Prawitz.
Deﬁne the height of a redex (λx:τ.P ρ)R to be h(τ →ρ). For M ∈ΛΠ
with M ̸∈NFβ deﬁne
m(M) = (h(M), n)
where
h(M) = max{h(∆) | ∆is a redex in M}
and n is the number of redex occurrences in M of height h(M). If M ∈NFβ
we deﬁne h(M) = (0, 0).
We show by induction on lexicographically ordered pairs m(M) that if
M is typable in λ→`a la Church, then M has a reduction to normal-form.
Let Γ ⊢M : σ. If M ∈NFβ the assertion is trivially true. If M ̸∈NFβ,
let ∆be the rightmost redex in M of maximal height h (we determine the
position of a subterm by the position of its leftmost symbol, i.e., the right-
most redex means the redex which begins as much to the right as possible).
Let M′ be obtained from M by reducing the redex ∆. The term M′
may in general have more redexes than M. But we claim that the number
of redexes of height h in M′ is smaller than in M. Indeed, the redex ∆has
disappeared, and the reduction of ∆may only create new redexes of height

52
Chapter 3. Simply typed λ-calculus
less than h. To see this, note that the number of redexes can increase by
either copying existing redexes or by creating new ones. Now observe that
if a new redex is created then one of the following cases must hold:
1. The redex ∆is of the form (λx:τ. . . . xP ρ . . . )(λyρ.Qµ)τ, where τ =
ρ →µ, and reduces to
. . . (λyρ.Qµ)P ρ . . . . There is a new redex
(λyρ.Qµ)P ρ of height h(τ) < h.
2. We have ∆= (λx:τ.λy:ρ.Rµ)P τ, occurring in the context ∆ρ→µQρ.
The reduction of ∆to λy:ρ.Rµ
1, for some R1, creates a new redex
(λy:ρ.Rµ
1)Qρ of height h(ρ →µ) < h(τ →ρ →µ) = h.
3. The last case is when ∆= (λx:τ.x)(λyρ.P µ), with τ = ρ →µ, and
it occurs in the context ∆τQρ. The reduction creates the new redex
(λyρ.P µ)Qρ of height h(τ) < h.
The other possibility of adding redexes is by copying.
If we have ∆=
(λx:τ.P ρ)Qτ, and P contains more than one free occurrence of x, then all
redexes in Q are multiplied by the reduction. But we have chosen ∆to be
the rightmost redex of height h, and thus all redexes in Q must be of smaller
heights, because they are to the right of ∆.
Thus, in all cases m(M) > m(M′), so by the induction hypothesis M′
has a normal-form, and then M also has a normal-form.
⊓⊔
In fact, an even stronger property than weak normalization holds: if
⊢∗
M : σ, then no inﬁnite reduction M1 →β M2 →β . . . exists.
This
property is called strong normalization and will be proved later.
The subject reduction property together with the Church-Rosser prop-
erty and strong normalization imply that reduction of any typable λ-term
terminates in a normal form of the same type, where the normal form is
independent of the particular order of reduction chosen.
3.5. Expressibility
As we saw in the preceding section, every simply typable λ-term has a
normal-form. In fact, one can eﬀectively ﬁnd this normal-form by repeated
reduction of the leftmost redex. (These results hold for both the `a la Curry
and `a la Church system.) Therefore one can easily ﬁgure out whether two
simply typable terms are β-equal: just reduce the terms to their respective
normal-forms and compare them.
These results should suggest that there will be diﬃculties in represent-
ing all the partial recursive functions and possibly also the total recursive
functions by simply typable λ-terms, as we shall now see. In the rest of this
section we are concerned with simply typed λ-calculus `a la Curry.

3.5. Expressibility
53
3.5.1. Definition. Let
int = (α →α) →(α →α)
where α is an arbitrary type variable. A numeric function f : Nn →N is
λ→-deﬁnable if there is an F ∈Λ with ⊢F : int →· · · →int →int
(n + 1 occurrences of int) such that
F cn1 . . . cnm =β cf(n1,... ,nm)
for all n1, . . . , nm ∈N.
It is natural to investigate which of the constructions from Chapter 1
carry over to the typed setting. This is carried out below.
3.5.2. Lemma. The constant and projection functions are λ→-deﬁnable.
Proof. See the Exercises.
⊓⊔
3.5.3. Lemma. The function sg : N →N deﬁned by sg(0) = 0, sg(m+1) = 1
is λ→-deﬁnable.
Proof. See the Exercises.
⊓⊔
3.5.4. Lemma. Addition and multiplication are λ→-deﬁnable.
Proof. See the Exercises.
⊓⊔
3.5.5. Definition. The class of extended polynomials is the smallest class
of numeric functions containing the
(i) projections: Um
i (n1, . . . , nm) = ni for all 1 ≤i ≤m;
(ii) constant functions: k(n) = k;
(iii) signum function: sg(0) = 0 and sg(m + 1) = 1.
and closed under addition and multiplication:
(i) addition: if f : Nk →N and g : Nl →N are extended polynomials, then
so is (f + g) : Nk+l →N
(f + g)(n1, . . . , nk, m1, . . . , ml) = f(n1, . . . , nk) + g(m1, . . . , ml)
(ii) multiplication: if f : Nk →N and g : Nl →N are extended polynomials,
then so is (f · g) : Nk+l →N
(f · g)(n1, . . . , nk, m1, . . . , ml) = f(n1, . . . , nk) · g(m1, . . . , ml)
3.5.6. Theorem (Schwichtenberg). The λ→-deﬁnable functions are exactly
the extended polynomials.
The proof is omitted. One direction follows easily from what has been
said already; the other direction is proved in [97].
If one does not insist that numbers be uniformly represented as terms of
type int, more functions become λ→-deﬁnable—see [35].

54
Chapter 3. Simply typed λ-calculus
3.6. Exercises
3.6.1. Exercise. Show that the following λ-terms have no type in λ→`a la
Curry.
1. λx.x x;
2. Ω
3. K I Ω;
4. Y;
5. c2 K.
3.6.2. Exercise. Find terms M and M′ and types σ, σ′ such that ⊢M : σ,
⊢M′ : σ′, M →
→β M′, and not ⊢M : σ′.
3.6.3. Exercise. Is the following true? If M →β N (where M, N ∈Λ) and
M′, N′ ∈ΛΠ are such that |M′| = M, |N ′| = N then M′ →β N′.
3.6.4. Exercise. Show that strong normalization for (λ →) `a la Curry im-
plies strong normalization for (λ →) `a la Church, and conversely.
3.6.5. Exercise. Find the bug in the example argument in Warning 3.3.4.
3.6.6. Exercise. Consider the proof of weak normalization. Assume that
a given term M is of length n including type annotations. Give a (rough)
upper bound (in terms of a function in n) for the length of the normalizing
sequence of reductions for M, obtained under the strategy deﬁned in that
proof. Can your function be bounded by expk(n), for some k? Can this be
done under the assumption that the height of redexes in M is bounded by
a given constant h? (Here, exp0(n) = n and expk+1(n) = 2expk(n).)
3.6.7. Exercise. This exercise, and the next one, are based on [35]. Deﬁne
the rank of a type τ, denoted rk(τ), as follows:
rk(α)
=
0
rk(τ →σ)
=
max(h(τ) + 1, h(σ))
Alternatively, we have
rk(τ1 →· · · →τn →α) = 1 + max(h(τ1), . . . , h(τn)).
The rank of a redex (λx:τ.P ρ)R is rk(τ →ρ). Then deﬁne the depth of a
term M, denoted d(M), by the conditions
d(x)
=
0;
d(MN)
=
1 + max(d(M), d(N));
d(λx:σ.M)
=
1 + d(M).

3.6. Exercises
55
Let r be the maximum rank of a redex occurring in M, and let d(M) = d.
Show (by induction w.r.t M) that M can be reduced in at most 2d −1 steps
to a term M1 such that the maximum rank of a redex occurring in M1 is at
most r −1, and d(M1) ≤2d.
3.6.8. Exercise. Let r be the maximum rank of a redex occurring in M,
and let d(M) = d. Use the previous exercise to prove that the normal form
of M is of depth at most expr(d), and can be obtained in at most expr(d)
reduction steps.
3.6.9. Exercise. Show that the constant functions and projection functions
are λ→-deﬁnable.
3.6.10. Exercise. Show that sg is λ→-deﬁnable.
3.6.11. Exercise. Show that addition and multiplication are λ→-deﬁnable.

56
Chapter 3. Simply typed λ-calculus

CHAPTER 4
The Curry-Howard isomorphism
Having met one formalism for expressing eﬀective functions—λ-calculus—
and another formalism for expressing proofs—natural deduction for intu-
itionistic logic—we shall now demonstrate an amazing analogy between the
two formalisms, known as the Curry-Howard isomorphism.
We have already seen several hints that eﬀective functions and proofs
should be intimately related.
For instance, as mentioned in Chapter 2,
the BHK-interpretation [17, 53, 63] states that a proof of an implication
ϕ1 →ϕ2 is a “construction” which transforms any proof of ϕ1 into a proof
of ϕ2. What is a construction? A possible answer is that it is some kind
of eﬀective function. There are several ways to make this answer precise.
In this chapter we present one such way; another one is given by Kleene’s
realizability interpretation, which we present later.
4.1. Natural deduction without contexts
Recall that Chapter 2 presented a so-called natural deduction formulation
of intuitionistic propositional logic. Such systems were originally introduced
by Gentzen [39]. More precisely, Gentzen introduced two kinds of systems,
nowadays called natural deduction systems and sequent calculus systems,
respectively. In this chapter we are concerned with the former kind; sequent
calculus systems will be introduced in the next chapter.
One of the most signiﬁcant studies of natural deduction systems after
Gentzen’s work in the 1930s appears in Prawitz’ classical book [85], which
is still very readable.
There is an informal way of writing natural deduction proofs. Instead of
maintaining explicitly in each node of a derivation the set of assumptions on
which the conclusion depends (the context), one writes all the assumptions
at the top of the derivation with a marker on those assumptions that have
been discharged by the implication introduction rule.
57

58
Chapter 4. The Curry-Howard isomorphism
Since this style is quite common in the proof theory literature—at least
until the Curry-Howard isomorphism became widely appreciated—we also
brieﬂy review that notation informally here. Another reason for doing so, is
that the notation displays certain interesting problems concerning assump-
tions that are hidden in our formulation of Chapter 2.
Consider the proof tree:
ϕ
(ϕ →ψ) ∧(ϕ →ρ)
ϕ →ψ
ψ
ϕ
(ϕ →ψ) ∧(ϕ →ρ)
ϕ →ρ
ρ
ψ ∧ρ
First note that, as always, the proof tree is written upside-down. The leaves
are the assumptions, and the root is the conclusion, so the proof tree demon-
strates that one can infer ψ ∧ρ from ϕ and (ϕ →ψ) ∧(ϕ →ρ).
As usual there is an →-introduction rule which discharges assumptions.
Thus we are able to infer ϕ →ψ ∧ρ from (ϕ →ψ) ∧(ϕ →ρ). Notationally
this is done by putting brackets around the assumption in question which
is then called closed, as opposed to the other assumptions which are called
open:
[ϕ]
(ϕ →ψ) ∧(ϕ →ρ)
ϕ →ψ
ψ
[ϕ]
(ϕ →ψ) ∧(ϕ →ρ)
ϕ →ρ
ρ
ψ ∧ρ
ϕ →ψ ∧ρ
Note that the above step discharges both occurrences of ϕ. In general, in an
→-introduction step, we may discharge zero, one, or more occurrences of an
assumption.
Taking this one step further we get
[ϕ]
[(ϕ →ψ) ∧(ϕ →ρ)]
ϕ →ψ
ψ
[ϕ]
[(ϕ →ψ) ∧(ϕ →ρ)]
ϕ →ρ
ρ
ψ ∧ρ
ϕ →ψ ∧ρ
(ϕ →ψ) ∧(ϕ →ρ) →ϕ →ψ ∧ρ
Since we may decide to discharge only some of the occurrences of an open
assumption in an →-introduction step, one sometimes adopts for readability
the convention of assigning numbers to assumptions, and one then indicates
in an →-introduction step which of the occurrences where discharged. In
the above example we thus might have the following sequence of proof trees.

4.1. Natural deduction without contexts
59
First:
ϕ(1)
(ϕ →ψ) ∧(ϕ →ρ)(2)
ϕ →ψ
ψ
ϕ(1)
(ϕ →ψ) ∧(ϕ →ρ)(2)
ϕ →ρ
ρ
ψ ∧ρ
Then by closing both occurrences of ϕ:
[ϕ](1)
(ϕ →ψ) ∧(ϕ →ρ)(2)
ϕ →ψ
ψ
[ϕ](1)
(ϕ →ψ) ∧(ϕ →ρ)(2)
ϕ →ρ
ρ
ψ ∧ρ
ϕ →ψ ∧ρ(1)
And by closing both occurrences of (ϕ →ψ) ∧(ϕ →ρ):
[ϕ](1)
[(ϕ →ψ) ∧(ϕ →ρ)](2)
ϕ →ψ
ψ
[ϕ](1)
[(ϕ →ψ) ∧(ϕ →ρ)](2)
ϕ →ρ
ρ
ψ ∧ρ
ϕ →ψ ∧ρ(1)
(ϕ →ψ) ∧(ϕ →ρ) →ϕ →ψ ∧ρ(2)
It is interesting to note that the notation where we indicate which as-
sumption is discharged allows us to distinguish between certain very similar
proofs. For instance, in
[ϕ](1)
[(ϕ →ψ) ∧(ϕ →ρ)](2)
ϕ →ψ
ψ
[ϕ](1)
[(ϕ →ψ) ∧(ϕ →ρ)](3)
ϕ →ρ
ρ
ψ ∧ρ
ϕ →ψ ∧ρ(1)
(ϕ →ψ) ∧(ϕ →ρ) →ϕ →ψ ∧ρ(2)
(ϕ →ψ) ∧(ϕ →ρ) →(ϕ →ψ) ∧(ϕ →ρ) →ϕ →ψ ∧ρ(3)
and
[ϕ](1)
[(ϕ →ψ) ∧(ϕ →ρ)](2)
ϕ →ψ
ψ
[ϕ](1)
[(ϕ →ψ) ∧(ϕ →ρ)](3)
ϕ →ρ
ρ
ψ ∧ρ
ϕ →ψ ∧ρ(1)
(ϕ →ψ) ∧(ϕ →ρ) →ϕ →ψ ∧ρ(3)
(ϕ →ψ) ∧(ϕ →ρ) →(ϕ →ψ) ∧(ϕ →ρ) →ϕ →ψ ∧ρ(2)

60
Chapter 4. The Curry-Howard isomorphism
we discharge the two occurrences of (ϕ →ψ) ∧(ϕ →ρ) separately, but in
diﬀerent orders.
Similarly,
[ϕ](1)
ϕ →ϕ(1)
ϕ →ϕ →ϕ(2)
and
[ϕ](1)
ϕ →ϕ(2)
ϕ →ϕ →ϕ(1)
are two diﬀerent proofs of ϕ →ϕ →ϕ. In the ﬁrst proof there is ﬁrst a
discharge step in which the single occurrence of ϕ is discharged, and then a
discharge step in which zero occurrences of ϕ are discharged. In the second
proof the order is reversed.
In order to avoid confusion with assumption numbers, we require that if
two assumptions ϕ and ψ have the same number, then ϕ and ψ are the same
formula. Also, when we discharge the assumptions with a given number (i),
we require that every assumption with this number actually occur on a
branch from the node where the discharging occurs.
In general, the rules for constructing the above proof trees look as follows.
ϕ
ψ
ϕ ∧ψ
ϕ ∧ψ
ϕ
ϕ ∧ψ
ψ
ϕ
ϕ ∨ψ
ψ
ϕ ∨ψ
ϕ ∨ψ
[ϕ](i)
...
ρ
[ψ](j)
...
ρ
ρ(i,j)
[ϕ](i)
...
ψ
ϕ →ψ(i)
ϕ →ψ
ϕ
ψ
⊥
ϕ
For instance, the upper left rule (∧-introduction) states that two proof
trees ending in roots ϕ and ψ, respectively, may be joined into a single proof
tree by addition of a new root ϕ ∧ψ with the former roots as children. The
→-introduction rule states that one may infer an implication by discharging
the assumptions with the label indicated by the step.

4.1. Natural deduction without contexts
61
As we shall see later in this chapter, there is an interest in proofs of a
certain simple form. One arrives at such proofs from arbitrary proofs by
means of proof normalization rules that eliminate detours in a proof. More
concretely, consider the proof tree:
[ϕ](1)
ϕ →ϕ(1)
[ψ](2)
ψ →ψ(2)
(ϕ →ϕ) ∧(ψ →ψ)
ϕ →ϕ
The proof tree demonstrates that ϕ →ϕ is derivable. However, it does
so by ﬁrst showing ϕ →ϕ, then inferring (ϕ →ϕ) ∧(ψ →ψ), and then,
ﬁnally, concluding ϕ →ϕ. A more direct proof tree, which does not make
an excursion via (ϕ →ϕ) ∧(ψ →ψ) is:
[ϕ](1)
ϕ →ϕ(1)
Note that the detour in the former proof tree is signiﬁed by an intro-
duction rule immediately followed by the corresponding elimination rule,
for example ∧-introduction and ∧-elimination. In fact, the above style of
detour-elimination is possible whenever an introduction rule is immediately
followed by the corresponding elimination rule.
As another example, consider the proof tree:
[ϕ](3)
ϕ →ϕ(3)
[ϕ →ϕ](1)
ψ →ϕ →ϕ(2)
(ϕ →ϕ) →ψ →ϕ →ϕ(1)
ψ →ϕ →ϕ
Here we infer ψ →ϕ →ϕ from ϕ →ϕ and (ϕ →ϕ) →ψ →ϕ →ϕ.
The proof of the latter formula proceeds by inferring ψ →ϕ →ϕ from the
assumption ϕ →ϕ. Since we can prove this assumption, we could simply
take this proof and replace the assumption ϕ →ϕ with the proof of this
formula:
[ϕ](3)
ϕ →ϕ(3)
ψ →ϕ →ϕ(2)
In general one considers the following proof normalization rules (sym-

62
Chapter 4. The Curry-Howard isomorphism
metric cases omitted):
Σ
ϕ
Π
ψ
ϕ ∧ψ
ϕ
→
Σ
ϕ
Σ
ψ
[ψ](i)
Π
ϕ
ψ →ϕ(i)
ϕ
→
Σ
ψ
Π
ϕ
Θ
ϕ
ϕ ∨ψ
[ϕ](i)
Σ
ρ
[ψ](j)
Π
ρ
ρ(i,j)
→
Θ
ϕ
Σ
ρ
The ﬁrst rule states that if we, somewhere in a proof, infer ϕ and ψ and then
use ∧-introduction to infer ϕ ∧ψ followed by ∧-elimination to infer ϕ, we
might as well avoid the detour and replace this proof simply by the subproof
of ϕ.
The second rule states that if we have a proof of ϕ from assumption ψ
and we use this and →-introduction to get a proof of ψ →ϕ, and we have
a proof of ψ then, instead of inferring ϕ by →-elimination, we might as well
replace this proof by the original proof of ϕ where we plug in the proof of ψ
in all the places where the assumption ψ occurs.
The reading of the third rule is similar.
The process of eliminating proof detours of the above kind, is called
proof normalization, and a proof tree with no detours is said to be in normal
form. Another similar process, called cut elimination, eliminates detours in
sequent calculus proofs whereas proof normalization eliminates detours in
natural deduction proofs. Sequent calculus systems are introduced in the
next chapter.
Proof normalization and cut elimination were studied in the 1930s by
Gentzen, and his studies were continued by several researchers, perhaps most
importantly by Prawitz in [85]. Nowadays, proof theory is an independent
discipline of logic.
In these notes we shall not consider natural deduction proofs in the above
style any further.

4.2. The Curry-Howard isomorphism
63
4.2. The Curry-Howard isomorphism
We could introduce reductions `a la those of the preceding section for the
natural deduction formulation of Chapter 2, but we shall not do so. The
rules for that formulation are rather tedious (try the rule for →!). It would
be more convenient to have each proof tree denoted by some 1-dimensional
expression and then state transformations on such expressions rather than
on proof trees. It happens that the terms of the simply typed λ-calculus are
ideal for this purpose, as we shall see in this section.
We show that any derivation in intuitionistic propositional logic corre-
sponds to a typable λ-term `a la Church, and vice versa. More precisely we
show this for the implicational fragment of intuitionistic propositional logic.
Recall from Section 2.6 that the implicational fragment is the subsystem
in which the only connective is →and in which the only rules are (→E)
and (→I). This fragment is denoted IPC(→). The whole system is denoted
IPC(→, ∧, ∨, ⊥) or plainly IPC.
If we take PV (the set of propositional variables) equal to U (the set of
type variables), then Φ (the set of propositional formulas in the implicational
fragment of intuitionistic propositional logic) and Π (the set of simply types)
are identical. This will be used implicitly below.
4.2.1. Proposition (Curry-Howard isomorphism).
(i) If Γ ⊢M : ϕ then |Γ| ⊢ϕ.1
(ii) If Γ ⊢ϕ then there exists M ∈ΛΠ such that ∆⊢M : ϕ, where
∆= {(xϕ : ϕ) | ϕ ∈Γ}.
Proof. (i): by induction on the derivation of Γ ⊢M : ϕ.
(ii): by induction on the derivation of Γ ⊢ϕ. Let ∆= {xϕ : ϕ | ϕ ∈Γ}.
1. The derivation is
Γ, ϕ ⊢ϕ
We consider two subcases:
(a) ϕ ∈Γ. Then ∆⊢xϕ : ϕ.
(b) ϕ ̸∈Γ. Then ∆, xϕ : ϕ ⊢xϕ : ϕ.
2. The derivation ends in
Γ ⊢ϕ →ψ
Γ ⊢ϕ
Γ ⊢ψ
By the induction hypothesis ∆⊢M : ϕ →ψ and ∆⊢N : ϕ, and
then also ∆⊢M N : ψ.
1Recall that |Γ| denotes the range of Γ.

64
Chapter 4. The Curry-Howard isomorphism
3. The derivation ends in
Γ, ϕ ⊢ψ
Γ ⊢ϕ →ψ
We consider two subcases:
(a) ϕ ∈Γ.
Then by the induction hypothesis ∆⊢M : ψ.
By
Weakening (Lemma 3.19(i)) ∆, x : ϕ
⊢
M : ψ, where x ̸∈
dom(∆). Then also ∆⊢λx:ϕ . M : ϕ →ψ.
(b) ϕ ̸∈Γ. Then by the induction hypothesis ∆, xϕ : ϕ ⊢M : ψ and
then also ∆⊢λxϕ :ϕ . M : ϕ →ψ.
⊓⊔
4.2.2. Remark. The correspondence displays certain interesting problems
with the natural deduction formulation of Chapter 2. For instance
x : ϕ, y : ϕ ⊢x : ϕ
x : ϕ ⊢λy:ϕ . x : ϕ →ϕ
⊢λx:ϕ . λy:ϕ . x : ϕ →ϕ →ϕ
and
x : ϕ, y : ϕ ⊢y : ϕ
x : ϕ ⊢λy:ϕ . y : ϕ →ϕ
⊢λx:ϕ . λy:ϕ . y : ϕ →ϕ →ϕ
are two diﬀerent derivations in λ→showing that both λx:ϕ . λy :ϕ . x and
λx:ϕ . λy:ϕ . y have type ϕ →ϕ →ϕ.
Both of these derivations are projected to
ϕ ⊢ϕ
ϕ ⊢ϕ →ϕ
⊢ϕ →ϕ →ϕ
This reﬂects the fact that, in the natural deduction system of Chapter 2, one
cannot distinguish proofs in which assumptions are discharged in diﬀerent
orders. Indeed, λ→can be viewed as an extension of IPC(→) in which
certain aspects such as this distinction are elaborated.
The correspondence between derivations in IPC(→) and λ →can be
extended to the whole system IPC by extending the simply typed λ-calculus
with pairs and disjoint sums. One extends the language ΛΠ with clauses:
ΛΠ
::=
. . .
| < ΛΠ, ΛΠ > | π1(ΛΠ) | π2(ΛΠ)
| inψ∨ϕ
1
(ΛΠ) | inψ∨ϕ
2
(ΛΠ) | case(ΛΠ; V.ΛΠ; V.ΛΠ)

4.2. The Curry-Howard isomorphism
65
and adds typing rules:
Γ ⊢M : ψ
Γ ⊢N : ϕ
Γ ⊢< M, N >: ψ ∧ϕ
Γ ⊢M : ψ ∧ϕ
Γ ⊢π1(M) : ψ
Γ ⊢M : ψ ∧ϕ
Γ ⊢π2(M) : ϕ
Γ ⊢M : ψ
Γ ⊢inψ∨ϕ
1
(M) : ψ ∨ϕ
Γ ⊢M : ϕ
Γ ⊢inψ∨ϕ
2
(M) : ψ ∨ϕ
Γ ⊢L : ψ ∨ϕ
Γ, x : ψ ⊢M : ρ
Γ, y : ϕ ⊢N : ρ
Γ ⊢case(L; x.M; y.N) : ρ
and reduction rules:
π1(< M1, M2 >)
→
M1
π2(< M1, M2 >)
→
M2
case(inϕ
1 (N); x.K; y.L)
→
K{x := N}
case(inϕ
2 (N); x.K; y.L)
→
L{y := N}
Intuitively, φ ∧ψ is a product type, so < M1, M2 > is a pair, and π1(M)
is the ﬁrst projection. In type-free λ-calculus these could be deﬁned in terms
of pure λ-terms (see Proposition 1.46), but this is not possible in λ→. This
is related to the fact that one cannot deﬁne conjunction in IPC in terms of
implication (contrary to the situation in classical logic, as we shall see later).
In the same spirit, φ ∨ψ is a sum (or “variant”) type. A sum type is
a data type with two unary constructors. Compare this to the data type
“integer list”, which is usually deﬁned as a data type with two constructors:
the 0-ary constructor Nil and the 2-ary constructor Cons(•, •) which takes a
number and a list of numbers. In a sum we have the two unary constructors
left and right injection.
Thus case(M; x.K; y.L) is a case-expression which tests whether M has
form inϕ
1 (N) (and then returns K with N for x) or in2(N) (and then re-
turns L with N for y), just like in a functional programming language
we could have a case-expression testing whether an expression is Nil or
Cons(n, ns).
Thus, uses of the axiom of intuitionistic propositional logic are reﬂected
by variables in the term, uses of the →-elimination rule correspond to ap-
plications, and uses of the →-introduction rule correspond to abstractions.
In fact, we can view λ→as a more elaborate formulation of IPC(→)
in which the terms “record” the rules it was necessary to apply to prove
the type of the term, when we view that type as a proposition. For in-
stance, λx : ϕ . x has type ϕ →ϕ, signifying the fact that we can prove
ϕ →ϕ by ﬁrst using the axiom recorded by the variable x and then using
→-introduction, recorded by λx : ϕ. In short, in λ→viewed as a logic,
the terms serve as a linear representation of proof trees, and are usually

66
Chapter 4. The Curry-Howard isomorphism
called constructions [58]. These are also constructions in the sense of the
BHK-interpretation: a construction of ϕ →ψ is a λ-term λx:ϕ . M of type
ϕ →ψ.
Two diﬀerent propositions cannot have the same construction, since we
work with Church terms. In contrast, several constructions may correspond
to the same proposition. This is because the same proposition may be proven
in diﬀerent ways.
Thus λ→and IPC(→) may be viewed as diﬀerent names for essentially
the same thing. This means that each of the concepts and properties con-
sidered in λ→makes sense in IPC(→) and vice versa.
As mentioned, terms in λ →correspond to constructions in IPC(→).
Types correspond to formulas, type constructors (sum and pair) to connec-
tives. Asking whether there exists a term of a given type (inhabitation),
corresponds to asking whether there exist a construction for a given propo-
sition (provability.) Asking whether there exists a type for a given term
(typability), corresponds to asking whether the construction is a construc-
tion of some formula.
What is a redex in a construction? Well, each introduction rule intro-
duces a constructor (a lambda, a pair, or an injection) in the construction,
and each elimination rule introduces a destructor (an application, a projec-
tion, or a case-expression). Now, a redex consists of a constructor imme-
diately surrounded by the corresponding destructor. Therefore a redex in
the construction represents a proof tree containing an application of an in-
troduction rule immediately followed by an application of the corresponding
elimination rule; this was what we called a detour in a proof tree. Therefore,
reduction on terms corresponds to normalization of constructions. A term
in normal form corresponds to a construction representing a proof tree in
normal form. The subject reduction proposition states that reducing a con-
struction of a formula yields a construction for the same formula.
The
Church-Rosser Theorem states that the order of normalization is immate-
rial. Also, it states that we managed to identify essentially identical proofs
without identifying all proofs.

4.2. The Curry-Howard isomorphism
67
In summary:
λ→
IPC(→)
term variable
assumption
term
construction (proof)
type variable
propositional variable
type
formula
type constructor
connective
inhabitation
provability
typable term
construction for a proposition
redex
construction representing proof tree with redundancy
reduction
normalization
value
normal construction
4.2.3. Example. Consider the following example deduction containing re-
dundancy. The original derivation with constructions is:
x : ϕ ⊢x : ϕ
⊢λx:ϕ . x : ϕ →ϕ
The complicated proof with constructions is:
y : ψ ⊢y : ψ
⊢λy:ψ . y : ψ →ψ
x : ϕ ⊢x : ϕ
⊢λx:ϕ . x : ϕ →ϕ
⊢< λx:ϕ . x, λy:ψ . y >: (ϕ →ϕ) ∧(ψ →ψ)
⊢π1(< λx:ϕ . x, λy:ψ . y >) : ϕ →ϕ
The construction of the latter proof tree in fact contains a redex which upon
reduction yields the construction of the former proof tree.
The perfect correspondence between reduction and normalization and
the related concepts, justiﬁes the name “isomorphism” rather than simply
“bijection.” In fact, reduction has been studied extensively in the λ-calculus
literature, while normalization has been studied independently in proof the-
ory.
Since the “discovery” of the isomorphism, the two worlds have merged,
and some authors feel that it is exactly in the correspondence between reduc-
tion and normalization that the isomorphism is deepest and most fruitful.
This point of view is supported by the fact that some typed λ-calculi have
been introduced as means of studying normalization for logics, most notably
Girard’s System F introduced in his work [44] from 1971. System F corre-
sponds to second order minimal propositional logic and will be discussed in
Chapter 12.

68
Chapter 4. The Curry-Howard isomorphism
As an appealing illustration of the isomorphism and an appropriate con-
clusion of this section, this system was independently invented at roughly
the same time in computer science by Reynolds [90] in his study of poly-
morphism in typed functional programming languages.
In the remainder of these notes the concepts corresponding to one an-
other under the isomorphism are used interchangeably. In particular, any
system as that of the preceding subsection will be called both a logic and a
λ-calculus depending on the aspects being emphasized.
4.3. Consistency from normalization
A number of properties regarding unprovability can be diﬃcult to establish
directly, but more easy to establish by semantical methods as we saw in
Chapter 2. Often these semantical methods can be replaced by methods
involving the weak normalization property.
The following shows that IPC(→) is consistent.
4.3.1. Proposition. ̸⊢⊥.
Proof. Assume that ⊢⊥. Then ⊢M : ⊥for some M ∈ΛΠ. By the weak
normalization theorem and the subject reduction theorem there is then an
N ∈NFβ such that ⊢N : ⊥.
Now, λ-terms in normal form have form x N1 . . . Nm (where N1, . . . , Nn
are normal-forms) and λx:σ . N′ (where N′ is in normal form). We cannot
have N of the ﬁrst form (then x ∈FV(N), but since ⊢N : ⊥, FV(N) = {}).
We also cannot have N of the second form (then ⊥= σ →τ for some σ, τ
which is patently false).
⊓⊔
4.4. Strong normalization
As suggested by the application in the preceding section, the weak normal-
ization property of λ→is a very useful tool in proof theory. In this section
we prove the strong normalization property of λ→which is sometimes even
more useful.
The standard method of proving strong normalization of typed λ-calculi
was invented by Tait [104] for simply typed λ-calculus, generalized to second-
order typed λ-calculus by Girard [44], and subsequently simpliﬁed by Tait [105].
Our presentation follows [8]; we consider in this section terms `a la Curry.
4.4.1. Definition.
(i) SNβ = {M ∈Λ | M is strongly normalizing }.
(ii) For A, B ⊆Λ, deﬁne A →B = {F ∈Λ | ∀a ∈A : F a ∈B}.

4.4. Strong normalization
69
(iii) For every simple type σ, deﬁne [[σ]] ⊆Λ by:
[[α]]
=
SNβ
[[σ →τ]]
=
[[σ]] →[[τ]]
4.4.2. Definition.
(i) A set X ⊆SNβ is saturated if
1. For all n ≥0 and M1, . . . Mn ∈SNβ:
x M1 . . . Mn ∈X
2. For all n ≥1 and M1, . . . , Mn ∈SNβ:
M0{x := M1} M2 . . . Mn ∈X ⇒(λx.M0) M1 M2 . . . Mn ∈X
(ii) S = {X ⊆Λ | X is saturated }.
4.4.3. Lemma.
(i) SNβ ∈S;
(ii) A, B ∈S ⇒A →B ∈S;
(iii) σ ∈Π ⇒[[σ]] ∈S.
Proof. Exercise 4.6.3.
⊓⊔
4.4.4. Definition.
(i) a valuation is a map ρ : V →Λ, where V is the set of term variables.
The valuation ρ(x := N) is deﬁned by
ρ(x := N)(y) =
½ N
if x ≡y
ρ(y)
otherwise
(ii) Let ρ be a valuation. Then [[M]]ρ = M{x1 := ρ(x1), . . . , xn := ρ(xn)},
where FV(M) = {x1, . . . , xn}.
(iii) Let ρ be a valuation. Then ρ |= M : σ iﬀ[[M]]ρ ∈[[σ]]. Also, ρ |= Γ iﬀ
ρ(x) ∈[[σ]] for all x : σ ∈Γ.
(iv) Γ |= M : σ iﬀ∀ρ : ρ |= Γ ⇒ρ |= M : σ.
4.4.5. Proposition (Soundness). Γ ⊢M : σ ⇒Γ |= M : σ.
Proof. By induction on the derivation of Γ ⊢M : σ.
1. The derivation is
Γ ⊢x : σ
x : σ ∈Γ
If ρ |= Γ, then [[x]]ρ = ρ(x) ∈[[σ]].

70
Chapter 4. The Curry-Howard isomorphism
2. The derivation ends in
Γ ⊢M : σ →τ
Γ ⊢N : σ
Γ ⊢M N : τ
Suppose ρ |= Γ. By the induction hypothesis Γ |= M : σ →τ and
Γ |= N : σ, so ρ |= M : σ →τ and ρ |= N : σ, i.e., [[M]]ρ ∈[[σ]] →[[τ]]
and [[N]]ρ ∈[[σ]]. Then [[M N]]ρ = [[M]]ρ [[N]]ρ ∈[[τ]], as required.
3. The derivation ends in
Γ, x : σ ⊢M : τ
Γ ⊢λx.M : σ →τ
Suppose ρ |= Γ. Also, suppose N ∈[[σ]]. Then ρ(x := N) |= Γ, x : σ.
By the induction hypothesis Γ, x : σ |= M : τ, so ρ(x := N) |= M : τ,
i.e., [[M]]ρ(x:=N) ∈[[τ]]. Now,
[[λx.M]]ρ N
≡
(λx.M) {y1 := ρ(y1), . . . , yn := ρ(yn)}N
→β
M{y1 := ρ(y1), . . . , yn := ρ(yn), x := N}
≡
[[M]]ρ(x:=N)
Since N ∈[[σ]] ⊆SNβ and [[M]]ρ(x:=N) ∈[[τ]] ∈S, it follows that
[[λx.M]]ρ N ∈[[τ]]. Hence [[λx.M]]ρ ∈[[σ →τ]].
⊓⊔
4.4.6. Theorem. Γ ⊢M : σ ⇒M ∈SNβ.
Proof. If Γ
⊢
M : σ, then Γ
|=
M : σ.
For each x : τ ∈Γ, let
ρ(x) = x. Then x ∈[[τ]] holds since [[τ]] ∈S. Then ρ |= Γ, and we have
M = [[M]]ρ ∈[[σ]] ⊆SNβ.
⊓⊔
The reader may think that the above proof is more complicated than the
weak normalization proof of the preceding chapter; in fact, this feeling can
be made into a technical property by noting that the latter proof involves
quantifying over sets, whereas the former does not.
The fact that the strong normalization property seems more diﬃcult to
prove has led to some techniques that aim at inferring strong normalization
from weak normalization—see [102].
There are many applications of strong normalization, but many of these
applications can be obtained already by using the weak normalization theo-
rem. The following is a true application of strong normalization where weak
normalization does not suﬃce.
4.4.7. Definition. Let →be a binary relation on some set L, and write
M →
→M′ if M = M1 →. . . →Mn = M′, where n ≥1. Then
1. →satisﬁes CR iﬀfor all M1, M2, M3 ∈L, M1 →
→M2 and M1 →
→M3
implies that there is an M4 ∈L such that M2 →
→M4 and M3 →
→M4.

4.5. Historical remarks
71
2. →satisﬁes WCR iﬀfor all M1, M2, M3 ∈L, M1 →M2 and M1 →M3
implies that there is an M4 ∈L such that M2 →
→M4 and M3 →
→M4.
3. →satisﬁes SN iﬀfor all M ∈L, there is no inﬁnite reduction sequence
M →M′ →. . . .
4. →satisﬁes WN iﬀfor all M ∈L, there is a ﬁnite reduction sequence
M →M′ →. . . →M′′ such that M′′ is a normal form (i.e., for all
N ∈L: M′′ ̸→N).
4.4.8. Proposition (Newman’s lemma). Let →be a binary relation satis-
fying SN. If →satisﬁes WCR, then →satisﬁes CR.
Proof. See the exercises.
⊓⊔
The following shows that the assumption about strong normalization
cannot be replaced by weak normalization.
4.4.9. Proposition. There is a binary relation →satisfying WN and WCR,
but not CR.
Proof. See the exercises.
⊓⊔
4.4.10. Corollary. Let M1 ∈Λ be typable in λ→`a la Church and assume
that M1 →
→β M2 and M1 →
→β M3. Then there is an M4 such that M2 →
→β M4
and M3 →
→β M4.
Proof. See the exercises.
⊓⊔
4.5. Historical remarks
The informal notion of a “construction” mentioned in the BHK-interpretation
was ﬁrst formalized in Kleene’s recursive realizability interpretation [60, 61]
in which proofs in intuitionistic number theory are interpreted as numbers,
as we will see later in the notes. A proof of ϕ1 →ϕ2 is interpreted as the
G¨odel number of a partial recursive function mapping the interpretation of
any proof of ϕ1 to the interpretation of a proof of ϕ2.
One can see the Curry-Howard isomorphism—the correspondence be-
tween systems of formal logic and functional calculi with types, mentioned
above—as a syntactic reﬂection of this interpretation. It shows that a cer-
tain notation system for denoting certain recursive functions coincides with
a system for expressing proofs.
Curry [24] discovered that the provable formulas in a so-called Hilbert
formulation of IPC(→) coincide with the inhabited types of combinatory
logic, when one identiﬁes function type with implication. Moreover, every
proof in the logic corresponds to a term in the functional calculus, and

72
Chapter 4. The Curry-Howard isomorphism
vice versa. Curry also noted a similar correspondence between a natural
deduction formulation of IPC(→) and simply typed λ-calculus, and between
a sequent calculus formulation of IPC(→) and a sequent calculus version of
simply typed λ-calculus.
Gentzen’s Hauptsatz [39] shows how one can transform a sequent cal-
culus proof into another proof with no applications of the cut rule. Curry
now proved a corresponding result for the sequent calculus version of simply
typed λ-calculus. He then formulated correspondences between sequent cal-
culus systems, natural deduction systems, and Hilbert systems (in terms of
the corresponding functional calculi) and used these to infer weak normal-
ization for β-reduction in simply typed λ-calculus and for so-called strong
reduction in combinatory logic.
A more direct relation between reduction on terms and normalization
of proofs was given by Howard in a paper from 1968, published as [58].
Prawitz had studied reduction of natural deduction proofs extensively [85]—
seven years after Curry’s book—and had proved weak normalization of this
notion of reduction. Howard now showed that reduction of a proof in the
natural deduction system for minimal implicational logic corresponds to β-
reduction on the corresponding term in the simply typed λ-calculus. He also
extended this correspondence to ﬁrst order intuitionistic arithmetic and a
related typed λ-calculus.
Howard’s correspondence and the weak normalization theorem give a
syntactic version of Kleene’s interpretation, where one replaces recursive
functions by λ-terms in normal form. For instance, any proof of ϕ1 →ϕ2
reduces to a λ-abstraction which, when applied to a proof of ϕ1, yields a
proof of ϕ2.
Constable [19, 20] suggested that a type or proposition ϕ be viewed as a
speciﬁcation, and any proof M of ϕ as a program satisfying the speciﬁcation.
For instance, sorting can be speciﬁed by the formula
∀x ∃y : ordered(y) ∧permutation(x, y)
in predicate logic, and a proof of the formula will be a sorting algorithm.
There is a literature devoted to methods for ﬁnding eﬃcient programs in
this way.
The Curry-Howard isomorphism has evolved with the invention of nu-
merous typed λ-calculi and corresponding natural deduction logics, see [87,
55, 8, 41]. Other names for the isomorphism include propositions-as-types,
formula-as-types, and proofs-as-programs.
4.6. Exercises
4.6.1. Exercise. Give derivations of the formulas (1),(3),(5),(7),(9),(11) from
Section 2.2 using the natural deduction style of Section 4.1.

4.6. Exercises
73
4.6.2. Exercise. Give λ-terms corresponding to the derivations from Exer-
cise 4.6.1. Use the following rule for λ-terms corresponding to the ex-falso
rule:
Γ ⊢M : ⊥
Γ ⊢εϕ(M) : ϕ .
4.6.3. Exercise. Prove Lemma 4.4.3.
4.6.4. Exercise.
1. Prove Newman’s Lemma.
Hint: Prove by induction on the length of the longest reduction se-
quence from M that M →
→M1 and M →
→M2 implies that there is
an M3 such that M1 →
→M3 and M2 →
→M3.
2. Prove Proposition 4.4.9.
3. Infer from Newman’s Lemma Corollary 4.4.10.
4.6.5. Exercise. Prove Proposition 4.2.1(i) in detail.
4.6.6. Exercise. A β-reduction strategy is a map F : Λ →Λ such that
M →β F(M) if M ̸∈NFβ, and F(M) = M otherwise. Informally, a reduc-
tion strategy selects from any term not in normal form a redex and reduces
that.
For example, Fl is the reduction strategy that always reduces the
left-most redex.
A reduction strategy F is normalizing if, for any weakly normalizing
term M, there is an i such that2
M →β F(M) →β . . . →β F i(M) ∈NFβ
That is, if the term has a normal form, then repeated application of F
eventually ends in the normal form. A classical result due to Curry and
Feys states that Fl is normalizing.
A reduction strategy F is perpetual if, for any term M which is not
strongly normalizing, there is no i such that
M →β F(M) →β . . . →β F i(M) ∈NFβ
That is, if the term has an inﬁnite reduction, then repeated application of F
yields an inﬁnite reduction sequence.
Deﬁne F∞: Λ →Λ as follows. If M ∈NFβ then F∞(M) = M; other-
wise3
F∞(x ⃗P Q ⃗R)
=
x ⃗P F∞(Q) ⃗R
If ⃗P ∈NFβ, Q ̸∈NFβ
F∞(λx.P)
=
λx.F∞(P)
F∞((λx.P) Q ⃗R)
=
P{x := Q} ⃗R
If x ∈FV(P) or Q ∈NFβ
F∞((λx.P) Q ⃗R)
=
(λx.P) F∞(Q) ⃗R
If x ̸∈FV(P) and Q ̸∈NFβ
2As usual, F 0(M) = M and F i+1(M) = F(F i(M)).
3By ⃗P we denote a ﬁnite, possibly empty, sequence of terms.

74
Chapter 4. The Curry-Howard isomorphism
Show that F∞is perpetual.
Let ΛI be the set of all λ-terms M such that any part λx.P of M satisﬁes
x ∈FV(P). For instance, I ∈ΛI and Ω∈ΛI but K = λx.λy.x ̸∈ΛI. Show
that for any M ∈ΛI: M ∈WNβ iﬀM ∈SNβ.
Hint: Compare being weakly normalizing with Fl leading to a normal
form, and compare begin strongly normalizing with F∞leading to a normal
form. What is the relation between Fl and F∞on M ∈ΛI?
Since ΛI is a subset of Λ, the elements of ΛI that have a type in λ→
(`a la Curry) must correspond to a subset of all proofs in IPC(→). Which
proofs are these?

CHAPTER 5
Proofs as combinators
In the preceding chapters we have considered various systems of λ-calculi.
One rather disturbing aspect of these systems is the role played by bound
variables, especially in connection with substitution.
In this chapter we
consider a system, combinatory logic, which is equivalent to λ-calculus in a
certain sense, and in which there are no bound variables.
The ﬁrst section introduces a version of combinatory logic analogous to
type-free λ-calculus. The second section presents simply typed combinatory
logic, analogous to simply typed λ-calculus.
Since simply typed λ-calculus corresponds to the natural deduction for-
mulation of intuitionistic propositional logic via the Curry-Howard isomor-
phism, and combinatory logic is a variant of λ-calculus, it is natural to ex-
pect that simply typed combinatory logic also corresponds to some variant of
intuitionistic propositional logic. This variant, traditionally called Hilbert-
style as opposed to natural deduction style, is introduced in the third section,
and the fourth section presents the Curry-Howard isomorphism between the
Hilbert-style intuitionistic propositional logic and combinatory logic.
The ﬁfth section studies special cases of the Curry-Howard isomorphism
by investigating how certain restrictions in the logic are reﬂected by restric-
tions in the functional calculus.
5.1. Combinatory logic
Combinatory logic was invented by Sch¨onﬁnkel and Curry in the 1920’s
shortly before Church introduced the lambda-calculus.
The idea was to
build the foundations of logic on a formal system in which logical formulas
could be handled in a variable-free manner.
As mentioned in Chapter 1, the systems of combinatory logic and λ-
calculus that aimed at providing a foundations of mathematics and logic
turned out to be inconsistent, due to the presence of arbitrary ﬁxed-points—
see [7, App. B] or [55, Chap. 17]. Nevertheless, one may distinguish a useful
75

76
Chapter 5. Proofs as combinators
subsystem of the original system of combinators dealing only with pure
functions, and this system will be called combinatory logic below.
The objects of study in combinatory logic are the combinatory terms.
5.1.1. Definition. The set C of combinatory terms is deﬁned by the gram-
mar:
C ::= V | K | S | (CC)
where V is the same set of variables as used in Λ. The notational conventions
concerning parentheses are the same as for lambda-terms.
5.1.2. Definition. The reduction relation →w on combinatory terms, called
weak reduction is deﬁned by the following rules:
• KFG →w F;
• SFGH →w FH(GH);
• If F →w F ′ then FG →w F ′G and GF →w GF ′.
The symbol →
→w denotes the smallest reﬂexive and transitive relation con-
taining →w, and =w denotes the least equivalence relation containing →w.
A w-normal form is a combinatory term F such that F ̸→w G, for all
combinatory terms G.
5.1.3. Example.
• Let I = SKK. Then, for all F, we have IF →w KF(KF) →w F.
• The term SII(SII) reduces to itself.
• Let W = SS(KI). Then, for all F, G, we have WFG →
→w FGG.
• Let B = S(KS)K. Then, for all F, G, H, we have BFGH →
→w F(GH).
• Let C = S(BBS)(KK). Then CFGH →
→w FHG, for all F, G, H.
• K, S, K S, S K, and S KK are w-normal forms.
The following gives the ﬁrst hint that combinatory logic is essentially
simpler than λ-calculus in some respects.
5.1.4. Definition. For F ∈C deﬁne the set FV(F) of free variables of F
by:
FV(x)
=
{x};
FV(H G)
=
FV(H) ∪FV(G);
FV(S)
=
{};
FV(K)
=
{}.

5.1. Combinatory logic
77
For F, G ∈C and x ∈V deﬁne substitution of G for x in F by:
x{x := G}
=
G;
y{x := G}
=
y
if x ̸= y;
(H E){x := G}
=
H{x := G} E{x := G};
S{x := G}
=
S;
K{x := G}
=
K.
Note that there are no bound variables, and no need for renaming in
substitutions.
The following is similar to the the Church-Rosser property for λ-calculus.
5.1.5. Theorem (Church-Rosser property). If F →
→w F1 and F →
→w F2
then F1 →
→w G and F2 →
→w G, for some G.
Proof. See the exercises.
⊓⊔
One can then infer Corollaries similar to 1.35–37 in Chapter 1.
There is an obvious similarity between terms of lambda-calculus and
combinatory terms. A translation
( )Λ : C →Λ
is easy to deﬁne. We just identify K and S with the corresponding lambda-
terms:
5.1.6. Definition.
• (x)Λ = x, for x ∈V ;
• (K)Λ = λxy.x;
• (S)Λ = λxyz.xz(yz);
• (FG)Λ = (F)Λ(G)Λ.
5.1.7. Proposition.
If F →
→w G then (F)Λ →
→β (G)Λ.
Proof. By induction on the derivation of F →
→w G.
⊓⊔
5.1.8. Remark. It is not in general the case that (F)Λ →
→β (G)Λ implies
F →
→w G. Counter-example: (S (K I) K)Λ →β (K)Λ but S (K I) K ̸→w K.
It is less obvious how to make a translation backward, because we have
to deﬁne lambda abstraction without bound variables. One of the possible
methods is as follows.
5.1.9. Definition.
For each F ∈C and each x ∈V we deﬁne the term
λ∗x.F ∈C.

78
Chapter 5. Proofs as combinators
• λ∗x.x = I;
• λ∗x.F = KF, if x ̸∈FV(F);
• λ∗x.FG = S(λ∗x.F)(λ∗x.G), otherwise.
The following shows that the deﬁnition of abstraction behaves (partly)
as expected.
5.1.10. Proposition.
(λ∗x.F)G →
→w F{x := G}
Proof. Exercise 5.6.3.
⊓⊔
Using the operator λ∗x, we can deﬁne a translation
( )C : Λ →C
as follows.
5.1.11. Definition.
• (x)C = x, for x ∈V ;
• (MN)C = (M)C(N)C;
• (λx.M)C = λ∗x.(M)C.
5.1.12. Remark. It is natural to expect, dually to Proposition 5.1.7, that
one could use Proposition 5.1.10 to prove that
M →
→β N ⇒(M)C →
→w (N)C
(∗)
However, this property does not hold. For instance λx.I I →β λx.I, but
(λx.I I)C = S (K I) (K I) ̸→
→w K I = (λx.I)C.
If one attempts to prove (∗) by induction on the derivation of M →
→β N,
one runs into diﬃculties in the case M →β N ⇒λx.M →β λx.N. The
problem is that the corresponding principle
F →w G ⇒λ∗x.F →w λ∗x.G
(ξ)
fails. The references at the end of the chapter contain more information
about this problem.
The following shows that the translations between Λ and C are inverses in
a weak sense.
5.1.13. Proposition.
For all M ∈Λ, we have ((M)C)Λ =β M.
Proof. Exercise 5.6.4.
⊓⊔

5.2. Typed combinators
79
Because of Propositions 5.1.7 and 5.1.13, we can think of ( )Λ as of a
homomorphic embedding of the combinatory logic into the lambda-calculus.
In what follows, we often abuse the notation by using the names S, K, etc. for
the λ-terms (K)Λ, (S)Λ, etc.
The following property is sometimes expressed by saying that K and S
make a basis for untyped λ-calculus.
5.1.14. Corollary. Every closed lambda term M is beta-equal to a term
obtained from K and S solely by application.
Proof. The desired term is ((M)C)Λ.
⊓⊔
Unfortunately, the embedding ( )Λ : C →Λ is not an isomorphism. Put
diﬀerently, the left inverse operator ( )C is only a projection (retraction).
Indeed, we have already seen that the statement dual to Proposition 5.1.7
fails, and the same holds for the statement dual to Proposition 5.1.13.
5.1.15. Example. ((K)Λ)C = S(KK)I ̸=w K.
It follows that “weak” equality is actually a strong property!
5.2. Typed combinators
Since combinatory terms can be seen as a subset of lambda-terms, they can
also inherit the structure of simply-typed lambda-calculus. Of course, there
are two ways to do this.
5.2.1. Definition. Deﬁne the typability relation ⊢on C × C × Π by:
Γ, x : τ ⊢x : τ
Γ ⊢K : σ →τ →σ
Γ ⊢S : (σ →τ →ρ) →(σ →τ) →σ →ρ
Γ ⊢M : σ →τ
Γ ⊢N : σ
Γ ⊢M N : τ
for all types σ, τ and ρ and arbitrary context Γ.
The other formulation of simply typed combinatory logic uses combina-
tory terms `a la Church.

80
Chapter 5. Proofs as combinators
5.2.2. Definition. Deﬁne the set CΠ of combinatory terms `a la Church by
the grammar:
CΠ ::= V | Kσ,τ | Sσ,τ,ρ | (CΠ CΠ)
Deﬁne the typability relation ⊢on C × CΠ × Π by:
Γ, x : τ ⊢x : τ
Γ ⊢Kσ,τ σ →τ →σ
Γ ⊢Sσ,τ,ρ : (σ →τ →ρ) →(σ →τ) →σ →ρ
Γ ⊢M : σ →τ
Γ ⊢N : σ
Γ ⊢M N : τ
Following the path of Chapter 3 we could derive the usual properties,
e.g., the free variables lemma, a version of the generation lemma, and so
on, for each of the two combinatory logics with types. In some cases, e.g.
the proof of subject reduction, the proof is simpler since reduction does not
entail any substitutions, in contrast to the case of β-reduction. Moreover, we
might also prove an equivalence result analogous to Propositions 3.3.2–3.3.3.
However, for the sake of brevity, we shall not do so.
To distinguish between the typing relation for simply typed combinatory
logic and the one for simply typed λ-calculus, we shall use ⊢C and ⊢Λ for the
two, respectively. In the remainder of the notes it will be clear from context
whether the typing relations refer to `a la Curry or `a la Church systems, both
in connection with combinatory logic and λ-calculus.
It is not diﬃcult to see that our embedding ( )Λ preserves types. In
addition, the same is true for the translation ( )C, but this requires the
following lemma:
5.2.3. Lemma. Let Γ, x : ρ ⊢C F : τ. Then Γ ⊢C λ∗x.F : ρ →τ.
Proof. By induction on F.
⊓⊔
5.2.4. Proposition.
1. If Γ ⊢C F : τ then Γ ⊢Λ (F)Λ : τ.
2. If Γ ⊢Λ M : τ then Γ ⊢C (M)C : τ.
Proof. (i): By induction on the derivation of Γ ⊢C F : τ. (ii): By induction
on the derivation of Γ ⊢Λ M : τ, using Lemma 5.2.3
⊓⊔
5.2.5. Corollary. The simply-typed version of the calculus of combinators
has the strong normalization property.
Proof. By strong normalization of simply typed λ-calculus and Proposi-
tion 5.1.7.
⊓⊔

5.3. Hilbert-style proofs
81
5.3. Hilbert-style proofs
Recall from Chapter 2 and 4 that, so far, our formal proofs have been of the
natural deduction style. Apart from the sequent calculus style of presenta-
tion, which will be introduced later, there is yet another style of presentation
of logics, known as the Hilbert-style. In fact, this is the traditional approach
to the deﬁnition of a formal proof. A Hilbert-style proof system consists of
a set of axioms and only a few proof rules.
Below we describe such a system for the implicational fragment of propo-
sitional intuitionistic logic. This system has only one proof rule, called modus
ponens, which is sometimes translated to English as “detachment rule”:
ϕ, ϕ →ψ
ψ
There will be two axiom schemes. That is, all formulas that ﬁt the patterns
below are considered axioms:
(A1) ϕ →ψ →ϕ;
(A2) (ϕ →ψ →ϑ) →(ϕ →ψ) →ϕ →ϑ.
Note that there are in fact inﬁnitely many axioms. But this does not bother
us as long as they can be eﬀectively described. Formal proofs in Hilbert-style
systems are traditionally deﬁned as sequences of formulas.
5.3.1. Definition. A formal proof of a formula ϕ from a set Γ of assump-
tions is a a ﬁnite sequence of formulas ψ1, ψ2, . . . , ψn, such that ψn = ϕ,
and for all i = 1, . . . , n, one of the following cases takes place:
• ψi is an axiom, or
• ψi is an element of Γ, or
• there are j, ℓ< i such that ψj = ψℓ→ψi (i.e., ψi is obtained from ψj,
ψℓusing modus ponens).
We write Γ ⊢H ϕ if such a proof exists. The notation ⊢H obeys the usual
conventions.
5.3.2. Example. Here is a proof of ϕ →ϕ from the empty set.
1. (ϕ →(ψ →ϕ) →ϕ) →((ϕ →(ψ →ϕ)) →(ϕ →ϕ))
(axiom A2);
2. ϕ →(ψ →ϕ) →ϕ
(axiom A1);
3. (ϕ →(ψ →ϕ)) →(ϕ →ϕ)
(modus ponens: detach 2 from 1);
4. ϕ →(ψ →ϕ)
(axiom A1);

82
Chapter 5. Proofs as combinators
5. ϕ →ϕ
(modus ponens: detach 4 from 3);
5.3.3. Example. And here is a proof of ϑ from {ϕ →ψ, ψ →ϑ, ϕ}:
1. ϕ →ψ
(assumption);
2. ϕ
(assumption);
3. ψ
(modus ponens: detach 2 from 1);
4. ψ →ϑ
(assumption);
5. ϑ
(modus ponens: detach 3 from 4).
The following important property of Hilbert-style proof systems is called
the Deduction Theorem.
5.3.4. Proposition (Herbrand, 1930). Γ, ϕ ⊢H ψ iﬀΓ ⊢H ϕ →ψ.
Proof. The proof from right to left requires one application of modus po-
nens and weakening. For the other direction, proceed by induction on the
size of the proof.
⊓⊔
Note how easy the proof of ϕ →ϕ becomes with the availability of the
deduction theorem, as compared to having to do the direct proof explicitly.
5.3.5. Proposition. For every Γ and ϕ: Γ ⊢N ϕ iﬀΓ ⊢H ϕ.
Proof. The right to left part is an easy induction. The converse is also
easy, using the Deduction Theorem.
⊓⊔
We conclude that our Hilbert-style system is complete in the sense of
both Heyting algebras and Kripke models.
5.3.6. Theorem. Γ |= ϕ iﬀΓ ⊢H ϕ.
Proof. Immediate from the completeness for natural deduction and the
previous proposition.
⊓⊔
5.3.7. Remark. By adding axioms to handle the other connectives, one can
obtain complete Hilbert-style proof systems for full propositional intuition-
istic logic and for classical propositional logic. It is perhaps interesting that
a complete proof systems for classical propositional calculus is obtained by
adding only the axiom schemes
• ⊥→ϕ;
• ((ϕ →ψ) →ϕ) →ϕ.

5.4. Relevance and linearity
83
(Recall that ∨and ∧can be deﬁned in classical logic by →and ⊥.)
The following is a version of the Curry-Howard Isomorphism for Hilbert-
style proof systems and combinatory logics.
We work with combinatory
terms `a la Church.
5.3.8. Proposition.
(i) If Γ ⊢C F : ϕ then |Γ| ⊢H ϕ.
(ii) If Γ ⊢H
ϕ then there exists F ∈C such that ∆⊢C
F : ϕ, where
∆= {(xϕ : ϕ) | ϕ ∈Γ}.
Proof. (i): by induction on the derivation of Γ ⊢C M : ϕ.
(ii): by induction on the derivation of Γ ⊢H ϕ.
⊓⊔
The Curry-Howard isomorphism in the case of Hilbert-style proofs and
combinatory terms is realized by a correspondence between proofs and and
Church-style combinatory terms. Here we have the following pairs of equiv-
alent notions:
application
modus ponens
variable
assumption
constants K and S
axioms
5.4. Relevance and linearity
Neither intuitionistic nor classical logic have any objections against the ax-
iom scheme ϕ →ψ →ϕ, which expresses the following rule of reasoning:
“an unnecessary assumption can be forgotten”. This rule is however du-
bious when we are interested in the relevance of assumptions with respect
to the conclusion. Logicians and philosophers have studied various variants
of intuitionistic logic in which restrictions are made concerning the manip-
ulation of assumptions. The classical references here are [1] and [2], but
the idea of relevant logics dates back to early 50’s. Hindley [54] attributes
the idea to Moh and Church. Just like no use of an assumptions may be
regarded as a dubious phenomenon, multiple use of an assumption may also
raise important doubts. The most ancient reference to a logic in which this
was taken into account, given by Hindley [54], is a work of Fitch from 1936.
With the Curry-Howard isomorphism at hand, we can easily identify
the corresponding fragments of (the implicational fragment of) intuitionis-
tic propositional logic, by characterizing lambda-terms with respect to the
number of occurrences of bound variables within their scopes.

84
Chapter 5. Proofs as combinators
5.4.1. Definition.
1. The set of λI-terms is deﬁned by the following induction:
• Every variable is a λI-term;
• An application MN is a λI-term iﬀboth M and N are λI-terms;
• An abstraction λx.M is a λI-term iﬀM is a λI-term and x ∈FV(M).
2. The set of BCK-terms is deﬁned as follows:
• Every variable is a BCK-term;
• An application MN is a BCK-term iﬀboth M and N are BCK-
terms, and FV (M) ∩FV(N) = {};
• An abstraction λx.M is a BCK-term iﬀM is a BCK-term.
3. A term is called linear iﬀit is both a λI-term and a BCK-term.
Of course, λI-terms correspond to reasoning where each assumption is used
at least once, but all assumptions are reusable. The BCK-terms represent
the idea of disposable assumptions that are thrown away after a use, so they
cannot be reused. A strict control over all assumptions, with each one being
used exactly once, is maintained in proofs corresponding to linear terms.
The three classes of lambda-terms determine three fragments of IPC(→):
Relevant logic
λI-terms
BCK-logic
BCK-terms
BCI-logic
linear terms
The above table can be taken as a formal deﬁnition of these three logics,
in that the λ-calculi simply are the logics. Below we give more traditional
Hilbert-style formulations of the logics.
5.4.2. Definition.
1. The relevant propositional calculus is a Hilbert-style proof system with
the modus ponens as the only rule, and the following axiom schemes:
AS) (ϕ →ψ →ϑ) →(ϕ →ψ) →ϕ →ϑ;
AB) (ψ →ϑ) →(ϕ →ψ) →ϕ →ϑ;
AC) (ϕ →ψ →ϑ) →ψ →ϕ →ϑ;
AI) ϕ →ϕ.

5.4. Relevance and linearity
85
2. The BCK propositional calculus is a Hilbert-style proof system with
the modus ponens as the only rule, and the axiom schemes (AB) and
(AC) and
AK) ϕ →ψ →ϕ.
3. The BCI propositional calculus is a Hilbert-style proof system with
the modus ponens as the only rule, and the axiom schemes (AB) and
(AC) and (AI).
5.4.3. Warning. The expression “linear logic” denotes a system which is a
strict extension of the BCI-logic. (But linear logic is based on the same
principle as BCI-logic: every assumption is used exactly once.)
Of course the axioms (AK) and (AS) are exactly our axioms (A1) and (A2)
of the full IPC(→). The other axioms can also be seen as types of combina-
tors (see Example 5.1.3). We have:
• B = λxyz.x(yz) : (ψ →ϑ) →(ϕ →ψ) →ϕ →ϑ;
• C = λxyz.xzy : (ϕ →ψ →ϑ) →ψ →ϕ →ϑ.
Clearly, our three logics correspond to fragments of C generated by the
appropriate choices of combinators.
This explains the abbreviations λI,
BCK and BCI. The full untyped lambda-calculus is sometimes called λK-
calculus.
We have still to justify that the above deﬁnitions are equivalent to those
obtained by appropriately restricting occurrences of variables in lambda-
terms. First we have the obvious part (remember that we identify combina-
tory terms with their translations via ( )Λ).
5.4.4. Lemma.
1. The combinators S, B, C, I are λI-terms, and so are all terms obtained
from S, B, C, I by applications;
2. The combinators B, C, K are BCK-terms, and so are all terms ob-
tained from B, C, K by applications;
3. The combinators B, C, I are BCI-terms, and so are all terms obtained
from B, C, I by applications.
Thus, the embedding ( )Λ translates the appropriate fragments of C into
the appropriate fragments of Λ. But the inverse translation ( )C cannot be
used anymore, as it requires S, and K to be available. We need ﬁrst to
redeﬁne the combinatory abstraction λ∗.

86
Chapter 5. Proofs as combinators
5.4.5. Definition.
1. For each term in C and each x ∈V we deﬁne the term λ◦x.M ∈C.
• λ◦x.x = I;
• λ◦x.F = KF, whenever x ̸∈FV(F);
• λ◦x.FG = S(λ◦x.F)(λ◦x.G), if x ∈FV(F) ∩FV(G);
• λ◦x.FG = C(λ◦x.F)G, if x ∈FV(F) and x ̸∈FV(G);
• λ◦x.FG = BF(λ◦x.G), if x ̸∈FV(F) and x ∈FV(G).
2. Now deﬁne a translation [ ]C : Λ →C, as follows:
• [x]C = x, for x ∈V ;
• [MN]C = [M]C[N]C;
• [λx.M]C = λ◦x.[M]C.
The translation [ ]C : Λ →C has all the good properties of ( )C. That is,
Propositions 5.1.10, 5.1.13 and 5.2.4 remain true. (For the proof note ﬁrst
that (λ◦x.F)Λ =β (λ∗x.F)Λ.) In addition we have:
5.4.6. Proposition.
1. If M is a λI-term, then [M]C is built solely from the combinators S,
B, C and I.
2. If M is a BCK-term then [M]C is built solely from the combinators
B, C and K.
3. If M is a linear term then [M]C is built solely from the combinators
B, C and I.
Proof. Easy. Uses the following property: FV ([M]C) = FV(M).
⊓⊔
It follows that the translation [ ]C can be seen as an embedding of each
of the appropriate fragments of C into the corresponding fragment of simply
typed lambda calculus. We can conclude with the following summary:
5.4.7. Theorem.
• A formula ϕ is a theorem of relevant logic if and only if it is a type of
a λI-term;
• A formula ϕ is a theorem of BCK-logic if and only if it is a type of a
BCK-term.
• A formula ϕ is a theorem of BCI-logic if and only if it is a type of a
linear term.
Proof. Immediate from Proposition 5.4.6, and the appropriate modiﬁca-
tions of Propositions 5.1.13 and 5.2.4.
⊓⊔

5.5. Historical remarks
87
5.5. Historical remarks
Combinatory logic was introduced by Curry in some early papers [21, 22, 23]
and is also studied at length in some newer books [24, 25], which are still
very readable.
Hilbert-style proofs are often used in text books on logic that are not
concerned with proof normalization in particular, or proof theory in gen-
eral. It is interesting to note that the deduction theorem, which provides
a translation from natural deduction proofs to Hilbert-style proofs, and the
abstraction operator, which provides a translation from typed combinatory
terms to typed λ-terms, were discovered independently in work on Hilbert
systems and work on combinatory logic, although they are essentially the
same result. This is just one example of a number of results that have been
discovered independently in work on logical systems and functional calculi.
Incidentally, the correspondence between β-equality and weak equality
is not as tight as one might hope for.
However, if one adds a certain—
somewhat involved—set of rules, called Aβ, to the rules for weak equality,
the resulting relation is equivalent to β-equality in the sense that the above
translations between Λ and C preserve equality and are each other’s inverses.
In particular, the extended equality on combinators is closed under rule (ξ).
The correspondence between β-equality and weak equality is more ele-
gant in the extensional versions of these calculi. More precisely, if one adds
the principle of extensionality
P x =β P ′ x & x ̸∈FV(P P ′) ⇒P =β P ′
(ext)β
to =β and the similar principle (ext)w to weak equality, then the resulting
calculi are equivalent in the above sense.
Adding rule (ext) to =β is equivalent to adding so-called η-equality (see
Chapter 6), and adding rule (ext) to =w is equivalent to adding a certain
set of equational axioms, called Aβη. More about all this can be found, e.g.,
in [7].
5.6. Exercises
5.6.1. Exercise. Find a combinator 2 ∈C such that 2FA →
→w F(FA), for
all F and A in C.
5.6.2. Exercise. Prove the Church-Rosser property for weak reduction us-
ing the Tait & Martin-L¨of method from Chapter 1. Note that the proof for
combinatory logic is somewhat simpler due to the fact that non-overlapping
redexes remain non-overlapping during reduction of other redexes.
5.6.3. Exercise. Prove Proposition 5.1.10.

88
Chapter 5. Proofs as combinators
5.6.4. Exercise. Prove Proposition 5.1.13.
5.6.5. Exercise. Give a Hilbert-style proof of the formula
(ϕ →ψ) →(ψ →ϑ) →ϕ →ϑ.
5.6.6. Exercise. Give a detailed proof of the Deduction Theorem. Use your
proof to give an abstraction operator, like λ∗.
5.6.7. Exercise. Describe a notion of reduction for Hilbert-style proofs,
corresponding to weak reduction on combinatory terms.
5.6.8. Exercise. Consider the following variant of the calculus of combina-
tors: there are typed constants Kσ,τ, and Sτ,τ,τ, with typing and reduction
rules as usual, and in addition, there are additional constants Iτ : τ →τ
with the reduction rule IτF →F. (The identity combinator cannot now be
deﬁned as SKK because not all typed forms of S are available.) By em-
bedding into Church-style combinatory logic, show that this variant satisﬁes
subject reduction and strong normalization properties.
5.6.9. Exercise. (Based on [16]) Consider the terms : K = λxy.x, S◦=
λixyz.i(i((x(iz))(i(y(iz))))) and I = λx.x. Show that these terms form a
basis for lambda-calculus in the sense of Corollary 5.1.14, but their types
(whatever choice is taken) do not make a complete Hilbert-style axiom sys-
tem for IPC(→).
Hint: One cannot derive the formula (p →p →q) →p →q.
5.6.10. Exercise. Adopt your solutions of Exercises 5.6.1 and 5.6.3 to the
case of the translation [ ]C of Section 5.4.

CHAPTER 6
Type-checking and related problems
In this chapter we discuss some decision problems related to simply-typed
lambda calculus and intuitionistic propositional logic. We are mostly inter-
ested in decision problems arising from the analysis of the ternary predicate
“Γ ⊢M : τ” in the Curry-style version of simply-typed lambda calculus.
But the following deﬁnition makes sense for every type-assignment system
deriving judgements of this form (including Church-style systems).
6.0.11. Definition.
1. The type checking problem is to decide whether Γ ⊢M : τ holds, for
a given context Γ, a term M and a type τ.
2. The type reconstruction problem, also called typability problem, is to
decide, for a given term M, whether there exist a context Γ and a
type τ, such that Γ ⊢M : τ holds, i.e., whether M is typable.
3. The type inhabitation problem, also called type emptiness problem, is
to decide, for a given type τ, whether there exists a closed term M,
such that ⊢M : τ holds. (Then we say that τ is non-empty and has
an inhabitant M).
An obvious motivation to consider type-checking and type reconstruction
problems comes of course from programming language design, especially
related to the language ML, see [72, 27].
But there were earlier results
concerning this problem, due to Curry, Morris and Hindley. See [54, pp.
33–34], for historical notes.
If we look at the type reconstruction problem from the point of view
of the Curry-Howard isomorphism, it becomes a problem of determining
whether a given “proof skeleton” can be actually turned into a correct proof
by inserting the missing formulas. It may be surprising that this kind of
questions are sometimes motivated by proof-theoretic research. As noted
89

90
Chapter 6. Type-checking and related problems
in [54, pp. 103–104], the main ideas of a type-reconstruction algorithm can
be traced as far as the 20’s.1 See [114], for a fresh work, where the “skeleton
instantiation” problem is discussed, without any relation to types.
For the type inhabitation problem, the Curry-Howard isomorphism gives
an immediate translation into the language of logic:
6.0.12. Proposition. The type inhabitation problem for the simply-typed
lambda calculus is recursively equivalent to the validity problem in the im-
plicational fragment of intuitionistic propositional logic.
Proof. Obvious.
⊓⊔
The above proposition remains true for other typed languages, for which the
Curry-Howard isomorphism makes sense.
From a programmer’s point of view, the type inhabitation problem can
be seen as follows: An empty type (a type which cannot be assigned to any
term) means a speciﬁcation that cannot be fulﬁlled by any program phrase.
Solving type inhabitation means (in the contexts of modular programming)
the ability to rule out such speciﬁcations at compile time.
6.1. Hard and complete
This short section is to recall a few basic notions from complexity theory.
The reader is referred to standard textbooks, like [57], for a more compre-
hensive discussion.
6.1.1. Definition. The notation LOGSPACE, PSPACE and P, refers re-
spectively to the classes of languages (decision problems) solvable by de-
terministic Turing Machines in logarithmic space, polynomial space, and
polynomial time (measured w.r.t. the input size).
6.1.2. Definition. We say that a language L1 is reducible to a language L2
in logarithmic space (or LOGSPACE-reducible) iﬀthere is a Turing Machine,
that works in logarithmic space (we count only the work tapes, not the input
or output tapes) and computes a total function f, such that
w ∈L1
iﬀ
f(w) ∈L2,
for all inputs w. Two languages are LOGSPACE-equivalent iﬀthere are
LOGSPACE-reductions each way.
That is, to decide if w ∈L1 one can ask if f(w) ∈L2, and the cost of the
translation is only shipping and handling. Note that a logarithmic space
reduction takes at most polynomial time, so this notion is slightly more
general than that of a polynomial time reduction.
1The good old Polish school again . . .

6.2. The 12 variants
91
6.1.3. Definition. We say that a language L is hard for a complexity class
C, iﬀevery language L′ ∈C is reducible to L in logarithmic space. If we
have L ∈C in addition, then we say that L is complete in the class C, or
simply C-complete.
6.2. The 12 variants
The type reconstruction problem is often abbreviated by “? ⊢M : ?”, and
the type inhabitation problem is written as “ ⊢M : ?”. This notation nat-
urally suggests other related problems, as one can choose to replace various
parts of our ternary predicate by question marks, and choose the context
to be empty or not. A little combinatorics shows that we have actually 12
problems. Out of these 12 problems, four are completely trivial, since the
answer is always “yes”:
•
? ⊢? : ?;
• Γ ⊢? : ?;
•
⊢? : ?;
•
? ⊢? : τ.
Thus we end up with eight non-trivial problems, as follows:
1) Γ ⊢M : τ
(type checking);
2)
⊢M : τ
(type checking for closed terms);
3)
? ⊢M : τ
(type checking without context);
4)
? ⊢M : ?
(type reconstruction);
5)
⊢M : ?
(type reconstruction for closed terms);
6) Γ ⊢M : ?
(type reconstruction in a context);
7)
⊢? : τ
(inhabitation);
8) Γ ⊢? : τ
(inhabitation in a context).
Most of these problems can easily be shown LOGSPACE-equivalent to one
of our three main problems: (1), (4) or (7). Some of these LOGSPACE
reductions are just inclusions. Indeed, problem (2) is a special case of (1)
and of (3), problem (5) is a special case of (4) and (6), and problem (7) is
a special case of (8). Others are the subject of Exercises 6.8.1 and 6.8.3.
An exception is problem (3). Problems (1), (2) and (4)–(6) reduce to (3) in
logarithmic space, but we do not know of any simple LOGSPACE reduction

92
Chapter 6. Type-checking and related problems
the other way.2 However, such reductions exists between all problems (1)–
(6), because all they turn out to be P-complete.
Let us make one more remark here: On a ﬁrst look it might seem that
determining whether a given term has a given type in a given environment
could be easier than determining whether it has any type at all. This impres-
sion however is generally wrong, as type reconstruction is easily reducible to
type checking, see Exercise 6.8.1. This reduction is “generic”, i.e., it works
for all reasonable typed calculi.
It is quite unlikely to have a reduction from (7) or (8) to any of (1)–(6),
because the inhabitation problems are PSPACE-complete, and that would
imply P = PSPACE. We do not know about a simple reduction the other
way.
6.3. (First-order) uniﬁcation
The following is a general deﬁnition of (ﬁrst-order) uniﬁcation.
In what
follows we will need only a special case, where the ﬁrst-order signature is
ﬁxed to consist of only one symbol: the binary function symbol “→”.
6.3.1. Definition.
1. A ﬁrst-order signature is a ﬁnite family of function, relation and con-
stant symbols. Each function and relation symbol comes with a des-
ignated non-zero arity. (Constants are sometimes treated as zero-ary
functions.) In this section we consider only algebraic signatures, i.e.,
signatures without relation symbols.
2. An algebraic term over a signature Σ, or just term is either a variable
or a constant in Σ, or an expression of the form (ft1 . . . tn), where f is
an n-ary function symbol, and t1, . . . , tn are algebraic terms over Σ.3
We usually omit outermost parentheses.
The formal deﬁnition of an algebraic term involves a preﬁx application of
function symbols. Of course, there is a tradition to write some binary func-
tion symbols in the inﬁx style, and we normally do it this way. Our most
beloved signature is one that has the (inﬁx) arrow as the only symbol. It is
not diﬃcult to see that algebraic terms over this signature can be identiﬁed
with simple types, or with implicational formulas if you prefer.
In general, algebraic terms over Σ can be identiﬁed with ﬁnite labelled
trees satisfying the following conditions:
• Leaves are labelled by variables and constant symbols;
2A solution was given by Henning Makholm, see Chapter 14, Exercise 6.8.3.
3Do not confuse algebraic terms with lambda-terms.

6.3. (First-order) uniﬁcation
93
• Internal nodes with n daughters are labelled by n-ary function sym-
bols.
6.3.2. Definition.
1. An equation is a pair of terms, written “t = u”. A system of equations
is a ﬁnite set of equations. Variables occurring in a system of equations
are called unknowns.
2. A substitution is a function from variables to terms which is the iden-
tity almost everywhere. Such a function S is extended to a function
from terms to terms by S(ft1 . . . tn) = fS(t1) · · · S(tn) and S(c) = c.4
3. A substitution S is a solution of an equation “t = u” iﬀS(t) = S(u)
(meaning that S(t) and S(u) is the same term). It is a solution of a
system E of equations iﬀit is a solution of all equations in E.
Thus, for instance, the equation f(gxy)x = fz(fyy) has a solution S with
S(x) = fyy, S(y) = y and S(z) = g(fyy)y (and many other solutions
too), while the equation f(gxy)c = fz(fyy), where c is a constant, has no
solution.
This is because no substitution can turn fyy into c.
Another
example with no solution is f(gxy)x = fx(fyy), but this time the reason is
diﬀerent: if S were a solution then S(x) would be a proper subterm of itself.
The problem of determining whether a given system of equations has a
solution is called the uniﬁcation problem. It is not diﬃcult to see that there
is no loss of generality in considering single equations rather than systems of
equations (Exercise 6.8.5). The uniﬁcation algorithm (we say “the”, because
all these algorithms are actually based on similar ideas, and diﬀer only in
details) is due to J.A. Robinson [93], and was motivated by the ﬁrst-order
resolution rule. But, as pointed out by Hindley [54, pp. 43–44], there were
also earlier works.
Discussions of uniﬁcation algorithms can be found in
various textbooks, for instance in [74].
We choose to sketch a version of the algorithm that is “algebraic” in
style. For this, we need the folllowing deﬁnition.
6.3.3. Definition.
1. A system of equations is in a solved form iﬀit has the following prop-
erties:
• All equations are of the form “x = t”, where x is a variable;
• A variable that occurs at a left-hand side of an equation does not
occur at the right-hand side of any equation;
• A variable may occur in only one left-hand side.
4Thus, a substitution is a valuation in the algebra of all terms over Σ.

94
Chapter 6. Type-checking and related problems
A variable not occurring as a left-hand side of any equation is called
undeﬁned.
2. A system of equations is inconsistent iﬀit contains an equation of
either of the forms:
• “gu1 . . . up = ft1 . . . tq”, where f and g are two diﬀerent function
symbols;
• “c = ft1 . . . tq”, or “ft1 . . . tq = c”, where c is a constant symbol
and f is an n-ary function symbol;
• “c = d”, where c and d are two diﬀerent constant symbols;
• “x = ft1 . . . tq”, where x is a variable, f is an n-ary function
symbol, and x occurs in one of t1, . . . , tq.
3. Two systems of equations are equivalent iﬀthey have the same solu-
tions.
It is easy to see that an inconsistent system has no solutions and that a
solved system E has a solution S0 deﬁned as follows:
• If a variable x is undeﬁned then S0(x) = x;
• If “x = t” is in E, then S0(x) = t.
The core of Robinson’s algorithm can be seen as follows:
6.3.4. Lemma. For every system E of equations, there is an equivalent sys-
tem E′ which is either inconsistent or in a solved form. In addition, the
system E′ can be obtained by performing a ﬁnite number of the following
operations:
a) Replace “x = t” and “x = s” (where t is not a variable) by “x = t”
and “t = s”;
b) Replace “t = x” by “x = t”;
c) Replace “ft1 . . . tn = fu1 . . . un” by “t1 = u1”, . . . , “tn = un”;
d) Replace “x = t” and “r = s” by “x = t” and “r[x := t] = s[x := t]”;
e) Remove an equation of the form “t = t”.
Proof. As long as our system is not solved, and not inconsistent, we can
always apply one of the operations (a)–(d). We leave it as Exercise 6.8.8
to show that this process terminates (unless (b) or (d) is used in a silly
way).
⊓⊔

6.4. Type reconstruction algorithm
95
6.3.5. Corollary. The uniﬁcation problem is decidable.
⊓⊔
In fact, the above algorithm can be optimized to work in polynomial time
(Exercise 6.8.10), provided we only need to check whether a solution exists,
and we do not need to write it down explicitly, cf.
Exercise 6.8.6.
The
following result is from Dwork et al [33].
6.3.6. Theorem. The uniﬁcation problem is P-complete with respect to Log-
space reductions.
⊓⊔
Suppose that we have a system of equations E, which is transformed to an
equivalent solved system E′. The solution S0 of E′ deﬁned as above, is a
most general solution of E′ and E, because every other solution must be a
specialization of S0. Formally we have the following deﬁnition.
6.3.7. Definition.
• If P and R are substitutions then P ◦R is a substitution deﬁned by
(P ◦R)(x) = P(R(x)).
• We say that a substitution S is an instance of another substitution R
(written R ≤S) iﬀS = P ◦R, for some substitution P.
• A solution R of a system E is principal iﬀthe following equivalence
holds for all substitutions S:
S is a solution of E
iﬀ
R ≤S.
6.3.8. Proposition. If a system of equations has a solution then it has a
principal one.
Proof. For a given system of equations E, let E′ be an equivalent system
in a solved form, and let S0 be as described above. Then S0 is a principal
solution of E.
⊓⊔
6.4. Type reconstruction algorithm
We now show how type-reconstruction can be reduced to uniﬁcation. This
is a LOGSPACE-reduction, and it can easily be modiﬁed to work for all the
problems (1)–(6) of Section 6.2. Since there is also a LOGSPACE-reduction
the other way, the main result of this section may be stated as:
6.4.1. Theorem. Type-reconstruction in simply-typed lambda calculus is P-
complete.

96
Chapter 6. Type-checking and related problems
The ﬁrst work where this result was explicitly stated was probably the M.Sc.
Thesis of Jurek Tyszkiewicz [110]. Our proof of the theorem consists of two
reductions. The ﬁrst one is from type-reconstruction to uniﬁcation.
Let M be a lambda-term.
Choose a representative of M so that no
bound variable occurs free in M and no bound variable is bound twice. In
what follows we work with this representative rather than with M as an
equivalence class. By induction on the construction of M, we deﬁne:
• a system of equations EM (over the signature consisting only of the
binary function symbol →);
• a type τM.
Of course, the idea is as follows: EM will have a solution iﬀM is typable,
and τM is (informally) a pattern of a type for M.
6.4.2. Definition.
• If M is a variable x, then EM = {} and τM = αx, where αx is a fresh
type variable.
• If M is an application PQ then τM = α, where α is a fresh type
variable, and EM = EP ∪EQ ∪{τP = τQ →α}.
• If M is an abstraction λx.P, then EM = EP and τM = αx →τP .
It is not diﬃcult to see that the above construction can be done in logarith-
mic space. The main property of our translation is as follows.
6.4.3. Lemma.
1. If Γ ⊢M : ρ, then there exists a solution S of EM, such that ρ =
S(τM) and S(αx) = Γ(x), for all variables x ∈FV (M).
2. Let S be a solution of EM, and let Γ be such that Γ(x) = S(αx), for
all x ∈FV (M). Then Γ ⊢M : S(τM).
Proof. Induction with respect to M.
⊓⊔
It follows that M is typable iﬀEM has a solution. But EM has then a
principal solution, and this has the folllowing consequence. (Here, S(Γ) is a
context such that S(Γ)(x) = S(Γ(x)).)
6.4.4. Definition. A pair (Γ, τ), consisting of a context (such that the do-
main of Γ is FV (M)) and a type, is called the principal pair for a term M
iﬀthe following holds:

6.5. Eta-reductions
97
• Γ ⊢M : τ;
• If Γ′ ⊢M : τ ′ then Γ′ ⊇S(Γ) and τ ′ = S(τ), for some substitution S.
(Note that the ﬁrst condition implies S(Γ) ⊢M : S(τ), for all S.) If M is
closed (in which case Γ is empty), we say that τ is the principal type of M.
6.4.5. Corollary. If a term M is typable, then there exists a principal pair
for M. This principal pair is unique up to renaming of type variables.
Proof. Immediate from Proposition 6.3.8.
⊓⊔
6.4.6. Example.
• The principal type of S is (α →β →γ) →(α →β) →α →γ. The
type (α →β →α) →(α →β) →α →α can also be assigned to S,
but it is not principal.
• The principal type of all the Church numerals is (α →α) →α →α.
But the type ((α →β) →α →β) →(α →β) →α →β can also be
assigned to each numeral.
To complete the proof of Theorem 6.4.1, we should also give the other re-
duction. We only give a brief hint of how this should be done. First we
reduce the general case of uniﬁcation to our special arrow-only case (Exer-
cise 6.8.7) and one equation only (Exercise 6.8.5). Then, for a given equation
“τ = σ”, we consider the term λxy.x(ytτ)(ytσ), where x, y are new variables
and terms tτ and tσ are as in Exercise 6.8.2.
6.5. Eta-reductions
We cannot hide this from the reader any more—we ﬁnally have to con-
fess that other notions of reduction than beta-reduction are considered in
lambda-calculi. In particular, we have eta-reduction, based on the following
principle:
λx.Mx →η M,
whenever x ̸∈FV (M).
Formally, we have the following deﬁnition:
6.5.1. Definition. We deﬁne the relation →η as the least relation satisfying
• If x ̸∈FV (M) then λx.Mx →η M;
• If P →η P ′ then λx.P →η λx.P ′;
• If P →η P ′ then PQ →η P ′Q and QP →η QP ′.
The notation →
→η and =η has the expected meaning. We also use the symbols
→βη, →
→βη, =βη to refer to reductions combining β- and η-reductions.

98
Chapter 6. Type-checking and related problems
The motivation for this notion of reduction (and equality) is as follows: Two
functions should be considered equal if and only if they return equal results
for equal arguments. Indeed, we have
6.5.2. Proposition. Let =ext be the least equivalence relation such that:
• If M =β N then M =ext N;
• If Mx =ext Nx, and x ̸∈FV (M) ∪FV (M) then M =ext N;
• If P =ext P ′ then PQ =ext P ′Q and QP =ext QP ′.
Then =ext is identical to =βη.
Proof. Exercise 6.8.15. Note that the above deﬁnition does not contain
the condition “If P =ext P ′ then λx.P =ext λx.P ′”. This is not a mistake,
because this property (called “rule ξ”) follows from the others.
⊓⊔
We do not take →η as our standard notion of reduction, because we do
not want our calculus of functions to be extensional. After all, we want to
be able to distinguish between two algorithms, even if their input-output
behaviour is the same.
The notions of eta- and beta-eta-reduction and equality have most of the
good properties of beta-reduction and equality. In particular, the Church-
Rosser theorem remains true, leftmost reductions are normalizing,5 and on
the typed level we still have both subject reduction and strong normalization
properties.
(Note that strong normalization for eta alone is immediate,
as each eta-reduction step reduces the length of a term.) Of course, eta-
reduction makes sense also for the Church-style typed terms.
6.5.3. Definition. We now deﬁne the notion of a Church-style term in an
η-long normal form (or just long normal form). Recall that we write Mσ
as an informal way of saying that the Church-style term M has type σ in
some ﬁxed context. The deﬁnition is by induction:
• If x is a variable of type τ1 →· · · →τn →α, and Mτ1
1 , . . . , Mτn
n
are
in η-long normal form, then (xM1 . . . Mn)α is in η-long normal form.
• If Mσ is in η-long normal form then (λx : τ.M)τ→σ is in η-long normal
form.
Thus a term in a long normal form is a term in normal form where all
function variables are “fully applied” to arguments.
6.5.4. Lemma. For every Church-style term Mσ in beta normal form there
exists a term Mσ
1 in η-long normal form, such that Mσ
1 →
→η M.
Proof. Easy.
⊓⊔
5But the proof is somewhat more involved than for beta-reduction.

6.6. Type inhabitation
99
6.6. Type inhabitation
In this section we prove a result of Statman [103], that the inhabitation
problem for the ﬁnitely-typed lambda calculus is PSPACE-complete.
In
particular it is decidable.
An immediate consequence is that provability
in IPC(→) is also decidable and PSPACE-complete. The decidability was
already known to to Gentzen in 1935, and we will discuss his (syntactic)
proof in the next chapter. There are also semantic methods based on the
existence of ﬁnite models.
First observe that a type is inhabited if and only if there exists a closed
Church-style term of that type. Thus it suﬃces to consider Church-style
terms. First we prove that our problem is in PSPACE.
6.6.1. Lemma. There is an alternating polynomial time algorithm (and thus
also a deterministic polynomial space algorithm) to determine whether a
given type τ is inhabited in a given context Γ.
Proof. If a type is inhabited then, by Lemma 6.5.4, it is inhabited by a
term in a long normal form. To determine whether there exists a term M
in a long normal form, satisfying Γ ⊢M : τ, we proceed as follows:
• If τ = τ1 →τ2, then M must be an abstraction, M = λx:τ1.M′. Thus,
we look for an M′ satisfying Γ, x:τ1 ⊢M′ : τ2.
• If τ is a type variable, then M is an application of a variable to a
sequence of terms. We nondeterministically choose a variable z, de-
clared in Γ to be of type τ1 →· · · →τn →τ. (If there is no such
variable, we reject.) If n = 0 then we accept. If n > 0, we answer in
parallel the questions if τi are inhabited in Γ.
This alternating (or recursive) procedure is repeated as long as there are
new questions of the form Γ ⊢? : τ. Note that if there are two variables
in Γ, say x and y, declared to be of the same type σ, then each term M
can be replaced with M[x/y] with no change of type. This means that a
type τ is inhabited in Γ iﬀit is inhabited in Γ −{y : σ}, and it suﬃces to
consider contexts with all declared types being diﬀerent. At each step of
our procedure, the context Γ either stays the same or it expands. Thus the
number of steps (depth of recursion) does not exceed the squared number of
subformulas of types in Γ, τ, where Γ ⊢? : τ is the initially posed question.
⊓⊔
To show PSPACE-hardness, we deﬁne a reduction from the satisﬁability
problem for classical second-order propositional formulas (QBF). We refer
the reader to [57] for details about this problem. (But do not use the Polish
translation.)

100
Chapter 6. Type-checking and related problems
Assume that a second-order propositional formula Φ is given. Without
loss of generality we may assume that the negation symbol ¬ does not occur
in Φ, except in the context ¬p, where p is a propositional variable.
Assume that all bound variables of Φ are diﬀerent and that no variable
occurs both free and bound. For each propositional variable p, occurring
in Φ (free or bound), let αp and α¬p be fresh type variables. Also, for each
subformula ϕ of Φ, let αϕ be a fresh type variable. We construct a basis ΓΦ
from the following types:
• (αp →αψ) →(α¬p →αψ) →αϕ, for each subformula ϕ of the
form ∀pψ;
• (αp →αψ) →αϕ and (α¬p →αψ) →αϕ, for each subformula ϕ of the
form ∃pψ;
• αψ →αϑ →αϕ, for each subformula ϕ of the form ψ ∧ϑ;
• αψ →αϕ and αϑ →αϕ, for each subformula ϕ of the form ψ ∨ϑ.
If v is a zero-one valuation of propositional variables, then Γv is Γ extended
with the type variables
• αp, when v(p) = 1;
• α¬p, when v(p) = 0.
The following lemma is proven by a routine induction w.r.t. the length of
formulas. Details are left to the reader.
6.6.2. Lemma. For every subformula ϕ of Φ, and every valuation v, deﬁned
on the free variables of ϕ, the type αϕ is inhabited in Γv iﬀv(ϕ) = 1.
Proof. Exercise 6.8.18.
⊓⊔
From Lemma 6.6.2 we obtain PSPACE-hardness, since the reduction can be
performed in logarithmic space. This, together with Lemma 6.6.1 implies
the main result of this section.
6.6.3. Theorem. The inhabitation problem for simply-typed lambda-calculus
is complete for polynomial space.
⊓⊔

6.7. Equality of typed terms
101
6.7. Equality of typed terms
As we have already observed, to verify whether two typable lambda-terms
are beta-equal or not, it suﬃces to reduce them to normal form. One thing
that often is overlooked here is that the complexity of this decision procedure
depends on the size of particular type derivations (or Church-style terms)
and not directly on the size of the pure lambda-terms to be veriﬁed. In the
case of simply-typed lambda calculus, the cost of type-reconstruction is is a
minor fraction of the total cost, even if we insist on the possibly exponential
types to be written down. Indeed, we have the following theorem of Statman:
6.7.1. Theorem (R. Statman). The problem to decide whether two given
Church-style terms M and N of a given type τ are beta-equal is of non-
elementary complexity.
That is, for each r, the decision procedure takes
more than expr(n) steps on inputs of size n. (Recall that exp0(n) = n and
expk+1(n) = 2expk(n).)
The simplest known proof of this result is by H. Mairson [68]. This proof,
like the original proof of Statman, uses validity for a simple higher-order
logic as an intermediate step. It might be interesting to have a direct coding
of Turing Machines into lambda-terms.
6.8. Exercises
6.8.1. Exercise. Show that:
a) problem (4) reduces to problem (5);
b) problem (5) reduces to problem (1);
c) problem (1) reduces to problem (2);
d) problem (8) reduces to problem (7)
in logarithmic space.
6.8.2. Exercise. Assume a context Γ consisting of type assumptions of the
form (xα : α). Deﬁne terms tτ such that Γ ⊢tτ : σ holds if and only if
τ = σ.
6.8.3. Exercise. Show that problem (6) reduces to problem (4) in logarith-
mic space. Hint: ﬁrst do Exercise 6.8.2.
6.8.4. Exercise. What’s wrong with the following reduction of problem (3)
to problem (4)? To answer ? ⊢M : τ ask ? ⊢λyz.y(zM)(ztτ) : ?.

102
Chapter 6. Type-checking and related problems
6.8.5. Exercise. Show that for every system of equations there is an equiv-
alent single equation.
6.8.6. Exercise. Show that the size of a shortest possible solution of a
given system of equations may be exponential in the size of that system.
(Construct systems of equations of size O(n), such that all their solutions
are of size at least exponential in n.) Can a solution be always represented
in polynomial space?
6.8.7. Exercise. Prove that the general form of the uniﬁcation problem
reduces in logarithmic space to uniﬁcation over the signature consisting only
of an arrow.
6.8.8. Exercise. Complete the proof of Lemma 6.3.4.
6.8.9. Exercise. Show examples of loops in the uniﬁcation algorithm that
may be caused by using rule (d) in a silly way, or removing the restriction
in rule (a) that t is not a variable.
6.8.10. Exercise. Design a polynomial time algorithm to decide whether a
given equation has a solution.
6.8.11. Exercise. Modify the algorithm of Section 6.4 to obtain an algo-
rithm for problem (3).
6.8.12. Exercise. Prove the following converse principal type theorem: If
ϕ is a non-empty type, then there exists a closed term M such that ϕ is the
principal type of M. Hint: Use the technique of Exercise 6.8.2. (In fact, if
N is a closed term of type τ, then we can require M to be beta-reducible
to N.)
6.8.13. Exercise. Show that every principal pair of a BCK-term in normal
form has the following properties:
• Each type variable occurs at most twice;
• If it does, then one occurrence is positive (to the left of an even number
of arrows) and the other negative.
Also show that if (Γ, τ) is a principal pair of a BCK-term M in normal form
then M is an erasure of a Church style term in long normal form that has
the type τ in Γ.
6.8.14. Exercise. (S. Hirokawa [56])
Prove that for a given pair (Γ, τ), there is at most one BCK-term M in
normal form such that (Γ, τ) is its principal pair.

6.8. Exercises
103
6.8.15. Exercise. Prove Proposition 6.5.2.
6.8.16. Exercise. What is the natural deduction counterpart of eta-reduction?
6.8.17. Exercise. Show examples of types that have exactly n normal in-
habitants, for any number n ∈N ∪{ℵ0}.
6.8.18. Exercise. Prove Lemma 6.6.2
6.8.19. Exercise. (C.-B. Ben-Yelles)
Show that it is decidable whether a type has a ﬁnite or an inﬁnite number
of diﬀerent normal inhabitants.
6.8.20. Exercise. Let ϕ = τ1 →· · · →τn →α and let α be the only type
variable occurring in ϕ. Prove (by induction) that ϕ is an inhabited type if
and only if at least one of the τi’s is not inhabited.
6.8.21. Exercise. (R. Statman)
Let p be the only propositional variable, and let →be the only connective
occurring in a classical propositional tautology ϕ. Show that ϕ is intuition-
istically valid. Hint: First do Exercise 6.8.20.
6.8.22. Exercise. (T. Prucnal, W. Dekkers [30]) A proof rule of the form
τ1, . . . , τn
τ
is sound for IPC(→) iﬀfor every substitution S with S(τ1), . . . S(τn) all
valid, also S(τ) must be valid. Prove that if such a rule is sound then the
implication τ1 →· · · →τn →τ is valid.

104
Chapter 6. Type-checking and related problems

CHAPTER 7
Sequent calculus
We have seen two diﬀerent formalisms for presenting systems of formal logic:
natural deduction and Hilbert-style. Each of these has its advantages. For
instance, in Hilbert-style proofs, there are no problems pertaining to the
management of assumptions, whereas in natural deduction, the proofs are
easier to discover, informally speaking.
As we have seen earlier, both classical and intuitionistic propositional
calculus are decidable; that is, there is an algorithm which decides, for any ϕ,
whether or not ϕ is classically valid (according to the truth table semantics),
and similarly, there is an algorithm which decides, for any ϕ, whether or not
ϕ is intuitionistically valid (according to the Heyting algebra semantics or
Kripke models).
By the soundness and completeness results, this result
means that there are algorithms that decide, for any ϕ, whether or not ϕ
is provable in our proof systems for classical and intuitionistic propositional
calculus, respectively.
This result suggests that we should be able to develop decision algorithms
that do not make an excursion via semantics; that is, we should be able to
read the inference rules bottom-up and turn this reading into algorithms
that decide whether formulas have proofs in the systems.
Anyone who has tried at least once to write down an actual Hilbert-style
proof for even a simple formula will understand why this approach is not
satisfactory in practice. If we want to prove a formula ψ, using the modus
ponens rule
ϕ, ϕ →ψ
ψ
the formula ϕ has to be somehow chosen or guessed. And there is no bound
for the space we make this choice from: the formula ϕ can be anything at
all. Any approach to automatic theorem proving based on this rule seems
doomed to failure.
The same problem appears in natural deduction proofs, since we also
have the modus ponens rule there. (In addition, we have another unpleasant
105

106
Chapter 7. Sequent calculus
property in the Hilbert-style system: formulas occurring in proofs are very
long, so even if we know what to choose, such proofs are still inconvenient.)
In this chapter we introduce a third kind of formalism, known as sequent
calculus, for presenting systems of formal logic. Sequent calculus was intro-
duced in the 1930’s, by Gerhard Gentzen [39], who also introduced natural
deduction.1
Despite similar syntax, sequent calculus and natural deduction are quite
diﬀerent and serve diﬀerent purposes. While natural deduction highlights
the most fundamental properties of connectives by its introduction and elim-
ination rule for each connective, sequent calculus is more “practically” ori-
ented: if one reads the rules of sequent calculus from bottom to top, the rules
simplify the process of proof construction. Instead of introduction and elimi-
nation rules, there are only introduction rules. Some of these rules introduce
connectives in the conclusion parts of judgements—in fact, these rules are
identical to the introduction rules from natural deduction. But there are
also rules introducing connectives in the assumption parts of judgements.
These rules replace the elimination rules of natural deduction.
The development of sequent calculus systems has been successful not
only for theoretical purposes: many practical approaches to automated the-
orem proving are based on some form of sequent calculi or their relatives.
In particular, the resolution rule can be seen as such a relative.
7.1. Classical sequent calculus
Although we are now mostly concerned with intuitionistic proof systems, we
introduce a classical version of sequent calculus ﬁrst. Intuitionistic sequent
calculus is obtained from the classical one by a restriction which sheds some
light on the relationship between these two equally fundamental logics.
As mentioned below, many variations on the deﬁnition of sequent calcu-
lus systems are possible; we use the systems studied by Prawitz [85, App. A],
since these minimize the noise in the relationship with natural deduction.
A number of variants can be found in, e.g., [109] and [38].
7.1.1. Definition. A (classical) sequent is a pair of sets of formulas, written
Γ ⊢Σ, where the right-hand side is not empty.2 A proof in the sequent
calculus is a tree labelled with sequents in such a way that mothers and
daughters match the proof rules below.
We write Γ ⊢+
LC Σ iﬀΓ ⊢Σ has a proof, and we write Γ ⊢LC Σ iﬀΓ ⊢Σ
has a proof which does not use the rule Cut.
1StanisÃlaw
Ja´skowski
independently
introduced
natural
deduction
systems—see
Prawitz’ book [85], where more information about the origins of natural deduction and
sequent calculus systems can be found.
2Sequents with empty right-hand sides are permitted in many presentations.
The
meaning of an empty right-hand side is the same as of a right-hand side consisting only
of ⊥, so our restriction is not essential.

7.1. Classical sequent calculus
107
We use similar conventions as in the case of natural deduction.
For
instance, we write Γ, ∆for Γ ∪∆, and ϕ for {ϕ}.
Axiom:
Γ, ϕ ⊢ϕ, ∆
Rules:
Γ, ϕ ⊢Σ
Γ, ϕ ∧ψ ⊢Σ
(L∧)
Γ, ψ ⊢Σ
Γ, ϕ ∧ψ ⊢Σ
Γ ⊢ϕ, ∆
Γ ⊢ψ, ∆
Γ ⊢ϕ ∧ψ, ∆
(R∧)
Γ, ϕ ⊢Σ
Γ, ψ ⊢Σ
Γ, ϕ ∨ψ ⊢Σ
(L∨)
Γ ⊢ϕ, ∆
Γ ⊢ϕ ∨ψ, ∆
(R∨)
Γ ⊢ψ, ∆
Γ ⊢ϕ ∨ψ, ∆
Γ ⊢ϕ, ∆
Γ, ψ ⊢Σ
Γ, ϕ →ψ ⊢∆∪Σ
(L→)
Γ, ϕ ⊢ψ, ∆
Γ ⊢ϕ →ψ, ∆
(R→)
Γ, ⊥⊢Σ
(L⊥)
Γ ⊢ϕ, ∆
Γ, ϕ ⊢Σ
Γ ⊢∆∪Σ
(Cut)
The rule (L⊥) has no premise and may be regarded as an axiom. The
remaining rules, except the cut rule, are called logical rules since they deﬁne
the meaning of the logical connectives ∧, ∨, and →. The logical rules consists
of left and right introduction rules for every connective. The right rules are
identical to the introduction rules from natural deduction; the left rules will
play the role of the elimination rules from natural deduction.
The cut rule is the only one that is neither a left nor a right rule. The
formula ϕ in the cut rule is called the cut formula. One can recognize a
similarity between cut and modus ponens.
The intuitive meaning of Γ ⊢Σ is that the assumptions in Γ imply one
of the conclusions in Σ, i.e., that ϕ1 ∧. . . ∧ϕn implies ψ1 ∨. . . ∨ψm, where
Γ = {ϕ1, . . . , ϕn} and Σ = {ψ1, . . . , ψm}. The rules for conjunction and
disjunction clearly reﬂect this idea.

108
Chapter 7. Sequent calculus
7.1.2. Remark. In order to facilitate comparison with natural deduction
we have taken ⊥as primitive—as we have seen earlier, negation can then
be deﬁned by ¬ϕ = ϕ →⊥. One often ﬁnds in the literature ¬ taken as
primitive instead. In this case, the rule (L⊥) is replaced by the two rules
Γ ⊢∆, ϕ
Γ, ¬ϕ ⊢∆
(L¬)
Γ, ϕ ⊢Σ
Γ ⊢¬ϕ, Σ
(R¬)
which are derived rules in the above system.
7.1.3. Warning. In many presentations of sequent calculus, sequents are
pairs of sequences (with possible repetitions) rather than sets. In such sys-
tems one must in addition to the axiom, the cut rule, and the logical rules,
adopt so-called structural rules, namely weakening rules that allow addition
of formulas to the left and right of ⊢, contraction rules that allow contraction
of two identical formulas into one on the left and right of ⊢, and exchange
rules that allow changing the order of two consecutive formulas on the left
or on the right of ⊢. In this case one takes the axiom in the form ϕ ⊢ϕ.
Such a system occurs, e.g., in [46].
One may also use multi-sets instead of sets and sequences. In this case,
the exchange rules are not needed.
7.1.4. Remark. It is not diﬃcult to see that in the presence of weakening,
the rules (Cut) and (L→) could as well be written as follows:
Γ ⊢ϕ, ∆
Γ, ϕ ⊢∆
Γ ⊢∆
(Cut)
Γ ⊢ϕ, Σ
Γ, ψ ⊢Σ
Γ, ϕ →ψ ⊢Σ
(L →)
We prefer the other presentation of these rules for uniformity with the intu-
itionistic fragment, to be deﬁned in the next section.
The following shows that sequent calculus is complete with respect to
the ordinary semantics of classical logic.
7.1.5. Proposition. If Σ = {ϕ1, . . . ϕn} then we have Γ ⊢+
LC Σ if and only
if the entailment Γ |= ϕ1 ∨· · ·∨ϕn is classically valid.3 In particular, ⊢+
LC Σ
iﬀϕ1 ∨· · · ∨ϕn is a classical tautology.
The proof is omitted. Gentzen [39] proved the completeness of the se-
quent calculus system by proving that the system is equivalent to another
logical system. For the purposes of that proof, the cut rule is very conve-
nient. Gentzen’s Hauptsatz then states that the cut rule is a derived rule,
and hence the cut rule is in fact not necessary for completeness; that is,
every application of the cut rule can be eliminated from a given proof. This
results is also known as the Cut Elimination Theorem. We shall have more
to say about this result in the context of intuitionistic logic below.
3That is, iﬀeach valuation satisfying all the formulas in Γ must also satisfy ϕ1∨· · ·∨ϕn.

7.2. Intuitionistic sequent calculus
109
7.1.6. Example. Here is a sequent calculus proof of Peirce’s law:
(R →)
(L →)
(R →)
p ⊢p, q
⊢p, p →q
p ⊢p
(p →q) →p ⊢p
⊢((p →q) →p) →p
Note that we sometimes have two formulas at the right-hand side.
7.1.7. Example. And here is another example that uses only sequents with
one-element right-hand sides:
(L →)
p, p →q ⊢p
(L→)p ⊢p
p, q ⊢q
p, p →q ⊢q
p, p →q, r ⊢r
p, p →q, q →r ⊢r
(L →)
(R →)
p, p →q, p →q →r ⊢r
(R →)
p →q, p →q →r ⊢p →r
(R →)
p →q →r ⊢(p →q) →p →r
⊢(p →q →r) →(p →q) →p →r
7.2. Intuitionistic sequent calculus
The intuitionistic sequent calculus is obtained from the classical system by
a simple syntactic restriction. We just require that only one formula occurs
at the right-hand side of a sequent. That is, the above classical rules are
modiﬁed so that
• Σ has always exactly one element;
• ∆is always empty.
7.2.1. Definition. An intuitionistic sequent is one of the form Γ ⊢ϕ,
where ϕ is a single formula.
We write Γ ⊢+
L ϕ iﬀΓ ⊢ϕ has a sequent
calculus proof using only intuitionistic sequents, i.e., using only the below
rules. We write Γ ⊢L ϕ if there is such a proof that does not use the rule Cut.

110
Chapter 7. Sequent calculus
Axiom:
Γ, ϕ ⊢ϕ
Rules:
Γ, ϕ ⊢σ
Γ, ϕ ∧ψ ⊢σ
(L∧)
Γ, ψ ⊢σ
Γ, ϕ ∧ψ ⊢σ
Γ ⊢ϕ
Γ ⊢ψ
Γ ⊢ϕ ∧ψ
(R∧)
Γ, ϕ ⊢σ
Γ, ψ ⊢σ
Γ, ϕ ∨ψ ⊢σ
(L∨)
Γ ⊢ϕ
Γ ⊢ϕ ∨ψ
(R∨)
Γ ⊢ψ
Γ ⊢ϕ ∨ψ
Γ ⊢ϕ
Γ, ψ ⊢σ
Γ, ϕ →ψ ⊢σ
(L→)
Γ, ϕ ⊢ψ
Γ ⊢ϕ →ψ
(R→)
Γ, ⊥⊢σ
(L⊥)
Γ ⊢ϕ
Γ, ϕ ⊢σ
Γ ⊢σ
(Cut)
The following shows that intuitionistic natural deduction and intuition-
istic sequent calculus are equivalent.
7.2.2. Proposition. Γ ⊢+
L ϕ iﬀΓ ⊢N ϕ.
Proof. We prove each direction by induction on the derivation of the se-
quent.
For the left-to-right direction, the main problem is how to express the
left rules of sequent calculus in terms of the elimination rules of natural
deduction, and how to express the cut rule in terms of modus ponens.
1. The derivation of Γ ⊢+
L ϕ is
Γ′, ϕ ⊢ϕ
Then
Γ′, ϕ ⊢ϕ
is also a derivation of Γ ⊢N ϕ.

7.2. Intuitionistic sequent calculus
111
2. The derivation of Γ ⊢+
L ϕ ends in
Γ′, ψ1 ⊢ϕ
Γ′, ψ1 ∧ψ2 ⊢ϕ
By the induction hypothesis we have a natural deduction derivation of
Γ′, ψ1 ⊢ϕ. By Lemma 2.6, Γ′, ψ1∧ψ2, ψ1 ⊢ϕ, so Γ′, ψ1∧ψ2 ⊢ψ1 →ϕ.
Since also Γ′, ψ1 ∧ψ2 ⊢ψ1 ∧ψ2, and hence Γ′, ψ1 ∧ψ2 ⊢ψ1, we get
Γ′, ψ1 ∧ψ2 ⊢ϕ, by modus ponens. Thus Γ ⊢N ϕ.
3. The derivation of Γ ⊢+
L ϕ ends in
Γ′, ψ1 ⊢ϕ
Γ′, ψ2 ⊢ϕ
Γ′, ψ1 ∨ψ2 ⊢ϕ
By the induction hypothesis we have derivations in natural deduction
of Γ′, ψ1 ⊢ϕ and Γ′, ψ2 ⊢ϕ. By Lemma 2.6, Γ′, ψ1, ψ1 ∨ψ2 ⊢ϕ
and Γ′, ψ2, ψ1 ∨ψ2 ⊢ϕ. Since also Γ′, ψ1 ∨ψ2 ⊢ψ1 ∨ψ2, we get
Γ′, ψ1 ∨ψ2 ⊢ϕ. Thus Γ ⊢N ϕ.
4. The derivation of Γ ⊢+
L ϕ ends in
Γ′ ⊢ψ1
Γ′, ψ2 ⊢ϕ
Γ′, ψ1 →ψ2 ⊢ϕ
By the induction hypothesis we have derivations in natural deduction
Γ′ ⊢ψ1 and Γ′, ψ2 ⊢ϕ. By Lemma 2.6, Γ′, ψ1 →ψ2 ⊢ψ1 and
Γ′, ψ1 →ψ2, ψ2
⊢
ϕ.
As before, Γ′, ψ1 →ψ2
⊢
ψ1 →ψ2, so
Γ′, ψ1 →ψ2 ⊢ψ2. Also Γ′, ψ1 →ψ2 ⊢ψ2 →ϕ, so Γ′, ψ1 →ψ2 ⊢ϕ.
Thus Γ ⊢N ϕ.
5. The derivation of Γ ⊢+
L ϕ is
Γ′, ⊥⊢ϕ
Then
Γ′, ⊥⊢⊥
Γ′, ⊥⊢ϕ
is a derivation of Γ ⊢N ϕ.
6. The derivation of Γ ⊢+
L ϕ ends in
Γ ⊢ψ
Γ, ψ ⊢ϕ
Γ ⊢ϕ
By the induction hypothesis we have derivations in natural deduction
of Γ ⊢ψ and Γ, ψ ⊢ϕ. Then Γ ⊢ψ →ϕ, and then Γ ⊢ϕ. Thus
Γ ⊢N ϕ.

112
Chapter 7. Sequent calculus
The remaining cases—the right rules—are trivial.
For the right-to-left direction the problem is to express the elimination
rules of natural deduction in terms of the left rules of sequent calculus; the
cut rule turns out to be useful for this.
As above the cases where the derivation consists of a use of the axiom
or ends in an introduction rule are trivial.
1. The derivation of Γ ⊢N ϕ ends in
Γ ⊢ϕ ∧ψ
Γ ⊢ϕ
By the induction hypothesis we have a sequent calculus derivation of
Γ ⊢ϕ ∧ψ. By the axiom and the left rule for ∧we get Γ, ϕ ∧ψ ⊢ϕ.
Then by the cut rule Γ ⊢ϕ. Thus Γ ⊢+
L ϕ.
2. The derivation of Γ ⊢N ϕ ends in
Γ, ψ1 ⊢ϕ
Γ, ψ2 ⊢ϕ
Γ ⊢ψ1 ∨ψ2
Γ ⊢ϕ
By the induction hypothesis we have sequent calculus derivations of
Γ, ψ1 ⊢ϕ, of Γ, ψ2 ⊢ϕ, and of Γ ⊢ψ1 ∨ψ2. By the left rule for ∨
we get Γ, ψ1 ∨ψ2 ⊢ϕ. Then by the cut rule Γ ⊢ϕ. Thus Γ ⊢+
L ϕ.
3. The derivation of Γ ⊢N ϕ ends in
Γ ⊢ψ →ϕ
Γ ⊢ψ
Γ ⊢ϕ
By the induction hypothesis we have sequent calculus derivations of
Γ ⊢ψ →ϕ and Γ ⊢ψ. By the axiom Γ, ϕ ⊢ϕ, so by the left rule
for →we have that Γ, ψ →ϕ ⊢ϕ. Then by the cut rule Γ ⊢ϕ. Thus
Γ ⊢+
L ϕ.
4. The derivation of Γ ⊢N ϕ ends in
Γ ⊢⊥
Γ ⊢ϕ
By the induction hypothesis we have a sequent calculus derivation of
Γ ⊢⊥. By the left rule for ⊥we have Γ, ⊥⊢ϕ. Then by the cut
rule Γ ⊢ϕ. Thus Γ ⊢+
L ϕ.
⊓⊔

7.3. Cut elimination
113
7.3. Cut elimination
In both directions of the proof of Proposition 7.2.2 we introduce detours. In
the left-to-right direction we express the left rule for, say ∧, by a sequence of
rules in which a ∧-introduction is immediately followed by a ∧-elimination
(this is reﬂected by a redex of form πi(< M1, M2 >) in the λ-term corre-
sponding to the proof). In general we expressed each left rule of the sequent
calculus system by a natural deduction proof in which a sequent occurrence
was both the conclusion of an introduction rule and the major4 premise of
the corresponding elimination rule (in general, such sequent occurrences are
reﬂected by redexes in the λ-term corresponding to the proof).
In the right-to-left direction we used the cut rule to express elimination
rules in terms of left rules.
We know that we can get rid of the detours in the natural deduction
proofs; that is, we can transform any natural deduction proof into one in
which no sequent occurrence is both the conclusion of an introduction rule
and the major premise of the corresponding elimination rule. This corre-
sponds to the fact that, by the weak normalization theorem, we can eliminate
all redexes in a term of the simply typed λ-calculus with pairs and sums.
The following theorem states that we can also do without the cuts.
7.3.1. Theorem (Cut elimination). For all ϕ and Γ the conditions Γ ⊢+
L ϕ
and Γ ⊢L ϕ are equivalent.
The proof is somewhat tedious, especially when presented in terms of
proof trees—see, e.g., [46] or [109].
Therefore we postpone the proof to
Section 7.6 where a more convenient notation for proofs is developed. Here
we merely reﬂect on some of the more interesting aspects of the proof, and
consider some consequences of the theorem.
First observe that there is no uniform way to eliminate an application of
the cut rule, i.e., there is no ﬁxed sequence of other rules that is equivalent
to a cut. Each cut has to be eliminated diﬀerently, and this depends on the
shape of the cut formula and the way it was constructed above the cut.
In addition, in an attempt to eliminate a cut with a complex cut formula,
i.e., one of the form ϕ →ψ, we may actually create new cuts, as can be seen
from the following example. Consider a proof that ends with an application
of a cut rule of the form:
4In ∨E, →E, and ∧E the major premise is the leftmost one, the rightmost one, and
the single one, respectively.

114
Chapter 7. Sequent calculus
(R →)
(1)
...
Γ, ϕ ⊢ψ
Γ ⊢ϕ →ψ
(2)
...
Γ ⊢ϕ
(3)
...
Γ, ψ ⊢ϑ
Γ, ϕ →ψ ⊢ϑ
(L →)
Γ ⊢ϑ
(Cut)
We can eliminate this cut at the cost of introducing two new ones. This
makes sense, because the new cut formulas are simpler. The new proof is as
follows:
(Cut)
(2)
...
Γ ⊢ϕ
(1)
...
Γ, ϕ ⊢ψ
Γ ⊢ψ
(3)
......
Γ, ψ ⊢ϑ
Γ ⊢ϑ
(Cut)
Note that in our example the cut formula ϕ →ψ was introduced just before
the cut by the rules (R→) and (L→).
The strategy of the cut elimination proof is as follows. The main cases,
when the cut formula is introduced by the appropriate left and right rules
directly before cut, is treated as in our example: by replacing the cut by
new “simpler” cuts. Other cuts are “permuted upward” so that each cut is
eventually either applied to an axiom (an easy case), or another main case
is obtained. This requires an induction over two parameters: the depths of
cuts and the complexity of cut formulas.5
7.3.2. Remark. The cut elimination theorem also holds for the classical
sequent calculus; that is, for all Σ and Γ the conditions Γ ⊢+
LC Σ and Γ ⊢LC Σ
are equivalent.
7.3.3. Lemma (Subformula property). The cut-free sequent calculus ⊢L has
the following property: Each formula occurring in a proof of Γ ⊢ϕ is either
a subformula of ϕ or a subformula of a formula occurring in Γ.
Proof. By induction on the derivation of Γ ⊢ϕ.
⊓⊔
There are a number of consequences of the subformula property. One
is that ﬁnding a sequent calculus proof of a given formula (or ﬁnding out
that no such proof exists) is incomparably easier than ﬁnding such a proof
in the Hilbert, or natural deduction system. As we reconstruct the proof
5The similarity between this approach and the proof method of weak normalization is
not at all incidental.

7.4. Term assignment for sequent calculus
115
by building the tree upward, the search space at each step is limited to
subformulas of the formulas occurring at the present stage. This process
cannot continue indeﬁnitely, as the number of available formulas is bounded,
and we will eventually repeat already considered sequents.
7.3.4. Corollary (Gentzen). It is decidable, for input ϕ, whether ⊢+
L ϕ.
Another consequence is the conservativity of fragments of the calculus
determined by a choice of connectives. The subformula property implies
that a cut-free proof of a sequent can only mention connectives occurring
in that sequent. Thus, e.g., a formula ((p ∧q) →r) ↔(p →(q →r)) is
provable in a system containing only rules for implication and conjunction.
7.3.5. Corollary. IPC is conservative over its implicational fragment.
We end this section with another proof of the disjunction property
(Proposition 2.5.7).
7.3.6. Corollary. If ⊢+
L ϕ ∨ψ then either ⊢+
L ϕ or ⊢+
L ψ.
Proof. If there is a proof of ⊢+
L ϕ ∨ψ, then there is a cut-free one. And a
cut-free proof of a disjunction must end up with an application of rule (∨I).
Thus, either ⊢L ϕ or ⊢L ψ must have been proved ﬁrst.
⊓⊔
7.4. Term assignment for sequent calculus
Natural deduction proofs correspond to typed λ-terms and Hilbert-style
proofs correspond to typed combinators. What do sequent calculus proofs
correspond to?
There are several answers. The traditional one—see, e.g., [84, 118]—
is that we can assign lambda-terms to sequent calculus proofs; that is, we
can devise an alternative version of simply typed λ-calculus—with the same
term language, but with diﬀerent typing rules—which is to sequent calculus
what the traditional formulation of simply typed λ-calculus is to natural
deduction.
This is carried out below. We begin with the implicational fragment.
7.4.1. Definition (Sequent calculus style λ→). The type and term language
of the sequent calculus style λ→is as for λ→(`a la Curry). The typing rules
are as follows:

116
Chapter 7. Sequent calculus
Axiom:
Γ, x:ϕ ⊢x : ϕ
Rules:
Γ ⊢M : ϕ
Γ, x:ψ ⊢N : σ
Γ, y:ϕ →ψ ⊢N[x := yM] : σ
(L→)
Γ, x:ϕ ⊢M : ψ
Γ ⊢λx.M : ϕ →ψ
(R→)
Γ ⊢M : ϕ
Γ, x:ϕ ⊢N : σ
Γ ⊢(λx.N)M : σ
(Cut)
We also write ⊢+
L and ⊢L for derivability in this system with and without
cut, respectively. We thus have binary and ternary version of both ⊢+
L and
⊢L; the binary version refers to the sequent calculus formulation of IPC(→)
in Deﬁnition 7.2.1, and the ternary version refers to the present sequent
calculus style formulation of λ→.
As usual we have that the system with terms agrees with the system
without terms.
7.4.2. Proposition.
(i) If Γ ⊢+
L M : ϕ then |Γ| ⊢+
L ϕ.
(ii) If Γ ⊢+
L ϕ then there exists M ∈Λ such that ∆⊢+
L M : ϕ, where
∆= {(xϕ : ϕ) | ϕ ∈Γ}.
The above sequent calculus system assigns types to certain λ-terms. Are
these the same λ-terms as those that receive types by the usual simply typed
λ-calculus `a la Curry? The answer is no! For instance, there is no way to
assign a type to (λx.λy.x) (λz.z) (λz.z) in the above system.
However, the proof of Proposition 7.2.2 implicitly deﬁnes a translation
from terms typable in simply typed λ-calculus (corresponding to natural
deduction proofs) to terms typable in the above system (corresponding to
sequent calculus proofs), and vice versa.
On the other hand, if we restrict attention to λ-terms in normal form,
then the set of terms typable in traditional simply typed λ-calculus coincides
with the set of terms typable in sequent calculus.
7.4.3. Proposition. For every term M in normal form, Γ ⊢+
L M : ϕ iﬀ
Γ ⊢M : ϕ in simply typed λ-calculus.

7.4. Term assignment for sequent calculus
117
Proof. First show that a term M is in normal form iﬀeither
• M is a variable, or
• M = λx.N, where N is a normal form, or
• M = N[y := xP], where N and P are normal forms.
Then the property follows easily.
⊓⊔
In the correspondence between simply typed λ-calculus and natural de-
duction, λ-terms in normal form correspond to normal deductions (i.e., de-
ductions where no sequent is at the same time the conclusion of an intro-
duction rule and the major premise of the corresponding elimination rule).
In the sequent calculus variant of simply typed λ-calculus, λ-terms in
normal form correspond to cut-free proofs in sequent calculus.
7.4.4. Proposition. If Γ ⊢+
L M : ϕ, then M is in normal form if and only
if Γ ⊢L M : ϕ.
Proof. Obvious.
⊓⊔
Thus simply typable λ-terms in normal form correspond to both nor-
mal proofs in natural deduction and cut-free sequent calculus proofs. We
therefore have the correspondence
Normal deductions
⇐⇒
Cut-free proofs
However, note that a deduction may use the cut rule even if the cor-
responding λ-term is in normal form (cf. Exercise 7.7.5): the substitution
N[x := y M] may delete the term M which may contain redexes. In this
case we just know that there is another typing that does not use the cut
rule of the same term.
7.4.5. Remark. As mentioned above, the proof of Proposition 7.2.2 implic-
itly deﬁnes a translation from terms typable in traditional simply typed
λ-calculus (corresponding to natural deduction proofs) to terms typable in
the above system (corresponding to sequent calculus proofs), and vice versa.
From what has been said above one might expect that the translations
map normal forms to normal forms. However this is not the case. The reason
for this is that in the proof of Proposition 7.2.2 we aimed at the simplest
possible way to get from natural deduction proofs to sequent calculus proofs;
in particular, we translated the left rules of sequent calculus into natural
deduction proofs containing detours, and we made use of the cut rule in
translating elimination rules into left rules.

118
Chapter 7. Sequent calculus
7.5. The general case
We brieﬂy show how the development of the preceding section can be gen-
eralized to the full propositional language.
Recall the extension of λ→`a la Curry with pairs and sums:
Γ ⊢M : ψ
Γ ⊢N : ϕ
Γ ⊢< M, N >: ψ ∧ϕ
Γ ⊢M : ψ ∧ϕ
Γ ⊢π1(M) : ψ
Γ ⊢M : ψ ∧ϕ
Γ ⊢π2(M) : ϕ
Γ ⊢M : ψ
Γ ⊢in1(M) : ψ ∨ϕ
Γ ⊢M : ϕ
Γ ⊢in2(M) : ψ ∨ϕ
Γ ⊢L : ψ ∨ϕ
Γ, x : ψ ⊢M : ρ
Γ, y : ϕ ⊢N : ρ
Γ ⊢case(L; x.M; y.N) : ρ
For completeness, extend the language with an operator ε for falsity, with
the following rule:
Γ ⊢M : ⊥
Γ ⊢ε(M) : σ
and with no reduction rule (as there is no ⊥-introduction rule).
First we generalize the construction in the proof of Proposition 7.4.3
7.5.1. Lemma. A term M is in normal form iﬀeither
• M is a variable, or
• M = λx.P, or
• M = P[y := xQ], or
• M =< P, Q >, or
• M = in1(P), or
• M = in2(P), or
• M = P[y := π1(x)], or
• M = P[y := π2(x)], or
• M = P[y := case(x; v.Q; w.R)], or
• M = ε(P),
where P, Q, and R are normal forms.
Proof. Easy.
⊓⊔

7.5. The general case
119
7.5.2. Definition (Sequent calculus style λ→for the full language). The se-
quent calculus style λ→for the full propositional language is as for λ→`a la
Curry with pairs and sums. The typing rules are are those of Deﬁnition 7.4.1
and in addition the following:
(L∧)
Γ, x:ϕi ⊢M : σ
Γ, y:ϕ1 ∧ϕ2 ⊢M[x := πi(y)] : σ
Γ ⊢M : ϕ
Γ ⊢N : ψ
Γ ⊢< M, N >: ϕ ∧ψ
(R∧)
(L∨)
Γ, x:ϕ ⊢M : σ
Γ, y:ψ ⊢N : σ
Γ, z:ϕ ∨ψ ⊢case(z; x.M; y.N) : σ
Γ ⊢M : ϕi
Γ ⊢ini(M) : ϕ1 ∨ϕ2
(R∨)
Γ, x:⊥⊢ε(x) : σ
(L⊥)
It is a routine matter to verify that the generalized version of Proposi-
tion 7.4.2 holds.
We would like now to generalize Proposition 7.4.3, but there is a problem.
Some typable lambda-terms in normal form do not correspond to any terms
typable in the new system. For instance, if M, N, P and Q are normal
forms, then the term π1(case(z; x. < M, N >; y. < P, Q >)) is in normal
form. But it has no type in the above system, even if the term is typable in
λ→with pairs and sums (to see this, observe that no rule could possibly be
the last one used.)
One way to remedy this problem is to modify the term assignment for
the (Cut) rule to:
Γ ⊢M : ϕ
Γ, x:ϕ ⊢N : σ
Γ ⊢N[x := M] : σ
(Cut)
Then our example term can be typed, but only using the cut-rule, so the
correspondence between normal proofs and cut-free proofs has been lost.
Incidentally, this diﬃculty does not occur for implication and conjunc-
tion, but only for the disjunction and falsity. The reason is that the elimina-
tion rules for these connectives are diﬀerent. Recall that every elimination
rule has a main premise involving the eliminated connective.
In case of
implication and conjunction, the conclusion of the elimination rule (more
precisely: the right-hand side of the conclusion) is a subformula of the main
premise. In case of disjunction and falsity this is not the case.
Our example term corresponds to the following sequence of proof steps:
conjunction introduction (pairing) followed by disjunction elimination (case),
followed by conjunction elimination (projection). Due to the “irregular” be-
haviour of disjunction elimination, the last projection should actually be
applied to the pair(s) created at the beginning. But the case instruction

120
Chapter 7. Sequent calculus
makes this impossible. It is a stranger who entered here by mistake due to
an improperly closed door (the “bad” elimination, as Girard calls it) and
does her own work quite unrelated to the form of the main premise. A so-
lution is either to ignore her or to open the door even more and let her go
out. Technically, these two alternatives mean that we should either relax the
existing reduction rules to allow for reduction of introduction/elimination
pairs, even if the latter does not immediately follow the former, or we should
introduce commuting conversions, i.e., reduction rules to permute elimina-
tions.
After Girard [46] we take the second option.
7.5.3. Definition. In λ→with pairs and sums let →c denote the union
of →β, of the β-reductions for pairs and sums (see Page 75), and of the
compatible closure of the relation deﬁned by the following rules:
• π1(case(M; x.P; y.Q)) →case(M; x.π1(P); y.π1(Q));
• π2(case(M; x.P; y.Q)) →case(M; x.π2(P); y.π2(Q));
• (case(M; x.P; y.Q))N →case(M; x.PN; y.QN);
• ε(case(M; x.P; y.Q)) →case(M; x.ε(P); y.ε(Q));
• case(case(M; x.P; y.Q); z.N; v.R) →
case(M; x.case(P; z.N; v.R); y.case(Q; z.N; v.R));
• ε(π1(M)) →ε(M);
• ε(π2(M)) →ε(M);
• ε(ε(M)) →ε(M);
• (ε(M))N →ε(M);
• case(ε(M); x.P; y.Q) →ε(M).
Also, let NFc denote the set of normal forms with respect to →c.
Now we can state a version of Proposition 7.4.3.
7.5.4. Proposition. For every M ∈NFc: Γ ⊢+
L M : ϕ iﬀΓ ⊢M : ϕ in λ→
with pairs and sums.
For the full system we also have
7.5.5. Proposition. For every deduction Γ ⊢+
L M : ϕ, M is in c-normal
form if and only if Γ ⊢L M : ϕ.

7.6. Alternative term assignment
121
Proof. Obvious.
⊓⊔
7.5.6. Remark. The notion of η-reduction is often understood as follows.
An elimination followed by an introduction of the same connective should
be ignored. We can write the following eta-rule for ∧:
< π1(M), π2(M) >→η M.
The above rule, although looking very convincing, hides an unpleasant sur-
prise to be discovered in Exercise 7.7.6.
For function types, as we have already observed before, the meaning of
the eta rule is the postulate of extensionality for functions, In case of ∧,
eta-reduction has the following meaning: Every object of a product type is
actually a pair.
This leads to the idea of the following “generalized extensionality” prin-
ciple: Every object should be assumed to be in a “canonical form”. The
canonical form for an object of type σ ∨τ is a variant, i.e., it is either an
in1(M) or an in2(N). Thus suggest the following eta rule for disjunction:
case(M; x.in1(x); y.in2(y)) →M.
7.5.7. Warning. We use logical symbols ∨and ∧to denote also the corre-
sponding types. Similar symbols are often used to denote intersection and
union types, which have quite a diﬀerent meaning (see e.g. [6]). Our ∧is ac-
tually a product rather than intersection, and our ∨is a variant type rather
than set-theoretic or lattice union.
7.6. Alternative term assignment
The sequent calculus systems with terms in the preceding two sections reveal
interesting connections about normal natural deduction proofs and cut-free
sequent calculus proofs.
However, for a ﬁne-grained analysis of cut-elimination the term assign-
ment is not satisfactory. The problem is that diﬀerent proofs correspond to
the same term so that reductions on proofs is not exactly mirrored by reduc-
tions on terms. In this section we follow another well-known approach—see,
e.g., [15, 116, 38]—and introduce another, more explicit, way of assigning
terms to sequent calculus proofs. We shall use the term assignment to prove
the Cut Elimination Theorem.
Yet another approach to term assignment appears in [52].

122
Chapter 7. Sequent calculus
7.6.1. Definition (Alternative term assignment to sequent calculus). We con-
sider the language of propositional formulas and the following term language:
M
::=
x | in1(M) | in2(M) | λx.M | < M, M′ >
|
ε(x)
|
case(x; x′.M′; x′′.M′′)
|
let x = x′ M in M′
|
let x = π1(x′) in M′
|
let x = π2(x′) in M′
|
let ϕ x = M′ in M′
Note that in the ﬁrst three kinds of let-expression, the form of N in the
expression “let x = N in M” is restricted to certain forms.
The inference rules of the system are as follows:
Axiom:
Γ, x:ϕ ⊢x : ϕ
Rules:
(L→)
Γ ⊢M : ϕ
Γ, x:ψ ⊢N : σ
Γ, y:ϕ →ψ ⊢let x = y M in N : σ
Γ, x:ϕ ⊢M : ψ
Γ ⊢λx.M : ϕ →ψ
(R→)
(L∧)
Γ, x:ϕi ⊢M : σ
Γ, y:ϕ1 ∧ϕ2 ⊢let x = πi(y) in M : σ
Γ ⊢M : ϕ
Γ ⊢N : ψ
Γ ⊢< M, N >: ϕ ∧ψ
(R∧)
(L∨)
Γ, x:ϕ ⊢M : σ
Γ, y:ψ ⊢N : σ
Γ, z:ϕ ∨ψ ⊢case(z; x.M; y.N) : σ
Γ ⊢M : ϕi
Γ ⊢ini(M) : ϕ1 ∨ϕ2
(R∨)
Γ, x:⊥⊢ε(x) : σ
(L⊥)
Γ ⊢M : ϕ
Γ, x:ϕ ⊢N : σ
Γ ⊢let ϕ x = M in N : σ
(Cut)
In λ-terms with pairs and sums there are a number of constructors and
a number destructors. The constructors are < •, • >, ini(•), and λx.•; these
build up values, informally speaking. The destructors are case(•; x.M; x′.M′),
• N, and πi(•). These inspect and dissect values, informally speaking. In
the λ-calculus with pairs and sums one can freely apply a destructor to any

7.6. Alternative term assignment
123
term. The main diﬀerence to the above term language is that now the com-
bination of destructors and constructors are expressed via an explicit rule,
namely cut.
This makes it very explicit where intermediate results, e.g. a pair of
which one takes a projection, are constructed. In functional programming
there are various techniques to eliminate intermediate data structures from
functional programs, notably Wadler’s deforestation [115]. Marlow [69] stud-
ies deforestation of a functional programming language which is similar to
the term assignment for sequent calculus proofs.
The following rules remove cuts from sequent calculus proofs represented
by the alternative syntax of Deﬁnition 7.6.1.
7.6.2. Definition. On the term language introduced in Deﬁnition 7.6.1,
we introduce the relation →
→a as the transitive, reﬂexive, compatible closure
of the relation deﬁned by the following rules, which are divided into three
groups: main cases, absent constructor in left term, and absent constructor
in right term.
The main cases are:
let ϕ1∧ϕ2 y =< M1, M2 > in let x = πi(y) in M
→
let ϕi x = Mi in M
let ϕ1∨ϕ2 y = ini(M) in case(y; x1.M1; x2.M2)
→
let ϕi xi = M in Mi
let ϕ1→ϕ2 y = λx.M in let z = y N in L
→
let ϕ1 x = N in let ϕ2 z = M in L
Absent constructor from left hypothesis:
let ϕ x = y in N
→N{x := y}
let ϕ x = let y = πi(z) in M in N
→let y = πi(z) in let ϕ x = M in N
let ϕ x = case(z; y1.M1; y2.M2) in N →
case(z; y1.let ϕ x = M1 in N; y2.let ϕ x = M1 in N)
let ϕ x = let y = z M in K in N
→let y = z M in let ϕ x = K in N
let ϕ x = let ψ y = M in K in N
→let ψ y = M in let ϕ x = K in N
let ϕ x = ε(y) in N
→ε(y)
Absent constructor from right hypothesis:
let ϕ x = N in y
→
y{x := N}
let ϕ x = N in < M1, M2 >
→
< let ϕ x = N in M1, let ϕ x = N in M2 >
let ϕ x = N in ini(M)
→
ini(let ϕ x = N in M)
let ϕ x = N in λy.M
→
λy.let ϕ x = N in M
let ϕ x = N in ε(y)
→
ε(y)
let ϕ x = N in let ψ y = K in L
→
let ψ y = (let ϕ x = N in K) in (let ϕ x = N in L)

124
Chapter 7. Sequent calculus
7.6.3. Definition.
1. Deﬁne the degree d(ϕ) of a formula ϕ by:
d(⊥) = d(α) = 0,
for α ∈PV ;
and
d(ϕ ∧ψ) = d(ϕ ∨ψ) = d(ϕ →ψ) = 1 + max{d(ϕ), d(ψ)}.
2. Deﬁne the degree d(M) of a term M as the maximal degree of any ϕ
in any let ϕ x = K in L in M.
3. Deﬁne the height h(M) of a term M as the height of M viewed as a
tree.
7.6.4. Lemma. Let d = d(ϕ) and assume
Γ ⊢+
L let ϕ x = M in N : ψ
where d(M) < d and d(N) < d. Then let ϕ x = M in N →
→a P for some P
with Γ ⊢+
L P : ψ and d(P) < d.
Proof. By induction on h(M) + h(N). Split into cases according to the
form of M and N.
⊓⊔
7.6.5. Proposition. If Γ ⊢+
L M : ϕ and d(M) > 0 then M →
→a N for
some N with Γ ⊢+
L N : ϕ and d(M) > d(N).
Proof. By induction on M using the lemma.
⊓⊔
7.6.6. Theorem (Gentzen). If Γ ⊢+
L M : ϕ then M →
→a N where Γ ⊢+
L N : ϕ
and d(N) = 0, i.e., N represents a cut-free proof.
Proof. By induction on d(M) using the Proposition.
⊓⊔
What does the system introduced above correspond to, computationally
speaking? The rules are similar to the rules that one ﬁnds in systems for
explicit substitution—see, e.g., [14]. It would be interesting to investigate
this in greater detail—this has been done recently [113].

7.7. Exercises
125
7.7. Exercises
7.7.1. Exercise. Give sequent calculus proofs for the formulas of Exam-
ple 2.2. To prove the odd-numbered formulas use only sequents with single
formulas at right-hand sides.
7.7.2. Exercise. Show that all cut-free proofs for the even-numbered for-
mulas of Example 2.2 must involve sequents with more than one formula at
the right-hand side.
7.7.3. Exercise. Design a sequent calculus allowing empty right-hand sides
of sequents. Does it make sense now to have a right rule for ⊥?
7.7.4. Exercise. Prove Proposition 7.4.3. On the basis of this proof de-
scribe algorithms translating a normal deduction into a cut-free proof and
conversely.
7.7.5. Exercise. Give examples of cuts that are assigned terms in normal
form, according to the term assignment of Section 7.4.
7.7.6. Exercise. Show that the Curry-style variant of lambda-calculus with ∧
does not have the subject reduction property for η-reductions. Show that
the eta rule for ∨has the subject reduction property.
7.7.7. Exercise. Design a Church-style calculus with ∧and ∨and show
that subject reduction property holds for that calculus.
7.7.8. Exercise. Explain the diﬀerence between the above two results.
7.7.9. Exercise. Can you design a reasonable eta-rule for disjunction aim-
ing at erasing elimination-introduction pairs? Why not?
7.7.10. Exercise. Deﬁne an eta-rule for ⊥.
7.7.11. Exercise. Let A denote the term language of Deﬁnition 7.6.1, ex-
cept that in A, cut terms have the form let∗x = M in N (the ϕ is omitted).
Let L denote the set of λ-terms with pairs and sums and ε.
Let ⊢L denote typability in λ→with pairs and sums and ⊥, and let ⊢A
denote typability in the sense of Deﬁnition 7.6.1 with the obvious modiﬁca-
tion to the cut rule to accomodate the change in the syntax of cut terms.
Let →
→A denote the reduction relation from Deﬁnition 7.6.2, and let →
→L
denote the transitive, reﬂexive closure of →β plus the reductions on pairs
and sums. =A and =L are the obvious closures.
Use the proof of Proposition 7.2.2 to give translations tL : A →L and
tA : L →A between A and L.
Note that these can also be viewed as
translations on type-free terms.
Which of the following properties hold for your translations?

126
Chapter 7. Sequent calculus
1. Γ ⊢L M : ϕ ⇔Γ ⊢A tA(M) : ϕ;
2. Γ ⊢A M : ϕ ⇔Γ ⊢L tL(M) : ϕ;
3. M →
→L N ⇔tA(M) →
→A tA(N);
4. M →
→A N ⇔tL(M) →
→L tL(N);
5. tL(tA(M)) =L M;
6. tA(tL(M)) =A M.
What happens if you add commuting conversion to the relations →L, =L,
etc.?

CHAPTER 8
Classical logic and control operators
In the previous chapters we have encountered the Curry-Howard isomor-
phism in various incarnations; each of these state a correspondence between
some system of typed terms and a system of formal logic.
Until now these systems of formal logic have been constructive; that is,
in none of them have we found the principle of the excluded middle or the
double negation elimination principle that one ﬁnds in classical logics.
This is by no means a coincidence.
Until around 1990 there was a
widespread consensus to the eﬀect that “there is no Curry-Howard isomor-
phism for classical logic.” However, at that time Tim Griﬃn made a path-
breaking discovery which have convinced most critics that classical logics
have something to oﬀer the Curry-Howard isomorphism.
In this chapter we introduce classical propositional logic, we study how
one can assign terms to classical proofs, and we present a system for classical
proof normalization.
The connection between classical and intuitionistic
logic is also elaborated in some detail. Griﬃn’s discovery is then presented
at the end of the chapter.
8.1. Classical propositional logic, implicational fragment
Although the bulk of the previous chapters have been concerned with formu-
lations of intuitionistic propositional logic we have occasionally come across
classical propositional logic.
For instance, in Chapter 2, we brieﬂy studied the algebraic semantics of
classical logic, and in the preceding chapter, we introduced sequent calculus
for intuitionistic logic as the restriction of classical sequent calculus to one-
formula right hand sides.
In the case of natural deduction, there are several ways to obtain classi-
cal propositional logic from intuitionistic propositional logic. The following
gives one way of doing this for the implicational fragment.
127

128
Chapter 8. Classical logic and control operators
8.1.1. Remark. In order to avoid confusion and lengthy remarks it is con-
venient in this chapter to have available a systematic way of assigning names
to subsets of the language of propositions and to logical system and typed
λ-calculi.
In this chapter, L(→) denotes the set of implicational formulas, i.e., the
language generated by the grammar:
L(→) ∋ϕ ::= ⊥| α | ϕ →ϕ′
The full propositional language L(→, ∨, ∧) is the language generated by
the grammar:
L(→, ∨, ∧) ∋ϕ ::= ⊥| α | ϕ →ϕ′ | ϕ ∨ϕ′ | ϕ ∧ϕ′
We shall occasionally be concerned with the set L−(→) of pure implica-
tional formulas, i.e., the language generated by
L−(→) ∋ϕ ::= α | ϕ →ϕ′
Similarly, the pure full propositional language L−(→, ∨, ∧) is the lan-
guage generated by the grammar:
L−(→, ∨, ∧) ∋ϕ ::= α | ϕ →ϕ′ | ϕ ∨ϕ′ | ϕ ∧ϕ′
We will follow similar naming conventions for logical systems and typed
λ-calculi.
8.1.2. Definition (Classical propositional logic, implicational fragment). Let
ϕ, ψ range over implicational formulas, i.e., over L(→). As usual, Γ and ∆
denote contexts for which we use the standard conventions.
The natural deduction presentation of the implicational fragment CPC(→)
of classical propositional logic is deﬁned by the following axiom and rules:
Axiom:
Γ, ϕ ⊢ϕ
Rules:
Γ, ϕ ⊢ψ
Γ ⊢ϕ →ψ
(→I)
Γ ⊢ϕ →ψ
Γ ⊢ϕ
Γ ⊢ψ
(→E)
Γ, ϕ →⊥⊢⊥
Γ ⊢ϕ
(¬¬E)

8.1. Classical propositional logic, implicational fragment
129
8.1.3. Proposition. Let ϕ be an implicational formula.
Then Γ ⊢ϕ iﬀ
Γ |= ϕ according to the truth-table semantics. In particular ⊢ϕ iﬀϕ is a
tautology.
Proof. The proof is left as an exercise.
⊓⊔
8.1.4. Remark. A small variation of the system is obtained by changing
rule (¬¬E) to
Γ ⊢(ϕ →⊥) →⊥
Γ ⊢ϕ
(¬¬E′)
It is an easy exercise to see that this change does not aﬀect the set of
provable sequents, i.e., Γ ⊢ϕ can be derived in the original system iﬀΓ ⊢ϕ
can be derived in the modiﬁed system.
Since ¬ϕ is deﬁned as ϕ →⊥a shorter way to express the formula in the
hypothesis is ¬¬ϕ, which explains the name double negation elimination.
8.1.5. Remark. In CPC(→) one can prove every formula that can be proved
in IPC(→), the implicational fragment of intuitionistic propositional logic.
The latter system contains the axiom and the rules (→I), (→E) and (⊥E),
so the only problem is to show that (⊥E) holds as a derived rule in CPC(→).
That is, that we have to show that in CPC(→),
Γ ⊢⊥⇒Γ ⊢ϕ
for any ϕ. In fact, this is easy. If Γ ⊢⊥then also Γ, ϕ →⊥⊢⊥by an easy
weakening lemma, and then Γ ⊢ϕ by (¬¬E).
8.1.6. Remark. Another way to deﬁne CPC(→) is to consider the axiom
along with rules (→I) and (→E) and then the following two rules:
Γ, ϕ →ψ ⊢ϕ
Γ ⊢ϕ
(P)
Γ ⊢⊥
Γ ⊢ϕ
(⊥E)
The left-most rule is called Peirce’s law, and the right-most one is called
ex falso sequitur quod libet (from absurdity follows whatever you like).
An alternative is to consider instead the following two rules:
Γ, ϕ →⊥⊢ϕ
Γ ⊢ϕ
(P⊥)
Γ ⊢⊥
Γ ⊢ϕ
(⊥E)
In other words, in the presence of (⊥E), Peirce’s law and the special case
ψ = ⊥are equivalent.
It is an exercise to show that these two systems derive the same sequents
as the system introduced in Deﬁnition 8.1.2.

130
Chapter 8. Classical logic and control operators
8.1.7. Remark. In the case of Hilbert-style proofs there are also several
ways to obtain classical logic from intuitionistic logic. For instance, if one
takes absurdity as primitive, one can add to the two axioms (A1) and (A2)
of Section 5.3 the principle of double negation elimination:
((ϕ →⊥) →⊥) →ϕ.
Another possibility is to add Peirce’s law in the form
((ϕ →ψ) →ϕ) →ϕ,
together with ex-falso in the form:
⊥→ϕ.
8.1.8. Remark. If one takes negation as primitive in a Hilbert-style system,
one can add to the axioms (A1) and (A2) the third axiom:
(¬ϕ →¬ψ) →(¬ϕ →ψ) →ϕ,
which is read: “if ¬ϕ implies both ψ and ¬ψ, then it is contradictory to
assume ¬ϕ, so ϕ holds.”
In case negation is taken as primitive one cannot simply add
¬¬ϕ →ϕ
(∗)
This may seem a bit strange since above we suggested to add exactly this
axiom when ¬ is deﬁned in terms of ⊥.
The point is, however, that in
deﬁning ¬ in terms of ⊥we get certain extra axioms for free. For instance,
we have above the rule
(ϕ →ψ) →(ϕ →(ψ →⊥)) →(ϕ →⊥)
and the corresponding axiom
(ϕ →ψ) →(ϕ →¬ψ) →¬ϕ
does not follow from axioms (A1) and (A2) and the double negation ax-
iom (∗).
Similar remarks apply to natural deduction systems in which negation
is taken as primitive.
Apart from classical propositional logic and intuitionistic propositional
logic, there are many other similar propositional logics, although none of
them are as fundamental as these two. One can show that classical propo-
sitional logic is a maximal logic in the sense that, for any axiom scheme ϕ,
either ϕ is a theorem of classical propositional logic, or addition of ϕ to
classical propositional logic would render the system inconsistent.
Such
properties are usually known as Hilbert-Post completeness.

8.2. The full system
131
8.2. The full system
In the previous section we were concerned with the implicational fragment
of classical propositional logic. What is required to obtain a deﬁnition of
the whole system with conjunction and disjunction?
One approach is to add to the language the two connectives ∧and ∨and
adopt the introduction and elimination rules of the system of Section 2.2.
8.2.1. Definition (Classical propositional logic). Let ϕ, ψ range over for-
mulas in the full propositional language, i.e., over L(→, ∨, ∧). As usual, Γ
and ∆denote contexts for which we use the standard conventions.
The natural deduction presentation of CPC(→, ∨, ∧), classical proposi-
tional logic, is deﬁned by same rules as in Deﬁnition 8.1.2 with the addition
of the following well-known rules.
Γ ⊢ϕ
Γ ⊢ψ
Γ ⊢ϕ ∧ψ
(∧I)
Γ ⊢ϕ ∧ψ
Γ ⊢ϕ
(∧E)Γ ⊢ϕ ∧ψ
Γ ⊢ψ
Γ ⊢ϕ
Γ ⊢ϕ ∨ψ
(∨I)
Γ ⊢ψ
Γ ⊢ϕ ∨ψ
Γ, ϕ ⊢σ
Γ, ψ ⊢σ
Γ ⊢ϕ ∨ψ
Γ ⊢σ
(∨E)
The above addition does not change anything concerning implicational
formulas.
8.2.2. Proposition. If ϕ ∈L(→) and ⊢ϕ in CPC(→, ∨, ∧), then ⊢ϕ in
CPC(→).
Proof. Left as an exercise.
⊓⊔
In other words, the full system is conservative over the implicational frag-
ment.
However, there is a more economical approach. In contrast to the sit-
uation in intuitionistic propositional logic, we may deﬁne conjunction and
disjunction as derived connectives.
8.2.3. Definition. Let ϕ ∧ψ and ϕ ∨ψ abbreviate the following formulas,
respectively:
ϕ ∧ψ
=
(ϕ →ψ →⊥) →⊥;
ϕ ∨ψ
=
(ϕ →⊥) →(ψ →⊥) →⊥.
8.2.4. Remark. The above deﬁnition of ϕ ∨ψ is not standard; one usually
takes ϕ∨ψ = (ϕ →⊥) →ψ. This deﬁnition lacks the double negation on ψ.
From a logical point of view this is of little importance, since in classical
logic we can pass back and forth between a formula and its double negation.
However, the abbreviations in Deﬁnition 8.2.3 are more systematic since
they arise as special case of a general scheme for representing data types in
typed λ-calculi, as we shall see later.

132
Chapter 8. Classical logic and control operators
The following states that our deﬁnition of ∧and ∨have the intended
behaviour.
8.2.5. Proposition. Let ϕ ∈L(→, ∨, ∧) and and let ϕ′ ∈L(→) be the
implicational formula obtained by replacing every occurrence of ∧and ∨by
their deﬁning formulas according to Deﬁnition 8.2.3. Then Γ ⊢ϕ′ iﬀΓ |= ϕ.
Proof. By completeness Γ ⊢ϕ′ iﬀΓ |= ϕ′. By elementary calculations
with truth tables, Γ |= ϕ′ iﬀΓ |= ϕ.
⊓⊔
8.3. Terms for classical proofs
In what way can we extend the Curry-Howard isomorphism to classical
propositional logic?
In one sense this is easy: we just add a new term
constructor ∆x.M (or ∆x:ϕ.M in the Church variant of the calculus) in the
conclusion of the double negation elimination rule.
8.3.1. Remark. It is convenient in this chapter to have available a system-
atic way of assigning names to subsets of the language of λ-terms with pairs,
etc.
Recall that Λ denotes the set of λ-terms, i.e., the language generated by
the grammar:
Λ ∋M ::= x | λx.M | M M′
The set of λ-terms, extended with pairs and sums, Λ(πi, ini) is the lan-
guage generated by the grammar:
Λ(πi, ini) ∋M
::=
x | λx.M | M M′ | < M, M′ > | πi(M) |
ini(M) | case(M; x′.M′; x′′.M′′)
We shall occasionally be concerned with the set Λε generated by
Λε ∋M ::= x | λx.M | M M′ | ε(M)
Similarly, we have the language generated by the grammar:
Λε(πi, ini) ∋M
::=
x | λx.M | M M′ | < M, M′ > | πi(M)
|
ini(M) | case(M; x′.M′; x′′.M′′) | ε(M)
8.3.2. Definition (type-free and simply typed λ∆-calculus, λ∆(→)). The term
language Λ∆of type-free λ∆-calculus is deﬁned by the grammar:
Λ∆∋M ::= x | λx.M | M M′ | ∆x.M
The simply typed λ∆-calculus has as type language the set L(→). The
inference system of simply typed λ∆-calculus arises from the system of sim-
ply typed λ-calculus `a la Curry by addition of the rule
Γ, x : ϕ →⊥⊢M : ⊥
Γ ⊢∆x.M : ϕ

8.4. Classical proof normalization
133
8.3.3. Remark. In the Church variant the obvious modiﬁcations are made
to the term language and to the inference rules. In particular, the double
negation elimination rule becomes
Γ, x : ϕ →⊥⊢M : ⊥
Γ ⊢∆x:ϕ →⊥.M : ϕ
We then have the usual correspondence (where binary ⊢means deriv-
ability in CPC(→) and ternary ⊢means typability in simply λ∆-calculus `a
la Curry):
8.3.4. Proposition.
(i) If Γ ⊢M : ϕ then |Γ| ⊢ϕ, where |Γ| = {ϕ | ∃x : (x : ϕ) ∈Γ}.
(ii) If Γ
⊢
ϕ then there exists an M such that Γ′
⊢
M : ϕ, where
Γ′ = {xϕ : ϕ | ϕ ∈Γ}.
The assignment of ∆x.M to the double negation elimination rule only
extends the Curry-Howard isomorphism to classical logic in a very naive
sense: we still have no idea what the computational signiﬁcance of ∆is.
However, we shall learn more about this in Section 8.7.
8.4. Classical proof normalization
As we have seen in previous chapters, reduction on proofs is a rather im-
portant concept in the proof theory of intuitionistic logic; for classical logic
the same is the case, and we now present certain reductions on classical,
propositional proofs that have appeared in the literature.
The following gives reductions on λ∆-terms `a la Church.
The corre-
sponding reductions on λ∆-terms `a la Curry are obtained by erasing all
type annotations.
8.4.1. Definition. Deﬁne the relation →∆on Λ∆`a la Church as the small-
est compatible relation containing the following rules:
(∆x:¬(ϕ →ψ).M) N
→∆
∆z:¬ψ.M{x := λy:ϕ →ψ . z (y N)};
∆x:¬ϕ.x M
→∆
M
provided x ̸∈FV(M);
∆x:¬ϕ.x ∆y:¬ϕ.N
→∆
∆z:¬ϕ.N{x, y := z}.
where {• := •} denotes substitution on λ∆-terms deﬁned in the obvious way,
and the notion of compatibility is taken in the obvious way relative to the
set Λ∆. We use the notation NF∆etc with the usual meaning.
From the point of view of reduction on proofs, the ﬁrst of these rules
decreases the complexity of formulas to which we apply the double negation
elimination rule. The second rule may be regarded as a form of η-rule for ∆.
The third rule reduces applications of the double negation elimination rule
nested in a certain trivial way.

134
Chapter 8. Classical logic and control operators
8.4.2. Warning. The reader should be warned that one ﬁnds in the liter-
ature diﬀerent typed λ-calculi corresponding to classical logic that are not
merely simple variations of the above one. This is in particular true for the
system studied by Parigot—see, e.g, [82]—which is one of the most widely
cited approaches.
Also, diﬀerent authors use diﬀerent symbols for the term corresponding
to variants of the double negation elimination rule, e.g. µ (Parigot [79, 80,
82, 81], Ong [78]), γ (Rezus [91, 92]), and C (Griﬃn [49] and Murthy [75, 76]);
the ∆is taken from Rehof and Sørensen [89].
8.4.3. Remark. In the literature one ﬁnds diﬀerent sets of reduction rules
for classical proofs, although almost every set contains a variant of the ﬁrst
of the above rules.
The following gives a characterization of the normal forms of β∆-reduction,
i.e., a characterization of classical proofs without detours.
8.4.4. Definition. Let N be the smallest class of λ∆-terms closed under
the rule: M1, . . . , Mn ∈N ⇒λx1. . . . λxn.∆y1. . . . ∆ym.z M1 . . . Mn ∈N
where n, m ≥0 and z may be an xi, a yj, or some other variable.
8.4.5. Proposition. If Γ ⊢M : ϕ in simply typed λ∆-calculus, and M ∈NFβ∆,
then M ∈N.
Proof. By induction on the derivation of Γ ⊢M : ϕ.
⊓⊔
The proposition states that any normal proof proceeds by ﬁrst making
certain assumptions (reﬂected by the variable z), then decomposing those
assumptions into simpler formulas by elimination rules (reﬂected by the
applications z M1 . . . Mn), then using on the resulting formulas some ap-
plications of the double negation elimination rule (reﬂected by ∆yi.•), and
ﬁnally by building up from the result more complicated formulas again by
introduction rules (reﬂected by the abstractions λxi.•).
The following shows that the reduction rules are suﬃciently strong that
the characterization of their normal forms entails consistency of the system.
8.4.6. Corollary. ̸⊢⊥.
Proof. If ⊢⊥then ⊢M : ⊥for some closed M. By the strong normal-
ization theorem—which will be proved later—we can assume that M is in
normal form. Then by induction on the derivation of M ∈N show that
⊢M : ⊥is impossible.
⊓⊔

8.5. Deﬁnability of pairs and sums
135
8.5. Deﬁnability of pairs and sums
We saw in the second section above that one can deﬁne conjunction and
disjunction in classical propositional logic. Intuitively speaking, at the level
of terms, this suggest that we should be able to deﬁne pairs and sums. In
this section we show that this is indeed possible. For simplicity we work in
this section with λ∆-terms `a la Curry.
First we introduce the extension that corresponds to the full system
CPC(→, ∨, ∧).
8.5.1. Definition. The term language Λ∆(πi, ini) of type-free λ∆-calculus
extended with pairs and sums is deﬁned by the grammar:
Λ∆(πi, ini) ∋M
::=
x | λx.M | M M′ | < M, M′ > | πi(M)
|
ini(M) | case(M; x′.M′; x′′.M′′) | ∆x.M
The simply typed λ∆-calculus extended with pairs and sums, denoted by
λ∆(→, ∨, ∧), has as type language the set L(→, ∨, ∧). The inference system
of λ∆(→, ∨, ∧) arises from that of λ∆(→) by addition of the usual rules `a
la Curry for typing pairs and sums.
The following shows how to deﬁne pairs and sums.
8.5.2. Definition. Deﬁne the following abbreviations.
< P, Q >
=
λz.z P Q;
πi(P)
=
∆k.P (λx1.λx2.k xi);
ini(P)
=
λy1.λy2.yi P;
case(P; x1.Q1; x2.Q2)
=
∆k.P (λx1.kQ1) (λx2.kQ2).
By some elementary calculations, one can then prove the following.
8.5.3. Proposition. Let M ∈Λ∆(πi, ini) and let M′ ∈Λ∆(πi, ini) be the
term obtained by expansion according to the abbreviations in the preceding
deﬁnition. Let ϕ ∈L(→, ∨, ∧) and let ϕ′ ∈L(→) be the formula obtained by
replacing every occurrence of ∧and ∨by their deﬁning formulas according
to Deﬁnition 8.2.3.
1. If Γ ⊢M : ϕ in simply typed λ∆-calculus extended with pairs and sums,
then Γ ⊢M′ : ϕ′ in the simply λ∆-calculus.
2. If M →β∆N (using reductions for pairs and sums) then M′ →
→β∆N′,
where N′ is the expansion of N according to the preceding deﬁnition.
The deﬁnition of pairs is the standard one from type-free λ-calculus (see
Chapter 1), while the projection construction is diﬀerent from that normally
employed in type-free λ-calculus, viz. M (λx1.λx2.xi). This latter deﬁnition

136
Chapter 8. Classical logic and control operators
does not work because λx1.λx2.xi has type ϕ1 →ϕ2 →ϕi instead of the type
ϕ1 →ϕ2 →⊥, which M expects. Changing the deﬁnition of conjunctive
types to solve the problem is not possible; it leads to the type of a pair
being dependent on which component a surrounding projection picks.1 The
operator ∆solves the problem by means of an application which turns the
type of xi into ⊥regardless of i. When the projection is calculated, the k
reaches its ∆and can be removed by the second reduction rule for ∆:
π1(< M1, M2 >)
≡
∆k.(λf.f M1 M2) λx1.λx2.k x1
→β
∆k.(λx1.λx2.k x1) M1 M2
→
→β
∆k.k M1
→∆
M1
As mentioned earlier, the deﬁnition for disjunctive formulas above is
not standard in logic. The standard deﬁnition is (ϕ →⊥) →ψ instead
of (ϕ →⊥) →(ψ →⊥) →⊥. However, when one tries to prove the de-
rived inference rules for this translation it turns out that the corresponding
constructions for injection and case analysis are very diﬀerent from those
deﬁning pairs and projections. Speciﬁcally, to have the desired reduction
rule hold derived one would need to add extra power to ∆. The present
deﬁnition and corresponding deﬁned constructions can be motivated by cor-
responding deﬁnition in second-order logic, which we will encounter in a
later chapter.
8.6. Embedding into intuitionistic propositional logic
In this section we shall show that classical logic can be embedded into intu-
itionistic logic in a certain sense.
Translations like the following have been studied since the 1930s by Kol-
mogorov, Gentzen, G¨odel, and Kuroda.
8.6.1. Definition. Deﬁne the translation k from implicational formulas to
implicational formulas by:
k(α)
=
¬¬α
k(⊥)
=
¬¬⊥
k(ϕ →ψ)
=
¬¬(k(ϕ) →k(ψ))
We aim to show that if ϕ is classically provable, then k(ϕ) is intuition-
istically provable. We do this by giving a translation of classical proofs of
ϕ into intuitionistic proofs of k(ϕ). More precisely, the translation is stated
on terms representing these proofs.
1If one is willing to settle for a weaker notion of pairs where both component must
have the same type, then this problem vanishes. This shows that pairs with components
of the same type can be represented in the simply typed λ-calculus.

8.6. Embedding into intuitionistic propositional logic
137
8.6.2. Definition. Deﬁne the translation t from λ∆-terms to λ-terms by:
t(x)
=
λk.x k
t(λx.M)
=
λk.k λx.t(M)
t(M N)
=
λk.t(M) (λm.m t(N) k)
t(∆x.M)
=
λk.(λx.t(M)) (λh.h λj.λi.i (j k)) λz.z
The following shows that k deﬁnes an embedding of classical logic into
intuitionistic logic.
8.6.3. Proposition. If Γ ⊢M : ϕ in simply typed λ∆-calculus, then k(Γ) ⊢
t(M) : k(ϕ) in simply typed λ-calculus.
This gives another proof of consistency of classical propositional logic: if
classical logic is inconsistent, so is intuitionistic logic.
8.6.4. Proposition. ̸⊢⊥in classical propositional logic.
Proof. If ⊢M : ⊥in classical propositional logic, then ⊢t(M) : ¬¬⊥
in intuitionistic logic, and then ⊢t(M) λz.z : ⊥in intuitionistic logic, a
contradiction.
⊓⊔
The above proof gives a conservativity result: if ⊥is provable in classical
logic, ⊥is provable already in intuitionistic logic.
The construction can
be generalized to other formulas than ⊥; in fact, this way one can prove
that any formula of form ∀x∃y : P(x, y), where P is a primitive recursive
predicate, is provable in classical arithmetic (i.e., Peano Arithmetic) iﬀit
is provable in intuitionistic arithmetic (i.e., Heyting Arithmetic). Formulas
of this form are quite important since they include, e.g., every assertion
that some algorithm terminates (“for any input x there is a terminating
computation y”). In other words, as concerns provability of termination of
algorithms there is no diﬀerence between intuitionistic and classical logic.
On the one hand, this means that constructivists should raise no ob-
jection to the use of classical logic in this special case since any classical
proof can be converted into an intuitionistic one of the same formula. Con-
versely, classical logicians cannot claim that any logical strength is lost by
the restriction to intuitionistic logic.
The following shows that the translation t internalizes ∆conversion by
β-conversion.
8.6.5. Proposition. If M =β∆N then t(M) =β t(N).
By analyzing the connection between ∆and β in some more detail, one
can prove:
8.6.6. Proposition. If M ∈∞β∆then t(M) ∈∞β.

138
Chapter 8. Classical logic and control operators
8.6.7. Corollary. The relation →β∆is strongly normalizing on typable
terms.
Proof. By the preceding proposition, Proposition 8.6.3, and strong nor-
malization of simply typed λ-calculus.
⊓⊔
8.7. Control operators and CPS translations
So far we have not revealed what the computational meaning of ∆is; in this
section we ﬁnally release the suspension: ∆is a control operator!
Control operators appear in functional programming languages like Scheme
(Call/cc), ML (exceptions), Lisp (catch and throw).
Let us illustrate, by way of example, how control operators can be used to
program eﬃciently and concisely. We shall consider the problem of writing
a function M which takes a binary tree of integer nodes and returns the
result of multiplying all the node values. Of course, this problem raises the
eﬃciency issue of what to do when a node value of 0 is encountered.
Our example programs will be written in syntactically sugared SCHEME,
the sugar being that instead of (define M N) we write M = N and in-
stead of (lambda (x) M) we write λ. x.M, and for (letrec ([f t]) t’)
we write (let f = t in t’).
Our ﬁrst solution is the straightforward purely functional one which
trades eﬃciency oﬀfor elegance. We suppose given auxiliary functions mt?
testing for the empty tree, num selecting the node value of the root node,
lson and rson returning the left and right subtrees.
8.7.1. Example. (Functional, elegant, ineﬃcient version)
M1 = λ. t.(if (mt?
t)
1
(* (num t) (* (M1 (lson t)))(M1 (rson t)))))
One can optimize M1 so as to stop multiplying as soon as a node value of 0 is
encountered. This can be done in purely functional style, by means of tests.
Our next solution embodies that strategy. Here we assume a constructor
EX and a test function EX? such that (EX M) tags M with the marker EX,
and EX? tests for the presence of the tag. Furthermore, we assume a 0 test
function zero?. The reader will probably agree that elegance (or at the
least conciseness) has now been traded oﬀfor eﬃciency.
8.7.2. Example. (Functional, inelegant, eﬃcient version)
M2 = λ. t.(if (mt?
t)
1
(if (zero?
(num t))
(EX 0)

8.7. Control operators and CPS translations
139
(let ((l (M2 (lson t))))
(if (EX? l)
(let ((r (M2 (rson t))))
(if (EX? r)
r
(* (num t) (* l r))))))))
The function M2 will return an integer, the product of all the tree nodes, if
no node contains 0, or the value (EX 0) if any node contains 0. We may
see the EX tag as a kind of exception marker which is propagated explicitly
up the recursion tree. In this vein one could view the EX constructor as an
injection function taking an integer to an element of a sum type of the form
int ∨ex. Now, the catch/throw mechanism is well suited to handle exactly
this kind of problem where an exceptional value is propagated. Eﬃciency is
enhanced by catch and throw because all the propagation is done in a single
step (or jump, as we might say). This leaves us with a relatively elegant and
eﬃcient but non functional version, as shown in the next example program.
8.7.3. Example. (Non functional, elegant, eﬃcient version)
M3 = λ. t.
catch j in
(let L = λ. t’.(if (mt?
t’)
1
(if (zero?
(num t’))
(throw j 0)
(* (num t’)
(* (L (lson t’))(L (rson t’))))))
in (L t))
It is an interesting fact that the mechanism used in Example 8.7.3 can be
internalized in the purely functional part of the language by the so-called
CPS-transformation technique. Applying that translation to the program
with catch and throw gives:
8.7.4. Example. (CPS version of M3)
M4 = λ. t.
λ. k.
(if (mt?
t)
(k 1)
(if (zero?
(num t))
0
((M4 (lson t))
(λ. l.((M4 (rson t))
(λ. r.(k (* (num t) (* l r)))))))))
The non-functional program can be written as follows in the type-free
λ∆-calculus.

140
Chapter 8. Classical logic and control operators
M = λt.∆j.j
(Y (λf.λt′. (if (mt?
t′)
1
(if (zero?
(num t′))
ε(j 0)
(* (num t′)
(* (f (lson t′))(f (rson t′))))))) t),
where Y denotes Church’s ﬁxpoint combinator and ε(M) abbreviates ∆x.M,
for x ̸∈FV(M).
It is instructive to verify that, e.g., for T ≡<2,<0,nil,nil>,nil>, we
have MT = 0, noticing how an “exception” is raised as the node value 0 is
encountered.
In conclusion, the ∆may be regarded as a control operator similar to
call/cc of Scheme and exceptions of ML, and the double negation embedding
of classical logic into intuitionisitic logic corresponds to well-known CPS-
translations of terms with control operators into pure, control-operator-free
languages.
8.8. Historical remarks
Felleisen and his co-workers studied λ-calculi with control operators in an
untyped setting. Their aim was to provide a foundation of type-free func-
tional programming langauges with control operators similarly to the way
λ-calculus may be regarded as a foundation of type-free pure functional
programming languages.
Felleisen devised a control calculus, an extension of the λ-calculus, and
carried out what could aptly be called Plotkin’s program (see [83]) for the
study of the relation between calculi and programming languages.
Griﬃn discovered in 1990, in an attempt to incorporate control operators
into the world of typed λ-calculi, that Felleisen’s C-operator could be typed
by the classical double negation elimination rule [49]. Using this rule does,
however, lead to certain diﬃculties because typing is not in general preserved
under reduction (“Failure of Subject Reduction.”) This defect was repaired
by Griﬃn via a so-called computational simulation.
Later, Murthy overcame the same diﬃculties by changing the type sys-
tem into a so-called pseudo-classical logic. Applying conservativity results
of classical logics over corresponding minimal logics Murthy showed in [75]
that for a certain class of classically provable formulas the Realizability In-
terpretation remains sound. This was done using CPS-translations of control
operator calculi into pure λ-calculi.
Since the seminal work of Griﬃn and Murthy, numerous systems have
appeared that connect classical logic and control operators; indeed, the study
of classical logic in connection with the Curry-Howard isomorphism now

8.9. Exercises
141
constitutes a separate ﬁeld.
8.9. Exercises
8.9.1. Exercise. Prove Proposition 8.1.3.
8.9.2. Exercise.
1. Show that Peirce’s law can be derived from the special case of Peirce’s
law and ex-falso.
2. Show that double negation elimination can be derived from the special
case of Peirce’s law and ex-falso.
3. Show that the special case of Peirce’s law and ex-falso can both be
derived from double negation elimination.
8.9.3. Exercise. Prove that Γ ⊢ϕ can be derived in the system of Deﬁni-
tion 8.1.2 iﬀΓ ⊢ϕ can be derived in the system of Remark 8.1.4.
8.9.4. Exercise. Let ϕ be some implicational formula such that ̸⊢ϕ in
CPC(→), and consider the system Z which arises from CPC(→) by adding
all instances (substituting implicational formulas for propositional variables)
of ϕ as axioms. Show that ⊢⊥in Z.
8.9.5. Exercise. prove Proposition 8.2.2.
8.9.6. Exercise. Show that in CPC(→, ∨, ∧) one can derive ⊢α ∨¬α.
8.9.7. Exercise. The rule
(∆x:¬(ϕ →ψ).M) N →∆∆z:¬ψ.M{x := λy:ϕ →ψ . z (y N)}
can only reduce ∆’s inside an application. The following aggressive variant
does not wait for the application:
(∆x:¬(ϕ →ψ).M) →∆λa:ϕ . ∆z:¬ψ.M{x := λy:ϕ →ψ . z (y a)}
Corresponding to these two diﬀerent rules, give reduction rules for the con-
structs πi(∆x:¬(ϕ ∧ψ).M) and ∆x:¬(ϕ ∧ψ).M.
Can you give corresponding rules for disjunction?
8.9.8. Exercise. Show that →β∆on λ∆-terms `a la Curry is Church-Rosser,
or show that →β∆on λ∆-terms `a la Curry is not Church-Rosser.
Same question for →β∆on terms `a la Church.
8.9.9. Exercise. Does the following hold? For any M ∈Λ∆, M ∈N iﬀ
M ∈NFβ∆.

142
Chapter 8. Classical logic and control operators

CHAPTER 9
First-order logic
In this chapter we extend our consideration to formulas with quantiﬁers and
generalize the proof systems and interpretations seen in earlier chapters to
the ﬁrst-order case.
9.1. Syntax of ﬁrst-order logic
The objects investigated by propositional logic are compound statements,
built from some atomic statements (represented by propositional variables)
by means of logical connectives. The goal is to understand relations be-
tween compound statements depending on their structure, rather than on
the actual “meaning” of the atoms occurring in these statements. But math-
ematics always involves reasoning about individual objects, and statements
about properties of objects can not always be adequately expressed in the
propositional language. The famous syllogism is an example:
All humans are mortal;
Socrates is a human;
Therefore Socrates is mortal.
To express this reasoning in the language of formal logic, we need to quantify
over individual objects (humans), and of course we need predicates (rela-
tions) on individual objects. The logical systems involving these two features
are known under the names “predicate logic”, “predicate calculus”, “quanti-
ﬁer calculus” or “ﬁrst-order logic”. This section describes a variant of the
ﬁrst-order syntax. Such syntax is always deﬁned with respect to a ﬁxed
ﬁrst-order signature Σ, which is typically assumed to be ﬁnite. Recall from
Chapter 6 that a signature is a family of function, relation and constant
symbols, each with a ﬁxed arity. Also recall that algebraic terms over Σ are
individual variables, constants and expressions of the form (ft1 . . . tn), where
f is an n-ary function symbol, and t1, . . . , tn are algebraic terms over Σ.
143

144
Chapter 9. First-order logic
9.1.1. Definition.
1. An atomic formula is an expression of the form (rt1 . . . tn), where r is
an n-ary relation symbol, and t1, . . . , tn are algebraic terms over Σ.
2. The set ΦΣ of ﬁrst-order formulas over Σ, is the least set such that:
• All atomic formulas and ⊥are in ΦΣ;
• If ϕ, ψ ∈ΦΣ then (ϕ →ψ), (ϕ ∨ψ), (ϕ ∧ψ) ∈ΦΣ;
• If ϕ ∈ΦΣ and x is an individual variable, then ∀x ϕ, ∃x ϕ ∈ΦΣ.
3. As usual, we abbreviate (ϕ →⊥) as ¬ϕ and ((ϕ →ψ) ∧(ψ →ϕ)) as
(ϕ ↔ψ).
4. A formula is open iﬀit contains no quantiﬁers.
9.1.2. Convention. The parentheses-avoiding conventions used for propo-
sitional formulas apply as well to ﬁrst-order formulas. However, there is no
general consensus about how quantiﬁers should be written. One convention,
which is common in logic, is that a quantiﬁer is an operator of highest pri-
ority, so that “∀x ϕ →ψ” stands for “(∀x ϕ) →ψ”. The other convention
seems to have originated in type theory and is that the quantiﬁer scope
extends as much to the right as possible. In order to avoid confusion, we
will sometimes use extra parentheses and sometimes we will use an explicit
dot notation. Namely, we will write “∀x.ϕ →ψ” for “∀x(ϕ →ψ)” and
“∀xϕ. →ψ” instead of “(∀xϕ) →ψ”. (Needless to say, authors sometimes
forget about such conventions. The reader should be warned that each of
the two authors has got used to a diﬀerent style.)
9.1.3. Definition.
1. If t is an algebraic term then FV (t) stands for the set of all variables
occurring in t.
2. The set FV (ϕ) of free variables of a formula ϕ is deﬁned by induction:
• FV (rt1 . . . tn) = FV (t1) ∪. . . ∪FV (tn);
• FV (ϕ →ψ) = FV (ϕ ∨ψ) = FV (ϕ ∧ψ) = FV (ϕ) ∪FV (ψ);
• FV (∀x ϕ) = FV (∃x ϕ) = FV (ϕ) −{x}.
3. A sentence, also called a closed formula, is a formula without free
variables.
9.1.4. Definition. The deﬁnition of a substitution of a term for an individ-
ual variable, denoted ϕ[x := t], respects the quantiﬁers as variable-binding
operators, and thus must involve variable renaming. Formally,

9.2. Intuitive semantics
145
x[x := t] = t;
y[x := t] = y,
if y ̸= x;
(ft1 . . . tn)[x := t] = ft1[x := t] . . . tn[x := t];
(rt1 . . . tn)[x := t] = rt1[x := t] . . . tn[x := t];
(∀xϕ)[x := t] = ∀xϕ;
(∀yϕ)[x := t] = ∀yϕ[x := t], if y̸=x, and y ̸∈FV(t) or x ̸∈FV(ϕ);
(∀yϕ)[x := t] = ∀zϕ[y := z][x := t], if y ̸= x and y ∈FV(t) and x ∈FV(ϕ);
(∃xϕ)[x := t] = ∃xϕ;
(∃yϕ)[x := t] = ∃yϕ[x := t] if y ̸= x, and y ̸∈FV(t) or x ̸∈FV(ϕ);
(∃yϕ)[x := t] = ∃zϕ[y := z][x := t] if y ̸= x and y ∈FV(t) and x ∈FV(ϕ).
where z is a fresh variable.
The simultaneous substitution, written ϕ[x1 := t1, . . . , xn := tn], is the
term
ϕ[x1 :=s1] · · · [xn :=sn][y1
1 :=z1
1] · · · [y1
m1 :=z1
m1] · · · [yn
1 :=zn
1 ] · · · [yn
mn :=zn
mn],
where zi
1, . . . , zi
mi are all variables in ti, the variables yi
j are all fresh and
diﬀerent, and si = ti[zi
1 :=yi
1] · · · [zi
mi :=yi
mi], for all i.
9.1.5. Convention. It is a common convention to write e.g., ϕ(x, y, z) in-
stead of ϕ, to stress that x, y, z may occur in ϕ. In this case, the notation
like ϕ(t, s, u) is used as a shorthand for ϕ[x := t, y := s, z := u]. We will
also use this convention, but one should be aware that it is not a part of the
syntax.
It is not customary to introduce alpha-conversion on ﬁrst-order formu-
las. Typically, alpha-equivalent formulas are considered diﬀerent, although
they are equivalent with respect to all reasonable semantics, and one can
be derived from another with all reasonable proof systems. However, for
uniformity of our presentation, we prefer to allow for the alpha-conversion
(deﬁned in the obvious way) and identify alpha-convertible formulas from
now on.
9.2. Intuitive semantics
The Brouwer-Heyting-Kolmogorov interpretation of propositional formulas
(Chapter 2) extends to ﬁrst-order logic as follows:
• A construction of ∀x ϕ(x) is a method (function) transforming every
object a into a construction of ϕ(a).
• A construction of ∃x ϕ(x) is a pair consisting of an object a and a
construction of ϕ(a).
Note that the BHK-interpretation should be taken with respect to some do-
main of “objects”. These objects are syntactically represented by algebraic
terms.

146
Chapter 9. First-order logic
9.2.1. Example. Consider the following formulas:
1. ¬∃x ϕ. ↔∀x¬ϕ;
2. ¬∀x ϕ. ↔∃x¬ϕ;
3. (ψ →∀x ϕ(x)) ↔∀x(ψ →ϕ(x)), where x ̸∈FV (ψ);
4. (ψ →∃x ϕ(x)) ↔∃x(ψ →ϕ(x)), where x ̸∈FV (ψ);
5. ∀x(ϕ →ψ) →(∃x ϕ. →∃x ψ);
6. ∀x(ψ ∨ϕ(x)) ↔ψ ∨∀x ϕ(x), where x ̸∈FV (ψ);
7. ∀x(ϕ →ψ). →(∀x ϕ. →∀x ψ);
8. (∀x ϕ(x). →ψ) →∃x(ϕ(x) →ψ), where x ̸∈FV (ψ);
9. ∀x ϕ(x). →ϕ(t);
10. ¬¬∀x(ϕ ∨¬ϕ);
11. ψ →∀x ψ, where x ̸∈FV (ψ);
12. ∃x(∃y ϕ(y). →ϕ(x))
Although all these formulas are all classical ﬁrst-order tautologies,1 one will
have diﬃculties ﬁnding BHK-interpretations for some of them.
9.2.2. Remark. It should be no surprise when we say that universal quan-
tiﬁcation is a generalization of conjunction. Indeed, the sentence “all cats
have tails” is quite like an inﬁnite conjunction of statements concerning each
individual cat separately. In quite the same spirit one can say that existen-
tial quantiﬁcation is a generalized disjunction. This idea is reﬂected by the
algebraic semantics, where we interpret quantiﬁers as (possibly inﬁnite) joins
and meets, see Deﬁnitions 9.4.3 and 9.4.4.
But the BHK-interpretation as above hints for another correspondence:
between universal quantiﬁcation and implication, because in both cases we
have a function as a construction. The analogy is so strong that in certain
systems with quantiﬁers, implication is just syntactic sugar. We will see it
in Chapters 10 and 13.
9.3. Proof systems
The three main approaches: natural deduction, sequent calculus and the
Hilbert style extend to ﬁrst-order logic by adding suitable rules and axioms
to the rules and axiom schemes for propositional logic. The notation ⊢N,
⊢L, etc., is the obvious modiﬁcation from the propositional case.
1We assume that the reader is familiar with classical ﬁrst-order logic. A suggested
textbook is e.g. [70].

9.3. Proof systems
147
Natural deduction
We extend the system of natural deduction with the following rules to in-
troduce and eliminate quantiﬁers:
(∀I) Γ ⊢ϕ
Γ ⊢∀x ϕ
(x ̸∈FV (Γ))
(∀E)
Γ ⊢∀x ϕ
Γ ⊢ϕ[x := t]
(∃I)Γ ⊢ϕ[x := t]
Γ ⊢∃x ϕ
(∃E)Γ ⊢∃x ϕ
Γ, ϕ ⊢ψ
Γ ⊢ψ
(x ̸∈FV (Γ, ψ))
The reader should be warned that our rules are such because we have agreed
on alpha-conversion of formulas. Otherwise, one has to modify rules (∀I)
and (∃E) to work for any alpha-variant of the quantiﬁer bindings. Similar
modiﬁcations would have to be done on the other proof systems to follow.
Sequent calculus
Here are classical sequent calculus rules for quantiﬁers. Note the symmetry
between the two quantiﬁers.
(∀L)Γ, ϕ[x := t] ⊢Σ
Γ, ∀x ϕ ⊢Σ
(∀R) Γ ⊢ϕ, ∆
Γ ⊢∀x ϕ, ∆
(x ̸∈FV (Γ, ∆))
(∃L) Γ, ϕ ⊢Σ
Γ, ∃x ϕ ⊢Σ
(x ̸∈FV (Γ, Σ))
(∃R)Γ ⊢ϕ[x := t], ∆
Γ ⊢∃x ϕ, ∆
To obtain intuitionistic sequent calculus we restrict ourselves to single for-
mulas at the right-hand sides (Σ consists of a single formula and ∆is always
empty).
(∀L)Γ, ϕ[x := t] ⊢σ
Γ, ∀x ϕ ⊢σ
(∀R) Γ ⊢ϕ
Γ ⊢∀x ϕ
(x ̸∈FV (Γ))
(∃L) Γ, ϕ ⊢σ
Γ, ∃x ϕ ⊢σ
(x ̸∈FV (Γ, σ))
(∃R)Γ ⊢ϕ[x := t]
Γ ⊢∃x ϕ
9.3.1. Theorem (Cut elimination). For all ϕ and Γ, if the sequent Γ ⊢ϕ
has a proof then it has a cut-free proof.
The following was probably ﬁrst shown by Rasiowa and Sikorski using
the topological space semantics, see [88].
9.3.2. Corollary (Existence property). If ⊢∃x ϕ then there exists a term t
such that ⊢ϕ[x := t].

148
Chapter 9. First-order logic
Proof. The last rule in a cut-free proof of ⊢∃x ϕ must be (∃R).
⊓⊔
Note that if the signature consists of relation symbols only (and thus the
only terms are variables) then ⊢∃x ϕ implies ⊢∀x ϕ !
Hilbert-style proofs
It is diﬃcult to ﬁnd two diﬀerent authors who would give identical Hilbert-
style proof systems.2 Our choice is as follows. We take as axioms all the
propositional axiom schemes, and in addition all formulas of the form:
• ∀x ϕ(x). →ϕ(t);
• ϕ(t) →∃x ϕ(x);
• ψ →∀x ψ, where x ̸∈FV (ψ);
• ∃x ψ. →ψ, where x ̸∈FV (ψ);
• ∀x(ϕ →ψ). →(∃x ϕ. →∃x ψ);
• ∀x(ϕ →ψ). →(∀x ϕ. →∀x ψ).
As inference rules of our system we take modus ponens and the following
generalization rule:
ϕ
∀x ϕ
The use of generalization requires some caution (corresponding to the side
conditions in rules (∀I) and (∀R)).
9.3.3. Definition. A formal proof of a formula ϕ from a set Γ of assump-
tions is a a ﬁnite sequence of formulas ψ1, ψ2, . . . , ψn, such that ψn = ϕ,
and for all i = 1, . . . , n, one of the following cases takes place:
• ψi is an axiom;
• ψi is an element of Γ;
• there are j, ℓ< i such that ψj = ψℓ→ψi (i.e., ψi is obtained from ψj,
ψℓusing modus ponens);
• there is j < i such that ψi = ∀x ψj, for some x ̸∈FV (Γ) (i.e., ψi is
obtained from ψj by generalization).
2Unless they are co-authors, of course.

9.3. Proof systems
149
9.3.4. Warning. In many textbooks, the above deﬁnition of a proof does
not include the restriction on applicability of the generalization rule. This
does not matter as long as Γ is a set of sentences (what is typically assumed).
In general however, this gives a diﬀerent relation ⊢◦
H, such that
Γ ⊢◦
H ϕ
iﬀ
Γ◦⊢H ϕ,
where Γ◦is obtained from Γ by binding all free variables by universal quanti-
ﬁers placed at the beginning of all formulas. For this relation, the deduction
theorem (see below) would only hold for Γ consisting of sentences.
9.3.5. Lemma (Deduction Theorem).
The conditions Γ, ϕ ⊢H ψ and Γ ⊢H ϕ →ψ are equivalent.
Proof. Easy.
⊓⊔
9.3.6. Theorem. Natural deduction, sequent calculus, and the above Hilbert-
style proof system are all equivalent, i.e., Γ ⊢N ϕ and Γ ⊢L ϕ and Γ ⊢H ϕ
are equivalent to each other for all Γ and ϕ.
Proof. Boring.
⊓⊔
Translations from classical logic
Double negation translations from classical to intuitionistic logic can be ex-
tended to the ﬁrst-order case. We add the following clauses to the deﬁnition
of the Kolmogorov translation of Chapter 8:
• t(∀x ϕ) := ¬¬∀x t(ϕ);
• t(∃x ϕ) := ¬¬∃x t(ϕ).
and we still have the following result:
9.3.7. Theorem. A formula ϕ is a classical theorem iﬀt(ϕ) is an intuition-
istic theorem.
Proof. Exercise 9.5.6
⊓⊔
Since classical provability reduces to intuitionistic provability, and classical
ﬁrst-order logic is undecidable, we obtain undecidability of intuitionistic
ﬁrst-order logic as a consequence.
9.3.8. Corollary. First-order intuitionistic logic is undecidable.
In fact, the undecidability result holds already for a very restricted frag-
ment of ﬁrst-order intuitionistic logic, with ∀and →as the only connectives
and with no function symbols. In particular, there is no need for negation
or falsity.

150
Chapter 9. First-order logic
9.4. Semantics
We begin with classical semantics. Assume that our signature Σ consists of
the function symbols f1, . . . , fn, relation symbols r1, . . . , rm and constant
symbols c1, . . . , ck.
9.4.1. Definition. A structure or model for Σ is an algebraic system A =
⟨A, fA
1 , . . . , fA
n , rA
1 , . . . , rA
m, cA
1 , . . . , cA
k ⟩, where the fA
i ’s and rA
i ’s are respec-
tively operations and relations over A (of appropriate arities) and the cA
i ’s
are distinguished elements of A.
9.4.2. Convention.
• Typical notational conventions are to forget about the superscript A in
e.g., fA, and to identify A and A. (Otherwise we may write A = |A|.)
• We think of relations in A as of functions ranging over the set {0, 1}
rather than of sets of tuples.
9.4.3. Definition.
1. Let t be a term with all free variables among ⃗x, and let ⃗a be a vector of
elements of A of the same length as ⃗x. We deﬁne the value tA(⃗a) ∈A
by induction:
• (xi)A(⃗a) = ai;
• (ft1 . . . tn)A(⃗a) = fA(tA
1 (⃗a), . . . , tA
n (⃗a)).
2. Let ϕ be a formula such that all free variables of ϕ are among ⃗x, and
let ⃗a be as before. We deﬁne the value ϕA(⃗a) ∈{0, 1}, as follows
• ⊥A(⃗a) = 0;
• (rt1 . . . tn)A(⃗a) = rA(tA
1 (⃗a), . . . , tA
n (⃗a));
• (ϕ ∨ψ)A(⃗a) = ϕA(⃗a) ∪ψA(⃗a);
• (ϕ ∧ψ)A(⃗a) = ϕA(⃗a) ∩ψA(⃗a);
• (ϕ →ψ)A(⃗a) = ϕA(⃗a) ⇒ψA(⃗a);
• (∀y ϕ(y, ⃗x))A(⃗a) = inf{ϕ(y, ⃗x)A(b,⃗a) : b ∈A};
• (∃y ϕ(y, ⃗x))A(⃗a) = sup{ϕ(y, ⃗x)A(b,⃗a) : b ∈A},
where the operations ∪, ∩, ⇒, inf and sup, and the constant 0 are in
the two-element Boolean algebra of truth values. (Of course, we have
a ⇒b = (1 −a) ∪b.) We write A,⃗a |= ϕ(⃗x) iﬀϕA(⃗a) = 1, and we
write A |= ϕ(⃗x) iﬀA,⃗a |= ϕ(⃗x), for all ⃗a. We write Γ |= ϕ iﬀfor all A
and ⃗a with A,⃗a |= ψ, for all ψ ∈Γ, we also have A,⃗a |= ϕ.

9.4. Semantics
151
The above deﬁnition can now be generalized so that values of formulas are
not necessarily in {0, 1}, but in the algebra P(X) of all subsets of a certain
set X. Relations over A may now be seen as functions ranging over P(X)
rather than {0, 1}, i.e., the notion of a structure is more general. One can go
further and postulate values of formulas in an arbitrary Boolean algebra B.
This will work as well, provided B is a complete algebra, i.e., all inﬁnite
sup’s and inf’s do exist in B. (Otherwise, values of some quantiﬁed formulas
could not be deﬁned.)
One can show that these generalizations do not change the class of clas-
sically valid statements of the form Γ |= ϕ (Exercise 9.5.7).
We do not
investigate this further, since classical logic serves us as an illustration only.
Algebraic semantics
An obvious idea how to adopt the above approach to intuitionistic logic is
to replace complete Boolean algebras by complete Heyting algebras.
9.4.4. Definition.
1. An intuitionistic H-structure for Σ is a system
A = ⟨A, fA
1 , . . . , fA
n , rA
1 , . . . , rA
m, cA
1 , . . . , cA
k ⟩,
where the fA
i ’s and rA
i ’s and cA
i ’s are as before, and the rA
i ’s are
functions of appropriate arity from A to a complete Heyting algebra H.
2. The values of terms and formulas are deﬁned as in Deﬁnition 9.4.3,
except that operations ∪, ∩, inf, sup and ⇒are in H.
3. The notation A,⃗a |= ϕ(⃗x) and A |= ϕ(⃗x) is as in Deﬁnition 9.4.3.
4. The notation Γ |= ϕ should be understood as follows: “For all H
and all H-structures A and vectors ⃗a, with A,⃗a |= Γ, we also have
A,⃗a |= ϕ”.
5. The symbol |=K is |= restricted to any given class K of complete Heyt-
ing algebras.
An example of a complete Heyting algebra is the algebra of open sets of a
topological space (in particular a metric space), where sup is set-theoretic S,
and
inf{Ai : i ∈I} = Int(T{Ai : i ∈I}).
9.4.5. Theorem.
The following conditions are equivalent for the intuitionistic ﬁrst-order
logic:
1. Γ ⊢ϕ, where “ ⊢” is either “ ⊢N” or “ ⊢L” or “ ⊢H”;

152
Chapter 9. First-order logic
2. Γ |= ϕ;
3. Γ |=K ϕ, where K is the class of (algebras of open sets of) all metric
spaces.
It seems to be still an open problem whether the class of all metric spaces
can be replaced by a one-element class consisting only of R2. But it can
be shown that there exists a single metric space of this property, see [88].
(Note however that R2 can still be used for counterexamples.)
Kripke semantics
An alternative way of relaxing the deﬁnition of classical semantics is to keep
the classical notion of a model, but think of models as of possible worlds.
9.4.6. Definition. A structure A = ⟨A, fA
1 , . . . , fA
n , rA
1 , . . . , rA
m, cA
1 , . . . , cA
k ⟩
is a substructure of B = ⟨B, fB
1 , . . . , fB
n , rB
1 , . . . , rB
m, cB
1 , . . . , cB
k ⟩iﬀthe follow-
ing hold:
• A ⊆B;
• rA
i ⊆rB
i , for all i;
• fA
i ⊆fB
i , for all i;
• cA
i = cB
i , for all i.
Thus, B extends the possible world A by enriching the domain of available
objects and by adding more information about known objects. We write
A ⊆B to express that A is a substructure of B.
9.4.7. Definition. A Kripke model for ﬁrst-order logic is a triple of the
form C = ⟨C, ≤, {Ac : c ∈C}⟩, where C is a non-empty set, ≤is a partial
order in C, and Ac’s are structures such that
if c ≤c′ then Ac ⊆Ac′.
Let now ϕ be a formula such that all free variables of ϕ are among ⃗x, and
let ⃗a be a vector of elements of Ac of the same length as ⃗x. We deﬁne the
relation ⊩by induction as follows:
• c,⃗a ⊩rt1 . . . tn iﬀAc,⃗a |= rt1 . . . tn (classically);
• c,⃗a ⊮⊥;
• c,⃗a ⊩ϕ ∨ψ
iﬀ
c,⃗a ⊩ϕ or c,⃗a ⊩ψ;
• c,⃗a ⊩ϕ ∧ψ
iﬀ
c,⃗a ⊩ϕ and c,⃗a ⊩ψ;

9.5. Exercises
153
• c,⃗a ⊩ϕ →ψ
iﬀ
c′,⃗a ⊩ψ, for all c′ such that c ≤c′ and c′,⃗a ⊩ϕ;
• c,⃗a ⊩∃y ϕ(y, ⃗x)
iﬀ
c, b,⃗a ⊩ϕ(y, ⃗x), for some b ∈Ac;
• c,⃗a ⊩∀y ϕ(y, ⃗x)
iﬀ
c′, b,⃗a ⊩ϕ(y, ⃗x), for all c′ such that c ≤c′ and
all b ∈Ac′.
The symbol ⊩is now used in various contexts as usual, in particular Γ ⊩ϕ
means that c,⃗a ⊩ϕ whenever c,⃗a ⊩Γ.
9.4.8. Theorem. The conditions Γ ⊩ϕ and Γ |= ϕ are equivalent.
More about semantics can be found in [88, 106, 107, 108].
9.5. Exercises
9.5.1. Exercise. Find constructions for formulas (1), (3), (5), (7), (9) and (11)
of Example 9.2.1, and do not ﬁnd constructions for the other formulas.
9.5.2. Exercise. A ﬁrst-order formula is in prenex normal form iﬀit begins
with a sequence of quantiﬁers followed by an open formula.
Consider a
signature with no function symbols, and let ϕ be an intuitionistic theorem
in a prenex normal form. Show that there exists an open formula ϕ′ obtained
from ϕ by removing quantiﬁers and by replacing some variables by constants,
and such that ⊢ϕ′. Hint: Use the existence property (Corollary 9.3.2).
9.5.3. Exercise (V.P. Orevkov). Apply Exercise 9.5.2 to show that the prenex
fragment of intuitionistic ﬁrst-order logic over function-free signatures is
decidable.
(In fact, this remains true even with function symbols in the
signature, but fails for logics with equality, see [29]).
9.5.4. Exercise. Prove that every ﬁrst-order formula is classically equiv-
alent to a formula in prenex normal form. Then prove that intuitionistic
ﬁrst-order logic does not have this property.
9.5.5. Exercise. Show that the existence property (Corollary 9.3.2) does
not hold for classical logic. Why does the proof break down in this case?
9.5.6. Exercise. Prove Theorem 9.3.7.
9.5.7. Exercise. Let X be an arbitrary set with more than one element.
Show that the semantics of classical logic where values of formulas are taken
in the family P(X) of all subsets of X is equivalent to the ordinary semantics.
That is, the sets of tautologies are the same.
9.5.8. Exercise. Verify that the odd-numbered formulas of Example 9.2.1
are intuitionistically valid, while the even-numbered ones are not.

154
Chapter 9. First-order logic
9.5.9. Exercise. Show that the following classical ﬁrst-order tautologies are
not valid intuitionistically:
• ∃x(ϕ(x) →∀x ϕ(x));
• ∃x(ϕ(0) ∨ϕ(1) →ϕ(x));
• ∀x ¬¬ϕ(x). ↔¬¬∀x ϕ(x);
• ∃x ¬¬ϕ(x). ↔¬¬∃x ϕ(x).
9.5.10. Exercise. A Kripke model C = ⟨C, ≤, {Ac : c ∈C}⟩has constant
domains iﬀall the Ac are the same. Prove that the formula ∀x(ψ ∨ϕ(x)) ↔
ψ ∨∀x ϕ(x), where x ̸∈FV (ψ) (formula (6) of Example 9.2.1) is valid in all
models with constant domains.
9.5.11. Exercise. Prove that the formula ¬¬∀x(ϕ ∨¬ϕ) (formula (10) of
Example 9.2.1) is valid in all Kripke models with ﬁnite sets of states.

CHAPTER 10
Dependent types
Dependent types can probably be considered as old as the whole idea of
propositions-as-types. Explicitly, dependent types were perhaps ﬁrst used
in various systems aimed at constructing and verifying formal proofs. One of
the ﬁrst was the project AUTOMATH of de Bruijn, see [28]. Another such
system that gained much attention is the Edinburgh Logical Framework (LF)
of Harper, Honsell and Plotkin [51]. The expression “logical frameworks”
is now used as a generic name for various similar calculi, see [59]. Last but
not least, one should mention here Martin-L¨of’s type theory [77]. For more
references, see [108, 51, 8].
Our presentation of dependent types follows
essentially that of [8].
From a programmer’s point of view, a dependent type is one that depends
on an object value. For instance, one may need to introduce a type string(n)
of all binary strings of length n.1 This type depends on a choice of n : int.
The operator string makes a type from an integer, and corresponds, under
the Curry-Howard isomorphism, to a predicate over int. Such a predicate
is called a type constructor, or simply constructor. Of course, we have to
classify constructors according to their domains, and this leads to the notion
of a kind: we say that our constructor string is of kind int ⇒∗, where ∗is the
kind of all types. Of course, there is no reason to disallow binary predicates,
and so on, and thus the family of kinds should include τ1 ⇒· · · τn ⇒∗.
A deﬁnition of an object of type string(n) may happen to be uniform
in n, i.e., we may have a generic procedure Onlyzeros that turns any n : int
into a string of zeros of length n. The type of such a procedure should be
written as (∀x:int)string(x).
In general, a type of the form (∀x:τ)σ is a type of a function applicable
to objects of type τ and returning an object of type σ[x := a], for each
argument a : τ. It is not diﬃcult to see that this idea is more general than
the idea of a function type. Indeed, if x is not free in σ, then (∀x:τ)σ behaves
1Example from [74].
155

156
Chapter 10. Dependent types
exactly as τ →σ. Thus, in presence of dependent types there is no need to
introduce →separately.
The set-theoretic counterpart of a dependent type is the product. Recall
that if {At}t∈T is an indexed family of sets (formally a function that assigns
the set At to any t ∈T)2 then the product of this family is the set:
Y
t∈T
At = {f ∈(
[
t∈T
At)T : f(t) ∈At, for all t ∈T}.
For f ∈Q
t∈T At, the value of f(t) is in a set At, perhaps diﬀerent for each
argument, rather than in a single co-domain A. If all At are equal to a ﬁxed
set A, we obtain the equality
Y
t∈T
At = AT ,
corresponding to our previous observation about →versus ∀.
The logical counterpart of this should now be as follows: the implication
is a special case of universal quantiﬁcation. And that is correct, because we
have already agreed to identify objects of type τ with proofs of τ. We only
have to agree that this way of thinking applies to individual objects as well,
so that, for instance, an integer can be seen as a proof of int.
10.1. System λP
We will now deﬁne the Church-style system λP of dependent types. We
begin with a calculus without existantial quantiﬁcation, as in [8]. Unfortu-
nately, even without existantial quantiﬁers, the language of λP is a broad
extension of the language of simply-typed lambda-calculus. We have three
sorts of expressions: object expressions (ranged over by M, N, etc.), con-
structors (ranged over by τ, ϕ, etc.) and kinds (ranged over by κ, κ′, etc.).
There are object and constructor variables (ranged over by x, y, . . . and
α, β, . . . , respectively), and one kind constant ∗. A type is treated as a
special case of a constructor, so we do not need extra syntax for types.
Contexts can no longer be arbitrary sets of assumptions. This is because
in order to declare a variable of type e.g., αx, one has to know before that
the application is legal, i.e., that the type of x ﬁts the kind of α. Thus,
contexts in λP are deﬁned as sequences of assumptions. In addition, not
every sequence of declarations can be regarded as a valid context, and being
valid or not depends on derivability of certain judgements.
For similar reasons, being a constructor or a kind, also depends on deriv-
able judgements. Well-formed types, kinds and contexts are thus formally
deﬁned by the rules of our system.
2That is why we do not use here the set notation {At : t ∈T}.

10.1. System λP
157
Unfortunately, we cannot stick to ⇒as the only way to build kinds, and
we have to introduce a more general product operator also at the level of
kinds. To understand why, see Example 10.2.3(2).
10.1.1. Definition.
1. Raw expressions (raw contexts Γ, raw kinds κ, raw constructors φ and
raw lambda-terms M) are deﬁned by the following grammar:
Γ ::= {} | Γ, (x : φ) | Γ, (α : κ);
κ ::= ∗| (Πx : φ)κ;
φ ::= α | (∀x:φ)φ | (φM);
M ::= x | (MM) | (λx:φ.M).
2. Beta reduction on raw terms is deﬁned as follows:
• (λx:τ.M)N →β M[N := x];
• If τ →β τ ′ then λx:τ.M →β λx:τ ′.M;
• If M →β M′ then λx:τ.M →β λx:τ.M′ and NM →β NM ′ and
MN →β M′N;
• If τ →β τ ′ then (Πx : τ)κ →β (Πx : τ ′)κ;
• If κ →β κ′ then (Πx : τ)κ →β (Πx : τ)κ′;
• If τ →β τ ′ then (∀x:τ)σ →β (∀x:τ ′)σ;
• If σ →β σ′ then (∀x:τ)σ →β (∀x:τ)σ′;
• If ϕ →β ϕ′ then ϕM →β ϕ′M;
• If M →β M′ then ϕM →β ϕM′.
3. If (x : τ) or (α : κ) is in Γ then we write Γ(x) = τ or Γ(α) = κ,
respectively. We also write Dom(Γ) for the set of all constructors and
object variables declared in Γ.
4. We skip the obvious deﬁnition of free variables. Of course, there are
three binding operators now: lambda-abstraction, quantiﬁcation and
the product of kinds. And we also omit the deﬁnition of substitution.
5. We use arrows as abbreviations: if x is not free in κ then we write
τ ⇒κ instead of (Πx : τ)κ. And if x is not free in σ then (∀x:τ)σ is
abbreviated by our good old implication τ →σ.
10.1.2. Remark. In order to spare the reader some additional noise, we
choose a non-standard presentation of λP, namely we do not allow lambda
abstractions in constructors. Thus, every constructor must be of the form
(∀x:τ1) · · · (∀x:τn)αM1 . . . Mn. This restriction is not essential as long as our
primary interest is in types. Indeed, a dependent type in normal form always
obeys this pattern, and a term substitution may never create a constructor
redex.

158
Chapter 10. Dependent types
We will have three diﬀerent sorts of judgements in our system:
• kind formation judgements of the form “Γ ⊢κ : 2”;
• kinding judgements of the form “Γ ⊢ϕ : κ”;
• typing judgements of the form “Γ ⊢M : τ”.
The meaning of “κ : 2” is just that κ is a well-formed kind, and 2 itself is
not a part of the language.
10.2. Rules of λP
Kind formation rules:
⊢∗: 2
Γ, x : τ ⊢κ : 2
Γ ⊢(Πx:τ)κ : 2
Kinding rules:
Γ ⊢κ : 2
Γ, α : κ ⊢α : κ
(α ̸∈Dom(Γ))
Γ ⊢ϕ : (Πx:τ)κ
Γ ⊢M : τ
Γ ⊢ϕM : κ[x := M]
Γ, x : τ ⊢σ : ∗
Γ ⊢(∀x:τ)σ : ∗
Typing rules:
Γ ⊢τ : ∗
Γ, x : τ ⊢x : τ
(x ̸∈Dom(Γ))
Γ ⊢N : (∀x:τ)σ
Γ ⊢M : τ
Γ ⊢NM : σ[x := M]
Γ, x : τ ⊢M : σ
Γ ⊢λx:τ.M : (∀x:τ)σ
Note that there is no restriction “x ̸∈FV(Γ)” attached to the ∀-introduction
rule. This restriction is unnecessary because otherwise Γ, x : τ would not be
a valid context, in which case the premise could not be derived.
Weakening rules:
There are six weakening rules, but all obey the same pattern: an additional
assumption does not hurt, as long as it is well-formed. We need explicit
wekening (rather than relaxed axioms) because of the sequential structure
of contexts we must respect.
Γ ⊢τ : ∗
Γ ⊢κ : 2
Γ, x : τ ⊢κ : 2
(x ̸∈Dom(Γ)) Γ ⊢κ : 2
Γ ⊢κ′ : 2
Γ, α : κ ⊢κ′ : 2
(α ̸∈Dom(Γ))

10.3. Properties of λP
159
Γ ⊢τ : ∗
Γ ⊢ϕ : κ
Γ, x : τ ⊢ϕ : κ
(x ̸∈Dom(Γ)) Γ ⊢κ : 2
Γ ⊢ϕ : κ′
Γ, α : κ ⊢ϕ : κ′
(α ̸∈Dom(Γ))
Γ ⊢τ : ∗
Γ ⊢M : σ
Γ, x : τ ⊢M : σ
(x ̸∈Dom(Γ)) Γ ⊢κ : 2
Γ ⊢M : σ
Γ, α : κ ⊢M : σ
(α ̸∈Dom(Γ))
Conversion rules
These rules are necessary because of the terms occurring in types which do
not have to be in normal forms.
Γ ⊢ϕ : κ
κ =β κ′
Γ ⊢ϕ : κ′
Γ ⊢M : σ
σ =β σ′
Γ ⊢M : σ′
10.2.1. Remark. Note that type-checking in λP is not a trivial task, even
if our language is Church-style. This is because the conversion rules. A
veriﬁcation whether two types or kinds are equal may be as diﬃcult as
checking equality of simply-typed lambda terms, and this decision problem
is non-elementary (Theorem 6.7.1).
10.2.2. Definition.
If Γ ⊢τ : ∗then we say that τ is a type in the context Γ.
10.2.3. Example.
1. The lambda term λy:(∀x:0.αx →βx).λz:(∀x:0.αx).λx:0.yx(zx) has
type (∀x:0.αx →βx) →(∀x:0.αx) →∀x:0.βx in the context consisting
of declarations α : 0 ⇒∗and β : 0 ⇒∗.
2. Here is an example of a kind that cannot be expressed only with ⇒:
α : 0 ⇒∗⊢(Πy:0)(αy ⇒∗) : 2
If we now declare a variable ϕ to be of this kind, we can consider types
of the form ϕyx, where x is of type αy.
10.3. Properties of λP
System λP has the Church-Rosser and strong normalization properties.
These facts follow from properties of simply typed terms, thanks to an
embedding M 7→M•, described in [51]. Certain variants of this embed-
ding (esp. the “forgetting map” M 7→M, which erases all dependencies)
were also discovered by V. Breazu-Tannen and Ch. Paulin, but apparently
R.O. Gandy was the ﬁrst to use this approach (see [108, p. 565]).

160
Chapter 10. Dependent types
10.3.1. Definition. We deﬁne the dependency-erasure map on construc-
tors:
α = α;
(∀x : τ)σ = τ →σ;
ϕM = ϕ.
We write Γ for the contexts obtained by applying the above operation to all
right-hand sides of declarations in Γ of the form (x : τ), and removing other
declarations.
10.3.2. Definition. The translations M 7→M• and τ 7→τ • are deﬁned
for both types and terms of λP. Both terms and types are translated into
terms. Below, 0 stands for a ﬁxed type variable. Abusing the formalism a
little, we assume that we can use as many fresh term variables as we want.
(αM1 . . . Mn)• = xαM•
1 . . . M•
n, where xα is a fresh variable;
((∀x:τ)σ)• = xττ •(λx:τ.σ•), where xτ is a fresh variable;
x• = x;
(MN)• = M•N•;
(λx:τ.M)• = (λy:0λx:τ.M•)τ •, where y is a fresh variable.
10.3.3. Lemma.
1. If Γ ⊢τ : ∗then Γ
′ ⊢τ • : 0, for some extension Γ′ of Γ.
2. If Γ ⊢M : τ then Γ
′ ⊢M• : τ, for some extension Γ′ of Γ.
3. If Γ ⊢M : τ and M →β M1 then M• →
→β M•
1 in at least one step.
Proof. Exercise 10.7.2.
⊓⊔
10.3.4. Corollary (Strong normalization).
The system λP has the strong normalization property.
Proof. By part (3) of Lemma 10.3.3, an inﬁnite reduction starting from M
would be translated to an inﬁnite reduction in the simply-typed lambda
calculus.
⊓⊔
10.3.5. Corollary. The system λP has the Church-Rosser property.
Proof. Exercise 10.7.5.
⊓⊔

10.4. Dependent types `a la Curry
161
10.4. Dependent types `a la Curry
10.4.1. Definition. We deﬁne a type-erasure mapping |·| from terms of λP
to pure lambda terms, as usual:
• |x| = x;
• |λx:τ.M| = λx.|M|;
• |MN| = |M||N|.
For a a pure lambda term N, we write Γ ⊢P N : τ iﬀN = |M|, for some
Church-style term M with Γ ⊢M : τ. We say that a pure lambda term N
is typable iﬀΓ ⊢P N : τ holds for some Γ, τ.
An alternative to the above deﬁnition is to deﬁne a type assignment
system for pure lambda-terms, corresponding to λP. Note that in this case
we must deal with diﬀerent notion of a type, since types must depend on
pure lambda-terms rather than on Church-style terms. It follows that the
type-erasure mapping must be extended to types and kinds. Fortunately,
the notion of a typable term is the same with this approach as with our
simple deﬁnition, see [5].
10.4.2. Proposition. The Curry-style variant of λP has the subject-reduction
property, that is if Γ ⊢P N : τ and N →
→β N′ then also Γ ⊢P N′ : τ.
Proof. Boring. See [5].
⊓⊔
Let us come back to the dependency-erasure map. We extend it to terms
as follows:
10.4.3. Definition.
x = x;
MN = M N;
λx:τ.M = λx:τ.M;
We have the following result:
10.4.4. Lemma. If Γ ⊢M : τ then Γ ⊢M : τ (in λ→).
Proof. Exercise 10.7.3.
⊓⊔
10.4.5. Proposition. A term is typable in λP iﬀit is simply-typable. In
particular, the type reconstruction problem for λP is decidable in polynomial
time.

162
Chapter 10. Dependent types
Proof. Suppose that Γ ⊢M : τ in λP.
By Lemma 10.4.4, we have
Γ ⊢M : τ, in the simply typed lambda calculus. But it is easy to see that
|M| = |M|.
We have just shown that all pure terms typable in λP are typable in
simple types. The converse is obvious, and thus type reconstruction in λP
is the same as in simple types.
⊓⊔
Here comes the surprise: it is not at all that easy with type checking!
10.4.6. Theorem (G. Dowek [31]). Type checking in the Curry-style ver-
sion of λP is undecidable.
No Proof. We regret that we do not have enough time to present this nice
proof. But we recommend reading the original paper [31].
⊓⊔
10.5. Existential quantiﬁcation
This section is a diggression. The system λP, as most other typed lambda-
calculi, is normally studied with ∀and →as the only basic connectives. Of
course, an extension of this system with ∨, ∧and ⊥can be deﬁned in much
the same way as for the simply-typed lambda calculus. It remains to see
what is the lambda calculus counterpart of existential quantiﬁcation. The
intuition suggests that (∃x:τ) ϕ(x) should be understood as a disjoint union
or coproduct of types ϕ(a), for all objects a of type τ. That is, objects of
type (∃x:τ) ϕ(x) are pairs consisting of an object a of type τ and a proof M
of ϕ(a). This may be syntactically written as: pack M, a to (∃x:τ) ϕ(x).
An elimination operator for type (∃x:τ) ϕ(x) takes such a pair and uses
it whenever an object of type ϕ(x) can be used with an unspeciﬁed x. This
leads to the following deduction rules:
(∃I)
Γ ⊢M : ϕ[x := N]
Γ ⊢N : τ
Γ ⊢pack M, N to (∃x:τ) ϕ : (∃x:τ) ϕ
(∃E)Γ ⊢M : (∃x:τ) ϕ
Γ, x : τ, z : ϕ ⊢N : ψ
Γ ⊢let z : ϕ be M : (∃x:τ) ϕ in N : ψ
(x ̸∈FV (Γ, ψ))
Note that although ψ in (∃E) cannot contain x free, this restriction does
not extend to the proof N. The variable x may thus be free in N, but it
should be considered bound in the let expression.
The reduction rule for sum types is as follows:
let z : ϕ be (pack M, N to (∃x:τ) ϕ) in Q −→β Q[x := N][z := M]
Everything is ﬁne with this rule, as long as we do not get seduced by the
temptation of making a Curry-style calculus with existential quantiﬁers.
Look, how beautiful rules we may have:

10.6. Correspondence with ﬁrst-order logic
163
(∃I)Γ ⊢M : ϕ[x := N]
Γ ⊢N : τ
Γ ⊢M : (∃x:τ) ϕ
(∃E)Γ ⊢M : (∃x:τ) ϕ
Γ, z : ϕ ⊢N : ψ
Γ ⊢N[z := M] : ψ
(x ̸∈FV (Γ, ψ))
These rules are based on the idea of existential polymorphism: a term of
an existential type is like an object with some data being abstracted or
encapsulated or “private”, and not available for external manipulations. It
seems very appealing that this sort of abstraction might be done with only
implicit typing discipline.
There are however some annoying little diﬃculties when one attempts
to prove the subject reduction property for a type inference system ⊢∃with
rules as above. Some of these diﬃculties can be eliminated by improving
the rules, but some cannot. The following example is based on an idea used
in [6] for union types (which cause similar problems).
10.5.1. Example. Consider a context Γ with the following declarations:
0 : ∗,
α : ∗,
β : ∗,
σ : 0 ⇒∗,
x : 0,
X : σx →σx →α,
Y : β →(∃x:0)σx,
Z : β.
Then Γ ⊢∃X(IY Z)(IY Z) : α, but Γ ̸⊢∃X(IY Z)(Y Z) : α.
10.6. Correspondence with ﬁrst-order logic
The system λP of dependent types is much stronger than is needed to provide
a term assignment for ﬁrst-order intuitionistic logic. In fact, ﬁrst-order logic
corresponds to a fairly weak fragment of λP. This fragment is obtained by
restricting the syntax3 so that each context must satisfy the following:
• There is only one type variable 0 (which should be regarded as a type
constant), representing the type of individuals;
• All kinds are of the form 0 ⇒· · · ⇒0 ⇒∗;
• There is a ﬁnite number of distinguished constructor variables, repre-
senting relation symbols in the signature (they must be of appropriate
kinds, depending on arity);
• Function symbols in the signature are represented by distinguished
object variables of types 0 →· · · →0 →0, depending on arity;
• Constant symbols are represented by distinguished object variables of
type 0;
3Of course one has to either add ∃to λP, as in the previous section, or to consider only
universal quantiﬁcation in formulas.

164
Chapter 10. Dependent types
• Other declarations in the context may only be of the form (x : 0), and
correspond to individual variables.
Clearly, algebraic terms are represented now by lambda terms of type 0
in normal form.
Formulas are represented by types.
Because of strong
normalization, we can restrict attention to formulas containing only terms
in normal form.
It follows that an inhabited formula is a theorem and
conversely. The reader is invited to formally deﬁne the syntax of the ﬁrst-
order fragment (Exercise 10.7.9).
In summary, we have the following pairs of corresponding items:
formulas
∼
types
proofs
∼
terms
domain of individuals
∼
type constant 0
algebraic terms
∼
terms of type 0
relations
∼
constructors of kind
0 ⇒0 ⇒· · · ⇒0 ⇒∗
atomic formula r(t1, . . . , tn)
∼
dependent type rt1 . . . tn : ∗
universal formula
∼
product type
proof by generalization
∼
abstraction λx : 0.Mϕ
proof by modus ponens
∼
application M∀x:0 ϕN0
10.6.1. Example. Consider the Hilbert-style axioms of Section 9.3 Each of
them corresponds to a type in λP, extended by existential quantiﬁcation as
in Section 10.5. These types are inhabited as follows. (We write types as
upper indices to improve readability.)
• λY (∀x:0)ϕ(x).Y t : (∀x:0)ϕ(x). →ϕ(t);
• λXϕ(t).pack X, t to (∃x:0)ϕ(x) : ϕ(t) →(∃x:0)ϕ(x);
• λY ψλx0.Y : ψ →(∀x : 0) ψ, where x ̸∈FV (ψ);
• λY (∃x:0)ψ.let z:ψ be Y :(∃x:0)ψ in z : (∃x:0)ψ. →ψ,
where x ̸∈FV (ψ);
• λX(∀x:0)(ϕ→ψ)λY (∃x:0)ϕ.let zϕ be Y :(∃x:0)ϕ in pack Xxz, x to (∃x:0)ϕ :
(∀x:0)(ϕ →ψ). →((∃x:0)ϕ. →(∃x:0)ψ);
• λX(∀x:0)(ϕ→ψ)λY (∀x:0)ϕλz0.Xz(Y z) : (∀x:0)(ϕ →ψ). →((∀x:0)ϕ. →
(∀x:0)ψ).
Out of the above six examples three do not use existential quantiﬁcation.
If we apply the dependency-erasing translation M 7→M to the third and
sixth of the above terms, we obtain the typed combinators
• K : ψ →0 →ψ and

10.7. Exercises
165
• S : (0 →ϕ →ψ) →(0 →ϕ) →0 →ψ.
This may be a suprise on the ﬁrst look that we obtain something so much
familiar. But it is fully justiﬁed by the fact that universal quantiﬁcation is
a generalization of implication.
The ﬁrst example is a little less spectacular, as it erases to λY 0→ϕ.Y t :
(0 →ϕ) →ϕ (parameterized by t : 0).
The above embedding of ﬁrst-order logic into λP can easily be generalized
to various extensions. For instance, many-sorted logic is handled just by
allowing more than one atomic type.
Here are some examples of other
features that are not present in ﬁrst-order logic:
• There are sorts (types) for many domains for individuals, and also for
functions on the individuals;
• There is a function abstraction mechanism (we deal with lambda-terms
rather than algebraic terms);
• Quantiﬁcation over functions is permitted; a quantiﬁer ranges over
arbitrary expressions of a given sort;
• Proofs are terms, so that properties of proofs can be expressed by
formulas.
The presence of quantiﬁcation over objects of all ﬁnite types means that
λP can express many higher-order languages (see [51]).
We would how-
ever prefer not to use the expression “higher-order logic” here, as there is
no quantiﬁcation over propositions. A more adequate statement about λP
is that it provides a many-sorted ﬁrst-order representation of higher-order
logic.
Another issue is expressibility of ﬁrst-order theories in λP. You can ﬁnd
more about this in [8, p. 202].
As we have already observed, ﬁrst-order intuitionistic logic is undecid-
able. Thus type inhabitation in the corresponding fragment of λP must be
also undecidable. But λP can be shown conservative over this fragment, and
it follows that type inhabitation for the whole system is also undecidable.
Another direct and simple proof can be found in [13].
10.6.2. Theorem. Type inhabitation in λP is undecidable.
⊓⊔
10.7. Exercises
10.7.1. Exercise. Let string(n) be the type of binary strings of length n.
Every such string w determines a record type with integer and boolean
ﬁelds corresponding to the digits in w.
For example, for 01101 we take

166
Chapter 10. Dependent types
int ∧bool ∧bool ∧int ∧bool. Deﬁne an appropriate context Γ declaring
variables string and record so that record(n)(w) is a well-formed type, for
n : int and w : string(n).
10.7.2. Exercise. Prove Lemma 10.3.3.
(First extend the translation to
kinds and deﬁne Γ′. A substitution lemma will also be necessary.)
10.7.3. Exercise. Prove Lemma 10.4.4. Also prove that Γ ⊢M : τ and
M →β M′ implies M →β M
′ or M = M′.
10.7.4. Exercise. Consider the following attempt to prove strong normal-
ization for λP:
Assume ﬁrst that a term M is such that no type occurring in M contains a lambda
term.
In this case an inﬁnite reduction starting from M would be translated,
by Lemma 10.4.4, to an inﬁnite reduction in the simply-typed lambda calculus.
The general case follows from the following induction step: If all subterms of M
(including all terms occurring in types in M) are strongly normalizing then M
is strongly normalizing. To prove the induction step, we observe that an inﬁnite
reduction starting from M translates to a sequence of pure terms Ni, with Ni = Nj,
for all i, j > i0. Thus our inﬁnite reduction must, from some point on, consist
exclusively of reduction steps performed exclusively within types. But all terms
occurring in types are obtained from subterms of the original term M and thus
must strongly normalize by the induction hypothesis.
Find the bug in this proof. Can you ﬁx it?4
10.7.5. Exercise. Prove the Church-Rosser property for λP (Corollary 10.3.5).
Warning: do ﬁrst Exercise 10.7.6. Hint: Apply Newman’s Lemma.
10.7.6. Exercise. Show an example of λP terms M and M′ of the same
type such that M = M
′, but M ̸=β M′.
10.7.7. Exercise. The proof technique that fails for Church-style λP (Exer-
cise 10.7.4) works for the Curry-style terms. Prove strong normalization for
Curry-style λP with help of the dependency-erasing translation M 7→M.
10.7.8. Exercise. Verify the correctness of Example 10.5.1.
10.7.9. Exercise. Deﬁne formally the fragment of λP corresponding to ﬁrst-
order logic over a ﬁxed signature.
10.7.10. Exercise. Consider the odd-numbered formulas of Example 9.2.1,
as types in an appropriate extension of λP. Write lambda-terms inhabiting
these types. (If necessary use operators related to conjunction, disjunction,
and the existential quantiﬁer.)
4We do not know how.

10.7. Exercises
167
10.7.11. Exercise. We know that types of K and S are suﬃcient to ax-
iomatize the arrow-only fragment of propositional intuitionistic logic. These
types correspond to the third and sixth axiom of Section 9.3 (see Exam-
ple 10.6.1). One can thus conjecture that the ﬁrst axiom ∀x ϕ(x). →ϕ(t),
which becomes (0 →ϕ) →ϕ after erasing dependencies, can be eliminated
from the axiom system. Show that this conjecture is wrong: our formula
cannot be derived from the other two axiom schemes.

168
Chapter 10. Dependent types

CHAPTER 11
First-order arithmetic and G¨odel’s T
Arithmetic is the core of almost all of mathematics. And expressing and
proving properties of integers always was one of the primary goals of math-
ematical logic. In this chapter, we will trace the Curry-Howard correspon-
dence back to the 40’s and 50’s, to discover it in some fundamental works of
Kleene and G¨odel. Both these works aimed at proving consistency of Peano
Arithmetic. For this purpose they give some fundamental insights on the
constructive contents of arithmetical proofs.
11.1. The language of arithmetic
The signature (cf. Deﬁnition 6.6) of ﬁrst-order arithmetic consists of two
binary function symbols + and ·, two constant symbols 0 and 1 and the sym-
bol = for equality.1 The standard model of arithmetic is the set of integers
N with the ordinary understanding of these symbols, i.e., the structure:
N = ⟨N, +, ·, 0, 1, =⟩.
Note that all elements of N can be given names in the language of arithmetic.
Let n denote the term 1 + 1 + · · · + 1, with exactly n copies of 1 (assuming
that 0 is 0).
By Th(A) we denote the set of all ﬁrst-order sentences that are classically
true in A (i.e., the set of all sentences ϕ such that A |= ϕ, in the sense of
Section 9.4). The following classical result shows the limitation of ﬁrst-order
logic:
11.1.1. Theorem. There exists a nonstandard model of arithmetic, i.e., a
structure M = ⟨M, ⊕, ⊗, 0, 1, =⟩, such that Th(M) = Th(N), but M and
N are not isomorphic.
1Another typical choice is to take a unary function symbol s for the successor function,
instead of 1.
169

170
Chapter 11. First-order arithmetic and G¨odel’s T
The above fact is a consequence of compactness theorem, see [71].
However, the deﬁnitional strength of ﬁrst-order formulas over the stan-
dard model is quite nontrivial. Let us say that a k-ary relation r over N
is arithmetical iﬀthere exists a formula ϕ(⃗x) with k free variables ⃗x, such
that, for every ⃗n ∈Nk:
r(⃗n) holds
iﬀ
N |= ϕ(⃗n).
A function is arithmetical iﬀit is arithmetical as a relation. We have the
following theorem of G¨odel:
11.1.2. Theorem. All partial recursive functions (in particular all recursive
functions) are arithmetical.
In fact, partial recursive functions and relations are just the very beginning
of the “arithmetical hierarchy”.
The above theorem implies in paricular
that Th(N) must be undecidable. Otherwise, membership in every r.e. set
would be also decidable.
11.2. Peano Arithmetic
Before G¨odel, people thought that it could be possible to axiomatize Th(N),
i.e., to give a simple set of axioms A such that all sentences of Th(N)
would be consequences of A. Peano Arithmetic, abbreviated PA, is such an
attempt. The axioms of PA are the following formulas:
• ∀x (x = x);
• ∀x∀y (x = y →y = x);
• ∀x∀y (ϕ(x) →x = y →ϕ(y));
• ∀x¬(x + 1 = 0);
• ∀x∀y (x + 1 = y + 1 →x = y);
• ∀x (x + 0 = x);
• ∀x∀y (x + (y + 1) = (x + y) + 1);
• ∀x (x · 0 = 0);
• ∀x∀y (x · (y + 1) = (x · y) + x);
• ∀x (ϕ(x) →ϕ(x + 1)). →ϕ(0) →∀x ϕ(x)).

11.2. Peano Arithmetic
171
The third and the last items are actually axiom schemes, not single axioms.
Although the set of axioms is thus inﬁnite, it is still recursive, and thus the
set of theorems (derivable sentences) of PA is r.e. The last axiom scheme is
called the induction scheme.
A theory T (a set of sentences) is complete iﬀfor all sentences ψ of
the ﬁrst-order language of T, either T ⊢ψ or T ⊢¬ψ. G¨odel’s famous
incompleteness theorem asserts that PA is not a complete theory.
This
statement is equivalent to PA ̸= Th(N), because every Th(A) is complete.
The importance of G¨odel’s theorem is that it holds also for all extensions
of PA, as long as they are eﬀectively axiomatizable. (A consequence of this
is of course that Th(N) is not r.e.)
11.2.1. Theorem (G¨odel incompleteness). There is a sentence Z such that
neither PA ⊢Z nor PA ⊢¬Z.
Proof. The proof of the theorem is so beautiful that we cannot resist the
temptation to sketch here the main idea, which is to express the “liar para-
dox”2 in the language of arithmetic. This cannot be done in full, as it would
imply inconsistency of arithmetic, but a weaker property will do. G¨odel’s
sentence Z expresses the property “Z has no proof in PA”. More formally,
we have:
N |= Z
iﬀ
PA ̸⊢Z.
Now if PA ⊢Z then N |= Z, because N is a model of PA, and thus PA ̸⊢Z.
On the other hand, if PA ⊢¬Z then N |= ¬Z, but also N |= Z, by the
property of Z. Thus Z can be neither proved nor disproved within PA.
The construction of Z is based on the idea of G¨odel numbering. Each
expression in the language gets a number, and we can write formulas express-
ing properties of expressions by referring to their numbers. In particular,
one can write a formula T(x, y), such that:
N |= T(n, m)
iﬀ
PA ⊢ϕn(m)
whenever n is a number of a formula ϕn(x) with one free variable x. The
formula ¬T(x, x) must also have a number, say ¬T(x, x) = ϕk(x). Thus
N |= ϕk(n)
iﬀ
PA ̸⊢ϕn(n).
The formula Z that says “I have no proof!” can now be deﬁned as ϕk(k):
N |= ϕk(k)
iﬀ
PA ̸⊢ϕk(k).
⊓⊔
2The sentence: “This sentence is false” cannot be true and cannot be false.

172
Chapter 11. First-order arithmetic and G¨odel’s T
It was a popular opinion among mathematicians that G¨odel’s theorem is of
little practical importance. Indeed, the formula Z is based on an artiﬃcial
diagonalization, and everything one ﬁnds in number theory textbooks could
be formalized in PA. It is commonly assumed that the ﬁrst “natural” mathe-
matical problem independent from PA, was shown by Paris and Harrington,
see [11].
This problem concerns ﬁnite combinatorics and may indeed be
considered natural. But it is not a purely arithmetical problem, i.e., it has
to be coded into arithmetic. In addition, it was actually invented for the
purpose of being independent, rather than suggested by actual mathemat-
ical research. We will see later a strong normalization theorem (and these
deﬁnitely belong to the mathematical practice) independent from PA. This
theorem was obtained already by G¨odel, and thus is much older than the
Paris and Harrington example.
With the G¨odel numbers technique, one can express consistency of PA.
Indeed, let T(x) be a formula such that:
N |= T(n)
iﬀ
PA ⊢ϕn,
whenever n is a number of a sentence ϕn.
Let k be the number of the
sentence “0 = 1” and let Con be the formula “¬T(k)”. Then Con expresses
consistency of PA:
N |= Con
iﬀ
PA is consistent.
The following theorem was also obtained by G¨odel, by a reﬁnement of tech-
niques used for the proof of Theorem 11.2.1.
11.2.2. Theorem (Non-provability of consistency). If PA is consistent then
PA ̸⊢Con.
The conclusion is that to prove consistency of arithmetic, one must neces-
sarily use tools from outside the arithmetic.
11.3. Representable and provably recursive functions
We now consider two properties of functions that are stronger than being
arithmetical. We not only want our functions to be deﬁnable over the stan-
dard model, but we want to prove in PA (or some other theory) that the
appropriate formula actually deﬁnes a function.
In the deﬁnition below, the symbol ∃! should be read as “there exists ex-
actly one”. Formally, ∃!x ϕ(x) is an abbreviation for “∃x ϕ(x).∧∀y (ϕ(y) →
x = y)”.
11.3.1. Definition. We say that a k-ary total function f over N is repre-
sentable in PA iﬀthere exists a formula ϕ(⃗x, y), with k + 1 free variables
⃗x, y, such that:

11.3. Representable and provably recursive functions
173
1) f(⃗n) = m implies PA ⊢ϕ(⃗n, m), for all ⃗n, m;
2) PA ⊢∃!y ϕ(⃗n, y),
for all ⃗n ∈Nk.
A function is strongly representable in PA, if (1) holds and
3) PA ⊢∀⃗x ∃!y ϕ(⃗x, y).
Each representable function is in fact strongly representable (Exercise 11.8.3)
but proving that (2) implies (3) is a brutal application of tertium non datur.
Of course, each representable function is arithmetical. The converse is not
true, but we have the following stronger version of Theorem 11.1.2:
11.3.2. Theorem (G¨odel). A function is representable in PA if and only if
it is recursive.
The above theorem implies that the totality of every recursive function can
actually be proven in PA. However, the excluded middle trick used in Exer-
cise 11.8.3 suggests that such proofs are not necessarily constructive. Proofs
required by part (2) of Deﬁnition 11.3.1 are constructive, but non-uniform.
What we want, is a constructive and uniform proof of termination for all
arguments, such that we are able to actually compute the value m of f(⃗n)
from this proof.
We should understand however that for this reason we
should be concerned with particular algorithms rather than extensionally
understood functions. This calls for a ﬁner notion of provable totality.
Recall that, by Kleene’s normal form theorem, every partial recursive
function f can be written as
f(⃗n) = π2(µy.tf(⃗n, y) = 0),
where π2 is a projection (second inverse to the pairing function) and tf is
primitive recursive. The function tf describes a particular algorithm com-
puting f. Termination of this particular algorithm can be expressed by a
formula of the form
∀⃗x ∃y (tf(⃗x, y) = 0).
Fortunately, primitive recursive functions do not create any of the above
mentioned diﬃculties.
That is, proofs of totality for primitive recursive
functions are completely eﬀective.
In addition, every primitive recursive
function can be uniquely deﬁned by means of equational axioms. Thus, we
can actually extend the language of PA by names and deﬁning equations for
“as many primitive recursive functions as we wish”3 without any unwanted
side-eﬀects (i.e., this extension of PA is conservative.) It follows that as-
suming the above formula to be literally a formula of PA is as harmless as
it is convenient.
3A quotation from [26].

174
Chapter 11. First-order arithmetic and G¨odel’s T
11.3.3. Definition. A recursive function f is said to be provably total (or
provably recursive) in PA iﬀ
PA ⊢∀⃗x ∃y (tf(⃗x, y) = 0).
It is customary to talk about provably recursive functions, but what we
actually deal with is the notion of a provably recursive algorithm. A function
should be regarded provably total if one of its algorithms is provably total.
The class of functions provably total in PA is very large and includes
most of commonly considered functions, and much more, up to unbelievable
complexity. But there are recursive functions that are not provably total
in PA.
11.4. Heyting Arithmetic
The search for a constructive meaning of classical proof of totality of a recur-
sive function, leads of course to the notion of intuitionistic arithmetic. By
Heyting Arithmetic (HA), we mean a formal theory based on the following
axioms and rules:
• All axioms and rules of ﬁrst-order intuitionistic logic;
• All axioms of Peano Arithmetic;
• Deﬁning equations for all primitive recursive functions.
This means that HA is a theory in the language of arithmetic, extended by
new function symbols for all primitive recursive functions. This extension is
not essential, because of conservativity, but is technically very useful.
Here are some interesting properties of HA. (More can be found in [107]
and [26].)
11.4.1. Theorem.
1. HA ⊢∀x ∀y (x = y ∨¬(x = y)).
2. If HA ⊢∃x ϕ(x) for a closed formula ∃x ϕ(x) then HA ⊢ϕ(k), for
some k ∈N.
3. HA ⊢(ϕ ∨ψ) ↔∃x ((x = 0 →ϕ) ∧(¬(x = 0) →ψ)), for all ϕ, ψ.
4. If HA ⊢ϕ ∨ψ, for closed ϕ and ψ, then either HA ⊢ϕ or HA ⊢ψ.
5. If HA ⊢∀x (ϕ(x) ∨¬ϕ(x)) and HA ⊢¬¬∃x ϕ(x) then HA ⊢∃x ϕ(x).
(Markov’s Principle)

11.4. Heyting Arithmetic
175
Proof.
1) Exercise 11.8.6.
2) See [26] for a semantical proof using Kripke models.
3) Follows from part 2.
4) Follows from parts 2 and 3.
5) From HA ⊢¬¬∃x ϕ(x) it follows that PA ⊢∃x ϕ(x), and thus N |=
ϕ(k), for some k. But we have HA ⊢ϕ(k) ∨¬ϕ(k) and thus, by (4),
either ϕ(k) or ¬ϕ(k) is a theorem of HA. In each case we conclude
that HA ⊢∃x ϕ(x). (But note that this proof is classical.)
⊓⊔
11.4.2. Theorem (Kreisel (1958)). A recursive function is provably total in
Peano Arithmetic iﬀit is provably total in Heyting Arithmetic.
Proof. The right-to-left part is immediate.
We prove the other part.
Without loss of generality, we consider the case of a unary function. Let
PA ⊢∀x ∃y (tf(x, y) = 0). Thus also PA ⊢∃y (tf(x, y) = 0). One can show
that the Kolmogorov translation (see Chapter 8 and 9) works for arithmetic
(see e.g. [107]), so that we obtain HA ⊢¬¬∃y (tf(x, y) = 0). From Theo-
rem 11.4.1(1), we have
HA ⊢∀x∀y (tf(x, y) = 0 ∨¬tf(x, y) = 0).
We apply Markov’s Principle (Theorem 11.4.1(5)) to obtain the desired re-
sult.
⊓⊔
There is also a direct syntactic proof due to Friedman, which does not
require the whole power of Markov’s Principle and carries over to second-
order arithmetic. See Exercise 11.8.8.
The proof of Kreisel’s theorem works as well for any formula of the form
∀x ∃y R(x, y), where R is a primitive recursive predicate. For instance, R
may be just ⊥, in which case the quantiﬁers are redundant. We conclude
with the following result.
11.4.3. Corollary. HA is consistent if and only if PA is consistent.
⊓⊔
Kreisel’s theorem has the following consequence: classical termination
proofs can be made constructive.
11.4.4. Example. Consider a formula of the form ∀x∃y P(x, y) = 0 with
primitive recursive P. It can be seen as a speciﬁcation for an input-output
relation of a program.
A classical or intuitionistic proof of our formula

176
Chapter 11. First-order arithmetic and G¨odel’s T
asserts that such a program (a recursive function) exists. A program com-
puting this function can actually be extracted from a constructive proof. For
this, let us assume that the signature of arithmetic (and perhaps a bit more)
has been added to λP. Then a formula like ∀n∃m(n = 2 · m ∨n = 2 · m + 1)
is inhabited by a proof, i.e., a lambda term. This lambda term M, applied
to any speciﬁc n, will evaluate to a normal form pack ini(N), m to . . . for
a speciﬁc value of m. Thus M is actually a program for dividing numbers
by 2.
The little missing point in the above example is the “bit more” to be added
to the lambda calculus. We have speciﬁc axioms in arithmetic, most notably
the induction scheme. And this has to be accounted for by extending the
lambda calculus by a primitive recursion operator.
11.5. Kleene’s realizability interpretation
The BHK interpretation mentioned in previous chapters relies on the infor-
mal notion of a “construction.” Kleene [60] proposed a way to make this
precise.
The idea is that a construction of a formula is a number encoding the
constructions of the subformulas of the formula. For instance, a construction
of a conjunction ϕ1∧ϕ2 is a number n encoding a pair of numbers n1 and n2,
where n1 and n2 are constructions of ϕ1 and ϕ2, respectively.
The main problematic parts of the BHK-interpretation is in the case
of implication and universal quantiﬁer. For instance, a construction of an
implication ϕ →ψ is an eﬀective procedure that maps any construction of ϕ
into a construction of ψ. Having settled on N as the domain of constructions
it is now natural to require that a construction of an implication be a number
encoding a recursive function that maps any construction of the antecedent
to a construction of the succedent.
Below we carry this out in detail, following [61], showing that any formula
provable in intuitionistic arithmetic has a construction in this sense.
11.5.1. Definition. Let e ∈N and ϕ be a closed formula of arithmetic.
Then the circumstances under which e realizes ϕ are deﬁned as follows.
1. e realizes A, where A is an atomic formula, if e = 0 and A is true;
2. e realizes ϕ1 ∧ϕ2 if e = 2a · 3b where a realizes ϕ1 and b realizes ϕ2;
3. e realizes ϕ1 ∨ϕ2 if e = 20 · 3a and a realizes ϕ1, or e = 21 · 3a and a
realizes ϕ2;
4. e realizes ϕ1 →ϕ2 if e is the G¨odel number of a partial recursive
function f of one argument such that, whenever a realizes ϕ1, then
f(a) realizes ϕ2;

11.5. Kleene’s realizability interpretation
177
5. e realizes ∃xϕ(x), where ϕ(x) is a formula containing only x free, if
e = 2n · 3a where a realizes ϕ(n).
6. e realizes ∀xϕ(x), where ϕ(x) is a formula containing only x free, if e
is the G¨odel number of a general recursive function f of one argument
such that f(n) realizes ϕ(n), for every n.
A closed formula ϕ is realizable if there exists a number e which re-
alizes ϕ.
A formula ϕ(x1, . . . , xk) containing only the distinct variables
x1, . . . , xk (k ≥0) free is realizable if there exists a general recursive func-
tion f of k variables such that f(n1, . . . , nk) realizes ϕ(n1, . . . , nk), for every
n1, . . . , nk.
We shall prove below that every formula provable in HA is realizable. Be-
fore proceeding with the details it is convenient to introduce some notation
for partial recursive functions.
Let us recall again Kleene’s normal form theorem, which we used in
Section 11.3. The predicate tf is in fact uniform in f, or more precisely
in the G¨odel number of f.
That is, for every partial recursive function
f(x1, . . . , xn) of n variables, there is a number e such that
f(x1, . . . , xn) = π2(µy. Tn(e, x1, . . . , xn, y)),
where Tn is a certain primitive recursive predicate. Informally speaking, Tn
states that e is an encoding of f, and y is an encoding of a computation of
the function encoded by e (i.e., f) on input x1, . . . , xn. This encoding is a
pair, and the second component of this pair is the output. The projection π2
extracts this output from y. The number e is called a G¨odel number of f.
We abbreviate π2(µy. Tn(e, x1, . . . , xn, y)) by Φn(e, x1, . . . , xn).
Also recall that by Kleene’s Sm
n theorem, there is for every m, n ≥0 an
m + 1-ary primitive recursive function Sm
n (z, y1, . . . , ym) such that, if e is a
G¨odel number of the m + n-ary function f(y1, . . . , ym, x1, . . . , xn), then for
each m-tuple (k1, . . . , km) of numbers, Sm
n (e, k1, . . . , km) is a G¨odel number
of the n-ary function f(k1, . . . , km, x1, . . . , xn).
When f(y1, . . . , yn, x1, . . . , xm) is an n+m-ary partial recursive function
with G¨odel number e, we denote by
Λx1 . . . xm.f(y1, . . . , yn, x1, . . . , xm)
the function Sm
n (e, y1, . . . , ym).
Thus, Λx1 . . . xn.f(x1, . . . , xn) denotes a G¨odel number of the function f
and Λx1 . . . xn.f(y1, . . . , ym, x1, . . . , xn) denotes a primitve recursive func-
tion f(y1, . . . , ym) whose value for each m-tuple (k1, . . . , km) of numbers is
a G¨odel number of the n-ary function f(k1, . . . , km, x1, . . . , xn).
We also write {z}(x1, . . . , xn) for Φn(z, x1, . . . , xn).

178
Chapter 11. First-order arithmetic and G¨odel’s T
We then have for any n-tuple k1, . . . , kn of numbers that
{Λx1 . . . xn.f(y1, . . . , ym, x1, . . . , xn)}(k1, . . . , kn)
≈f(k1, . . . , km, x1, . . . , xn)
where ≈means that the two functions have the same domain and have the
same results on same arguments inside the domain.
11.5.2. Theorem. If ⊢HA ϕ then ϕ is realizable.
Proof. We use a Hilbert-type formulation of HA: this amounts to the
Hilbert-type formulation of intuitionistic predicate calculus from Chapter 9,
together with the axioms for arithmetic in the ﬁrst section above.
The proof is by induction on the derivation of ⊢HA ϕ. (This requires
a generalized induction hypothesis that makes sense for formulas with free
variables.) We skip most of the proof, showing only two example cases. The
reader may ﬁnd the details in §82 of Kleene’s classic [61].
1. Let the proof be an instance of the axiom A →B →A for some A, B.
Then ϕ = A →B →A. We deﬁne
e = Λa.Λb.a
(does this look familiar?) To show that e realizes ϕ, let a realize A.
We must show that {Λa.Λb.a}(a) i.e.Λb.a realizes B →A. For this
end let b realize B, and we must show that {Λb.a}(b), i.e., a realizes A,
but this holds by assumption.
2. Let the proof be an instance of (A →B →C) →(A →B) →A →C
for some A, B, C. Then:
e = Λp.Λq.Λa.{{p}(a)}({q}(a))
⊓⊔
11.5.3. Corollary. HA is consistent.
Proof. There is no number realizing ⊥.
⊓⊔
11.5.4. Corollary. PA is consistent.
Proof. Immediate from Corollaries 11.4.3 and 11.5.3.
⊓⊔
The proof that all intuitionistically provable arithmetical statements
have realizers works by mapping proofs into realizers. These realizers are
numbers coding recursive functions.
Another similar approach would be to identify the proofs with λ-terms
in an appropriate extension of λP. This would avoid the passing back and

11.6. G¨odel’s System T
179
forth between functions and encoding of functions. And we would have a nice
example of a Curry-Howard correspondence. If we deﬁne such an extension,
then consistency of arithmetic should be inferred from normalization: there
is no normal form of type ⊥.
In fact, it occurs that we do not need dependent types at all to perform
a similar construction. It was actually done by G¨odel at the simply-typed
(propositional) level, with help of his System T.
11.6. G¨odel’s System T
We have seen that in λ→, the simply typed λ-calculus, very few functions can
be deﬁned. For instance, among the numeric functions, only the extended
polynomials can be deﬁned.
In this section we consider G¨odel’s system T, which arises from λ→by
addition of primitive types for numbers and booleans and by addition of
primitive recursion and conditionals for computing with these new types.
the exposition follows [46] to a large extent.
It will be seen that λT is far more expressible than λ→. The system was
conceived and used by G¨odel to prove the consistency of arithmetic.
11.6.1. Definition. G¨odel’s system T, denoted also by λT, is deﬁned as
follows.
1. λT has the same set of types as simply typed λ-calculus λ→, with the
following additions:
τ ::= . . . | int | bool
2. λT has the same set of terms as simply typed λ-calculus λ →`a la
Curry, with the following additions:
M ::= . . . | z | s(M) | r(M, N, L) | t | f | d(M, N, L)
3. λT has the same set of typing rules as simply typed λ-calculus λ→`a
la Curry, with the following additions:
Γ ⊢z : int
Γ ⊢M : int
Γ ⊢s(M) : int
Γ ⊢M : τ & Γ ⊢N : τ →int →τ & Γ ⊢L : int
Γ ⊢r(M, N, L) : τ
Γ ⊢t : bool
Γ ⊢f : bool
Γ ⊢M : τ & Γ ⊢N : τ & Γ ⊢L : bool
Γ ⊢d(M, N, L) : τ

180
Chapter 11. First-order arithmetic and G¨odel’s T
4. λT has the same set of reduction rules as simply typed λ-calculus λ→
`a la Curry, with the following additions:
r(M, N, z)
→
M
r(M, N, s(L))
→
N (r(M, N, L))L
d(M, N, t)
→
M
d(M, N, f)
→
N
By →T we denote the union of →β and the above reductions.
As mentioned above, int and bool denote types for integers and booleans,
respectively. The term formation operators z and s denote zero and succes-
sor, respectively, as one might imagine.
The two ﬁrst inference rules for int can be seen as introduction rules,
whereas the third rule for int is an elimination rule. Analogously, z and s are
constructors of type int and r is a destructor of type int. Similar remarks
apply to the inference rules and term formation operators for bool.
11.6.2. Remark. As always one can study a Church variant and one can
study a variant in which pairs are included.
The following two theorems show that the main properties of simply
typed λ-calculus are preserved. In particular, the extra expressibility does
not come at the expense of loosing strong normalization.
11.6.3. Theorem. The relation →T is Church-Rosser.
Proof. By the Tait–Martin-L¨of technique.
⊓⊔
11.6.4. Theorem. The relation →T is strongly normalizing.
Proof. By the method of Tait.
⊓⊔
Recall that Tait’s method (which applies to λT with very few adjust-
ments) is based on a construction that assigns a set of terms to every type.
If we attempt to formalize Tait’s proof, we necessarily must use expressions
of the form: “For all sets A of terms, satisfying . . . we have . . . ”. We can
talk about terms using their numbers, but one cannot enumerate all possible
sets of terms, and expressions as the above cannot be coded into ﬁrst-order
arithmetic. One needs to quantify over sets of numbers.
Speciﬁcally, Lemma 4.4.3(iii) asserts that for all types σ the set [[σ]] is
saturated. If we could deﬁne [[σ]] directly then we could write a formula ξσ(x)
expressing in arithmetic that x is a member of [[σ]]. Then, the statement of
our lemma could be expressed in the ﬁrst-order language. But the deﬁnition
of [[σ]] is by induction, and there is no single formula expressing the property

11.6. G¨odel’s System T
181
of being a member of [[σ]]. The deﬁnition of [[σ]] can only be seen as a set of
postulates about a set (unary relation) variable X. Thus, Lemma 4.4.3(iii)
can only be formalized as follows: for all types σ and all sets X, if X
satisﬁes the postulates on [[σ]] then X is saturated. And this involves the
quantiﬁer “∀X”.
Our ﬁrst normalization proofs were for simply typed λ-calculus.
We
proved both weak normalization by the “simple” Turing-Prawitz technique
and strong normalization by the “nontrivial” technique due to Tait. There
are also “simple” proofs of the strong normalization theorem for λ →. The
diﬀerence between simple and nontrivial can be given more precise mean-
ing: the “simple” techniques can be formalized in arithmetic, whereas the
“nontrivial” can not.
In the case of λT the situation is diﬀerent. The Tait proof can be adapted
to prove strong normalization for λT, but the simple proofs mentioned above
do not work. In fact, any strong normalization proof for System T must be
“nontrivial”. See Corollary 11.7.5.
However, if we restrict attention to ﬁnitely many types, the situation
is diﬀerent. We no longer need to quantify over all sets, because we only
need ﬁnitely many of them, and these can be explicitely deﬁned by formulas.
Thus, the whole proof carries over in ﬁrst-order arithmetic. This situation
occurs in particular when we deal with a single function f, deﬁnable by a
term F, see Proposition 11.6.10.
In λT, one can compute with booleans.
11.6.5. Example. Deﬁne
not(M)
=
d(f, t, M)
or(M, N)
=
d(t, N, M)
and(M, N)
=
d(N, f, M)
Then
not(t)
→T
f
not(f)
→T
t
and we similarly have the expected reductions for or and and.
We also have some more reductions. For instance,
or(t, N) →T t
However, we do not have
or(N, t) →T t
Indeed, one can show that there is no typable term G(x, y) such that both
G(t, N) →T t and G(N, t) →T t.
Above we have introduced int as a representation of integers. The fol-
lowing characterization of normal forms gives the precise interpretation of
that.

182
Chapter 11. First-order arithmetic and G¨odel’s T
11.6.6. Proposition. Let M be a closed normal form and suppose ⊢M : τ.
1. if τ = int then M = m, for some m ∈N;
2. if τ = bool then M = f or M = t;
3. if τ = τ1 →τ2 then M = λx.N.
In λT one can also compute with integers.
11.6.7. Example. Deﬁne for any number n ∈N:
n = sn(z)
Then we can deﬁne
plus(M, N)
=
r(M, λx.λy.s(x), N)
Indeed,
plus(m, z)
=
r(m, λx.λy.s(x), z)
→T
m
and
plus(m, n + 1)
=
plus(m, s(n))
=
r(m, λx.λy.s(x), s(n))
→T
(λx.λy.s(x)) (r(m, λx.λy.s(x), n))n
→
→T
s(r(m, λx.λy.s(x), n))
→
→T
s(m + n)
=
m + n + 1
11.6.8. Definition. A function f : Nk →N is deﬁnable in λT by a term F
if4
1. ⊢F : intk →int;
2. F(m1, . . . , mk) =T f(m1, . . . , mk).
It is an easy exercise to show that multiplication, exponential, predecessor,
etc.. are deﬁnable.
As long as τ in the typing rules for the new constructs is restriced to
base types, i.e., bool and int, the functions that can be deﬁned in this
way are primitive recursive. However, as the type τ increases, more and
more functions become deﬁnable. In fact, one can show that Ackermann’s
function is deﬁnable in λT (Exercise 11.8.11).
The system λT is also called the system of primitive recursive function-
als of ﬁnite type, because it makes a system of notation for higher-order
functions (i.e., functions on functions etc.) deﬁned over the set of integers
by means of primitive recursion. (The “al” in “functionals” reﬂects exactly
the point that we deal with higher-order objects.)
4intk means int →. . . →int (k arrows).

11.7. G¨odel’s Dialectica interpretation
183
11.6.9. Remark. A construction related to the recursor r is the iterator i.
It has form i(M, N, L) with the typing rule
Γ ⊢M : τ & Γ ⊢N : τ →τ & Γ ⊢L : int
Γ ⊢i(M, N, L) : τ
and reduction rules
i(M, N, z)
→
M
i(M, N, s(L))
→
N (i(M, N, L))
The predecessor function satisfying p(s(x)) →T x can be deﬁned by the
recursor but not by the iterator. However, also the iterator can deﬁne the
predecessor provided one only requires that p(m + 1) →T m. In fact, one
can deﬁne the recursor from the iterator and pairing, provided one only
requires reductions of this form.
The question arises exactly which functions can be deﬁned in λT. It is
not diﬃcult to see that every primitive recursive function is deﬁnable. It is
also not diﬃcult to see that not every recursive function can be deﬁnable.
Indeed, suppose otherwise. All terms of type int →int can be eﬀectively
enumerated, and each of these terms deﬁnes a total function (because of
strong normalization). Thus, we can enumerate all total recursive functions
of one argument: g0, g1, . . . . But the function h(x) = gx(x) is recursive and
cannot occur in the sequence. We can have even a tighter upper bound.
11.6.10. Proposition. All functions deﬁnable in λT are provably total in PA.
Proof. If a function f is deﬁnable by a term F then this term describes an
algorithm to compute f. Thus, a predicate tf can be eﬀectively computed
from F and conversely. Proving the formula ∀x ∃y (tf(x, y) = 0) thus reduces
to proving that all applications of the form Fn are strongly normalizable.
One can do it (with Tait’s technique) so that only ﬁnitely many types must
be considered. All this argument can be coded into arithmetic.
⊓⊔
We will see later (Theorem 11.7.7) that the class of functions deﬁnable
in λT coincides with the class of provably total functions of PA.
11.7. G¨odel’s Dialectica interpretation
G¨odel introduced System T as a vehicle to prove consistency of PA. More
precisely, he translates each formula of arithmetic into a statement about
the primitive recursive functionals of ﬁnite type by the so-called Dialectica
interpretation. The original G¨odel’s paper is [48]. We will only sketch the
main ideas here. More details can be found e.g. in [55, Ch.18].

184
Chapter 11. First-order arithmetic and G¨odel’s T
The basis of the method is a translation of a formula ϕ in the language
of arithmetic into a term ϕD of type bool. Suppose ﬁrst that ϕ is an atomic
formula. Since all primitive recursive functions and predicates are deﬁnable
in λT, we can deﬁne ϕD so that
HA ⊢ϕ
iﬀ
ϕD =T t.
Here we do not require any additional information about the proof of ϕ to be
preserved by ϕD. (This is because primitive recursive statements are treated
as “observables”. Compare this to 0 realizing all atomic formulas in Kleene’s
approach.) For complex formulas, we want more. An ideal situation would
be as follows: ϕD has one free variable x, and
HA ⊢ϕ
iﬀ
ϕD[x := M] =T t,
for some M.
The term M would be the realizer, i.e., it would represent the proof. (Note
the distinction: ϕD is a syntactic translation, the computational contents is
in M.)
Life is not that easy, and we have to settle for something a little less
transparent and more complicated. But the essential idea remains the same.
Below we work in Church-style λT, extended with product types for simplic-
ity. (This is a syntactic sugar that allows us to identify sequences of types
(variables etc.) with single types (variables, etc.) if we ﬁnd it convenient.)
11.7.1. Definition.
1. For a term M : bool, with FV(M) = {zσ}, we write T |= M iﬀ
M[z := Z] =T t, for all closed Z : σ.
2. We deﬁne a λ-formula as an expression of the form “∃xσ∀yτD(x, y)”,
where x, y are variables, τ and σ are arbitrary types, and D(x, y) has
type bool.
3. We write T |= ∃xσ∀yτD iﬀthere exists a term X : σ with y ̸∈FV(X),
such that T |= D[x := X].5
The variables x and y in the above deﬁnition, part (2) may be of product
types, thus actually may represent sequences of variables.
11.7.2. Definition. For each formula ϕ in the language of arithmetic, we
deﬁne a λ-formula ϕD = ∃x∀y ϕD by induction with respect to ϕ.
• If ϕ is an atom (a primitive recursive relation) then ϕD = ∃xint∀yint ϕD,
where ϕD is a term which deﬁnes this relation in λT, and x and y are
fresh variables.
5The term X should be seen as parameterized by the free variables of D, except y.

11.7. G¨odel’s Dialectica interpretation
185
Note that ⊥is a primitive recursive relation. Thus, as ⊥D we can take e.g.
the term f.
Also note that the quantiﬁers ∃xint∀yint are redundant and
introduced here just for uniformity.
Let now assume that ϕD = ∃xσ∀yτ ϕD(x, y) and ψD = ∃uρ∀vµ ψD(u, v).
Then:
• (ϕ ∧ψ)D = ∃xu∀yv(ϕD(x, y) ∧ψD(u, v));
• (ϕ ∨ψ)D = ∃zintxu∀yv((z = 0 →ϕD) ∧(z ̸= 0 →ψD));
• (ϕ →ψ)D = ∃u1σ→ρy1σ→µ→τ∀xv(ϕD(x, y1xv) →ψD(u1x, v));
• (¬ϕ)D = ∃zσ→τ∀x(¬ϕD(x, zx));
And now take ϕD = ∃xσ∀yτ ϕD(x, y, zint). Then
• (∃z ϕ)D = ∃zx∀y ϕD(x, y, z);
• (∀z ϕ)D = ∃x1int→σ∀yzϕD(x1z, y, z)
11.7.3. Theorem (G¨odel). If HA ⊢ϕ then T |= ϕD.
Proof. The proof is by induction with respect to the proof of ϕ. We omit
this proof, which can be found in [55, Ch.18].
⊓⊔
The proof of the above theorem is actually building a realizer X for a given
proof in HA. The computational contents of the proof in HA is preserved
by the realizer as we will see below. Here are some consequences of the
interpretation.
11.7.4. Corollary. HA is consistent.
Proof. Suppose HA ⊢⊥. Then T |= ⊥D, i.e., we have f =T t.
⊓⊔
11.7.5. Corollary. The strong normalization theorem for System T is a
statement independent from PA.6
Proof. Otherwise, all the proof of SN would be formalizable in PA. This
contradicts Theorem 11.2.2.
⊓⊔
The above result can be explained as follows. G¨odel’s consistency proof
makes use of the normalization theorem for λT, and every other part than
this latter result can be proved in PA itself, provided we go through the eﬀort
of translating terms to numbers by some G¨odel-numbering. By G¨odel’s the-
orem about the unprovability of consistency of arithmetic within arithmetic
6SN is expressible in the language of arithmetic with help of K¨onig’s Lemma: “For
each (G¨odel number of a) term M there is n such that all reduction paths from M (coded
by a G¨odel number) consist of at most n steps”.

186
Chapter 11. First-order arithmetic and G¨odel’s T
it follows that the normalization therem cannot be proved in PA—unless
PA is inconsistent.
Thus, in proving the normalization for λT we must be using methods
which essentially transcend proof techniques that are formalizable in PA,
i.e., induction over natural numbers.
In normalization proof for simply typed λ-calculus we used induction
on lexicographically order triples, and similarly in the proof of Gentzen’s
Hauptsatz (the cut-elimination theorem). Such inductions can be reduced
to nested inductions and are therefore still formalizable in PA.
One can also view induction on lexicographically ordered tuples as an
ordinal induction—induction up to ωn—which happens to be formalizable
in PA. Gentzen discovered that by moving to larger ordinals, one could prove
a cut-elimination theorem for arithmetic.
More speciﬁcally he considers
induction up to ϵ0.
This is the ﬁrst ordinal that cannot be reached by
addition, multiplication, and exponentiation.
Also, one can show that the functions deﬁnable in λT are the functions
which are deﬁnable by transﬁnite recursion up to the ordinals which are
strictly smaller than ϵ0, see [96].
This shows that the expressive power
of λT is enormous.
11.7.6. Corollary. All functions provably total in ﬁrst-order arithmetic
are deﬁnable in T.
Proof. Without loss of generality we can consider a unary function. As-
sume PA ⊢∀x ∃y (tf(x, y) = 0), where tf is as in Deﬁnition 11.3.3. Recall
that tf(x, y) = 0 is primitive, and thus treated as an atomic formula. Thus,
the translation of the above formula (after removing redundant quantiﬁers)
has the form
(∀x ∃y (tf(x, y) = 0))D = ∃yint→int
1
∀xωD(y1x, x),
where D represents the relation tf(x, y) = 0.
Since HA |= (∀x ∃y (tf(x, y) = 0))D, we have a realizing term Y1, such
that D(Y1n, n) reduces to t. Let Y1n =T m. Then we have tf(n, m) = 0,
and thus f(n) = π2(m). Clearly, the projection is primitive recursive and
represented by some term Π2. The conclusion is that the term λx.Π2(Y1x)
represents f in System T.
⊓⊔
Together with Proposition 11.6.10, this gives:
11.7.7. Theorem. The functions deﬁnable in λT are exactly those that are
provably total in PA.
11.7.8. Remark. Let us now come back to the idea mentioned in Exam-
ple 11.4.4 of a variant of λP corresponding to ﬁrst-order arithmetic. We

11.8. Exercises
187
shall argue that System T can be seen as a propositional counterpart of
such a calculus. Indeed, let us consider again the induction scheme
(∀x:int)(ϕ(x) →ϕ(x + 1)). →ϕ(0) →(∀x:int)ϕ(x).
In order to incorporate arithmetic into λP one has to make sure that every
such type is inhabited. One way to do it is to introduce new constants Rϕ
of the above types.
A proof by induction is now represented by a term
RϕM(∀x:int)(ϕ(x)→ϕ(x+1))Nϕ0 of type (∀x:int)ϕ(x).
The next question is what should be a reduction rule associated with Rϕ.
Let n : int be a speciﬁc integer.
The term RϕMNn represents a proof
of ϕ(n) obtained as follows: ﬁrst prove the general statement (∀x:int)ϕ(x)
by induction and then apply it to n. Such a proof can be seen as containing
a redundancy: an introduction of universal quantiﬁer by Rϕ followed by
elimination of that quantiﬁer. We can avoid redundancy by applying M
to N exactly n times instead. This justiﬁes the reduction rules:
• RϕMN0 →β N;
• RϕMN(n + 1) →β Mn(RϕMNn).
Now observe what happens to our constant under the dependency erasing
translation M 7→M. The type of Rϕ becomes:
(int →ϕ →ϕ) →ϕ →int →ϕ(x),
which is, up to permutation, the same as the type of the recursor r. Also,
the reduction rules above diﬀer from those of Deﬁnition 11.6.1(4) just in the
order of arguments.
11.8. Exercises
11.8.1. Exercise. Show that the following theorems are derivable in PA:
• ∀x (¬(x = 0) →∃y(y = x + 1));
• ∀x∀y∀z (x = y →y = z →x = z);
• ∀x∀y∀z ((x + y) + z = x + (y + z));
• ∀x∀y (x + y = y + x);
• 2 + 2 = 4;
• ∀x∃y (x = 2 · y ∨x = 2 · y + 1);
• other common arithmetical properties.

188
Chapter 11. First-order arithmetic and G¨odel’s T
11.8.2. Exercise. Check whether the axiom scheme ∀x∀y (ϕ(x) →x =
y →ϕ(y)) of PA can be replaced by ∀x∀y (x = y →x + 1 = y + 1) and
∀x∀y∀z (x = y →y = z →x = z).
11.8.3. Exercise. Show that every function representable in PA is strongly
representable (and conversely). Hint: Consider the formula:
(∃!z ϕ(⃗x, z). ∧ϕ(⃗x, y)) ∨(¬∃!z ϕ(⃗x, z). ∧y = 0).
11.8.4. Exercise. Show that the condition (2) in Deﬁnition 11.3.1 can be
replaced by:
2’) PA ⊢∃y ϕ(⃗n, y),
for all ⃗n ∈Nk;
2”) N |= ϕ(⃗n, m) implies f(n) = m, for all ⃗n and m.
Hint: Consider the formula: ϕ(⃗x, y) ∧∀z (ϕ(⃗x, z) →y ≤z).
11.8.5. Exercise. Consider again the formulas of Exercise 11.8.1. Are they
provable in HA?
11.8.6. Exercise. Prove part 1 of Theorem 11.4.1.
11.8.7. Exercise. Let ϱ be a ﬁxed formula. For any formula ϕ, let ϕϱ be
obtained from ϕ by replacing every atomic subformula ν by ν ∨ϕ. Show
that if HA ⊢ϕ then also HA ⊢ϕϱ.
11.8.8. Exercise (H. Friedman). Prove Theorem 11.4.2, using Exercise 11.8.7
as a lemma. Hint: Take ϱ to be ∃y(tf(⃗x, y) = 0), and apply Exercise 11.8.7
to the formula ¬¬∃y(tf(⃗x, y) = 0).
11.8.9. Exercise. Show that multiplication, exponentiation, subtraction,
and all your favourite integer functions are deﬁnable in λT.
11.8.10. Exercise. Here are our favourite integer functions: let f0 be the
successor function, and deﬁne fk+1(x) := fx
k (x) (apply fk to x exactly x
times). Show that all functions fk are deﬁnable i n λT.
11.8.11. Exercise. The Ackermann function fω is deﬁned by fω(x) = fx(x).
Prove that the Ackermann function is not primitive recursive. Hint: Show
that every primitive recursive function is majorized by one of the fk’s.
11.8.12. Exercise. Show that the Ackermann function fω (Exercise 11.8.11)
is deﬁnable in λT.
11.8.13. Exercise. Show that all functions fω+k+1(x) = fx
ω+k(x) are deﬁn-
able in λT, as well as the function fω·2(x) = fω+x(x).

11.8. Exercises
189
11.8.14. Exercise. Go ahead, deﬁne even faster growing functions, all de-
ﬁnable in λT. Will this ever stop?
11.8.15. Exercise. Show that all functions deﬁnable in λ→are deﬁnable
in λT. Too easy? Do not use Schwichtenberg theorem.
11.8.16. Exercise. Show that Booleans make syntactic sugar in λT, that
is, the class of integer functions deﬁnable in λT without Booleans is the
same.

190
Chapter 11. First-order arithmetic and G¨odel’s T

CHAPTER 12
Second-order logic and polymorphism
We often say that individuals are objects of order zero.
Functions and
relations on individuals are of order one. Further, operations on objects of
order n will be themselves classiﬁed as being of order n+1. This terminology
is often used in the metalanguage, referring to problems, systems etc. For
instance, the uniﬁcation problem discussed in Chapter 6, is often called
“ﬁrst-order uniﬁcation”. Note that the uniﬁed expressions (unknowns) are of
order zero, its the uniﬁcation itself (an operation on terms) that is ﬁrst-order.
One can also consider second-order uniﬁcation, with function unknowns and
so on.
We talk of “ﬁrst-order logic”, because we have ﬁrst-order predicates, and
because quantiﬁcation can be seen as an operator acting on individuals. So
what “second-order logic” should be? Typically, one adds to the language
variables ranging over predicates, sets or functions, and quantify over such
variables.
Thus, second-order logic is usually an extension of ﬁrst-order
logic. However, in presence of second-order quantiﬁcation, the ﬁrst-order
features become less important than one could expect, and many properties
of second-order logic can be studied in a simpliﬁed settings: propositional
second-order logic. This logic is obtained by adding second-order features di-
rectly to propositional calculus. That is, quantiﬁers are now binding propo-
sitional variables.
12.1. Propositional second-order formulas
We extend the language of propositional logic by second-order quantiﬁers,
i.e., quantiﬁers over propositions. As before, we assume an inﬁnite set PV of
propositional variables and we deﬁne the second-order propositional formulas
by induction, represented by the following grammar:
2Φ ::= ⊥| p | (2Φ →2Φ) | (2Φ ∨2Φ) | (2Φ ∧2Φ) | ∀p 2Φ | ∃p 2Φ,
191

192
Chapter 12. Second-order logic and polymorphism
where p ranges over PV . The quantiﬁers are meant to bind propositional
variables within their scope, so that e.g., FV(∀p ϕ) = FV(ϕ) −{p}. (We
skip the full deﬁnition of FV, leaving this pleasure to the reader, as well as
another one: to deﬁne the operation of substitution ϕ[p := ψ].) We identify
alpha-convertible formulas. Notational conventions are similar to those used
for propositional and ﬁrst-order logic.
The intended meaning of “∀p ϕ(p)” is that ϕ(p) holds for all possible
meanings of p. The meaning of “∃p ϕ(p)” is that ϕ(p) holds for some mean-
ing of p. Classically, there are just two possible such meanings: the two truth
values. Thus, the statement ∀p ϕ(p) is classically equivalent to ϕ(⊤)∧ϕ(⊥),
and ∃p ϕ(p) is equivalent to ϕ(⊤)∨ϕ(⊥). Therefore, every property express-
ible with quantiﬁers can be also expressed without.1 In fact, every function
over the two-element Boolean algebra {⊥, ⊤} can be deﬁned with help of
ordinary propositional connectives (this property is called functional com-
pleteness) and thus no extension at all of the propositional language can
increase its expressive power.
12.1.1. Warning. The above is no longer true when we add second-order
quantiﬁcation to ﬁrst-order classical logic, and when the quantiﬁed predi-
cates may depend on individual terms. These are no longer just truth-values,
but rather truth-valued functions on individuals.
In the intuitionistic logic, there is no ﬁnite set of truth-values, and the
propositional quantiﬁers should be regarded as ranging over some inﬁnite
space of predicates. (In fact, there is nothing like functional completeness:
Kreisel [64] and Goad [47] show predicates non-expressible in propositional
intuitionistic logic but deﬁnable with help of quantiﬁers or inﬁnite opera-
tions.)
The intuitive meaning of quantiﬁed expressions is best explained by
means of the Brouwer-Heyting-Kolmogorov interpretation.
Note that we
deal only with propositions expressible in our language. Indeed, to handle
the predicates in a constructive way, we must be able to refer to their proofs.
• A construction of ∀p ϕ(p) is a method (function) transforming every
construction of any proposition P into a proof of ϕ(P).
• A construction of ∃p ϕ(p) consists of a proposition P, together with a
construction of P, and a construction of ϕ(P).
Syntactically, predicates P must be themselves represented by formulas. The
class of formulas quantiﬁers range over can be taken to be the full set 2Φ, or
a proper subset of 2Φ. We choose the ﬁrst option (called full comprehension)
so that the following schemes are valid (for every ϕ):
1But at a certain cost: compare the PSPACE-completeness of satisﬁability of quantiﬁed
Boolean formulas to the NP-completeness of ordinary propositional formulas. It follows
that removing quantiﬁers may cause an exponential increase of the size of a formula.

12.2. Semantics
193
• ∀p ϕ. →ϕ[p := ψ];
• ∃p(p ↔ϕ).
One has to be aware that the full comprehension postulate has the follow-
ing side-eﬀect, called impredicativity of second-order logic. The meaning of
a formula ∀p ϕ is determined by the meanings of all formulas ϕ[p := ψ],
including the cases when ψ is either equal or more complex than ∀p ϕ it-
self. There is no well-founded hierarchy with respect to the semantics, in
particular many proof methods based on induction must fail.
On the other hand, the assumption that quantiﬁers range over deﬁnable
propositions only is a sharp restriction compared to the ordinary understand-
ing of (full) second-order classical logic, as in Warning 12.1.1. However, from
a constructive point of view, a proof and not a model is the ultimate cri-
terium, and thus the syntactic approach should be given priority over the
semantic way of thinking. See also Remark 12.2.7.
12.1.2. Definition. Natural deduction.
The natural deduction system for second-order intuitionistic proposi-
tional logic consists of the ordinary rules for propositional connectives plus
the following rules for quantiﬁers:
(∀I) Γ ⊢ϕ
Γ ⊢∀p ϕ
(p ̸∈FV (Γ))
(∀E)
Γ ⊢∀p ϕ
Γ ⊢ϕ[p := ϑ]
(∃I)Γ ⊢ϕ[p := ϑ]
Γ ⊢∃p ϕ
(∃E)Γ ⊢∃p ϕ
Γ, ϕ ⊢ψ
Γ ⊢ψ
(p ̸∈FV (Γ, ψ))
In the above, the notation FV (Γ) is the union of all FV(ϱ), for ϱ ∈Γ.
One can also deﬁne other proof systems, most notably sequent calculus
for second-order propositional intuitionistic logic.
Cut-elimination proofs
for this calculus were obtained independently by several authors; three of
them (by Girard, Martin-L¨of and Prawitz) are published in the book [34].
12.2. Semantics
We begin, as usual, with the algebraic approach, based on Heyting algebras,
although, historically, second-order Kripke semantics was considered ﬁrst.
12.2.1. Definition. Let v : V →H be a valuation of propositional variables
in a complete Heyting algebra H. We extend v to arbitrary second-order
formulas as follows:
• v(ϕ ∨ψ) = v(ϕ) ∪v(ψ);

194
Chapter 12. Second-order logic and polymorphism
• v(ϕ ∧ψ) = v(ϕ) ∩v(ψ);
• v(ϕ →ψ) = v(ϕ) ⇒v(ψ);
• v(⊥) = 0;
• v(∀pϕ) = inf{va
p(ϕ) : a ∈H};
• v(∃pϕ) = sup{va
p(ϕ) : a ∈H}.
where vψ
p is a valuation deﬁned by va
p(p) = a, and va
p(q) = v(q), for q ̸= p.
We use the symbol |= in the obvious way, except that we deal now
exclusively with complete algebras. For instance, we write |= ϕ (and we
say that ϕ is a tautology) iﬀϕ has the value 1 under all valuations in all
complete Heyting algebras.
12.2.2. Theorem (Heyting completeness). The conditions Γ |= ϕ and Γ ⊢ϕ
are equivalent.
Proof. Omitted.2 See the paper [40] for details.
⊓⊔
The paper of Geuvers [40] is suggested for reading, but algebraic semantics
for various second-order and higher-order intuitionistic logics was known
before Geuvers, cf. the work of Albert Dragalin [32].
Kripke semantics for second-order propositional formulas was considered
by several authors. There are various sorts of models and diﬀerent variants
of the logics under consideration.
One should begin with a reference to
Prawitz [86], who ﬁrst proved a completeness theorem for a class of Beth
models, structures similar in spirit to Kripke models. Then, Gabbay [36, 37]
showed completeness for a slight extension of our second-order logic for a
restricted class of Kripke models. This result was adjusted by Sobolev [100]
so that the Gabbay’s axiom (see Remark 12.2.5) was no longer necessary.
We recommend the paper [99] of Skvorov for a survey of these results. Our
deﬁnition below follows the latter paper (up to syntactic sugar).
12.2.3. Definition.
1. A second-order Kripke model is a tuple of the form C = ⟨C, ≤, {Dc :
c ∈C}⟩, where C is a non-empty set, ≤is a partial order in C, and
the Dc’s are families of upward-closed3 subsets of C, satisfying
if c ≤c′ then Dc ⊆Dc′.
The intuition is that Dc is the family of predicates meaningful at
state c.
2A diﬃculty in this proof is that the Lindenbaum algebra of second-order formulas is
not complete and has to be embedded into a complete one in such a way that the existing
joins and meets are preserved.
3If c′ ∈x ∈Dc and c′ ≤c′′ then also c′′ ∈x.

12.2. Semantics
195
2. A valuation in C assigns upward-closed subsets of C to propositional
variables. Such a valuation v is admissible for a state c iﬀv(p) ∈Dc,
for all propositional variables p. Clearly, a valuation admissible for c
is also admissible for all c′ ≥c. We write vx
p for a valuation satisfying
vx
p(p) = x, and vx
p(q) = v(q), for q ̸= p.
The forcing relation c, v ⊩ϕ is deﬁned (when v is admissible for c) as
follows:
• c, v ⊩p
iﬀ
c ∈v(p);
• c, v ⊩ϕ ∨ψ
iﬀ
c, v ⊩ϕ or c, v ⊩ψ;
• c, v ⊩ϕ ∧ψ
iﬀ
c, v ⊩ϕ and c, v ⊩ψ;
• c, v ⊩ϕ →ψ
iﬀ
c′, v ⊩ψ, for all c′ ≥c with c′, v ⊩ϕ;
• c, v ⊩⊥never happens;
• c, v ⊩∃p ϕ
iﬀ
c, vx
p ⊩ϕ, for some x ∈Dc;
• c, v ⊩∀p ϕ
iﬀ
c′, vx
p ⊩ϕ, for all c′ ≥c, and all x ∈Dc′.
3. A Kripke model is complete iﬀfor every formula ϕ, every c and v, the
set v(ϕ) = {c′ : c′, v ⊩ϕ} is in Dc, whenever v is admissible for c. (If
we understand the meaning of propositional variables free in ϕ then
we should understand the formula too.)
4. We write Γ ⊩ϕ iﬀfor every complete Kripke model C, every c ∈C
and every valuation v admissible for c, such that c, v forces all formulas
in Γ, we also have c, v ⊩ϕ.
The completeness theorem for Kripke models in the form below should prob-
ably be attributed to Sobolev [100].
12.2.4. Theorem (Kripke completeness). The conditions Γ ⊩ϕ and Γ ⊢ϕ
are equivalent.
12.2.5. Remark. The additional axiom scheme used by Gabbbay is:
∀p(ψ ∨ϕ(p)). →ψ ∨∀p ϕ(p),
where p ̸∈FV(ψ).
This is a classical second-order tautology, but not an intuitionistic tautology.
The class of models corresponding to propositional second-order intuition-
istic logic extended with Gabbay’s axiom (called also Grzegorczyk schema)
is obtained by postulating that all Dc are equal to each other (models with
constant domains).
12.2.6. Remark. Note that the postulate of completeness of Kripke models
reﬂects the idea of impredicativity. Indeed, it guarantees that the range of
a quantiﬁed variable includes every deﬁnable predicate. In fact, if we do
not require completeness, the following tautology schemes (expressing full
comprehension) would be no longer valid:

196
Chapter 12. Second-order logic and polymorphism
• ∀p ϕ →ϕ[p := ψ];
• ∃p (p ↔ϕ).
Observe that completeness cannot be replaced by a modiﬁed deﬁnition of
forcing,
c, v ⊩∀p ϕ
iﬀ
c′, vv(ψ)
p
⊩ϕ,
for all c′ ≥c, and all formulas ψ,
because such a deﬁnition would be circular. (Take ψ = ∀pϕ.)
12.2.7. Remark. It is tempting to consider Kripke models with all Dc equal
to the family of all upward-closed subsets of C (principal Kripke models).
Unfortunately, the class of all formulas valid in principal models is not re-
cursively enumerable, and thus non-axiomatizable in a ﬁnitary way. This
result is due to Skvorov [99] and independently to Kremer [65].
Of course the above mentioned results of Skvorov and Kremer imply
that the set of second-order sentences true in all principal models cannot
be decidable or even recursively enumerable. The set of provable sentences
of our second-order intuitionistic logic is of course recursively enumerable.
But it is undecidable.
12.2.8. Theorem.
It is undecidable whether a given formula ϕ ∈2Φ has a proof.
The ﬁrst proof of undecidability was given by Gabbay [36, 37]. But this proof
applies to the logic extended by Gabbay’s axiom (see Remark 12.2.5), and
it does not extend automatically to the pure intuitionistc case. The proof is
using completeness theorem, for Kripke models with constant domains. The
paper [100] of Sobolev ﬁlled this gap, and allowed to infer Theorem 12.2.8 by
essentially the same method. In the meantime, M.H. L¨ob [67] has published
another proof of Theorem 12.2.8.
The main result of [67] which implies
undecidability, is an eﬀective translation from ﬁrst-order classical logic to
second-order intuitionistic logic.
Unfortunately, L¨ob’s paper is quite in-
comprehensible. It has been later slightly simpliﬁed by Arts [3] and Arts
and Dekkers [4], but the resulting presentations are still quite complicated.
A simpler, syntactic proof of Theorem 12.2.8 can be found in [112].
12.3. Polymorphic lambda-calculus (System F)
The polymorphic lambda-calculus λ2, often referred to as “System F” is an
excellent example of a Curry-Howard correspondence and provides a surpris-
ing evidence for the relationships between logic and computer science. This
system was actually invented twice: by the logician Jean-Yves Girard [44]
and by the computer scientist John Reynolds [90]. The ﬁrst one’s goal was

12.3. Polymorphic lambda-calculus (System F)
197
to design a proof notation needed for his work on second-order logic, the
other’s idea was to build a type system for a polymorphic programming
language. The results (after dissolving the syntactic sugar) were essentially
the same.
For a treatment of System F extending the scope of the present notes,
one can consult the following books: [45, 66, 74].
12.3.1. Definition.
1. (Second-order) types are deﬁned as follows:
• Type variables are types;
• If σ and τ are types then (σ →τ) is a type;
• If σ is a type and α is a type variable, then ∀α σ is a type.
Thus, types coincide with second-order propositional formulas over →
and ∀only.
2. Well-typed lambda-terms (Church style) are deﬁned by the type infer-
ence rules below. Every term is either a variable, an ordinary applica-
tion or abstraction, or it is
• a polymorphic abstraction, written Λα.M, where M is a term and
α is a type variable, or
• a type application, written (Mτ), where M is a term and τ is a
type.
The intuitive meaning of Λα.M is that the term M (which may refer to a
free type variable α) is taken as a polymorphic procedure with a type param-
eter α. Type application correspond to a call to such a generic procedure
with an actual type parameter. This is an explicit form of polymorphism
(type as parameter) as opposed to implicit polymorphism of ML.
12.3.2. Definition (Type inference rules). A context is again a ﬁnite set of
declarations (x : τ), for diﬀerent variables (i.e., ﬁnite partial function from
variables to types). The axiom and the rules for →are as usual:
Γ, x:τ ⊢x : τ
Γ ⊢N : τ →σ
Γ ⊢M : τ
Γ ⊢NM : σ
Γ, x : τ ⊢M : σ
Γ ⊢λx:τ.M : τ →σ
and we also have rules for ∀corresponding to natural deduction rules (∀I)
and (∀E)
Γ ⊢M : σ
Γ ⊢(Λα.M) : ∀α σ
(α ̸∈FV (Γ))
Γ ⊢M : ∀α σ
Γ ⊢Mτ : σ[α := τ]

198
Chapter 12. Second-order logic and polymorphism
Let us recall that a Church-style term makes sense for us only within a con-
text that assigns types to free variables. We sometimes stress this fact by
placing (informally) an upper index, as for instance in x∀α(σ→ρ)τyσ[α:=τ]. In
fact, ﬁnding a proper decoration of free variables in a given term expres-
sion (to obtain a proper Church-style term) is, surprisingly, an undecidable
problem, see [95].
12.3.3. Convention. As in previous chapters, we sometimes write upper
indices to mark types of certain (sub)terms. Also, we sometimes write e.g.
λxτ. M, rather than λx:τ. M, to improve readability.
As should be now clear from the rules, the universal type ∀α σ(α) corre-
sponds to a product construction of the form Q
τ∈⋆σ(τ). This answers very
well to the idea that a proof of ∀α σ(α) is a function translating proofs of τ
into proofs of σ(τ).
From the programmer’s point of view, ∀α σ is a type of a polymorphic
procedure. Note that the restriction α ̸∈FV (Γ) in the ∀introduction rule
(called also generalization rule) corresponds to that a type parameter must
be a local identiﬁer.
12.3.4. Example. Here are some well-typed Church-style terms:
• ⊢Λα.(λx∀α(α→α).x(β →β)(xβ) : ∀β(∀α(α →α). →β →β);
• ⊢Λα.λfα→αλxα.f(fx) : ∀α((α →α) →(α →α));
• ⊢λf∀α(α→β→α)Λαλxα.f(β→α)(fαx) : ∀α(α →β →α). →∀α(α →
β →β →α).
12.3.5. Theorem (Curry-Howard isomorphism). We have Γ ⊢M : τ in the
polymorphic lambda calculus if and only if |Γ| ⊢τ has a proof in the {∀, →}-
fragment of the second-order intuitionistic propositional logic.
12.3.6. Corollary. The inhabitation problem for the polymorphic lambda
calculus (“Given type τ, is there a closed term of type τ?”) is undecidable.
Proof. Immediate from the above and Theorem 12.2.8.
⊓⊔
12.3.7. Warning. We skip the detailed deﬁnition of free variables and sub-
stitution. The reader should be able to write this deﬁnition herself, provided
she remembers about the following:
• There are free object variables in terms as well as free type variables.
The latter occur in the lambda abstractions “λx:τ” and in type appli-
cations. Thus we have to consider substitutions of the form M[x := N]
and of the form M[α := τ].

12.4. Expressive power
199
• There are two binding operators in terms:
the big and the small
lambda.
Substitutions must account for both.
And note that the
term N in M[x := N] may contain free type variables that are bound
in M. Thus, both sorts of renaming may be necessary.
• The deﬁnition of alpha conversion must account for the two sorts of
bindings.
• Binding an object variable xρ does not mean binding type variables
in ρ.
• The eﬀect of substitution x[α := τ] is of course x. But if we work
in a context containing a declaration (x : σ), then one should better
understand it this way: xσ[α := τ] = xσ[α:=τ]. This is because what
we want is Γ[α := τ] ⊢M[α := τ] : σ[α := τ] whenever Γ ⊢M : σ.
12.3.8. Definition (Beta reduction).
There are two sorts of beta reduction rules:
• Object reduction: (λx:τ.M)N −→β M[x := N];
• Type reduction: (Λα.M)τ −→β M[α := τ].
This notion of reduction has the expected properties, in particular it is
Church-Rosser and preserves types.
12.4. Expressive power
In classical logic, the connectives ¬, ∨and ∧can be deﬁned by means of
⊥and →. The quantiﬁer ∃is also expressible via the De Morgan law, so
that ⊥, →and ∀make a suﬃcient set of operators. This is not the case in
intuitionistic logic, neither propositional nor ﬁrst-order. However, in second-
order propositional logic, this opportunity appears again. And we can even
get more: using →and ∀one can express the other connectives and also
the constant ⊥. We have postponed these deﬁnitions until now, in order to
accompany them with term notation.
12.4.1. Definition (Absurdity). We deﬁne
⊥:= ∀α α.
We have the following term assignment to rule (E⊥):
Γ ⊢M : ⊥
Γ ⊢Mτ : τ

200
Chapter 12. Second-order logic and polymorphism
It is easy to see that there is no closed term in normal form that can be
assigned type ∀α α. It will follow from strong normalization that ⊥is an
empty type.
12.4.2. Definition (Conjunction (product)).
Let α be not free in τ nor σ. Then
τ ∧σ := ∀α((τ →σ →α) →α).
(Read this deﬁnition as: τ ∧σ holds iﬀeverything holds that can be derived
from {τ, σ}.)
Lambda-terms related to conjunction are pairs and projections.
We
deﬁne them as follows:
• ⟨P, Q⟩:= Λαλzτ→σ→α. zPQ;
• π1(Mτ∧σ) := Mτ(λxτλyσ. x);
• π2(Mτ∧σ) := Mσ(λxτλyσ. y).
It is left to the reader to check that the term assignment to the ∧-related
rules of natural deduction, described in Section 4.2:
Γ ⊢M : ψ
Γ ⊢N : ϕ
Γ ⊢< M, N >: ψ ∧ϕ
Γ ⊢M : ψ ∧ϕ
Γ ⊢π1(M) : ψ
Γ ⊢M : ψ ∧ϕ
Γ ⊢π2(M) : ϕ
is correct, as well as the beta-reduction πi(⟨P1, P2⟩) →β Pi is implemented
(but with →β replaced by →
→β). Note however that eta-conversion is not
implemented: if yτ∧σ is a variable then ⟨π1(y), π2(y)⟩is a normal form.
12.4.3. Definition (Disjunction (variant)).
We deﬁne the disjunction of τ and σ as their weakest common conse-
quence. That is, τ ∨σ holds iﬀall common consequences of τ and σ hold.
Formally, for α ̸∈FV(σ) ∪FV(τ), we take:
τ ∨σ := ∀α((τ →α) →(σ →α) →α).
We deﬁne injections and case eliminator this way:
• in1(Mτ) := Λαλuτ→αλvσ→α. uM;
• in2(Mσ) := Λαλuτ→αλvσ→α. vM;
• case(Lτ∨σ; xτ.Mρ; yσ.Nρ) := Lρ(λxτ.M)(λyσ.N).

12.4. Expressive power
201
The reader is invited to check the correctness of rules:
Γ ⊢M : ψ
Γ ⊢in1(M) : ψ ∨ϕ
Γ ⊢M : ϕ
Γ ⊢in2(M) : ψ ∨ϕ
Γ ⊢L : ψ ∨ϕ
Γ, x : ψ ⊢M : ρ
Γ, y : ϕ ⊢N : ρ
Γ ⊢case(L; x.M; y.N) : ρ
as well as the correctness of beta reduction (Exercise 12.7.6).
Before we discuss the existential quantiﬁer, let us observe that various
data types can be implemented in System F. For instance, type Bool can
be interpreted as ∀α(α →α →α), with true = Λαλxαyα. x and false =
Λαλxαyα. y. Integers are represented by the type
ω := ∀α((α →α) →α →α),
with the polymorphic Church numerals
cn := Λαλfα→αxα. f(· · · f(x) · · · )
representing numbers.
We can now generalize the notion of a deﬁnable
integer function in the obvious way. Clearly, all functions deﬁnable in simple
types can also be deﬁned in System F by simply adding some Λ’s at the
beginning. For instance, we deﬁne the successor function as:
succ := λnω.Λα.λfα→αxα. f(nαfx).
But one can do much more, for instance the function n 7→nn can be deﬁned
as follows:
Exp := λnω. n(α →α)(nα).
Note that this trick uses polymorphism in an essential way. We can general-
ize it to represent primitive recursion. Indeed, System T (as an equational
theory) can be embedded into System F.
12.4.4. Proposition. For a given type σ, deﬁne rσ : σ →(σ →ω →σ) →
ω →σ as the following term:
λyσλfσ→ω→σλnω. π1(n(σ∧ω)(λvσ∧ω. ⟨f(π1(v))(π2(v)), succ(π2(v))⟩)⟨y, c0⟩).
Then rσMN(c0) =β M and rσMN(succ(n)) =β N(rσMNn)n,
Proof. Exercise 12.7.8.
⊓⊔
The reader is invited to deﬁne representation of various other data types in
Exercise 12.7.7.
Let us now consider the existential quantiﬁer. We need a term assign-
ment the introduction and elimination rules. One possibility is as follows:

202
Chapter 12. Second-order logic and polymorphism
(∃I)
Γ ⊢M : σ[α := τ]
Γ ⊢pack M, τ to ∃α. σ : ∃α. σ
(∃E)
Γ ⊢M : ∃α. σ
Γ, x : σ ⊢N : ρ
Γ ⊢abstype α with x : σ is M in N : ρ
(α ̸∈FV (Γ, ρ))
As in the ﬁrst-order case, existential quantiﬁcation corresponds to data ab-
straction. An existential type of the form ∃α σ can be seen as a partial type
speciﬁcation, where type α is “private” and not accessible for the user. For
instance, one can consider a type of push-down stores (with the push and
pop operations) deﬁned as
ω-pds := ∃α(α ∧(ω →α →α) ∧(α →α ∧ω)).
A user can operate on such a pds without knowing the actual type used to
implement it. A generic pds type may now be deﬁned this way:
generic-pds := ∀β∃α(α ∧(β →α →α) ∧(α →α ∧β)).
The beta reduction rule for existential type constructors is as follows:
abstype α with x : σ is pack M, τ to ∃α. σ in N −→β N[α := τ][x := M].
This corresponds to using an abstract type in a context where an actual
implementation may be hidden from the user. More on existential types can
be found in Mitchell’s book [74].
Existential quantiﬁcation can be represented in System F as follows:
12.4.5. Definition. Assuming β ̸∈FV(σ), we deﬁne
∃α σ := ∀β(∀α(σ →β). →β).
The packing and unpacking terms are as follows:
• pack M, τ to ∃α. σ = Λβ.λx∀α(σ→β). xτM;
• abstype α with x : σ is M in N ρ = Mρ(λα.λxσ.N).
Compare the above deﬁnition to Deﬁnition 12.4.3. We again have the weak-
est common consequence of all σ(α), for arbitrary type α. This supports
the understanding of existential quantiﬁer as inﬁnite disjunction. But note
also that there is a similarity to De Morgan’s law here: take ⊥instead of β
and we obtain ¬∀α¬σ. We leave to the reader the veriﬁcation that beta
reduction is correctly implemented.

12.5. Curry-style polymorphism
203
12.5. Curry-style polymorphism
The Curry-style variant of System F is deﬁned by the following type assign-
ment rules for pure lambda terms. These rules correspond exactly to these
in Deﬁnition 12.3.2. (The notion of a type and a context remains the same.)
Γ, x:τ ⊢x : τ
Γ ⊢N : τ →σ
Γ ⊢M : τ
Γ ⊢NM : σ
Γ, x : τ ⊢M : σ
Γ ⊢λx.M : τ →σ
Γ ⊢M : σ
Γ ⊢M : ∀α σ
(α ̸∈FV (Γ))
Γ ⊢M : ∀α σ
Γ ⊢M : σ[α := τ]
Rules for abstraction and application are the same as for the simply-typed
Curry-style lambda-calculus. Rules for introducing and eliminating the uni-
versal quantiﬁer (called respectively generalization and instantiation rules)
reﬂect the idea of implicit polymorphism: to have the universal type ∀α τ
means to have all possible instances of this type (all types τ[α := σ]).
12.5.1. Definition. The erasure map | · | from terms of Church-style Sys-
tem F to pure lambda terms, is deﬁned by the following clauses:
|x|
=
x
|MN|
=
|M||N|
|λx:σ. M|
=
λx. |M|
|Λα. M|
=
|M|
|Mτ|
=
|M|
12.5.2. Proposition. For a pure lambda term M, we have Γ ⊢M : τ if and
only if there is a Church-style term M0 with |M0| = M, such that Γ ⊢M0 : τ.
Proof. Easy.
A Church-style term M0 can be seen as a type derivation for a Curry-
style term |M0|. The following theorem follows from the fact that every
beta reduction performed in a typable pure lambda term corresponds to a
reduction in the corrsponding Church-style term.
12.5.3. Theorem (Subject reduction). Let Γ ⊢M : τ, for a pure lambda
term M. Then M →β M′ implies Γ ⊢M′ : τ.
Proof. Omitted.
⊓⊔

204
Chapter 12. Second-order logic and polymorphism
The above result is not as obvious as it can perhaps appear at the ﬁrst look.
To see this, consider the following example:
12.5.4. Example. We have the following correct type assignment:
x : α →∀β (β →β) ⊢λy. xy : α →β →β,
and the eta-reduction λy. xy →η x. However,
x : α →∀β (β →β) ̸⊢x : α →β →β.
Observe that the Church-style term corresponding to λy. xy in our example
is λy:α. xyβ and is not an η-redex. Thus, the reason why Curry-style Sys-
tem F is not closed under η-reductions is that there are Curry-style η-redexes
that do not correspond to any Church-style redex.
12.5.5. Remark. Closure under η-reductions can be obtained (see Mitchell’s
paper [73]) by adding to the system a certain subtyping relation ≤together
with a subsumption rule of the form
Γ ⊢M : τ,
τ ≤σ
Γ ⊢M : σ.
12.5.6. Remark. Adding existential quantiﬁcation to Curry-style version of
System F results with the same problem as that described in Section 9.10.
See Exercise 12.7.10.
With polymorphism, one can assign types to many pure lambda terms
which are untypable in simple types. A prominent example is λx. xx, and
another one is c2K. As we will see below, only strongly normalizable terms
can be typable, because of strong normalization.
But there are strongly
normalizable terms, untypable in F. The ﬁrst such example4 was given by
Simona Ronchi Della Rocca and Paola Giannini in the paper [43], and it is
the following term:
(λzy. y(zI)(zK))(λx. xx).
The essential thing here is that we cannot ﬁnd one type for (λx. xx) that
could be applied to both I and K. Another example is:
c2c2K.
Compare the latter to the typable term c2(c2K).
It was long an open question whether the type reconstruction and type
checking problem for System F was decidable. Both were shown undecidable
by Joe Wells.
12.5.7. Theorem (Wells [117]). Type reconstruction and type checking in
the second-order λ-calculus are recursively equivalent and undecidable.
Proof. Too long.
⊓⊔
4apparently based on an idea of Furio Honsell.

12.6. Strong normalization of second-order typed λ-calculus
205
12.6. Strong normalization of second-order typed λ-calculus
We end the chapter by extending the proof of strong normalization of simply
typed λ-calculus from Chapter 4 to second-order typed λ-calculus `a la Curry.
As mentioned earlier, the standard method of proving strong normaliza-
tion of typed λ-calculi was invented by Tait [104] for simply typed λ-calculus
and generalized to second-order typed λ-calculus by Girard [44].
Our presentation follows again [8].
12.6.1. Definition.
(i) The set of type variables is denoted U and the set of second-order types
is denoted by Π2.
(ii) A valuation in S is a map
ξ : U →S.
(iii) For a valuation ξ, deﬁne the valuation ξ{α := X} by: deﬁned by
ξ{α := X}(β) =
½ X
if α = β
ξ(β)
otherwise
(iv) For each valuation ξ in S and each σ ∈Π2 the set [[σ]]ξ is deﬁned by:
[[α]]ξ
=
ξ(α)
[[σ →τ]]ξ
=
[[σ]]ξ →[[τ]]ξ
[[∀α.σ]]ξ
=
T
X∈S[[σ]]ξ{α:=X}
12.6.2. Lemma. For each valuation ξ in S and σ ∈Π2, we have [[σ]]ξ ∈S.
Proof. Similar to the corresponding proof for λ→.
⊓⊔
12.6.3. Definition.
(i) Let ρ be a substitution (i.e., a map from term variables to Λ), and ξ be
a valuation in S. Then
ρ, ξ |= M : σ ⇔[[M]]ρ ∈[[σ]]ξ
(ii) Let ρ be a substitution and ξ be a valuation in S. Then
ρ, ξ |= Γ ⇔ρ, ξ |= x : σ, for all x : σ in Γ
(iii) Finally,
Γ |= M : σ ⇔∀ρ∀ξ[ρ, ξ |= Γ ⇒ρ, ξ |= M : σ]
12.6.4. Proposition (Soundness).
Γ ⊢M : σ ⇒Γ |= M : σ

206
Chapter 12. Second-order logic and polymorphism
Proof. Similar to the proof for the corresponding property of λ→, i.e.,
by induction on the derivation of Γ ⊢M : σ. There are two new cases
corresponding to the ∀-rules.
If the derivation ends in
Γ ⊢M : ∀α.σ
Γ ⊢M : σ{α := τ}
then by the induction hypothesis
Γ |= M : ∀α.σ
Now suppose ρ, ξ |= Γ, and we are to show that ρ, ξ |= M : σ{α := τ}. We
have
[[M]]ρ ∈[[∀α.σ]]ξ =
\
X∈S
[[σ]]ξ{α:=X}
Hence
[[M]]ρ ∈[[σ]]ξ{α:=[[τ]]ξ} = [[σ{α := τ}]]ξ.
If the derivation ends in
Γ ⊢M : σ
Γ ⊢M : ∀α.σ
where α is not free in Γ, then by the induction hypothesis,
Γ |= M : σ.
Suppose ρ, ξ |= Γ, we are to show that ρ, ξ |= M : ∀α.σ. Since α is not free
in Γ, we have for all X ∈S that ρ, ξ{α := X} |= Γ. Therefore,
[[M]]ρ ∈[[σ]]ξ{α:=X}
for all X ∈S. Hence also
[[M]]ρ ∈[[∀α.σ]]ξ
as required.
⊓⊔
12.6.5. Theorem (Strong normalization). If Γ ⊢M : σ then M is strongly
normalizing.
Proof. Similar to the corresponding proof for λ→.
⊓⊔
The above proof diﬀers in a very substantial way from Tait’s strong
normalization proof for simple types or for System T. The diﬀerence is that
a formalization of this argument necessarily requires quantiﬁcation over sets
of sets of λ-terms.

12.7. Exercises
207
Indeed, let us compare the statement of Lemma 12.6.2 and Lemma 4.4.3
part (iii). As we have noticed in Chapter 11, the latter requires quantiﬁca-
tion over sets X satisfying the deﬁnition of [[σ]]. But then we could deﬁne
a ﬁxed set [[σ]] for each σ by induction. Because of impredicativity, such a
deﬁnition of [[σ]] would now become circular and we must consider various
candidates [[σ]]ξ for the position of [[σ]]. Each ξ gives a family of such candi-
dates (sets), and the quantiﬁcation over ξ in the statement of Lemma 12.6.2
is equivalent to quantiﬁcations over these families.
In other words, our proof cannot be formalized even in the second-order
language of arithmetic. In fact, we can repeat G¨odel’s argument and obtain
a consistency proof for second-order Peano Arithmetic in this way. Thus,
strong normalization for System F makes an example of a statement inde-
pendent from second-order Peano Arithmetic.
But as long as we are only interested in strong normalization of a set
of terms involving only ﬁnitely many types, we can proceed within second-
order arithmetic. Indeed, in this case, the functions ξ are of ﬁnite domains
and can be handled as tuples of sets. Thus, if (an algorithm of) an integer
function is deﬁnable in F, then its totality can be shown within second-order
arithmetic. On the other hand, the Dialectica interpretation, generalized by
Girard for System F, allows one to derive a deﬁnition in F for every function
provably total in second-order arithmetic. We obtain the following result:
12.6.6. Theorem (Girard). The class of functions deﬁnable in F coincides
with the class of provably recursive functions of second-order Peano Arith-
metic.
12.7. Exercises
12.7.1. Exercise. Prove that Gabbay’s axiom holds in all Kripke models
with constant domains, but not in all Kripke models.
12.7.2. Exercise. Can you simplify the deﬁnition of forcing of universal
formulas in models with constant domains? Hint: Yes, you can.
12.7.3. Exercise. Show that in complete Kripke models, the semantics of
the deﬁned connectives (see Section 12.4) coincides with the semantics of
their deﬁnitions. Does this hold in non-complete models?
12.7.4. Exercise. Show that the type assignment rules for pairs and pro-
jections are correct under Deﬁnition 12.4.2 and that πi(⟨P1, P2⟩) →
→β Pi.
12.7.5. Exercise. Show that the type assignment rules for injections and
case elimination are correct under Deﬁnition 12.4.3 and that beta-reduction
is properly implemented, i.e.,
case(ini(Nτi); xτ1
1 .Mρ
1 ; xτ2
2 .Mρ
2 ) →
→β Mi[xi := N].

208
Chapter 12. Second-order logic and polymorphism
12.7.6. Exercise. Consider the eta reduction rule for disjunction, and the
commuting conversions of Deﬁnition 7.23. Are they correct with respect to
Deﬁnition 12.4.3?
12.7.7. Exercise. Deﬁne an interpretetion in System F for the types of:
• words over a ﬁxed ﬁnite alphabet;
• ﬁnite binary trees;
• lists over a type τ,
with the appropriate basic operations on these types.
12.7.8. Exercise. Prove Proposition 12.4.4. Can you strenghten it by re-
placing =β by →
→β?
12.7.9. Exercise. Show that the deﬁnitions of abstype and pack in Sys-
tem F satisfy the beta reduction rule for existential types.
12.7.10. Exercise. Consider a Curry-style calculus with existential types,
analogous to the Curry-style calculus with ﬁrst-order existential quantiﬁca-
tion, as in Section 10.5. Show that it does not have the subject reduction
property.
12.7.11. Exercise. Verify the correctness of Example 12.5.4.
12.7.12. Exercise. Show that all terms in normal form are typable in Sys-
tem F.
12.7.13. Exercise. Show that (λx. xx)(λz. zyz) is typable in System F.
12.7.14. Exercise. Show an example of a pure lambda-term M, typable in
System F, and such that M →η M′, for some untypable M′. Warning: An
example known to the authors is the term
λa. [λyz. a((λv. v(λxy. yay))y)(zy)(z(λx. xxx))]Y Z,
where Y is λx. K(xx)(xaa) and Z is λu. u(λxy. a). A veriﬁcation takes 5
handwritten pages.
12.7.15. Exercise. Prove that (λx. xx)(λx. xx) is untypable in System F,
without using the fact that typable terms can be normalized.
12.7.16. Exercise. Prove that the terms c2c2K and (λzy. y(zI)(zK))(λx. xx)
are untypable in System F.
12.7.17. Exercise. Show that the polymorphic type assignment has no prin-
cipal type property. (For instance show that λx. xx has no principal type.)
12.7.18. Exercise. Assume strong normalization for Curry-style System F.
Derive strong normalization for Church-style System F.

CHAPTER 13
The λ-cube and pure type systems
In this chapter we introduce Barendregt’s λ-cube which can be seen as a
generic typed λ-calculus with eight instances. Among these are λ→, λ2,
and λP seen earlier. We also present the generalization to pure type systems
which can be seen as a generic typed λ-calculus with inﬁnitely many typed
λ-calculi as instances—among these are the eight systems of the λ-cube.
We ﬁrst present some motivation for the study of the λ-cube and then
proceed to the actual deﬁnitions. A number of examples are given to illus-
trate various aspects of the λ-cube. We then argue that the new presenta-
tions of λ→etc. are equivalent to the previous presentations, although we
do not settle this in all detail.
After this, we introduce pure type systems, give a number of examples,
and develop the most rudimentary theory of pure type systems.
The presentation follows [8].
13.1. Introduction
The previous chapters of the notes have presented several related typed λ-
calculi, e.g, the simply typed λ-calculus λ→, the system λP of dependent
types, and the second-order typed λ-calculus λ2.1
The simplest of the systems is clearly simply typed λ-calculus; in this
system one can have a term λx:σ . x of type σ →σ, in short
⊢λx:σ . x : σ →σ.
Given a term M, we may form the new term λx : σ . M which expects a
term as argument; in other words, the term λx : σ . M depends on a term.
Thus, in λ→, terms may depend on terms.
1In this chapter we are exclusively concerned with typed λ-calculi `a la Church.
209

210
Chapter 13. The λ-cube and pure type systems
In λ2 one can have a term2 Λα:∗. λx:α . x of type ∀α.α →α, in short
⊢Λα:∗. λx:α . x : ∀α.α →α.
Given a term M, we may form the new term Λα: ∗. M which expects a
type σ as argument; in other words, the term Λα: ∗. M depends on a type.
Thus, in λ2 terms may depend on types.
Finally, in the system λP, we can have an expression λx:α . α expecting
a term of type α as argument and returning the type α as result. Such
an expression is called a type constructor since it constructs a type when
provided with suitable arguments. To describe the input and output of a
term one uses types; a term has a certain type. Similarly, the input and
output of constructors are described by kinds. For instance, if α is a type,
then λx:α . α has kind α →∗, in short
α : ∗⊢λx:α . α : α ⇒∗,
expressing the fact that the constructor expects a term of type α and con-
structs a member of ∗, i.e., a type. If we apply this expression to a term of
type α, then we get a type:
α : ∗, y : α ⊢(λx:α . α) y : ∗.
In conclusion, given a type α we may form the type constructor λx : α . α
which expects a term of type α as argument; in other words, the type con-
structor λx : α . α depends on a term. Thus, in λP types may depend on
terms.
There is one combination we have not mentioned: we have seen terms
depending on terms, terms depending on types and types depending on
terms—what about types depending on types? Can we have expressions
like λα : ∗. α →α? This would again be a type constructor, but where
the argument is now a type rather than a term; such an expression would
have kind ∗→∗. In fact, a system exists in which such expressions may be
formed, known as λω.
The three systems λ2, λP, and λω each arise from λ→by adding an-
other type of dependency than terms depending on terms; it is natural to
study also the combination of these dependencies, and systems exist in which
several dependencies are allowed, e.g., the system λω in which both terms
depending on types and types depending on types are allowed, and this will
also be done below.
Before proceeding with the details of such systems, it will be well worth
our eﬀort to reconsider the style or presentation from previous chapters.
In all the λ-calculi presented in previous chapters, one or more forms of
2The annotation “: ∗” was not written in the preceding chapter. The informal meaning
of σ : ∗is that σ is a type.

13.2. Barendregt’s λ-cube
211
abstraction are present, and diﬀerent rules govern the typing of the various
forms of abstraction. For instance, in λ2 we have both
Γ, x : σ ⊢M : τ
Γ ⊢λx:σ . M : σ →τ
and
Γ ⊢M : τ
Γ ⊢Λα: ∗. M : ∀α.τ
Similarly, we have several types of products, e.g. σ →τ and ∀α.σ.
It would be better if we could present the systems with a single notion of
abstraction parametrized over the permitted dependencies. This is exactly
what one does on the λ-cube.
This idea facilitates a more slick presentation of each of the systems
in the λ-cube, and also makes the connection between the various systems
more transparent. Moreover, properties about the various systems can be
developed once and for all by providing proofs that are parametric in the
permitted dependencies: if we can prove, e.g., subject reduction regardless
of which dependencies are permitted, then we do not have to prove the
property for all the systems individually.
13.2. Barendregt’s λ-cube
We introduce Barendregt’s λ-cube following [8].
13.2.1. Definition.
(i) The set S of sorts is deﬁned by S = {∗, 2}. We use s, s′, s1, s2, etc. to
range over sorts.
(ii) For each s ∈S, let Vs denote a countably inﬁnite set of variables such
that Vs ∩Vs′ = ∅when s ̸= s′, and let V = S
s∈S Vs.
(iii) The set E of expressions is given by the abstract syntax:
E = V | S | EE | λV : E.E | ΠV : E.E
As before, we assume familiarity with the subexpression relation ⊆, with
the set FV(M) of free variables of M, and with substitution M{x := N}
for x ∈V and M, N ∈E. We write A →B for Πd:A.B when d ̸∈FV(B).
We use = to denote syntactic identity modulo α-conversion and adopt
the usual hygiene conventions.
(iv) The relation →β on E is the compatible closure of the rule
(λx:A . M) N
β
M{x := N}
Also, →
→β and =β are the transitive, reﬂexive closure and the transitive,
reﬂexive, symmetric closure of →β, respectively.

212
Chapter 13. The λ-cube and pure type systems
(v) The set C of contexts is the set of all sequences
x1 :A1, . . . , xn :An
where x1, . . . , xn ∈V, A1, . . . , An ∈E, and xi ̸= xj when i ̸= j.
The empty sequence is [], and the concatenation of Γ and ∆is Γ, ∆.
We write x : A ∈Γ if Γ = Γ1, x : A, Γ2, for some Γ1, Γ2, and we
write Γ ⊆∆if, for every x : A ∈Γ, also x : A ∈∆.
For Γ ∈C,
dom(Γ) = {x | x:A ∈Γ, for some A}.
(vi) For any set R ⊆S × S of rules, the relation ⊢⊆C × E × E is deﬁned
in Figure 13.1. If Γ ⊢M : A, then Γ is legal and M, A are legal (in
Γ). We use the notation Γ ⊢A : B : C meaning that Γ ⊢A : B and
Γ ⊢B : C.
(axiom)
[] ⊢∗: 2
(start)
Γ ⊢A : s
Γ, x:A ⊢x : A
if x ∈Vs & x ̸∈dom(Γ)
(weakening)
Γ ⊢A : B
Γ ⊢C : s
Γ, x:C ⊢A : B
if x ∈Vs & x ̸∈dom(Γ)
(product)
Γ ⊢A : s1
Γ, x:A ⊢B : s2
Γ ⊢(Πx:A. B) : s2
if (s1, s2) ∈R
(application)
Γ ⊢F : (Πx:A. B)
Γ ⊢a : A
Γ ⊢F a : B{x := a}
(abstraction)
Γ, x:A ⊢b : B
Γ ⊢(Πx:A. B) : s
Γ ⊢λx:A . b : Πx:A. B
(conversion)
Γ ⊢A : B
Γ ⊢B′ : s
Γ ⊢A : B′
if B =β B′
Figure 13.1: Inference rules of the λ-cube
(vii) The λ-cube consists of the eight λ-calculi obtained by taking the diﬀer-
ent sets of rules {(∗, ∗)} ⊆R ⊆{(∗, ∗), (2, ∗), (∗, 2), (2, 2)} speciﬁed
in the table in Figure 13.2.

13.2. Barendregt’s λ-cube
213
λ→
(∗, ∗)
λ2
(∗, ∗)
(2, ∗)
λω
(∗, ∗)
(2, 2)
λω = λω2
(∗, ∗)
(2, ∗)
(2, 2)
λP
(∗, ∗)
(∗, 2)
λP2
(∗, ∗)
(2, ∗)
(∗, 2)
λPω
(∗, ∗)
(2, 2)
(∗, 2)
λC = λPω
(∗, ∗)
(2, ∗)
(2, 2)
(∗, 2)
Figure 13.2: Rules of the λ-cube
13.2.2. Remark. The diﬀerent rules in Figure 13.2 correspond to the de-
pendencies mentioned earlier:
(∗, ∗) :
terms depending on terms
(∗, 2) :
terms depending on types
(2, ∗) :
types depending on terms
(2, 2) :
types depending on types
Informally speaking, terms may also depend on types in λ→; for instance,
λx : α . x is a term depending on the type α. However, the crucial point
is that we may not abstract over α in the term. In contract, this form of
abstraction is permitted in λ2.
The λ-cube is depicted diagrammatically in Figure 13.3.
λω
//λC
λ2
??
¨¨¨¨¨¨¨¨¨¨¨
//λP2
??
¨¨¨¨¨¨¨¨¨¨¨
λω
//
OO
λPω
OO
λ→
OO
//
??
¨¨¨¨¨¨¨¨¨¨¨
λP
??
¨¨¨¨¨¨¨¨¨¨¨
OO
Figure 13.3: The λ-cube

214
Chapter 13. The λ-cube and pure type systems
13.3. Example derivations
There are several subtle details in the previous deﬁnition. Some of these
are illustrated in the following examples, taken from [8], which the reader is
encouraged to work out in detail.
13.3.1. Example. In λ→one can derive the following.
1. α : ∗⊢Πx:α. α : ∗. Being a member of ∗should be conceived as being
a type, so if α is a type, then so is Πx:α. α.
Here α is a variable from V2 (type variables) and x is another variable
from V∗(term variables). Hence x ̸∈FV(α), so Πx: α. α = α →α,
using the abbreviation from Deﬁnition 13.2.1(iii).
This means that we may form expressions that map terms of type α
to terms of type α (terms may depend on terms).
Note that the type variable α must be declared in the context; the
only typing in the empty context in this formulation of λ→is ⊢∗: 2!
2. α : ∗⊢λx : α . x : Πx: α. α. Using the abbreviation from Deﬁni-
tion 13.2.1(iii), this means that we have α : ∗⊢λx:α . x : α →α.
Note that α : ∗⊢λx : α . x : Πx: α. α does not follow from the
mere fact that α : ∗, x : α ⊢x : α alone; we also have to show that
α : ∗⊢Πx:α.α : ∗, which can be derived using the fact that (∗, ∗) ∈R.
3. α : ∗, β : ∗, y : β ⊢λx:α . y : Πx:α. β.
4. α : ∗, y : α ⊢(λx:α . x) y : α.
5. α : ∗, y : α ⊢y : α. We have
(λx:α . x) y
→β
y.
Note that typing is preserved under this particular reduction.
6. α : ∗, β : ∗, x : α, y : β ⊢(λz : α . y) x : β. Note how the weakening
rule is required to establish this.
7. α : ∗, β : ∗⊢λx:α . λy:β . y : α →β →α : ∗.
13.3.2. Example. In λ2 one can derive the following.
1. α : ∗⊢λx:α . x : α →α, just like in λ→.
2. ⊢λα:∗. λx:α . x : Πα:∗. α →α : ∗.
To understand the relationship with the previous formulation of λ2,
the reader should realize that Πα: ∗. σ is just a new way of writing
∀α.σ and that λα:∗. M is just a new way of writing Λα:∗. M.

13.3. Example derivations
215
This means that we may form expressions that map any type α to a
term of type α →α (terms may depend on types).
The reader may be worried about the absence of the side condition
“where α is not free in the context” in the abstraction rule for second-
order generalization. How can we be sure that we do not move from
α : ∗, x : α ⊢M : σ to x : α ⊢λα : ∗. M : Πα: ∗. σ, where we
generalize over a variable which is free in the context? Interestingly,
this is ensured by the fact that contexts are sequences and that we
may discharge the rightmost assumption only.
This also shows why the weakening rule is necessary: without weaken-
ing, we could not derive something as elementary as α : ∗, x : α ⊢α : ∗.
3. β : ∗⊢(λα:∗. λx:α . x) β : β →β.
4. β : ∗, y : β ⊢(λα:∗. λx:α . x) β y : β. We have
(λα:∗. λx:α . x) β y
→β
(λx:β . x) y
→β
y
and each of these terms has type β.
5. Let ⊥= Πα:∗.α. Then ⊢(λβ :∗. λx:⊥. x β) : Πβ:∗.⊥→β. Via the
Curry-Howard isomorphism this type is a proposition in second-order
propositional logic which states that everything follows from absurdity;
the term is the constructive proof of the proposition.
13.3.3. Example. Let D = λβ : ∗. β →β.
In λω one can derive the
following.
1. ⊢∗→∗: 2. Being a member of 2 should be conceived as being a
kind, so ∗→∗is a kind.
This means that we may form expressions that map types to types
(types may depend on types).
2. ⊢D : ∗→∗.
3. α : ∗⊢D α : ∗.
4. α : ∗⊢D (D α) : ∗.
5. α : ∗⊢λx:(D α) . x : (D α) →(D α).
6. α : ∗⊢λx:(D α) . x : D (D α). Note how the conversion rule is used
to derive this. We have
(D α) →(D α) =β D (D α)
and the conversion rule allows us to exchange the ﬁrst type with the
second.

216
Chapter 13. The λ-cube and pure type systems
13.3.4. Example. In λP one can derive the following.
1. α : ∗⊢α →∗: 2.
This means that we may form expressions that map a term of type α
to a type (types may depend on terms).
If we view α as a set and ∗as the universe of propositions, then a
member of α →∗is a map from α to propositions, i.e., a predicate
on α.
2. α : ∗, p : α →∗, x : α ⊢p x : ∗. Again, if we view α as a set, p as a
predicate on α, and x as an element of α, then p x is a proposition.
3. α : ∗, p : α →α →∗⊢Πx:α. p x x : ∗.
If α is a set and p is a binary predicate on α, then Πx: α. p x x is a
proposition.
4. α : ∗, p : α →∗, q : α →∗⊢Πx: α. p x →q x : ∗. This proposition
states that every member of α which satisﬁes p also satisﬁes q.
5. α : ∗, p : α →∗⊢λx:α . λz :p x . z : Πx:α. p x →p x.
6. α : ∗, x0 : α, p : α →∗, q : ∗⊢
λz :(Πx:α. p x →q) . λy:(Πx:α. p x) . (x a0) (y a0) :
(Πx:α. p x →q) →(Πx:α. p x) →q.
This proposition states that in every non-empty set A,
(∀x ∈A : P x →Q) →(∀x ∈A : P x) →Q.
13.3.5. Example. In λω, the following can be derived.
1. Let α&β = Πγ: ∗. (α →β →γ) →γ. Then α : ∗, β : ∗⊢α&β : ∗.
This is can also be derived in λ2; it is the second-order deﬁnition of
conjunction.
2. Let AND = λα : ∗. λβ : ∗. α&β. Then ⊢AND : ∗→∗→∗and
⊢AND α β : ∗. Thus, AND is a uniform deﬁnition of conjunction over
all types—this cannot be done in λ2.
3. Let πi = λα1 :∗. λα2 :∗. λx1 :α1 . λx2 :α2 . xi. Then
⊢πi : Πα1:∗. Πα2:∗. α1 →α2 →αi.
Also,
α : ∗, β : ∗⊢λx:AND α β . x α (π1 α β) : AND α β →α.

13.4. Classiﬁcation and equivalence with previous formulations
217
13.3.6. Example. In λP2 the following can be derived.
1. α : ∗, p : α →∗⊢λx:α . p x →⊥: α →∗Here the construction of ⊥
requires λ2 and the construction of expressions α →∗requires λP.
2. α : ∗, p : α →α∗⊢(Πx:α. Πy:α. p x y →p y x →⊥) →Πz:α. p z z →
⊥: ∗. This proposition states that an asymmetric binary relation is
irreﬂexive.
13.3.7. Example. In λPω the following can be derived.
1. α : ∗⊢λp:α →α →∗. λx:α . p x x : (α →α →∗) →(α →∗).
This constructor maps any predicate to its own “diagonalization.”
Here the presence of ∗to the left and right of →requires λω, and the
construction of α →∗requires λP.
2. ⊢λα:∗. λp:α →α →∗. λx:α . pxx : Πα:∗.(α →α →∗) →(α →∗).
This constructor does the same uniformly in α.
13.3.8. Example. In λC the following can be derived.
1. λα:∗. λp:α →⊥. λx:α . p x →⊥: Πα:∗. (α →∗) →(α →∗). This
constructor maps a type α and a predicate p on α to the negation of p.
Here the presence of ∗on both sides of →requires λω, and A →∗
requires λP, and Πα:∗. . . . requires λ2.
13.4. Classiﬁcation and equivalence with previous formula-
tions
The above presentation of λ→etc. has several advantages, as mentioned
above. However, the presentation also has the disadvantage that in the case
of some of the simple systems (e.g. λ→) the presentation involves a certain
amount of redundancy. For instance, in case of λ→the product Πx: A. B
mentioned in the product rule always has form A →B. Also, the distinction
between terms, types, and kinds, which is abandoned in the cube is, after
all, useful for understanding the details of the various systems.
In this section we therefore try to recover some of what has been lost by
showing that—to a certain extent—the traditional formulations of some of
the systems in the λ-cube are equivalent with the formulations in terms of
the λ-cube. More about this can be found in [12, 8, 41].
Below we show how terms belonging to systems in the λ-cube can be
classiﬁed according to the notions of object, constructors, and kinds.

218
Chapter 13. The λ-cube and pure type systems
13.4.1. Definition. Deﬁne the sets O, T , K of objects, constructors, and
kinds as follows:
O
::=
V∗
| λV∗:T . O | O O | λV2 :K . O | O T
T
::=
V2
| λV∗:T . T | T O | λV2 :K . T | T T | ΠV∗:T . T | ΠV2:K. T
K
::=
ΠV∗:T . K | ΠV2:K. K | ∗
Reading objects as terms, constructors as types, and kinds as—well—
kinds, this crystalizes the four forms of dependencies between terms and
types expressed by the four forms of abstractions, or the four forms of prod-
ucts.
The following selects among the above expressions those that are legal.
In the deﬁnition and the following proposition, ⊢refers to λC.
13.4.2. Definition. Deﬁne the sets O+, T +, K+ as follows:
O+
=
{O ∈O | ∃Γ, A . Γ ⊢O : A}
T +
=
{T ∈T | ∃Γ, A . Γ ⊢T : A}
K+
=
{K ∈K | ∃Γ . Γ ⊢K : 2}
13.4.3. Proposition (Classiﬁcation of the λ-cube).
1. The sets O+, T +, K+ and {2} are pairwise disjoint and closed under
reduction.
2. If Γ ⊢A : B then exactly one of the following holds:
• (A, B) ∈O+ × T +, or
• (A, B) ∈T + × K+, or
• (A, B) ∈K+ × {2}
One obtains similar classiﬁcations for particular systems within the λ-cube:
1. For λ →,λ2,λω, and λω omit the clauses λV ∗: T . T , T O, and
ΠV ∗:T . K;
2. For λ→,λ2,λP2, and λP omit the clauses λV 2 : K . T , T T , and
ΠV 2:K. K;
3. For λ→,λω,λPω, and λP omit the clauses λV 2 : K . O, O T , and
ΠV 2:K. T .
One can use this to show, e.g., that in λ→products Πx:α. β in fact always
have form α →β, i.e., x ̸∈FV(α).

13.5. Pure type systems
219
13.5. Pure type systems
In this subsection we introduce pure type systems, as presented by Baren-
dregt, Geuvers, and Nederhof [8, 42, 41]. The main ideas in the step from
the λ-cube to pure type systems are the following:
1. One takes a set S as the set of sorts rather than just {∗, 2}.
2. One takes a relation A ⊆S × S as the set of axioms rather than the
single axiom (∗: 2).
3. One takes a relation R ⊆S × S × S as the set of rules rather than the
speciﬁc sets of rules from Figure 13.2.
4. The product rule is generalized so that products need not live in the
same universe as their range. That is, A →B does not necessarily live
in the same sort as B.3
13.5.1. Definition. A pure type system (PTS) is a triple (S, A, R) where
(i) S is a set of sorts;
(ii) A ⊆S × S is a set of axioms;
(iii) R ⊆S × S × S is a set of rules.
We write (s, s′) ∈R for (s, s′, s′) ∈R.
13.5.2. Definition. Let (S, A, R) be a PTS.
(i) For each s ∈S, let Vs denote a countably inﬁnite set of variables such
that Vs ∩Vs′ = ∅when s ̸= s′, and let V = S
s∈S Vs.
(ii) The set E of expressions is given by the abstract syntax:
E = V | S | EE | λV : E.E | ΠV : E.E
We assume familiarity with the subexpression relation ⊆, with the set
FV(M) of free variables of M, and with substitution M{x := N} for
x ∈V and M, N ∈E. We write A →B for Πd:A. B when d ̸∈FV(B).
We use = to denote syntactic identity modulo α-conversion and adopt
the usual hygiene conventions—see [7].
(iii) The relation →β on E is smallest compatible relation satisfying
(λx:A . M) N
→β
M{x := N}
Also, →
→β and =β are the transitive, reﬂexive closure and the transitive,
reﬂexive, symmetric closure of →β, respectively.
3Notice the diﬀerence in the side condition in the product rule in the λ-cube and the
product rule in pure type systems (see below): in the latter case we also have to specify
s3—the sort in which the product is to live.

220
Chapter 13. The λ-cube and pure type systems
(iv) The set C of contexts is the set of all sequences
x1 :A1, . . . , xn :An
where x1, . . . , xn ∈V, A1, . . . , An ∈E, and xi ̸= xj when i ̸= j.
The empty sequence is [], and the concatenation of Γ and ∆is Γ, ∆.
We write x : A ∈Γ if Γ = Γ1, x : A, Γ2, for some Γ1, Γ2, and we
write Γ ⊆∆if, for every x : A ∈Γ, also x : A ∈∆.
For Γ ∈C,
dom(Γ) = {x | x:A ∈Γ, for some A}.
(v) The relation ⊢⊆C ×E ×E is deﬁned in Figure 13.4. If Γ ⊢M : A, then
Γ is legal and M, A are legal (in Γ). We use the notation Γ ⊢A : B : C
meaning that Γ ⊢A : B and Γ ⊢B : C.
(axiom)
[] ⊢s1 : s2
if (s1, s2) ∈A
(start)
Γ ⊢A : s
Γ, x:A ⊢x : A
if x ∈Vs & x ̸∈dom(Γ)
(weakening)
Γ ⊢A : B
Γ ⊢C : s
Γ, x:C ⊢A : B
if x ∈Vs & x ̸∈dom(Γ)
(product)
Γ ⊢A : s1
Γ, x:A ⊢B : s2
Γ ⊢(Πx:A. B) : s3
if (s1, s2, s3) ∈R
(application)
Γ ⊢F : (Πx:A. B)
Γ ⊢a : A
Γ ⊢F a : B{x := a}
(abstraction)
Γ, x:A ⊢b : B
Γ ⊢(Πx:A. B) : s
Γ ⊢λx:A . b : Πx:A. B
(conversion)
Γ ⊢A : B
Γ ⊢B′ : s
Γ ⊢A : B′
if B =β B′
Figure 13.4: Pure type systems
13.5.3. Convention. To save notation we often consider in the remainder a
PTS λS and say, e.g., that s ∈S or M ∈E with the understanding that λS =
(S, A, R) and that V, E, C, →β and ⊢are deﬁned as in Deﬁnition 13.5.2.

13.6. Examples of pure type systems
221
13.6. Examples of pure type systems
13.6.1. Example. The λ-cube consists of the eight PTSs λS, where
(i) S = {∗, 2};
(ii) A = {(∗, 2)};
(iii) {(∗, ∗)} ⊆R ⊆{(∗, ∗), (2, ∗), (∗, 2), (2, 2)}.
The following systems extend λω with sort △, axiom 2 : △, and some
rules for the new sort. The system λHOL is deﬁned by:
(i) S = {∗, 2, △};
(ii) A = {(∗, 2), (2, △)};
(iii) R = {(∗, ∗), (2, ∗), (2, 2)}.
The system λU−is deﬁned by:
(i) S = {∗, 2, △};
(ii) A = {(∗, 2), (2, △)};
(iii) R = {(∗, ∗), (2, ∗), (2, 2), (△, 2)}.
The system λU is deﬁned by:
(i) S = {∗, 2, △};
(ii) A = {(∗, 2), (2, △)};
(iii) R = {(∗, ∗), (2, ∗), (2, 2), (△, ∗), (△, 2)}.
13.6.2. Example. The system λ∗is deﬁned by:
(i) S = {∗};
(ii) A = {(∗, ∗)};
(iii) R = {(∗, ∗)}.
We end this section with an example of a somewhat diﬀerent pure type
system.
13.6.3. Example. The system λPRED is deﬁned by:
(i) S = {∗s, ∗p, ∗f, 2s, 2p};
(ii) A = {(∗s, 2s), (∗p, 2p)};
(iii) R = {(∗p, ∗p), (∗s, ∗p), (∗s, 2p), (∗s, ∗s, ∗f), (∗s, ∗f, ∗f)}.
This is another formulation of predicate logic as a PTS (other than λP).
The signiﬁcance of the sorts is as follows.

222
Chapter 13. The λ-cube and pure type systems
1. The sort ∗s is for sets.
2. The sort ∗p is for propositions.
3. The sort ∗f is for ﬁrst-order functions from sets to sets.
4. The sorts 2s and 2p contain ∗s and ∗p respectively.
There is no
sort 2f. This means that we cannot have variables ranging over func-
tion spaces.
The signiﬁcance of the rules is as follows.
1. The rule (∗p, ∗p) allows the formation of implication between proposi-
tions.
ϕ : ∗p, ψ : ∗p ⊢ϕ →ψ = Πx:ϕ. ψ : ∗p
2. The rule (∗s, ∗p) allows quantiﬁcation over sets.
α : ∗s, ϕ : ∗p ⊢∀x ∈α.ϕ = Πx:α. ϕ : ∗p
3. The rule (∗s, 2p) allows the formation of ﬁrst-order predicates.
α : ∗s ⊢α →∗p = Πx:α. ∗p : 2p
so
α : ∗s, p : α →∗p, x : α ⊢p x : ∗p.
4. The rule (∗s, ∗s, ∗f) allows the formation of function spaces between
sets.
α : ∗s, β : ∗s ⊢α →β : ∗f.
5. The rule (∗s, ∗f, ∗f) allows the formation of curried multi-argument
function spaces between sets.
α : ∗s ⊢α →(α →α) : ∗f.
13.7. Properties of pure type systems
As mentioned in the introduction, one of the reasons for introducing the
λ-cube is the desire to facilitate proofs which apply to a number of systems
at the same time. For instance, it is better to prove the subject reduction
property in a generic way which applies to all the systems in the λ-cube,
regardless of the particular set R of rules, than it is to prove the property
for each system individually.
This idea is even more compelling in the case of pure type systems:
having shown that a property holds for all pure type systems we know
not only that the property holds for all the systems of the λ-cube, but

13.7. Properties of pure type systems
223
also for inﬁnitely many other systems, a number of which have appeared
independently in the literature.
In this section we develop the most rudimentary theory of pure type
systems. Throughout the section, λS denotes an arbitrary pure type system.
13.7.1. Lemma (Properties of substitution).
1. A{x := B}{y := C} = A{y := C}{x := B{y := C}}, if y ̸∈FV(B);
2. B =β C ⇒A{x := B} =β A{x := C};
3. A =β B & C =β D ⇒A{x := C} =β B{x := D}.
Proof. (1)-(2): By induction on A. (3): By induction on A =β B, using
(1)-(2).
⊓⊔
13.7.2. Proposition (Church-Rosser). The relation →β on E is conﬂuent.
Proof. By the technique of Tait and Martin-L¨of—see e.g. [8].
⊓⊔
13.7.3. Lemma (Free variables). If x1 :A1, . . . , xn :An ⊢B : C then:
1. x1, . . . , xn are distinct;
2. FV(B) ∪FV(C) ⊆{x1, . . . , xn};
3. FV(Ai) ⊆{x1, . . . , xi−1} for 1 ≤i ≤n.
Proof. By induction on the derivation of x1 :A1, . . . , xn :An ⊢B : C.
⊓⊔
13.7.4. Lemma (Start). If Γ is legal then:
1. (s1, s2) ∈A ⇒Γ ⊢s1 : s2;
2. x:A ∈Γ ⇒Γ ⊢x : A.
Proof. Since Γ is legal Γ ⊢B : C for some B, C. Proceed by induction
on the derivation of Γ ⊢B : C.
⊓⊔
13.7.5. Lemma (Transitivity). Let ∆be legal. If x1 :A1 . . . , xn :An ⊢A : B
and ∆⊢xi : Ai for i = 1, . . . , n then ∆⊢A : B.
Proof. By induction on the derivation of x1 : A1, . . . , xn : An ⊢A : B
making use of the start lemma.
⊓⊔
13.7.6. Lemma (Substitution). If Γ, x:A, ∆⊢B : C and Γ ⊢a : A, then4
Γ, ∆{x := a} ⊢A{x := a} : B{x := a}.
4Substitution (and any other map) is extended from expressions to contexts in the
usual way.

224
Chapter 13. The λ-cube and pure type systems
Proof. By induction on the derivation of Γ, x:A, ∆⊢B : C using the free
variables lemma and properties of substitution.
⊓⊔
13.7.7. Lemma (Thinning). If Γ ⊢A : B, ∆is legal, and every (x:A) in Γ
is also in ∆, then ∆⊢A : B.
Proof. This follows from the start lemma and the transitivity lemma.
⊓⊔
13.7.8. Lemma (Generation). Suppose that Γ ⊢M : C.
1. M = s ⇒∃(s, s′) ∈A. C =β s′
2. M = x ⇒∃D ∈E. C =β D & x:D ∈Γ.
3. M = λx.Ab ⇒∃s∈S, B ∈E. C =β Πx:A. B & Γ,x:A ⊢b : B & Γ ⊢
Πx:A. B : s.
4. M = Πx:A. B ⇒∃(s1, s2, s3) ∈R. C =β s3 & Γ ⊢A : s1 & Γ, x :
A ⊢B : s2.
5. M = F a ⇒∃x∈V, A,B ∈E. C =β B{x := a} & Γ ⊢F : Πx:
A. B & Γ ⊢a : A.
Proof. By induction on the derivation of Γ ⊢M : C.
⊓⊔
13.7.9. Lemma (Correctness of types). If Γ ⊢A : B then either B ∈S or
∃s ∈S. Γ ⊢B : s.
Proof. By induction on Γ ⊢A : B, using the generation and substitution
lemmas.
⊓⊔
13.7.10. Theorem (Subject reduction). If Γ ⊢A : B and A →β A′ then
Γ ⊢A′ : B.
Proof. Prove by simultaneous induction on the derivation of Γ ⊢A : B:
1. if Γ ⊢A : B and A →β A′ then Γ ⊢A′ : B;
2. if Γ ⊢A : B and Γ →β Γ′ then Γ′ ⊢A : B.
The proof uses the substitution lemma.
⊓⊔

13.8. The Barendregt-Geuvers-Klop conjecture
225
13.8. The Barendregt-Geuvers-Klop conjecture
The following terminology should be well-known by now.
13.8.1. Definition. Let λS be a PTS. A β-reduction path from an expres-
sion M0 is a (possibly inﬁnite) sequence M0 →β M1 →β M2 →β . . . If the
sequence is ﬁnite, it ends in the last expression Mn and has length n.
13.8.2. Definition. Let λS be a PTS, and M an expression.
(i) M ∈∞β ⇔there is an inﬁnite β-reduction path from M;
(ii) M ∈NFβ ⇔there is no β-reduction path of length 1 or more from M;
(iii) M ∈SNβ ⇔all β-reduction paths from M are ﬁnite;
(iv) M ∈WNβ ⇔there is a β-reduction from M ending in N ∈NFβ.
Elements of NFβ, SNβ, WNβ are β-normal forms, β-strongly normalizing, and
β-weakly normalizing, respectively. We also write, e.g., ∞β(M) for M ∈∞β.
13.8.3. Definition. λS is weakly normalizing if all legal expressions are
weakly normalizing, and strongly normalizing if all legal expressions are
strongly normalizing. In this case we write λS |= WNβ and λS |= SNβ,
respectively.
13.8.4. Example. All the systems of the λ-cube are strongly normalizing—
see, e.g., [12, 8, 42, 41]. The system λ∗is the simplest PTS which is not
strongly normalizing. The system λU is is a natural extension of λω which,
surprisingly, is not strongly normalizing. This result shows that, apparently,
the fact that λ∗fails to be strongly normalizing is not merely a consequence
of the cyclicity in its axiom (∗, ∗).
We conclude the notes by mentioning an open problem in the ﬁeld—for
more on the problem see [101].
13.8.5. Conjecture (Barendregt, Geuvers, Klop). For every PTS λS:
λS |= WNβ ⇒λS |= SNβ

226
Chapter 13. The λ-cube and pure type systems

CHAPTER 14
Solutions and hints to selected exercises
Some of the solutions below are based on actual homework done in LATEX by
Henning Niss (1.7.7) and Henning Makholm (6.8.20 and 6.8.21). In one of
his homeworks, Henning Makholm has solved an apparently open problem
(Exercise 6.8.3).
Exercise 1.7.7
14.0.6. Lemma (Substitution Lemma). If x ̸= y and x ̸∈FV(L) then
M{x := N}{y := L} = M{y := L}{x := N{y := L}}
Proof. By induction on M.
Case M = x. Since x ̸= y:
M{x := N}{y := L}
=
x{x := N}{y := L}
=
N{y := L}
=
x{x := N{y := L}}
=
x{y := L}{x := N{y := L}}
=
M{y := L}{x := N{y := L}}
The remaining cases are shown in less detail.
Case M = y. Since x ̸∈FV(L):
M{x := N}{y := L}
=
L
M{y := L}{x := N{y := L}}
Case M = z where z ̸= x and z ̸= y. Then:
M{x := N}{y := L}
=
z
=
M{y := L}{x := N{y := L}}
Case M = λz.P. Without loss of generality we may assume z ̸= x and
227

228
Chapter 14. Solutions and hints to selected exercises
z ̸= y. Then by the induction hypothesis:
M{x := N}{y := L}
=
λz.P{x := N}{y := L}
=
λz.P{y := L}{x := N{y := L}}
=
M{y := L}{x := N{y := L}}
Case M = P Q. Similar to the preceding case.
⊓⊔
The following states that →
→β is compatible.
14.0.7. Lemma. Assume that P, P ′ ∈Λ are such that P →
→β P ′. Then, for
all x ∈V and all Q ∈Λ:
(i) λx.P →
→β λx.P ′;
(ii) P Q →
→β P ′ Q;
(iii) Q P →
→β Q P ′.
Proof. (i): By induction on the derivation of P →
→β P ′.
Case P →
→β P ′ because P →β P. Then λx.P
→β
λx.P ′. Therefore
also λx.P →
→β λx.P ′.
Case P →
→β P ′ because P →
→β P ′′ and P ′′ →
→β P. By the induction
hypothesis, λx.P →
→β λx.P ′′ and λx.P ′′ →
→β λx.P ′, so λx.P →
→β λx.P ′.
Case P →
→β P ′ because P = P ′. Then λx.P = λx.P ′. Therefore also
λx.P →
→β λx.P ′.
(ii)-(iii): induction on the deﬁnition of P →
→β P ′
⊓⊔
14.0.8. Lemma. For all P, P ′, Q ∈Λ, if
P →β P ′
then also
P{x := Q} →β P ′{x := Q}.
Proof. By induction on the derivation of P →β P ′. The interesting case
is P = (λy.P1) Q1 →β P1{y := Q1} = P ′. We have
((λy.P1) Q1){x := Q}
=
(λy.P1{x := Q}) (Q1{x := Q})
→β
P1{x := Q}{y := Q1{x := Q}}
=
P1{y := Q1}{x := Q},
where the last equality follows from the Substitution Lemma (since y is not
free in Q).
⊓⊔

229
14.0.9. Lemma. For all P, Q, Q′ ∈Λ, if
Q →β Q′
then also
P{x := Q} →
→β P{x := Q′}.
Proof. By induction on the structure of P.
Case P = x, then P{x := Q} = Q →β Q′ = P{x := Q′}.
Case P = y, then P{x := Q} = y →
→β y = P{x := Q′}.
Case P = λy.P ′, then
(λy.P ′){x := Q}
=
λy.P ′{x := Q}
→
→β
λy.P ′{x := Q′}
=
(λy.P ′){x := Q′}
where →
→β follows from the induction hypothesis and compatibility of →
→β.
Case P = P1 P2, then
(P1 P2){x := Q}
=
(P1{x := Q}) (P2{x := Q})
→
→β
(P1{x := Q′}) (P2{x := Q})
→
→β
(P1{x := Q′}) (P2{x := Q′})
=
(P1 P2){x := Q′}
where both →
→β-steps follow from the induction hypothesis and compatibility
of →
→β.
⊓⊔
Now the proposition in the exercise (1.72) can be proved.
14.0.10. Proposition (Weak Church-Rosser). For all M1, M2, M3 ∈Λ, if
M1
→β
M2 and M1
→β
M3, then there exists an M4 ∈Λ such that
M2 →
→β M4 and M3 →
→β M4.
Proof. By induction on the derivation of M1 →β M2.
Case M1 = (λx.P) Q and M2 = P{x := Q}. Then either (1) M3 =
(λx.P ′) Q for P ′ such that P →β P ′, (2) M3 = (λx.P) Q′ for Q′ such that
Q →β
Q′, or M3 = M2. In the last case we are done. In situation (1)
we have M3 = (λx.P ′) Q →β
P ′{x := Q} and M2 = P{x := Q} →β
P ′{x := Q} by Lemma 14.0.8, i.e., M4 = P ′{x := Q}. Situation (2) is
similar using Lemma 14.0.9.
(1)
(2)
(λx.P) Q
——
yyyyyyyy
””
E
E
E
E
E
E
E
E
P{x := Q}
(λx.P ′) Q
P ′{x := Q}
=
P ′{x := Q}
(λx.P) Q
——
yyyyyyyy
””
E
E
E
E
E
E
E
E
P{x := Q}
(λx.P) Q′
P{x := Q′}
=
P{x := Q′}

230
Chapter 14. Solutions and hints to selected exercises
Case M1 = λx.P and M2 = λx.P ′ because P
→β P ′. Then M3 must
be λx.Q for Q ∈Λ such that P →β Q. By the induction hypothesis there
is a term M′ such that P ′ →
→β M′ and Q →
→β M′.
Then since →
→β is
compatible we have M2 = λx.P ′ →
→β λx.M′ and M3 = λx.Q →
→β λx.M′,
and M4 = λx.M′ is the sought term.
λx.P
øø
9999999
λx.P ′
øø
øø
9999999
λx.Q
λx.M′
Case M1 = P Q and M2 = P ′ Q because P →β P ′. Then
(1) M3 = P ′′ Q for P ′′ ∈Λ such that P →β P ′′, or
(2) M3 = P Q′ for Q′ ∈Λ such that Q →β Q′.
In the former case by the induction hypothesis we obtain an M′ such that
P ′ →
→β M′ and P ′′ →
→β M′ and thus (again by compatibility of →
→β) that
M2 = P ′ Q →
→β M′ Q and M3 = P ′′ Q →
→β M′ Q, i.e., M4 = M′ Q. In the
latter case we have that M2 = P ′ Q →β P ′ Q′ and M3 = P Q′ →β P ′ Q′
(also by compatibility) and consequently M4 = P Q′ as desired.
(1)
(2)
P Q
˘
ŒŒ
¡¡¡¡¡¡¡
P ′ Q
ÆÆ
ÆÆ
;;;;;;;
P ′′ Q
˘˘
M′ Q
P Q
˘
ÆÆ
:::::::
P ′ Q
P Q′
P ′ Q′
=
P ′ Q′
This completes the proof.
⊓⊔
The proof does not extend directly to the full Church-Rosser property.
Let us say that a relation →on a set S is weakly conﬂuent if, whenever
s1 →s2 and s1 →s3, there is an s4 such that s2 →. . . →s4 and s3 →. . . →
s4. Let us call →conﬂuent if, whenever s1 →. . . →s2 and s1 →. . . →s3,
there is an s4 such that s2 →. . . →s4 and s3 →. . . →s4.
There are relations that are weakly conﬂuent and not conﬂuent. The
simplest example is when we have a four-element set S = {s1, s2, s3, s4}
s1 ←s2, and s2 →s3, s2 ←s3, and s3 →s4:
s1
s2
oo
//s3
oo
//s4
A relation →on a set S is strongly normalizing if there are no inﬁnite
reduction sequences
s1 →s2 →. . .

231
of (not necessarily distinct) elements from S. Can you ﬁnd a weakly conﬂu-
ent, strongly normalizing relation that is not conﬂuent?
A diggression
How many details should a proof contain? Everybody should do a proof in
the style of Lemma 14.0.6 (induction on M ∈Λ) and a proof in the style of
Lemma 14.0.7 (induction on the deﬁnition of P →
→β P ′) in every detail at
least once in their life.
However, having tried this, one can see that many details are completely
mechanical. In choosing a level of detail in a proof, one should leave out de-
tails that can be reconstructed mechanically with little eﬀort by the reader.
In contrast, steps that require good ideas, even small good ideas, should
usually not be left out.
Thus, a complete proof of Lemma 14.0.6 would be “Induction on M” and
a complete proof of Lemma 14.0.7 would read “Induction on the deﬁnition
of P →
→β P ′.” A complete proof of Lemma 14.0.8 might be “Induction on
the deﬁnition of P →β P ′,” but since something interesting happens in the
case where P = (λy.P1) Q1 →β P1{y := Q1} = P ′, one can also present
that case and refer to the substitution lemma.
If several cases in a proof are similar, but non-trivial, one can do the
ﬁrst example in detail and omit the remaining ones.
Exercise 1.7.17
14.0.11. Proposition (Klop). Let λx1x2 . . . xn.M be an abbreviation for the
λ-term λx1.λx2. . . . λxn.M. Let
?
=
λabcdefghijklmnopqstuvwxyzr.r (thisisafixedpointcombinator)
$
=
??????????????????????????
Then $ is a ﬁxed point combinator, i.e., for any F ∈Λ: $ F =β F ($ F).
Proof. We have:
$ F
=
?????????????????????????? F
=
(λabcdefghijklmnopqstuvwxyzr.
r (thisisafixedpointcombinator))
????????????????????????? F
=β
F (??????????????????????????F)
=
F ($ F)
as required.
⊓⊔

232
Chapter 14. Solutions and hints to selected exercises
Exercise 2.7.2
We only show the closure under weakening. The proof is by induction with
respect to the size of the proof of Γ ⊢ϕ. We proceed by cases depending
on the last rule used in this proof. Recall that the notation Γ, ψ stands for
Γ ∪{ψ}, whether or not ψ ∈Γ. That’s why e.g., Case 3 below works.
Case 1: The proof consists only of a single application of an axiom scheme,
that is ϕ is an element of Γ. Then Γ, ψ ⊢ϕ is also an axiom.
Case 2: The proof ends with an application of (∧I). That is, ϕ has the
form ϕ1 ∧ϕ2 and we have proven Γ ⊢ϕ1 and Γ ⊢ϕ2.
The proofs of
these judgements are contained in the proof of Γ ⊢ϕ, so we can apply the
induction hypothesis to obtain Γ, ψ ⊢ϕ1 and Γ, ψ ⊢ϕ2. By an application
of (∧I) we can derive Γ, ψ ⊢ϕ1 ∧ϕ2.
Case 3: The proof ends with an application of (∨E). That is, we have
Γ ⊢θ1 ∨θ2, for some formulas θ1, θ2, such that Γ, θ1 ⊢ϕ and Γ, θ2 ⊢ϕ.
These proofs are all shorter, thus we can apply the induction hypothesis to
obtain Γ, ψ ⊢θ1 ∨θ2 and Γ, θ1, ψ ⊢ϕ and Γ, θ2, ψ ⊢ϕ. It remains to use
rule (∨E).
Other cases are similar.
Exercise 2.7.3
1) Begin with the axiom ⊥⊢⊥. Apply (⊥E), to derive ⊥⊢ϕ and (→I)
to derive ⊢⊥→ϕ.
3) Begin with p, p →⊥⊢p and p, p →⊥⊢p →⊥. Apply (→E) to get
p, p →⊥⊢⊥, then twice (→I) to get ⊢p →(p →⊥) →⊥.
5) First show that ¬¬¬p, ¬p, p ⊢⊥(unfold the ¬’s). Thus, ¬¬¬p, p ⊢
¬p →⊥, i.e., ¬¬¬p, p ⊢¬¬p. But ¬¬¬p = ¬¬p →⊥and one can
derive ¬¬¬p, p ⊢⊥. It remains to use (→I).
7) First show that p →q, q →⊥, p ⊢⊥. Then apply (→I) three times.
9) What we need is ¬p∨¬q, p∧q ⊢⊥. With help of (∧E), derive separately
¬p ∨¬q, ¬p, p ∧q ⊢⊥and ¬p ∨¬q, ¬q, p ∧q ⊢⊥. Apply (∨E) to these
two judgements.
11) Remember that ↔abbreviates a conjunction, so (∧I) will be the last
rule. One part of this proof uses (∧E), the other one uses (∧I).
13) First derive (p∨¬p) →⊥, p ⊢⊥, using rules (∨E) and (→E). By (→I)
obtain (p ∨¬p) →⊥⊢¬p. Then use (∨E) and (→E) again to derive
(p ∨¬p) →⊥⊢⊥.

233
Exercise 2.7.4
• First we show that a ∪a = a, that is a ≤a holds for all a. This is
because a = 0∪a = (−a∩a)∪a = (−a∪a)∩(a∪a) = 1∩(a∪a) = a∪a.
• The relation ≤is transitive because a ∪b = b and b ∪c = c implies
that c = b ∪c = (a ∪b) ∪c = a ∪(b ∪c) = a ∪c.
• The antisymmetry (a ≤b and b ≤a implies a = b) follows immediately
from the deﬁnition. To see that a ∪b is the lub of a and b, assume
that a ≤c and b ≤c. Then (a ∪b) ∪c = a ∪(b ∪c) = a ∪c = c, i.e.,
a ∪b ≤c.
• The condition a ∩b ≤a (that is (a ∩b) ∪a = a) is shown as follows:
(a ∩b) ∪a = (a ∩b) ∪(a ∩1) = (a ∩b) ∪(a ∩(b ∪−b)) = (a ∩b) ∪(a ∩
b) ∪(a ∩−b) = (a ∩b) ∪(a ∩−b) = a ∩(b ∪−b) = a ∩1 = a.
• If a ∩b = a then b = (a ∩b) ∪b = a ∪b, i.e., a ≤b. On the other hand,
if a ≤b then (a ∩b) ∪a = (a ∪a) ∩(b ∪a) = a ∩b, and thus a ≤a ∩b.
We conclude a = a ∩b, by the previous item and antisymmetry.
Exercise 2.7.5
• The proof that the relation ≤is a partial order, and that ∪is the lub,
is similar as for Exercise 2.7.4.
• Next we show that −a∩a = 0. We have −a ≤−a, i.e., a ⇒0 ≤a ⇒0.
Thus, a ∩(a ⇒0) ≤0, and since 0 is obviously the least element, we
have a ∩−a = a ∩(a ⇒0) = 0.
• Now we prove (a ∪b) ∩a = a, in a similar way as we proved the dual
law (a ∩b) ∪a = a for a Boolean algebra. (Note that now we use
b ∩−b = 0 instead of b ∪−b = 1.)
• We derive (a ∩b) ∪a = a from the above, because (a ∩b) ∪a =
(a∪a)∩(b∪a) = a∩(b∪a). Note that we obtain here the idempotency
of ∩, since a ∩a = a ∩(a ∪a) = a ∩a.
• Then we proceed in a similar way as for Boolean algebra.
Exercise 2.7.6
The only property which is not immediate is the equivalence between A ∩
C ⊆B and C ⊆Int(−A ∪B). First note that the condition A ∩C ⊆B
is equivalent to C ⊆−A ∪B, for all A, B and C.
For the left-to-right
implication observe that X ⊆Y implies X ⊆Int(Y ), whenever X is an
open set. The converse follows from Int(−A ∪B) ⊆−A ∪B.

234
Chapter 14. Solutions and hints to selected exercises
Exercise 2.7.8 (1)⇒(2)
Let Γ = {ϑ1, . . . , ϑn}, and let v be a valuation in a Heyting algebra H.
We write v(Γ) to denote v(ϑ1) ∩· · · ∩v(ϑn). By induction with respect to
derivations we prove the following statement: “If Γ ⊢ϕ then v(Γ) ≤v(ϕ),
for all valuations in arbitrary Heyting algebras”. The hypothesis follows
from the special case when v(Γ) = 1.
For instance, consider the case of (→I). To show v(Γ) ≤v(ϕ →ψ)
recall that v(ϕ →ψ) = v(ϕ) ⇒v(ψ) and use the induction hypothesis
v(Γ) ∩v(ϕ) ≤v(ψ). For the case of (∨E) use the distributivity law.
Exercise 2.7.9
First we consider counterexamples with open sets. In what follows we use
the convention that v(p) = P, v(q) = Q, etc, and we write ∼A for Int(−A).
4) Take P to be the whole R2 without one point. Then ∼P is empty
and ∼∼P is the full set R2. Thus ∼∼P ⇒P ̸= 1.
6) Let P be an open disk, and Q be R2 without one straight line crossing
the middle of the disk. Then P ⇒Q is the whole space without the
intersection of the disk and the line. The value of the right-hand side
is the whole space.
8) Take the interiors of two complementary halves of R2.
10) Take Q and R to be the half of R2 where x < 0, and take P =
R2 −{(0, 0)}. Then (P ⇒Q) ∩(Q ⇒P) is equal to Q and R. Thus
the value of (p ↔q) ↔r is R2 ̸⊆P.
12) Take both P and Q to be the same open disk.
Here are counterexamples in Kripke models.
4) A two-element model with c < c′, where c ⊮p and c′ ⊩p.
6) A two-element model with c < c′, where c, c′ ⊩p and c′ ⊩q and c ⊮q.
8) A three-element model with c < c′, c′′, where c′ ⊩p, c′′ ⊩q and noth-
ing more happens.
10) A three-element model with c < c′ < c′′, where c′ ⊩p, c′′ ⊩p, q, r and
nothing more happens.
12) A two-element model with c < c′, where c′ ⊩p, q and c forces nothing.

235
Exercise 2.7.10
Use n lines beginning in (0, 0) to divide the space R2 into n disjoint angles
and take their interiors as values of pi. The point (0, 0) does not belong
to the interpretation of this formula. Or take a Kripke model with all sets
{c ≥c0 : c ⊩pi} diﬀerent. Then c0 does not force our formula.
Exercise 2.7.11
Let F be maximal and let a ∪b ∈F, but a, b ̸∈F. We show that either
F ∪{a} or F ∪{b} can be extended to a proper ﬁlter. First assume that
there are f1, f2 ∈F such that f1 ∩a = f2 ∩b = 0. Then (f1 ∩f2) ∩(a ∪b) =
(f1 ∩f2 ∩a) ∪(f1 ∩f2 ∩b) = 0 ∪0 = 0, a contradiction. Thus either such
f1 or such f2 does not exist. Assume for instance that f ∩a ̸= 0, for all
f ∈F. Then the set Fa = {x : x ≥f ∩a for some f ∈F} is a proper ﬁlter
extending F.
Let F be a prime ﬁlter in a Boolean algebra, and assume that F ⊂F ′,
with a ∈F ′ −F. Since a ∪−a = 1 ∈F and F is prime, we have −a ∈F
and 0 = a ∩−a ∈F ′, a contradiction.
Exercise 2.7.12
The argument is similar to the ﬁrst part of Exercise 2.7.11. Assume that G
is our maximal element, and that c ∪d ∈G, but c, d ̸∈G. The assumption
of g1, g2 ∈G with g1 ∩a ≤b and g2 ∩a ≤c leads to contradiction, and thus
either G∪{b} or G∪{c} can be extended to a proper ﬁlter, not containing a.
Exercise 2.7.13 (⇒)
We need to prove a slightly more general statement, namely:
Let Γ ⊢ϕ. Then for every Kripke model C and every state c
of C, the condition c ⊩Γ implies c ⊩ϕ.
(An alternative of this generalization is to remember that for each state c,
the set of all c′ with c ≤c′ makes a Kripke model.) As an example consider
the induction step for rule (∨E). Assume that we have derived Γ ⊢ϕ from
the three assertions: Γ, ψ ⊢ϕ and Γ, ϑ ⊢ϕ and Γ ⊢ψ ∨ϑ. Let c ⊩Γ. By
the induction hypothesis we have c ⊩ψ ∨ϑ, and thus either c ⊩ψ or c ⊩ϑ.
Assume the ﬁrst case and we have c ⊩Γ, ψ. By induction hypothesis we get
c ⊩ϕ.
Exercise 2.7.14
The induction fails in the case of disjunction.

236
Chapter 14. Solutions and hints to selected exercises
Exercise 2.7.17
First do the previous two exercises. Now assume that ϕ is a classical tautol-
ogy (the other direction is obvious), but ¬¬ϕ is not valid intuitionistically.
This means that there is a Kripke model with a state c, such that c ⊩¬ϕ.
Without loss of generality, we can assume that c determines all propositional
variables in ϕ. Indeed, suppose that c does not determine a variable p. Then
there is a c′ ≥c with c′ ⊩p, and we can take c′ instead. From Exercise 2.7.16
we obtain that c ⊩ϕ, a contradiction.
Exercise 4.6.4
14.0.12. Lemma (Newman’s Lemma). Let →be a binary relation satisfying
SN. If →satisﬁes WCR, then →satisﬁes CR.
Proof. We give the proof in the case where →satisﬁes FB, i.e., for all
M ∈L the set {N | M →N} is ﬁnite. [This was the case the hint aimed
at. See another proof at the end of the note.] Since →satisﬁes FB and SN,
there is for any M an m so that any reduction sequence from M has length
at most m.1
Assume →is SN and WCR. Given M1, M2, M3 ∈L where M1 →
→M2 and
M1 →
→M3, we must ﬁnd M4 ∈L such that
M1
˝˝
˝˝––––––––
!!!!
C
C
C
C
C
C
C
C
M2
!!!!
M3
˝˝
˝˝
M4
Since →is strongly normalizing, for every M ∈L there will be a longest
reduction starting in M. Let |M| ∈N denote the length of this reduction.
Assume M1, M2, M3 ∈L such that M1 →
→M2 and M1 →
→M3. We proceed
by induction over |M1|:
Case |M1| = 0: Since the longest reduction has length 0, it must be the
case that M1 = M2 and M1 = M3, and thus M4 = M1 is the desired term.
Case |M1| > 0: Assume for all N1 ∈L such that |N1| < |M1|, if N1 →
→N2
and N2 →
→N3 then there exists N4 such that N2 →
→N4 and N3 →
→N4.
1How does this follow? Recall K¨onig’s Lemma which states that if a tree—which is
ﬁnitely branching, i.e., each node has ﬁnitely many children—is inﬁnite, then it must have
an inﬁnite branch. Now, given M, consider the tree where the root is labeled with M, and
for any node labeled with K, if K →N then the node labeled K has a child labeled N.
Since →satisﬁes SN, there is no inﬁnite branch. Also, there cannot be arbitrarily long
ﬁnite sequences, because then the tree would be inﬁnite, and then by K¨onig’s Lemma
there would be an inﬁnite branch, contradicting SN.

237
If M1 →
→M2 has length 0 the desired term is M3:
M1
––––––––
––––––––
!!!!
C
C
C
C
C
C
C
C
M2
!!!!
M3
––––––––
––––––––
M3
Similarly if M1 →
→M3 has length 0.
Thus assume that M1 →N2 →
→M2 and M1 →N3 →
→M3,
M1
˝˝––––––––
!!
C
C
C
C
C
C
C
C
N2
N3
M2
M3
Since →is WCR from M1 →N2 and M1 →N3 we get a term N ∈L such
that N2 →
→N and N3 →
→N
M1
˝˝––––––––
!!
C
C
C
C
C
C
C
C
N2
!!!!
N3
˝˝
˝˝
M2
N
M3
Since M1 →N2 →
→N, |N2| < |M1|. Applying the induction hypothesis we
thus get a term M′
4 ∈L such that M2 →
→M′
4 and N →
→M′
4
M1
˝˝––––––––
!!
C
C
C
C
C
C
C
C
N2
!!!!
C
C
C
C
C
C
C
C
N3
˝˝
˝˝––––––––
M2
!!!!
N
M3
M′
4

238
Chapter 14. Solutions and hints to selected exercises
Then N3 →
→M′
4 and N3 →
→M3 and hence by the induction hypothesis we get
a term M4 ∈L such that M′
4 →
→M4 and M3 →
→M4
M1
˝˝––––––––
!!
C
C
C
C
C
C
C
C
N2
!!!!
C
C
C
C
C
C
C
C
N3
˝˝
˝˝––––––––
M2
!!!!
C
C
C
C
C
C
C
C
N
M3
M′
4
M4
i.e., M2 →
→M4 and M3 →
→M4. This concludes the proof.
⊓⊔
14.0.13. Proposition. There is a binary relation satisfying WN and WCR,
but not CR.
Proof. Consider L = {M, MNF, N, NNF} and the relation →given by
M
%%
N
ee
MNF
NNF
The relation is not Church-Rosser: for M ∈L we have two reductions
M →MNF and M →N →NNF, but there is no term in L such that MNF
and NNF both reduce to this term (because both are in “normal form”).
The relation is Weak Church-Rosser: if M →MNF and M →N, then
MNF is a common reduct. Similarly for N.
Finally, we have that →is weakly normalizing since any reduction can
always end in either MNF or NNF. (It is obviously not strongly normalizing
because we have an inﬁnite reduction M →N →M →· · · .)
⊓⊔
14.0.14. Corollary. Let M1 ∈Λ be typable in λ →´a la Curry and assume
that M1 →
→β M2 and M1 →
→β M3.
Then there is an M4 ∈Λ such that
M2 →
→β M4 and M3 →
→β M4.
Proof. Let L = {M ∈Λ|∃σ. ⊢M : σ} and consider →=→β. By The-
orem 4.10 →satisﬁes SN and by Exercise 1.72 →satisﬁes WCR, thus by
Newman’s Lemma →satisﬁes CR, i.e., →β is Church-Rosser on L—the set
of Curry-typable terms.
⊓⊔

239
How does one prove Newman’s Lemma in case →does not necessarily
satisfy FB? As follows.
Proof. Let →be a relation on L satisfying SN and WCR. As usual, a
normal form is an M ∈L such that for all N ∈L, M ̸→N.
Since →satisﬁes SN, any M ∈L reduces to a normal form. Call M
ambiguous if M reduces to two distinct normal forms. It is easy to see that
→satisﬁes CR if there are no ambiguous terms.
Now, for any ambiguous M there is another ambiguous M′ such that
M →M′. Indeed, suppose M →
→N1 and M →
→N2. Both of these reductions
must make at least one step since N1 and N2 are distinct, so the reductions
have form M →M1 →
→N1 and M →M2 →
→N2. If M1 = M2 we can choose
M′ = M1 = M2. If M1 ̸= M2 we now by WCR that for some N3, M1 →
→N3
and M2 →N3. We can assume that N3 is a normal form. Since N1 and N2
are distinct, N3 is diﬀerent from N1 or N2 so we can choose M′ = M1 or
M′ = M2.
Thus, M has an inﬁnite reduction sequence, contradicting SN. Hence,
there are no ambiguous terms.
⊓⊔
Exercise 5.6.1
One possibility is S(S(KS)K)I.
Exercise 5.6.9
It should be easy to see that all types that can be assigned to K, I and S◦
must be respectively of the form:
• τ →σ →τ;
• τ →τ;
• (τ →τ) →(τ →τ →τ) →(τ →τ) →τ →τ.
We can take all instances of the above formulas as our Hilbert style axioms.
But we can easily simplify the the system, replacing the last axiom by:
• (τ →τ →τ) →(τ →τ) →τ →τ.
A Hilbert style proof will now correspond to a combinatory term built from
the combinators of Exercise 5.6.8, and without loss of generality, we can
only deal with terms in normal forms.
Suppose we have a proof of (p →p →q) →p →q, where p and q are
propositional (type) variables. Let M be the corresponding combinatory
term in the language of Exercise 5.6.8, and assume that M is in a normal
form.

240
Chapter 14. Solutions and hints to selected exercises
Clearly, M is neither Kσ,τ, nor Sτ,τ,τ, nor Iτ.
If M = Kσ,τN, then
N proves p →q, which is not a valid tautology. Also M = Sτ,τ,τPQ or
M = Sτ,τ,τN is impossible, because types of these expressions do not match
(p →p →q) →p →q.
Exercise 6.8.1
a) To reduce ? ⊢M : ? to ⊢M : ?, observe that a term M with free
variables x1, . . . , xn is typable if and only if λx1 . . . xn.M is typable.
b) In order to ﬁnd out if a closed term M is typable, ask if x : α ⊢KxM : α.
Exercise 6.8.2
Of course tα = xα, and then we proceed by induction as follows: tσ→τ =
λx.Ktτ(λzy.z(yx)(ytσ)).
Exercise 6.8.3 (Author’s hint)
Adopt the technique of Exercise 6.8.2 to write lambda-terms t[x:τ] such that
x ∈FV (t[x:τ]) and t[x:τ] is typable in a context ∆if and only if ∆(x) = S(τ),
for some S. (Use a fresh variable xα, for every type variable α occurring in τ.)
Then reduce the problem of Γ ⊢M : ? with Γ = {(x1 : τ1), . . . , (xn : τn)} to
the problem ? ⊢M′ : ?, where M′ = λz.zMt[x1:τ1] . . . t[xn:τn].
Exercise 6.8.3 (Solution by Henning Makholm)
(This is a fragment of Henning’s solution containing the reduction of prob-
lem (3) to problem (4).)
Definition. Let Γ0 denote a type environment of the form discussed in
exercise 6.29. That is, one that maps all variables to distinct type variables.
Definitions. I consider the following problems:
(3) ? ⊢M : τ;
(4) ? ⊢M : ?;
(5 1
2) Γ0 ⊢M : ?.
In each of the following reductions, x1 up to xn will be understood to be the
free variables of the given M.
Reduction from (3) to (5 1
2). To answer ? ⊢M : τ, ask
Γ0 ⊢λx1· · · xnyz.y(zM)(ztτ) : ?.

241
Reduction from (5 1
2)to (4). This is the harder part. Without the Γ0
it is not trivial to design a subterm that is forced to have a primitive type
(one that cannot be destructed).
Solution with product types. One simple solution can be obtained if
we assume that we have product types at our disposal, together with pair
and projection operators. To answer Γ0 ⊢M : ?, ask:
? ⊢K ((λx1· · · xn.M) ⟨x1, x1⟩⟨x2, x2⟩. . . ⟨xn, xn⟩)
((λx1· · · xn.M)(λy1.y1)(λy1y2.y1) . . . (λy1· · · yn.y1)) : ?
Clearly, if M has a typing in Γ0 then this complicated term is also typable.
For the other direction, I exploit the existence of unique principal types. If
the long term is typable, then λx1· · · xn.M will have a principal type
τ1 →· · · →τn →σ.
Since that principal type have instances where the τi’s are arrow types as
well as where they are pair types, we conclude that the τi’s must be type
variables. Furthermore, because λy1· · · yi.y1 and λy1· · · yj.y1 cannot have
equal type for i ̸= j, the τi’s must be diﬀerent type variables. Thus, modulo
renaming of type variables we have Γ0 ⊢M : σ.
Implicational solution.
My solution is based on an “encoding” • of
types and terms2:
α
=
α;
σ →τ
=
(τ →τ) →(σ →τ);
x
=
x;
λx.M
=
λex.e(e(M));
MN
=
(λe.e(MeN))(λx.x).
Lemma.
• If Γ ⊢M : τ then Γ ⊢M : τ.
• If ∆⊢M : σ then Γ ⊢M : τ, for some Γ and τ with Γ = ∆and τ = σ.
The proof of the ﬁrst part is easy. The other part follows by induction with
respect to M.
⊓⊔
2Never mind that τ is not LOGSPACE-computable because τ can be exponentially
bigger than τ. It is not used in the actual reduction, just in the argument for its correct-
ness. The important thing is that M is LOGSPACE-computable by having a treeless,
linear deﬁnition.

242
Chapter 14. Solutions and hints to selected exercises
Now, to answer Γ0 ⊢M : ?, ask
? ⊢(λx1· · · xn.M)(λzy1.z)(λxy1y2.z) . . . (λzy1· · · yn.z) : ?.
It is easy to see that this holds whenever M is typable in Γ0. Conversely,
assume that the massaged and wrapped M is typable. We know then that
M is typable and thus so is M. Let (Γ, τ) be the principal pair of M.
What remains to be shown is that Γ is Γ0. We know that Γ(xi) = Γ(xi)
has an instance which is a type of λzy1· · · yi.z. But by inspection of the
deﬁnition of • we see that this can only be the case when Γ(xi) is a type
variable. (This is because all compound types are translated into types with
“symmetric” ﬁrst arguments.) Furthermore the type variables in Γ have to
be diﬀerent, because λzy1· · · yi.z and λzy1· · · yj.z do not have a common
type for i ̸= j. Thus Γ is a Γ0 which completes the reduction.
⊓⊔
Exercise 6.8.6
Take the equations “α1 = α2 →α2”, “α2 = α3 →α3”,. . . , “αn−1 = αn →αn”.
Exercise 6.8.7
Use non-uniﬁable terms as diﬀerent ﬂags.
Represent n-ary operators as
combinations of arrows, using ﬂags to identify operators.
Exercise 6.8.8
Label all subterms occurring in the equations and keep labels unchanged in τ
in steps (a) and (d). A variable x is called deﬁned iﬀthere is an equation
of the form “x = t” or “t = x”. The occurrence of x as a left-hand or a
right-hand side of such an equation is called main. Note that “x = y” has
two main occurrences.
Proceed by induction w.r.t. the following parameters: 1) number of la-
bels; 2) number of equations; 3) number of main occurrrences of deﬁned
variables; 4) number of all occurrrences of deﬁned variables. Each applica-
tion of rule (c) decreases (1) and does not increase the other parameters.
Rule (e) decreases (2) without aﬀecting (1), and rule (a) decreases (3) with-
out increasing (1) or (2). Rule (d), used with caution (i.e., only when x
occurs in “r = s” and when t is not a deﬁned variable), will not increase any
of the parameters (1)–(3) and will decrease (4). Thus, after a ﬁnite number
of applications of rules (a), (c), (d) and (e) we obtain a system of equations,
that is not normal only for the following reasons: there may be some equa-
tions of the form “t = x” and there may be some equations between deﬁned
variables. Use rules (b) and (d) for a clean-up.

243
Exercise 6.8.10
Use acyclic graphs instead of trees to represent algebraic terms. Proceed by
identifying nodes of these graphs as long as either a contradiction is found
(a loop or an attempt to place two diﬀerent operation labels at a node) or
no more nodes need to be identiﬁed.
Exercise 6.8.11
Just add one more equation.
Exercise 6.8.12
Take the term (λv.Kv(λxα1 . . . xαn.t[v:τ]))N, where N is any inhabitant of τ,
and t[v:τ] is as in Exercise 6.8.3.
Exercise 6.8.14
Let a pair (Γ, τ) be called semi-principal iﬀit has the properties mentioned in
Exercise 6.8.13. We show that if (Γ, τ) is semi-principal then there is at most
one Church-style BCK-term M in long normal form such that Γ ⊢M : τ.
The proof is by induction w.r.t. the total number of arrows in (Γ, τ). Assume
ﬁrst that τ = τ1 →τ2. Then M cannot be of the form xM1 . . . Mn, as it
would not be fully-applied (x has too few arguments). Thus, M = λy.N,
with fully applied N, and we apply the induction hypothesis to the pair
(Γ ∪{y : τ1}; τ2).
The remaining case is when τ is a type variable α. There is at most one
variable x declared in Γ to be of type σ1 →· · · →σp →α, since α occurs at
most twice. Thus M = xN1...Np. Apply the induction hypothesis to pairs
(Γ′, σj), where Γ′ is Γ without the declaration (x : σ1 →· · · →σp →α).
Exercise 6.8.18
Modify the algorithm of Lemma 6.6.1 so that it searches for all inhabitants
rather than for only one. This process may loop by asking a question of the
form Γ ⊢? : α, which has already been asked. We can eﬀectively identify all
loop-free solutions and all loops. If we have a loop caused by a question that
has a loop-free solution, then the answer is: “inﬁnite”. (Note the similarity
of this argument to the pumping lemma for CF-languages.)
Exercise 6.8.20
Assume all τi’s are inhabited. We prove indirectly that then ϕ is not inhab-
ited. Assume ⊢Ni : τi and ⊢M : ϕ. Then ⊢M N1 · · · Nn : α, which is a
contradiction because type variables are not inhabited.

244
Chapter 14. Solutions and hints to selected exercises
The proof that ϕ is inhabited if there is a τi that is not inhabited is by
induction on the size of ϕ. Since α is the only type variable in ϕ, type τi has
the form σ1 →· · · →σm →α. If any of the σj’s were not inhabited then
by the induction hypothesis τi would be inhabited, but we know it is not.
Thus for some Nj’s we have ⊢Nj : σj. Then ⊢λx1· · · xn.xiN1 . . . Nm : ϕ.
Exercise 6.8.21
The formula ϕ must have the form ψ1 →· · · →ψn →p. Classically, this
is equivalent to (ψ1 ∧· · · ∧ψn) →p. For this to be a tautology, some ψi
must be false in a valuation that sets p to be false. Hence that ψi is not
classically valid, so it cannot be intuitionistically valid either. That means
that ψi is not inhabited when viewed as a type. Then ϕ is inhabited by
Exercise 6.8.20, and ϕ is thus intuitionistically valid.
Exercise 6.8.22
First reduce the general case to the case when τ is a type variable α. To prove
that τ1, . . . , τn ⊢α, consider a substitution S such that S(α) = τ1 →· · · →
τn →α, and S(β) = β, for β ̸= α. Show that all formulas S(τ1), . . . , S(τn)
are valid, and conclude what you need.
Exercise 7.7.6
Consider the term M =< π1(FK), π2(FK) >, where F = λx. < x, λy.x >.
Then F can be assigned all instances of the type α →(α ∧(β →α)), and
since K has both the types γ →γ →γ and γ →(γ →γ) →γ, we can
derive that M : (γ →γ →γ) ∧(β →γ →(γ →γ) →γ). But M →η FK,
and FK cannot be assigned this type.
Exercise 7.7.8
The example term in the above solution is an untyped η-redex that is not
an erasure of a typed η-redex. The Church-style version of that term uses
two diﬀerent K’s.
Exercise 7.7.9
The problem is that the conclusion of the elimination rule is not neces-
sarily identical to a premise of any of the introduction rules. Thus, in an
elimination-introduction pair, one eliminates and introduces possibly diﬀer-
ent things.

245
Exercise 7.7.10
There is no canonical object of type ⊥, so one can argue that no eta rule
makes sense.
By analogy to the eta rule for ∨one may only postulate
that an “artiﬃcial” use of ⊥-introduction should be avoided. This leads to
something like ε⊥(M) →M, for M : ⊥.
Exercise 8.9.1 (Hint)
For the right-to-left direction, proceed as follows:
1. Show that ⊢(ϕ →ψ) →(¬ϕ →ψ) →ψ.
2. Let α1, . . . , αn be the propositional variables of ϕ. Let ρ be a Boolean
valuation. Now let
α′
i =
½ αi
if ρ(α) = 1
¬αi
if ρ(α) = 0
Also, let
ϕ′ =
½ ϕ
if ρ(ϕ) = 1
¬ϕ
if ρ(ϕ) = 0
where ρ is lifted to formulas according to the usual truth-table seman-
tics. Show that {α′
1, . . . , α′
n} ⊢ϕ′.
3. Prove the right-to-left direction.
Exercise 9.5.2
The construction of ϕ′ is by induction w.r.t. the length of the quantiﬁer
preﬁx of ϕ. If ϕ is quantiﬁer-free then ϕ′ = ϕ. If ϕ = ∀x ψ(x) then ϕ′ =
ψ′(x). If ϕ = ∃x ψ(x) then ϕ′ = ψ′(c), where c is a constant such that
⊢ψ(c). (Here we apply the induction hypothesis to ψ(c).)
Exercise 9.5.3
For a given formula there is a ﬁnite number of possible replacements of
existentially quantiﬁed variables by constants.
To verify provability of a
prenex formula one checks provability of these replacements (provability of
open formulas is decidable, like for the propositional case).
Exercise 9.5.4 (Intuitionistic case)
The argument is of course as follows: if every intuitionistic ﬁrst-order for-
mula was equivalent to a prenex formula, then intuitionistic ﬁrst-order logic
would be decidable by the previous exercise. Note however that to apply
this argument one needs to know that the translation to prenex normal form

246
Chapter 14. Solutions and hints to selected exercises
must be eﬀective, and we can assume only the existence of a prenex formula
equivalent to any given ϕ.
But one can eﬀectively list all proofs until a
proof of ϕ ↔ψ, for a prenex formula ψ is found, and this gives an eﬀective
translation.
Exercise 9.5.5
Consider the formula ∃x(P(0)∨P(1) →P(x)), where P is a unary predicate
symbol and 0 and 1 are constants. It should be clear that no formula of the
form P(0) ∨P(1) →P(t) is classically valid. The proof of Corollary 9.3.2
breaks down in the “obvious” and omitted part, and the confusion is cre-
ated by the principle of contraction (two occurrences of the same formula
in a sequent are treated as a single occurrence). In a sequent calculus with
explicit contraction rules, the last rule of our proof would be the right con-
traction rule. In our version of sequent-calculus, the contraction is implicit,
and the last rule must indeed be (∃R). But the premise of this rule may be
for instance of the form:
⊢∃x(P(0) ∨P(1) →P(x)), P(0) ∨P(1) →P(1),
because a classical sequent may have two formulas at the right-hand side.
The second last rule is also (∃R) with premise
⊢P(0) ∨P(1) →P(0), P(0) ∨P(1) →P(1),
a classical proof of which should be easy.
Exercise 9.5.7 (Hint)
The proof is similar to that of Proposition 2.3.4. Choose c ∈X. We trans-
form a model A where relations are valued over P(X) into an ordinary
model ¯
A, by deﬁning
(a1, . . . , an) ∈r
¯
A
iﬀ
c ∈rA(a1, . . . , an).
Both our models have a common domain A. Let v be a valuation in A. We
extend v to terms and formulas in the usual way (the values of formulas
range over P(X)). One proves by induction the following claim:
c ∈v(ϕ)
iﬀ
¯
A, v |= ϕ,
for all ϕ. (Note that the right-hand side makes sense, because v can also be
regarded as ordinary two-valued valuation in ¯
A.) Note that in the right-to-
left direction in the case of ∀, one uses the fact that lower bounds in P(X)
are actually intersections (if c belongs to all sets in a family then it belongs
to their glb).3
Now if A, v ̸|= ϕ then there is c ̸∈v(ϕ), and thus ¯
A, v ̸|= ϕ as well.
3One has to use ultraﬁlters for the case of arbitrary Boolean algebras.

247
Exercise 9.5.8
Algebraic counterexamples, after [88]
The domain of individuals A is the set of all positive integers. The Heyting
algebra H is the set of all open sets of R2. We take ϕ and ψ as atomic
formulas p(x) and q(y), and we abbreviate p(x)A(n) by P(n) and q(y)A(m)
by Q (the latter will not depend on m). The symbol wi denotes the i-th
point with rational coeﬃcients, according to some ﬁxed order.
2) Take P(n) = R2 −{wn}, a full space without one rational point. The
intersection of all sets P(n) is R2 with all rational points deleted. This
set has an empty interior, and thus the value of the formula ¬∀x p(x) is
the full space. On the other hand, the complement in H of every P(n)
is empty and the value of the formula at the right-hand side is the
union of empty sets.
4) Let Q be the whole space without the point (0, 0), and let P(n) be the
set of all points with distance from (0, 0) greater than 1
n (full space
without a disk). The union of all P(n)’s is equal to Q, and the value
of the left-hand side is Q ⇒Q = R2. But Q ⇒P(n) = P(n), for all n,
and the union of these sets (the value of the right-hand side) does not
contain (0, 0).
6) Take Q as above and let P(n) be the open disk centered at (0, 0), with
radius equal to 1
n. The value of the left-hand side is R2 because each
set Q ∪P(n) covers the whole space. The value of the right-hand side
is Q because the glb in H of all sets P(n) is empty. (Their intersection
is a one-point set which is not open.)
8) Let Q be empty, and let P(n) be as in (2). The value of the left-hand
side is the full space, because the glb of all sets P(n) is empty. But
the value of the right-hand side is empty.
10) Let P(n) be as in (2) and (8). Then ∼P(n) is empty and thus P(n) ∪
∼P(n) = P(n). The intersection of these sets has an empty interior,
thus the value of our formula is empty.
12) Take P(n) = A for even n and P(n) = B for odd n where A and B
are complementary open halves of the space. (Note that this formula
has a propositional counterpart: (p ∨q →p) ∨(p ∨q →q), which is
also not valid.)
Counterexamples in Kripke models
2) Hint: adopt the solution of Exercise 2.7.9(8).

248
Chapter 14. Solutions and hints to selected exercises
4) Hint: ﬁrst make a counterexample for the propositional version of this
law: (p →q ∨r) →(p →q) ∨(p →r).
6) The model consists of two states c ≤d, with Ac = {1} and Ad =
{1, 2}. Let c, 1 ⊩ϕ(x) and c ⊮ψ, and let d ⊩ψ and d, 1 ⊩ϕ(x), but
d, 2 ⊮ϕ(x). Then c ⊩∀x(ψ ∨ϕ(x)), because d, 2 ⊩ψ, but c ⊮ψ ∨
∀x ϕ(x), because d, 2 ⊮ϕ(x).
8) Generalize (2).
10) The set of states is {cn : n ∈N}, the domain for each state is the set of
integers, and ci, j ⊩ϕ if and only if j > i. Then c1 ⊮¬¬∀x(ϕ ∨¬ϕ).
Otherwise there would be ci with ci ⊩∀x(ϕ ∨¬ϕ), in particular
ci, i ⊩ϕ ∨¬ϕ, and this does not hold.
12) The model consists of two states c ≤d, with Ac = {1} and Ad =
{1, 2}. Let c, 1 ⊮ϕ(x), and let d, 1 ⊮ϕ(x) and d, 2 ⊩ϕ(x). Then
c ⊮∃x(∃y ϕ(y). →ϕ(x)), as otherwise c, 1 ⊩∃y ϕ(y). →ϕ(x), which
implies d, 1 ⊩ϕ(x).
Exercise 9.5.9
• ∃x(ϕ(x) →∀x ϕ(x))
Heyting counterexample as for Exercise 9.5.8(2). Kripke counterexample as
for Exercise 9.5.8(6).
• ∃x(ϕ(0) ∨ϕ(1) →ϕ(x))
Similar to Exercise 9.5.8(12).
• ∀x ¬¬ϕ(x). ↔¬¬∀x ϕ(x)
Heyting counterexample as for Exercise 9.5.8(2). Kripke counterexample as
for Exercise 9.5.8(10).
• ∃x ¬¬ϕ(x). ↔¬¬∃x ϕ(x).
Heyting counterexample as for Exercise 9.5.8(12). A Kripke counterexample
consists of three states c ≤d, e (with d, e incomparable), all with domain
{1, 2}. The forcing relation consists only of d, 1 ⊩ϕ(x) and e, 2 ⊩ϕ(x).
Exercise 9.5.10
The implication from right to left is always valid, so we only consider the
implication ∀x(ψ ∨ϕ(x)) →ψ ∨∀x ϕ(x). Assume that Ac = A for all c in
our model. Let c,⃗a ⊩∀x(ψ ∨ϕ(x)), and suppose that c,⃗a ⊮ψ. Thus for
all b ∈A it must be that c, b,⃗a ⊩ϕ(x). By monotonicity, c′, b,⃗a ⊩ϕ(x),
for all c′ ≥c. It follows that c,⃗a ⊩∀x ϕ(x).

249
Exercise 9.5.11
First observe that c′′, b,⃗a ⊮ϕ ∨¬ϕ always holds if c′′ is a maximal state.
Now suppose c,⃗a ⊩¬¬∀x(ϕ ∨¬ϕ) in a ﬁnite Kripke model. There is c′ ≥c
with c′,⃗a ⊩¬∀x(ϕ ∨¬ϕ). Take a maximal state c′′ ≥c′ and we obtain
c′′, b,⃗a ⊮ϕ ∨¬ϕ.
Exercise 10.7.11
Consider a logic where all formulas of the form ∀x ϕ are equivalent to true.
Then the other two axioms remain sound but ∀x ϕ(x). →ϕ(t) is not valid.
Exercise 11.8.1
• ∀x (¬(x = 0) →∃y(x = y + 1))
We use induction scheme applied to the formula ¬(x = 0) →∃y(x = y + 1).
This means we have to show that the following formulas are provable:
¬(0 = 0) →∃y(0 = y + 1);
∀x [(¬(x = 0) →∃y(x = y + 1)) →¬(x + 1 = 0) →∃y(x + 1 = y + 1)],
and then it suﬃces to apply modus ponens twice. The ﬁrst formula is proven
with help of the ﬁrst axiom, which can be generalized to 0 = 0. The second
formula is easily derived from ∃y(x + 1 = y + 1), and this is a consequence
of y + 1 = y + 1 (ﬁrst axiom).
• ∀x∀y∀z (x = y →y = z →x = z);
This is an instance of the third axiom.
• ∀x∀y∀z ((x + y) + z = x + (y + z))
We prove ∀z ((x+y)+z = x+(y+z)) by induction and then generalize over
x and y. The ﬁrst step is (x+y)+0 = x+(y +0) and is an easy application
of the axiom ∀x (x + 0 = x) and the transitivity of equality. Then we must
derive (x+y)+(z+1) = x+(y+(z+1)) from (x+y)+z = x+(y+z). With
the axiom ∀x∀y (x + (y + 1) = (x + y) + 1) and the transitivity of equality,
we can formalize the calculation (x + y) + (z + 1) = ((x + y) + z) + 1 =
(x + (y + z)) + 1 = x + ((y + z) + 1) = x + (y + (z + 1)).
• ∀x∀y (x + y = y + x)
Hint: First prove by induction that ∀y (0 + y = y + 0). This is the base
of the main induction (with respect to x). The induction step is to derive
∀y ((x + 1) + y = y + (x + 1)) from ∀y (x + y = y + x). This also goes by
induction (with respect to y). Have fun!

250
Chapter 14. Solutions and hints to selected exercises
Exercise 11.8.3
Suppose a function f is representable by a formula ϕ. Then f is strongly
representable by the formula
ψ(⃗x, y) = (∃!z ϕ(⃗x, z). ∧ϕ(⃗x, y)) ∨(¬∃!z ϕ(⃗x, z). ∧y = 0).
We show PA ⊢∀⃗x ∃!y ψ(⃗x, y). (Then ψ implies ϕ and representability follows
easily.) Begin with PA ⊢ϑ ∨¬ϑ, where ϑ = ∃!z ϕ(⃗x, z). Then one can show
that PA ⊢ϑ →∃!y(ϑ ∧ϕ(⃗x, y)) and PA ⊢¬ϑ →∃!y(¬ϑ ∧y = 0). Thus
PA ⊢∃!y(ϑ∧ϕ(⃗x, y))∨∃!y(¬ϑ∧y = 0) and it remains to permute ∨with ∃!y.
Exercise 11.8.8
By translation, we have HA ⊢¬¬ϱ (note that tf(⃗x, y) = 0 is an atomic
formula), and thus HA ⊢(ϱϱ →ϱ) →ϱ. Now, the formula ϱϱ is equivalent
to ϱ (because ⊢∃y(ψ ∨∃yψ) ↔∃yψ) and thus HA ⊢(ϱ →ϱ) →ϱ. Then
HA ⊢ϱ, because ⊢ϱ →ϱ.
Exercise 12.7.1 (Hint)
Cf. Exercise 9.5.10.
Exercise 12.7.2
For a model with a constant domain D we have
c, v ⊩∀p ϕ
iﬀ
c, vx
p ⊩ϕ, for all x ∈D.
(One does not need to refer to c′ ≥c because of monotonicity.)
Exercise 12.7.3
This exercise contains a little trap: the notion of a complete model refers
to all formulas, including those containing ∨, ∧and ∃. But one can also
consider Kripke models for the language containing only →and ∀, satisfying
the appropriate (weaker) notion of completeness. Then the semantics of the
formula
τ + σ := ∀α((τ →α) →(σ →α) →α)
does not have to coincide with the expected semantics of τ ∨σ. Indeed,
consider a model of three states c0, c1 and c2 with a constant domain D =
{{ }, {c1}, {c2}, {c0, c1, c2}} and with c1 ⊩p and c2 ⊩q, and no other forcing.
This model is complete with respect to →and ∀, and we have c0 ⊩p + q.
The case of ∧is diﬀerent: if a model is complete with respect to →
and ∀, then c ⊩∀α((τ →σ →α) →α) iﬀc ⊩τ and c ⊩σ.

251
Exercise 12.7.13
In the context {y : ⊥, z : ∀γ(α →γ →β)} one can derive zyz : β. Now
consider the context {y : ⊥, x : ∀αβ(∀γ(α →γ →β). →β) and derive
xx : ⊥. Thus our term has type ∀αβ(∀γ(α →γ →β). →β). →⊥in the
context {y : ⊥}.
Exercise 12.7.15
Think of types as ﬁnite binary trees with leaves labeled by type variables
and internal nodes corresponding to arrows). Some of the internal nodes are
labeled by quantiﬁers.
Suppose that xx is typable in an environment containing the declara-
tion (x : τ). The type τ must begin with one or more universal quantiﬁers,
and one of these quantiﬁers must bind a type variable occurring at the very
end of the leftmost path of the type. (Otherwise self-application is impossi-
ble.) Thus, a type assigned to λx. xx must have the form (∀⃗ατ) →σ with
one of the ⃗α’s at the end of the leftmost path. This observation applies to
both copies of λx. xx which results in that two diﬀerent quantiﬁers attempt
to bind the same variable — a contradiction.
Exercise 12.7.16 (After [111])
The type σ assigned to K must have the form:
σ = ∀⃗α(τ →∀⃗β(ρ →τ ′)),
where τ ′ is an instance of τ. The rightmost path of τ ′ must be at least as
long as the rightmost path in τ. In addition, one of the variables ⃗α, say α,
must occur at the end of the rightmost path in τ. The same α must remain
at the end of the rightmost path in the instance τ ′, at the same depth.
The type of the second c2 in c2c2K must have the form ∀⃗γ(σ0 →ϱ),
where σ can be obtained from σ0 by instantiating ⃗γ. It begins with ∀⃗α and
has occurrences of α at the same places as σ does. In particular there is an
occurrence of α at some depth n at the rightmost path of the left subtree
of σ0 and at depth n + 1 at the rightmost path of the right subtree of σ0.
Now, σ0 is the type of f in f(fx) and ϱ is the type of λx. f(fx). No matter
what is the type of x, we can note that the asymetry of σ0 is doubled in ϱ,
and thus the rightmost path in ϱ must be of length at least n + 3. Although
∀⃗γ(σ0 →ϱ) may still be a good type for c2, a term of this type cannot
be composed with itself, as the positions of α cannot be changed by just
instantiating ⃗γ.
Exercise 12.7.18(12.48)
An inﬁnite sequence of Church-style beta reductions Mi →β Mi+1 erases to
an inﬁnite sequence of Curry-style terms |Mi|, where at each step we either

252
Chapter 14. Solutions and hints to selected exercises
have |Mi| →β |Mi+1| or |Mi| = |Mi+1|. The latter case must hold for almost
all i, and is only possible when almost all steps Mi →β Mi+1 are caused by
type reductions of the form (Λα.M)τ −→β M[α := τ]. But each of these
steps decreases the number of Λ’s in our term, so this process must also
terminate.

Bibliography
[1] A.R. Anderson and N.A. Belnap. Entailment. The Logic of Relevance
and Necessity, volume I. Princeton University Press, 1975.
[2] A.R. Anderson, N.A. Belnap, and J.M. Dunn. Entailment. The Logic
of Relevance and Necessity, volume II. Princeton University Press,
1992.
[3] T. Arts. Embedding ﬁrst order predicate logic in second order propo-
sitional logic. Master’s thesis, Katholieke Universiteit Nijmegen, 1992.
[4] T. Arts and W. Dekkers.
Embedding ﬁrst order predicate logic in
second order propositional logic. Technical Report 93-02, Katholieke
Universiteit Nijmegen, 1993.
[5] S. van Bakel, L. Liquori, S Ronchi della Rocca, and P. Urzyczyn.
Comparing cubes of typed and type assignment systems. Annals of
Pure and Applied Logic, 86:267–303, 1997.
[6] F. Barbanera, M. Dezani-Ciancaglini, and U. de’ Liguoro. Intersection
and union types: syntax and semantics. Information and Computa-
tion, 119:202–230, 1995.
[7] H.P. Barendregt. The Lambda Calculus: Its Syntax and Semantics.
North-Holland, second, revised edition, 1984.
[8] H.P. Barendregt. Lambda calculi with types. In S. Abramsky, D.M.
Gabbay, and T.S.E. Maibaum, editors, Handbook of Logic in Computer
Science, volume II, pages 117–309. Oxford University Press, 1992.
[9] H.P. Barendregt, M. Bunder, and W. Dekkers. Completeness of some
systems of illative combinatory logic for ﬁrst-order propositional and
predicate calculus. To appear in Archive f¨ur Mathematische Logik,
1996.
[10] H.P. Barendregt, M. Bunder, and W. Dekkers. Completeness of the
propositions-as-types interpretation of intuitionistic logic into illative
combinatory logic. To appear in the Journal of Symbolic Logic, 1996.
253

254
Bibliography
[11] J. Barwise. Handbook of Mathematical Logic. North-Holland, 1977.
[12] S. Berardi. Type Dependence and Constructive Mathematics. PhD
thesis, Universita di Torino, 1990.
[13] M. Bezem and J. Springintveld. A simple proof of the undecidability
of inhabitation in λP. Journal of Functional Programming, 6(5):757–
761, 1996.
[14] R. Bloo and K. Rose. Preservation of strong normalisation in named
lambda calculi with explicit substitution and garbage collection. In
CSN ’95 - Computer Science in the Netherlands, pages 62–72, 1995.
[15] V. Breazu Tannen, D. Kesner, and L. Puel. A typed pattern calculus.
In Logic in Computer Science, pages 262–274, 1993.
[16] S. Broda and L. Damas. On principal types of stratiﬁed combinators.
Technical Report DCC-97-4, Departamento de Cincia de Computa-
dores, Universidade do Porto, 1997.
[17] L.E.J. Brouwer. Intu¨ıtionistische splitsing van mathematische grond-
begrippen. Nederl. Akad. Wetensch. Verslagen, 32:877–880, 1923.
[18] A. Church. A formulation of the simple theory of types. Journal of
Symbolic Logic, 5:56–68, 1940.
[19] R. Constable. Constructive mathematics and automatic program writ-
ers. In Proceddings of the IFIP Congress, pages 229–233, Ljubljana,
1971.
[20] R. Constable. Programs as proofs: A synopsis. Information Processing
Letters, 16(3):105–112, 1983.
[21] H.B. Curry. Grundlagen der Kombinatorischen Logik. teil I. American
Journal of Mathematics, LII:509–536, 1930.
[22] H.B. Curry. Grundlagen der Kombinatorischen Logik. teil II. Ameri-
can Journal of Mathematics, LII:789–834, 1930.
[23] H.B. Curry. Functionality in combinatory logic. Proceedings of the
National Academy of Science USA, 20:584–590, 1934.
[24] H.B. Curry and R. Feys. Combinatory Logic. North-Holland, 1958.
[25] H.B. Curry, J.R. Hindley, and J.P. Seldin.
Combinatory Logic II,
volume 65 of Studies in Logic and the Foundations of Mathematics.
North-Holland, 1972.
[26] D. van Dalen. Intuitionistic logic. In Handbook of Philosophical Logic,
volume III, pages 225–339. Reidel Publ. Co., 1986.

Bibliography
255
[27] L. Damas and R. Milner. Principal type schemes for functional pro-
grams. In Conference Record of the Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages 207–212,
Jan. 1982.
[28] N.G. de Bruijn. A survey of the project AUTOMATH. In Seldin and
Hindley [98], pages 579–606.
[29] A. Degtyarev and A. Voronkov. Decidability problems for the prenex
fragment of intuitionistic logic. In Logic in Computer Science, pages
503–512, 1996.
[30] W. Dekkers.
Inhabitation of types in the simply typed λ-calculus.
Information and Computation, 119:14–17, 1995.
[31] G. Dowek. The undecidability of typability in the lambda-pi-calculus.
In M. Bezem and J.F. Groote, editors, Typed Lambda Calculus and
Applications, volume 664 of Lecture Notes in Computer Science, pages
139–145. Springer-Verlag, 1993.
[32] A. Dragalin. A completeness theorem for higher-order intuitionistic
logic. an intuitionistic proof. In D. Skordev, editor, Mathematical Logic
and its Applications, pages 107–124. Plenum Press, New York, 1987.
[33] C. Dwork, P.C. Kanellakis, and J.C. Mitchell. On the sequential nature
of uniﬁcation. Journal of Logic Programming, 1:35–50, 1984.
[34] J.E. Fenstad, editor. Proc. Second Scandinavian Logic Symposium.
North-Holland, Amsterdam, 1971.
[35] S. Fortune, D. Leivant, and M. O’Donnell.
The expresssiveness of
simple and second-order type structures. Journal of the Association
for Computing Machinery, 30:151–185, 1983.
[36] D.M. Gabbay. On 2nd order intuitionistic propositional calculus with
full comprehension. Archiv f¨ur Mathematische Logik und Grundlagen-
forschung, 16:177–186, 1974.
[37] D.M. Gabbay.
Semantical Investigations in Heyting’s Intuitionistic
Logic. D. Reidel Publ. Co, 1981.
[38] J.H. Gallier. Constructive logics, part I: A tutorial on proof systems
and typed λ-calculi. Theoretical Computer Science, 110:249–339, 1993.
[39] G. Gentzen. Untersuchungen ¨uber das logische Schliessen. Mathema-
tische Zeitschrift, 39:176–210, 405–431, 1935.

256
Bibliography
[40] J.H. Geuvers. Conservativity between logics and typed lambda-calculi.
In H. Barendregt and T. Nipkow, editors, Types for Proofs and Pro-
grams, volume 806 of Lecture Notes in Computer Science, pages 79–
107. Springer-Verlag, 1993.
[41] J.H. Geuvers. Logics and Type Systems. PhD thesis, University of
Nijmegen, 1993.
[42] J.H. Geuvers and M.J. Nederhof.
A modular proof of strong nor-
malization for the calculus of constructions.
Journal of Functional
Programming, 1(2):155–189, 1991.
[43] P. Giannini and S. Ronchi Della Rocca. Characterization of typings
in polymorphic type discipline. In Proc. Symp. on Logic in Computer
Sciene, pages 61–70. Computer Society Press, 1988.
[44] J.-Y. Girard. Interpr´etation fonctionelle et ´elimination des coupures
dans l’arithm´etique d’ordre sup´erieur. Th`ese d’´Etat, Universit´e Paris
VII, 1972.
[45] J.-Y. Girard. The system F of variable types, ﬁfteen years later. The-
oretical Computer Science, 45:159–192, 1986.
[46] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types, volume 7
of Cambridge Tracts in Theoretical Computer Science.
Cambridge
University Press, 1989.
[47] C.A. Goad. Monadic inﬁnitary propositional logic. Reports on Math-
ematical Logic, 10, 1978.
[48] K. G¨odel. ¨uber eine bisher noch nicht ben¨untze erweiterung des ﬁniten
standpunktes. Dialectica, 12:280–287, 1980. (English translation: J.
Philos. Logic, 9:133–142, 1980.).
[49] T.G. Griﬃn. A formulae-as-types notion of control. In Conference
Record of the Annual ACM SIGPLAN-SIGACT Symposium on Prin-
ciples of Programming Languages, pages 47–58. ACM Press, 1990.
[50] K. Grue. Map theory. Theoretical Computer Science, 102:1–133, 1992.
[51] R. Harper, F. Honsell, and F. Plotkin. A framework for deﬁning logics.
Journal of the Association for Computing Machinery, 40(1):143–184,
1993.
[52] H. Herbelin. A λ-calculus structure isomorphic to Gentzen-style se-
quent calculus structure. In Computer Science Logic 1994, volume 933
of Lecture Notes in Computer Science, pages 61–75. Springer-Verlag,
1995.

Bibliography
257
[53] A. Heyting. Mathematische Grundlagenforschung. Intuitionismus. Be-
weisteorie. Springer, 1934.
[54] J.R. Hindley.
Basic Simple Type Theory, volume 42 of Cambridge
Tracts in Theoretical Computer Science. Cambridge University Press,
1997.
[55] J.R. Hindley and J.P. Seldin.
Introduction to Combinators and λ-
calculus. Cambridge University Press, 1986.
[56] S. Hirokawa. Principal types of BCK-lambda terms. Theoretical Com-
puter Science, 107:253–276, 1993.
[57] J. E. Hopcroft and J. D. Ullman. Introduction to Automata Theory,
Languages and Computation. Addison-Wesley, 1979.
[58] W. Howard. The formulae-as-types notion of construction. In Seldin
and Hindley [98], pages 479–490.
[59] G. Huet and G. Plotkin. Logical Frameworks. Cambridge University
Press, 1991.
[60] S.C. Kleene. On the interpretation of intuitionistic number theory.
Journal of Symbolic Logic, 10:109–124, 1945.
[61] S.C. Kleene. Introduction to Metamathematics. Van Nostrand, 1952.
[62] S.C. Kleene. Origins of recursive function theory. Annals of the History
of Computing, 3(1):52–67, 1981.
[63] A. Kolmogorov. Zur Deutung der intuitionistischen Logik. Mathema-
tische Zeitschrift, 35:58–65, 1932.
[64] G. Kreisel. Monadic operators deﬁned by means of propositional quan-
tiﬁcation in intuitionistic logic. Reports on Mathematical Logic, 12:9–
15, 1981.
[65] P. Kremer. On the complexity of propositional quantiﬁcation in intu-
itionistic logic. Journal of Symbolic Logic, 62(2):529–544, 1997.
[66] J.-L. Krivine. Lambda-Calculus, Types and Models. Ellis Horwood Se-
ries in Computers and their Applications. Masson and Ellis Horwood,
English Edition, 1993.
[67] M. L¨ob. Embedding ﬁrst order predicate logic in fragments of intu-
itionistic logic. Journal of Symbolic Logic, 41(4):705–718, 1976.
[68] H.G. Mairson. A simple proof of a theorem of Statman. Theoretical
Computer Science, 103(2):387–394, 1992.

258
Bibliography
[69] S.D. Marlow. Deforestation for Higher-Order Functional Languages.
PhD thesis, University of Glasgow, 1996.
[70] E. Mendelson.
Introduction to Mathematical Logic.
Wadswoth &
Brooks/Cole Advanced Books and Software, third edition, 1987.
[71] E. Mendelson. Introduction to Mathematical Logic. Chapman & Hall,
London, fourth edition, 1997.
[72] R. Milner. A theory of type polymorphism in programming. Journal
of Computer and System Sciences, 17:348–375, 1978.
[73] J. Mitchell. Polymorphic type inference and containment. Information
and Control, 76:211–249, 1988.
[74] J.C. Mitchell. Foundations for Programming Languages. MIT Press,
Cambridge, 1996.
[75] C.R. Murthy. Extracting Constructive Contents from Classical Proofs.
PhD thesis, Cornell University, 1990.
[76] C.R. Murthy. Control operators, hierachies, and pseudo-classical type
systems: A-translation at work.
In ACM SIGPLAN Workshop on
Continuations, 1992.
[77] B. Norstr¨om, K. Petersson, and J.M. Smith. Programming in Martin-
L¨of’s Type Theory, An Introduction. Oxford University Press, 1990.
[78] C.-H. L. Ong. A semantic view of classical proofs: Type-theoretic,
categorical, and denotational characterizations. In Logic in Computer
Science, pages 230–241, 1996.
[79] M. Parigot. Free deduction: An analysis of “computations” in classical
logic. In Second Russian Conference on Logic programming, volume
592 of Lecture Notes in Artiﬁcial Intelligence, pages 361–380. Springer-
Verlag, 1991.
[80] M. Parigot.
λµ-calculus: An algorithmic interpretation of classical
natural deduction. In International Conference on Logic Programming
and Automated Reasoning, volume 624 of Lecture Notes in Computer
Science, pages 190–201. Springer-Verlag, 1992.
[81] M. Parigot. Classical proofs as programs. In Kurt G¨odel Colloquium,
volume 713 of Lecture Notes in Computer Science, pages 263–276.
Springer-Verlag, 1993.
[82] M. Parigot. Strong normalization for second order classical natural
deduction. In Logic in Computer Science, 1993.

Bibliography
259
[83] G. Plotkin. Call-by-name, call-by-value and the λ-calculus. Theoretical
Computer Science, 1:125–159, 1975.
[84] G. Pottinger.
Normalization as a homomorphic image of cut-
elimination. Annals of Mathematical Logic, 12:323–357, 1977.
[85] D. Prawitz. Natural Deduction: A Proof Theoretical Study. Almquist
& Wiksell, 1965.
[86] D. Prawitz.
Some results for intuitionistic logic with second order
quantiﬁcation. pages 259–270. North-Holland, Amsterdam, 1970.
[87] D. Prawitz. Ideas and results of proof theory. In Fenstad [34], pages
235–307.
[88] H. Rasiowa and R. Sikorski. The Mathematics of Metamathematics.
PWN, Warsaw, 1963.
[89] N.J. Rehof and M.H. Sørensen. The λ∆calculus. In M. Hagiya and
J. Mitchell, editors, Theoretical Aspects of Computer Software, volume
789 of Lecture Notes in Computer Science, pages 516–542. Springer-
Verlag, 1994.
[90] J. Reynolds. Towards a theory of type structure. In B Robinet, edi-
tor, Proceedings of the Programming Symposium, volume 19 of Lecture
Notes in Computer Science, pages 408–425. Springer-Verlag, 1974.
[91] A. Rezus. Classical proofs: Lambda calculus methods in elementary
proof theory, 1991. Manuscript.
[92] A. Rezus. Beyond BHK, 1993. Manuscript.
[93] J.A. Robinson. A machine-oriented logic based on the resolution prin-
ciple. Journal of the Association for Computing Machinery, 12(1):23–
41, 1965.
[94] J.B. Rosser. Highlights of the history of the lambda-calculus. Annals
of the History of Computing, 6(4):337–349, 1984.
[95] A. Schubert. Second-order uniﬁcation and type inference for church-
style polymorphism. In Proc. 25th ACM Symposium on Principles of
Programming Languages, pages 233–244, January 1998.
[96] H. Schwichtenberg. Elimination of higher type levels in deﬁnitions of
primitive recursive function by means of transﬁnite recursion. In H.E.
Rose, editor, Logic Colloquium ’73, pages 279–303. North-Holland,
1975.

260
Bibliography
[97] H. Schwichtenberg. Deﬁnierbare Funktionen im Lambda-Kalkul mit
Typen. Archiv Logik Grundlagenforsch., 17:113–114, 1976.
[98] J.P. Seldin and J.R. Hindley, editors.
To H.B. Curry: Essays on
Combinatory Logic, Lambda Calculus and Formalism. Academic Press
Limited, 1980.
[99] D. Skvortsov. Non-axiomatizable second-order intuitionistic proposi-
tional logic. Annals of Pure and Applied Logic, 86:33–46, 1997.
[100] S.K. Sobolev. On the intuitionistic propositional calculus with quan-
tiﬁers (russian). Mat. Zamietki AN SSSR, 22(1):69–76, 1977.
[101] M.H. Sørensen. Normalization in λ-Calculus and Type Theory. PhD
thesis, Department of Computer Science, University of Copenhagen,
1997. Available as DIKU Rapport 97/27.
[102] M.H. Sørensen.
Strong normalization from weak normalization in
typed λ-calculi. Information and Computation, 133(1):35–71, 1997.
[103] R. Statman. Intuitionistic propositional logic is polynomial-space com-
plete. Theoretical Computer Science, 9:67–72, 1979.
[104] W.W. Tait. Intensional interpretations of functionals of ﬁnite type I.
Journal of Symbolic Logic, 32(2):190–212, 1967.
[105] W.W. Tait. A realizability interpretation of the theory of species. In
R. Parikh, editor, Logic Colloquium, volume 453 of Lecture Notes in
Mathematics, pages 240–251. Springer-Verlag, 1975.
[106] A.S. Troelstra. Metamathematical Investigation of Intuitionistic Arith-
metic and Analysis, volume 344 of Lecture Notes in Mathematics.
Springer-Verlag, 1973.
[107] A.S. Troelstra and D. van Dalen.
Constructivism in Mathematics,
An Introduction, Volume I, volume 121 of Studies in Logic and the
Foundations of Mathematics. North-Holland, 1988.
[108] A.S. Troelstra and D. van Dalen.
Constructivism in Mathematics,
An Introduction, Volume II, volume 123 of Studies in Logic and the
Foundations of Mathematics. North-Holland, 1988.
[109] A.S. Troelstra and H. Schwichtenberg. Basic Proof Theory, volume 43
of Cambridge Tracts in Theoretical Computer Science.
Cambridge
University Press, 1996.
[110] J. Tyszkiewicz. ZÃlo˙zono´s´c problemu wyprowadzania typ´ow w rachunku
lambda. Master’s thesis, Warsaw, 1988.

Bibliography
261
[111] P. Urzyczyn. Positive recursive type assigment. In J. Wiedermann and
P. H´ajek, editors, Mathematical Foundations of Computer Science,
volume 969 of Lecture Notes in Computer Science, pages 382–391.
Springer-Verlag, 1995.
[112] P. Urzyczyn. Type inhabitation in typed lambda calculi (a syntactic
approach). In de Groote P. and J.R. Hindley, editors, Typed Lambda
Calculus and Applications, volume 1210 of Lecture Notes in Computer
Science, pages 373–389. Springer-Verlag, 1995.
[113] R. Vestergaard. The cut rule and explicit substitutions. Manuscript,
1998.
[114] A. Voronkov. Proof search in intuitionistic logic with equality or back
to simultaneous rigid E-uniﬁcation.
In M.A. Mc Robbie and J.K.
Slaney, editors, CADE-13, volume 1104 of Lecture Notes in Computer
Science, pages 32–46. Springer-Verlag, 1996.
[115] P.L. Wadler. Deforestation: Transforming programs to eliminate in-
termediate trees. Theoretical Computer Science, 73:231–248, 1990.
[116] P.L. Wadler.
A Curry-Howard isomorphism for sequent calculus.
Manuscript, 1993.
[117] J. Wells. Typability and type checking in the second-order λ-calculus
are equivalent and undecidable. In Proc. Symp. on Logic in Computer
Sciene, pages 176–185. IEEE, Computer Society, Computer Society
Press, 1994.
[118] J.I. Zucker. Correspondence between cut-elimination and normaliza-
tion. Annals of Mathematical Logic, 7:1–156, 1974.

